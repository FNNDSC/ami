(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.AMI = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
// jshint ignore: start

/* -*- Mode: Java; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- /
 /* vim: set shiftwidth=2 tabstop=2 autoindent cindent expandtab: */
/*
 Copyright 2011 notmasteryet

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
 */

// - The JPEG specification can be found in the ITU CCITT Recommendation T.81
//   (www.w3.org/Graphics/JPEG/itu-t81.pdf)
// - The JFIF specification can be found in the JPEG File Interchange Format
//   (www.w3.org/Graphics/JPEG/jfif3.pdf)
// - The Adobe Application-Specific JPEG markers in the Supporting the DCT Filters
//   in PostScript Level 2, Technical Note #5116
//   (partners.adobe.com/public/developer/en/ps/sdk/5116.DCT_Filter.pdf)

var ColorSpace = {Unkown: 0, Grayscale: 1, AdobeRGB: 2, RGB: 3, CYMK: 4};
var JpegImage = (function jpegImage() {
  "use strict";
  var dctZigZag = new Int32Array([
    0,
    1, 8,
    16, 9, 2,
    3, 10, 17, 24,
    32, 25, 18, 11, 4,
    5, 12, 19, 26, 33, 40,
    48, 41, 34, 27, 20, 13, 6,
    7, 14, 21, 28, 35, 42, 49, 56,
    57, 50, 43, 36, 29, 22, 15,
    23, 30, 37, 44, 51, 58,
    59, 52, 45, 38, 31,
    39, 46, 53, 60,
    61, 54, 47,
    55, 62,
    63
  ]);

  var dctCos1 = 4017;   // cos(pi/16)
  var dctSin1 = 799;   // sin(pi/16)
  var dctCos3 = 3406;   // cos(3*pi/16)
  var dctSin3 = 2276;   // sin(3*pi/16)
  var dctCos6 = 1567;   // cos(6*pi/16)
  var dctSin6 = 3784;   // sin(6*pi/16)
  var dctSqrt2 = 5793;   // sqrt(2)
  var dctSqrt1d2 = 2896;  // sqrt(2) / 2

  function constructor() {
  }

  function buildHuffmanTable(codeLengths, values) {
    var k = 0, code = [], i, j, length = 16;
    while (length > 0 && !codeLengths[length - 1])
      length--;
    code.push({children: [], index: 0});
    var p = code[0], q;
    for (i = 0; i < length; i++) {
      for (j = 0; j < codeLengths[i]; j++) {
        p = code.pop();
        p.children[p.index] = values[k];
        while (p.index > 0) {
          p = code.pop();
        }
        p.index++;
        code.push(p);
        while (code.length <= i) {
          code.push(q = {children: [], index: 0});
          p.children[p.index] = q.children;
          p = q;
        }
        k++;
      }
      if (i + 1 < length) {
        // p here points to last code
        code.push(q = {children: [], index: 0});
        p.children[p.index] = q.children;
        p = q;
      }
    }
    return code[0].children;
  }

  function getBlockBufferOffset(component, row, col) {
    return 64 * ((component.blocksPerLine + 1) * row + col);
  }

  function decodeScan(data, offset,
                      frame, components, resetInterval,
                      spectralStart, spectralEnd,
                      successivePrev, successive) {
    var precision = frame.precision;
    var samplesPerLine = frame.samplesPerLine;
    var scanLines = frame.scanLines;
    var mcusPerLine = frame.mcusPerLine;
    var progressive = frame.progressive;
    var maxH = frame.maxH, maxV = frame.maxV;

    var startOffset = offset, bitsData = 0, bitsCount = 0;

    function readBit() {
      if (bitsCount > 0) {
        bitsCount--;
        return (bitsData >> bitsCount) & 1;
      }
      bitsData = data[offset++];
      if (bitsData == 0xFF) {
        var nextByte = data[offset++];
        if (nextByte) {
          throw "unexpected marker: " + ((bitsData << 8) | nextByte).toString(16);
        }
        // unstuff 0
      }
      bitsCount = 7;
      return bitsData >>> 7;
    }

    function decodeHuffman(tree) {
      var node = tree;
      var bit;
      while ((bit = readBit()) !== null) {
        node = node[bit];
        if (typeof node === 'number')
          return node;
        if (typeof node !== 'object')
          throw "invalid huffman sequence";
      }
      return null;
    }

    function receive(length) {
      var n = 0;
      while (length > 0) {
        var bit = readBit();
        if (bit === null)
          return;
        n = (n << 1) | bit;
        length--;
      }
      return n;
    }

    function receiveAndExtend(length) {
      var n = receive(length);
      if (n >= 1 << (length - 1))
        return n;
      return n + (-1 << length) + 1;
    }

    function decodeBaseline(component, offset) {
      var t = decodeHuffman(component.huffmanTableDC);
      var diff = t === 0 ? 0 : receiveAndExtend(t);
      component.blockData[offset] = (component.pred += diff);
      var k = 1;
      while (k < 64) {
        var rs = decodeHuffman(component.huffmanTableAC);
        var s = rs & 15, r = rs >> 4;
        if (s === 0) {
          if (r < 15)
            break;
          k += 16;
          continue;
        }
        k += r;
        var z = dctZigZag[k];
        component.blockData[offset + z] = receiveAndExtend(s);
        k++;
      }
    }

    function decodeDCFirst(component, offset) {
      var t = decodeHuffman(component.huffmanTableDC);
      var diff = t === 0 ? 0 : (receiveAndExtend(t) << successive);
      component.blockData[offset] = (component.pred += diff);
    }

    function decodeDCSuccessive(component, offset) {
      component.blockData[offset] |= readBit() << successive;
    }

    var eobrun = 0;
    function decodeACFirst(component, offset) {
      if (eobrun > 0) {
        eobrun--;
        return;
      }
      var k = spectralStart, e = spectralEnd;
      while (k <= e) {
        var rs = decodeHuffman(component.huffmanTableAC);
        var s = rs & 15, r = rs >> 4;
        if (s === 0) {
          if (r < 15) {
            eobrun = receive(r) + (1 << r) - 1;
            break;
          }
          k += 16;
          continue;
        }
        k += r;
        var z = dctZigZag[k];
        component.blockData[offset + z] = receiveAndExtend(s) * (1 << successive);
        k++;
      }
    }

    var successiveACState = 0, successiveACNextValue;
    function decodeACSuccessive(component, offset) {
      var k = spectralStart, e = spectralEnd, r = 0;
      while (k <= e) {
        var z = dctZigZag[k];
        switch (successiveACState) {
          case 0: // initial state
            var rs = decodeHuffman(component.huffmanTableAC);
            var s = rs & 15;
            r = rs >> 4;
            if (s === 0) {
              if (r < 15) {
                eobrun = receive(r) + (1 << r);
                successiveACState = 4;
              } else {
                r = 16;
                successiveACState = 1;
              }
            } else {
              if (s !== 1)
                throw "invalid ACn encoding";
              successiveACNextValue = receiveAndExtend(s);
              successiveACState = r ? 2 : 3;
            }
            continue;
          case 1: // skipping r zero items
          case 2:
            if (component.blockData[offset + z]) {
              component.blockData[offset + z] += (readBit() << successive);
            } else {
              r--;
              if (r === 0)
                successiveACState = successiveACState == 2 ? 3 : 0;
            }
            break;
          case 3: // set value for a zero item
            if (component.blockData[offset + z]) {
              component.blockData[offset + z] += (readBit() << successive);
            } else {
              component.blockData[offset + z] = successiveACNextValue << successive;
              successiveACState = 0;
            }
            break;
          case 4: // eob
            if (component.blockData[offset + z]) {
              component.blockData[offset + z] += (readBit() << successive);
            }
            break;
        }
        k++;
      }
      if (successiveACState === 4) {
        eobrun--;
        if (eobrun === 0)
          successiveACState = 0;
      }
    }

    function decodeMcu(component, decode, mcu, row, col) {
      var mcuRow = (mcu / mcusPerLine) | 0;
      var mcuCol = mcu % mcusPerLine;
      var blockRow = mcuRow * component.v + row;
      var blockCol = mcuCol * component.h + col;
      var offset = getBlockBufferOffset(component, blockRow, blockCol);
      decode(component, offset);
    }

    function decodeBlock(component, decode, mcu) {
      var blockRow = (mcu / component.blocksPerLine) | 0;
      var blockCol = mcu % component.blocksPerLine;
      var offset = getBlockBufferOffset(component, blockRow, blockCol);
      decode(component, offset);
    }

    var componentsLength = components.length;
    var component, i, j, k, n;
    var decodeFn;
    if (progressive) {
      if (spectralStart === 0)
        decodeFn = successivePrev === 0 ? decodeDCFirst : decodeDCSuccessive;
      else
        decodeFn = successivePrev === 0 ? decodeACFirst : decodeACSuccessive;
    } else {
      decodeFn = decodeBaseline;
    }

    var mcu = 0, marker;
    var mcuExpected;
    if (componentsLength == 1) {
      mcuExpected = components[0].blocksPerLine * components[0].blocksPerColumn;
    } else {
      mcuExpected = mcusPerLine * frame.mcusPerColumn;
    }
    if (!resetInterval) {
      resetInterval = mcuExpected;
    }

    var h, v;
    while (mcu < mcuExpected) {
      // reset interval stuff
      for (i = 0; i < componentsLength; i++) {
        components[i].pred = 0;
      }
      eobrun = 0;

      if (componentsLength == 1) {
        component = components[0];
        for (n = 0; n < resetInterval; n++) {
          decodeBlock(component, decodeFn, mcu);
          mcu++;
        }
      } else {
        for (n = 0; n < resetInterval; n++) {
          for (i = 0; i < componentsLength; i++) {
            component = components[i];
            h = component.h;
            v = component.v;
            for (j = 0; j < v; j++) {
              for (k = 0; k < h; k++) {
                decodeMcu(component, decodeFn, mcu, j, k);
              }
            }
          }
          mcu++;
        }
      }

      // find marker
      bitsCount = 0;
      marker = (data[offset] << 8) | data[offset + 1];
      if (marker <= 0xFF00) {
        throw "marker was not found";
      }

      if (marker >= 0xFFD0 && marker <= 0xFFD7) { // RSTx
        offset += 2;
      } else {
        break;
      }
    }

    return offset - startOffset;
  }

  // A port of poppler's IDCT method which in turn is taken from:
  //   Christoph Loeffler, Adriaan Ligtenberg, George S. Moschytz,
  //   "Practical Fast 1-D DCT Algorithms with 11 Multiplications",
  //   IEEE Intl. Conf. on Acoustics, Speech & Signal Processing, 1989,
  //   988-991.
  function quantizeAndInverse(component, blockBufferOffset, p) {
    var qt = component.quantizationTable;
    var v0, v1, v2, v3, v4, v5, v6, v7, t;
    var i;

    // dequant
    for (i = 0; i < 64; i++) {
      p[i] = component.blockData[blockBufferOffset + i] * qt[i];
    }

    // inverse DCT on rows
    for (i = 0; i < 8; ++i) {
      var row = 8 * i;

      // check for all-zero AC coefficients
      if (p[1 + row] === 0 && p[2 + row] === 0 && p[3 + row] === 0 &&
        p[4 + row] === 0 && p[5 + row] === 0 && p[6 + row] === 0 &&
        p[7 + row] === 0) {
        t = (dctSqrt2 * p[0 + row] + 512) >> 10;
        p[0 + row] = t;
        p[1 + row] = t;
        p[2 + row] = t;
        p[3 + row] = t;
        p[4 + row] = t;
        p[5 + row] = t;
        p[6 + row] = t;
        p[7 + row] = t;
        continue;
      }

      // stage 4
      v0 = (dctSqrt2 * p[0 + row] + 128) >> 8;
      v1 = (dctSqrt2 * p[4 + row] + 128) >> 8;
      v2 = p[2 + row];
      v3 = p[6 + row];
      v4 = (dctSqrt1d2 * (p[1 + row] - p[7 + row]) + 128) >> 8;
      v7 = (dctSqrt1d2 * (p[1 + row] + p[7 + row]) + 128) >> 8;
      v5 = p[3 + row] << 4;
      v6 = p[5 + row] << 4;

      // stage 3
      t = (v0 - v1 + 1) >> 1;
      v0 = (v0 + v1 + 1) >> 1;
      v1 = t;
      t = (v2 * dctSin6 + v3 * dctCos6 + 128) >> 8;
      v2 = (v2 * dctCos6 - v3 * dctSin6 + 128) >> 8;
      v3 = t;
      t = (v4 - v6 + 1) >> 1;
      v4 = (v4 + v6 + 1) >> 1;
      v6 = t;
      t = (v7 + v5 + 1) >> 1;
      v5 = (v7 - v5 + 1) >> 1;
      v7 = t;

      // stage 2
      t = (v0 - v3 + 1) >> 1;
      v0 = (v0 + v3 + 1) >> 1;
      v3 = t;
      t = (v1 - v2 + 1) >> 1;
      v1 = (v1 + v2 + 1) >> 1;
      v2 = t;
      t = (v4 * dctSin3 + v7 * dctCos3 + 2048) >> 12;
      v4 = (v4 * dctCos3 - v7 * dctSin3 + 2048) >> 12;
      v7 = t;
      t = (v5 * dctSin1 + v6 * dctCos1 + 2048) >> 12;
      v5 = (v5 * dctCos1 - v6 * dctSin1 + 2048) >> 12;
      v6 = t;

      // stage 1
      p[0 + row] = v0 + v7;
      p[7 + row] = v0 - v7;
      p[1 + row] = v1 + v6;
      p[6 + row] = v1 - v6;
      p[2 + row] = v2 + v5;
      p[5 + row] = v2 - v5;
      p[3 + row] = v3 + v4;
      p[4 + row] = v3 - v4;
    }

    // inverse DCT on columns
    for (i = 0; i < 8; ++i) {
      var col = i;

      // check for all-zero AC coefficients
      if (p[1 * 8 + col] === 0 && p[2 * 8 + col] === 0 && p[3 * 8 + col] === 0 &&
        p[4 * 8 + col] === 0 && p[5 * 8 + col] === 0 && p[6 * 8 + col] === 0 &&
        p[7 * 8 + col] === 0) {
        t = (dctSqrt2 * p[i + 0] + 8192) >> 14;
        p[0 * 8 + col] = t;
        p[1 * 8 + col] = t;
        p[2 * 8 + col] = t;
        p[3 * 8 + col] = t;
        p[4 * 8 + col] = t;
        p[5 * 8 + col] = t;
        p[6 * 8 + col] = t;
        p[7 * 8 + col] = t;
        continue;
      }

      // stage 4
      v0 = (dctSqrt2 * p[0 * 8 + col] + 2048) >> 12;
      v1 = (dctSqrt2 * p[4 * 8 + col] + 2048) >> 12;
      v2 = p[2 * 8 + col];
      v3 = p[6 * 8 + col];
      v4 = (dctSqrt1d2 * (p[1 * 8 + col] - p[7 * 8 + col]) + 2048) >> 12;
      v7 = (dctSqrt1d2 * (p[1 * 8 + col] + p[7 * 8 + col]) + 2048) >> 12;
      v5 = p[3 * 8 + col];
      v6 = p[5 * 8 + col];

      // stage 3
      t = (v0 - v1 + 1) >> 1;
      v0 = (v0 + v1 + 1) >> 1;
      v1 = t;
      t = (v2 * dctSin6 + v3 * dctCos6 + 2048) >> 12;
      v2 = (v2 * dctCos6 - v3 * dctSin6 + 2048) >> 12;
      v3 = t;
      t = (v4 - v6 + 1) >> 1;
      v4 = (v4 + v6 + 1) >> 1;
      v6 = t;
      t = (v7 + v5 + 1) >> 1;
      v5 = (v7 - v5 + 1) >> 1;
      v7 = t;

      // stage 2
      t = (v0 - v3 + 1) >> 1;
      v0 = (v0 + v3 + 1) >> 1;
      v3 = t;
      t = (v1 - v2 + 1) >> 1;
      v1 = (v1 + v2 + 1) >> 1;
      v2 = t;
      t = (v4 * dctSin3 + v7 * dctCos3 + 2048) >> 12;
      v4 = (v4 * dctCos3 - v7 * dctSin3 + 2048) >> 12;
      v7 = t;
      t = (v5 * dctSin1 + v6 * dctCos1 + 2048) >> 12;
      v5 = (v5 * dctCos1 - v6 * dctSin1 + 2048) >> 12;
      v6 = t;

      // stage 1
      p[0 * 8 + col] = v0 + v7;
      p[7 * 8 + col] = v0 - v7;
      p[1 * 8 + col] = v1 + v6;
      p[6 * 8 + col] = v1 - v6;
      p[2 * 8 + col] = v2 + v5;
      p[5 * 8 + col] = v2 - v5;
      p[3 * 8 + col] = v3 + v4;
      p[4 * 8 + col] = v3 - v4;
    }

    // convert to 8-bit integers
    for (i = 0; i < 64; ++i) {
      var index = blockBufferOffset + i;
      var q = p[i];
      q = (q <= -2056 / component.bitConversion) ? 0 :
        (q >= 2024 / component.bitConversion) ? 255 / component.bitConversion :
        (q + 2056 / component.bitConversion) >> 4;
      component.blockData[index] = q;
    }
  }

  function buildComponentData(frame, component) {
    var lines = [];
    var blocksPerLine = component.blocksPerLine;
    var blocksPerColumn = component.blocksPerColumn;
    var samplesPerLine = blocksPerLine << 3;
    var computationBuffer = new Int32Array(64);

    var i, j, ll = 0;
    for (var blockRow = 0; blockRow < blocksPerColumn; blockRow++) {
      for (var blockCol = 0; blockCol < blocksPerLine; blockCol++) {
        var offset = getBlockBufferOffset(component, blockRow, blockCol);
        quantizeAndInverse(component, offset, computationBuffer);
      }
    }
    return component.blockData;
  }

  function clampToUint8(a) {
    return a <= 0 ? 0 : a >= 255 ? 255 : a | 0;
  }

  constructor.prototype = {
    load: function load(path) {
      var handleData = (function (data) {
        this.parse(data);
        if (this.onload)
          this.onload();
      }).bind(this);

      if (path.indexOf("data:") > -1) {
        var offset = path.indexOf("base64,") + 7;
        var data = atob(path.substring(offset));
        var arr = new Uint8Array(data.length);
        for (var i = data.length - 1; i >= 0; i--) {
          arr[i] = data.charCodeAt(i);
        }
        handleData(data);
      } else {
        var xhr = new XMLHttpRequest();
        xhr.open("GET", path, true);
        xhr.responseType = "arraybuffer";
        xhr.onload = (function () {
          // TODO catch parse error
          var data = new Uint8Array(xhr.response);
          handleData(data);
        }).bind(this);
        xhr.send(null);
      }
    },
    parse: function parse(data) {

      function readUint16() {
        var value = (data[offset] << 8) | data[offset + 1];
        offset += 2;
        return value;
      }

      function readDataBlock() {
        var length = readUint16();
        var array = data.subarray(offset, offset + length - 2);
        offset += array.length;
        return array;
      }

      function prepareComponents(frame) {
        var mcusPerLine = Math.ceil(frame.samplesPerLine / 8 / frame.maxH);
        var mcusPerColumn = Math.ceil(frame.scanLines / 8 / frame.maxV);
        for (var i = 0; i < frame.components.length; i++) {
          component = frame.components[i];
          var blocksPerLine = Math.ceil(Math.ceil(frame.samplesPerLine / 8) * component.h / frame.maxH);
          var blocksPerColumn = Math.ceil(Math.ceil(frame.scanLines / 8) * component.v / frame.maxV);
          var blocksPerLineForMcu = mcusPerLine * component.h;
          var blocksPerColumnForMcu = mcusPerColumn * component.v;

          var blocksBufferSize = 64 * blocksPerColumnForMcu * (blocksPerLineForMcu + 1);
          component.blockData = new Int16Array(blocksBufferSize);
          component.blocksPerLine = blocksPerLine;
          component.blocksPerColumn = blocksPerColumn;
        }
        frame.mcusPerLine = mcusPerLine;
        frame.mcusPerColumn = mcusPerColumn;
      }

      var offset = 0, length = data.length;
      var jfif = null;
      var adobe = null;
      var pixels = null;
      var frame, resetInterval;
      var quantizationTables = [];
      var huffmanTablesAC = [], huffmanTablesDC = [];
      var fileMarker = readUint16();
      if (fileMarker != 0xFFD8) { // SOI (Start of Image)
        throw "SOI not found";
      }

      fileMarker = readUint16();
      while (fileMarker != 0xFFD9) { // EOI (End of image)
        var i, j, l;
        switch (fileMarker) {
          case 0xFFE0: // APP0 (Application Specific)
          case 0xFFE1: // APP1
          case 0xFFE2: // APP2
          case 0xFFE3: // APP3
          case 0xFFE4: // APP4
          case 0xFFE5: // APP5
          case 0xFFE6: // APP6
          case 0xFFE7: // APP7
          case 0xFFE8: // APP8
          case 0xFFE9: // APP9
          case 0xFFEA: // APP10
          case 0xFFEB: // APP11
          case 0xFFEC: // APP12
          case 0xFFED: // APP13
          case 0xFFEE: // APP14
          case 0xFFEF: // APP15
          case 0xFFFE: // COM (Comment)
            var appData = readDataBlock();

            if (fileMarker === 0xFFE0) {
              if (appData[0] === 0x4A && appData[1] === 0x46 && appData[2] === 0x49 &&
                appData[3] === 0x46 && appData[4] === 0) { // 'JFIF\x00'
                jfif = {
                  version: {major: appData[5], minor: appData[6]},
                  densityUnits: appData[7],
                  xDensity: (appData[8] << 8) | appData[9],
                  yDensity: (appData[10] << 8) | appData[11],
                  thumbWidth: appData[12],
                  thumbHeight: appData[13],
                  thumbData: appData.subarray(14, 14 + 3 * appData[12] * appData[13])
                };
              }
            }
            // TODO APP1 - Exif
            if (fileMarker === 0xFFEE) {
              if (appData[0] === 0x41 && appData[1] === 0x64 && appData[2] === 0x6F &&
                appData[3] === 0x62 && appData[4] === 0x65 && appData[5] === 0) { // 'Adobe\x00'
                adobe = {
                  version: appData[6],
                  flags0: (appData[7] << 8) | appData[8],
                  flags1: (appData[9] << 8) | appData[10],
                  transformCode: appData[11]
                };
              }
            }
            break;

          case 0xFFDB: // DQT (Define Quantization Tables)
            var quantizationTablesLength = readUint16();
            var quantizationTablesEnd = quantizationTablesLength + offset - 2;
            while (offset < quantizationTablesEnd) {
              var quantizationTableSpec = data[offset++];
              var tableData = new Int32Array(64);
              if ((quantizationTableSpec >> 4) === 0) { // 8 bit values
                for (j = 0; j < 64; j++) {
                  var z = dctZigZag[j];
                  tableData[z] = data[offset++];
                }
              } else if ((quantizationTableSpec >> 4) === 1) { //16 bit
                for (j = 0; j < 64; j++) {
                  var zz = dctZigZag[j];
                  tableData[zz] = readUint16();
                }
              } else
                throw "DQT: invalid table spec";
              quantizationTables[quantizationTableSpec & 15] = tableData;
            }
            break;

          case 0xFFC0: // SOF0 (Start of Frame, Baseline DCT)
          case 0xFFC1: // SOF1 (Start of Frame, Extended DCT)
          case 0xFFC2: // SOF2 (Start of Frame, Progressive DCT)
            if (frame) {
              throw "Only single frame JPEGs supported";
            }
            readUint16(); // skip data length
            frame = {};
            frame.extended = (fileMarker === 0xFFC1);
            frame.progressive = (fileMarker === 0xFFC2);
            frame.precision = data[offset++];
            frame.scanLines = readUint16();
            frame.samplesPerLine = readUint16();
            frame.components = [];
            frame.componentIds = {};
            var componentsCount = data[offset++], componentId;
            var maxH = 0, maxV = 0;
            for (i = 0; i < componentsCount; i++) {
              componentId = data[offset];
              var h = data[offset + 1] >> 4;
              var v = data[offset + 1] & 15;
              if (maxH < h)
                maxH = h;
              if (maxV < v)
                maxV = v;
              var qId = data[offset + 2];
              l = frame.components.push({
                h: h,
                v: v,
                quantizationTable: quantizationTables[qId],
                quantizationTableId: qId,
                bitConversion: 255 / ((1 << frame.precision) - 1)
              });
              frame.componentIds[componentId] = l - 1;
              offset += 3;
            }
            frame.maxH = maxH;
            frame.maxV = maxV;
            prepareComponents(frame);
            break;

          case 0xFFC4: // DHT (Define Huffman Tables)
            var huffmanLength = readUint16();
            for (i = 2; i < huffmanLength; ) {
              var huffmanTableSpec = data[offset++];
              var codeLengths = new Uint8Array(16);
              var codeLengthSum = 0;
              for (j = 0; j < 16; j++, offset++)
                codeLengthSum += (codeLengths[j] = data[offset]);
              var huffmanValues = new Uint8Array(codeLengthSum);
              for (j = 0; j < codeLengthSum; j++, offset++)
                huffmanValues[j] = data[offset];
              i += 17 + codeLengthSum;

              ((huffmanTableSpec >> 4) === 0 ?
                huffmanTablesDC : huffmanTablesAC)[huffmanTableSpec & 15] =
                buildHuffmanTable(codeLengths, huffmanValues);
            }
            break;

          case 0xFFDD: // DRI (Define Restart Interval)
            readUint16(); // skip data length
            resetInterval = readUint16();
            break;

          case 0xFFDA: // SOS (Start of Scan)
            var scanLength = readUint16();
            var selectorsCount = data[offset++];
            var components = [], component;
            for (i = 0; i < selectorsCount; i++) {
              var componentIndex = frame.componentIds[data[offset++]];
              component = frame.components[componentIndex];
              var tableSpec = data[offset++];
              component.huffmanTableDC = huffmanTablesDC[tableSpec >> 4];
              component.huffmanTableAC = huffmanTablesAC[tableSpec & 15];
              components.push(component);
            }
            var spectralStart = data[offset++];
            var spectralEnd = data[offset++];
            var successiveApproximation = data[offset++];
            var processed = decodeScan(data, offset,
              frame, components, resetInterval,
              spectralStart, spectralEnd,
              successiveApproximation >> 4, successiveApproximation & 15);
            offset += processed;
            break;
          default:
            if (data[offset - 3] == 0xFF &&
              data[offset - 2] >= 0xC0 && data[offset - 2] <= 0xFE) {
              // could be incorrect encoding -- last 0xFF byte of the previous
              // block was eaten by the encoder
              offset -= 3;
              break;
            }
            throw "unknown JPEG marker " + fileMarker.toString(16);
        }
        fileMarker = readUint16();
      }

      this.width = frame.samplesPerLine;
      this.height = frame.scanLines;
      this.jfif = jfif;
      this.adobe = adobe;
      this.components = [];
      switch (frame.components.length)
      {
        case 1:
          this.colorspace = ColorSpace.Grayscale;
          break;
        case 3:
          if (this.adobe)
            this.colorspace = ColorSpace.AdobeRGB;
          else
            this.colorspace = ColorSpace.RGB;
          break;
        case 4:
          this.colorspace = ColorSpace.CYMK;
          break;
        default:
          this.colorspace = ColorSpace.Unknown;
      }
      for (var i = 0; i < frame.components.length; i++) {
        var component = frame.components[i];
        if (!component.quantizationTable && component.quantizationTableId !== null)
          component.quantizationTable = quantizationTables[component.quantizationTableId];
        this.components.push({
          output: buildComponentData(frame, component),
          scaleX: component.h / frame.maxH,
          scaleY: component.v / frame.maxV,
          blocksPerLine: component.blocksPerLine,
          blocksPerColumn: component.blocksPerColumn,
          bitConversion: component.bitConversion
        });
      }
    },
    getData16: function getData16(width, height) {
      if (this.components.length !== 1)
        throw 'Unsupported color mode';
      var scaleX = this.width / width, scaleY = this.height / height;

      var component, componentScaleX, componentScaleY;
      var x, y, i;
      var offset = 0;
      var numComponents = this.components.length;
      var dataLength = width * height * numComponents;
      var data = new Uint16Array(dataLength);
      var componentLine;

      // lineData is reused for all components. Assume first component is
      // the biggest
      var lineData = new Uint16Array((this.components[0].blocksPerLine << 3) *
      this.components[0].blocksPerColumn * 8);

      // First construct image data ...
      for (i = 0; i < numComponents; i++) {
        component = this.components[i];
        var blocksPerLine = component.blocksPerLine;
        var blocksPerColumn = component.blocksPerColumn;
        var samplesPerLine = blocksPerLine << 3;

        var j, k, ll = 0;
        var lineOffset = 0;
        for (var blockRow = 0; blockRow < blocksPerColumn; blockRow++) {
          var scanLine = blockRow << 3;
          for (var blockCol = 0; blockCol < blocksPerLine; blockCol++) {
            var bufferOffset = getBlockBufferOffset(component, blockRow, blockCol);
            var offset = 0, sample = blockCol << 3;
            for (j = 0; j < 8; j++) {
              var lineOffset = (scanLine + j) * samplesPerLine;
              for (k = 0; k < 8; k++) {
                lineData[lineOffset + sample + k] =
                  component.output[bufferOffset + offset++];
              }
            }
          }
        }

        componentScaleX = component.scaleX * scaleX;
        componentScaleY = component.scaleY * scaleY;
        offset = i;

        var cx, cy;
        var index;
        for (y = 0; y < height; y++) {
          for (x = 0; x < width; x++) {
            cy = 0 | (y * componentScaleY);
            cx = 0 | (x * componentScaleX);
            index = cy * samplesPerLine + cx;
            data[offset] = lineData[index];
            offset += numComponents;
          }
        }
      }
      return data;
    },
    getData: function getData(width, height) {
      var scaleX = this.width / width, scaleY = this.height / height;

      var component, componentScaleX, componentScaleY;
      var x, y, i;
      var offset = 0;
      var Y, Cb, Cr, K, C, M, Ye, R, G, B;
      var colorTransform;
      var numComponents = this.components.length;
      var dataLength = width * height * numComponents;
      var data = new Uint8Array(dataLength);
      var componentLine;

      // lineData is reused for all components. Assume first component is
      // the biggest
      var lineData = new Uint8Array((this.components[0].blocksPerLine << 3) *
      this.components[0].blocksPerColumn * 8);

      // First construct image data ...
      for (i = 0; i < numComponents; i++) {
        component = this.components[i];
        var blocksPerLine = component.blocksPerLine;
        var blocksPerColumn = component.blocksPerColumn;
        var samplesPerLine = blocksPerLine << 3;

        var j, k, ll = 0;
        var lineOffset = 0;
        for (var blockRow = 0; blockRow < blocksPerColumn; blockRow++) {
          var scanLine = blockRow << 3;
          for (var blockCol = 0; blockCol < blocksPerLine; blockCol++) {
            var bufferOffset = getBlockBufferOffset(component, blockRow, blockCol);
            var offset = 0, sample = blockCol << 3;
            for (j = 0; j < 8; j++) {
              var lineOffset = (scanLine + j) * samplesPerLine;
              for (k = 0; k < 8; k++) {
                lineData[lineOffset + sample + k] =
                  component.output[bufferOffset + offset++] * component.bitConversion;
              }
            }
          }
        }

        componentScaleX = component.scaleX * scaleX;
        componentScaleY = component.scaleY * scaleY;
        offset = i;

        var cx, cy;
        var index;
        for (y = 0; y < height; y++) {
          for (x = 0; x < width; x++) {
            cy = 0 | (y * componentScaleY);
            cx = 0 | (x * componentScaleX);
            index = cy * samplesPerLine + cx;
            data[offset] = lineData[index];
            offset += numComponents;
          }
        }
      }

      // ... then transform colors, if necessary
      switch (numComponents) {
        case 1:
        case 2:
          break;
        // no color conversion for one or two compoenents

        case 3:
          // The default transform for three components is true
          colorTransform = true;
          // The adobe transform marker overrides any previous setting
          if (this.adobe && this.adobe.transformCode)
            colorTransform = true;
          else if (typeof this.colorTransform !== 'undefined')
            colorTransform = !!this.colorTransform;

          if (colorTransform) {
            for (i = 0; i < dataLength; i += numComponents) {
              Y = data[i    ];
              Cb = data[i + 1];
              Cr = data[i + 2];

              R = clampToUint8(Y - 179.456 + 1.402 * Cr);
              G = clampToUint8(Y + 135.459 - 0.344 * Cb - 0.714 * Cr);
              B = clampToUint8(Y - 226.816 + 1.772 * Cb);

              data[i    ] = R;
              data[i + 1] = G;
              data[i + 2] = B;
            }
          }
          break;
        case 4:
          if (!this.adobe)
            throw 'Unsupported color mode (4 components)';
          // The default transform for four components is false
          colorTransform = false;
          // The adobe transform marker overrides any previous setting
          if (this.adobe && this.adobe.transformCode)
            colorTransform = true;
          else if (typeof this.colorTransform !== 'undefined')
            colorTransform = !!this.colorTransform;

          if (colorTransform) {
            for (i = 0; i < dataLength; i += numComponents) {
              Y = data[i];
              Cb = data[i + 1];
              Cr = data[i + 2];

              C = clampToUint8(434.456 - Y - 1.402 * Cr);
              M = clampToUint8(119.541 - Y + 0.344 * Cb + 0.714 * Cr);
              Y = clampToUint8(481.816 - Y - 1.772 * Cb);

              data[i    ] = C;
              data[i + 1] = M;
              data[i + 2] = Y;
              // K is unchanged
            }
          }
          break;
        default:
          throw 'Unsupported color mode';
      }
      return data;
    }
  };

  return constructor;
})();

var moduleType = typeof module;
if ((moduleType !== 'undefined') && module.exports) {
    module.exports = JpegImage;
}
},{}],2:[function(require,module,exports){
/*! image-JPEG2000 - v0.3.1 - 2015-08-26 | https://github.com/OHIF/image-JPEG2000 */
/* -*- Mode: Java; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
/* vim: set shiftwidth=2 tabstop=2 autoindent cindent expandtab: */
/* Copyright 2012 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* globals ArithmeticDecoder, globalScope, log2, readUint16, readUint32,
           info, warn */

'use strict';

var JpxImage = (function JpxImageClosure() {
  // Table E.1
  var SubbandsGainLog2 = {
    'LL': 0,
    'LH': 1,
    'HL': 1,
    'HH': 2
  };
  function JpxImage() {
    this.failOnCorruptedImage = false;
  }
  JpxImage.prototype = {
    parse: function JpxImage_parse(data) {

      var head = readUint16(data, 0);
      // No box header, immediate start of codestream (SOC)
      if (head === 0xFF4F) {
        this.parseCodestream(data, 0, data.length);
        return;
      }

      var position = 0, length = data.length;
      while (position < length) {
        var headerSize = 8;
        var lbox = readUint32(data, position);
        var tbox = readUint32(data, position + 4);
        position += headerSize;
        if (lbox === 1) {
          // XLBox: read UInt64 according to spec.
          // JavaScript's int precision of 53 bit should be sufficient here.
          lbox = readUint32(data, position) * 4294967296 +
                 readUint32(data, position + 4);
          position += 8;
          headerSize += 8;
        }
        if (lbox === 0) {
          lbox = length - position + headerSize;
        }
        if (lbox < headerSize) {
          throw new Error('JPX Error: Invalid box field size');
        }
        var dataLength = lbox - headerSize;
        var jumpDataLength = true;
        switch (tbox) {
          case 0x6A703268: // 'jp2h'
            jumpDataLength = false; // parsing child boxes
            break;
          case 0x636F6C72: // 'colr'
            // Colorspaces are not used, the CS from the PDF is used.
            var method = data[position];
            var precedence = data[position + 1];
            var approximation = data[position + 2];
            if (method === 1) {
              // enumerated colorspace
              var colorspace = readUint32(data, position + 3);
              switch (colorspace) {
                case 16: // this indicates a sRGB colorspace
                case 17: // this indicates a grayscale colorspace
                case 18: // this indicates a YUV colorspace
                  break;
                default:
                  warn('Unknown colorspace ' + colorspace);
                  break;
              }
            } else if (method === 2) {
              info('ICC profile not supported');
            }
            break;
          case 0x6A703263: // 'jp2c'
            this.parseCodestream(data, position, position + dataLength);
            break;
          case 0x6A502020: // 'jP\024\024'
            if (0x0d0a870a !== readUint32(data, position)) {
              warn('Invalid JP2 signature');
            }
            break;
          // The following header types are valid but currently not used:
          case 0x6A501A1A: // 'jP\032\032'
          case 0x66747970: // 'ftyp'
          case 0x72726571: // 'rreq'
          case 0x72657320: // 'res '
          case 0x69686472: // 'ihdr'
            break;
          default:
            var headerType = String.fromCharCode((tbox >> 24) & 0xFF,
                                                 (tbox >> 16) & 0xFF,
                                                 (tbox >> 8) & 0xFF,
                                                 tbox & 0xFF);
            warn('Unsupported header type ' + tbox + ' (' + headerType + ')');
            break;
        }
        if (jumpDataLength) {
          position += dataLength;
        }
      }
    },
    parseImageProperties: function JpxImage_parseImageProperties(stream) {
      var newByte = stream.getByte();
      while (newByte >= 0) {
        var oldByte = newByte;
        newByte = stream.getByte();
        var code = (oldByte << 8) | newByte;
        // Image and tile size (SIZ)
        if (code === 0xFF51) {
          stream.skip(4);
          var Xsiz = stream.getInt32() >>> 0; // Byte 4
          var Ysiz = stream.getInt32() >>> 0; // Byte 8
          var XOsiz = stream.getInt32() >>> 0; // Byte 12
          var YOsiz = stream.getInt32() >>> 0; // Byte 16
          stream.skip(16);
          var Csiz = stream.getUint16(); // Byte 36
          this.width = Xsiz - XOsiz;
          this.height = Ysiz - YOsiz;
          this.componentsCount = Csiz;
          // Results are always returned as Uint8Arrays
          this.bitsPerComponent = 8;
          return;
        }
      }
      throw new Error('JPX Error: No size marker found in JPX stream');
    },
    parseCodestream: function JpxImage_parseCodestream(data, start, end) {
      var context = {};
      try {
        var doNotRecover = false;
        var position = start;
        while (position + 1 < end) {
          var code = readUint16(data, position);
          position += 2;

          var length = 0, j, sqcd, spqcds, spqcdSize, scalarExpounded, tile;
          switch (code) {
            case 0xFF4F: // Start of codestream (SOC)
              context.mainHeader = true;
              break;
            case 0xFFD9: // End of codestream (EOC)
              break;
            case 0xFF51: // Image and tile size (SIZ)
              length = readUint16(data, position);
              var siz = {};
              siz.Xsiz = readUint32(data, position + 4);
              siz.Ysiz = readUint32(data, position + 8);
              siz.XOsiz = readUint32(data, position + 12);
              siz.YOsiz = readUint32(data, position + 16);
              siz.XTsiz = readUint32(data, position + 20);
              siz.YTsiz = readUint32(data, position + 24);
              siz.XTOsiz = readUint32(data, position + 28);
              siz.YTOsiz = readUint32(data, position + 32);
              var componentsCount = readUint16(data, position + 36);
              siz.Csiz = componentsCount;
              var components = [];
              j = position + 38;
              for (var i = 0; i < componentsCount; i++) {
                var component = {
                  precision: (data[j] & 0x7F) + 1,
                  isSigned: !!(data[j] & 0x80),
                  XRsiz: data[j + 1],
                  YRsiz: data[j + 1]
                };
                calculateComponentDimensions(component, siz);
                components.push(component);
              }
              context.SIZ = siz;
              context.components = components;
              calculateTileGrids(context, components);
              context.QCC = [];
              context.COC = [];
              break;
            case 0xFF5C: // Quantization default (QCD)
              length = readUint16(data, position);
              var qcd = {};
              j = position + 2;
              sqcd = data[j++];
              switch (sqcd & 0x1F) {
                case 0:
                  spqcdSize = 8;
                  scalarExpounded = true;
                  break;
                case 1:
                  spqcdSize = 16;
                  scalarExpounded = false;
                  break;
                case 2:
                  spqcdSize = 16;
                  scalarExpounded = true;
                  break;
                default:
                  throw new Error('JPX Error: Invalid SQcd value ' + sqcd);
              }
              qcd.noQuantization = (spqcdSize === 8);
              qcd.scalarExpounded = scalarExpounded;
              qcd.guardBits = sqcd >> 5;
              spqcds = [];
              while (j < length + position) {
                var spqcd = {};
                if (spqcdSize === 8) {
                  spqcd.epsilon = data[j++] >> 3;
                  spqcd.mu = 0;
                } else {
                  spqcd.epsilon = data[j] >> 3;
                  spqcd.mu = ((data[j] & 0x7) << 8) | data[j + 1];
                  j += 2;
                }
                spqcds.push(spqcd);
              }
              qcd.SPqcds = spqcds;
              if (context.mainHeader) {
                context.QCD = qcd;
              } else {
                context.currentTile.QCD = qcd;
                context.currentTile.QCC = [];
              }
              break;
            case 0xFF5D: // Quantization component (QCC)
              length = readUint16(data, position);
              var qcc = {};
              j = position + 2;
              var cqcc;
              if (context.SIZ.Csiz < 257) {
                cqcc = data[j++];
              } else {
                cqcc = readUint16(data, j);
                j += 2;
              }
              sqcd = data[j++];
              switch (sqcd & 0x1F) {
                case 0:
                  spqcdSize = 8;
                  scalarExpounded = true;
                  break;
                case 1:
                  spqcdSize = 16;
                  scalarExpounded = false;
                  break;
                case 2:
                  spqcdSize = 16;
                  scalarExpounded = true;
                  break;
                default:
                  throw new Error('JPX Error: Invalid SQcd value ' + sqcd);
              }
              qcc.noQuantization = (spqcdSize === 8);
              qcc.scalarExpounded = scalarExpounded;
              qcc.guardBits = sqcd >> 5;
              spqcds = [];
              while (j < (length + position)) {
                spqcd = {};
                if (spqcdSize === 8) {
                  spqcd.epsilon = data[j++] >> 3;
                  spqcd.mu = 0;
                } else {
                  spqcd.epsilon = data[j] >> 3;
                  spqcd.mu = ((data[j] & 0x7) << 8) | data[j + 1];
                  j += 2;
                }
                spqcds.push(spqcd);
              }
              qcc.SPqcds = spqcds;
              if (context.mainHeader) {
                context.QCC[cqcc] = qcc;
              } else {
                context.currentTile.QCC[cqcc] = qcc;
              }
              break;
            case 0xFF52: // Coding style default (COD)
              length = readUint16(data, position);
              var cod = {};
              j = position + 2;
              var scod = data[j++];
              cod.entropyCoderWithCustomPrecincts = !!(scod & 1);
              cod.sopMarkerUsed = !!(scod & 2);
              cod.ephMarkerUsed = !!(scod & 4);
              cod.progressionOrder = data[j++];
              cod.layersCount = readUint16(data, j);
              j += 2;
              cod.multipleComponentTransform = data[j++];

              cod.decompositionLevelsCount = data[j++];
              cod.xcb = (data[j++] & 0xF) + 2;
              cod.ycb = (data[j++] & 0xF) + 2;
              var blockStyle = data[j++];
              cod.selectiveArithmeticCodingBypass = !!(blockStyle & 1);
              cod.resetContextProbabilities = !!(blockStyle & 2);
              cod.terminationOnEachCodingPass = !!(blockStyle & 4);
              cod.verticalyStripe = !!(blockStyle & 8);
              cod.predictableTermination = !!(blockStyle & 16);
              cod.segmentationSymbolUsed = !!(blockStyle & 32);
              cod.reversibleTransformation = data[j++];
              if (cod.entropyCoderWithCustomPrecincts) {
                var precinctsSizes = [];
                while (j < length + position) {
                  var precinctsSize = data[j++];
                  precinctsSizes.push({
                    PPx: precinctsSize & 0xF,
                    PPy: precinctsSize >> 4
                  });
                }
                cod.precinctsSizes = precinctsSizes;
              }
              var unsupported = [];
              if (cod.selectiveArithmeticCodingBypass) {
                unsupported.push('selectiveArithmeticCodingBypass');
              }
              if (cod.resetContextProbabilities) {
                unsupported.push('resetContextProbabilities');
              }
              if (cod.terminationOnEachCodingPass) {
                unsupported.push('terminationOnEachCodingPass');
              }
              if (cod.verticalyStripe) {
                unsupported.push('verticalyStripe');
              }
              if (cod.predictableTermination) {
                unsupported.push('predictableTermination');
              }
              if (unsupported.length > 0) {
                doNotRecover = true;
                throw new Error('JPX Error: Unsupported COD options (' +
                                unsupported.join(', ') + ')');
              }
              if (context.mainHeader) {
                context.COD = cod;
              } else {
                context.currentTile.COD = cod;
                context.currentTile.COC = [];
              }
              break;
            case 0xFF90: // Start of tile-part (SOT)
              length = readUint16(data, position);
              tile = {};
              tile.index = readUint16(data, position + 2);
              tile.length = readUint32(data, position + 4);
              tile.dataEnd = tile.length + position - 2;
              tile.partIndex = data[position + 8];
              tile.partsCount = data[position + 9];

              context.mainHeader = false;
              if (tile.partIndex === 0) {
                // reset component specific settings
                tile.COD = context.COD;
                tile.COC = context.COC.slice(0); // clone of the global COC
                tile.QCD = context.QCD;
                tile.QCC = context.QCC.slice(0); // clone of the global COC
              }
              context.currentTile = tile;
              break;
            case 0xFF93: // Start of data (SOD)
              tile = context.currentTile;
              if (tile.partIndex === 0) {
                initializeTile(context, tile.index);
                buildPackets(context);
              }

              // moving to the end of the data
              length = tile.dataEnd - position;
              parseTilePackets(context, data, position, length);
              break;
            case 0xFF55: // Tile-part lengths, main header (TLM)
            case 0xFF57: // Packet length, main header (PLM)
            case 0xFF58: // Packet length, tile-part header (PLT)
            case 0xFF64: // Comment (COM)
              length = readUint16(data, position);
              // skipping content
              break;
            case 0xFF53: // Coding style component (COC)
              throw new Error('JPX Error: Codestream code 0xFF53 (COC) is ' +
                              'not implemented');
            default:
              throw new Error('JPX Error: Unknown codestream code: ' +
                              code.toString(16));
          }
          position += length;
        }
      } catch (e) {
        if (doNotRecover || this.failOnCorruptedImage) {
          throw e;
        } else {
          warn('Trying to recover from ' + e.message);
        }
      }
      this.tiles = transformComponents(context);
      this.width = context.SIZ.Xsiz - context.SIZ.XOsiz;
      this.height = context.SIZ.Ysiz - context.SIZ.YOsiz;
      this.componentsCount = context.SIZ.Csiz;
    }
  };
  function calculateComponentDimensions(component, siz) {
    // Section B.2 Component mapping
    component.x0 = Math.ceil(siz.XOsiz / component.XRsiz);
    component.x1 = Math.ceil(siz.Xsiz / component.XRsiz);
    component.y0 = Math.ceil(siz.YOsiz / component.YRsiz);
    component.y1 = Math.ceil(siz.Ysiz / component.YRsiz);
    component.width = component.x1 - component.x0;
    component.height = component.y1 - component.y0;
  }
  function calculateTileGrids(context, components) {
    var siz = context.SIZ;
    // Section B.3 Division into tile and tile-components
    var tile, tiles = [];
    var numXtiles = Math.ceil((siz.Xsiz - siz.XTOsiz) / siz.XTsiz);
    var numYtiles = Math.ceil((siz.Ysiz - siz.YTOsiz) / siz.YTsiz);
    for (var q = 0; q < numYtiles; q++) {
      for (var p = 0; p < numXtiles; p++) {
        tile = {};
        tile.tx0 = Math.max(siz.XTOsiz + p * siz.XTsiz, siz.XOsiz);
        tile.ty0 = Math.max(siz.YTOsiz + q * siz.YTsiz, siz.YOsiz);
        tile.tx1 = Math.min(siz.XTOsiz + (p + 1) * siz.XTsiz, siz.Xsiz);
        tile.ty1 = Math.min(siz.YTOsiz + (q + 1) * siz.YTsiz, siz.Ysiz);
        tile.width = tile.tx1 - tile.tx0;
        tile.height = tile.ty1 - tile.ty0;
        tile.components = [];
        tiles.push(tile);
      }
    }
    context.tiles = tiles;

    var componentsCount = siz.Csiz;
    for (var i = 0, ii = componentsCount; i < ii; i++) {
      var component = components[i];
      for (var j = 0, jj = tiles.length; j < jj; j++) {
        var tileComponent = {};
        tile = tiles[j];
        tileComponent.tcx0 = Math.ceil(tile.tx0 / component.XRsiz);
        tileComponent.tcy0 = Math.ceil(tile.ty0 / component.YRsiz);
        tileComponent.tcx1 = Math.ceil(tile.tx1 / component.XRsiz);
        tileComponent.tcy1 = Math.ceil(tile.ty1 / component.YRsiz);
        tileComponent.width = tileComponent.tcx1 - tileComponent.tcx0;
        tileComponent.height = tileComponent.tcy1 - tileComponent.tcy0;
        tile.components[i] = tileComponent;
      }
    }
  }
  function getBlocksDimensions(context, component, r) {
    var codOrCoc = component.codingStyleParameters;
    var result = {};
    if (!codOrCoc.entropyCoderWithCustomPrecincts) {
      result.PPx = 15;
      result.PPy = 15;
    } else {
      result.PPx = codOrCoc.precinctsSizes[r].PPx;
      result.PPy = codOrCoc.precinctsSizes[r].PPy;
    }
    // calculate codeblock size as described in section B.7
    result.xcb_ = (r > 0 ? Math.min(codOrCoc.xcb, result.PPx - 1) :
                   Math.min(codOrCoc.xcb, result.PPx));
    result.ycb_ = (r > 0 ? Math.min(codOrCoc.ycb, result.PPy - 1) :
                   Math.min(codOrCoc.ycb, result.PPy));
    return result;
  }
  function buildPrecincts(context, resolution, dimensions) {
    // Section B.6 Division resolution to precincts
    var precinctWidth = 1 << dimensions.PPx;
    var precinctHeight = 1 << dimensions.PPy;
    // Jasper introduces codeblock groups for mapping each subband codeblocks
    // to precincts. Precinct partition divides a resolution according to width
    // and height parameters. The subband that belongs to the resolution level
    // has a different size than the level, unless it is the zero resolution.

    // From Jasper documentation: jpeg2000.pdf, section K: Tier-2 coding:
    // The precinct partitioning for a particular subband is derived from a
    // partitioning of its parent LL band (i.e., the LL band at the next higher
    // resolution level)... The LL band associated with each resolution level is
    // divided into precincts... Each of the resulting precinct regions is then
    // mapped into its child subbands (if any) at the next lower resolution
    // level. This is accomplished by using the coordinate transformation
    // (u, v) = (ceil(x/2), ceil(y/2)) where (x, y) and (u, v) are the
    // coordinates of a point in the LL band and child subband, respectively.
    var isZeroRes = resolution.resLevel === 0;
    var precinctWidthInSubband = 1 << (dimensions.PPx + (isZeroRes ? 0 : -1));
    var precinctHeightInSubband = 1 << (dimensions.PPy + (isZeroRes ? 0 : -1));
    var numprecinctswide = (resolution.trx1 > resolution.trx0 ?
      Math.ceil(resolution.trx1 / precinctWidth) -
      Math.floor(resolution.trx0 / precinctWidth) : 0);
    var numprecinctshigh = (resolution.try1 > resolution.try0 ?
      Math.ceil(resolution.try1 / precinctHeight) -
      Math.floor(resolution.try0 / precinctHeight) : 0);
    var numprecincts = numprecinctswide * numprecinctshigh;

    resolution.precinctParameters = {
      precinctWidth: precinctWidth,
      precinctHeight: precinctHeight,
      numprecinctswide: numprecinctswide,
      numprecinctshigh: numprecinctshigh,
      numprecincts: numprecincts,
      precinctWidthInSubband: precinctWidthInSubband,
      precinctHeightInSubband: precinctHeightInSubband
    };
  }
  function buildCodeblocks(context, subband, dimensions) {
    // Section B.7 Division sub-band into code-blocks
    var xcb_ = dimensions.xcb_;
    var ycb_ = dimensions.ycb_;
    var codeblockWidth = 1 << xcb_;
    var codeblockHeight = 1 << ycb_;
    var cbx0 = subband.tbx0 >> xcb_;
    var cby0 = subband.tby0 >> ycb_;
    var cbx1 = (subband.tbx1 + codeblockWidth - 1) >> xcb_;
    var cby1 = (subband.tby1 + codeblockHeight - 1) >> ycb_;
    var precinctParameters = subband.resolution.precinctParameters;
    var codeblocks = [];
    var precincts = [];
    var i, j, codeblock, precinctNumber;
    for (j = cby0; j < cby1; j++) {
      for (i = cbx0; i < cbx1; i++) {
        codeblock = {
          cbx: i,
          cby: j,
          tbx0: codeblockWidth * i,
          tby0: codeblockHeight * j,
          tbx1: codeblockWidth * (i + 1),
          tby1: codeblockHeight * (j + 1)
        };

        codeblock.tbx0_ = Math.max(subband.tbx0, codeblock.tbx0);
        codeblock.tby0_ = Math.max(subband.tby0, codeblock.tby0);
        codeblock.tbx1_ = Math.min(subband.tbx1, codeblock.tbx1);
        codeblock.tby1_ = Math.min(subband.tby1, codeblock.tby1);

        // Calculate precinct number for this codeblock, codeblock position
        // should be relative to its subband, use actual dimension and position
        // See comment about codeblock group width and height
        var pi = Math.floor((codeblock.tbx0_ - subband.tbx0) /
          precinctParameters.precinctWidthInSubband);
        var pj = Math.floor((codeblock.tby0_ - subband.tby0) /
          precinctParameters.precinctHeightInSubband);
        precinctNumber = pi + (pj * precinctParameters.numprecinctswide);

        codeblock.precinctNumber = precinctNumber;
        codeblock.subbandType = subband.type;
        codeblock.Lblock = 3;

        if (codeblock.tbx1_ <= codeblock.tbx0_ ||
            codeblock.tby1_ <= codeblock.tby0_) {
          continue;
        }
        codeblocks.push(codeblock);
        // building precinct for the sub-band
        var precinct = precincts[precinctNumber];
        if (precinct !== undefined) {
          if (i < precinct.cbxMin) {
            precinct.cbxMin = i;
          } else if (i > precinct.cbxMax) {
            precinct.cbxMax = i;
          }
          if (j < precinct.cbyMin) {
            precinct.cbxMin = j;
          } else if (j > precinct.cbyMax) {
            precinct.cbyMax = j;
          }
        } else {
          precincts[precinctNumber] = precinct = {
            cbxMin: i,
            cbyMin: j,
            cbxMax: i,
            cbyMax: j
          };
        }
        codeblock.precinct = precinct;
      }
    }
    subband.codeblockParameters = {
      codeblockWidth: xcb_,
      codeblockHeight: ycb_,
      numcodeblockwide: cbx1 - cbx0 + 1,
      numcodeblockhigh: cby1 - cby0 + 1
    };
    subband.codeblocks = codeblocks;
    subband.precincts = precincts;
  }
  function createPacket(resolution, precinctNumber, layerNumber) {
    var precinctCodeblocks = [];
    // Section B.10.8 Order of info in packet
    var subbands = resolution.subbands;
    // sub-bands already ordered in 'LL', 'HL', 'LH', and 'HH' sequence
    for (var i = 0, ii = subbands.length; i < ii; i++) {
      var subband = subbands[i];
      var codeblocks = subband.codeblocks;
      for (var j = 0, jj = codeblocks.length; j < jj; j++) {
        var codeblock = codeblocks[j];
        if (codeblock.precinctNumber !== precinctNumber) {
          continue;
        }
        precinctCodeblocks.push(codeblock);
      }
    }
    return {
      layerNumber: layerNumber,
      codeblocks: precinctCodeblocks
    };
  }
  function LayerResolutionComponentPositionIterator(context) {
    var siz = context.SIZ;
    var tileIndex = context.currentTile.index;
    var tile = context.tiles[tileIndex];
    var layersCount = tile.codingStyleDefaultParameters.layersCount;
    var componentsCount = siz.Csiz;
    var maxDecompositionLevelsCount = 0;
    for (var q = 0; q < componentsCount; q++) {
      maxDecompositionLevelsCount = Math.max(maxDecompositionLevelsCount,
        tile.components[q].codingStyleParameters.decompositionLevelsCount);
    }

    var l = 0, r = 0, i = 0, k = 0;

    this.nextPacket = function JpxImage_nextPacket() {
      // Section B.12.1.1 Layer-resolution-component-position
      for (; l < layersCount; l++) {
        for (; r <= maxDecompositionLevelsCount; r++) {
          for (; i < componentsCount; i++) {
            var component = tile.components[i];
            if (r > component.codingStyleParameters.decompositionLevelsCount) {
              continue;
            }

            var resolution = component.resolutions[r];
            var numprecincts = resolution.precinctParameters.numprecincts;
            for (; k < numprecincts;) {
              var packet = createPacket(resolution, k, l);
              k++;
              return packet;
            }
            k = 0;
          }
          i = 0;
        }
        r = 0;
      }
    };
  }
  function ResolutionLayerComponentPositionIterator(context) {
    var siz = context.SIZ;
    var tileIndex = context.currentTile.index;
    var tile = context.tiles[tileIndex];
    var layersCount = tile.codingStyleDefaultParameters.layersCount;
    var componentsCount = siz.Csiz;
    var maxDecompositionLevelsCount = 0;
    for (var q = 0; q < componentsCount; q++) {
      maxDecompositionLevelsCount = Math.max(maxDecompositionLevelsCount,
        tile.components[q].codingStyleParameters.decompositionLevelsCount);
    }

    var r = 0, l = 0, i = 0, k = 0;

    this.nextPacket = function JpxImage_nextPacket() {
      // Section B.12.1.2 Resolution-layer-component-position
      for (; r <= maxDecompositionLevelsCount; r++) {
        for (; l < layersCount; l++) {
          for (; i < componentsCount; i++) {
            var component = tile.components[i];
            if (r > component.codingStyleParameters.decompositionLevelsCount) {
              continue;
            }

            var resolution = component.resolutions[r];
            var numprecincts = resolution.precinctParameters.numprecincts;
            for (; k < numprecincts;) {
              var packet = createPacket(resolution, k, l);
              k++;
              return packet;
            }
            k = 0;
          }
          i = 0;
        }
        l = 0;
      }
    };
  }
  function ResolutionPositionComponentLayerIterator(context) {
    var siz = context.SIZ;
    var tileIndex = context.currentTile.index;
    var tile = context.tiles[tileIndex];
    var layersCount = tile.codingStyleDefaultParameters.layersCount;
    var componentsCount = siz.Csiz;
    var l, r, c, p;
    var maxDecompositionLevelsCount = 0;
    for (c = 0; c < componentsCount; c++) {
      var component = tile.components[c];
      maxDecompositionLevelsCount = Math.max(maxDecompositionLevelsCount,
        component.codingStyleParameters.decompositionLevelsCount);
    }
    var maxNumPrecinctsInLevel = new Int32Array(
      maxDecompositionLevelsCount + 1);
    for (r = 0; r <= maxDecompositionLevelsCount; ++r) {
      var maxNumPrecincts = 0;
      for (c = 0; c < componentsCount; ++c) {
        var resolutions = tile.components[c].resolutions;
        if (r < resolutions.length) {
          maxNumPrecincts = Math.max(maxNumPrecincts,
            resolutions[r].precinctParameters.numprecincts);
        }
      }
      maxNumPrecinctsInLevel[r] = maxNumPrecincts;
    }
    l = 0;
    r = 0;
    c = 0;
    p = 0;

    this.nextPacket = function JpxImage_nextPacket() {
      // Section B.12.1.3 Resolution-position-component-layer
      for (; r <= maxDecompositionLevelsCount; r++) {
        for (; p < maxNumPrecinctsInLevel[r]; p++) {
          for (; c < componentsCount; c++) {
            var component = tile.components[c];
            if (r > component.codingStyleParameters.decompositionLevelsCount) {
              continue;
            }
            var resolution = component.resolutions[r];
            var numprecincts = resolution.precinctParameters.numprecincts;
            if (p >= numprecincts) {
              continue;
            }
            for (; l < layersCount;) {
              var packet = createPacket(resolution, p, l);
              l++;
              return packet;
            }
            l = 0;
          }
          c = 0;
        }
        p = 0;
      }
    };
  }
  function PositionComponentResolutionLayerIterator(context) {
    var siz = context.SIZ;
    var tileIndex = context.currentTile.index;
    var tile = context.tiles[tileIndex];
    var layersCount = tile.codingStyleDefaultParameters.layersCount;
    var componentsCount = siz.Csiz;
    var precinctsSizes = getPrecinctSizesInImageScale(tile);
    var precinctsIterationSizes = precinctsSizes;
    var l = 0, r = 0, c = 0, px = 0, py = 0;

    this.nextPacket = function JpxImage_nextPacket() {
      // Section B.12.1.4 Position-component-resolution-layer
      for (; py < precinctsIterationSizes.maxNumHigh; py++) {
        for (; px < precinctsIterationSizes.maxNumWide; px++) {
          for (; c < componentsCount; c++) {
            var component = tile.components[c];
            var decompositionLevelsCount =
              component.codingStyleParameters.decompositionLevelsCount;
            for (; r <= decompositionLevelsCount; r++) {
              var resolution = component.resolutions[r];
              var sizeInImageScale =
                precinctsSizes.components[c].resolutions[r];
              var k = getPrecinctIndexIfExist(
                px,
                py,
                sizeInImageScale,
                precinctsIterationSizes,
                resolution);
              if (k === null) {
                continue;
              }
              for (; l < layersCount;) {
                var packet = createPacket(resolution, k, l);
                l++;
                return packet;
              }
              l = 0;
            }
            r = 0;
          }
          c = 0;
        }
        px = 0;
      }
    };
  }
  function ComponentPositionResolutionLayerIterator(context) {
    var siz = context.SIZ;
    var tileIndex = context.currentTile.index;
    var tile = context.tiles[tileIndex];
    var layersCount = tile.codingStyleDefaultParameters.layersCount;
    var componentsCount = siz.Csiz;
    var precinctsSizes = getPrecinctSizesInImageScale(tile);
    var l = 0, r = 0, c = 0, px = 0, py = 0;

    this.nextPacket = function JpxImage_nextPacket() {
      // Section B.12.1.5 Component-position-resolution-layer
      for (; c < componentsCount; ++c) {
        var component = tile.components[c];
        var precinctsIterationSizes = precinctsSizes.components[c];
        var decompositionLevelsCount =
          component.codingStyleParameters.decompositionLevelsCount;
        for (; py < precinctsIterationSizes.maxNumHigh; py++) {
          for (; px < precinctsIterationSizes.maxNumWide; px++) {
            for (; r <= decompositionLevelsCount; r++) {
              var resolution = component.resolutions[r];
              var sizeInImageScale = precinctsIterationSizes.resolutions[r];
              var k = getPrecinctIndexIfExist(
                px,
                py,
                sizeInImageScale,
                precinctsIterationSizes,
                resolution);
              if (k === null) {
                continue;
              }
              for (; l < layersCount;) {
                var packet = createPacket(resolution, k, l);
                l++;
                return packet;
              }
              l = 0;
            }
            r = 0;
          }
          px = 0;
        }
        py = 0;
      }
    };
  }
  function getPrecinctIndexIfExist(
    pxIndex, pyIndex, sizeInImageScale, precinctIterationSizes, resolution) {
    var posX = pxIndex * precinctIterationSizes.minWidth;
    var posY = pyIndex * precinctIterationSizes.minHeight;
    if (posX % sizeInImageScale.width !== 0 ||
        posY % sizeInImageScale.height !== 0) {
      return null;
    }
    var startPrecinctRowIndex =
      (posY / sizeInImageScale.width) *
      resolution.precinctParameters.numprecinctswide;
    return (posX / sizeInImageScale.height) + startPrecinctRowIndex;
  }
  function getPrecinctSizesInImageScale(tile) {
    var componentsCount = tile.components.length;
    var minWidth = Number.MAX_VALUE;
    var minHeight = Number.MAX_VALUE;
    var maxNumWide = 0;
    var maxNumHigh = 0;
    var sizePerComponent = new Array(componentsCount);
    for (var c = 0; c < componentsCount; c++) {
      var component = tile.components[c];
      var decompositionLevelsCount =
        component.codingStyleParameters.decompositionLevelsCount;
      var sizePerResolution = new Array(decompositionLevelsCount + 1);
      var minWidthCurrentComponent = Number.MAX_VALUE;
      var minHeightCurrentComponent = Number.MAX_VALUE;
      var maxNumWideCurrentComponent = 0;
      var maxNumHighCurrentComponent = 0;
      var scale = 1;
      for (var r = decompositionLevelsCount; r >= 0; --r) {
        var resolution = component.resolutions[r];
        var widthCurrentResolution =
          scale * resolution.precinctParameters.precinctWidth;
        var heightCurrentResolution =
          scale * resolution.precinctParameters.precinctHeight;
        minWidthCurrentComponent = Math.min(
          minWidthCurrentComponent,
          widthCurrentResolution);
        minHeightCurrentComponent = Math.min(
          minHeightCurrentComponent,
          heightCurrentResolution);
        maxNumWideCurrentComponent = Math.max(maxNumWideCurrentComponent,
          resolution.precinctParameters.numprecinctswide);
        maxNumHighCurrentComponent = Math.max(maxNumHighCurrentComponent,
          resolution.precinctParameters.numprecinctshigh);
        sizePerResolution[r] = {
          width: widthCurrentResolution,
          height: heightCurrentResolution
        };
        scale <<= 1;
      }
      minWidth = Math.min(minWidth, minWidthCurrentComponent);
      minHeight = Math.min(minHeight, minHeightCurrentComponent);
      maxNumWide = Math.max(maxNumWide, maxNumWideCurrentComponent);
      maxNumHigh = Math.max(maxNumHigh, maxNumHighCurrentComponent);
      sizePerComponent[c] = {
        resolutions: sizePerResolution,
        minWidth: minWidthCurrentComponent,
        minHeight: minHeightCurrentComponent,
        maxNumWide: maxNumWideCurrentComponent,
        maxNumHigh: maxNumHighCurrentComponent
      };
    }
    return {
      components: sizePerComponent,
      minWidth: minWidth,
      minHeight: minHeight,
      maxNumWide: maxNumWide,
      maxNumHigh: maxNumHigh
    };
  }
  function buildPackets(context) {
    var siz = context.SIZ;
    var tileIndex = context.currentTile.index;
    var tile = context.tiles[tileIndex];
    var componentsCount = siz.Csiz;
    // Creating resolutions and sub-bands for each component
    for (var c = 0; c < componentsCount; c++) {
      var component = tile.components[c];
      var decompositionLevelsCount =
        component.codingStyleParameters.decompositionLevelsCount;
      // Section B.5 Resolution levels and sub-bands
      var resolutions = [];
      var subbands = [];
      for (var r = 0; r <= decompositionLevelsCount; r++) {
        var blocksDimensions = getBlocksDimensions(context, component, r);
        var resolution = {};
        var scale = 1 << (decompositionLevelsCount - r);
        resolution.trx0 = Math.ceil(component.tcx0 / scale);
        resolution.try0 = Math.ceil(component.tcy0 / scale);
        resolution.trx1 = Math.ceil(component.tcx1 / scale);
        resolution.try1 = Math.ceil(component.tcy1 / scale);
        resolution.resLevel = r;
        buildPrecincts(context, resolution, blocksDimensions);
        resolutions.push(resolution);

        var subband;
        if (r === 0) {
          // one sub-band (LL) with last decomposition
          subband = {};
          subband.type = 'LL';
          subband.tbx0 = Math.ceil(component.tcx0 / scale);
          subband.tby0 = Math.ceil(component.tcy0 / scale);
          subband.tbx1 = Math.ceil(component.tcx1 / scale);
          subband.tby1 = Math.ceil(component.tcy1 / scale);
          subband.resolution = resolution;
          buildCodeblocks(context, subband, blocksDimensions);
          subbands.push(subband);
          resolution.subbands = [subband];
        } else {
          var bscale = 1 << (decompositionLevelsCount - r + 1);
          var resolutionSubbands = [];
          // three sub-bands (HL, LH and HH) with rest of decompositions
          subband = {};
          subband.type = 'HL';
          subband.tbx0 = Math.ceil(component.tcx0 / bscale - 0.5);
          subband.tby0 = Math.ceil(component.tcy0 / bscale);
          subband.tbx1 = Math.ceil(component.tcx1 / bscale - 0.5);
          subband.tby1 = Math.ceil(component.tcy1 / bscale);
          subband.resolution = resolution;
          buildCodeblocks(context, subband, blocksDimensions);
          subbands.push(subband);
          resolutionSubbands.push(subband);

          subband = {};
          subband.type = 'LH';
          subband.tbx0 = Math.ceil(component.tcx0 / bscale);
          subband.tby0 = Math.ceil(component.tcy0 / bscale - 0.5);
          subband.tbx1 = Math.ceil(component.tcx1 / bscale);
          subband.tby1 = Math.ceil(component.tcy1 / bscale - 0.5);
          subband.resolution = resolution;
          buildCodeblocks(context, subband, blocksDimensions);
          subbands.push(subband);
          resolutionSubbands.push(subband);

          subband = {};
          subband.type = 'HH';
          subband.tbx0 = Math.ceil(component.tcx0 / bscale - 0.5);
          subband.tby0 = Math.ceil(component.tcy0 / bscale - 0.5);
          subband.tbx1 = Math.ceil(component.tcx1 / bscale - 0.5);
          subband.tby1 = Math.ceil(component.tcy1 / bscale - 0.5);
          subband.resolution = resolution;
          buildCodeblocks(context, subband, blocksDimensions);
          subbands.push(subband);
          resolutionSubbands.push(subband);

          resolution.subbands = resolutionSubbands;
        }
      }
      component.resolutions = resolutions;
      component.subbands = subbands;
    }
    // Generate the packets sequence
    var progressionOrder = tile.codingStyleDefaultParameters.progressionOrder;
    switch (progressionOrder) {
      case 0:
        tile.packetsIterator =
          new LayerResolutionComponentPositionIterator(context);
        break;
      case 1:
        tile.packetsIterator =
          new ResolutionLayerComponentPositionIterator(context);
        break;
      case 2:
        tile.packetsIterator =
          new ResolutionPositionComponentLayerIterator(context);
        break;
      case 3:
        tile.packetsIterator =
          new PositionComponentResolutionLayerIterator(context);
        break;
      case 4:
        tile.packetsIterator =
          new ComponentPositionResolutionLayerIterator(context);
        break;
      default:
        throw new Error('JPX Error: Unsupported progression order ' +
                        progressionOrder);
    }
  }
  function parseTilePackets(context, data, offset, dataLength) {
    var position = 0;
    var buffer, bufferSize = 0, skipNextBit = false;
    function readBits(count) {
      while (bufferSize < count) {
        if(offset + position  >= data.length){
          throw new Error("Unexpected EOF");
        }
        var b = data[offset + position];
        position++;
        if (skipNextBit) {
          buffer = (buffer << 7) | b;
          bufferSize += 7;
          skipNextBit = false;
        } else {
          buffer = (buffer << 8) | b;
          bufferSize += 8;
        }
        if (b === 0xFF) {
          skipNextBit = true;
        }
      }
      bufferSize -= count;
      return (buffer >>> bufferSize) & ((1 << count) - 1);
    }
    function skipMarkerIfEqual(value) {
      if (data[offset + position - 1] === 0xFF &&
          data[offset + position] === value) {
        skipBytes(1);
        return true;
      } else if (data[offset + position] === 0xFF &&
                 data[offset + position + 1] === value) {
        skipBytes(2);
        return true;
      }
      return false;
    }
    function skipBytes(count) {
      position += count;
    }
    function alignToByte() {
      bufferSize = 0;
      if (skipNextBit) {
        position++;
        skipNextBit = false;
      }
    }
    function readCodingpasses() {
      if (readBits(1) === 0) {
        return 1;
      }
      if (readBits(1) === 0) {
        return 2;
      }
      var value = readBits(2);
      if (value < 3) {
        return value + 3;
      }
      value = readBits(5);
      if (value < 31) {
        return value + 6;
      }
      value = readBits(7);
      return value + 37;
    }
    var tileIndex = context.currentTile.index;
    var tile = context.tiles[tileIndex];
    var sopMarkerUsed = context.COD.sopMarkerUsed;
    var ephMarkerUsed = context.COD.ephMarkerUsed;
    var packetsIterator = tile.packetsIterator;
    while (position < dataLength) {
      try{
        alignToByte();
        if (sopMarkerUsed && skipMarkerIfEqual(0x91)) {
          // Skip also marker segment length and packet sequence ID
          skipBytes(4);
        }
        var packet = packetsIterator.nextPacket();
        if (packet === undefined) {
          //No more packets. Stream is probably truncated.
          return;
        }
        if (!readBits(1)) {
          continue;
        }
        var layerNumber = packet.layerNumber;
        var queue = [], codeblock;
        for (var i = 0, ii = packet.codeblocks.length; i < ii; i++) {
          codeblock = packet.codeblocks[i];
          var precinct = codeblock.precinct;
          var codeblockColumn = codeblock.cbx - precinct.cbxMin;
          var codeblockRow = codeblock.cby - precinct.cbyMin;
          var codeblockIncluded = false;
          var firstTimeInclusion = false;
          var valueReady;
          if (codeblock['included'] !== undefined) {
            codeblockIncluded = !!readBits(1);
          } else {
            // reading inclusion tree
            precinct = codeblock.precinct;
            var inclusionTree, zeroBitPlanesTree;
            if (precinct['inclusionTree'] !== undefined) {
              inclusionTree = precinct.inclusionTree;
            } else {
              // building inclusion and zero bit-planes trees
              var width = precinct.cbxMax - precinct.cbxMin + 1;
              var height = precinct.cbyMax - precinct.cbyMin + 1;
              inclusionTree = new InclusionTree(width, height);
              zeroBitPlanesTree = new TagTree(width, height);
              precinct.inclusionTree = inclusionTree;
              precinct.zeroBitPlanesTree = zeroBitPlanesTree;
            }

            inclusionTree.reset(codeblockColumn, codeblockRow, layerNumber);
            while (true) {
              if (position >= data.length) {
                return;
              }
              if (inclusionTree.isAboveThreshold()){
                break;
              }
              if (inclusionTree.isKnown()) {
                inclusionTree.nextLevel();
                continue;
              }
              if (readBits(1)) {
                inclusionTree.setKnown();
                if (inclusionTree.isLeaf()) {
                  codeblock.included = true;
                  codeblockIncluded = firstTimeInclusion = true;
                  break;
                } else {
                  inclusionTree.nextLevel();
                }
              } else {
                inclusionTree.incrementValue();
              }
            }
          }
          if (!codeblockIncluded) {
            continue;
          }
          if (firstTimeInclusion) {
            zeroBitPlanesTree = precinct.zeroBitPlanesTree;
            zeroBitPlanesTree.reset(codeblockColumn, codeblockRow);
            while (true) {
              if (position >= data.length) {
                return;
              }
              if (readBits(1)) {
                valueReady = !zeroBitPlanesTree.nextLevel();
                if (valueReady) {
                  break;
                }
              } else {
                zeroBitPlanesTree.incrementValue();
              }
            }
            codeblock.zeroBitPlanes = zeroBitPlanesTree.value;
          }
          var codingpasses = readCodingpasses();
          while (readBits(1)) {
            codeblock.Lblock++;
          }
          var codingpassesLog2 = log2(codingpasses);
          // rounding down log2
          var bits = ((codingpasses < (1 << codingpassesLog2)) ?
                      codingpassesLog2 - 1 : codingpassesLog2) + codeblock.Lblock;
          var codedDataLength = readBits(bits);
          queue.push({
            codeblock: codeblock,
            codingpasses: codingpasses,
            dataLength: codedDataLength
          });
        }
        alignToByte();
        if (ephMarkerUsed) {
          skipMarkerIfEqual(0x92);
        }
        while (queue.length > 0) {
          var packetItem = queue.shift();
          codeblock = packetItem.codeblock;
          if (codeblock['data'] === undefined) {
            codeblock.data = [];
          }
          codeblock.data.push({
            data: data,
            start: offset + position,
            end: offset + position + packetItem.dataLength,
            codingpasses: packetItem.codingpasses
          });
          position += packetItem.dataLength;
        }
      } catch (e) {
        return;
      }
    }
    return position;
  }
  function copyCoefficients(coefficients, levelWidth, levelHeight, subband,
                            delta, mb, reversible, segmentationSymbolUsed) {
    var x0 = subband.tbx0;
    var y0 = subband.tby0;
    var width = subband.tbx1 - subband.tbx0;
    var codeblocks = subband.codeblocks;
    var right = subband.type.charAt(0) === 'H' ? 1 : 0;
    var bottom = subband.type.charAt(1) === 'H' ? levelWidth : 0;

    for (var i = 0, ii = codeblocks.length; i < ii; ++i) {
      var codeblock = codeblocks[i];
      var blockWidth = codeblock.tbx1_ - codeblock.tbx0_;
      var blockHeight = codeblock.tby1_ - codeblock.tby0_;
      if (blockWidth === 0 || blockHeight === 0) {
        continue;
      }
      if (codeblock['data'] === undefined) {
        continue;
      }

      var bitModel, currentCodingpassType;
      bitModel = new BitModel(blockWidth, blockHeight, codeblock.subbandType,
                              codeblock.zeroBitPlanes, mb);
      currentCodingpassType = 2; // first bit plane starts from cleanup

      // collect data
      var data = codeblock.data, totalLength = 0, codingpasses = 0;
      var j, jj, dataItem;
      for (j = 0, jj = data.length; j < jj; j++) {
        dataItem = data[j];
        totalLength += dataItem.end - dataItem.start;
        codingpasses += dataItem.codingpasses;
      }
      var encodedData = new Int16Array(totalLength);
      var position = 0;
      for (j = 0, jj = data.length; j < jj; j++) {
        dataItem = data[j];
        var chunk = dataItem.data.subarray(dataItem.start, dataItem.end);
        encodedData.set(chunk, position);
        position += chunk.length;
      }
      // decoding the item
      var decoder = new ArithmeticDecoder(encodedData, 0, totalLength);
      bitModel.setDecoder(decoder);

      for (j = 0; j < codingpasses; j++) {
        switch (currentCodingpassType) {
          case 0:
            bitModel.runSignificancePropogationPass();
            break;
          case 1:
            bitModel.runMagnitudeRefinementPass();
            break;
          case 2:
            bitModel.runCleanupPass();
            if (segmentationSymbolUsed) {
              bitModel.checkSegmentationSymbol();
            }
            break;
        }
        currentCodingpassType = (currentCodingpassType + 1) % 3;
      }

      var offset = (codeblock.tbx0_ - x0) + (codeblock.tby0_ - y0) * width;
      var sign = bitModel.coefficentsSign;
      var magnitude = bitModel.coefficentsMagnitude;
      var bitsDecoded = bitModel.bitsDecoded;
      var magnitudeCorrection = reversible ? 0 : 0.5;
      var k, n, nb;
      position = 0;
      // Do the interleaving of Section F.3.3 here, so we do not need
      // to copy later. LL level is not interleaved, just copied.
      var interleave = (subband.type !== 'LL');
      for (j = 0; j < blockHeight; j++) {
        var row = (offset / width) | 0; // row in the non-interleaved subband
        var levelOffset = 2 * row * (levelWidth - width) + right + bottom;
        for (k = 0; k < blockWidth; k++) {
          n = magnitude[position];
          if (n !== 0) {
            n = (n + magnitudeCorrection) * delta;
            if (sign[position] !== 0) {
              n = -n;
            }
            nb = bitsDecoded[position];
            var pos = interleave ? (levelOffset + (offset << 1)) : offset;
            if (reversible && (nb >= mb)) {
              coefficients[pos] = n;
            } else {
              coefficients[pos] = n * (1 << (mb - nb));
            }
          }
          offset++;
          position++;
        }
        offset += width - blockWidth;
      }
    }
  }
  function transformTile(context, tile, c) {
    var component = tile.components[c];
    var codingStyleParameters = component.codingStyleParameters;
    var quantizationParameters = component.quantizationParameters;
    var decompositionLevelsCount =
      codingStyleParameters.decompositionLevelsCount;
    var spqcds = quantizationParameters.SPqcds;
    var scalarExpounded = quantizationParameters.scalarExpounded;
    var guardBits = quantizationParameters.guardBits;
    var segmentationSymbolUsed = codingStyleParameters.segmentationSymbolUsed;
    var precision = context.components[c].precision;

    var reversible = codingStyleParameters.reversibleTransformation;
    var transform = (reversible ? new ReversibleTransform() :
                                  new IrreversibleTransform());

    var subbandCoefficients = [];
    var b = 0;
    for (var i = 0; i <= decompositionLevelsCount; i++) {
      var resolution = component.resolutions[i];

      var width = resolution.trx1 - resolution.trx0;
      var height = resolution.try1 - resolution.try0;
      // Allocate space for the whole sublevel.
      var coefficients = new Float32Array(width * height);

      for (var j = 0, jj = resolution.subbands.length; j < jj; j++) {
        var mu, epsilon;
        if (!scalarExpounded) {
          // formula E-5
          mu = spqcds[0].mu;
          epsilon = spqcds[0].epsilon + (i > 0 ? 1 - i : 0);
        } else {
          mu = spqcds[b].mu;
          epsilon = spqcds[b].epsilon;
          b++;
        }

        var subband = resolution.subbands[j];
        var gainLog2 = SubbandsGainLog2[subband.type];

        // calulate quantization coefficient (Section E.1.1.1)
        var delta = (reversible ? 1 :
          Math.pow(2, precision + gainLog2 - epsilon) * (1 + mu / 2048));
        var mb = (guardBits + epsilon - 1);

        // In the first resolution level, copyCoefficients will fill the
        // whole array with coefficients. In the succeding passes,
        // copyCoefficients will consecutively fill in the values that belong
        // to the interleaved positions of the HL, LH, and HH coefficients.
        // The LL coefficients will then be interleaved in Transform.iterate().
        copyCoefficients(coefficients, width, height, subband, delta, mb,
                         reversible, segmentationSymbolUsed);
      }
      subbandCoefficients.push({
        width: width,
        height: height,
        items: coefficients
      });
    }

    var result = transform.calculate(subbandCoefficients,
                                     component.tcx0, component.tcy0);
    return {
      left: component.tcx0,
      top: component.tcy0,
      width: result.width,
      height: result.height,
      items: result.items
    };
  }
  function transformComponents(context) {
    var siz = context.SIZ;
    var components = context.components;
    var componentsCount = siz.Csiz;
    var resultImages = [];
    for (var i = 0, ii = context.tiles.length; i < ii; i++) {
      var tile = context.tiles[i];
      var transformedTiles = [];
      var c;
      for (c = 0; c < componentsCount; c++) {
        transformedTiles[c] = transformTile(context, tile, c);
      }
      var tile0 = transformedTiles[0];
      var isSigned = components[0].isSigned;
      if (isSigned) {
        var out = new Int16Array(tile0.items.length * componentsCount);
      } else {
        var out = new Uint16Array(tile0.items.length * componentsCount);
      }
      var result = {
        left: tile0.left,
        top: tile0.top,
        width: tile0.width,
        height: tile0.height,
        items: out
      };

      // Section G.2.2 Inverse multi component transform
      var shift, offset, max, min, maxK;
      var pos = 0, j, jj, y0, y1, y2, r, g, b, k, val;
      if (tile.codingStyleDefaultParameters.multipleComponentTransform) {
        var fourComponents = componentsCount === 4;
        var y0items = transformedTiles[0].items;
        var y1items = transformedTiles[1].items;
        var y2items = transformedTiles[2].items;
        var y3items = fourComponents ? transformedTiles[3].items : null;

        // HACK: The multiple component transform formulas below assume that
        // all components have the same precision. With this in mind, we
        // compute shift and offset only once.
        shift = components[0].precision - 8;
        offset = (128 << shift) + 0.5;
        max = 255 * (1 << shift);
        maxK = max * 0.5;
        min = -maxK;

        var component0 = tile.components[0];
        var alpha01 = componentsCount - 3;
        jj = y0items.length;
        if (!component0.codingStyleParameters.reversibleTransformation) {
          // inverse irreversible multiple component transform
          for (j = 0; j < jj; j++, pos += alpha01) {
            y0 = y0items[j] + offset;
            y1 = y1items[j];
            y2 = y2items[j];
            r = y0 + 1.402 * y2;
            g = y0 - 0.34413 * y1 - 0.71414 * y2;
            b = y0 + 1.772 * y1;
            out[pos++] = r <= 0 ? 0 : r >= max ? 255 : r >> shift;
            out[pos++] = g <= 0 ? 0 : g >= max ? 255 : g >> shift;
            out[pos++] = b <= 0 ? 0 : b >= max ? 255 : b >> shift;
          }
        } else {
          // inverse reversible multiple component transform
          for (j = 0; j < jj; j++, pos += alpha01) {
            y0 = y0items[j] + offset;
            y1 = y1items[j];
            y2 = y2items[j];
            g = y0 - ((y2 + y1) >> 2);
            r = g + y2;
            b = g + y1;
            out[pos++] = r <= 0 ? 0 : r >= max ? 255 : r >> shift;
            out[pos++] = g <= 0 ? 0 : g >= max ? 255 : g >> shift;
            out[pos++] = b <= 0 ? 0 : b >= max ? 255 : b >> shift;
          }
        }
        if (fourComponents) {
          for (j = 0, pos = 3; j < jj; j++, pos += 4) {
            k = y3items[j];
            out[pos] = k <= min ? 0 : k >= maxK ? 255 : (k + offset) >> shift;
          }
        }
      } else { // no multi-component transform
        for (c = 0; c < componentsCount; c++) {
          if (components[c].precision === 8){
            var items = transformedTiles[c].items;
            shift = components[c].precision - 8;
            offset = (128 << shift) + 0.5;
            max = (127.5 * (1 << shift));
            min = -max;
            for (pos = c, j = 0, jj = items.length; j < jj; j++) {
              val = items[j];
              out[pos] = val <= min ? 0 :
                         val >= max ? 255 : (val + offset) >> shift;
              pos += componentsCount;
            }
          }else{
            var isSigned = components[c].isSigned;
            var items = transformedTiles[c].items;

            if(isSigned){
              for (pos = c, j = 0, jj = items.length; j < jj; j++) {
                out[pos] = items[j];
                pos += componentsCount;
              }
            }else{
              shift = components[c].precision - 8;
              offset = (128 << shift) + 0.5;
              var precisionMax = Math.pow(2,components[c].precision)-1;
              for (pos = c, j = 0, jj = items.length; j < jj; j++) {
                val = items[j];
                out[pos] = Math.max(Math.min((val + offset),precisionMax),0);
                pos += componentsCount;
              }
            }
          }
        }
      }
      resultImages.push(result);
    }
    return resultImages;
  }
  function initializeTile(context, tileIndex) {
    var siz = context.SIZ;
    var componentsCount = siz.Csiz;
    var tile = context.tiles[tileIndex];
    for (var c = 0; c < componentsCount; c++) {
      var component = tile.components[c];
      var qcdOrQcc = (context.currentTile.QCC[c] !== undefined ?
        context.currentTile.QCC[c] : context.currentTile.QCD);
      component.quantizationParameters = qcdOrQcc;
      var codOrCoc = (context.currentTile.COC[c] !== undefined  ?
        context.currentTile.COC[c] : context.currentTile.COD);
      component.codingStyleParameters = codOrCoc;
    }
    tile.codingStyleDefaultParameters = context.currentTile.COD;
  }

  // Section B.10.2 Tag trees
  var TagTree = (function TagTreeClosure() {
    function TagTree(width, height) {
      var levelsLength = log2(Math.max(width, height)) + 1;
      this.levels = [];
      for (var i = 0; i < levelsLength; i++) {
        var level = {
          width: width,
          height: height,
          items: []
        };
        this.levels.push(level);
        width = Math.ceil(width / 2);
        height = Math.ceil(height / 2);
      }
    }
    TagTree.prototype = {
      reset: function TagTree_reset(i, j) {
        var currentLevel = 0, value = 0, level;
        while (currentLevel < this.levels.length) {
          level = this.levels[currentLevel];
          var index = i + j * level.width;
          if (level.items[index] !== undefined) {
            value = level.items[index];
            break;
          }
          level.index = index;
          i >>= 1;
          j >>= 1;
          currentLevel++;
        }
        currentLevel--;
        level = this.levels[currentLevel];
        level.items[level.index] = value;
        this.currentLevel = currentLevel;
        delete this.value;
      },
      incrementValue: function TagTree_incrementValue() {
        var level = this.levels[this.currentLevel];
        level.items[level.index]++;
      },
      nextLevel: function TagTree_nextLevel() {
        var currentLevel = this.currentLevel;
        var level = this.levels[currentLevel];
        var value = level.items[level.index];
        currentLevel--;
        if (currentLevel < 0) {
          this.value = value;
          return false;
        }

        this.currentLevel = currentLevel;
        level = this.levels[currentLevel];
        level.items[level.index] = value;
        return true;
      }
    };
    return TagTree;
  })();

  var InclusionTree = (function InclusionTreeClosure() {
    function InclusionTree(width, height) {
      var levelsLength = log2(Math.max(width, height)) + 1;
      this.levels = [];
      for (var i = 0; i < levelsLength; i++) {
        var items = new Uint8Array(width * height);
        var status = new Uint8Array(width * height);
        for (var j = 0, jj = items.length; j < jj; j++) {
          items[j] = 0;
          status[j] = 0;
        }

        var level = {
          width: width,
          height: height,
          items: items,
          status: status
        };
        this.levels.push(level);

        width = Math.ceil(width / 2);
        height = Math.ceil(height / 2);
      }
    }
    InclusionTree.prototype = {
      reset: function InclusionTree_reset(i, j, stopValue) {
        this.currentStopValue = stopValue;
        var currentLevel = 0;
        while (currentLevel < this.levels.length) {
          var level = this.levels[currentLevel];
          var index = i + j * level.width;
          level.index = index;

          i >>= 1;
          j >>= 1;
          currentLevel++;
        }

        this.currentLevel = this.levels.length - 1;
        this.minValue =this.levels[this.currentLevel].items[0];
        return;
      },
      incrementValue: function InclusionTree_incrementValue() {
        var level = this.levels[this.currentLevel];
        level.items[level.index] = level.items[level.index] + 1;
        if(level.items[level.index] > this.minValue) {
          this.minValue = level.items[level.index];
        }
      },
      nextLevel: function InclusionTree_nextLevel() {
        var currentLevel = this.currentLevel;
        currentLevel--;
        if (currentLevel < 0) {
          return false;
        } else {
          this.currentLevel = currentLevel;
          var level = this.levels[currentLevel];
          if(level.items[level.index] < this.minValue) {
            level.items[level.index] = this.minValue;
          }else if (level.items[level.index] > this.minValue) {
            this.minValue = level.items[level.index];
          }
          return true;
        }
      },
    isLeaf: function InclusionTree_isLeaf(){
      return (this.currentLevel === 0);
    },
    isAboveThreshold: function InclusionTree_isAboveThreshold(){
      var levelindex = this.currentLevel;
      var level = this.levels[levelindex];
      return (level.items[level.index] > this.currentStopValue);
    },
    isKnown: function InclusionTree_isKnown(){
      var levelindex = this.currentLevel;
      var level = this.levels[levelindex];
      return (level.status[level.index] > 0);
    },
    setKnown: function InclusionTree_setKnown(){
      var levelindex = this.currentLevel;
      var level = this.levels[levelindex];
      level.status[level.index] = 1;
      return;
    }

    };
    return InclusionTree;
  })();

  // Section D. Coefficient bit modeling
  var BitModel = (function BitModelClosure() {
    var UNIFORM_CONTEXT = 17;
    var RUNLENGTH_CONTEXT = 18;
    // Table D-1
    // The index is binary presentation: 0dddvvhh, ddd - sum of Di (0..4),
    // vv - sum of Vi (0..2), and hh - sum of Hi (0..2)
    var LLAndLHContextsLabel = new Uint8Array([
      0, 5, 8, 0, 3, 7, 8, 0, 4, 7, 8, 0, 0, 0, 0, 0, 1, 6, 8, 0, 3, 7, 8, 0, 4,
      7, 8, 0, 0, 0, 0, 0, 2, 6, 8, 0, 3, 7, 8, 0, 4, 7, 8, 0, 0, 0, 0, 0, 2, 6,
      8, 0, 3, 7, 8, 0, 4, 7, 8, 0, 0, 0, 0, 0, 2, 6, 8, 0, 3, 7, 8, 0, 4, 7, 8
    ]);
    var HLContextLabel = new Uint8Array([
      0, 3, 4, 0, 5, 7, 7, 0, 8, 8, 8, 0, 0, 0, 0, 0, 1, 3, 4, 0, 6, 7, 7, 0, 8,
      8, 8, 0, 0, 0, 0, 0, 2, 3, 4, 0, 6, 7, 7, 0, 8, 8, 8, 0, 0, 0, 0, 0, 2, 3,
      4, 0, 6, 7, 7, 0, 8, 8, 8, 0, 0, 0, 0, 0, 2, 3, 4, 0, 6, 7, 7, 0, 8, 8, 8
    ]);
    var HHContextLabel = new Uint8Array([
      0, 1, 2, 0, 1, 2, 2, 0, 2, 2, 2, 0, 0, 0, 0, 0, 3, 4, 5, 0, 4, 5, 5, 0, 5,
      5, 5, 0, 0, 0, 0, 0, 6, 7, 7, 0, 7, 7, 7, 0, 7, 7, 7, 0, 0, 0, 0, 0, 8, 8,
      8, 0, 8, 8, 8, 0, 8, 8, 8, 0, 0, 0, 0, 0, 8, 8, 8, 0, 8, 8, 8, 0, 8, 8, 8
    ]);

    function BitModel(width, height, subband, zeroBitPlanes, mb) {
      this.width = width;
      this.height = height;

      this.contextLabelTable = (subband === 'HH' ? HHContextLabel :
        (subband === 'HL' ? HLContextLabel : LLAndLHContextsLabel));

      var coefficientCount = width * height;

      // coefficients outside the encoding region treated as insignificant
      // add border state cells for significanceState
      this.neighborsSignificance = new Uint8Array(coefficientCount);
      this.coefficentsSign = new Uint8Array(coefficientCount);
      this.coefficentsMagnitude = mb > 14 ? new Uint32Array(coefficientCount) :
                                  mb > 6 ? new Uint16Array(coefficientCount) :
                                  new Uint8Array(coefficientCount);
      this.processingFlags = new Uint8Array(coefficientCount);

      var bitsDecoded = new Uint8Array(coefficientCount);
      if (zeroBitPlanes !== 0) {
        for (var i = 0; i < coefficientCount; i++) {
          bitsDecoded[i] = zeroBitPlanes;
        }
      }
      this.bitsDecoded = bitsDecoded;

      this.reset();
    }

    BitModel.prototype = {
      setDecoder: function BitModel_setDecoder(decoder) {
        this.decoder = decoder;
      },
      reset: function BitModel_reset() {
        // We have 17 contexts that are accessed via context labels,
        // plus the uniform and runlength context.
        this.contexts = new Int8Array(19);

        // Contexts are packed into 1 byte:
        // highest 7 bits carry the index, lowest bit carries mps
        this.contexts[0] = (4 << 1) | 0;
        this.contexts[UNIFORM_CONTEXT] = (46 << 1) | 0;
        this.contexts[RUNLENGTH_CONTEXT] = (3 << 1) | 0;
      },
      setNeighborsSignificance:
        function BitModel_setNeighborsSignificance(row, column, index) {
        var neighborsSignificance = this.neighborsSignificance;
        var width = this.width, height = this.height;
        var left = (column > 0);
        var right = (column + 1 < width);
        var i;

        if (row > 0) {
          i = index - width;
          if (left) {
            neighborsSignificance[i - 1] += 0x10;
          }
          if (right) {
            neighborsSignificance[i + 1] += 0x10;
          }
          neighborsSignificance[i] += 0x04;
        }

        if (row + 1 < height) {
          i = index + width;
          if (left) {
            neighborsSignificance[i - 1] += 0x10;
          }
          if (right) {
            neighborsSignificance[i + 1] += 0x10;
          }
          neighborsSignificance[i] += 0x04;
        }

        if (left) {
          neighborsSignificance[index - 1] += 0x01;
        }
        if (right) {
          neighborsSignificance[index + 1] += 0x01;
        }
        neighborsSignificance[index] |= 0x80;
      },
      runSignificancePropogationPass:
        function BitModel_runSignificancePropogationPass() {
        var decoder = this.decoder;
        var width = this.width, height = this.height;
        var coefficentsMagnitude = this.coefficentsMagnitude;
        var coefficentsSign = this.coefficentsSign;
        var neighborsSignificance = this.neighborsSignificance;
        var processingFlags = this.processingFlags;
        var contexts = this.contexts;
        var labels = this.contextLabelTable;
        var bitsDecoded = this.bitsDecoded;
        var processedInverseMask = ~1;
        var processedMask = 1;
        var firstMagnitudeBitMask = 2;

        for (var i0 = 0; i0 < height; i0 += 4) {
          for (var j = 0; j < width; j++) {
            var index = i0 * width + j;
            for (var i1 = 0; i1 < 4; i1++, index += width) {
              var i = i0 + i1;
              if (i >= height) {
                break;
              }
              // clear processed flag first
              processingFlags[index] &= processedInverseMask;

              if (coefficentsMagnitude[index] ||
                  !neighborsSignificance[index]) {
                continue;
              }

              var contextLabel = labels[neighborsSignificance[index]];
              var decision = decoder.readBit(contexts, contextLabel);
              if (decision) {
                var sign = this.decodeSignBit(i, j, index);
                coefficentsSign[index] = sign;
                coefficentsMagnitude[index] = 1;
                this.setNeighborsSignificance(i, j, index);
                processingFlags[index] |= firstMagnitudeBitMask;
              }
              bitsDecoded[index]++;
              processingFlags[index] |= processedMask;
            }
          }
        }
      },
      decodeSignBit: function BitModel_decodeSignBit(row, column, index) {
        var width = this.width, height = this.height;
        var coefficentsMagnitude = this.coefficentsMagnitude;
        var coefficentsSign = this.coefficentsSign;
        var contribution, sign0, sign1, significance1;
        var contextLabel, decoded;

        // calculate horizontal contribution
        significance1 = (column > 0 && coefficentsMagnitude[index - 1] !== 0);
        if (column + 1 < width && coefficentsMagnitude[index + 1] !== 0) {
          sign1 = coefficentsSign[index + 1];
          if (significance1) {
            sign0 = coefficentsSign[index - 1];
            contribution = 1 - sign1 - sign0;
          } else {
            contribution = 1 - sign1 - sign1;
          }
        } else if (significance1) {
          sign0 = coefficentsSign[index - 1];
          contribution = 1 - sign0 - sign0;
        } else {
          contribution = 0;
        }
        var horizontalContribution = 3 * contribution;

        // calculate vertical contribution and combine with the horizontal
        significance1 = (row > 0 && coefficentsMagnitude[index - width] !== 0);
        if (row + 1 < height && coefficentsMagnitude[index + width] !== 0) {
          sign1 = coefficentsSign[index + width];
          if (significance1) {
            sign0 = coefficentsSign[index - width];
            contribution = 1 - sign1 - sign0 + horizontalContribution;
          } else {
            contribution = 1 - sign1 - sign1 + horizontalContribution;
          }
        } else if (significance1) {
          sign0 = coefficentsSign[index - width];
          contribution = 1 - sign0 - sign0 + horizontalContribution;
        } else {
          contribution = horizontalContribution;
        }

        if (contribution >= 0) {
          contextLabel = 9 + contribution;
          decoded = this.decoder.readBit(this.contexts, contextLabel);
        } else {
          contextLabel = 9 - contribution;
          decoded = this.decoder.readBit(this.contexts, contextLabel) ^ 1;
        }
        return decoded;
      },
      runMagnitudeRefinementPass:
        function BitModel_runMagnitudeRefinementPass() {
        var decoder = this.decoder;
        var width = this.width, height = this.height;
        var coefficentsMagnitude = this.coefficentsMagnitude;
        var neighborsSignificance = this.neighborsSignificance;
        var contexts = this.contexts;
        var bitsDecoded = this.bitsDecoded;
        var processingFlags = this.processingFlags;
        var processedMask = 1;
        var firstMagnitudeBitMask = 2;
        var length = width * height;
        var width4 = width * 4;

        for (var index0 = 0, indexNext; index0 < length; index0 = indexNext) {
          indexNext = Math.min(length, index0 + width4);
          for (var j = 0; j < width; j++) {
            for (var index = index0 + j; index < indexNext; index += width) {

              // significant but not those that have just become
              if (!coefficentsMagnitude[index] ||
                (processingFlags[index] & processedMask) !== 0) {
                continue;
              }

              var contextLabel = 16;
              if ((processingFlags[index] & firstMagnitudeBitMask) !== 0) {
                processingFlags[index] ^= firstMagnitudeBitMask;
                // first refinement
               var significance = neighborsSignificance[index] & 127;
               contextLabel = significance === 0 ? 15 : 14;
              }

              var bit = decoder.readBit(contexts, contextLabel);
              coefficentsMagnitude[index] =
                (coefficentsMagnitude[index] << 1) | bit;
              bitsDecoded[index]++;
              processingFlags[index] |= processedMask;
            }
          }
        }
      },
      runCleanupPass: function BitModel_runCleanupPass() {
        var decoder = this.decoder;
        var width = this.width, height = this.height;
        var neighborsSignificance = this.neighborsSignificance;
        var coefficentsMagnitude = this.coefficentsMagnitude;
        var coefficentsSign = this.coefficentsSign;
        var contexts = this.contexts;
        var labels = this.contextLabelTable;
        var bitsDecoded = this.bitsDecoded;
        var processingFlags = this.processingFlags;
        var processedMask = 1;
        var firstMagnitudeBitMask = 2;
        var oneRowDown = width;
        var twoRowsDown = width * 2;
        var threeRowsDown = width * 3;
        var iNext;
        for (var i0 = 0; i0 < height; i0 = iNext) {
          iNext = Math.min(i0 + 4, height);
          var indexBase = i0 * width;
          var checkAllEmpty = i0 + 3 < height;
          for (var j = 0; j < width; j++) {
            var index0 = indexBase + j;
            // using the property: labels[neighborsSignificance[index]] === 0
            // when neighborsSignificance[index] === 0
            var allEmpty = (checkAllEmpty &&
              processingFlags[index0] === 0 &&
              processingFlags[index0 + oneRowDown] === 0 &&
              processingFlags[index0 + twoRowsDown] === 0 &&
              processingFlags[index0 + threeRowsDown] === 0 &&
              neighborsSignificance[index0] === 0 &&
              neighborsSignificance[index0 + oneRowDown] === 0 &&
              neighborsSignificance[index0 + twoRowsDown] === 0 &&
              neighborsSignificance[index0 + threeRowsDown] === 0);
            var i1 = 0, index = index0;
            var i = i0, sign;
            if (allEmpty) {
              var hasSignificantCoefficent =
                decoder.readBit(contexts, RUNLENGTH_CONTEXT);
              if (!hasSignificantCoefficent) {
                bitsDecoded[index0]++;
                bitsDecoded[index0 + oneRowDown]++;
                bitsDecoded[index0 + twoRowsDown]++;
                bitsDecoded[index0 + threeRowsDown]++;
                continue; // next column
              }
              i1 = (decoder.readBit(contexts, UNIFORM_CONTEXT) << 1) |
                    decoder.readBit(contexts, UNIFORM_CONTEXT);
              if (i1 !== 0) {
                i = i0 + i1;
                index += i1 * width;
              }

              sign = this.decodeSignBit(i, j, index);
              coefficentsSign[index] = sign;
              coefficentsMagnitude[index] = 1;
              this.setNeighborsSignificance(i, j, index);
              processingFlags[index] |= firstMagnitudeBitMask;

              index = index0;
              for (var i2 = i0; i2 <= i; i2++, index += width) {
                bitsDecoded[index]++;
              }

              i1++;
            }
            for (i = i0 + i1; i < iNext; i++, index += width) {
              if (coefficentsMagnitude[index] ||
                (processingFlags[index] & processedMask) !== 0) {
                continue;
              }

              var contextLabel = labels[neighborsSignificance[index]];
              var decision = decoder.readBit(contexts, contextLabel);
              if (decision === 1) {
                sign = this.decodeSignBit(i, j, index);
                coefficentsSign[index] = sign;
                coefficentsMagnitude[index] = 1;
                this.setNeighborsSignificance(i, j, index);
                processingFlags[index] |= firstMagnitudeBitMask;
              }
              bitsDecoded[index]++;
            }
          }
        }
      },
      checkSegmentationSymbol: function BitModel_checkSegmentationSymbol() {
        var decoder = this.decoder;
        var contexts = this.contexts;
        var symbol = (decoder.readBit(contexts, UNIFORM_CONTEXT) << 3) |
                     (decoder.readBit(contexts, UNIFORM_CONTEXT) << 2) |
                     (decoder.readBit(contexts, UNIFORM_CONTEXT) << 1) |
                      decoder.readBit(contexts, UNIFORM_CONTEXT);
        if (symbol !== 0xA) {
          throw new Error('JPX Error: Invalid segmentation symbol');
        }
      }
    };

    return BitModel;
  })();

  // Section F, Discrete wavelet transformation
  var Transform = (function TransformClosure() {
    function Transform() {}

    Transform.prototype.calculate =
      function transformCalculate(subbands, u0, v0) {
      var ll = subbands[0];
      for (var i = 1, ii = subbands.length; i < ii; i++) {
        ll = this.iterate(ll, subbands[i], u0, v0);
      }
      return ll;
    };
    Transform.prototype.extend = function extend(buffer, offset, size) {
      // Section F.3.7 extending... using max extension of 4
      var i1 = offset - 1, j1 = offset + 1;
      var i2 = offset + size - 2, j2 = offset + size;
      buffer[i1--] = buffer[j1++];
      buffer[j2++] = buffer[i2--];
      buffer[i1--] = buffer[j1++];
      buffer[j2++] = buffer[i2--];
      buffer[i1--] = buffer[j1++];
      buffer[j2++] = buffer[i2--];
      buffer[i1] = buffer[j1];
      buffer[j2] = buffer[i2];
    };
    Transform.prototype.iterate = function Transform_iterate(ll, hl_lh_hh,
                                                             u0, v0) {
      var llWidth = ll.width, llHeight = ll.height, llItems = ll.items;
      var width = hl_lh_hh.width;
      var height = hl_lh_hh.height;
      var items = hl_lh_hh.items;
      var i, j, k, l, u, v;

      // Interleave LL according to Section F.3.3
      for (k = 0, i = 0; i < llHeight; i++) {
        l = i * 2 * width;
        for (j = 0; j < llWidth; j++, k++, l += 2) {
          items[l] = llItems[k];
        }
      }
      // The LL band is not needed anymore.
      llItems = ll.items = null;

      var bufferPadding = 4;
      var rowBuffer = new Float32Array(width + 2 * bufferPadding);

      // Section F.3.4 HOR_SR
      if (width === 1) {
        // if width = 1, when u0 even keep items as is, when odd divide by 2
        if ((u0 & 1) !== 0) {
          for (v = 0, k = 0; v < height; v++, k += width) {
            items[k] *= 0.5;
          }
        }
      } else {
        for (v = 0, k = 0; v < height; v++, k += width) {
          rowBuffer.set(items.subarray(k, k + width), bufferPadding);

          this.extend(rowBuffer, bufferPadding, width);
          this.filter(rowBuffer, bufferPadding, width);

          items.set(
            rowBuffer.subarray(bufferPadding, bufferPadding + width),
            k);
        }
      }

      // Accesses to the items array can take long, because it may not fit into
      // CPU cache and has to be fetched from main memory. Since subsequent
      // accesses to the items array are not local when reading columns, we
      // have a cache miss every time. To reduce cache misses, get up to
      // 'numBuffers' items at a time and store them into the individual
      // buffers. The colBuffers should be small enough to fit into CPU cache.
      var numBuffers = 16;
      var colBuffers = [];
      for (i = 0; i < numBuffers; i++) {
        colBuffers.push(new Float32Array(height + 2 * bufferPadding));
      }
      var b, currentBuffer = 0;
      ll = bufferPadding + height;

      // Section F.3.5 VER_SR
      if (height === 1) {
          // if height = 1, when v0 even keep items as is, when odd divide by 2
        if ((v0 & 1) !== 0) {
          for (u = 0; u < width; u++) {
            items[u] *= 0.5;
          }
        }
      } else {
        for (u = 0; u < width; u++) {
          // if we ran out of buffers, copy several image columns at once
          if (currentBuffer === 0) {
            numBuffers = Math.min(width - u, numBuffers);
            for (k = u, l = bufferPadding; l < ll; k += width, l++) {
              for (b = 0; b < numBuffers; b++) {
                colBuffers[b][l] = items[k + b];
              }
            }
            currentBuffer = numBuffers;
          }

          currentBuffer--;
          var buffer = colBuffers[currentBuffer];
          this.extend(buffer, bufferPadding, height);
          this.filter(buffer, bufferPadding, height);

          // If this is last buffer in this group of buffers, flush all buffers.
          if (currentBuffer === 0) {
            k = u - numBuffers + 1;
            for (l = bufferPadding; l < ll; k += width, l++) {
              for (b = 0; b < numBuffers; b++) {
                items[k + b] = colBuffers[b][l];
              }
            }
          }
        }
      }

      return {
        width: width,
        height: height,
        items: items
      };
    };
    return Transform;
  })();

  // Section 3.8.2 Irreversible 9-7 filter
  var IrreversibleTransform = (function IrreversibleTransformClosure() {
    function IrreversibleTransform() {
      Transform.call(this);
    }

    IrreversibleTransform.prototype = Object.create(Transform.prototype);
    IrreversibleTransform.prototype.filter =
      function irreversibleTransformFilter(x, offset, length) {
      var len = length >> 1;
      offset = offset | 0;
      var j, n, current, next;

      var alpha = -1.586134342059924;
      var beta = -0.052980118572961;
      var gamma = 0.882911075530934;
      var delta = 0.443506852043971;
      var K = 1.230174104914001;
      var K_ = 1 / K;

      // step 1 is combined with step 3

      // step 2
      j = offset - 3;
      for (n = len + 4; n--; j += 2) {
        x[j] *= K_;
      }

      // step 1 & 3
      j = offset - 2;
      current = delta * x[j -1];
      for (n = len + 3; n--; j += 2) {
        next = delta * x[j + 1];
        x[j] = K * x[j] - current - next;
        if (n--) {
          j += 2;
          current = delta * x[j + 1];
          x[j] = K * x[j] - current - next;
        } else {
          break;
        }
      }

      // step 4
      j = offset - 1;
      current = gamma * x[j - 1];
      for (n = len + 2; n--; j += 2) {
        next = gamma * x[j + 1];
        x[j] -= current + next;
        if (n--) {
          j += 2;
          current = gamma * x[j + 1];
          x[j] -= current + next;
        } else {
          break;
        }
      }

      // step 5
      j = offset;
      current = beta * x[j - 1];
      for (n = len + 1; n--; j += 2) {
        next = beta * x[j + 1];
        x[j] -= current + next;
        if (n--) {
          j += 2;
          current = beta * x[j + 1];
          x[j] -= current + next;
        } else {
          break;
        }
      }

      // step 6
      if (len !== 0) {
        j = offset + 1;
        current = alpha * x[j - 1];
        for (n = len; n--; j += 2) {
          next = alpha * x[j + 1];
          x[j] -= current + next;
          if (n--) {
            j += 2;
            current = alpha * x[j + 1];
            x[j] -= current + next;
          } else {
            break;
          }
        }
      }
    };

    return IrreversibleTransform;
  })();

  // Section 3.8.1 Reversible 5-3 filter
  var ReversibleTransform = (function ReversibleTransformClosure() {
    function ReversibleTransform() {
      Transform.call(this);
    }

    ReversibleTransform.prototype = Object.create(Transform.prototype);
    ReversibleTransform.prototype.filter =
      function reversibleTransformFilter(x, offset, length) {
      var len = length >> 1;
      offset = offset | 0;
      var j, n;

      for (j = offset, n = len + 1; n--; j += 2) {
        x[j] -= (x[j - 1] + x[j + 1] + 2) >> 2;
      }

      for (j = offset + 1, n = len; n--; j += 2) {
        x[j] += (x[j - 1] + x[j + 1]) >> 1;
      }
    };

    return ReversibleTransform;
  })();

  return JpxImage;
})();


/* -*- Mode: Java; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
/* vim: set shiftwidth=2 tabstop=2 autoindent cindent expandtab: */
/* Copyright 2012 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

'use strict';

/* This class implements the QM Coder decoding as defined in
 *   JPEG 2000 Part I Final Committee Draft Version 1.0
 *   Annex C.3 Arithmetic decoding procedure 
 * available at http://www.jpeg.org/public/fcd15444-1.pdf
 * 
 * The arithmetic decoder is used in conjunction with context models to decode
 * JPEG2000 and JBIG2 streams.
 */
var ArithmeticDecoder = (function ArithmeticDecoderClosure() {
  // Table C-2
  var QeTable = [
    {qe: 0x5601, nmps: 1, nlps: 1, switchFlag: 1},
    {qe: 0x3401, nmps: 2, nlps: 6, switchFlag: 0},
    {qe: 0x1801, nmps: 3, nlps: 9, switchFlag: 0},
    {qe: 0x0AC1, nmps: 4, nlps: 12, switchFlag: 0},
    {qe: 0x0521, nmps: 5, nlps: 29, switchFlag: 0},
    {qe: 0x0221, nmps: 38, nlps: 33, switchFlag: 0},
    {qe: 0x5601, nmps: 7, nlps: 6, switchFlag: 1},
    {qe: 0x5401, nmps: 8, nlps: 14, switchFlag: 0},
    {qe: 0x4801, nmps: 9, nlps: 14, switchFlag: 0},
    {qe: 0x3801, nmps: 10, nlps: 14, switchFlag: 0},
    {qe: 0x3001, nmps: 11, nlps: 17, switchFlag: 0},
    {qe: 0x2401, nmps: 12, nlps: 18, switchFlag: 0},
    {qe: 0x1C01, nmps: 13, nlps: 20, switchFlag: 0},
    {qe: 0x1601, nmps: 29, nlps: 21, switchFlag: 0},
    {qe: 0x5601, nmps: 15, nlps: 14, switchFlag: 1},
    {qe: 0x5401, nmps: 16, nlps: 14, switchFlag: 0},
    {qe: 0x5101, nmps: 17, nlps: 15, switchFlag: 0},
    {qe: 0x4801, nmps: 18, nlps: 16, switchFlag: 0},
    {qe: 0x3801, nmps: 19, nlps: 17, switchFlag: 0},
    {qe: 0x3401, nmps: 20, nlps: 18, switchFlag: 0},
    {qe: 0x3001, nmps: 21, nlps: 19, switchFlag: 0},
    {qe: 0x2801, nmps: 22, nlps: 19, switchFlag: 0},
    {qe: 0x2401, nmps: 23, nlps: 20, switchFlag: 0},
    {qe: 0x2201, nmps: 24, nlps: 21, switchFlag: 0},
    {qe: 0x1C01, nmps: 25, nlps: 22, switchFlag: 0},
    {qe: 0x1801, nmps: 26, nlps: 23, switchFlag: 0},
    {qe: 0x1601, nmps: 27, nlps: 24, switchFlag: 0},
    {qe: 0x1401, nmps: 28, nlps: 25, switchFlag: 0},
    {qe: 0x1201, nmps: 29, nlps: 26, switchFlag: 0},
    {qe: 0x1101, nmps: 30, nlps: 27, switchFlag: 0},
    {qe: 0x0AC1, nmps: 31, nlps: 28, switchFlag: 0},
    {qe: 0x09C1, nmps: 32, nlps: 29, switchFlag: 0},
    {qe: 0x08A1, nmps: 33, nlps: 30, switchFlag: 0},
    {qe: 0x0521, nmps: 34, nlps: 31, switchFlag: 0},
    {qe: 0x0441, nmps: 35, nlps: 32, switchFlag: 0},
    {qe: 0x02A1, nmps: 36, nlps: 33, switchFlag: 0},
    {qe: 0x0221, nmps: 37, nlps: 34, switchFlag: 0},
    {qe: 0x0141, nmps: 38, nlps: 35, switchFlag: 0},
    {qe: 0x0111, nmps: 39, nlps: 36, switchFlag: 0},
    {qe: 0x0085, nmps: 40, nlps: 37, switchFlag: 0},
    {qe: 0x0049, nmps: 41, nlps: 38, switchFlag: 0},
    {qe: 0x0025, nmps: 42, nlps: 39, switchFlag: 0},
    {qe: 0x0015, nmps: 43, nlps: 40, switchFlag: 0},
    {qe: 0x0009, nmps: 44, nlps: 41, switchFlag: 0},
    {qe: 0x0005, nmps: 45, nlps: 42, switchFlag: 0},
    {qe: 0x0001, nmps: 45, nlps: 43, switchFlag: 0},
    {qe: 0x5601, nmps: 46, nlps: 46, switchFlag: 0}
  ];

  // C.3.5 Initialisation of the decoder (INITDEC)
  function ArithmeticDecoder(data, start, end) {
    this.data = data;
    this.bp = start;
    this.dataEnd = end;

    this.chigh = data[start];
    this.clow = 0;

    this.byteIn();

    this.chigh = ((this.chigh << 7) & 0xFFFF) | ((this.clow >> 9) & 0x7F);
    this.clow = (this.clow << 7) & 0xFFFF;
    this.ct -= 7;
    this.a = 0x8000;
  }

  ArithmeticDecoder.prototype = {
    // C.3.4 Compressed data input (BYTEIN)
    byteIn: function ArithmeticDecoder_byteIn() {
      var data = this.data;
      var bp = this.bp;
      if (data[bp] === 0xFF) {
        var b1 = data[bp + 1];
        if (b1 > 0x8F) {
          this.clow += 0xFF00;
          this.ct = 8;
        } else {
          bp++;
          this.clow += (data[bp] << 9);
          this.ct = 7;
          this.bp = bp;
        }
      } else {
        bp++;
        this.clow += bp < this.dataEnd ? (data[bp] << 8) : 0xFF00;
        this.ct = 8;
        this.bp = bp;
      }
      if (this.clow > 0xFFFF) {
        this.chigh += (this.clow >> 16);
        this.clow &= 0xFFFF;
      }
    },
    // C.3.2 Decoding a decision (DECODE)
    readBit: function ArithmeticDecoder_readBit(contexts, pos) {
      // contexts are packed into 1 byte:
      // highest 7 bits carry cx.index, lowest bit carries cx.mps
      var cx_index = contexts[pos] >> 1, cx_mps = contexts[pos] & 1;
      var qeTableIcx = QeTable[cx_index];
      var qeIcx = qeTableIcx.qe;
      var d;
      var a = this.a - qeIcx;

      if (this.chigh < qeIcx) {
        // exchangeLps
        if (a < qeIcx) {
          a = qeIcx;
          d = cx_mps;
          cx_index = qeTableIcx.nmps;
        } else {
          a = qeIcx;
          d = 1 ^ cx_mps;
          if (qeTableIcx.switchFlag === 1) {
            cx_mps = d;
          }
          cx_index = qeTableIcx.nlps;
        }
      } else {
        this.chigh -= qeIcx;
        if ((a & 0x8000) !== 0) {
          this.a = a;
          return cx_mps;
        }
        // exchangeMps
        if (a < qeIcx) {
          d = 1 ^ cx_mps;
          if (qeTableIcx.switchFlag === 1) {
            cx_mps = d;
          }
          cx_index = qeTableIcx.nlps;
        } else {
          d = cx_mps;
          cx_index = qeTableIcx.nmps;
        }
      }
      // C.3.3 renormD;
      do {
        if (this.ct === 0) {
          this.byteIn();
        }

        a <<= 1;
        this.chigh = ((this.chigh << 1) & 0xFFFF) | ((this.clow >> 15) & 1);
        this.clow = (this.clow << 1) & 0xFFFF;
        this.ct--;
      } while ((a & 0x8000) === 0);
      this.a = a;

      contexts[pos] = cx_index << 1 | cx_mps;
      return d;
    }
  };

  return ArithmeticDecoder;
})();

/* -*- Mode: Java; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
/* vim: set shiftwidth=2 tabstop=2 autoindent cindent expandtab: */
/* Copyright 2012 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* globals Cmd, ColorSpace, Dict, MozBlobBuilder, Name, PDFJS, Ref, URL,
           Promise */

'use strict';

var globalScope = (typeof window === 'undefined') ? this : window;

var isWorker = (typeof window === 'undefined');

var FONT_IDENTITY_MATRIX = [0.001, 0, 0, 0.001, 0, 0];

var TextRenderingMode = {
  FILL: 0,
  STROKE: 1,
  FILL_STROKE: 2,
  INVISIBLE: 3,
  FILL_ADD_TO_PATH: 4,
  STROKE_ADD_TO_PATH: 5,
  FILL_STROKE_ADD_TO_PATH: 6,
  ADD_TO_PATH: 7,
  FILL_STROKE_MASK: 3,
  ADD_TO_PATH_FLAG: 4
};

var ImageKind = {
  GRAYSCALE_1BPP: 1,
  RGB_24BPP: 2,
  RGBA_32BPP: 3
};

var AnnotationType = {
  WIDGET: 1,
  TEXT: 2,
  LINK: 3
};

var StreamType = {
  UNKNOWN: 0,
  FLATE: 1,
  LZW: 2,
  DCT: 3,
  JPX: 4,
  JBIG: 5,
  A85: 6,
  AHX: 7,
  CCF: 8,
  RL: 9
};

var FontType = {
  UNKNOWN: 0,
  TYPE1: 1,
  TYPE1C: 2,
  CIDFONTTYPE0: 3,
  CIDFONTTYPE0C: 4,
  TRUETYPE: 5,
  CIDFONTTYPE2: 6,
  TYPE3: 7,
  OPENTYPE: 8,
  TYPE0: 9,
  MMTYPE1: 10
};

// The global PDFJS object exposes the API
// In production, it will be declared outside a global wrapper
// In development, it will be declared here
if (!globalScope.PDFJS) {
  globalScope.PDFJS = {};
}

globalScope.PDFJS.pdfBug = false;

PDFJS.VERBOSITY_LEVELS = {
  errors: 0,
  warnings: 1,
  infos: 5
};

// All the possible operations for an operator list.
var OPS = PDFJS.OPS = {
  // Intentionally start from 1 so it is easy to spot bad operators that will be
  // 0's.
  dependency: 1,
  setLineWidth: 2,
  setLineCap: 3,
  setLineJoin: 4,
  setMiterLimit: 5,
  setDash: 6,
  setRenderingIntent: 7,
  setFlatness: 8,
  setGState: 9,
  save: 10,
  restore: 11,
  transform: 12,
  moveTo: 13,
  lineTo: 14,
  curveTo: 15,
  curveTo2: 16,
  curveTo3: 17,
  closePath: 18,
  rectangle: 19,
  stroke: 20,
  closeStroke: 21,
  fill: 22,
  eoFill: 23,
  fillStroke: 24,
  eoFillStroke: 25,
  closeFillStroke: 26,
  closeEOFillStroke: 27,
  endPath: 28,
  clip: 29,
  eoClip: 30,
  beginText: 31,
  endText: 32,
  setCharSpacing: 33,
  setWordSpacing: 34,
  setHScale: 35,
  setLeading: 36,
  setFont: 37,
  setTextRenderingMode: 38,
  setTextRise: 39,
  moveText: 40,
  setLeadingMoveText: 41,
  setTextMatrix: 42,
  nextLine: 43,
  showText: 44,
  showSpacedText: 45,
  nextLineShowText: 46,
  nextLineSetSpacingShowText: 47,
  setCharWidth: 48,
  setCharWidthAndBounds: 49,
  setStrokeColorSpace: 50,
  setFillColorSpace: 51,
  setStrokeColor: 52,
  setStrokeColorN: 53,
  setFillColor: 54,
  setFillColorN: 55,
  setStrokeGray: 56,
  setFillGray: 57,
  setStrokeRGBColor: 58,
  setFillRGBColor: 59,
  setStrokeCMYKColor: 60,
  setFillCMYKColor: 61,
  shadingFill: 62,
  beginInlineImage: 63,
  beginImageData: 64,
  endInlineImage: 65,
  paintXObject: 66,
  markPoint: 67,
  markPointProps: 68,
  beginMarkedContent: 69,
  beginMarkedContentProps: 70,
  endMarkedContent: 71,
  beginCompat: 72,
  endCompat: 73,
  paintFormXObjectBegin: 74,
  paintFormXObjectEnd: 75,
  beginGroup: 76,
  endGroup: 77,
  beginAnnotations: 78,
  endAnnotations: 79,
  beginAnnotation: 80,
  endAnnotation: 81,
  paintJpegXObject: 82,
  paintImageMaskXObject: 83,
  paintImageMaskXObjectGroup: 84,
  paintImageXObject: 85,
  paintInlineImageXObject: 86,
  paintInlineImageXObjectGroup: 87,
  paintImageXObjectRepeat: 88,
  paintImageMaskXObjectRepeat: 89,
  paintSolidColorImageMask: 90,
  constructPath: 91
};

// A notice for devs. These are good for things that are helpful to devs, such
// as warning that Workers were disabled, which is important to devs but not
// end users.
function info(msg) {
  if (PDFJS.verbosity >= PDFJS.VERBOSITY_LEVELS.infos) {
    console.log('Info: ' + msg);
  }
}

// Non-fatal warnings.
function warn(msg) {
  if (PDFJS.verbosity >= PDFJS.VERBOSITY_LEVELS.warnings) {
    console.log('Warning: ' + msg);
  }
}

// Fatal errors that should trigger the fallback UI and halt execution by
// throwing an exception.
function error(msg) {
  // If multiple arguments were passed, pass them all to the log function.
  if (arguments.length > 1) {
    var logArguments = ['Error:'];
    logArguments.push.apply(logArguments, arguments);
    console.log.apply(console, logArguments);
    // Join the arguments into a single string for the lines below.
    msg = [].join.call(arguments, ' ');
  } else {
    console.log('Error: ' + msg);
  }
  console.log(backtrace());
  UnsupportedManager.notify(UNSUPPORTED_FEATURES.unknown);
  throw new Error(msg);
}

function backtrace() {
  try {
    throw new Error();
  } catch (e) {
    return e.stack ? e.stack.split('\n').slice(2).join('\n') : '';
  }
}

function assert(cond, msg) {
  if (!cond) {
    error(msg);
  }
}

var UNSUPPORTED_FEATURES = PDFJS.UNSUPPORTED_FEATURES = {
  unknown: 'unknown',
  forms: 'forms',
  javaScript: 'javaScript',
  smask: 'smask',
  shadingPattern: 'shadingPattern',
  font: 'font'
};

var UnsupportedManager = PDFJS.UnsupportedManager =
  (function UnsupportedManagerClosure() {
  var listeners = [];
  return {
    listen: function (cb) {
      listeners.push(cb);
    },
    notify: function (featureId) {
      warn('Unsupported feature "' + featureId + '"');
      for (var i = 0, ii = listeners.length; i < ii; i++) {
        listeners[i](featureId);
      }
    }
  };
})();

// Combines two URLs. The baseUrl shall be absolute URL. If the url is an
// absolute URL, it will be returned as is.
function combineUrl(baseUrl, url) {
  if (!url) {
    return baseUrl;
  }
  if (/^[a-z][a-z0-9+\-.]*:/i.test(url)) {
    return url;
  }
  var i;
  if (url.charAt(0) === '/') {
    // absolute path
    i = baseUrl.indexOf('://');
    if (url.charAt(1) === '/') {
      ++i;
    } else {
      i = baseUrl.indexOf('/', i + 3);
    }
    return baseUrl.substring(0, i) + url;
  } else {
    // relative path
    var pathLength = baseUrl.length;
    i = baseUrl.lastIndexOf('#');
    pathLength = i >= 0 ? i : pathLength;
    i = baseUrl.lastIndexOf('?', pathLength);
    pathLength = i >= 0 ? i : pathLength;
    var prefixLength = baseUrl.lastIndexOf('/', pathLength);
    return baseUrl.substring(0, prefixLength + 1) + url;
  }
}

// Validates if URL is safe and allowed, e.g. to avoid XSS.
function isValidUrl(url, allowRelative) {
  if (!url) {
    return false;
  }
  // RFC 3986 (http://tools.ietf.org/html/rfc3986#section-3.1)
  // scheme = ALPHA *( ALPHA / DIGIT / "+" / "-" / "." )
  var protocol = /^[a-z][a-z0-9+\-.]*(?=:)/i.exec(url);
  if (!protocol) {
    return allowRelative;
  }
  protocol = protocol[0].toLowerCase();
  switch (protocol) {
    case 'http':
    case 'https':
    case 'ftp':
    case 'mailto':
    case 'tel':
      return true;
    default:
      return false;
  }
}
PDFJS.isValidUrl = isValidUrl;

function shadow(obj, prop, value) {
  Object.defineProperty(obj, prop, { value: value,
                                     enumerable: true,
                                     configurable: true,
                                     writable: false });
  return value;
}
PDFJS.shadow = shadow;

var PasswordResponses = PDFJS.PasswordResponses = {
  NEED_PASSWORD: 1,
  INCORRECT_PASSWORD: 2
};

var PasswordException = (function PasswordExceptionClosure() {
  function PasswordException(msg, code) {
    this.name = 'PasswordException';
    this.message = msg;
    this.code = code;
  }

  PasswordException.prototype = new Error();
  PasswordException.constructor = PasswordException;

  return PasswordException;
})();
PDFJS.PasswordException = PasswordException;

var UnknownErrorException = (function UnknownErrorExceptionClosure() {
  function UnknownErrorException(msg, details) {
    this.name = 'UnknownErrorException';
    this.message = msg;
    this.details = details;
  }

  UnknownErrorException.prototype = new Error();
  UnknownErrorException.constructor = UnknownErrorException;

  return UnknownErrorException;
})();
PDFJS.UnknownErrorException = UnknownErrorException;

var InvalidPDFException = (function InvalidPDFExceptionClosure() {
  function InvalidPDFException(msg) {
    this.name = 'InvalidPDFException';
    this.message = msg;
  }

  InvalidPDFException.prototype = new Error();
  InvalidPDFException.constructor = InvalidPDFException;

  return InvalidPDFException;
})();
PDFJS.InvalidPDFException = InvalidPDFException;

var MissingPDFException = (function MissingPDFExceptionClosure() {
  function MissingPDFException(msg) {
    this.name = 'MissingPDFException';
    this.message = msg;
  }

  MissingPDFException.prototype = new Error();
  MissingPDFException.constructor = MissingPDFException;

  return MissingPDFException;
})();
PDFJS.MissingPDFException = MissingPDFException;

var UnexpectedResponseException =
    (function UnexpectedResponseExceptionClosure() {
  function UnexpectedResponseException(msg, status) {
    this.name = 'UnexpectedResponseException';
    this.message = msg;
    this.status = status;
  }

  UnexpectedResponseException.prototype = new Error();
  UnexpectedResponseException.constructor = UnexpectedResponseException;

  return UnexpectedResponseException;
})();
PDFJS.UnexpectedResponseException = UnexpectedResponseException;

var NotImplementedException = (function NotImplementedExceptionClosure() {
  function NotImplementedException(msg) {
    this.message = msg;
  }

  NotImplementedException.prototype = new Error();
  NotImplementedException.prototype.name = 'NotImplementedException';
  NotImplementedException.constructor = NotImplementedException;

  return NotImplementedException;
})();

var MissingDataException = (function MissingDataExceptionClosure() {
  function MissingDataException(begin, end) {
    this.begin = begin;
    this.end = end;
    this.message = 'Missing data [' + begin + ', ' + end + ')';
  }

  MissingDataException.prototype = new Error();
  MissingDataException.prototype.name = 'MissingDataException';
  MissingDataException.constructor = MissingDataException;

  return MissingDataException;
})();

var XRefParseException = (function XRefParseExceptionClosure() {
  function XRefParseException(msg) {
    this.message = msg;
  }

  XRefParseException.prototype = new Error();
  XRefParseException.prototype.name = 'XRefParseException';
  XRefParseException.constructor = XRefParseException;

  return XRefParseException;
})();


function bytesToString(bytes) {
  assert(bytes !== null && typeof bytes === 'object' &&
         bytes.length !== undefined, 'Invalid argument for bytesToString');
  var length = bytes.length;
  var MAX_ARGUMENT_COUNT = 8192;
  if (length < MAX_ARGUMENT_COUNT) {
    return String.fromCharCode.apply(null, bytes);
  }
  var strBuf = [];
  for (var i = 0; i < length; i += MAX_ARGUMENT_COUNT) {
    var chunkEnd = Math.min(i + MAX_ARGUMENT_COUNT, length);
    var chunk = bytes.subarray(i, chunkEnd);
    strBuf.push(String.fromCharCode.apply(null, chunk));
  }
  return strBuf.join('');
}

function stringToBytes(str) {
  assert(typeof str === 'string', 'Invalid argument for stringToBytes');
  var length = str.length;
  var bytes = new Uint8Array(length);
  for (var i = 0; i < length; ++i) {
    bytes[i] = str.charCodeAt(i) & 0xFF;
  }
  return bytes;
}

function string32(value) {
  return String.fromCharCode((value >> 24) & 0xff, (value >> 16) & 0xff,
                             (value >> 8) & 0xff, value & 0xff);
}

function log2(x) {
  var n = 1, i = 0;
  while (x > n) {
    n <<= 1;
    i++;
  }
  return i;
}

function readInt8(data, start) {
  return (data[start] << 24) >> 24;
}

function readUint16(data, offset) {
  return (data[offset] << 8) | data[offset + 1];
}

function readUint32(data, offset) {
  return ((data[offset] << 24) | (data[offset + 1] << 16) |
         (data[offset + 2] << 8) | data[offset + 3]) >>> 0;
}

// Lazy test the endianness of the platform
// NOTE: This will be 'true' for simulated TypedArrays
function isLittleEndian() {
  var buffer8 = new Uint8Array(2);
  buffer8[0] = 1;
  var buffer16 = new Uint16Array(buffer8.buffer);
  return (buffer16[0] === 1);
}

Object.defineProperty(PDFJS, 'isLittleEndian', {
  configurable: true,
  get: function PDFJS_isLittleEndian() {
    return shadow(PDFJS, 'isLittleEndian', isLittleEndian());
  }
});

//#if !(FIREFOX || MOZCENTRAL || B2G || CHROME)
//// Lazy test if the userAgant support CanvasTypedArrays
function hasCanvasTypedArrays() {
  var canvas = document.createElement('canvas');
  canvas.width = canvas.height = 1;
  var ctx = canvas.getContext('2d');
  var imageData = ctx.createImageData(1, 1);
  return (typeof imageData.data.buffer !== 'undefined');
}

Object.defineProperty(PDFJS, 'hasCanvasTypedArrays', {
  configurable: true,
  get: function PDFJS_hasCanvasTypedArrays() {
    return shadow(PDFJS, 'hasCanvasTypedArrays', hasCanvasTypedArrays());
  }
});

var Uint32ArrayView = (function Uint32ArrayViewClosure() {

  function Uint32ArrayView(buffer, length) {
    this.buffer = buffer;
    this.byteLength = buffer.length;
    this.length = length === undefined ? (this.byteLength >> 2) : length;
    ensureUint32ArrayViewProps(this.length);
  }
  Uint32ArrayView.prototype = Object.create(null);

  var uint32ArrayViewSetters = 0;
  function createUint32ArrayProp(index) {
    return {
      get: function () {
        var buffer = this.buffer, offset = index << 2;
        return (buffer[offset] | (buffer[offset + 1] << 8) |
          (buffer[offset + 2] << 16) | (buffer[offset + 3] << 24)) >>> 0;
      },
      set: function (value) {
        var buffer = this.buffer, offset = index << 2;
        buffer[offset] = value & 255;
        buffer[offset + 1] = (value >> 8) & 255;
        buffer[offset + 2] = (value >> 16) & 255;
        buffer[offset + 3] = (value >>> 24) & 255;
      }
    };
  }

  function ensureUint32ArrayViewProps(length) {
    while (uint32ArrayViewSetters < length) {
      Object.defineProperty(Uint32ArrayView.prototype,
        uint32ArrayViewSetters,
        createUint32ArrayProp(uint32ArrayViewSetters));
      uint32ArrayViewSetters++;
    }
  }

  return Uint32ArrayView;
})();
//#else
//PDFJS.hasCanvasTypedArrays = true;
//#endif

var IDENTITY_MATRIX = [1, 0, 0, 1, 0, 0];

var Util = PDFJS.Util = (function UtilClosure() {
  function Util() {}

  var rgbBuf = ['rgb(', 0, ',', 0, ',', 0, ')'];

  // makeCssRgb() can be called thousands of times. Using |rgbBuf| avoids
  // creating many intermediate strings.
  Util.makeCssRgb = function Util_makeCssRgb(r, g, b) {
    rgbBuf[1] = r;
    rgbBuf[3] = g;
    rgbBuf[5] = b;
    return rgbBuf.join('');
  };

  // Concatenates two transformation matrices together and returns the result.
  Util.transform = function Util_transform(m1, m2) {
    return [
      m1[0] * m2[0] + m1[2] * m2[1],
      m1[1] * m2[0] + m1[3] * m2[1],
      m1[0] * m2[2] + m1[2] * m2[3],
      m1[1] * m2[2] + m1[3] * m2[3],
      m1[0] * m2[4] + m1[2] * m2[5] + m1[4],
      m1[1] * m2[4] + m1[3] * m2[5] + m1[5]
    ];
  };

  // For 2d affine transforms
  Util.applyTransform = function Util_applyTransform(p, m) {
    var xt = p[0] * m[0] + p[1] * m[2] + m[4];
    var yt = p[0] * m[1] + p[1] * m[3] + m[5];
    return [xt, yt];
  };

  Util.applyInverseTransform = function Util_applyInverseTransform(p, m) {
    var d = m[0] * m[3] - m[1] * m[2];
    var xt = (p[0] * m[3] - p[1] * m[2] + m[2] * m[5] - m[4] * m[3]) / d;
    var yt = (-p[0] * m[1] + p[1] * m[0] + m[4] * m[1] - m[5] * m[0]) / d;
    return [xt, yt];
  };

  // Applies the transform to the rectangle and finds the minimum axially
  // aligned bounding box.
  Util.getAxialAlignedBoundingBox =
    function Util_getAxialAlignedBoundingBox(r, m) {

    var p1 = Util.applyTransform(r, m);
    var p2 = Util.applyTransform(r.slice(2, 4), m);
    var p3 = Util.applyTransform([r[0], r[3]], m);
    var p4 = Util.applyTransform([r[2], r[1]], m);
    return [
      Math.min(p1[0], p2[0], p3[0], p4[0]),
      Math.min(p1[1], p2[1], p3[1], p4[1]),
      Math.max(p1[0], p2[0], p3[0], p4[0]),
      Math.max(p1[1], p2[1], p3[1], p4[1])
    ];
  };

  Util.inverseTransform = function Util_inverseTransform(m) {
    var d = m[0] * m[3] - m[1] * m[2];
    return [m[3] / d, -m[1] / d, -m[2] / d, m[0] / d,
      (m[2] * m[5] - m[4] * m[3]) / d, (m[4] * m[1] - m[5] * m[0]) / d];
  };

  // Apply a generic 3d matrix M on a 3-vector v:
  //   | a b c |   | X |
  //   | d e f | x | Y |
  //   | g h i |   | Z |
  // M is assumed to be serialized as [a,b,c,d,e,f,g,h,i],
  // with v as [X,Y,Z]
  Util.apply3dTransform = function Util_apply3dTransform(m, v) {
    return [
      m[0] * v[0] + m[1] * v[1] + m[2] * v[2],
      m[3] * v[0] + m[4] * v[1] + m[5] * v[2],
      m[6] * v[0] + m[7] * v[1] + m[8] * v[2]
    ];
  };

  // This calculation uses Singular Value Decomposition.
  // The SVD can be represented with formula A = USV. We are interested in the
  // matrix S here because it represents the scale values.
  Util.singularValueDecompose2dScale =
    function Util_singularValueDecompose2dScale(m) {

    var transpose = [m[0], m[2], m[1], m[3]];

    // Multiply matrix m with its transpose.
    var a = m[0] * transpose[0] + m[1] * transpose[2];
    var b = m[0] * transpose[1] + m[1] * transpose[3];
    var c = m[2] * transpose[0] + m[3] * transpose[2];
    var d = m[2] * transpose[1] + m[3] * transpose[3];

    // Solve the second degree polynomial to get roots.
    var first = (a + d) / 2;
    var second = Math.sqrt((a + d) * (a + d) - 4 * (a * d - c * b)) / 2;
    var sx = first + second || 1;
    var sy = first - second || 1;

    // Scale values are the square roots of the eigenvalues.
    return [Math.sqrt(sx), Math.sqrt(sy)];
  };

  // Normalize rectangle rect=[x1, y1, x2, y2] so that (x1,y1) < (x2,y2)
  // For coordinate systems whose origin lies in the bottom-left, this
  // means normalization to (BL,TR) ordering. For systems with origin in the
  // top-left, this means (TL,BR) ordering.
  Util.normalizeRect = function Util_normalizeRect(rect) {
    var r = rect.slice(0); // clone rect
    if (rect[0] > rect[2]) {
      r[0] = rect[2];
      r[2] = rect[0];
    }
    if (rect[1] > rect[3]) {
      r[1] = rect[3];
      r[3] = rect[1];
    }
    return r;
  };

  // Returns a rectangle [x1, y1, x2, y2] corresponding to the
  // intersection of rect1 and rect2. If no intersection, returns 'false'
  // The rectangle coordinates of rect1, rect2 should be [x1, y1, x2, y2]
  Util.intersect = function Util_intersect(rect1, rect2) {
    function compare(a, b) {
      return a - b;
    }

    // Order points along the axes
    var orderedX = [rect1[0], rect1[2], rect2[0], rect2[2]].sort(compare),
        orderedY = [rect1[1], rect1[3], rect2[1], rect2[3]].sort(compare),
        result = [];

    rect1 = Util.normalizeRect(rect1);
    rect2 = Util.normalizeRect(rect2);

    // X: first and second points belong to different rectangles?
    if ((orderedX[0] === rect1[0] && orderedX[1] === rect2[0]) ||
        (orderedX[0] === rect2[0] && orderedX[1] === rect1[0])) {
      // Intersection must be between second and third points
      result[0] = orderedX[1];
      result[2] = orderedX[2];
    } else {
      return false;
    }

    // Y: first and second points belong to different rectangles?
    if ((orderedY[0] === rect1[1] && orderedY[1] === rect2[1]) ||
        (orderedY[0] === rect2[1] && orderedY[1] === rect1[1])) {
      // Intersection must be between second and third points
      result[1] = orderedY[1];
      result[3] = orderedY[2];
    } else {
      return false;
    }

    return result;
  };

  Util.sign = function Util_sign(num) {
    return num < 0 ? -1 : 1;
  };

  Util.appendToArray = function Util_appendToArray(arr1, arr2) {
    Array.prototype.push.apply(arr1, arr2);
  };

  Util.prependToArray = function Util_prependToArray(arr1, arr2) {
    Array.prototype.unshift.apply(arr1, arr2);
  };

  Util.extendObj = function extendObj(obj1, obj2) {
    for (var key in obj2) {
      obj1[key] = obj2[key];
    }
  };

  Util.getInheritableProperty = function Util_getInheritableProperty(dict,
                                                                     name) {
    while (dict && !dict.has(name)) {
      dict = dict.get('Parent');
    }
    if (!dict) {
      return null;
    }
    return dict.get(name);
  };

  Util.inherit = function Util_inherit(sub, base, prototype) {
    sub.prototype = Object.create(base.prototype);
    sub.prototype.constructor = sub;
    for (var prop in prototype) {
      sub.prototype[prop] = prototype[prop];
    }
  };

  Util.loadScript = function Util_loadScript(src, callback) {
    var script = document.createElement('script');
    var loaded = false;
    script.setAttribute('src', src);
    if (callback) {
      script.onload = function() {
        if (!loaded) {
          callback();
        }
        loaded = true;
      };
    }
    document.getElementsByTagName('head')[0].appendChild(script);
  };

  return Util;
})();

/**
 * PDF page viewport created based on scale, rotation and offset.
 * @class
 * @alias PDFJS.PageViewport
 */
var PageViewport = PDFJS.PageViewport = (function PageViewportClosure() {
  /**
   * @constructor
   * @private
   * @param viewBox {Array} xMin, yMin, xMax and yMax coordinates.
   * @param scale {number} scale of the viewport.
   * @param rotation {number} rotations of the viewport in degrees.
   * @param offsetX {number} offset X
   * @param offsetY {number} offset Y
   * @param dontFlip {boolean} if true, axis Y will not be flipped.
   */
  function PageViewport(viewBox, scale, rotation, offsetX, offsetY, dontFlip) {
    this.viewBox = viewBox;
    this.scale = scale;
    this.rotation = rotation;
    this.offsetX = offsetX;
    this.offsetY = offsetY;

    // creating transform to convert pdf coordinate system to the normal
    // canvas like coordinates taking in account scale and rotation
    var centerX = (viewBox[2] + viewBox[0]) / 2;
    var centerY = (viewBox[3] + viewBox[1]) / 2;
    var rotateA, rotateB, rotateC, rotateD;
    rotation = rotation % 360;
    rotation = rotation < 0 ? rotation + 360 : rotation;
    switch (rotation) {
      case 180:
        rotateA = -1; rotateB = 0; rotateC = 0; rotateD = 1;
        break;
      case 90:
        rotateA = 0; rotateB = 1; rotateC = 1; rotateD = 0;
        break;
      case 270:
        rotateA = 0; rotateB = -1; rotateC = -1; rotateD = 0;
        break;
      //case 0:
      default:
        rotateA = 1; rotateB = 0; rotateC = 0; rotateD = -1;
        break;
    }

    if (dontFlip) {
      rotateC = -rotateC; rotateD = -rotateD;
    }

    var offsetCanvasX, offsetCanvasY;
    var width, height;
    if (rotateA === 0) {
      offsetCanvasX = Math.abs(centerY - viewBox[1]) * scale + offsetX;
      offsetCanvasY = Math.abs(centerX - viewBox[0]) * scale + offsetY;
      width = Math.abs(viewBox[3] - viewBox[1]) * scale;
      height = Math.abs(viewBox[2] - viewBox[0]) * scale;
    } else {
      offsetCanvasX = Math.abs(centerX - viewBox[0]) * scale + offsetX;
      offsetCanvasY = Math.abs(centerY - viewBox[1]) * scale + offsetY;
      width = Math.abs(viewBox[2] - viewBox[0]) * scale;
      height = Math.abs(viewBox[3] - viewBox[1]) * scale;
    }
    // creating transform for the following operations:
    // translate(-centerX, -centerY), rotate and flip vertically,
    // scale, and translate(offsetCanvasX, offsetCanvasY)
    this.transform = [
      rotateA * scale,
      rotateB * scale,
      rotateC * scale,
      rotateD * scale,
      offsetCanvasX - rotateA * scale * centerX - rotateC * scale * centerY,
      offsetCanvasY - rotateB * scale * centerX - rotateD * scale * centerY
    ];

    this.width = width;
    this.height = height;
    this.fontScale = scale;
  }
  PageViewport.prototype = /** @lends PDFJS.PageViewport.prototype */ {
    /**
     * Clones viewport with additional properties.
     * @param args {Object} (optional) If specified, may contain the 'scale' or
     * 'rotation' properties to override the corresponding properties in
     * the cloned viewport.
     * @returns {PDFJS.PageViewport} Cloned viewport.
     */
    clone: function PageViewPort_clone(args) {
      args = args || {};
      var scale = 'scale' in args ? args.scale : this.scale;
      var rotation = 'rotation' in args ? args.rotation : this.rotation;
      return new PageViewport(this.viewBox.slice(), scale, rotation,
                              this.offsetX, this.offsetY, args.dontFlip);
    },
    /**
     * Converts PDF point to the viewport coordinates. For examples, useful for
     * converting PDF location into canvas pixel coordinates.
     * @param x {number} X coordinate.
     * @param y {number} Y coordinate.
     * @returns {Object} Object that contains 'x' and 'y' properties of the
     * point in the viewport coordinate space.
     * @see {@link convertToPdfPoint}
     * @see {@link convertToViewportRectangle}
     */
    convertToViewportPoint: function PageViewport_convertToViewportPoint(x, y) {
      return Util.applyTransform([x, y], this.transform);
    },
    /**
     * Converts PDF rectangle to the viewport coordinates.
     * @param rect {Array} xMin, yMin, xMax and yMax coordinates.
     * @returns {Array} Contains corresponding coordinates of the rectangle
     * in the viewport coordinate space.
     * @see {@link convertToViewportPoint}
     */
    convertToViewportRectangle:
      function PageViewport_convertToViewportRectangle(rect) {
      var tl = Util.applyTransform([rect[0], rect[1]], this.transform);
      var br = Util.applyTransform([rect[2], rect[3]], this.transform);
      return [tl[0], tl[1], br[0], br[1]];
    },
    /**
     * Converts viewport coordinates to the PDF location. For examples, useful
     * for converting canvas pixel location into PDF one.
     * @param x {number} X coordinate.
     * @param y {number} Y coordinate.
     * @returns {Object} Object that contains 'x' and 'y' properties of the
     * point in the PDF coordinate space.
     * @see {@link convertToViewportPoint}
     */
    convertToPdfPoint: function PageViewport_convertToPdfPoint(x, y) {
      return Util.applyInverseTransform([x, y], this.transform);
    }
  };
  return PageViewport;
})();

var PDFStringTranslateTable = [
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0x2D8, 0x2C7, 0x2C6, 0x2D9, 0x2DD, 0x2DB, 0x2DA, 0x2DC, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x2022, 0x2020, 0x2021, 0x2026, 0x2014,
  0x2013, 0x192, 0x2044, 0x2039, 0x203A, 0x2212, 0x2030, 0x201E, 0x201C,
  0x201D, 0x2018, 0x2019, 0x201A, 0x2122, 0xFB01, 0xFB02, 0x141, 0x152, 0x160,
  0x178, 0x17D, 0x131, 0x142, 0x153, 0x161, 0x17E, 0, 0x20AC
];

function stringToPDFString(str) {
  var i, n = str.length, strBuf = [];
  if (str[0] === '\xFE' && str[1] === '\xFF') {
    // UTF16BE BOM
    for (i = 2; i < n; i += 2) {
      strBuf.push(String.fromCharCode(
        (str.charCodeAt(i) << 8) | str.charCodeAt(i + 1)));
    }
  } else {
    for (i = 0; i < n; ++i) {
      var code = PDFStringTranslateTable[str.charCodeAt(i)];
      strBuf.push(code ? String.fromCharCode(code) : str.charAt(i));
    }
  }
  return strBuf.join('');
}

function stringToUTF8String(str) {
  return decodeURIComponent(escape(str));
}

function isEmptyObj(obj) {
  for (var key in obj) {
    return false;
  }
  return true;
}

function isBool(v) {
  return typeof v === 'boolean';
}

function isInt(v) {
  return typeof v === 'number' && ((v | 0) === v);
}

function isNum(v) {
  return typeof v === 'number';
}

function isString(v) {
  return typeof v === 'string';
}

function isNull(v) {
  return v === null;
}

function isName(v) {
  return v instanceof Name;
}

function isCmd(v, cmd) {
  return v instanceof Cmd && (cmd === undefined || v.cmd === cmd);
}

function isDict(v, type) {
  if (!(v instanceof Dict)) {
    return false;
  }
  if (!type) {
    return true;
  }
  var dictType = v.get('Type');
  return isName(dictType) && dictType.name === type;
}

function isArray(v) {
  return v instanceof Array;
}

function isStream(v) {
  return typeof v === 'object' && v !== null && v.getBytes !== undefined;
}

function isArrayBuffer(v) {
  return typeof v === 'object' && v !== null && v.byteLength !== undefined;
}

function isRef(v) {
  return v instanceof Ref;
}

/**
 * Promise Capability object.
 *
 * @typedef {Object} PromiseCapability
 * @property {Promise} promise - A promise object.
 * @property {function} resolve - Fullfills the promise.
 * @property {function} reject - Rejects the promise.
 */

/**
 * Creates a promise capability object.
 * @alias PDFJS.createPromiseCapability
 *
 * @return {PromiseCapability} A capability object contains:
 * - a Promise, resolve and reject methods.
 */
function createPromiseCapability() {
  var capability = {};
  capability.promise = new Promise(function (resolve, reject) {
    capability.resolve = resolve;
    capability.reject = reject;
  });
  return capability;
}

PDFJS.createPromiseCapability = createPromiseCapability;

/**
 * Polyfill for Promises:
 * The following promise implementation tries to generally implement the
 * Promise/A+ spec. Some notable differences from other promise libaries are:
 * - There currently isn't a seperate deferred and promise object.
 * - Unhandled rejections eventually show an error if they aren't handled.
 *
 * Based off of the work in:
 * https://bugzilla.mozilla.org/show_bug.cgi?id=810490
 */
(function PromiseClosure() {
  if (globalScope.Promise) {
    // Promises existing in the DOM/Worker, checking presence of all/resolve
    if (typeof globalScope.Promise.all !== 'function') {
      globalScope.Promise.all = function (iterable) {
        var count = 0, results = [], resolve, reject;
        var promise = new globalScope.Promise(function (resolve_, reject_) {
          resolve = resolve_;
          reject = reject_;
        });
        iterable.forEach(function (p, i) {
          count++;
          p.then(function (result) {
            results[i] = result;
            count--;
            if (count === 0) {
              resolve(results);
            }
          }, reject);
        });
        if (count === 0) {
          resolve(results);
        }
        return promise;
      };
    }
    if (typeof globalScope.Promise.resolve !== 'function') {
      globalScope.Promise.resolve = function (value) {
        return new globalScope.Promise(function (resolve) { resolve(value); });
      };
    }
    if (typeof globalScope.Promise.reject !== 'function') {
      globalScope.Promise.reject = function (reason) {
        return new globalScope.Promise(function (resolve, reject) {
          reject(reason);
        });
      };
    }
    if (typeof globalScope.Promise.prototype.catch !== 'function') {
      globalScope.Promise.prototype.catch = function (onReject) {
        return globalScope.Promise.prototype.then(undefined, onReject);
      };
    }
    return;
  }
//#if !MOZCENTRAL
  var STATUS_PENDING = 0;
  var STATUS_RESOLVED = 1;
  var STATUS_REJECTED = 2;

  // In an attempt to avoid silent exceptions, unhandled rejections are
  // tracked and if they aren't handled in a certain amount of time an
  // error is logged.
  var REJECTION_TIMEOUT = 500;

  var HandlerManager = {
    handlers: [],
    running: false,
    unhandledRejections: [],
    pendingRejectionCheck: false,

    scheduleHandlers: function scheduleHandlers(promise) {
      if (promise._status === STATUS_PENDING) {
        return;
      }

      this.handlers = this.handlers.concat(promise._handlers);
      promise._handlers = [];

      if (this.running) {
        return;
      }
      this.running = true;

      setTimeout(this.runHandlers.bind(this), 0);
    },

    runHandlers: function runHandlers() {
      var RUN_TIMEOUT = 1; // ms
      var timeoutAt = Date.now() + RUN_TIMEOUT;
      while (this.handlers.length > 0) {
        var handler = this.handlers.shift();

        var nextStatus = handler.thisPromise._status;
        var nextValue = handler.thisPromise._value;

        try {
          if (nextStatus === STATUS_RESOLVED) {
            if (typeof handler.onResolve === 'function') {
              nextValue = handler.onResolve(nextValue);
            }
          } else if (typeof handler.onReject === 'function') {
              nextValue = handler.onReject(nextValue);
              nextStatus = STATUS_RESOLVED;

              if (handler.thisPromise._unhandledRejection) {
                this.removeUnhandeledRejection(handler.thisPromise);
              }
          }
        } catch (ex) {
          nextStatus = STATUS_REJECTED;
          nextValue = ex;
        }

        handler.nextPromise._updateStatus(nextStatus, nextValue);
        if (Date.now() >= timeoutAt) {
          break;
        }
      }

      if (this.handlers.length > 0) {
        setTimeout(this.runHandlers.bind(this), 0);
        return;
      }

      this.running = false;
    },

    addUnhandledRejection: function addUnhandledRejection(promise) {
      this.unhandledRejections.push({
        promise: promise,
        time: Date.now()
      });
      this.scheduleRejectionCheck();
    },

    removeUnhandeledRejection: function removeUnhandeledRejection(promise) {
      promise._unhandledRejection = false;
      for (var i = 0; i < this.unhandledRejections.length; i++) {
        if (this.unhandledRejections[i].promise === promise) {
          this.unhandledRejections.splice(i);
          i--;
        }
      }
    },

    scheduleRejectionCheck: function scheduleRejectionCheck() {
      if (this.pendingRejectionCheck) {
        return;
      }
      this.pendingRejectionCheck = true;
      setTimeout(function rejectionCheck() {
        this.pendingRejectionCheck = false;
        var now = Date.now();
        for (var i = 0; i < this.unhandledRejections.length; i++) {
          if (now - this.unhandledRejections[i].time > REJECTION_TIMEOUT) {
            var unhandled = this.unhandledRejections[i].promise._value;
            var msg = 'Unhandled rejection: ' + unhandled;
            if (unhandled.stack) {
              msg += '\n' + unhandled.stack;
            }
            warn(msg);
            this.unhandledRejections.splice(i);
            i--;
          }
        }
        if (this.unhandledRejections.length) {
          this.scheduleRejectionCheck();
        }
      }.bind(this), REJECTION_TIMEOUT);
    }
  };

  function Promise(resolver) {
    this._status = STATUS_PENDING;
    this._handlers = [];
    try {
      resolver.call(this, this._resolve.bind(this), this._reject.bind(this));
    } catch (e) {
      this._reject(e);
    }
  }
  /**
   * Builds a promise that is resolved when all the passed in promises are
   * resolved.
   * @param {array} array of data and/or promises to wait for.
   * @return {Promise} New dependant promise.
   */
  Promise.all = function Promise_all(promises) {
    var resolveAll, rejectAll;
    var deferred = new Promise(function (resolve, reject) {
      resolveAll = resolve;
      rejectAll = reject;
    });
    var unresolved = promises.length;
    var results = [];
    if (unresolved === 0) {
      resolveAll(results);
      return deferred;
    }
    function reject(reason) {
      if (deferred._status === STATUS_REJECTED) {
        return;
      }
      results = [];
      rejectAll(reason);
    }
    for (var i = 0, ii = promises.length; i < ii; ++i) {
      var promise = promises[i];
      var resolve = (function(i) {
        return function(value) {
          if (deferred._status === STATUS_REJECTED) {
            return;
          }
          results[i] = value;
          unresolved--;
          if (unresolved === 0) {
            resolveAll(results);
          }
        };
      })(i);
      if (Promise.isPromise(promise)) {
        promise.then(resolve, reject);
      } else {
        resolve(promise);
      }
    }
    return deferred;
  };

  /**
   * Checks if the value is likely a promise (has a 'then' function).
   * @return {boolean} true if value is thenable
   */
  Promise.isPromise = function Promise_isPromise(value) {
    return value && typeof value.then === 'function';
  };

  /**
   * Creates resolved promise
   * @param value resolve value
   * @returns {Promise}
   */
  Promise.resolve = function Promise_resolve(value) {
    return new Promise(function (resolve) { resolve(value); });
  };

  /**
   * Creates rejected promise
   * @param reason rejection value
   * @returns {Promise}
   */
  Promise.reject = function Promise_reject(reason) {
    return new Promise(function (resolve, reject) { reject(reason); });
  };

  Promise.prototype = {
    _status: null,
    _value: null,
    _handlers: null,
    _unhandledRejection: null,

    _updateStatus: function Promise__updateStatus(status, value) {
      if (this._status === STATUS_RESOLVED ||
          this._status === STATUS_REJECTED) {
        return;
      }

      if (status === STATUS_RESOLVED &&
          Promise.isPromise(value)) {
        value.then(this._updateStatus.bind(this, STATUS_RESOLVED),
                   this._updateStatus.bind(this, STATUS_REJECTED));
        return;
      }

      this._status = status;
      this._value = value;

      if (status === STATUS_REJECTED && this._handlers.length === 0) {
        this._unhandledRejection = true;
        HandlerManager.addUnhandledRejection(this);
      }

      HandlerManager.scheduleHandlers(this);
    },

    _resolve: function Promise_resolve(value) {
      this._updateStatus(STATUS_RESOLVED, value);
    },

    _reject: function Promise_reject(reason) {
      this._updateStatus(STATUS_REJECTED, reason);
    },

    then: function Promise_then(onResolve, onReject) {
      var nextPromise = new Promise(function (resolve, reject) {
        this.resolve = resolve;
        this.reject = reject;
      });
      this._handlers.push({
        thisPromise: this,
        onResolve: onResolve,
        onReject: onReject,
        nextPromise: nextPromise
      });
      HandlerManager.scheduleHandlers(this);
      return nextPromise;
    },

    catch: function Promise_catch(onReject) {
      return this.then(undefined, onReject);
    }
  };

  globalScope.Promise = Promise;
//#else
//throw new Error('DOM Promise is not present');
//#endif
})();

var StatTimer = (function StatTimerClosure() {
  function rpad(str, pad, length) {
    while (str.length < length) {
      str += pad;
    }
    return str;
  }
  function StatTimer() {
    this.started = {};
    this.times = [];
    this.enabled = true;
  }
  StatTimer.prototype = {
    time: function StatTimer_time(name) {
      if (!this.enabled) {
        return;
      }
      if (name in this.started) {
        warn('Timer is already running for ' + name);
      }
      this.started[name] = Date.now();
    },
    timeEnd: function StatTimer_timeEnd(name) {
      if (!this.enabled) {
        return;
      }
      if (!(name in this.started)) {
        warn('Timer has not been started for ' + name);
      }
      this.times.push({
        'name': name,
        'start': this.started[name],
        'end': Date.now()
      });
      // Remove timer from started so it can be called again.
      delete this.started[name];
    },
    toString: function StatTimer_toString() {
      var i, ii;
      var times = this.times;
      var out = '';
      // Find the longest name for padding purposes.
      var longest = 0;
      for (i = 0, ii = times.length; i < ii; ++i) {
        var name = times[i]['name'];
        if (name.length > longest) {
          longest = name.length;
        }
      }
      for (i = 0, ii = times.length; i < ii; ++i) {
        var span = times[i];
        var duration = span.end - span.start;
        out += rpad(span['name'], ' ', longest) + ' ' + duration + 'ms\n';
      }
      return out;
    }
  };
  return StatTimer;
})();

PDFJS.createBlob = function createBlob(data, contentType) {
  if (typeof Blob !== 'undefined') {
    return new Blob([data], { type: contentType });
  }
  // Blob builder is deprecated in FF14 and removed in FF18.
  var bb = new MozBlobBuilder();
  bb.append(data);
  return bb.getBlob(contentType);
};

PDFJS.createObjectURL = (function createObjectURLClosure() {
  // Blob/createObjectURL is not available, falling back to data schema.
  var digits =
    'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';

  return function createObjectURL(data, contentType) {
    if (!PDFJS.disableCreateObjectURL &&
        typeof URL !== 'undefined' && URL.createObjectURL) {
      var blob = PDFJS.createBlob(data, contentType);
      return URL.createObjectURL(blob);
    }

    var buffer = 'data:' + contentType + ';base64,';
    for (var i = 0, ii = data.length; i < ii; i += 3) {
      var b1 = data[i] & 0xFF;
      var b2 = data[i + 1] & 0xFF;
      var b3 = data[i + 2] & 0xFF;
      var d1 = b1 >> 2, d2 = ((b1 & 3) << 4) | (b2 >> 4);
      var d3 = i + 1 < ii ? ((b2 & 0xF) << 2) | (b3 >> 6) : 64;
      var d4 = i + 2 < ii ? (b3 & 0x3F) : 64;
      buffer += digits[d1] + digits[d2] + digits[d3] + digits[d4];
    }
    return buffer;
  };
})();

function MessageHandler(name, comObj) {
  this.name = name;
  this.comObj = comObj;
  this.callbackIndex = 1;
  this.postMessageTransfers = true;
  var callbacksCapabilities = this.callbacksCapabilities = {};
  var ah = this.actionHandler = {};

  ah['console_log'] = [function ahConsoleLog(data) {
    console.log.apply(console, data);
  }];
  ah['console_error'] = [function ahConsoleError(data) {
    console.error.apply(console, data);
  }];
  ah['_unsupported_feature'] = [function ah_unsupportedFeature(data) {
    UnsupportedManager.notify(data);
  }];

  comObj.onmessage = function messageHandlerComObjOnMessage(event) {
    var data = event.data;
    if (data.isReply) {
      var callbackId = data.callbackId;
      if (data.callbackId in callbacksCapabilities) {
        var callback = callbacksCapabilities[callbackId];
        delete callbacksCapabilities[callbackId];
        if ('error' in data) {
          callback.reject(data.error);
        } else {
          callback.resolve(data.data);
        }
      } else {
        error('Cannot resolve callback ' + callbackId);
      }
    } else if (data.action in ah) {
      var action = ah[data.action];
      if (data.callbackId) {
        Promise.resolve().then(function () {
          return action[0].call(action[1], data.data);
        }).then(function (result) {
          comObj.postMessage({
            isReply: true,
            callbackId: data.callbackId,
            data: result
          });
        }, function (reason) {
          comObj.postMessage({
            isReply: true,
            callbackId: data.callbackId,
            error: reason
          });
        });
      } else {
        action[0].call(action[1], data.data);
      }
    } else {
      error('Unknown action from worker: ' + data.action);
    }
  };
}

MessageHandler.prototype = {
  on: function messageHandlerOn(actionName, handler, scope) {
    var ah = this.actionHandler;
    if (ah[actionName]) {
      error('There is already an actionName called "' + actionName + '"');
    }
    ah[actionName] = [handler, scope];
  },
  /**
   * Sends a message to the comObj to invoke the action with the supplied data.
   * @param {String} actionName Action to call.
   * @param {JSON} data JSON data to send.
   * @param {Array} [transfers] Optional list of transfers/ArrayBuffers
   */
  send: function messageHandlerSend(actionName, data, transfers) {
    var message = {
      action: actionName,
      data: data
    };
    this.postMessage(message, transfers);
  },
  /**
   * Sends a message to the comObj to invoke the action with the supplied data.
   * Expects that other side will callback with the response.
   * @param {String} actionName Action to call.
   * @param {JSON} data JSON data to send.
   * @param {Array} [transfers] Optional list of transfers/ArrayBuffers.
   * @returns {Promise} Promise to be resolved with response data.
   */
  sendWithPromise:
    function messageHandlerSendWithPromise(actionName, data, transfers) {
    var callbackId = this.callbackIndex++;
    var message = {
      action: actionName,
      data: data,
      callbackId: callbackId
    };
    var capability = createPromiseCapability();
    this.callbacksCapabilities[callbackId] = capability;
    try {
      this.postMessage(message, transfers);
    } catch (e) {
      capability.reject(e);
    }
    return capability.promise;
  },
  /**
   * Sends raw message to the comObj.
   * @private
   * @param message {Object} Raw message.
   * @param transfers List of transfers/ArrayBuffers, or undefined.
   */
  postMessage: function (message, transfers) {
    if (transfers && this.postMessageTransfers) {
      this.comObj.postMessage(message, transfers);
    } else {
      this.comObj.postMessage(message);
    }
  }
};

var moduleType = typeof module;
if ((moduleType !== 'undefined') && module.exports) {
    module.exports = JpxImage;
}

function loadJpegStream(id, imageUrl, objs) {
  var img = new Image();
  img.onload = (function loadJpegStream_onloadClosure() {
    objs.resolve(id, img);
  });
  img.onerror = (function loadJpegStream_onerrorClosure() {
    objs.resolve(id, null);
    warn('Error during JPEG image loading');
  });
  img.src = imageUrl;
}
},{}],3:[function(require,module,exports){
(function (global){
'use strict';

// compare and isBuffer taken from https://github.com/feross/buffer/blob/680e9e5e488f22aac27599a57dc844a6315928dd/index.js
// original notice:

/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
function compare(a, b) {
  if (a === b) {
    return 0;
  }

  var x = a.length;
  var y = b.length;

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i];
      y = b[i];
      break;
    }
  }

  if (x < y) {
    return -1;
  }
  if (y < x) {
    return 1;
  }
  return 0;
}
function isBuffer(b) {
  if (global.Buffer && typeof global.Buffer.isBuffer === 'function') {
    return global.Buffer.isBuffer(b);
  }
  return !!(b != null && b._isBuffer);
}

// based on node assert, original notice:

// http://wiki.commonjs.org/wiki/Unit_Testing/1.0
//
// THIS IS NOT TESTED NOR LIKELY TO WORK OUTSIDE V8!
//
// Originally from narwhal.js (http://narwhaljs.org)
// Copyright (c) 2009 Thomas Robinson <280north.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the 'Software'), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

var util = require('util/');
var hasOwn = Object.prototype.hasOwnProperty;
var pSlice = Array.prototype.slice;
var functionsHaveNames = (function () {
  return function foo() {}.name === 'foo';
}());
function pToString (obj) {
  return Object.prototype.toString.call(obj);
}
function isView(arrbuf) {
  if (isBuffer(arrbuf)) {
    return false;
  }
  if (typeof global.ArrayBuffer !== 'function') {
    return false;
  }
  if (typeof ArrayBuffer.isView === 'function') {
    return ArrayBuffer.isView(arrbuf);
  }
  if (!arrbuf) {
    return false;
  }
  if (arrbuf instanceof DataView) {
    return true;
  }
  if (arrbuf.buffer && arrbuf.buffer instanceof ArrayBuffer) {
    return true;
  }
  return false;
}
// 1. The assert module provides functions that throw
// AssertionError's when particular conditions are not met. The
// assert module must conform to the following interface.

var assert = module.exports = ok;

// 2. The AssertionError is defined in assert.
// new assert.AssertionError({ message: message,
//                             actual: actual,
//                             expected: expected })

var regex = /\s*function\s+([^\(\s]*)\s*/;
// based on https://github.com/ljharb/function.prototype.name/blob/adeeeec8bfcc6068b187d7d9fb3d5bb1d3a30899/implementation.js
function getName(func) {
  if (!util.isFunction(func)) {
    return;
  }
  if (functionsHaveNames) {
    return func.name;
  }
  var str = func.toString();
  var match = str.match(regex);
  return match && match[1];
}
assert.AssertionError = function AssertionError(options) {
  this.name = 'AssertionError';
  this.actual = options.actual;
  this.expected = options.expected;
  this.operator = options.operator;
  if (options.message) {
    this.message = options.message;
    this.generatedMessage = false;
  } else {
    this.message = getMessage(this);
    this.generatedMessage = true;
  }
  var stackStartFunction = options.stackStartFunction || fail;
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, stackStartFunction);
  } else {
    // non v8 browsers so we can have a stacktrace
    var err = new Error();
    if (err.stack) {
      var out = err.stack;

      // try to strip useless frames
      var fn_name = getName(stackStartFunction);
      var idx = out.indexOf('\n' + fn_name);
      if (idx >= 0) {
        // once we have located the function frame
        // we need to strip out everything before it (and its line)
        var next_line = out.indexOf('\n', idx + 1);
        out = out.substring(next_line + 1);
      }

      this.stack = out;
    }
  }
};

// assert.AssertionError instanceof Error
util.inherits(assert.AssertionError, Error);

function truncate(s, n) {
  if (typeof s === 'string') {
    return s.length < n ? s : s.slice(0, n);
  } else {
    return s;
  }
}
function inspect(something) {
  if (functionsHaveNames || !util.isFunction(something)) {
    return util.inspect(something);
  }
  var rawname = getName(something);
  var name = rawname ? ': ' + rawname : '';
  return '[Function' +  name + ']';
}
function getMessage(self) {
  return truncate(inspect(self.actual), 128) + ' ' +
         self.operator + ' ' +
         truncate(inspect(self.expected), 128);
}

// At present only the three keys mentioned above are used and
// understood by the spec. Implementations or sub modules can pass
// other keys to the AssertionError's constructor - they will be
// ignored.

// 3. All of the following functions must throw an AssertionError
// when a corresponding condition is not met, with a message that
// may be undefined if not provided.  All assertion methods provide
// both the actual and expected values to the assertion error for
// display purposes.

function fail(actual, expected, message, operator, stackStartFunction) {
  throw new assert.AssertionError({
    message: message,
    actual: actual,
    expected: expected,
    operator: operator,
    stackStartFunction: stackStartFunction
  });
}

// EXTENSION! allows for well behaved errors defined elsewhere.
assert.fail = fail;

// 4. Pure assertion tests whether a value is truthy, as determined
// by !!guard.
// assert.ok(guard, message_opt);
// This statement is equivalent to assert.equal(true, !!guard,
// message_opt);. To test strictly for the value true, use
// assert.strictEqual(true, guard, message_opt);.

function ok(value, message) {
  if (!value) fail(value, true, message, '==', assert.ok);
}
assert.ok = ok;

// 5. The equality assertion tests shallow, coercive equality with
// ==.
// assert.equal(actual, expected, message_opt);

assert.equal = function equal(actual, expected, message) {
  if (actual != expected) fail(actual, expected, message, '==', assert.equal);
};

// 6. The non-equality assertion tests for whether two objects are not equal
// with != assert.notEqual(actual, expected, message_opt);

assert.notEqual = function notEqual(actual, expected, message) {
  if (actual == expected) {
    fail(actual, expected, message, '!=', assert.notEqual);
  }
};

// 7. The equivalence assertion tests a deep equality relation.
// assert.deepEqual(actual, expected, message_opt);

assert.deepEqual = function deepEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected, false)) {
    fail(actual, expected, message, 'deepEqual', assert.deepEqual);
  }
};

assert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected, true)) {
    fail(actual, expected, message, 'deepStrictEqual', assert.deepStrictEqual);
  }
};

function _deepEqual(actual, expected, strict, memos) {
  // 7.1. All identical values are equivalent, as determined by ===.
  if (actual === expected) {
    return true;
  } else if (isBuffer(actual) && isBuffer(expected)) {
    return compare(actual, expected) === 0;

  // 7.2. If the expected value is a Date object, the actual value is
  // equivalent if it is also a Date object that refers to the same time.
  } else if (util.isDate(actual) && util.isDate(expected)) {
    return actual.getTime() === expected.getTime();

  // 7.3 If the expected value is a RegExp object, the actual value is
  // equivalent if it is also a RegExp object with the same source and
  // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).
  } else if (util.isRegExp(actual) && util.isRegExp(expected)) {
    return actual.source === expected.source &&
           actual.global === expected.global &&
           actual.multiline === expected.multiline &&
           actual.lastIndex === expected.lastIndex &&
           actual.ignoreCase === expected.ignoreCase;

  // 7.4. Other pairs that do not both pass typeof value == 'object',
  // equivalence is determined by ==.
  } else if ((actual === null || typeof actual !== 'object') &&
             (expected === null || typeof expected !== 'object')) {
    return strict ? actual === expected : actual == expected;

  // If both values are instances of typed arrays, wrap their underlying
  // ArrayBuffers in a Buffer each to increase performance
  // This optimization requires the arrays to have the same type as checked by
  // Object.prototype.toString (aka pToString). Never perform binary
  // comparisons for Float*Arrays, though, since e.g. +0 === -0 but their
  // bit patterns are not identical.
  } else if (isView(actual) && isView(expected) &&
             pToString(actual) === pToString(expected) &&
             !(actual instanceof Float32Array ||
               actual instanceof Float64Array)) {
    return compare(new Uint8Array(actual.buffer),
                   new Uint8Array(expected.buffer)) === 0;

  // 7.5 For all other Object pairs, including Array objects, equivalence is
  // determined by having the same number of owned properties (as verified
  // with Object.prototype.hasOwnProperty.call), the same set of keys
  // (although not necessarily the same order), equivalent values for every
  // corresponding key, and an identical 'prototype' property. Note: this
  // accounts for both named and indexed properties on Arrays.
  } else if (isBuffer(actual) !== isBuffer(expected)) {
    return false;
  } else {
    memos = memos || {actual: [], expected: []};

    var actualIndex = memos.actual.indexOf(actual);
    if (actualIndex !== -1) {
      if (actualIndex === memos.expected.indexOf(expected)) {
        return true;
      }
    }

    memos.actual.push(actual);
    memos.expected.push(expected);

    return objEquiv(actual, expected, strict, memos);
  }
}

function isArguments(object) {
  return Object.prototype.toString.call(object) == '[object Arguments]';
}

function objEquiv(a, b, strict, actualVisitedObjects) {
  if (a === null || a === undefined || b === null || b === undefined)
    return false;
  // if one is a primitive, the other must be same
  if (util.isPrimitive(a) || util.isPrimitive(b))
    return a === b;
  if (strict && Object.getPrototypeOf(a) !== Object.getPrototypeOf(b))
    return false;
  var aIsArgs = isArguments(a);
  var bIsArgs = isArguments(b);
  if ((aIsArgs && !bIsArgs) || (!aIsArgs && bIsArgs))
    return false;
  if (aIsArgs) {
    a = pSlice.call(a);
    b = pSlice.call(b);
    return _deepEqual(a, b, strict);
  }
  var ka = objectKeys(a);
  var kb = objectKeys(b);
  var key, i;
  // having the same number of owned properties (keys incorporates
  // hasOwnProperty)
  if (ka.length !== kb.length)
    return false;
  //the same set of keys (although not necessarily the same order),
  ka.sort();
  kb.sort();
  //~~~cheap key test
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] !== kb[i])
      return false;
  }
  //equivalent values for every corresponding key, and
  //~~~possibly expensive deep test
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!_deepEqual(a[key], b[key], strict, actualVisitedObjects))
      return false;
  }
  return true;
}

// 8. The non-equivalence assertion tests for any deep inequality.
// assert.notDeepEqual(actual, expected, message_opt);

assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
  if (_deepEqual(actual, expected, false)) {
    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);
  }
};

assert.notDeepStrictEqual = notDeepStrictEqual;
function notDeepStrictEqual(actual, expected, message) {
  if (_deepEqual(actual, expected, true)) {
    fail(actual, expected, message, 'notDeepStrictEqual', notDeepStrictEqual);
  }
}


// 9. The strict equality assertion tests strict equality, as determined by ===.
// assert.strictEqual(actual, expected, message_opt);

assert.strictEqual = function strictEqual(actual, expected, message) {
  if (actual !== expected) {
    fail(actual, expected, message, '===', assert.strictEqual);
  }
};

// 10. The strict non-equality assertion tests for strict inequality, as
// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);

assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
  if (actual === expected) {
    fail(actual, expected, message, '!==', assert.notStrictEqual);
  }
};

function expectedException(actual, expected) {
  if (!actual || !expected) {
    return false;
  }

  if (Object.prototype.toString.call(expected) == '[object RegExp]') {
    return expected.test(actual);
  }

  try {
    if (actual instanceof expected) {
      return true;
    }
  } catch (e) {
    // Ignore.  The instanceof check doesn't work for arrow functions.
  }

  if (Error.isPrototypeOf(expected)) {
    return false;
  }

  return expected.call({}, actual) === true;
}

function _tryBlock(block) {
  var error;
  try {
    block();
  } catch (e) {
    error = e;
  }
  return error;
}

function _throws(shouldThrow, block, expected, message) {
  var actual;

  if (typeof block !== 'function') {
    throw new TypeError('"block" argument must be a function');
  }

  if (typeof expected === 'string') {
    message = expected;
    expected = null;
  }

  actual = _tryBlock(block);

  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +
            (message ? ' ' + message : '.');

  if (shouldThrow && !actual) {
    fail(actual, expected, 'Missing expected exception' + message);
  }

  var userProvidedMessage = typeof message === 'string';
  var isUnwantedException = !shouldThrow && util.isError(actual);
  var isUnexpectedException = !shouldThrow && actual && !expected;

  if ((isUnwantedException &&
      userProvidedMessage &&
      expectedException(actual, expected)) ||
      isUnexpectedException) {
    fail(actual, expected, 'Got unwanted exception' + message);
  }

  if ((shouldThrow && actual && expected &&
      !expectedException(actual, expected)) || (!shouldThrow && actual)) {
    throw actual;
  }
}

// 11. Expected to throw an error:
// assert.throws(block, Error_opt, message_opt);

assert.throws = function(block, /*optional*/error, /*optional*/message) {
  _throws(true, block, error, message);
};

// EXTENSION! This is annoying to write outside this module.
assert.doesNotThrow = function(block, /*optional*/error, /*optional*/message) {
  _throws(false, block, error, message);
};

assert.ifError = function(err) { if (err) throw err; };

var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    if (hasOwn.call(obj, key)) keys.push(key);
  }
  return keys;
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"util/":86}],4:[function(require,module,exports){
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function placeHoldersCount (b64) {
  var len = b64.length
  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // the number of equal signs (place holders)
  // if there are two placeholders, than the two characters before it
  // represent one byte
  // if there is only one, then the three characters before it represent 2 bytes
  // this is just a cheap hack to not do indexOf twice
  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0
}

function byteLength (b64) {
  // base64 is 4/3 + up to two characters of the original data
  return b64.length * 3 / 4 - placeHoldersCount(b64)
}

function toByteArray (b64) {
  var i, j, l, tmp, placeHolders, arr
  var len = b64.length
  placeHolders = placeHoldersCount(b64)

  arr = new Arr(len * 3 / 4 - placeHolders)

  // if there are placeholders, only get up to the last complete 4 chars
  l = placeHolders > 0 ? len - 4 : len

  var L = 0

  for (i = 0, j = 0; i < l; i += 4, j += 3) {
    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]
    arr[L++] = (tmp >> 16) & 0xFF
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  if (placeHolders === 2) {
    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[L++] = tmp & 0xFF
  } else if (placeHolders === 1) {
    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var output = ''
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    output += lookup[tmp >> 2]
    output += lookup[(tmp << 4) & 0x3F]
    output += '=='
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])
    output += lookup[tmp >> 10]
    output += lookup[(tmp >> 4) & 0x3F]
    output += lookup[(tmp << 2) & 0x3F]
    output += '='
  }

  parts.push(output)

  return parts.join('')
}

},{}],5:[function(require,module,exports){

},{}],6:[function(require,module,exports){
'use strict';


var TYPED_OK =  (typeof Uint8Array !== 'undefined') &&
                (typeof Uint16Array !== 'undefined') &&
                (typeof Int32Array !== 'undefined');


exports.assign = function (obj /*from1, from2, from3, ...*/) {
  var sources = Array.prototype.slice.call(arguments, 1);
  while (sources.length) {
    var source = sources.shift();
    if (!source) { continue; }

    if (typeof source !== 'object') {
      throw new TypeError(source + 'must be non-object');
    }

    for (var p in source) {
      if (source.hasOwnProperty(p)) {
        obj[p] = source[p];
      }
    }
  }

  return obj;
};


// reduce buffer size, avoiding mem copy
exports.shrinkBuf = function (buf, size) {
  if (buf.length === size) { return buf; }
  if (buf.subarray) { return buf.subarray(0, size); }
  buf.length = size;
  return buf;
};


var fnTyped = {
  arraySet: function (dest, src, src_offs, len, dest_offs) {
    if (src.subarray && dest.subarray) {
      dest.set(src.subarray(src_offs, src_offs + len), dest_offs);
      return;
    }
    // Fallback to ordinary array
    for (var i = 0; i < len; i++) {
      dest[dest_offs + i] = src[src_offs + i];
    }
  },
  // Join array of chunks to single array.
  flattenChunks: function (chunks) {
    var i, l, len, pos, chunk, result;

    // calculate data length
    len = 0;
    for (i = 0, l = chunks.length; i < l; i++) {
      len += chunks[i].length;
    }

    // join chunks
    result = new Uint8Array(len);
    pos = 0;
    for (i = 0, l = chunks.length; i < l; i++) {
      chunk = chunks[i];
      result.set(chunk, pos);
      pos += chunk.length;
    }

    return result;
  }
};

var fnUntyped = {
  arraySet: function (dest, src, src_offs, len, dest_offs) {
    for (var i = 0; i < len; i++) {
      dest[dest_offs + i] = src[src_offs + i];
    }
  },
  // Join array of chunks to single array.
  flattenChunks: function (chunks) {
    return [].concat.apply([], chunks);
  }
};


// Enable/Disable typed arrays use, for testing
//
exports.setTyped = function (on) {
  if (on) {
    exports.Buf8  = Uint8Array;
    exports.Buf16 = Uint16Array;
    exports.Buf32 = Int32Array;
    exports.assign(exports, fnTyped);
  } else {
    exports.Buf8  = Array;
    exports.Buf16 = Array;
    exports.Buf32 = Array;
    exports.assign(exports, fnUntyped);
  }
};

exports.setTyped(TYPED_OK);

},{}],7:[function(require,module,exports){
'use strict';

// Note: adler32 takes 12% for level 0 and 2% for level 6.
// It doesn't worth to make additional optimizationa as in original.
// Small size is preferable.

function adler32(adler, buf, len, pos) {
  var s1 = (adler & 0xffff) |0,
      s2 = ((adler >>> 16) & 0xffff) |0,
      n = 0;

  while (len !== 0) {
    // Set limit ~ twice less than 5552, to keep
    // s2 in 31-bits, because we force signed ints.
    // in other case %= will fail.
    n = len > 2000 ? 2000 : len;
    len -= n;

    do {
      s1 = (s1 + buf[pos++]) |0;
      s2 = (s2 + s1) |0;
    } while (--n);

    s1 %= 65521;
    s2 %= 65521;
  }

  return (s1 | (s2 << 16)) |0;
}


module.exports = adler32;

},{}],8:[function(require,module,exports){
'use strict';


module.exports = {

  /* Allowed flush values; see deflate() and inflate() below for details */
  Z_NO_FLUSH:         0,
  Z_PARTIAL_FLUSH:    1,
  Z_SYNC_FLUSH:       2,
  Z_FULL_FLUSH:       3,
  Z_FINISH:           4,
  Z_BLOCK:            5,
  Z_TREES:            6,

  /* Return codes for the compression/decompression functions. Negative values
  * are errors, positive values are used for special but normal events.
  */
  Z_OK:               0,
  Z_STREAM_END:       1,
  Z_NEED_DICT:        2,
  Z_ERRNO:           -1,
  Z_STREAM_ERROR:    -2,
  Z_DATA_ERROR:      -3,
  //Z_MEM_ERROR:     -4,
  Z_BUF_ERROR:       -5,
  //Z_VERSION_ERROR: -6,

  /* compression levels */
  Z_NO_COMPRESSION:         0,
  Z_BEST_SPEED:             1,
  Z_BEST_COMPRESSION:       9,
  Z_DEFAULT_COMPRESSION:   -1,


  Z_FILTERED:               1,
  Z_HUFFMAN_ONLY:           2,
  Z_RLE:                    3,
  Z_FIXED:                  4,
  Z_DEFAULT_STRATEGY:       0,

  /* Possible values of the data_type field (though see inflate()) */
  Z_BINARY:                 0,
  Z_TEXT:                   1,
  //Z_ASCII:                1, // = Z_TEXT (deprecated)
  Z_UNKNOWN:                2,

  /* The deflate compression method */
  Z_DEFLATED:               8
  //Z_NULL:                 null // Use -1 or null inline, depending on var type
};

},{}],9:[function(require,module,exports){
'use strict';

// Note: we can't get significant speed boost here.
// So write code to minimize size - no pregenerated tables
// and array tools dependencies.


// Use ordinary array, since untyped makes no boost here
function makeTable() {
  var c, table = [];

  for (var n = 0; n < 256; n++) {
    c = n;
    for (var k = 0; k < 8; k++) {
      c = ((c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));
    }
    table[n] = c;
  }

  return table;
}

// Create table on load. Just 255 signed longs. Not a problem.
var crcTable = makeTable();


function crc32(crc, buf, len, pos) {
  var t = crcTable,
      end = pos + len;

  crc ^= -1;

  for (var i = pos; i < end; i++) {
    crc = (crc >>> 8) ^ t[(crc ^ buf[i]) & 0xFF];
  }

  return (crc ^ (-1)); // >>> 0;
}


module.exports = crc32;

},{}],10:[function(require,module,exports){
'use strict';

var utils   = require('../utils/common');
var trees   = require('./trees');
var adler32 = require('./adler32');
var crc32   = require('./crc32');
var msg     = require('./messages');

/* Public constants ==========================================================*/
/* ===========================================================================*/


/* Allowed flush values; see deflate() and inflate() below for details */
var Z_NO_FLUSH      = 0;
var Z_PARTIAL_FLUSH = 1;
//var Z_SYNC_FLUSH    = 2;
var Z_FULL_FLUSH    = 3;
var Z_FINISH        = 4;
var Z_BLOCK         = 5;
//var Z_TREES         = 6;


/* Return codes for the compression/decompression functions. Negative values
 * are errors, positive values are used for special but normal events.
 */
var Z_OK            = 0;
var Z_STREAM_END    = 1;
//var Z_NEED_DICT     = 2;
//var Z_ERRNO         = -1;
var Z_STREAM_ERROR  = -2;
var Z_DATA_ERROR    = -3;
//var Z_MEM_ERROR     = -4;
var Z_BUF_ERROR     = -5;
//var Z_VERSION_ERROR = -6;


/* compression levels */
//var Z_NO_COMPRESSION      = 0;
//var Z_BEST_SPEED          = 1;
//var Z_BEST_COMPRESSION    = 9;
var Z_DEFAULT_COMPRESSION = -1;


var Z_FILTERED            = 1;
var Z_HUFFMAN_ONLY        = 2;
var Z_RLE                 = 3;
var Z_FIXED               = 4;
var Z_DEFAULT_STRATEGY    = 0;

/* Possible values of the data_type field (though see inflate()) */
//var Z_BINARY              = 0;
//var Z_TEXT                = 1;
//var Z_ASCII               = 1; // = Z_TEXT
var Z_UNKNOWN             = 2;


/* The deflate compression method */
var Z_DEFLATED  = 8;

/*============================================================================*/


var MAX_MEM_LEVEL = 9;
/* Maximum value for memLevel in deflateInit2 */
var MAX_WBITS = 15;
/* 32K LZ77 window */
var DEF_MEM_LEVEL = 8;


var LENGTH_CODES  = 29;
/* number of length codes, not counting the special END_BLOCK code */
var LITERALS      = 256;
/* number of literal bytes 0..255 */
var L_CODES       = LITERALS + 1 + LENGTH_CODES;
/* number of Literal or Length codes, including the END_BLOCK code */
var D_CODES       = 30;
/* number of distance codes */
var BL_CODES      = 19;
/* number of codes used to transfer the bit lengths */
var HEAP_SIZE     = 2 * L_CODES + 1;
/* maximum heap size */
var MAX_BITS  = 15;
/* All codes must not exceed MAX_BITS bits */

var MIN_MATCH = 3;
var MAX_MATCH = 258;
var MIN_LOOKAHEAD = (MAX_MATCH + MIN_MATCH + 1);

var PRESET_DICT = 0x20;

var INIT_STATE = 42;
var EXTRA_STATE = 69;
var NAME_STATE = 73;
var COMMENT_STATE = 91;
var HCRC_STATE = 103;
var BUSY_STATE = 113;
var FINISH_STATE = 666;

var BS_NEED_MORE      = 1; /* block not completed, need more input or more output */
var BS_BLOCK_DONE     = 2; /* block flush performed */
var BS_FINISH_STARTED = 3; /* finish started, need only more output at next deflate */
var BS_FINISH_DONE    = 4; /* finish done, accept no more input or output */

var OS_CODE = 0x03; // Unix :) . Don't detect, use this default.

function err(strm, errorCode) {
  strm.msg = msg[errorCode];
  return errorCode;
}

function rank(f) {
  return ((f) << 1) - ((f) > 4 ? 9 : 0);
}

function zero(buf) { var len = buf.length; while (--len >= 0) { buf[len] = 0; } }


/* =========================================================================
 * Flush as much pending output as possible. All deflate() output goes
 * through this function so some applications may wish to modify it
 * to avoid allocating a large strm->output buffer and copying into it.
 * (See also read_buf()).
 */
function flush_pending(strm) {
  var s = strm.state;

  //_tr_flush_bits(s);
  var len = s.pending;
  if (len > strm.avail_out) {
    len = strm.avail_out;
  }
  if (len === 0) { return; }

  utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);
  strm.next_out += len;
  s.pending_out += len;
  strm.total_out += len;
  strm.avail_out -= len;
  s.pending -= len;
  if (s.pending === 0) {
    s.pending_out = 0;
  }
}


function flush_block_only(s, last) {
  trees._tr_flush_block(s, (s.block_start >= 0 ? s.block_start : -1), s.strstart - s.block_start, last);
  s.block_start = s.strstart;
  flush_pending(s.strm);
}


function put_byte(s, b) {
  s.pending_buf[s.pending++] = b;
}


/* =========================================================================
 * Put a short in the pending buffer. The 16-bit value is put in MSB order.
 * IN assertion: the stream state is correct and there is enough room in
 * pending_buf.
 */
function putShortMSB(s, b) {
//  put_byte(s, (Byte)(b >> 8));
//  put_byte(s, (Byte)(b & 0xff));
  s.pending_buf[s.pending++] = (b >>> 8) & 0xff;
  s.pending_buf[s.pending++] = b & 0xff;
}


/* ===========================================================================
 * Read a new buffer from the current input stream, update the adler32
 * and total number of bytes read.  All deflate() input goes through
 * this function so some applications may wish to modify it to avoid
 * allocating a large strm->input buffer and copying from it.
 * (See also flush_pending()).
 */
function read_buf(strm, buf, start, size) {
  var len = strm.avail_in;

  if (len > size) { len = size; }
  if (len === 0) { return 0; }

  strm.avail_in -= len;

  // zmemcpy(buf, strm->next_in, len);
  utils.arraySet(buf, strm.input, strm.next_in, len, start);
  if (strm.state.wrap === 1) {
    strm.adler = adler32(strm.adler, buf, len, start);
  }

  else if (strm.state.wrap === 2) {
    strm.adler = crc32(strm.adler, buf, len, start);
  }

  strm.next_in += len;
  strm.total_in += len;

  return len;
}


/* ===========================================================================
 * Set match_start to the longest match starting at the given string and
 * return its length. Matches shorter or equal to prev_length are discarded,
 * in which case the result is equal to prev_length and match_start is
 * garbage.
 * IN assertions: cur_match is the head of the hash chain for the current
 *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1
 * OUT assertion: the match length is not greater than s->lookahead.
 */
function longest_match(s, cur_match) {
  var chain_length = s.max_chain_length;      /* max hash chain length */
  var scan = s.strstart; /* current string */
  var match;                       /* matched string */
  var len;                           /* length of current match */
  var best_len = s.prev_length;              /* best match length so far */
  var nice_match = s.nice_match;             /* stop if match long enough */
  var limit = (s.strstart > (s.w_size - MIN_LOOKAHEAD)) ?
      s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0/*NIL*/;

  var _win = s.window; // shortcut

  var wmask = s.w_mask;
  var prev  = s.prev;

  /* Stop when cur_match becomes <= limit. To simplify the code,
   * we prevent matches with the string of window index 0.
   */

  var strend = s.strstart + MAX_MATCH;
  var scan_end1  = _win[scan + best_len - 1];
  var scan_end   = _win[scan + best_len];

  /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
   * It is easy to get rid of this optimization if necessary.
   */
  // Assert(s->hash_bits >= 8 && MAX_MATCH == 258, "Code too clever");

  /* Do not waste too much time if we already have a good match: */
  if (s.prev_length >= s.good_match) {
    chain_length >>= 2;
  }
  /* Do not look for matches beyond the end of the input. This is necessary
   * to make deflate deterministic.
   */
  if (nice_match > s.lookahead) { nice_match = s.lookahead; }

  // Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, "need lookahead");

  do {
    // Assert(cur_match < s->strstart, "no future");
    match = cur_match;

    /* Skip to next match if the match length cannot increase
     * or if the match length is less than 2.  Note that the checks below
     * for insufficient lookahead only occur occasionally for performance
     * reasons.  Therefore uninitialized memory will be accessed, and
     * conditional jumps will be made that depend on those values.
     * However the length of the match is limited to the lookahead, so
     * the output of deflate is not affected by the uninitialized values.
     */

    if (_win[match + best_len]     !== scan_end  ||
        _win[match + best_len - 1] !== scan_end1 ||
        _win[match]                !== _win[scan] ||
        _win[++match]              !== _win[scan + 1]) {
      continue;
    }

    /* The check at best_len-1 can be removed because it will be made
     * again later. (This heuristic is not always a win.)
     * It is not necessary to compare scan[2] and match[2] since they
     * are always equal when the other bytes match, given that
     * the hash keys are equal and that HASH_BITS >= 8.
     */
    scan += 2;
    match++;
    // Assert(*scan == *match, "match[2]?");

    /* We check for insufficient lookahead only every 8th comparison;
     * the 256th check will be made at strstart+258.
     */
    do {
      /*jshint noempty:false*/
    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             scan < strend);

    // Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");

    len = MAX_MATCH - (strend - scan);
    scan = strend - MAX_MATCH;

    if (len > best_len) {
      s.match_start = cur_match;
      best_len = len;
      if (len >= nice_match) {
        break;
      }
      scan_end1  = _win[scan + best_len - 1];
      scan_end   = _win[scan + best_len];
    }
  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);

  if (best_len <= s.lookahead) {
    return best_len;
  }
  return s.lookahead;
}


/* ===========================================================================
 * Fill the window when the lookahead becomes insufficient.
 * Updates strstart and lookahead.
 *
 * IN assertion: lookahead < MIN_LOOKAHEAD
 * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD
 *    At least one byte has been read, or avail_in == 0; reads are
 *    performed for at least two bytes (required for the zip translate_eol
 *    option -- not supported here).
 */
function fill_window(s) {
  var _w_size = s.w_size;
  var p, n, m, more, str;

  //Assert(s->lookahead < MIN_LOOKAHEAD, "already enough lookahead");

  do {
    more = s.window_size - s.lookahead - s.strstart;

    // JS ints have 32 bit, block below not needed
    /* Deal with !@#$% 64K limit: */
    //if (sizeof(int) <= 2) {
    //    if (more == 0 && s->strstart == 0 && s->lookahead == 0) {
    //        more = wsize;
    //
    //  } else if (more == (unsigned)(-1)) {
    //        /* Very unlikely, but possible on 16 bit machine if
    //         * strstart == 0 && lookahead == 1 (input done a byte at time)
    //         */
    //        more--;
    //    }
    //}


    /* If the window is almost full and there is insufficient lookahead,
     * move the upper half to the lower one to make room in the upper half.
     */
    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {

      utils.arraySet(s.window, s.window, _w_size, _w_size, 0);
      s.match_start -= _w_size;
      s.strstart -= _w_size;
      /* we now have strstart >= MAX_DIST */
      s.block_start -= _w_size;

      /* Slide the hash table (could be avoided with 32 bit values
       at the expense of memory usage). We slide even when level == 0
       to keep the hash table consistent if we switch back to level > 0
       later. (Using level 0 permanently is not an optimal usage of
       zlib, so we don't care about this pathological case.)
       */

      n = s.hash_size;
      p = n;
      do {
        m = s.head[--p];
        s.head[p] = (m >= _w_size ? m - _w_size : 0);
      } while (--n);

      n = _w_size;
      p = n;
      do {
        m = s.prev[--p];
        s.prev[p] = (m >= _w_size ? m - _w_size : 0);
        /* If n is not on any hash chain, prev[n] is garbage but
         * its value will never be used.
         */
      } while (--n);

      more += _w_size;
    }
    if (s.strm.avail_in === 0) {
      break;
    }

    /* If there was no sliding:
     *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&
     *    more == window_size - lookahead - strstart
     * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)
     * => more >= window_size - 2*WSIZE + 2
     * In the BIG_MEM or MMAP case (not yet supported),
     *   window_size == input_size + MIN_LOOKAHEAD  &&
     *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.
     * Otherwise, window_size == 2*WSIZE so more >= 2.
     * If there was sliding, more >= WSIZE. So in all cases, more >= 2.
     */
    //Assert(more >= 2, "more < 2");
    n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
    s.lookahead += n;

    /* Initialize the hash value now that we have some input: */
    if (s.lookahead + s.insert >= MIN_MATCH) {
      str = s.strstart - s.insert;
      s.ins_h = s.window[str];

      /* UPDATE_HASH(s, s->ins_h, s->window[str + 1]); */
      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + 1]) & s.hash_mask;
//#if MIN_MATCH != 3
//        Call update_hash() MIN_MATCH-3 more times
//#endif
      while (s.insert) {
        /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;

        s.prev[str & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = str;
        str++;
        s.insert--;
        if (s.lookahead + s.insert < MIN_MATCH) {
          break;
        }
      }
    }
    /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,
     * but this is not important since only literal bytes will be emitted.
     */

  } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);

  /* If the WIN_INIT bytes after the end of the current data have never been
   * written, then zero those bytes in order to avoid memory check reports of
   * the use of uninitialized (or uninitialised as Julian writes) bytes by
   * the longest match routines.  Update the high water mark for the next
   * time through here.  WIN_INIT is set to MAX_MATCH since the longest match
   * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.
   */
//  if (s.high_water < s.window_size) {
//    var curr = s.strstart + s.lookahead;
//    var init = 0;
//
//    if (s.high_water < curr) {
//      /* Previous high water mark below current data -- zero WIN_INIT
//       * bytes or up to end of window, whichever is less.
//       */
//      init = s.window_size - curr;
//      if (init > WIN_INIT)
//        init = WIN_INIT;
//      zmemzero(s->window + curr, (unsigned)init);
//      s->high_water = curr + init;
//    }
//    else if (s->high_water < (ulg)curr + WIN_INIT) {
//      /* High water mark at or above current data, but below current data
//       * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up
//       * to end of window, whichever is less.
//       */
//      init = (ulg)curr + WIN_INIT - s->high_water;
//      if (init > s->window_size - s->high_water)
//        init = s->window_size - s->high_water;
//      zmemzero(s->window + s->high_water, (unsigned)init);
//      s->high_water += init;
//    }
//  }
//
//  Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,
//    "not enough room for search");
}

/* ===========================================================================
 * Copy without compression as much as possible from the input stream, return
 * the current block state.
 * This function does not insert new strings in the dictionary since
 * uncompressible data is probably not useful. This function is used
 * only for the level=0 compression option.
 * NOTE: this function should be optimized to avoid extra copying from
 * window to pending_buf.
 */
function deflate_stored(s, flush) {
  /* Stored blocks are limited to 0xffff bytes, pending_buf is limited
   * to pending_buf_size, and each stored block has a 5 byte header:
   */
  var max_block_size = 0xffff;

  if (max_block_size > s.pending_buf_size - 5) {
    max_block_size = s.pending_buf_size - 5;
  }

  /* Copy as much as possible from input to output: */
  for (;;) {
    /* Fill the window as much as possible: */
    if (s.lookahead <= 1) {

      //Assert(s->strstart < s->w_size+MAX_DIST(s) ||
      //  s->block_start >= (long)s->w_size, "slide too late");
//      if (!(s.strstart < s.w_size + (s.w_size - MIN_LOOKAHEAD) ||
//        s.block_start >= s.w_size)) {
//        throw  new Error("slide too late");
//      }

      fill_window(s);
      if (s.lookahead === 0 && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }

      if (s.lookahead === 0) {
        break;
      }
      /* flush the current block */
    }
    //Assert(s->block_start >= 0L, "block gone");
//    if (s.block_start < 0) throw new Error("block gone");

    s.strstart += s.lookahead;
    s.lookahead = 0;

    /* Emit a stored block if pending_buf will be full: */
    var max_start = s.block_start + max_block_size;

    if (s.strstart === 0 || s.strstart >= max_start) {
      /* strstart == 0 is possible when wraparound on 16-bit machine */
      s.lookahead = s.strstart - max_start;
      s.strstart = max_start;
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/


    }
    /* Flush if we may have to slide, otherwise block_start may become
     * negative and the data will be gone:
     */
    if (s.strstart - s.block_start >= (s.w_size - MIN_LOOKAHEAD)) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }

  s.insert = 0;

  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }

  if (s.strstart > s.block_start) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }

  return BS_NEED_MORE;
}

/* ===========================================================================
 * Compress as much as possible from the input stream, return the current
 * block state.
 * This function does not perform lazy evaluation of matches and inserts
 * new strings in the dictionary only for unmatched strings or for short
 * matches. It is used only for the fast compression options.
 */
function deflate_fast(s, flush) {
  var hash_head;        /* head of the hash chain */
  var bflush;           /* set if current block must be flushed */

  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the next match, plus MIN_MATCH bytes to insert the
     * string following the next match.
     */
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break; /* flush the current block */
      }
    }

    /* Insert the string window[strstart .. strstart+2] in the
     * dictionary, and set hash_head to the head of the hash chain:
     */
    hash_head = 0/*NIL*/;
    if (s.lookahead >= MIN_MATCH) {
      /*** INSERT_STRING(s, s.strstart, hash_head); ***/
      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
      /***/
    }

    /* Find the longest match, discarding those <= prev_length.
     * At this point we have always match_length < MIN_MATCH
     */
    if (hash_head !== 0/*NIL*/ && ((s.strstart - hash_head) <= (s.w_size - MIN_LOOKAHEAD))) {
      /* To simplify the code, we prevent matches with the string
       * of window index 0 (in particular we have to avoid a match
       * of the string with itself at the start of the input file).
       */
      s.match_length = longest_match(s, hash_head);
      /* longest_match() sets match_start */
    }
    if (s.match_length >= MIN_MATCH) {
      // check_match(s, s.strstart, s.match_start, s.match_length); // for debug only

      /*** _tr_tally_dist(s, s.strstart - s.match_start,
                     s.match_length - MIN_MATCH, bflush); ***/
      bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);

      s.lookahead -= s.match_length;

      /* Insert new strings in the hash table only if the match length
       * is not too large. This saves time but degrades compression.
       */
      if (s.match_length <= s.max_lazy_match/*max_insert_length*/ && s.lookahead >= MIN_MATCH) {
        s.match_length--; /* string at strstart already in table */
        do {
          s.strstart++;
          /*** INSERT_STRING(s, s.strstart, hash_head); ***/
          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
          /***/
          /* strstart never exceeds WSIZE-MAX_MATCH, so there are
           * always MIN_MATCH bytes ahead.
           */
        } while (--s.match_length !== 0);
        s.strstart++;
      } else
      {
        s.strstart += s.match_length;
        s.match_length = 0;
        s.ins_h = s.window[s.strstart];
        /* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); */
        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + 1]) & s.hash_mask;

//#if MIN_MATCH != 3
//                Call UPDATE_HASH() MIN_MATCH-3 more times
//#endif
        /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not
         * matter since it will be recomputed at next deflate call.
         */
      }
    } else {
      /* No match, output a literal byte */
      //Tracevv((stderr,"%c", s.window[s.strstart]));
      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);

      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = ((s.strstart < (MIN_MATCH - 1)) ? s.strstart : MIN_MATCH - 1);
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
}

/* ===========================================================================
 * Same as above, but achieves better compression. We use a lazy
 * evaluation for matches: a match is finally adopted only if there is
 * no better match at the next window position.
 */
function deflate_slow(s, flush) {
  var hash_head;          /* head of hash chain */
  var bflush;              /* set if current block must be flushed */

  var max_insert;

  /* Process the input block. */
  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the next match, plus MIN_MATCH bytes to insert the
     * string following the next match.
     */
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) { break; } /* flush the current block */
    }

    /* Insert the string window[strstart .. strstart+2] in the
     * dictionary, and set hash_head to the head of the hash chain:
     */
    hash_head = 0/*NIL*/;
    if (s.lookahead >= MIN_MATCH) {
      /*** INSERT_STRING(s, s.strstart, hash_head); ***/
      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
      /***/
    }

    /* Find the longest match, discarding those <= prev_length.
     */
    s.prev_length = s.match_length;
    s.prev_match = s.match_start;
    s.match_length = MIN_MATCH - 1;

    if (hash_head !== 0/*NIL*/ && s.prev_length < s.max_lazy_match &&
        s.strstart - hash_head <= (s.w_size - MIN_LOOKAHEAD)/*MAX_DIST(s)*/) {
      /* To simplify the code, we prevent matches with the string
       * of window index 0 (in particular we have to avoid a match
       * of the string with itself at the start of the input file).
       */
      s.match_length = longest_match(s, hash_head);
      /* longest_match() sets match_start */

      if (s.match_length <= 5 &&
         (s.strategy === Z_FILTERED || (s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096/*TOO_FAR*/))) {

        /* If prev_match is also MIN_MATCH, match_start is garbage
         * but we will ignore the current match anyway.
         */
        s.match_length = MIN_MATCH - 1;
      }
    }
    /* If there was a match at the previous step and the current
     * match is not better, output the previous match:
     */
    if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
      max_insert = s.strstart + s.lookahead - MIN_MATCH;
      /* Do not insert strings in hash table beyond this. */

      //check_match(s, s.strstart-1, s.prev_match, s.prev_length);

      /***_tr_tally_dist(s, s.strstart - 1 - s.prev_match,
                     s.prev_length - MIN_MATCH, bflush);***/
      bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
      /* Insert in hash table all strings up to the end of the match.
       * strstart-1 and strstart are already inserted. If there is not
       * enough lookahead, the last two strings are not inserted in
       * the hash table.
       */
      s.lookahead -= s.prev_length - 1;
      s.prev_length -= 2;
      do {
        if (++s.strstart <= max_insert) {
          /*** INSERT_STRING(s, s.strstart, hash_head); ***/
          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
          /***/
        }
      } while (--s.prev_length !== 0);
      s.match_available = 0;
      s.match_length = MIN_MATCH - 1;
      s.strstart++;

      if (bflush) {
        /*** FLUSH_BLOCK(s, 0); ***/
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
        /***/
      }

    } else if (s.match_available) {
      /* If there was no match at the previous position, output a
       * single literal. If there was a match but the current match
       * is longer, truncate the previous match to a single literal.
       */
      //Tracevv((stderr,"%c", s->window[s->strstart-1]));
      /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
      bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);

      if (bflush) {
        /*** FLUSH_BLOCK_ONLY(s, 0) ***/
        flush_block_only(s, false);
        /***/
      }
      s.strstart++;
      s.lookahead--;
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    } else {
      /* There is no previous match to compare with, wait for
       * the next step to decide.
       */
      s.match_available = 1;
      s.strstart++;
      s.lookahead--;
    }
  }
  //Assert (flush != Z_NO_FLUSH, "no flush?");
  if (s.match_available) {
    //Tracevv((stderr,"%c", s->window[s->strstart-1]));
    /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
    bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);

    s.match_available = 0;
  }
  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }

  return BS_BLOCK_DONE;
}


/* ===========================================================================
 * For Z_RLE, simply look for runs of bytes, generate matches only of distance
 * one.  Do not maintain a hash table.  (It will be regenerated if this run of
 * deflate switches away from Z_RLE.)
 */
function deflate_rle(s, flush) {
  var bflush;            /* set if current block must be flushed */
  var prev;              /* byte at distance one to match */
  var scan, strend;      /* scan goes up to strend for length of run */

  var _win = s.window;

  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the longest run, plus one for the unrolled loop.
     */
    if (s.lookahead <= MAX_MATCH) {
      fill_window(s);
      if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) { break; } /* flush the current block */
    }

    /* See how many times the previous byte repeats */
    s.match_length = 0;
    if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
      scan = s.strstart - 1;
      prev = _win[scan];
      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
        strend = s.strstart + MAX_MATCH;
        do {
          /*jshint noempty:false*/
        } while (prev === _win[++scan] && prev === _win[++scan] &&
                 prev === _win[++scan] && prev === _win[++scan] &&
                 prev === _win[++scan] && prev === _win[++scan] &&
                 prev === _win[++scan] && prev === _win[++scan] &&
                 scan < strend);
        s.match_length = MAX_MATCH - (strend - scan);
        if (s.match_length > s.lookahead) {
          s.match_length = s.lookahead;
        }
      }
      //Assert(scan <= s->window+(uInt)(s->window_size-1), "wild scan");
    }

    /* Emit match if have run of MIN_MATCH or longer, else emit literal */
    if (s.match_length >= MIN_MATCH) {
      //check_match(s, s.strstart, s.strstart - 1, s.match_length);

      /*** _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ***/
      bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);

      s.lookahead -= s.match_length;
      s.strstart += s.match_length;
      s.match_length = 0;
    } else {
      /* No match, output a literal byte */
      //Tracevv((stderr,"%c", s->window[s->strstart]));
      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);

      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
}

/* ===========================================================================
 * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.
 * (It will be regenerated if this run of deflate switches away from Huffman.)
 */
function deflate_huff(s, flush) {
  var bflush;             /* set if current block must be flushed */

  for (;;) {
    /* Make sure that we have a literal to write. */
    if (s.lookahead === 0) {
      fill_window(s);
      if (s.lookahead === 0) {
        if (flush === Z_NO_FLUSH) {
          return BS_NEED_MORE;
        }
        break;      /* flush the current block */
      }
    }

    /* Output a literal byte */
    s.match_length = 0;
    //Tracevv((stderr,"%c", s->window[s->strstart]));
    /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
    bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
    s.lookahead--;
    s.strstart++;
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
}

/* Values for max_lazy_match, good_match and max_chain_length, depending on
 * the desired pack level (0..9). The values given below have been tuned to
 * exclude worst case performance for pathological files. Better values may be
 * found for specific files.
 */
function Config(good_length, max_lazy, nice_length, max_chain, func) {
  this.good_length = good_length;
  this.max_lazy = max_lazy;
  this.nice_length = nice_length;
  this.max_chain = max_chain;
  this.func = func;
}

var configuration_table;

configuration_table = [
  /*      good lazy nice chain */
  new Config(0, 0, 0, 0, deflate_stored),          /* 0 store only */
  new Config(4, 4, 8, 4, deflate_fast),            /* 1 max speed, no lazy matches */
  new Config(4, 5, 16, 8, deflate_fast),           /* 2 */
  new Config(4, 6, 32, 32, deflate_fast),          /* 3 */

  new Config(4, 4, 16, 16, deflate_slow),          /* 4 lazy matches */
  new Config(8, 16, 32, 32, deflate_slow),         /* 5 */
  new Config(8, 16, 128, 128, deflate_slow),       /* 6 */
  new Config(8, 32, 128, 256, deflate_slow),       /* 7 */
  new Config(32, 128, 258, 1024, deflate_slow),    /* 8 */
  new Config(32, 258, 258, 4096, deflate_slow)     /* 9 max compression */
];


/* ===========================================================================
 * Initialize the "longest match" routines for a new zlib stream
 */
function lm_init(s) {
  s.window_size = 2 * s.w_size;

  /*** CLEAR_HASH(s); ***/
  zero(s.head); // Fill with NIL (= 0);

  /* Set the default configuration parameters:
   */
  s.max_lazy_match = configuration_table[s.level].max_lazy;
  s.good_match = configuration_table[s.level].good_length;
  s.nice_match = configuration_table[s.level].nice_length;
  s.max_chain_length = configuration_table[s.level].max_chain;

  s.strstart = 0;
  s.block_start = 0;
  s.lookahead = 0;
  s.insert = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  s.ins_h = 0;
}


function DeflateState() {
  this.strm = null;            /* pointer back to this zlib stream */
  this.status = 0;            /* as the name implies */
  this.pending_buf = null;      /* output still pending */
  this.pending_buf_size = 0;  /* size of pending_buf */
  this.pending_out = 0;       /* next pending byte to output to the stream */
  this.pending = 0;           /* nb of bytes in the pending buffer */
  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */
  this.gzhead = null;         /* gzip header information to write */
  this.gzindex = 0;           /* where in extra, name, or comment */
  this.method = Z_DEFLATED; /* can only be DEFLATED */
  this.last_flush = -1;   /* value of flush param for previous deflate call */

  this.w_size = 0;  /* LZ77 window size (32K by default) */
  this.w_bits = 0;  /* log2(w_size)  (8..16) */
  this.w_mask = 0;  /* w_size - 1 */

  this.window = null;
  /* Sliding window. Input bytes are read into the second half of the window,
   * and move to the first half later to keep a dictionary of at least wSize
   * bytes. With this organization, matches are limited to a distance of
   * wSize-MAX_MATCH bytes, but this ensures that IO is always
   * performed with a length multiple of the block size.
   */

  this.window_size = 0;
  /* Actual size of window: 2*wSize, except when the user input buffer
   * is directly used as sliding window.
   */

  this.prev = null;
  /* Link to older string with same hash index. To limit the size of this
   * array to 64K, this link is maintained only for the last 32K strings.
   * An index in this array is thus a window index modulo 32K.
   */

  this.head = null;   /* Heads of the hash chains or NIL. */

  this.ins_h = 0;       /* hash index of string to be inserted */
  this.hash_size = 0;   /* number of elements in hash table */
  this.hash_bits = 0;   /* log2(hash_size) */
  this.hash_mask = 0;   /* hash_size-1 */

  this.hash_shift = 0;
  /* Number of bits by which ins_h must be shifted at each input
   * step. It must be such that after MIN_MATCH steps, the oldest
   * byte no longer takes part in the hash key, that is:
   *   hash_shift * MIN_MATCH >= hash_bits
   */

  this.block_start = 0;
  /* Window position at the beginning of the current output block. Gets
   * negative when the window is moved backwards.
   */

  this.match_length = 0;      /* length of best match */
  this.prev_match = 0;        /* previous match */
  this.match_available = 0;   /* set if previous match exists */
  this.strstart = 0;          /* start of string to insert */
  this.match_start = 0;       /* start of matching string */
  this.lookahead = 0;         /* number of valid bytes ahead in window */

  this.prev_length = 0;
  /* Length of the best match at previous step. Matches not greater than this
   * are discarded. This is used in the lazy match evaluation.
   */

  this.max_chain_length = 0;
  /* To speed up deflation, hash chains are never searched beyond this
   * length.  A higher limit improves compression ratio but degrades the
   * speed.
   */

  this.max_lazy_match = 0;
  /* Attempt to find a better match only when the current match is strictly
   * smaller than this value. This mechanism is used only for compression
   * levels >= 4.
   */
  // That's alias to max_lazy_match, don't use directly
  //this.max_insert_length = 0;
  /* Insert new strings in the hash table only if the match length is not
   * greater than this length. This saves time but degrades compression.
   * max_insert_length is used only for compression levels <= 3.
   */

  this.level = 0;     /* compression level (1..9) */
  this.strategy = 0;  /* favor or force Huffman coding*/

  this.good_match = 0;
  /* Use a faster search when the previous match is longer than this */

  this.nice_match = 0; /* Stop searching when current match exceeds this */

              /* used by trees.c: */

  /* Didn't use ct_data typedef below to suppress compiler warning */

  // struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */
  // struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */
  // struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */

  // Use flat array of DOUBLE size, with interleaved fata,
  // because JS does not support effective
  this.dyn_ltree  = new utils.Buf16(HEAP_SIZE * 2);
  this.dyn_dtree  = new utils.Buf16((2 * D_CODES + 1) * 2);
  this.bl_tree    = new utils.Buf16((2 * BL_CODES + 1) * 2);
  zero(this.dyn_ltree);
  zero(this.dyn_dtree);
  zero(this.bl_tree);

  this.l_desc   = null;         /* desc. for literal tree */
  this.d_desc   = null;         /* desc. for distance tree */
  this.bl_desc  = null;         /* desc. for bit length tree */

  //ush bl_count[MAX_BITS+1];
  this.bl_count = new utils.Buf16(MAX_BITS + 1);
  /* number of codes at each bit length for an optimal tree */

  //int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */
  this.heap = new utils.Buf16(2 * L_CODES + 1);  /* heap used to build the Huffman trees */
  zero(this.heap);

  this.heap_len = 0;               /* number of elements in the heap */
  this.heap_max = 0;               /* element of largest frequency */
  /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.
   * The same heap array is used to build all trees.
   */

  this.depth = new utils.Buf16(2 * L_CODES + 1); //uch depth[2*L_CODES+1];
  zero(this.depth);
  /* Depth of each subtree used as tie breaker for trees of equal frequency
   */

  this.l_buf = 0;          /* buffer index for literals or lengths */

  this.lit_bufsize = 0;
  /* Size of match buffer for literals/lengths.  There are 4 reasons for
   * limiting lit_bufsize to 64K:
   *   - frequencies can be kept in 16 bit counters
   *   - if compression is not successful for the first block, all input
   *     data is still in the window so we can still emit a stored block even
   *     when input comes from standard input.  (This can also be done for
   *     all blocks if lit_bufsize is not greater than 32K.)
   *   - if compression is not successful for a file smaller than 64K, we can
   *     even emit a stored file instead of a stored block (saving 5 bytes).
   *     This is applicable only for zip (not gzip or zlib).
   *   - creating new Huffman trees less frequently may not provide fast
   *     adaptation to changes in the input data statistics. (Take for
   *     example a binary file with poorly compressible code followed by
   *     a highly compressible string table.) Smaller buffer sizes give
   *     fast adaptation but have of course the overhead of transmitting
   *     trees more frequently.
   *   - I can't count above 4
   */

  this.last_lit = 0;      /* running index in l_buf */

  this.d_buf = 0;
  /* Buffer index for distances. To simplify the code, d_buf and l_buf have
   * the same number of elements. To use different lengths, an extra flag
   * array would be necessary.
   */

  this.opt_len = 0;       /* bit length of current block with optimal trees */
  this.static_len = 0;    /* bit length of current block with static trees */
  this.matches = 0;       /* number of string matches in current block */
  this.insert = 0;        /* bytes at end of window left to insert */


  this.bi_buf = 0;
  /* Output buffer. bits are inserted starting at the bottom (least
   * significant bits).
   */
  this.bi_valid = 0;
  /* Number of valid bits in bi_buf.  All bits above the last valid bit
   * are always zero.
   */

  // Used for window memory init. We safely ignore it for JS. That makes
  // sense only for pointers and memory check tools.
  //this.high_water = 0;
  /* High water mark offset in window for initialized bytes -- bytes above
   * this are set to zero in order to avoid memory check warnings when
   * longest match routines access bytes past the input.  This is then
   * updated to the new high water mark.
   */
}


function deflateResetKeep(strm) {
  var s;

  if (!strm || !strm.state) {
    return err(strm, Z_STREAM_ERROR);
  }

  strm.total_in = strm.total_out = 0;
  strm.data_type = Z_UNKNOWN;

  s = strm.state;
  s.pending = 0;
  s.pending_out = 0;

  if (s.wrap < 0) {
    s.wrap = -s.wrap;
    /* was made negative by deflate(..., Z_FINISH); */
  }
  s.status = (s.wrap ? INIT_STATE : BUSY_STATE);
  strm.adler = (s.wrap === 2) ?
    0  // crc32(0, Z_NULL, 0)
  :
    1; // adler32(0, Z_NULL, 0)
  s.last_flush = Z_NO_FLUSH;
  trees._tr_init(s);
  return Z_OK;
}


function deflateReset(strm) {
  var ret = deflateResetKeep(strm);
  if (ret === Z_OK) {
    lm_init(strm.state);
  }
  return ret;
}


function deflateSetHeader(strm, head) {
  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  if (strm.state.wrap !== 2) { return Z_STREAM_ERROR; }
  strm.state.gzhead = head;
  return Z_OK;
}


function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
  if (!strm) { // === Z_NULL
    return Z_STREAM_ERROR;
  }
  var wrap = 1;

  if (level === Z_DEFAULT_COMPRESSION) {
    level = 6;
  }

  if (windowBits < 0) { /* suppress zlib wrapper */
    wrap = 0;
    windowBits = -windowBits;
  }

  else if (windowBits > 15) {
    wrap = 2;           /* write gzip wrapper instead */
    windowBits -= 16;
  }


  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED ||
    windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||
    strategy < 0 || strategy > Z_FIXED) {
    return err(strm, Z_STREAM_ERROR);
  }


  if (windowBits === 8) {
    windowBits = 9;
  }
  /* until 256-byte window bug fixed */

  var s = new DeflateState();

  strm.state = s;
  s.strm = strm;

  s.wrap = wrap;
  s.gzhead = null;
  s.w_bits = windowBits;
  s.w_size = 1 << s.w_bits;
  s.w_mask = s.w_size - 1;

  s.hash_bits = memLevel + 7;
  s.hash_size = 1 << s.hash_bits;
  s.hash_mask = s.hash_size - 1;
  s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);

  s.window = new utils.Buf8(s.w_size * 2);
  s.head = new utils.Buf16(s.hash_size);
  s.prev = new utils.Buf16(s.w_size);

  // Don't need mem init magic for JS.
  //s.high_water = 0;  /* nothing written to s->window yet */

  s.lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */

  s.pending_buf_size = s.lit_bufsize * 4;

  //overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);
  //s->pending_buf = (uchf *) overlay;
  s.pending_buf = new utils.Buf8(s.pending_buf_size);

  // It is offset from `s.pending_buf` (size is `s.lit_bufsize * 2`)
  //s->d_buf = overlay + s->lit_bufsize/sizeof(ush);
  s.d_buf = 1 * s.lit_bufsize;

  //s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;
  s.l_buf = (1 + 2) * s.lit_bufsize;

  s.level = level;
  s.strategy = strategy;
  s.method = method;

  return deflateReset(strm);
}

function deflateInit(strm, level) {
  return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
}


function deflate(strm, flush) {
  var old_flush, s;
  var beg, val; // for gzip header write only

  if (!strm || !strm.state ||
    flush > Z_BLOCK || flush < 0) {
    return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
  }

  s = strm.state;

  if (!strm.output ||
      (!strm.input && strm.avail_in !== 0) ||
      (s.status === FINISH_STATE && flush !== Z_FINISH)) {
    return err(strm, (strm.avail_out === 0) ? Z_BUF_ERROR : Z_STREAM_ERROR);
  }

  s.strm = strm; /* just in case */
  old_flush = s.last_flush;
  s.last_flush = flush;

  /* Write the header */
  if (s.status === INIT_STATE) {

    if (s.wrap === 2) { // GZIP header
      strm.adler = 0;  //crc32(0L, Z_NULL, 0);
      put_byte(s, 31);
      put_byte(s, 139);
      put_byte(s, 8);
      if (!s.gzhead) { // s->gzhead == Z_NULL
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, s.level === 9 ? 2 :
                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?
                     4 : 0));
        put_byte(s, OS_CODE);
        s.status = BUSY_STATE;
      }
      else {
        put_byte(s, (s.gzhead.text ? 1 : 0) +
                    (s.gzhead.hcrc ? 2 : 0) +
                    (!s.gzhead.extra ? 0 : 4) +
                    (!s.gzhead.name ? 0 : 8) +
                    (!s.gzhead.comment ? 0 : 16)
                );
        put_byte(s, s.gzhead.time & 0xff);
        put_byte(s, (s.gzhead.time >> 8) & 0xff);
        put_byte(s, (s.gzhead.time >> 16) & 0xff);
        put_byte(s, (s.gzhead.time >> 24) & 0xff);
        put_byte(s, s.level === 9 ? 2 :
                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?
                     4 : 0));
        put_byte(s, s.gzhead.os & 0xff);
        if (s.gzhead.extra && s.gzhead.extra.length) {
          put_byte(s, s.gzhead.extra.length & 0xff);
          put_byte(s, (s.gzhead.extra.length >> 8) & 0xff);
        }
        if (s.gzhead.hcrc) {
          strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);
        }
        s.gzindex = 0;
        s.status = EXTRA_STATE;
      }
    }
    else // DEFLATE header
    {
      var header = (Z_DEFLATED + ((s.w_bits - 8) << 4)) << 8;
      var level_flags = -1;

      if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
        level_flags = 0;
      } else if (s.level < 6) {
        level_flags = 1;
      } else if (s.level === 6) {
        level_flags = 2;
      } else {
        level_flags = 3;
      }
      header |= (level_flags << 6);
      if (s.strstart !== 0) { header |= PRESET_DICT; }
      header += 31 - (header % 31);

      s.status = BUSY_STATE;
      putShortMSB(s, header);

      /* Save the adler32 of the preset dictionary: */
      if (s.strstart !== 0) {
        putShortMSB(s, strm.adler >>> 16);
        putShortMSB(s, strm.adler & 0xffff);
      }
      strm.adler = 1; // adler32(0L, Z_NULL, 0);
    }
  }

//#ifdef GZIP
  if (s.status === EXTRA_STATE) {
    if (s.gzhead.extra/* != Z_NULL*/) {
      beg = s.pending;  /* start of bytes to update crc */

      while (s.gzindex < (s.gzhead.extra.length & 0xffff)) {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            break;
          }
        }
        put_byte(s, s.gzhead.extra[s.gzindex] & 0xff);
        s.gzindex++;
      }
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (s.gzindex === s.gzhead.extra.length) {
        s.gzindex = 0;
        s.status = NAME_STATE;
      }
    }
    else {
      s.status = NAME_STATE;
    }
  }
  if (s.status === NAME_STATE) {
    if (s.gzhead.name/* != Z_NULL*/) {
      beg = s.pending;  /* start of bytes to update crc */
      //int val;

      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            val = 1;
            break;
          }
        }
        // JS specific: little magic to add zero terminator to end of string
        if (s.gzindex < s.gzhead.name.length) {
          val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);

      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (val === 0) {
        s.gzindex = 0;
        s.status = COMMENT_STATE;
      }
    }
    else {
      s.status = COMMENT_STATE;
    }
  }
  if (s.status === COMMENT_STATE) {
    if (s.gzhead.comment/* != Z_NULL*/) {
      beg = s.pending;  /* start of bytes to update crc */
      //int val;

      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            val = 1;
            break;
          }
        }
        // JS specific: little magic to add zero terminator to end of string
        if (s.gzindex < s.gzhead.comment.length) {
          val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);

      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (val === 0) {
        s.status = HCRC_STATE;
      }
    }
    else {
      s.status = HCRC_STATE;
    }
  }
  if (s.status === HCRC_STATE) {
    if (s.gzhead.hcrc) {
      if (s.pending + 2 > s.pending_buf_size) {
        flush_pending(strm);
      }
      if (s.pending + 2 <= s.pending_buf_size) {
        put_byte(s, strm.adler & 0xff);
        put_byte(s, (strm.adler >> 8) & 0xff);
        strm.adler = 0; //crc32(0L, Z_NULL, 0);
        s.status = BUSY_STATE;
      }
    }
    else {
      s.status = BUSY_STATE;
    }
  }
//#endif

  /* Flush as much pending output as possible */
  if (s.pending !== 0) {
    flush_pending(strm);
    if (strm.avail_out === 0) {
      /* Since avail_out is 0, deflate will be called again with
       * more output space, but possibly with both pending and
       * avail_in equal to zero. There won't be anything to do,
       * but this is not an error situation so make sure we
       * return OK instead of BUF_ERROR at next call of deflate:
       */
      s.last_flush = -1;
      return Z_OK;
    }

    /* Make sure there is something to do and avoid duplicate consecutive
     * flushes. For repeated and useless calls with Z_FINISH, we keep
     * returning Z_STREAM_END instead of Z_BUF_ERROR.
     */
  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) &&
    flush !== Z_FINISH) {
    return err(strm, Z_BUF_ERROR);
  }

  /* User must not provide more input after the first FINISH: */
  if (s.status === FINISH_STATE && strm.avail_in !== 0) {
    return err(strm, Z_BUF_ERROR);
  }

  /* Start a new block or continue the current one.
   */
  if (strm.avail_in !== 0 || s.lookahead !== 0 ||
    (flush !== Z_NO_FLUSH && s.status !== FINISH_STATE)) {
    var bstate = (s.strategy === Z_HUFFMAN_ONLY) ? deflate_huff(s, flush) :
      (s.strategy === Z_RLE ? deflate_rle(s, flush) :
        configuration_table[s.level].func(s, flush));

    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
      s.status = FINISH_STATE;
    }
    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
      if (strm.avail_out === 0) {
        s.last_flush = -1;
        /* avoid BUF_ERROR next call, see above */
      }
      return Z_OK;
      /* If flush != Z_NO_FLUSH && avail_out == 0, the next call
       * of deflate should use the same flush parameter to make sure
       * that the flush is complete. So we don't have to output an
       * empty block here, this will be done at next call. This also
       * ensures that for a very small output buffer, we emit at most
       * one empty block.
       */
    }
    if (bstate === BS_BLOCK_DONE) {
      if (flush === Z_PARTIAL_FLUSH) {
        trees._tr_align(s);
      }
      else if (flush !== Z_BLOCK) { /* FULL_FLUSH or SYNC_FLUSH */

        trees._tr_stored_block(s, 0, 0, false);
        /* For a full flush, this empty block will be recognized
         * as a special marker by inflate_sync().
         */
        if (flush === Z_FULL_FLUSH) {
          /*** CLEAR_HASH(s); ***/             /* forget history */
          zero(s.head); // Fill with NIL (= 0);

          if (s.lookahead === 0) {
            s.strstart = 0;
            s.block_start = 0;
            s.insert = 0;
          }
        }
      }
      flush_pending(strm);
      if (strm.avail_out === 0) {
        s.last_flush = -1; /* avoid BUF_ERROR at next call, see above */
        return Z_OK;
      }
    }
  }
  //Assert(strm->avail_out > 0, "bug2");
  //if (strm.avail_out <= 0) { throw new Error("bug2");}

  if (flush !== Z_FINISH) { return Z_OK; }
  if (s.wrap <= 0) { return Z_STREAM_END; }

  /* Write the trailer */
  if (s.wrap === 2) {
    put_byte(s, strm.adler & 0xff);
    put_byte(s, (strm.adler >> 8) & 0xff);
    put_byte(s, (strm.adler >> 16) & 0xff);
    put_byte(s, (strm.adler >> 24) & 0xff);
    put_byte(s, strm.total_in & 0xff);
    put_byte(s, (strm.total_in >> 8) & 0xff);
    put_byte(s, (strm.total_in >> 16) & 0xff);
    put_byte(s, (strm.total_in >> 24) & 0xff);
  }
  else
  {
    putShortMSB(s, strm.adler >>> 16);
    putShortMSB(s, strm.adler & 0xffff);
  }

  flush_pending(strm);
  /* If avail_out is zero, the application will call deflate again
   * to flush the rest.
   */
  if (s.wrap > 0) { s.wrap = -s.wrap; }
  /* write the trailer only once! */
  return s.pending !== 0 ? Z_OK : Z_STREAM_END;
}

function deflateEnd(strm) {
  var status;

  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {
    return Z_STREAM_ERROR;
  }

  status = strm.state.status;
  if (status !== INIT_STATE &&
    status !== EXTRA_STATE &&
    status !== NAME_STATE &&
    status !== COMMENT_STATE &&
    status !== HCRC_STATE &&
    status !== BUSY_STATE &&
    status !== FINISH_STATE
  ) {
    return err(strm, Z_STREAM_ERROR);
  }

  strm.state = null;

  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
}


/* =========================================================================
 * Initializes the compression dictionary from the given byte
 * sequence without producing any compressed output.
 */
function deflateSetDictionary(strm, dictionary) {
  var dictLength = dictionary.length;

  var s;
  var str, n;
  var wrap;
  var avail;
  var next;
  var input;
  var tmpDict;

  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {
    return Z_STREAM_ERROR;
  }

  s = strm.state;
  wrap = s.wrap;

  if (wrap === 2 || (wrap === 1 && s.status !== INIT_STATE) || s.lookahead) {
    return Z_STREAM_ERROR;
  }

  /* when using zlib wrappers, compute Adler-32 for provided dictionary */
  if (wrap === 1) {
    /* adler32(strm->adler, dictionary, dictLength); */
    strm.adler = adler32(strm.adler, dictionary, dictLength, 0);
  }

  s.wrap = 0;   /* avoid computing Adler-32 in read_buf */

  /* if dictionary would fill window, just replace the history */
  if (dictLength >= s.w_size) {
    if (wrap === 0) {            /* already empty otherwise */
      /*** CLEAR_HASH(s); ***/
      zero(s.head); // Fill with NIL (= 0);
      s.strstart = 0;
      s.block_start = 0;
      s.insert = 0;
    }
    /* use the tail */
    // dictionary = dictionary.slice(dictLength - s.w_size);
    tmpDict = new utils.Buf8(s.w_size);
    utils.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0);
    dictionary = tmpDict;
    dictLength = s.w_size;
  }
  /* insert dictionary into window and hash */
  avail = strm.avail_in;
  next = strm.next_in;
  input = strm.input;
  strm.avail_in = dictLength;
  strm.next_in = 0;
  strm.input = dictionary;
  fill_window(s);
  while (s.lookahead >= MIN_MATCH) {
    str = s.strstart;
    n = s.lookahead - (MIN_MATCH - 1);
    do {
      /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;

      s.prev[str & s.w_mask] = s.head[s.ins_h];

      s.head[s.ins_h] = str;
      str++;
    } while (--n);
    s.strstart = str;
    s.lookahead = MIN_MATCH - 1;
    fill_window(s);
  }
  s.strstart += s.lookahead;
  s.block_start = s.strstart;
  s.insert = s.lookahead;
  s.lookahead = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  strm.next_in = next;
  strm.input = input;
  strm.avail_in = avail;
  s.wrap = wrap;
  return Z_OK;
}


exports.deflateInit = deflateInit;
exports.deflateInit2 = deflateInit2;
exports.deflateReset = deflateReset;
exports.deflateResetKeep = deflateResetKeep;
exports.deflateSetHeader = deflateSetHeader;
exports.deflate = deflate;
exports.deflateEnd = deflateEnd;
exports.deflateSetDictionary = deflateSetDictionary;
exports.deflateInfo = 'pako deflate (from Nodeca project)';

/* Not implemented
exports.deflateBound = deflateBound;
exports.deflateCopy = deflateCopy;
exports.deflateParams = deflateParams;
exports.deflatePending = deflatePending;
exports.deflatePrime = deflatePrime;
exports.deflateTune = deflateTune;
*/

},{"../utils/common":6,"./adler32":7,"./crc32":9,"./messages":14,"./trees":15}],11:[function(require,module,exports){
'use strict';

// See state defs from inflate.js
var BAD = 30;       /* got a data error -- remain here until reset */
var TYPE = 12;      /* i: waiting for type bits, including last-flag bit */

/*
   Decode literal, length, and distance codes and write out the resulting
   literal and match bytes until either not enough input or output is
   available, an end-of-block is encountered, or a data error is encountered.
   When large enough input and output buffers are supplied to inflate(), for
   example, a 16K input buffer and a 64K output buffer, more than 95% of the
   inflate execution time is spent in this routine.

   Entry assumptions:

        state.mode === LEN
        strm.avail_in >= 6
        strm.avail_out >= 258
        start >= strm.avail_out
        state.bits < 8

   On return, state.mode is one of:

        LEN -- ran out of enough output space or enough available input
        TYPE -- reached end of block code, inflate() to interpret next block
        BAD -- error in block data

   Notes:

    - The maximum input bits used by a length/distance pair is 15 bits for the
      length code, 5 bits for the length extra, 15 bits for the distance code,
      and 13 bits for the distance extra.  This totals 48 bits, or six bytes.
      Therefore if strm.avail_in >= 6, then there is enough input to avoid
      checking for available input while decoding.

    - The maximum bytes that a single length/distance pair can output is 258
      bytes, which is the maximum length that can be coded.  inflate_fast()
      requires strm.avail_out >= 258 for each loop to avoid checking for
      output space.
 */
module.exports = function inflate_fast(strm, start) {
  var state;
  var _in;                    /* local strm.input */
  var last;                   /* have enough input while in < last */
  var _out;                   /* local strm.output */
  var beg;                    /* inflate()'s initial strm.output */
  var end;                    /* while out < end, enough space available */
//#ifdef INFLATE_STRICT
  var dmax;                   /* maximum distance from zlib header */
//#endif
  var wsize;                  /* window size or zero if not using window */
  var whave;                  /* valid bytes in the window */
  var wnext;                  /* window write index */
  // Use `s_window` instead `window`, avoid conflict with instrumentation tools
  var s_window;               /* allocated sliding window, if wsize != 0 */
  var hold;                   /* local strm.hold */
  var bits;                   /* local strm.bits */
  var lcode;                  /* local strm.lencode */
  var dcode;                  /* local strm.distcode */
  var lmask;                  /* mask for first level of length codes */
  var dmask;                  /* mask for first level of distance codes */
  var here;                   /* retrieved table entry */
  var op;                     /* code bits, operation, extra bits, or */
                              /*  window position, window bytes to copy */
  var len;                    /* match length, unused bytes */
  var dist;                   /* match distance */
  var from;                   /* where to copy match from */
  var from_source;


  var input, output; // JS specific, because we have no pointers

  /* copy state to local variables */
  state = strm.state;
  //here = state.here;
  _in = strm.next_in;
  input = strm.input;
  last = _in + (strm.avail_in - 5);
  _out = strm.next_out;
  output = strm.output;
  beg = _out - (start - strm.avail_out);
  end = _out + (strm.avail_out - 257);
//#ifdef INFLATE_STRICT
  dmax = state.dmax;
//#endif
  wsize = state.wsize;
  whave = state.whave;
  wnext = state.wnext;
  s_window = state.window;
  hold = state.hold;
  bits = state.bits;
  lcode = state.lencode;
  dcode = state.distcode;
  lmask = (1 << state.lenbits) - 1;
  dmask = (1 << state.distbits) - 1;


  /* decode literals and length/distances until end-of-block or not enough
     input data or output space */

  top:
  do {
    if (bits < 15) {
      hold += input[_in++] << bits;
      bits += 8;
      hold += input[_in++] << bits;
      bits += 8;
    }

    here = lcode[hold & lmask];

    dolen:
    for (;;) { // Goto emulation
      op = here >>> 24/*here.bits*/;
      hold >>>= op;
      bits -= op;
      op = (here >>> 16) & 0xff/*here.op*/;
      if (op === 0) {                          /* literal */
        //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
        //        "inflate:         literal '%c'\n" :
        //        "inflate:         literal 0x%02x\n", here.val));
        output[_out++] = here & 0xffff/*here.val*/;
      }
      else if (op & 16) {                     /* length base */
        len = here & 0xffff/*here.val*/;
        op &= 15;                           /* number of extra bits */
        if (op) {
          if (bits < op) {
            hold += input[_in++] << bits;
            bits += 8;
          }
          len += hold & ((1 << op) - 1);
          hold >>>= op;
          bits -= op;
        }
        //Tracevv((stderr, "inflate:         length %u\n", len));
        if (bits < 15) {
          hold += input[_in++] << bits;
          bits += 8;
          hold += input[_in++] << bits;
          bits += 8;
        }
        here = dcode[hold & dmask];

        dodist:
        for (;;) { // goto emulation
          op = here >>> 24/*here.bits*/;
          hold >>>= op;
          bits -= op;
          op = (here >>> 16) & 0xff/*here.op*/;

          if (op & 16) {                      /* distance base */
            dist = here & 0xffff/*here.val*/;
            op &= 15;                       /* number of extra bits */
            if (bits < op) {
              hold += input[_in++] << bits;
              bits += 8;
              if (bits < op) {
                hold += input[_in++] << bits;
                bits += 8;
              }
            }
            dist += hold & ((1 << op) - 1);
//#ifdef INFLATE_STRICT
            if (dist > dmax) {
              strm.msg = 'invalid distance too far back';
              state.mode = BAD;
              break top;
            }
//#endif
            hold >>>= op;
            bits -= op;
            //Tracevv((stderr, "inflate:         distance %u\n", dist));
            op = _out - beg;                /* max distance in output */
            if (dist > op) {                /* see if copy from window */
              op = dist - op;               /* distance back in window */
              if (op > whave) {
                if (state.sane) {
                  strm.msg = 'invalid distance too far back';
                  state.mode = BAD;
                  break top;
                }

// (!) This block is disabled in zlib defailts,
// don't enable it for binary compatibility
//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
//                if (len <= op - whave) {
//                  do {
//                    output[_out++] = 0;
//                  } while (--len);
//                  continue top;
//                }
//                len -= op - whave;
//                do {
//                  output[_out++] = 0;
//                } while (--op > whave);
//                if (op === 0) {
//                  from = _out - dist;
//                  do {
//                    output[_out++] = output[from++];
//                  } while (--len);
//                  continue top;
//                }
//#endif
              }
              from = 0; // window index
              from_source = s_window;
              if (wnext === 0) {           /* very common case */
                from += wsize - op;
                if (op < len) {         /* some from window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = _out - dist;  /* rest from output */
                  from_source = output;
                }
              }
              else if (wnext < op) {      /* wrap around window */
                from += wsize + wnext - op;
                op -= wnext;
                if (op < len) {         /* some from end of window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = 0;
                  if (wnext < len) {  /* some from start of window */
                    op = wnext;
                    len -= op;
                    do {
                      output[_out++] = s_window[from++];
                    } while (--op);
                    from = _out - dist;      /* rest from output */
                    from_source = output;
                  }
                }
              }
              else {                      /* contiguous in window */
                from += wnext - op;
                if (op < len) {         /* some from window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = _out - dist;  /* rest from output */
                  from_source = output;
                }
              }
              while (len > 2) {
                output[_out++] = from_source[from++];
                output[_out++] = from_source[from++];
                output[_out++] = from_source[from++];
                len -= 3;
              }
              if (len) {
                output[_out++] = from_source[from++];
                if (len > 1) {
                  output[_out++] = from_source[from++];
                }
              }
            }
            else {
              from = _out - dist;          /* copy direct from output */
              do {                        /* minimum length is three */
                output[_out++] = output[from++];
                output[_out++] = output[from++];
                output[_out++] = output[from++];
                len -= 3;
              } while (len > 2);
              if (len) {
                output[_out++] = output[from++];
                if (len > 1) {
                  output[_out++] = output[from++];
                }
              }
            }
          }
          else if ((op & 64) === 0) {          /* 2nd level distance code */
            here = dcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];
            continue dodist;
          }
          else {
            strm.msg = 'invalid distance code';
            state.mode = BAD;
            break top;
          }

          break; // need to emulate goto via "continue"
        }
      }
      else if ((op & 64) === 0) {              /* 2nd level length code */
        here = lcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];
        continue dolen;
      }
      else if (op & 32) {                     /* end-of-block */
        //Tracevv((stderr, "inflate:         end of block\n"));
        state.mode = TYPE;
        break top;
      }
      else {
        strm.msg = 'invalid literal/length code';
        state.mode = BAD;
        break top;
      }

      break; // need to emulate goto via "continue"
    }
  } while (_in < last && _out < end);

  /* return unused bytes (on entry, bits < 8, so in won't go too far back) */
  len = bits >> 3;
  _in -= len;
  bits -= len << 3;
  hold &= (1 << bits) - 1;

  /* update state and return */
  strm.next_in = _in;
  strm.next_out = _out;
  strm.avail_in = (_in < last ? 5 + (last - _in) : 5 - (_in - last));
  strm.avail_out = (_out < end ? 257 + (end - _out) : 257 - (_out - end));
  state.hold = hold;
  state.bits = bits;
  return;
};

},{}],12:[function(require,module,exports){
'use strict';


var utils         = require('../utils/common');
var adler32       = require('./adler32');
var crc32         = require('./crc32');
var inflate_fast  = require('./inffast');
var inflate_table = require('./inftrees');

var CODES = 0;
var LENS = 1;
var DISTS = 2;

/* Public constants ==========================================================*/
/* ===========================================================================*/


/* Allowed flush values; see deflate() and inflate() below for details */
//var Z_NO_FLUSH      = 0;
//var Z_PARTIAL_FLUSH = 1;
//var Z_SYNC_FLUSH    = 2;
//var Z_FULL_FLUSH    = 3;
var Z_FINISH        = 4;
var Z_BLOCK         = 5;
var Z_TREES         = 6;


/* Return codes for the compression/decompression functions. Negative values
 * are errors, positive values are used for special but normal events.
 */
var Z_OK            = 0;
var Z_STREAM_END    = 1;
var Z_NEED_DICT     = 2;
//var Z_ERRNO         = -1;
var Z_STREAM_ERROR  = -2;
var Z_DATA_ERROR    = -3;
var Z_MEM_ERROR     = -4;
var Z_BUF_ERROR     = -5;
//var Z_VERSION_ERROR = -6;

/* The deflate compression method */
var Z_DEFLATED  = 8;


/* STATES ====================================================================*/
/* ===========================================================================*/


var    HEAD = 1;       /* i: waiting for magic header */
var    FLAGS = 2;      /* i: waiting for method and flags (gzip) */
var    TIME = 3;       /* i: waiting for modification time (gzip) */
var    OS = 4;         /* i: waiting for extra flags and operating system (gzip) */
var    EXLEN = 5;      /* i: waiting for extra length (gzip) */
var    EXTRA = 6;      /* i: waiting for extra bytes (gzip) */
var    NAME = 7;       /* i: waiting for end of file name (gzip) */
var    COMMENT = 8;    /* i: waiting for end of comment (gzip) */
var    HCRC = 9;       /* i: waiting for header crc (gzip) */
var    DICTID = 10;    /* i: waiting for dictionary check value */
var    DICT = 11;      /* waiting for inflateSetDictionary() call */
var        TYPE = 12;      /* i: waiting for type bits, including last-flag bit */
var        TYPEDO = 13;    /* i: same, but skip check to exit inflate on new block */
var        STORED = 14;    /* i: waiting for stored size (length and complement) */
var        COPY_ = 15;     /* i/o: same as COPY below, but only first time in */
var        COPY = 16;      /* i/o: waiting for input or output to copy stored block */
var        TABLE = 17;     /* i: waiting for dynamic block table lengths */
var        LENLENS = 18;   /* i: waiting for code length code lengths */
var        CODELENS = 19;  /* i: waiting for length/lit and distance code lengths */
var            LEN_ = 20;      /* i: same as LEN below, but only first time in */
var            LEN = 21;       /* i: waiting for length/lit/eob code */
var            LENEXT = 22;    /* i: waiting for length extra bits */
var            DIST = 23;      /* i: waiting for distance code */
var            DISTEXT = 24;   /* i: waiting for distance extra bits */
var            MATCH = 25;     /* o: waiting for output space to copy string */
var            LIT = 26;       /* o: waiting for output space to write literal */
var    CHECK = 27;     /* i: waiting for 32-bit check value */
var    LENGTH = 28;    /* i: waiting for 32-bit length (gzip) */
var    DONE = 29;      /* finished check, done -- remain here until reset */
var    BAD = 30;       /* got a data error -- remain here until reset */
var    MEM = 31;       /* got an inflate() memory error -- remain here until reset */
var    SYNC = 32;      /* looking for synchronization bytes to restart inflate() */

/* ===========================================================================*/



var ENOUGH_LENS = 852;
var ENOUGH_DISTS = 592;
//var ENOUGH =  (ENOUGH_LENS+ENOUGH_DISTS);

var MAX_WBITS = 15;
/* 32K LZ77 window */
var DEF_WBITS = MAX_WBITS;


function zswap32(q) {
  return  (((q >>> 24) & 0xff) +
          ((q >>> 8) & 0xff00) +
          ((q & 0xff00) << 8) +
          ((q & 0xff) << 24));
}


function InflateState() {
  this.mode = 0;             /* current inflate mode */
  this.last = false;          /* true if processing last block */
  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */
  this.havedict = false;      /* true if dictionary provided */
  this.flags = 0;             /* gzip header method and flags (0 if zlib) */
  this.dmax = 0;              /* zlib header max distance (INFLATE_STRICT) */
  this.check = 0;             /* protected copy of check value */
  this.total = 0;             /* protected copy of output count */
  // TODO: may be {}
  this.head = null;           /* where to save gzip header information */

  /* sliding window */
  this.wbits = 0;             /* log base 2 of requested window size */
  this.wsize = 0;             /* window size or zero if not using window */
  this.whave = 0;             /* valid bytes in the window */
  this.wnext = 0;             /* window write index */
  this.window = null;         /* allocated sliding window, if needed */

  /* bit accumulator */
  this.hold = 0;              /* input bit accumulator */
  this.bits = 0;              /* number of bits in "in" */

  /* for string and stored block copying */
  this.length = 0;            /* literal or length of data to copy */
  this.offset = 0;            /* distance back to copy string from */

  /* for table and code decoding */
  this.extra = 0;             /* extra bits needed */

  /* fixed and dynamic code tables */
  this.lencode = null;          /* starting table for length/literal codes */
  this.distcode = null;         /* starting table for distance codes */
  this.lenbits = 0;           /* index bits for lencode */
  this.distbits = 0;          /* index bits for distcode */

  /* dynamic table building */
  this.ncode = 0;             /* number of code length code lengths */
  this.nlen = 0;              /* number of length code lengths */
  this.ndist = 0;             /* number of distance code lengths */
  this.have = 0;              /* number of code lengths in lens[] */
  this.next = null;              /* next available space in codes[] */

  this.lens = new utils.Buf16(320); /* temporary storage for code lengths */
  this.work = new utils.Buf16(288); /* work area for code table building */

  /*
   because we don't have pointers in js, we use lencode and distcode directly
   as buffers so we don't need codes
  */
  //this.codes = new utils.Buf32(ENOUGH);       /* space for code tables */
  this.lendyn = null;              /* dynamic table for length/literal codes (JS specific) */
  this.distdyn = null;             /* dynamic table for distance codes (JS specific) */
  this.sane = 0;                   /* if false, allow invalid distance too far */
  this.back = 0;                   /* bits back of last unprocessed length/lit */
  this.was = 0;                    /* initial length of match */
}

function inflateResetKeep(strm) {
  var state;

  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  state = strm.state;
  strm.total_in = strm.total_out = state.total = 0;
  strm.msg = ''; /*Z_NULL*/
  if (state.wrap) {       /* to support ill-conceived Java test suite */
    strm.adler = state.wrap & 1;
  }
  state.mode = HEAD;
  state.last = 0;
  state.havedict = 0;
  state.dmax = 32768;
  state.head = null/*Z_NULL*/;
  state.hold = 0;
  state.bits = 0;
  //state.lencode = state.distcode = state.next = state.codes;
  state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);
  state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);

  state.sane = 1;
  state.back = -1;
  //Tracev((stderr, "inflate: reset\n"));
  return Z_OK;
}

function inflateReset(strm) {
  var state;

  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  state = strm.state;
  state.wsize = 0;
  state.whave = 0;
  state.wnext = 0;
  return inflateResetKeep(strm);

}

function inflateReset2(strm, windowBits) {
  var wrap;
  var state;

  /* get the state */
  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  state = strm.state;

  /* extract wrap request from windowBits parameter */
  if (windowBits < 0) {
    wrap = 0;
    windowBits = -windowBits;
  }
  else {
    wrap = (windowBits >> 4) + 1;
    if (windowBits < 48) {
      windowBits &= 15;
    }
  }

  /* set number of window bits, free window if different */
  if (windowBits && (windowBits < 8 || windowBits > 15)) {
    return Z_STREAM_ERROR;
  }
  if (state.window !== null && state.wbits !== windowBits) {
    state.window = null;
  }

  /* update state and reset the rest of it */
  state.wrap = wrap;
  state.wbits = windowBits;
  return inflateReset(strm);
}

function inflateInit2(strm, windowBits) {
  var ret;
  var state;

  if (!strm) { return Z_STREAM_ERROR; }
  //strm.msg = Z_NULL;                 /* in case we return an error */

  state = new InflateState();

  //if (state === Z_NULL) return Z_MEM_ERROR;
  //Tracev((stderr, "inflate: allocated\n"));
  strm.state = state;
  state.window = null/*Z_NULL*/;
  ret = inflateReset2(strm, windowBits);
  if (ret !== Z_OK) {
    strm.state = null/*Z_NULL*/;
  }
  return ret;
}

function inflateInit(strm) {
  return inflateInit2(strm, DEF_WBITS);
}


/*
 Return state with length and distance decoding tables and index sizes set to
 fixed code decoding.  Normally this returns fixed tables from inffixed.h.
 If BUILDFIXED is defined, then instead this routine builds the tables the
 first time it's called, and returns those tables the first time and
 thereafter.  This reduces the size of the code by about 2K bytes, in
 exchange for a little execution time.  However, BUILDFIXED should not be
 used for threaded applications, since the rewriting of the tables and virgin
 may not be thread-safe.
 */
var virgin = true;

var lenfix, distfix; // We have no pointers in JS, so keep tables separate

function fixedtables(state) {
  /* build fixed huffman tables if first call (may not be thread safe) */
  if (virgin) {
    var sym;

    lenfix = new utils.Buf32(512);
    distfix = new utils.Buf32(32);

    /* literal/length table */
    sym = 0;
    while (sym < 144) { state.lens[sym++] = 8; }
    while (sym < 256) { state.lens[sym++] = 9; }
    while (sym < 280) { state.lens[sym++] = 7; }
    while (sym < 288) { state.lens[sym++] = 8; }

    inflate_table(LENS,  state.lens, 0, 288, lenfix,   0, state.work, { bits: 9 });

    /* distance table */
    sym = 0;
    while (sym < 32) { state.lens[sym++] = 5; }

    inflate_table(DISTS, state.lens, 0, 32,   distfix, 0, state.work, { bits: 5 });

    /* do this just once */
    virgin = false;
  }

  state.lencode = lenfix;
  state.lenbits = 9;
  state.distcode = distfix;
  state.distbits = 5;
}


/*
 Update the window with the last wsize (normally 32K) bytes written before
 returning.  If window does not exist yet, create it.  This is only called
 when a window is already in use, or when output has been written during this
 inflate call, but the end of the deflate stream has not been reached yet.
 It is also called to create a window for dictionary data when a dictionary
 is loaded.

 Providing output buffers larger than 32K to inflate() should provide a speed
 advantage, since only the last 32K of output is copied to the sliding window
 upon return from inflate(), and since all distances after the first 32K of
 output will fall in the output data, making match copies simpler and faster.
 The advantage may be dependent on the size of the processor's data caches.
 */
function updatewindow(strm, src, end, copy) {
  var dist;
  var state = strm.state;

  /* if it hasn't been done already, allocate space for the window */
  if (state.window === null) {
    state.wsize = 1 << state.wbits;
    state.wnext = 0;
    state.whave = 0;

    state.window = new utils.Buf8(state.wsize);
  }

  /* copy state->wsize or less output bytes into the circular window */
  if (copy >= state.wsize) {
    utils.arraySet(state.window, src, end - state.wsize, state.wsize, 0);
    state.wnext = 0;
    state.whave = state.wsize;
  }
  else {
    dist = state.wsize - state.wnext;
    if (dist > copy) {
      dist = copy;
    }
    //zmemcpy(state->window + state->wnext, end - copy, dist);
    utils.arraySet(state.window, src, end - copy, dist, state.wnext);
    copy -= dist;
    if (copy) {
      //zmemcpy(state->window, end - copy, copy);
      utils.arraySet(state.window, src, end - copy, copy, 0);
      state.wnext = copy;
      state.whave = state.wsize;
    }
    else {
      state.wnext += dist;
      if (state.wnext === state.wsize) { state.wnext = 0; }
      if (state.whave < state.wsize) { state.whave += dist; }
    }
  }
  return 0;
}

function inflate(strm, flush) {
  var state;
  var input, output;          // input/output buffers
  var next;                   /* next input INDEX */
  var put;                    /* next output INDEX */
  var have, left;             /* available input and output */
  var hold;                   /* bit buffer */
  var bits;                   /* bits in bit buffer */
  var _in, _out;              /* save starting available input and output */
  var copy;                   /* number of stored or match bytes to copy */
  var from;                   /* where to copy match bytes from */
  var from_source;
  var here = 0;               /* current decoding table entry */
  var here_bits, here_op, here_val; // paked "here" denormalized (JS specific)
  //var last;                   /* parent table entry */
  var last_bits, last_op, last_val; // paked "last" denormalized (JS specific)
  var len;                    /* length to copy for repeats, bits to drop */
  var ret;                    /* return code */
  var hbuf = new utils.Buf8(4);    /* buffer for gzip header crc calculation */
  var opts;

  var n; // temporary var for NEED_BITS

  var order = /* permutation of code lengths */
    [ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ];


  if (!strm || !strm.state || !strm.output ||
      (!strm.input && strm.avail_in !== 0)) {
    return Z_STREAM_ERROR;
  }

  state = strm.state;
  if (state.mode === TYPE) { state.mode = TYPEDO; }    /* skip check */


  //--- LOAD() ---
  put = strm.next_out;
  output = strm.output;
  left = strm.avail_out;
  next = strm.next_in;
  input = strm.input;
  have = strm.avail_in;
  hold = state.hold;
  bits = state.bits;
  //---

  _in = have;
  _out = left;
  ret = Z_OK;

  inf_leave: // goto emulation
  for (;;) {
    switch (state.mode) {
    case HEAD:
      if (state.wrap === 0) {
        state.mode = TYPEDO;
        break;
      }
      //=== NEEDBITS(16);
      while (bits < 16) {
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
      }
      //===//
      if ((state.wrap & 2) && hold === 0x8b1f) {  /* gzip header */
        state.check = 0/*crc32(0L, Z_NULL, 0)*/;
        //=== CRC2(state.check, hold);
        hbuf[0] = hold & 0xff;
        hbuf[1] = (hold >>> 8) & 0xff;
        state.check = crc32(state.check, hbuf, 2, 0);
        //===//

        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = FLAGS;
        break;
      }
      state.flags = 0;           /* expect zlib header */
      if (state.head) {
        state.head.done = false;
      }
      if (!(state.wrap & 1) ||   /* check if zlib header allowed */
        (((hold & 0xff)/*BITS(8)*/ << 8) + (hold >> 8)) % 31) {
        strm.msg = 'incorrect header check';
        state.mode = BAD;
        break;
      }
      if ((hold & 0x0f)/*BITS(4)*/ !== Z_DEFLATED) {
        strm.msg = 'unknown compression method';
        state.mode = BAD;
        break;
      }
      //--- DROPBITS(4) ---//
      hold >>>= 4;
      bits -= 4;
      //---//
      len = (hold & 0x0f)/*BITS(4)*/ + 8;
      if (state.wbits === 0) {
        state.wbits = len;
      }
      else if (len > state.wbits) {
        strm.msg = 'invalid window size';
        state.mode = BAD;
        break;
      }
      state.dmax = 1 << len;
      //Tracev((stderr, "inflate:   zlib header ok\n"));
      strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;
      state.mode = hold & 0x200 ? DICTID : TYPE;
      //=== INITBITS();
      hold = 0;
      bits = 0;
      //===//
      break;
    case FLAGS:
      //=== NEEDBITS(16); */
      while (bits < 16) {
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
      }
      //===//
      state.flags = hold;
      if ((state.flags & 0xff) !== Z_DEFLATED) {
        strm.msg = 'unknown compression method';
        state.mode = BAD;
        break;
      }
      if (state.flags & 0xe000) {
        strm.msg = 'unknown header flags set';
        state.mode = BAD;
        break;
      }
      if (state.head) {
        state.head.text = ((hold >> 8) & 1);
      }
      if (state.flags & 0x0200) {
        //=== CRC2(state.check, hold);
        hbuf[0] = hold & 0xff;
        hbuf[1] = (hold >>> 8) & 0xff;
        state.check = crc32(state.check, hbuf, 2, 0);
        //===//
      }
      //=== INITBITS();
      hold = 0;
      bits = 0;
      //===//
      state.mode = TIME;
      /* falls through */
    case TIME:
      //=== NEEDBITS(32); */
      while (bits < 32) {
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
      }
      //===//
      if (state.head) {
        state.head.time = hold;
      }
      if (state.flags & 0x0200) {
        //=== CRC4(state.check, hold)
        hbuf[0] = hold & 0xff;
        hbuf[1] = (hold >>> 8) & 0xff;
        hbuf[2] = (hold >>> 16) & 0xff;
        hbuf[3] = (hold >>> 24) & 0xff;
        state.check = crc32(state.check, hbuf, 4, 0);
        //===
      }
      //=== INITBITS();
      hold = 0;
      bits = 0;
      //===//
      state.mode = OS;
      /* falls through */
    case OS:
      //=== NEEDBITS(16); */
      while (bits < 16) {
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
      }
      //===//
      if (state.head) {
        state.head.xflags = (hold & 0xff);
        state.head.os = (hold >> 8);
      }
      if (state.flags & 0x0200) {
        //=== CRC2(state.check, hold);
        hbuf[0] = hold & 0xff;
        hbuf[1] = (hold >>> 8) & 0xff;
        state.check = crc32(state.check, hbuf, 2, 0);
        //===//
      }
      //=== INITBITS();
      hold = 0;
      bits = 0;
      //===//
      state.mode = EXLEN;
      /* falls through */
    case EXLEN:
      if (state.flags & 0x0400) {
        //=== NEEDBITS(16); */
        while (bits < 16) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.length = hold;
        if (state.head) {
          state.head.extra_len = hold;
        }
        if (state.flags & 0x0200) {
          //=== CRC2(state.check, hold);
          hbuf[0] = hold & 0xff;
          hbuf[1] = (hold >>> 8) & 0xff;
          state.check = crc32(state.check, hbuf, 2, 0);
          //===//
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
      }
      else if (state.head) {
        state.head.extra = null/*Z_NULL*/;
      }
      state.mode = EXTRA;
      /* falls through */
    case EXTRA:
      if (state.flags & 0x0400) {
        copy = state.length;
        if (copy > have) { copy = have; }
        if (copy) {
          if (state.head) {
            len = state.head.extra_len - state.length;
            if (!state.head.extra) {
              // Use untyped array for more conveniend processing later
              state.head.extra = new Array(state.head.extra_len);
            }
            utils.arraySet(
              state.head.extra,
              input,
              next,
              // extra field is limited to 65536 bytes
              // - no need for additional size check
              copy,
              /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
              len
            );
            //zmemcpy(state.head.extra + len, next,
            //        len + copy > state.head.extra_max ?
            //        state.head.extra_max - len : copy);
          }
          if (state.flags & 0x0200) {
            state.check = crc32(state.check, input, copy, next);
          }
          have -= copy;
          next += copy;
          state.length -= copy;
        }
        if (state.length) { break inf_leave; }
      }
      state.length = 0;
      state.mode = NAME;
      /* falls through */
    case NAME:
      if (state.flags & 0x0800) {
        if (have === 0) { break inf_leave; }
        copy = 0;
        do {
          // TODO: 2 or 1 bytes?
          len = input[next + copy++];
          /* use constant limit because in js we should not preallocate memory */
          if (state.head && len &&
              (state.length < 65536 /*state.head.name_max*/)) {
            state.head.name += String.fromCharCode(len);
          }
        } while (len && copy < have);

        if (state.flags & 0x0200) {
          state.check = crc32(state.check, input, copy, next);
        }
        have -= copy;
        next += copy;
        if (len) { break inf_leave; }
      }
      else if (state.head) {
        state.head.name = null;
      }
      state.length = 0;
      state.mode = COMMENT;
      /* falls through */
    case COMMENT:
      if (state.flags & 0x1000) {
        if (have === 0) { break inf_leave; }
        copy = 0;
        do {
          len = input[next + copy++];
          /* use constant limit because in js we should not preallocate memory */
          if (state.head && len &&
              (state.length < 65536 /*state.head.comm_max*/)) {
            state.head.comment += String.fromCharCode(len);
          }
        } while (len && copy < have);
        if (state.flags & 0x0200) {
          state.check = crc32(state.check, input, copy, next);
        }
        have -= copy;
        next += copy;
        if (len) { break inf_leave; }
      }
      else if (state.head) {
        state.head.comment = null;
      }
      state.mode = HCRC;
      /* falls through */
    case HCRC:
      if (state.flags & 0x0200) {
        //=== NEEDBITS(16); */
        while (bits < 16) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if (hold !== (state.check & 0xffff)) {
          strm.msg = 'header crc mismatch';
          state.mode = BAD;
          break;
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
      }
      if (state.head) {
        state.head.hcrc = ((state.flags >> 9) & 1);
        state.head.done = true;
      }
      strm.adler = state.check = 0;
      state.mode = TYPE;
      break;
    case DICTID:
      //=== NEEDBITS(32); */
      while (bits < 32) {
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
      }
      //===//
      strm.adler = state.check = zswap32(hold);
      //=== INITBITS();
      hold = 0;
      bits = 0;
      //===//
      state.mode = DICT;
      /* falls through */
    case DICT:
      if (state.havedict === 0) {
        //--- RESTORE() ---
        strm.next_out = put;
        strm.avail_out = left;
        strm.next_in = next;
        strm.avail_in = have;
        state.hold = hold;
        state.bits = bits;
        //---
        return Z_NEED_DICT;
      }
      strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;
      state.mode = TYPE;
      /* falls through */
    case TYPE:
      if (flush === Z_BLOCK || flush === Z_TREES) { break inf_leave; }
      /* falls through */
    case TYPEDO:
      if (state.last) {
        //--- BYTEBITS() ---//
        hold >>>= bits & 7;
        bits -= bits & 7;
        //---//
        state.mode = CHECK;
        break;
      }
      //=== NEEDBITS(3); */
      while (bits < 3) {
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
      }
      //===//
      state.last = (hold & 0x01)/*BITS(1)*/;
      //--- DROPBITS(1) ---//
      hold >>>= 1;
      bits -= 1;
      //---//

      switch ((hold & 0x03)/*BITS(2)*/) {
      case 0:                             /* stored block */
        //Tracev((stderr, "inflate:     stored block%s\n",
        //        state.last ? " (last)" : ""));
        state.mode = STORED;
        break;
      case 1:                             /* fixed block */
        fixedtables(state);
        //Tracev((stderr, "inflate:     fixed codes block%s\n",
        //        state.last ? " (last)" : ""));
        state.mode = LEN_;             /* decode codes */
        if (flush === Z_TREES) {
          //--- DROPBITS(2) ---//
          hold >>>= 2;
          bits -= 2;
          //---//
          break inf_leave;
        }
        break;
      case 2:                             /* dynamic block */
        //Tracev((stderr, "inflate:     dynamic codes block%s\n",
        //        state.last ? " (last)" : ""));
        state.mode = TABLE;
        break;
      case 3:
        strm.msg = 'invalid block type';
        state.mode = BAD;
      }
      //--- DROPBITS(2) ---//
      hold >>>= 2;
      bits -= 2;
      //---//
      break;
    case STORED:
      //--- BYTEBITS() ---// /* go to byte boundary */
      hold >>>= bits & 7;
      bits -= bits & 7;
      //---//
      //=== NEEDBITS(32); */
      while (bits < 32) {
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
      }
      //===//
      if ((hold & 0xffff) !== ((hold >>> 16) ^ 0xffff)) {
        strm.msg = 'invalid stored block lengths';
        state.mode = BAD;
        break;
      }
      state.length = hold & 0xffff;
      //Tracev((stderr, "inflate:       stored length %u\n",
      //        state.length));
      //=== INITBITS();
      hold = 0;
      bits = 0;
      //===//
      state.mode = COPY_;
      if (flush === Z_TREES) { break inf_leave; }
      /* falls through */
    case COPY_:
      state.mode = COPY;
      /* falls through */
    case COPY:
      copy = state.length;
      if (copy) {
        if (copy > have) { copy = have; }
        if (copy > left) { copy = left; }
        if (copy === 0) { break inf_leave; }
        //--- zmemcpy(put, next, copy); ---
        utils.arraySet(output, input, next, copy, put);
        //---//
        have -= copy;
        next += copy;
        left -= copy;
        put += copy;
        state.length -= copy;
        break;
      }
      //Tracev((stderr, "inflate:       stored end\n"));
      state.mode = TYPE;
      break;
    case TABLE:
      //=== NEEDBITS(14); */
      while (bits < 14) {
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
      }
      //===//
      state.nlen = (hold & 0x1f)/*BITS(5)*/ + 257;
      //--- DROPBITS(5) ---//
      hold >>>= 5;
      bits -= 5;
      //---//
      state.ndist = (hold & 0x1f)/*BITS(5)*/ + 1;
      //--- DROPBITS(5) ---//
      hold >>>= 5;
      bits -= 5;
      //---//
      state.ncode = (hold & 0x0f)/*BITS(4)*/ + 4;
      //--- DROPBITS(4) ---//
      hold >>>= 4;
      bits -= 4;
      //---//
//#ifndef PKZIP_BUG_WORKAROUND
      if (state.nlen > 286 || state.ndist > 30) {
        strm.msg = 'too many length or distance symbols';
        state.mode = BAD;
        break;
      }
//#endif
      //Tracev((stderr, "inflate:       table sizes ok\n"));
      state.have = 0;
      state.mode = LENLENS;
      /* falls through */
    case LENLENS:
      while (state.have < state.ncode) {
        //=== NEEDBITS(3);
        while (bits < 3) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.lens[order[state.have++]] = (hold & 0x07);//BITS(3);
        //--- DROPBITS(3) ---//
        hold >>>= 3;
        bits -= 3;
        //---//
      }
      while (state.have < 19) {
        state.lens[order[state.have++]] = 0;
      }
      // We have separate tables & no pointers. 2 commented lines below not needed.
      //state.next = state.codes;
      //state.lencode = state.next;
      // Switch to use dynamic table
      state.lencode = state.lendyn;
      state.lenbits = 7;

      opts = { bits: state.lenbits };
      ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
      state.lenbits = opts.bits;

      if (ret) {
        strm.msg = 'invalid code lengths set';
        state.mode = BAD;
        break;
      }
      //Tracev((stderr, "inflate:       code lengths ok\n"));
      state.have = 0;
      state.mode = CODELENS;
      /* falls through */
    case CODELENS:
      while (state.have < state.nlen + state.ndist) {
        for (;;) {
          here = state.lencode[hold & ((1 << state.lenbits) - 1)];/*BITS(state.lenbits)*/
          here_bits = here >>> 24;
          here_op = (here >>> 16) & 0xff;
          here_val = here & 0xffff;

          if ((here_bits) <= bits) { break; }
          //--- PULLBYTE() ---//
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
          //---//
        }
        if (here_val < 16) {
          //--- DROPBITS(here.bits) ---//
          hold >>>= here_bits;
          bits -= here_bits;
          //---//
          state.lens[state.have++] = here_val;
        }
        else {
          if (here_val === 16) {
            //=== NEEDBITS(here.bits + 2);
            n = here_bits + 2;
            while (bits < n) {
              if (have === 0) { break inf_leave; }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            //===//
            //--- DROPBITS(here.bits) ---//
            hold >>>= here_bits;
            bits -= here_bits;
            //---//
            if (state.have === 0) {
              strm.msg = 'invalid bit length repeat';
              state.mode = BAD;
              break;
            }
            len = state.lens[state.have - 1];
            copy = 3 + (hold & 0x03);//BITS(2);
            //--- DROPBITS(2) ---//
            hold >>>= 2;
            bits -= 2;
            //---//
          }
          else if (here_val === 17) {
            //=== NEEDBITS(here.bits + 3);
            n = here_bits + 3;
            while (bits < n) {
              if (have === 0) { break inf_leave; }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            //===//
            //--- DROPBITS(here.bits) ---//
            hold >>>= here_bits;
            bits -= here_bits;
            //---//
            len = 0;
            copy = 3 + (hold & 0x07);//BITS(3);
            //--- DROPBITS(3) ---//
            hold >>>= 3;
            bits -= 3;
            //---//
          }
          else {
            //=== NEEDBITS(here.bits + 7);
            n = here_bits + 7;
            while (bits < n) {
              if (have === 0) { break inf_leave; }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            //===//
            //--- DROPBITS(here.bits) ---//
            hold >>>= here_bits;
            bits -= here_bits;
            //---//
            len = 0;
            copy = 11 + (hold & 0x7f);//BITS(7);
            //--- DROPBITS(7) ---//
            hold >>>= 7;
            bits -= 7;
            //---//
          }
          if (state.have + copy > state.nlen + state.ndist) {
            strm.msg = 'invalid bit length repeat';
            state.mode = BAD;
            break;
          }
          while (copy--) {
            state.lens[state.have++] = len;
          }
        }
      }

      /* handle error breaks in while */
      if (state.mode === BAD) { break; }

      /* check for end-of-block code (better have one) */
      if (state.lens[256] === 0) {
        strm.msg = 'invalid code -- missing end-of-block';
        state.mode = BAD;
        break;
      }

      /* build code tables -- note: do not change the lenbits or distbits
         values here (9 and 6) without reading the comments in inftrees.h
         concerning the ENOUGH constants, which depend on those values */
      state.lenbits = 9;

      opts = { bits: state.lenbits };
      ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
      // We have separate tables & no pointers. 2 commented lines below not needed.
      // state.next_index = opts.table_index;
      state.lenbits = opts.bits;
      // state.lencode = state.next;

      if (ret) {
        strm.msg = 'invalid literal/lengths set';
        state.mode = BAD;
        break;
      }

      state.distbits = 6;
      //state.distcode.copy(state.codes);
      // Switch to use dynamic table
      state.distcode = state.distdyn;
      opts = { bits: state.distbits };
      ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
      // We have separate tables & no pointers. 2 commented lines below not needed.
      // state.next_index = opts.table_index;
      state.distbits = opts.bits;
      // state.distcode = state.next;

      if (ret) {
        strm.msg = 'invalid distances set';
        state.mode = BAD;
        break;
      }
      //Tracev((stderr, 'inflate:       codes ok\n'));
      state.mode = LEN_;
      if (flush === Z_TREES) { break inf_leave; }
      /* falls through */
    case LEN_:
      state.mode = LEN;
      /* falls through */
    case LEN:
      if (have >= 6 && left >= 258) {
        //--- RESTORE() ---
        strm.next_out = put;
        strm.avail_out = left;
        strm.next_in = next;
        strm.avail_in = have;
        state.hold = hold;
        state.bits = bits;
        //---
        inflate_fast(strm, _out);
        //--- LOAD() ---
        put = strm.next_out;
        output = strm.output;
        left = strm.avail_out;
        next = strm.next_in;
        input = strm.input;
        have = strm.avail_in;
        hold = state.hold;
        bits = state.bits;
        //---

        if (state.mode === TYPE) {
          state.back = -1;
        }
        break;
      }
      state.back = 0;
      for (;;) {
        here = state.lencode[hold & ((1 << state.lenbits) - 1)];  /*BITS(state.lenbits)*/
        here_bits = here >>> 24;
        here_op = (here >>> 16) & 0xff;
        here_val = here & 0xffff;

        if (here_bits <= bits) { break; }
        //--- PULLBYTE() ---//
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
        //---//
      }
      if (here_op && (here_op & 0xf0) === 0) {
        last_bits = here_bits;
        last_op = here_op;
        last_val = here_val;
        for (;;) {
          here = state.lencode[last_val +
                  ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];
          here_bits = here >>> 24;
          here_op = (here >>> 16) & 0xff;
          here_val = here & 0xffff;

          if ((last_bits + here_bits) <= bits) { break; }
          //--- PULLBYTE() ---//
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
          //---//
        }
        //--- DROPBITS(last.bits) ---//
        hold >>>= last_bits;
        bits -= last_bits;
        //---//
        state.back += last_bits;
      }
      //--- DROPBITS(here.bits) ---//
      hold >>>= here_bits;
      bits -= here_bits;
      //---//
      state.back += here_bits;
      state.length = here_val;
      if (here_op === 0) {
        //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
        //        "inflate:         literal '%c'\n" :
        //        "inflate:         literal 0x%02x\n", here.val));
        state.mode = LIT;
        break;
      }
      if (here_op & 32) {
        //Tracevv((stderr, "inflate:         end of block\n"));
        state.back = -1;
        state.mode = TYPE;
        break;
      }
      if (here_op & 64) {
        strm.msg = 'invalid literal/length code';
        state.mode = BAD;
        break;
      }
      state.extra = here_op & 15;
      state.mode = LENEXT;
      /* falls through */
    case LENEXT:
      if (state.extra) {
        //=== NEEDBITS(state.extra);
        n = state.extra;
        while (bits < n) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.length += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;
        //--- DROPBITS(state.extra) ---//
        hold >>>= state.extra;
        bits -= state.extra;
        //---//
        state.back += state.extra;
      }
      //Tracevv((stderr, "inflate:         length %u\n", state.length));
      state.was = state.length;
      state.mode = DIST;
      /* falls through */
    case DIST:
      for (;;) {
        here = state.distcode[hold & ((1 << state.distbits) - 1)];/*BITS(state.distbits)*/
        here_bits = here >>> 24;
        here_op = (here >>> 16) & 0xff;
        here_val = here & 0xffff;

        if ((here_bits) <= bits) { break; }
        //--- PULLBYTE() ---//
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
        //---//
      }
      if ((here_op & 0xf0) === 0) {
        last_bits = here_bits;
        last_op = here_op;
        last_val = here_val;
        for (;;) {
          here = state.distcode[last_val +
                  ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];
          here_bits = here >>> 24;
          here_op = (here >>> 16) & 0xff;
          here_val = here & 0xffff;

          if ((last_bits + here_bits) <= bits) { break; }
          //--- PULLBYTE() ---//
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
          //---//
        }
        //--- DROPBITS(last.bits) ---//
        hold >>>= last_bits;
        bits -= last_bits;
        //---//
        state.back += last_bits;
      }
      //--- DROPBITS(here.bits) ---//
      hold >>>= here_bits;
      bits -= here_bits;
      //---//
      state.back += here_bits;
      if (here_op & 64) {
        strm.msg = 'invalid distance code';
        state.mode = BAD;
        break;
      }
      state.offset = here_val;
      state.extra = (here_op) & 15;
      state.mode = DISTEXT;
      /* falls through */
    case DISTEXT:
      if (state.extra) {
        //=== NEEDBITS(state.extra);
        n = state.extra;
        while (bits < n) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.offset += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;
        //--- DROPBITS(state.extra) ---//
        hold >>>= state.extra;
        bits -= state.extra;
        //---//
        state.back += state.extra;
      }
//#ifdef INFLATE_STRICT
      if (state.offset > state.dmax) {
        strm.msg = 'invalid distance too far back';
        state.mode = BAD;
        break;
      }
//#endif
      //Tracevv((stderr, "inflate:         distance %u\n", state.offset));
      state.mode = MATCH;
      /* falls through */
    case MATCH:
      if (left === 0) { break inf_leave; }
      copy = _out - left;
      if (state.offset > copy) {         /* copy from window */
        copy = state.offset - copy;
        if (copy > state.whave) {
          if (state.sane) {
            strm.msg = 'invalid distance too far back';
            state.mode = BAD;
            break;
          }
// (!) This block is disabled in zlib defailts,
// don't enable it for binary compatibility
//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
//          Trace((stderr, "inflate.c too far\n"));
//          copy -= state.whave;
//          if (copy > state.length) { copy = state.length; }
//          if (copy > left) { copy = left; }
//          left -= copy;
//          state.length -= copy;
//          do {
//            output[put++] = 0;
//          } while (--copy);
//          if (state.length === 0) { state.mode = LEN; }
//          break;
//#endif
        }
        if (copy > state.wnext) {
          copy -= state.wnext;
          from = state.wsize - copy;
        }
        else {
          from = state.wnext - copy;
        }
        if (copy > state.length) { copy = state.length; }
        from_source = state.window;
      }
      else {                              /* copy from output */
        from_source = output;
        from = put - state.offset;
        copy = state.length;
      }
      if (copy > left) { copy = left; }
      left -= copy;
      state.length -= copy;
      do {
        output[put++] = from_source[from++];
      } while (--copy);
      if (state.length === 0) { state.mode = LEN; }
      break;
    case LIT:
      if (left === 0) { break inf_leave; }
      output[put++] = state.length;
      left--;
      state.mode = LEN;
      break;
    case CHECK:
      if (state.wrap) {
        //=== NEEDBITS(32);
        while (bits < 32) {
          if (have === 0) { break inf_leave; }
          have--;
          // Use '|' insdead of '+' to make sure that result is signed
          hold |= input[next++] << bits;
          bits += 8;
        }
        //===//
        _out -= left;
        strm.total_out += _out;
        state.total += _out;
        if (_out) {
          strm.adler = state.check =
              /*UPDATE(state.check, put - _out, _out);*/
              (state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out));

        }
        _out = left;
        // NB: crc32 stored as signed 32-bit int, zswap32 returns signed too
        if ((state.flags ? hold : zswap32(hold)) !== state.check) {
          strm.msg = 'incorrect data check';
          state.mode = BAD;
          break;
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        //Tracev((stderr, "inflate:   check matches trailer\n"));
      }
      state.mode = LENGTH;
      /* falls through */
    case LENGTH:
      if (state.wrap && state.flags) {
        //=== NEEDBITS(32);
        while (bits < 32) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if (hold !== (state.total & 0xffffffff)) {
          strm.msg = 'incorrect length check';
          state.mode = BAD;
          break;
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        //Tracev((stderr, "inflate:   length matches trailer\n"));
      }
      state.mode = DONE;
      /* falls through */
    case DONE:
      ret = Z_STREAM_END;
      break inf_leave;
    case BAD:
      ret = Z_DATA_ERROR;
      break inf_leave;
    case MEM:
      return Z_MEM_ERROR;
    case SYNC:
      /* falls through */
    default:
      return Z_STREAM_ERROR;
    }
  }

  // inf_leave <- here is real place for "goto inf_leave", emulated via "break inf_leave"

  /*
     Return from inflate(), updating the total counts and the check value.
     If there was no progress during the inflate() call, return a buffer
     error.  Call updatewindow() to create and/or update the window state.
     Note: a memory error from inflate() is non-recoverable.
   */

  //--- RESTORE() ---
  strm.next_out = put;
  strm.avail_out = left;
  strm.next_in = next;
  strm.avail_in = have;
  state.hold = hold;
  state.bits = bits;
  //---

  if (state.wsize || (_out !== strm.avail_out && state.mode < BAD &&
                      (state.mode < CHECK || flush !== Z_FINISH))) {
    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
      state.mode = MEM;
      return Z_MEM_ERROR;
    }
  }
  _in -= strm.avail_in;
  _out -= strm.avail_out;
  strm.total_in += _in;
  strm.total_out += _out;
  state.total += _out;
  if (state.wrap && _out) {
    strm.adler = state.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
      (state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out));
  }
  strm.data_type = state.bits + (state.last ? 64 : 0) +
                    (state.mode === TYPE ? 128 : 0) +
                    (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
  if (((_in === 0 && _out === 0) || flush === Z_FINISH) && ret === Z_OK) {
    ret = Z_BUF_ERROR;
  }
  return ret;
}

function inflateEnd(strm) {

  if (!strm || !strm.state /*|| strm->zfree == (free_func)0*/) {
    return Z_STREAM_ERROR;
  }

  var state = strm.state;
  if (state.window) {
    state.window = null;
  }
  strm.state = null;
  return Z_OK;
}

function inflateGetHeader(strm, head) {
  var state;

  /* check state */
  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  state = strm.state;
  if ((state.wrap & 2) === 0) { return Z_STREAM_ERROR; }

  /* save header structure */
  state.head = head;
  head.done = false;
  return Z_OK;
}

function inflateSetDictionary(strm, dictionary) {
  var dictLength = dictionary.length;

  var state;
  var dictid;
  var ret;

  /* check state */
  if (!strm /* == Z_NULL */ || !strm.state /* == Z_NULL */) { return Z_STREAM_ERROR; }
  state = strm.state;

  if (state.wrap !== 0 && state.mode !== DICT) {
    return Z_STREAM_ERROR;
  }

  /* check for correct dictionary identifier */
  if (state.mode === DICT) {
    dictid = 1; /* adler32(0, null, 0)*/
    /* dictid = adler32(dictid, dictionary, dictLength); */
    dictid = adler32(dictid, dictionary, dictLength, 0);
    if (dictid !== state.check) {
      return Z_DATA_ERROR;
    }
  }
  /* copy dictionary to window using updatewindow(), which will amend the
   existing dictionary if appropriate */
  ret = updatewindow(strm, dictionary, dictLength, dictLength);
  if (ret) {
    state.mode = MEM;
    return Z_MEM_ERROR;
  }
  state.havedict = 1;
  // Tracev((stderr, "inflate:   dictionary set\n"));
  return Z_OK;
}

exports.inflateReset = inflateReset;
exports.inflateReset2 = inflateReset2;
exports.inflateResetKeep = inflateResetKeep;
exports.inflateInit = inflateInit;
exports.inflateInit2 = inflateInit2;
exports.inflate = inflate;
exports.inflateEnd = inflateEnd;
exports.inflateGetHeader = inflateGetHeader;
exports.inflateSetDictionary = inflateSetDictionary;
exports.inflateInfo = 'pako inflate (from Nodeca project)';

/* Not implemented
exports.inflateCopy = inflateCopy;
exports.inflateGetDictionary = inflateGetDictionary;
exports.inflateMark = inflateMark;
exports.inflatePrime = inflatePrime;
exports.inflateSync = inflateSync;
exports.inflateSyncPoint = inflateSyncPoint;
exports.inflateUndermine = inflateUndermine;
*/

},{"../utils/common":6,"./adler32":7,"./crc32":9,"./inffast":11,"./inftrees":13}],13:[function(require,module,exports){
'use strict';


var utils = require('../utils/common');

var MAXBITS = 15;
var ENOUGH_LENS = 852;
var ENOUGH_DISTS = 592;
//var ENOUGH = (ENOUGH_LENS+ENOUGH_DISTS);

var CODES = 0;
var LENS = 1;
var DISTS = 2;

var lbase = [ /* Length codes 257..285 base */
  3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
  35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0
];

var lext = [ /* Length codes 257..285 extra */
  16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,
  19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78
];

var dbase = [ /* Distance codes 0..29 base */
  1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
  257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
  8193, 12289, 16385, 24577, 0, 0
];

var dext = [ /* Distance codes 0..29 extra */
  16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,
  23, 23, 24, 24, 25, 25, 26, 26, 27, 27,
  28, 28, 29, 29, 64, 64
];

module.exports = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts)
{
  var bits = opts.bits;
      //here = opts.here; /* table entry for duplication */

  var len = 0;               /* a code's length in bits */
  var sym = 0;               /* index of code symbols */
  var min = 0, max = 0;          /* minimum and maximum code lengths */
  var root = 0;              /* number of index bits for root table */
  var curr = 0;              /* number of index bits for current table */
  var drop = 0;              /* code bits to drop for sub-table */
  var left = 0;                   /* number of prefix codes available */
  var used = 0;              /* code entries in table used */
  var huff = 0;              /* Huffman code */
  var incr;              /* for incrementing code, index */
  var fill;              /* index for replicating entries */
  var low;               /* low bits for current root entry */
  var mask;              /* mask for low root bits */
  var next;             /* next available space in table */
  var base = null;     /* base value table to use */
  var base_index = 0;
//  var shoextra;    /* extra bits table to use */
  var end;                    /* use base and extra for symbol > end */
  var count = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];    /* number of codes of each length */
  var offs = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];     /* offsets in table for each length */
  var extra = null;
  var extra_index = 0;

  var here_bits, here_op, here_val;

  /*
   Process a set of code lengths to create a canonical Huffman code.  The
   code lengths are lens[0..codes-1].  Each length corresponds to the
   symbols 0..codes-1.  The Huffman code is generated by first sorting the
   symbols by length from short to long, and retaining the symbol order
   for codes with equal lengths.  Then the code starts with all zero bits
   for the first code of the shortest length, and the codes are integer
   increments for the same length, and zeros are appended as the length
   increases.  For the deflate format, these bits are stored backwards
   from their more natural integer increment ordering, and so when the
   decoding tables are built in the large loop below, the integer codes
   are incremented backwards.

   This routine assumes, but does not check, that all of the entries in
   lens[] are in the range 0..MAXBITS.  The caller must assure this.
   1..MAXBITS is interpreted as that code length.  zero means that that
   symbol does not occur in this code.

   The codes are sorted by computing a count of codes for each length,
   creating from that a table of starting indices for each length in the
   sorted table, and then entering the symbols in order in the sorted
   table.  The sorted table is work[], with that space being provided by
   the caller.

   The length counts are used for other purposes as well, i.e. finding
   the minimum and maximum length codes, determining if there are any
   codes at all, checking for a valid set of lengths, and looking ahead
   at length counts to determine sub-table sizes when building the
   decoding tables.
   */

  /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */
  for (len = 0; len <= MAXBITS; len++) {
    count[len] = 0;
  }
  for (sym = 0; sym < codes; sym++) {
    count[lens[lens_index + sym]]++;
  }

  /* bound code lengths, force root to be within code lengths */
  root = bits;
  for (max = MAXBITS; max >= 1; max--) {
    if (count[max] !== 0) { break; }
  }
  if (root > max) {
    root = max;
  }
  if (max === 0) {                     /* no symbols to code at all */
    //table.op[opts.table_index] = 64;  //here.op = (var char)64;    /* invalid code marker */
    //table.bits[opts.table_index] = 1;   //here.bits = (var char)1;
    //table.val[opts.table_index++] = 0;   //here.val = (var short)0;
    table[table_index++] = (1 << 24) | (64 << 16) | 0;


    //table.op[opts.table_index] = 64;
    //table.bits[opts.table_index] = 1;
    //table.val[opts.table_index++] = 0;
    table[table_index++] = (1 << 24) | (64 << 16) | 0;

    opts.bits = 1;
    return 0;     /* no symbols, but wait for decoding to report error */
  }
  for (min = 1; min < max; min++) {
    if (count[min] !== 0) { break; }
  }
  if (root < min) {
    root = min;
  }

  /* check for an over-subscribed or incomplete set of lengths */
  left = 1;
  for (len = 1; len <= MAXBITS; len++) {
    left <<= 1;
    left -= count[len];
    if (left < 0) {
      return -1;
    }        /* over-subscribed */
  }
  if (left > 0 && (type === CODES || max !== 1)) {
    return -1;                      /* incomplete set */
  }

  /* generate offsets into symbol table for each length for sorting */
  offs[1] = 0;
  for (len = 1; len < MAXBITS; len++) {
    offs[len + 1] = offs[len] + count[len];
  }

  /* sort symbols by length, by symbol order within each length */
  for (sym = 0; sym < codes; sym++) {
    if (lens[lens_index + sym] !== 0) {
      work[offs[lens[lens_index + sym]]++] = sym;
    }
  }

  /*
   Create and fill in decoding tables.  In this loop, the table being
   filled is at next and has curr index bits.  The code being used is huff
   with length len.  That code is converted to an index by dropping drop
   bits off of the bottom.  For codes where len is less than drop + curr,
   those top drop + curr - len bits are incremented through all values to
   fill the table with replicated entries.

   root is the number of index bits for the root table.  When len exceeds
   root, sub-tables are created pointed to by the root entry with an index
   of the low root bits of huff.  This is saved in low to check for when a
   new sub-table should be started.  drop is zero when the root table is
   being filled, and drop is root when sub-tables are being filled.

   When a new sub-table is needed, it is necessary to look ahead in the
   code lengths to determine what size sub-table is needed.  The length
   counts are used for this, and so count[] is decremented as codes are
   entered in the tables.

   used keeps track of how many table entries have been allocated from the
   provided *table space.  It is checked for LENS and DIST tables against
   the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in
   the initial root table size constants.  See the comments in inftrees.h
   for more information.

   sym increments through all symbols, and the loop terminates when
   all codes of length max, i.e. all codes, have been processed.  This
   routine permits incomplete codes, so another loop after this one fills
   in the rest of the decoding tables with invalid code markers.
   */

  /* set up for code type */
  // poor man optimization - use if-else instead of switch,
  // to avoid deopts in old v8
  if (type === CODES) {
    base = extra = work;    /* dummy value--not used */
    end = 19;

  } else if (type === LENS) {
    base = lbase;
    base_index -= 257;
    extra = lext;
    extra_index -= 257;
    end = 256;

  } else {                    /* DISTS */
    base = dbase;
    extra = dext;
    end = -1;
  }

  /* initialize opts for loop */
  huff = 0;                   /* starting code */
  sym = 0;                    /* starting code symbol */
  len = min;                  /* starting code length */
  next = table_index;              /* current table to fill in */
  curr = root;                /* current table index bits */
  drop = 0;                   /* current bits to drop from code for index */
  low = -1;                   /* trigger new sub-table when len > root */
  used = 1 << root;          /* use root table entries */
  mask = used - 1;            /* mask for comparing low */

  /* check available table space */
  if ((type === LENS && used > ENOUGH_LENS) ||
    (type === DISTS && used > ENOUGH_DISTS)) {
    return 1;
  }

  var i = 0;
  /* process all codes and make table entries */
  for (;;) {
    i++;
    /* create table entry */
    here_bits = len - drop;
    if (work[sym] < end) {
      here_op = 0;
      here_val = work[sym];
    }
    else if (work[sym] > end) {
      here_op = extra[extra_index + work[sym]];
      here_val = base[base_index + work[sym]];
    }
    else {
      here_op = 32 + 64;         /* end of block */
      here_val = 0;
    }

    /* replicate for those indices with low len bits equal to huff */
    incr = 1 << (len - drop);
    fill = 1 << curr;
    min = fill;                 /* save offset to next table */
    do {
      fill -= incr;
      table[next + (huff >> drop) + fill] = (here_bits << 24) | (here_op << 16) | here_val |0;
    } while (fill !== 0);

    /* backwards increment the len-bit code huff */
    incr = 1 << (len - 1);
    while (huff & incr) {
      incr >>= 1;
    }
    if (incr !== 0) {
      huff &= incr - 1;
      huff += incr;
    } else {
      huff = 0;
    }

    /* go to next symbol, update count, len */
    sym++;
    if (--count[len] === 0) {
      if (len === max) { break; }
      len = lens[lens_index + work[sym]];
    }

    /* create new sub-table if needed */
    if (len > root && (huff & mask) !== low) {
      /* if first time, transition to sub-tables */
      if (drop === 0) {
        drop = root;
      }

      /* increment past last table */
      next += min;            /* here min is 1 << curr */

      /* determine length of next table */
      curr = len - drop;
      left = 1 << curr;
      while (curr + drop < max) {
        left -= count[curr + drop];
        if (left <= 0) { break; }
        curr++;
        left <<= 1;
      }

      /* check for enough space */
      used += 1 << curr;
      if ((type === LENS && used > ENOUGH_LENS) ||
        (type === DISTS && used > ENOUGH_DISTS)) {
        return 1;
      }

      /* point entry in root table to sub-table */
      low = huff & mask;
      /*table.op[low] = curr;
      table.bits[low] = root;
      table.val[low] = next - opts.table_index;*/
      table[low] = (root << 24) | (curr << 16) | (next - table_index) |0;
    }
  }

  /* fill in remaining table entry if code is incomplete (guaranteed to have
   at most one remaining entry, since if the code is incomplete, the
   maximum code length that was allowed to get this far is one bit) */
  if (huff !== 0) {
    //table.op[next + huff] = 64;            /* invalid code marker */
    //table.bits[next + huff] = len - drop;
    //table.val[next + huff] = 0;
    table[next + huff] = ((len - drop) << 24) | (64 << 16) |0;
  }

  /* set return parameters */
  //opts.table_index += used;
  opts.bits = root;
  return 0;
};

},{"../utils/common":6}],14:[function(require,module,exports){
'use strict';

module.exports = {
  2:      'need dictionary',     /* Z_NEED_DICT       2  */
  1:      'stream end',          /* Z_STREAM_END      1  */
  0:      '',                    /* Z_OK              0  */
  '-1':   'file error',          /* Z_ERRNO         (-1) */
  '-2':   'stream error',        /* Z_STREAM_ERROR  (-2) */
  '-3':   'data error',          /* Z_DATA_ERROR    (-3) */
  '-4':   'insufficient memory', /* Z_MEM_ERROR     (-4) */
  '-5':   'buffer error',        /* Z_BUF_ERROR     (-5) */
  '-6':   'incompatible version' /* Z_VERSION_ERROR (-6) */
};

},{}],15:[function(require,module,exports){
'use strict';


var utils = require('../utils/common');

/* Public constants ==========================================================*/
/* ===========================================================================*/


//var Z_FILTERED          = 1;
//var Z_HUFFMAN_ONLY      = 2;
//var Z_RLE               = 3;
var Z_FIXED               = 4;
//var Z_DEFAULT_STRATEGY  = 0;

/* Possible values of the data_type field (though see inflate()) */
var Z_BINARY              = 0;
var Z_TEXT                = 1;
//var Z_ASCII             = 1; // = Z_TEXT
var Z_UNKNOWN             = 2;

/*============================================================================*/


function zero(buf) { var len = buf.length; while (--len >= 0) { buf[len] = 0; } }

// From zutil.h

var STORED_BLOCK = 0;
var STATIC_TREES = 1;
var DYN_TREES    = 2;
/* The three kinds of block type */

var MIN_MATCH    = 3;
var MAX_MATCH    = 258;
/* The minimum and maximum match lengths */

// From deflate.h
/* ===========================================================================
 * Internal compression state.
 */

var LENGTH_CODES  = 29;
/* number of length codes, not counting the special END_BLOCK code */

var LITERALS      = 256;
/* number of literal bytes 0..255 */

var L_CODES       = LITERALS + 1 + LENGTH_CODES;
/* number of Literal or Length codes, including the END_BLOCK code */

var D_CODES       = 30;
/* number of distance codes */

var BL_CODES      = 19;
/* number of codes used to transfer the bit lengths */

var HEAP_SIZE     = 2 * L_CODES + 1;
/* maximum heap size */

var MAX_BITS      = 15;
/* All codes must not exceed MAX_BITS bits */

var Buf_size      = 16;
/* size of bit buffer in bi_buf */


/* ===========================================================================
 * Constants
 */

var MAX_BL_BITS = 7;
/* Bit length codes must not exceed MAX_BL_BITS bits */

var END_BLOCK   = 256;
/* end of block literal code */

var REP_3_6     = 16;
/* repeat previous bit length 3-6 times (2 bits of repeat count) */

var REPZ_3_10   = 17;
/* repeat a zero length 3-10 times  (3 bits of repeat count) */

var REPZ_11_138 = 18;
/* repeat a zero length 11-138 times  (7 bits of repeat count) */

/* eslint-disable comma-spacing,array-bracket-spacing */
var extra_lbits =   /* extra bits for each length code */
  [0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0];

var extra_dbits =   /* extra bits for each distance code */
  [0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13];

var extra_blbits =  /* extra bits for each bit length code */
  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7];

var bl_order =
  [16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];
/* eslint-enable comma-spacing,array-bracket-spacing */

/* The lengths of the bit length codes are sent in order of decreasing
 * probability, to avoid transmitting the lengths for unused bit length codes.
 */

/* ===========================================================================
 * Local data. These are initialized only once.
 */

// We pre-fill arrays with 0 to avoid uninitialized gaps

var DIST_CODE_LEN = 512; /* see definition of array dist_code below */

// !!!! Use flat array insdead of structure, Freq = i*2, Len = i*2+1
var static_ltree  = new Array((L_CODES + 2) * 2);
zero(static_ltree);
/* The static literal tree. Since the bit lengths are imposed, there is no
 * need for the L_CODES extra codes used during heap construction. However
 * The codes 286 and 287 are needed to build a canonical tree (see _tr_init
 * below).
 */

var static_dtree  = new Array(D_CODES * 2);
zero(static_dtree);
/* The static distance tree. (Actually a trivial tree since all codes use
 * 5 bits.)
 */

var _dist_code    = new Array(DIST_CODE_LEN);
zero(_dist_code);
/* Distance codes. The first 256 values correspond to the distances
 * 3 .. 258, the last 256 values correspond to the top 8 bits of
 * the 15 bit distances.
 */

var _length_code  = new Array(MAX_MATCH - MIN_MATCH + 1);
zero(_length_code);
/* length code for each normalized match length (0 == MIN_MATCH) */

var base_length   = new Array(LENGTH_CODES);
zero(base_length);
/* First normalized length for each code (0 = MIN_MATCH) */

var base_dist     = new Array(D_CODES);
zero(base_dist);
/* First normalized distance for each code (0 = distance of 1) */


function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {

  this.static_tree  = static_tree;  /* static tree or NULL */
  this.extra_bits   = extra_bits;   /* extra bits for each code or NULL */
  this.extra_base   = extra_base;   /* base index for extra_bits */
  this.elems        = elems;        /* max number of elements in the tree */
  this.max_length   = max_length;   /* max bit length for the codes */

  // show if `static_tree` has data or dummy - needed for monomorphic objects
  this.has_stree    = static_tree && static_tree.length;
}


var static_l_desc;
var static_d_desc;
var static_bl_desc;


function TreeDesc(dyn_tree, stat_desc) {
  this.dyn_tree = dyn_tree;     /* the dynamic tree */
  this.max_code = 0;            /* largest code with non zero frequency */
  this.stat_desc = stat_desc;   /* the corresponding static tree */
}



function d_code(dist) {
  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
}


/* ===========================================================================
 * Output a short LSB first on the stream.
 * IN assertion: there is enough room in pendingBuf.
 */
function put_short(s, w) {
//    put_byte(s, (uch)((w) & 0xff));
//    put_byte(s, (uch)((ush)(w) >> 8));
  s.pending_buf[s.pending++] = (w) & 0xff;
  s.pending_buf[s.pending++] = (w >>> 8) & 0xff;
}


/* ===========================================================================
 * Send a value on a given number of bits.
 * IN assertion: length <= 16 and value fits in length bits.
 */
function send_bits(s, value, length) {
  if (s.bi_valid > (Buf_size - length)) {
    s.bi_buf |= (value << s.bi_valid) & 0xffff;
    put_short(s, s.bi_buf);
    s.bi_buf = value >> (Buf_size - s.bi_valid);
    s.bi_valid += length - Buf_size;
  } else {
    s.bi_buf |= (value << s.bi_valid) & 0xffff;
    s.bi_valid += length;
  }
}


function send_code(s, c, tree) {
  send_bits(s, tree[c * 2]/*.Code*/, tree[c * 2 + 1]/*.Len*/);
}


/* ===========================================================================
 * Reverse the first len bits of a code, using straightforward code (a faster
 * method would use a table)
 * IN assertion: 1 <= len <= 15
 */
function bi_reverse(code, len) {
  var res = 0;
  do {
    res |= code & 1;
    code >>>= 1;
    res <<= 1;
  } while (--len > 0);
  return res >>> 1;
}


/* ===========================================================================
 * Flush the bit buffer, keeping at most 7 bits in it.
 */
function bi_flush(s) {
  if (s.bi_valid === 16) {
    put_short(s, s.bi_buf);
    s.bi_buf = 0;
    s.bi_valid = 0;

  } else if (s.bi_valid >= 8) {
    s.pending_buf[s.pending++] = s.bi_buf & 0xff;
    s.bi_buf >>= 8;
    s.bi_valid -= 8;
  }
}


/* ===========================================================================
 * Compute the optimal bit lengths for a tree and update the total bit length
 * for the current block.
 * IN assertion: the fields freq and dad are set, heap[heap_max] and
 *    above are the tree nodes sorted by increasing frequency.
 * OUT assertions: the field len is set to the optimal bit length, the
 *     array bl_count contains the frequencies for each bit length.
 *     The length opt_len is updated; static_len is also updated if stree is
 *     not null.
 */
function gen_bitlen(s, desc)
//    deflate_state *s;
//    tree_desc *desc;    /* the tree descriptor */
{
  var tree            = desc.dyn_tree;
  var max_code        = desc.max_code;
  var stree           = desc.stat_desc.static_tree;
  var has_stree       = desc.stat_desc.has_stree;
  var extra           = desc.stat_desc.extra_bits;
  var base            = desc.stat_desc.extra_base;
  var max_length      = desc.stat_desc.max_length;
  var h;              /* heap index */
  var n, m;           /* iterate over the tree elements */
  var bits;           /* bit length */
  var xbits;          /* extra bits */
  var f;              /* frequency */
  var overflow = 0;   /* number of elements with bit length too large */

  for (bits = 0; bits <= MAX_BITS; bits++) {
    s.bl_count[bits] = 0;
  }

  /* In a first pass, compute the optimal bit lengths (which may
   * overflow in the case of the bit length tree).
   */
  tree[s.heap[s.heap_max] * 2 + 1]/*.Len*/ = 0; /* root of the heap */

  for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {
    n = s.heap[h];
    bits = tree[tree[n * 2 + 1]/*.Dad*/ * 2 + 1]/*.Len*/ + 1;
    if (bits > max_length) {
      bits = max_length;
      overflow++;
    }
    tree[n * 2 + 1]/*.Len*/ = bits;
    /* We overwrite tree[n].Dad which is no longer needed */

    if (n > max_code) { continue; } /* not a leaf node */

    s.bl_count[bits]++;
    xbits = 0;
    if (n >= base) {
      xbits = extra[n - base];
    }
    f = tree[n * 2]/*.Freq*/;
    s.opt_len += f * (bits + xbits);
    if (has_stree) {
      s.static_len += f * (stree[n * 2 + 1]/*.Len*/ + xbits);
    }
  }
  if (overflow === 0) { return; }

  // Trace((stderr,"\nbit length overflow\n"));
  /* This happens for example on obj2 and pic of the Calgary corpus */

  /* Find the first bit length which could increase: */
  do {
    bits = max_length - 1;
    while (s.bl_count[bits] === 0) { bits--; }
    s.bl_count[bits]--;      /* move one leaf down the tree */
    s.bl_count[bits + 1] += 2; /* move one overflow item as its brother */
    s.bl_count[max_length]--;
    /* The brother of the overflow item also moves one step up,
     * but this does not affect bl_count[max_length]
     */
    overflow -= 2;
  } while (overflow > 0);

  /* Now recompute all bit lengths, scanning in increasing frequency.
   * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all
   * lengths instead of fixing only the wrong ones. This idea is taken
   * from 'ar' written by Haruhiko Okumura.)
   */
  for (bits = max_length; bits !== 0; bits--) {
    n = s.bl_count[bits];
    while (n !== 0) {
      m = s.heap[--h];
      if (m > max_code) { continue; }
      if (tree[m * 2 + 1]/*.Len*/ !== bits) {
        // Trace((stderr,"code %d bits %d->%d\n", m, tree[m].Len, bits));
        s.opt_len += (bits - tree[m * 2 + 1]/*.Len*/) * tree[m * 2]/*.Freq*/;
        tree[m * 2 + 1]/*.Len*/ = bits;
      }
      n--;
    }
  }
}


/* ===========================================================================
 * Generate the codes for a given tree and bit counts (which need not be
 * optimal).
 * IN assertion: the array bl_count contains the bit length statistics for
 * the given tree and the field len is set for all tree elements.
 * OUT assertion: the field code is set for all tree elements of non
 *     zero code length.
 */
function gen_codes(tree, max_code, bl_count)
//    ct_data *tree;             /* the tree to decorate */
//    int max_code;              /* largest code with non zero frequency */
//    ushf *bl_count;            /* number of codes at each bit length */
{
  var next_code = new Array(MAX_BITS + 1); /* next code value for each bit length */
  var code = 0;              /* running code value */
  var bits;                  /* bit index */
  var n;                     /* code index */

  /* The distribution counts are first used to generate the code values
   * without bit reversal.
   */
  for (bits = 1; bits <= MAX_BITS; bits++) {
    next_code[bits] = code = (code + bl_count[bits - 1]) << 1;
  }
  /* Check that the bit counts in bl_count are consistent. The last code
   * must be all ones.
   */
  //Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,
  //        "inconsistent bit counts");
  //Tracev((stderr,"\ngen_codes: max_code %d ", max_code));

  for (n = 0;  n <= max_code; n++) {
    var len = tree[n * 2 + 1]/*.Len*/;
    if (len === 0) { continue; }
    /* Now reverse the bits */
    tree[n * 2]/*.Code*/ = bi_reverse(next_code[len]++, len);

    //Tracecv(tree != static_ltree, (stderr,"\nn %3d %c l %2d c %4x (%x) ",
    //     n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));
  }
}


/* ===========================================================================
 * Initialize the various 'constant' tables.
 */
function tr_static_init() {
  var n;        /* iterates over tree elements */
  var bits;     /* bit counter */
  var length;   /* length value */
  var code;     /* code value */
  var dist;     /* distance index */
  var bl_count = new Array(MAX_BITS + 1);
  /* number of codes at each bit length for an optimal tree */

  // do check in _tr_init()
  //if (static_init_done) return;

  /* For some embedded targets, global variables are not initialized: */
/*#ifdef NO_INIT_GLOBAL_POINTERS
  static_l_desc.static_tree = static_ltree;
  static_l_desc.extra_bits = extra_lbits;
  static_d_desc.static_tree = static_dtree;
  static_d_desc.extra_bits = extra_dbits;
  static_bl_desc.extra_bits = extra_blbits;
#endif*/

  /* Initialize the mapping length (0..255) -> length code (0..28) */
  length = 0;
  for (code = 0; code < LENGTH_CODES - 1; code++) {
    base_length[code] = length;
    for (n = 0; n < (1 << extra_lbits[code]); n++) {
      _length_code[length++] = code;
    }
  }
  //Assert (length == 256, "tr_static_init: length != 256");
  /* Note that the length 255 (match length 258) can be represented
   * in two different ways: code 284 + 5 bits or code 285, so we
   * overwrite length_code[255] to use the best encoding:
   */
  _length_code[length - 1] = code;

  /* Initialize the mapping dist (0..32K) -> dist code (0..29) */
  dist = 0;
  for (code = 0; code < 16; code++) {
    base_dist[code] = dist;
    for (n = 0; n < (1 << extra_dbits[code]); n++) {
      _dist_code[dist++] = code;
    }
  }
  //Assert (dist == 256, "tr_static_init: dist != 256");
  dist >>= 7; /* from now on, all distances are divided by 128 */
  for (; code < D_CODES; code++) {
    base_dist[code] = dist << 7;
    for (n = 0; n < (1 << (extra_dbits[code] - 7)); n++) {
      _dist_code[256 + dist++] = code;
    }
  }
  //Assert (dist == 256, "tr_static_init: 256+dist != 512");

  /* Construct the codes of the static literal tree */
  for (bits = 0; bits <= MAX_BITS; bits++) {
    bl_count[bits] = 0;
  }

  n = 0;
  while (n <= 143) {
    static_ltree[n * 2 + 1]/*.Len*/ = 8;
    n++;
    bl_count[8]++;
  }
  while (n <= 255) {
    static_ltree[n * 2 + 1]/*.Len*/ = 9;
    n++;
    bl_count[9]++;
  }
  while (n <= 279) {
    static_ltree[n * 2 + 1]/*.Len*/ = 7;
    n++;
    bl_count[7]++;
  }
  while (n <= 287) {
    static_ltree[n * 2 + 1]/*.Len*/ = 8;
    n++;
    bl_count[8]++;
  }
  /* Codes 286 and 287 do not exist, but we must include them in the
   * tree construction to get a canonical Huffman tree (longest code
   * all ones)
   */
  gen_codes(static_ltree, L_CODES + 1, bl_count);

  /* The static distance tree is trivial: */
  for (n = 0; n < D_CODES; n++) {
    static_dtree[n * 2 + 1]/*.Len*/ = 5;
    static_dtree[n * 2]/*.Code*/ = bi_reverse(n, 5);
  }

  // Now data ready and we can init static trees
  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0,          D_CODES, MAX_BITS);
  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0,         BL_CODES, MAX_BL_BITS);

  //static_init_done = true;
}


/* ===========================================================================
 * Initialize a new block.
 */
function init_block(s) {
  var n; /* iterates over tree elements */

  /* Initialize the trees. */
  for (n = 0; n < L_CODES;  n++) { s.dyn_ltree[n * 2]/*.Freq*/ = 0; }
  for (n = 0; n < D_CODES;  n++) { s.dyn_dtree[n * 2]/*.Freq*/ = 0; }
  for (n = 0; n < BL_CODES; n++) { s.bl_tree[n * 2]/*.Freq*/ = 0; }

  s.dyn_ltree[END_BLOCK * 2]/*.Freq*/ = 1;
  s.opt_len = s.static_len = 0;
  s.last_lit = s.matches = 0;
}


/* ===========================================================================
 * Flush the bit buffer and align the output on a byte boundary
 */
function bi_windup(s)
{
  if (s.bi_valid > 8) {
    put_short(s, s.bi_buf);
  } else if (s.bi_valid > 0) {
    //put_byte(s, (Byte)s->bi_buf);
    s.pending_buf[s.pending++] = s.bi_buf;
  }
  s.bi_buf = 0;
  s.bi_valid = 0;
}

/* ===========================================================================
 * Copy a stored block, storing first the length and its
 * one's complement if requested.
 */
function copy_block(s, buf, len, header)
//DeflateState *s;
//charf    *buf;    /* the input data */
//unsigned len;     /* its length */
//int      header;  /* true if block header must be written */
{
  bi_windup(s);        /* align on byte boundary */

  if (header) {
    put_short(s, len);
    put_short(s, ~len);
  }
//  while (len--) {
//    put_byte(s, *buf++);
//  }
  utils.arraySet(s.pending_buf, s.window, buf, len, s.pending);
  s.pending += len;
}

/* ===========================================================================
 * Compares to subtrees, using the tree depth as tie breaker when
 * the subtrees have equal frequency. This minimizes the worst case length.
 */
function smaller(tree, n, m, depth) {
  var _n2 = n * 2;
  var _m2 = m * 2;
  return (tree[_n2]/*.Freq*/ < tree[_m2]/*.Freq*/ ||
         (tree[_n2]/*.Freq*/ === tree[_m2]/*.Freq*/ && depth[n] <= depth[m]));
}

/* ===========================================================================
 * Restore the heap property by moving down the tree starting at node k,
 * exchanging a node with the smallest of its two sons if necessary, stopping
 * when the heap property is re-established (each father smaller than its
 * two sons).
 */
function pqdownheap(s, tree, k)
//    deflate_state *s;
//    ct_data *tree;  /* the tree to restore */
//    int k;               /* node to move down */
{
  var v = s.heap[k];
  var j = k << 1;  /* left son of k */
  while (j <= s.heap_len) {
    /* Set j to the smallest of the two sons: */
    if (j < s.heap_len &&
      smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
      j++;
    }
    /* Exit if v is smaller than both sons */
    if (smaller(tree, v, s.heap[j], s.depth)) { break; }

    /* Exchange v with the smallest son */
    s.heap[k] = s.heap[j];
    k = j;

    /* And continue down the tree, setting j to the left son of k */
    j <<= 1;
  }
  s.heap[k] = v;
}


// inlined manually
// var SMALLEST = 1;

/* ===========================================================================
 * Send the block data compressed using the given Huffman trees
 */
function compress_block(s, ltree, dtree)
//    deflate_state *s;
//    const ct_data *ltree; /* literal tree */
//    const ct_data *dtree; /* distance tree */
{
  var dist;           /* distance of matched string */
  var lc;             /* match length or unmatched char (if dist == 0) */
  var lx = 0;         /* running index in l_buf */
  var code;           /* the code to send */
  var extra;          /* number of extra bits to send */

  if (s.last_lit !== 0) {
    do {
      dist = (s.pending_buf[s.d_buf + lx * 2] << 8) | (s.pending_buf[s.d_buf + lx * 2 + 1]);
      lc = s.pending_buf[s.l_buf + lx];
      lx++;

      if (dist === 0) {
        send_code(s, lc, ltree); /* send a literal byte */
        //Tracecv(isgraph(lc), (stderr," '%c' ", lc));
      } else {
        /* Here, lc is the match length - MIN_MATCH */
        code = _length_code[lc];
        send_code(s, code + LITERALS + 1, ltree); /* send the length code */
        extra = extra_lbits[code];
        if (extra !== 0) {
          lc -= base_length[code];
          send_bits(s, lc, extra);       /* send the extra length bits */
        }
        dist--; /* dist is now the match distance - 1 */
        code = d_code(dist);
        //Assert (code < D_CODES, "bad d_code");

        send_code(s, code, dtree);       /* send the distance code */
        extra = extra_dbits[code];
        if (extra !== 0) {
          dist -= base_dist[code];
          send_bits(s, dist, extra);   /* send the extra distance bits */
        }
      } /* literal or match pair ? */

      /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */
      //Assert((uInt)(s->pending) < s->lit_bufsize + 2*lx,
      //       "pendingBuf overflow");

    } while (lx < s.last_lit);
  }

  send_code(s, END_BLOCK, ltree);
}


/* ===========================================================================
 * Construct one Huffman tree and assigns the code bit strings and lengths.
 * Update the total bit length for the current block.
 * IN assertion: the field freq is set for all tree elements.
 * OUT assertions: the fields len and code are set to the optimal bit length
 *     and corresponding code. The length opt_len is updated; static_len is
 *     also updated if stree is not null. The field max_code is set.
 */
function build_tree(s, desc)
//    deflate_state *s;
//    tree_desc *desc; /* the tree descriptor */
{
  var tree     = desc.dyn_tree;
  var stree    = desc.stat_desc.static_tree;
  var has_stree = desc.stat_desc.has_stree;
  var elems    = desc.stat_desc.elems;
  var n, m;          /* iterate over heap elements */
  var max_code = -1; /* largest code with non zero frequency */
  var node;          /* new node being created */

  /* Construct the initial heap, with least frequent element in
   * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].
   * heap[0] is not used.
   */
  s.heap_len = 0;
  s.heap_max = HEAP_SIZE;

  for (n = 0; n < elems; n++) {
    if (tree[n * 2]/*.Freq*/ !== 0) {
      s.heap[++s.heap_len] = max_code = n;
      s.depth[n] = 0;

    } else {
      tree[n * 2 + 1]/*.Len*/ = 0;
    }
  }

  /* The pkzip format requires that at least one distance code exists,
   * and that at least one bit should be sent even if there is only one
   * possible code. So to avoid special checks later on we force at least
   * two codes of non zero frequency.
   */
  while (s.heap_len < 2) {
    node = s.heap[++s.heap_len] = (max_code < 2 ? ++max_code : 0);
    tree[node * 2]/*.Freq*/ = 1;
    s.depth[node] = 0;
    s.opt_len--;

    if (has_stree) {
      s.static_len -= stree[node * 2 + 1]/*.Len*/;
    }
    /* node is 0 or 1 so it does not have extra bits */
  }
  desc.max_code = max_code;

  /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,
   * establish sub-heaps of increasing lengths:
   */
  for (n = (s.heap_len >> 1/*int /2*/); n >= 1; n--) { pqdownheap(s, tree, n); }

  /* Construct the Huffman tree by repeatedly combining the least two
   * frequent nodes.
   */
  node = elems;              /* next internal node of the tree */
  do {
    //pqremove(s, tree, n);  /* n = node of least frequency */
    /*** pqremove ***/
    n = s.heap[1/*SMALLEST*/];
    s.heap[1/*SMALLEST*/] = s.heap[s.heap_len--];
    pqdownheap(s, tree, 1/*SMALLEST*/);
    /***/

    m = s.heap[1/*SMALLEST*/]; /* m = node of next least frequency */

    s.heap[--s.heap_max] = n; /* keep the nodes sorted by frequency */
    s.heap[--s.heap_max] = m;

    /* Create a new node father of n and m */
    tree[node * 2]/*.Freq*/ = tree[n * 2]/*.Freq*/ + tree[m * 2]/*.Freq*/;
    s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
    tree[n * 2 + 1]/*.Dad*/ = tree[m * 2 + 1]/*.Dad*/ = node;

    /* and insert the new node in the heap */
    s.heap[1/*SMALLEST*/] = node++;
    pqdownheap(s, tree, 1/*SMALLEST*/);

  } while (s.heap_len >= 2);

  s.heap[--s.heap_max] = s.heap[1/*SMALLEST*/];

  /* At this point, the fields freq and dad are set. We can now
   * generate the bit lengths.
   */
  gen_bitlen(s, desc);

  /* The field len is now set, we can generate the bit codes */
  gen_codes(tree, max_code, s.bl_count);
}


/* ===========================================================================
 * Scan a literal or distance tree to determine the frequencies of the codes
 * in the bit length tree.
 */
function scan_tree(s, tree, max_code)
//    deflate_state *s;
//    ct_data *tree;   /* the tree to be scanned */
//    int max_code;    /* and its largest code of non zero frequency */
{
  var n;                     /* iterates over all tree elements */
  var prevlen = -1;          /* last emitted length */
  var curlen;                /* length of current code */

  var nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */

  var count = 0;             /* repeat count of the current code */
  var max_count = 7;         /* max repeat count */
  var min_count = 4;         /* min repeat count */

  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  tree[(max_code + 1) * 2 + 1]/*.Len*/ = 0xffff; /* guard */

  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;

    if (++count < max_count && curlen === nextlen) {
      continue;

    } else if (count < min_count) {
      s.bl_tree[curlen * 2]/*.Freq*/ += count;

    } else if (curlen !== 0) {

      if (curlen !== prevlen) { s.bl_tree[curlen * 2]/*.Freq*/++; }
      s.bl_tree[REP_3_6 * 2]/*.Freq*/++;

    } else if (count <= 10) {
      s.bl_tree[REPZ_3_10 * 2]/*.Freq*/++;

    } else {
      s.bl_tree[REPZ_11_138 * 2]/*.Freq*/++;
    }

    count = 0;
    prevlen = curlen;

    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;

    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;

    } else {
      max_count = 7;
      min_count = 4;
    }
  }
}


/* ===========================================================================
 * Send a literal or distance tree in compressed form, using the codes in
 * bl_tree.
 */
function send_tree(s, tree, max_code)
//    deflate_state *s;
//    ct_data *tree; /* the tree to be scanned */
//    int max_code;       /* and its largest code of non zero frequency */
{
  var n;                     /* iterates over all tree elements */
  var prevlen = -1;          /* last emitted length */
  var curlen;                /* length of current code */

  var nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */

  var count = 0;             /* repeat count of the current code */
  var max_count = 7;         /* max repeat count */
  var min_count = 4;         /* min repeat count */

  /* tree[max_code+1].Len = -1; */  /* guard already set */
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }

  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;

    if (++count < max_count && curlen === nextlen) {
      continue;

    } else if (count < min_count) {
      do { send_code(s, curlen, s.bl_tree); } while (--count !== 0);

    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        send_code(s, curlen, s.bl_tree);
        count--;
      }
      //Assert(count >= 3 && count <= 6, " 3_6?");
      send_code(s, REP_3_6, s.bl_tree);
      send_bits(s, count - 3, 2);

    } else if (count <= 10) {
      send_code(s, REPZ_3_10, s.bl_tree);
      send_bits(s, count - 3, 3);

    } else {
      send_code(s, REPZ_11_138, s.bl_tree);
      send_bits(s, count - 11, 7);
    }

    count = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;

    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;

    } else {
      max_count = 7;
      min_count = 4;
    }
  }
}


/* ===========================================================================
 * Construct the Huffman tree for the bit lengths and return the index in
 * bl_order of the last bit length code to send.
 */
function build_bl_tree(s) {
  var max_blindex;  /* index of last bit length code of non zero freq */

  /* Determine the bit length frequencies for literal and distance trees */
  scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
  scan_tree(s, s.dyn_dtree, s.d_desc.max_code);

  /* Build the bit length tree: */
  build_tree(s, s.bl_desc);
  /* opt_len now includes the length of the tree representations, except
   * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.
   */

  /* Determine the number of bit length codes to send. The pkzip format
   * requires that at least 4 bit length codes be sent. (appnote.txt says
   * 3 but the actual value used is 4.)
   */
  for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
    if (s.bl_tree[bl_order[max_blindex] * 2 + 1]/*.Len*/ !== 0) {
      break;
    }
  }
  /* Update opt_len to include the bit length tree and counts */
  s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
  //Tracev((stderr, "\ndyn trees: dyn %ld, stat %ld",
  //        s->opt_len, s->static_len));

  return max_blindex;
}


/* ===========================================================================
 * Send the header for a block using dynamic Huffman trees: the counts, the
 * lengths of the bit length codes, the literal tree and the distance tree.
 * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.
 */
function send_all_trees(s, lcodes, dcodes, blcodes)
//    deflate_state *s;
//    int lcodes, dcodes, blcodes; /* number of codes for each tree */
{
  var rank;                    /* index in bl_order */

  //Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, "not enough codes");
  //Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,
  //        "too many codes");
  //Tracev((stderr, "\nbl counts: "));
  send_bits(s, lcodes - 257, 5); /* not +255 as stated in appnote.txt */
  send_bits(s, dcodes - 1,   5);
  send_bits(s, blcodes - 4,  4); /* not -3 as stated in appnote.txt */
  for (rank = 0; rank < blcodes; rank++) {
    //Tracev((stderr, "\nbl code %2d ", bl_order[rank]));
    send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1]/*.Len*/, 3);
  }
  //Tracev((stderr, "\nbl tree: sent %ld", s->bits_sent));

  send_tree(s, s.dyn_ltree, lcodes - 1); /* literal tree */
  //Tracev((stderr, "\nlit tree: sent %ld", s->bits_sent));

  send_tree(s, s.dyn_dtree, dcodes - 1); /* distance tree */
  //Tracev((stderr, "\ndist tree: sent %ld", s->bits_sent));
}


/* ===========================================================================
 * Check if the data type is TEXT or BINARY, using the following algorithm:
 * - TEXT if the two conditions below are satisfied:
 *    a) There are no non-portable control characters belonging to the
 *       "black list" (0..6, 14..25, 28..31).
 *    b) There is at least one printable character belonging to the
 *       "white list" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).
 * - BINARY otherwise.
 * - The following partially-portable control characters form a
 *   "gray list" that is ignored in this detection algorithm:
 *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).
 * IN assertion: the fields Freq of dyn_ltree are set.
 */
function detect_data_type(s) {
  /* black_mask is the bit mask of black-listed bytes
   * set bits 0..6, 14..25, and 28..31
   * 0xf3ffc07f = binary 11110011111111111100000001111111
   */
  var black_mask = 0xf3ffc07f;
  var n;

  /* Check for non-textual ("black-listed") bytes. */
  for (n = 0; n <= 31; n++, black_mask >>>= 1) {
    if ((black_mask & 1) && (s.dyn_ltree[n * 2]/*.Freq*/ !== 0)) {
      return Z_BINARY;
    }
  }

  /* Check for textual ("white-listed") bytes. */
  if (s.dyn_ltree[9 * 2]/*.Freq*/ !== 0 || s.dyn_ltree[10 * 2]/*.Freq*/ !== 0 ||
      s.dyn_ltree[13 * 2]/*.Freq*/ !== 0) {
    return Z_TEXT;
  }
  for (n = 32; n < LITERALS; n++) {
    if (s.dyn_ltree[n * 2]/*.Freq*/ !== 0) {
      return Z_TEXT;
    }
  }

  /* There are no "black-listed" or "white-listed" bytes:
   * this stream either is empty or has tolerated ("gray-listed") bytes only.
   */
  return Z_BINARY;
}


var static_init_done = false;

/* ===========================================================================
 * Initialize the tree data structures for a new zlib stream.
 */
function _tr_init(s)
{

  if (!static_init_done) {
    tr_static_init();
    static_init_done = true;
  }

  s.l_desc  = new TreeDesc(s.dyn_ltree, static_l_desc);
  s.d_desc  = new TreeDesc(s.dyn_dtree, static_d_desc);
  s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);

  s.bi_buf = 0;
  s.bi_valid = 0;

  /* Initialize the first block of the first file: */
  init_block(s);
}


/* ===========================================================================
 * Send a stored block
 */
function _tr_stored_block(s, buf, stored_len, last)
//DeflateState *s;
//charf *buf;       /* input block */
//ulg stored_len;   /* length of input block */
//int last;         /* one if this is the last block for a file */
{
  send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);    /* send block type */
  copy_block(s, buf, stored_len, true); /* with header */
}


/* ===========================================================================
 * Send one empty static block to give enough lookahead for inflate.
 * This takes 10 bits, of which 7 may remain in the bit buffer.
 */
function _tr_align(s) {
  send_bits(s, STATIC_TREES << 1, 3);
  send_code(s, END_BLOCK, static_ltree);
  bi_flush(s);
}


/* ===========================================================================
 * Determine the best encoding for the current block: dynamic trees, static
 * trees or store, and output the encoded block to the zip file.
 */
function _tr_flush_block(s, buf, stored_len, last)
//DeflateState *s;
//charf *buf;       /* input block, or NULL if too old */
//ulg stored_len;   /* length of input block */
//int last;         /* one if this is the last block for a file */
{
  var opt_lenb, static_lenb;  /* opt_len and static_len in bytes */
  var max_blindex = 0;        /* index of last bit length code of non zero freq */

  /* Build the Huffman trees unless a stored block is forced */
  if (s.level > 0) {

    /* Check if the file is binary or text */
    if (s.strm.data_type === Z_UNKNOWN) {
      s.strm.data_type = detect_data_type(s);
    }

    /* Construct the literal and distance trees */
    build_tree(s, s.l_desc);
    // Tracev((stderr, "\nlit data: dyn %ld, stat %ld", s->opt_len,
    //        s->static_len));

    build_tree(s, s.d_desc);
    // Tracev((stderr, "\ndist data: dyn %ld, stat %ld", s->opt_len,
    //        s->static_len));
    /* At this point, opt_len and static_len are the total bit lengths of
     * the compressed block data, excluding the tree representations.
     */

    /* Build the bit length tree for the above two trees, and get the index
     * in bl_order of the last bit length code to send.
     */
    max_blindex = build_bl_tree(s);

    /* Determine the best encoding. Compute the block lengths in bytes. */
    opt_lenb = (s.opt_len + 3 + 7) >>> 3;
    static_lenb = (s.static_len + 3 + 7) >>> 3;

    // Tracev((stderr, "\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u ",
    //        opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,
    //        s->last_lit));

    if (static_lenb <= opt_lenb) { opt_lenb = static_lenb; }

  } else {
    // Assert(buf != (char*)0, "lost buf");
    opt_lenb = static_lenb = stored_len + 5; /* force a stored block */
  }

  if ((stored_len + 4 <= opt_lenb) && (buf !== -1)) {
    /* 4: two words for the lengths */

    /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.
     * Otherwise we can't have processed more than WSIZE input bytes since
     * the last block flush, because compression would have been
     * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to
     * transform a block into a stored block.
     */
    _tr_stored_block(s, buf, stored_len, last);

  } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {

    send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
    compress_block(s, static_ltree, static_dtree);

  } else {
    send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
    send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
    compress_block(s, s.dyn_ltree, s.dyn_dtree);
  }
  // Assert (s->compressed_len == s->bits_sent, "bad compressed size");
  /* The above check is made mod 2^32, for files larger than 512 MB
   * and uLong implemented on 32 bits.
   */
  init_block(s);

  if (last) {
    bi_windup(s);
  }
  // Tracev((stderr,"\ncomprlen %lu(%lu) ", s->compressed_len>>3,
  //       s->compressed_len-7*last));
}

/* ===========================================================================
 * Save the match info and tally the frequency counts. Return true if
 * the current block must be flushed.
 */
function _tr_tally(s, dist, lc)
//    deflate_state *s;
//    unsigned dist;  /* distance of matched string */
//    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */
{
  //var out_length, in_length, dcode;

  s.pending_buf[s.d_buf + s.last_lit * 2]     = (dist >>> 8) & 0xff;
  s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 0xff;

  s.pending_buf[s.l_buf + s.last_lit] = lc & 0xff;
  s.last_lit++;

  if (dist === 0) {
    /* lc is the unmatched char */
    s.dyn_ltree[lc * 2]/*.Freq*/++;
  } else {
    s.matches++;
    /* Here, lc is the match length - MIN_MATCH */
    dist--;             /* dist = match distance - 1 */
    //Assert((ush)dist < (ush)MAX_DIST(s) &&
    //       (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&
    //       (ush)d_code(dist) < (ush)D_CODES,  "_tr_tally: bad match");

    s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]/*.Freq*/++;
    s.dyn_dtree[d_code(dist) * 2]/*.Freq*/++;
  }

// (!) This block is disabled in zlib defailts,
// don't enable it for binary compatibility

//#ifdef TRUNCATE_BLOCK
//  /* Try to guess if it is profitable to stop the current block here */
//  if ((s.last_lit & 0x1fff) === 0 && s.level > 2) {
//    /* Compute an upper bound for the compressed length */
//    out_length = s.last_lit*8;
//    in_length = s.strstart - s.block_start;
//
//    for (dcode = 0; dcode < D_CODES; dcode++) {
//      out_length += s.dyn_dtree[dcode*2]/*.Freq*/ * (5 + extra_dbits[dcode]);
//    }
//    out_length >>>= 3;
//    //Tracev((stderr,"\nlast_lit %u, in %ld, out ~%ld(%ld%%) ",
//    //       s->last_lit, in_length, out_length,
//    //       100L - out_length*100L/in_length));
//    if (s.matches < (s.last_lit>>1)/*int /2*/ && out_length < (in_length>>1)/*int /2*/) {
//      return true;
//    }
//  }
//#endif

  return (s.last_lit === s.lit_bufsize - 1);
  /* We avoid equality with lit_bufsize because of wraparound at 64K
   * on 16 bit machines and because stored blocks are restricted to
   * 64K-1 bytes.
   */
}

exports._tr_init  = _tr_init;
exports._tr_stored_block = _tr_stored_block;
exports._tr_flush_block  = _tr_flush_block;
exports._tr_tally = _tr_tally;
exports._tr_align = _tr_align;

},{"../utils/common":6}],16:[function(require,module,exports){
'use strict';


function ZStream() {
  /* next input byte */
  this.input = null; // JS specific, because we have no pointers
  this.next_in = 0;
  /* number of bytes available at input */
  this.avail_in = 0;
  /* total number of input bytes read so far */
  this.total_in = 0;
  /* next output byte should be put there */
  this.output = null; // JS specific, because we have no pointers
  this.next_out = 0;
  /* remaining free space at output */
  this.avail_out = 0;
  /* total number of bytes output so far */
  this.total_out = 0;
  /* last error message, NULL if no error */
  this.msg = ''/*Z_NULL*/;
  /* not visible by applications */
  this.state = null;
  /* best guess about the data type: binary or text */
  this.data_type = 2/*Z_UNKNOWN*/;
  /* adler32 value of the uncompressed data */
  this.adler = 0;
}

module.exports = ZStream;

},{}],17:[function(require,module,exports){
(function (process,Buffer){
var msg = require('pako/lib/zlib/messages');
var zstream = require('pako/lib/zlib/zstream');
var zlib_deflate = require('pako/lib/zlib/deflate.js');
var zlib_inflate = require('pako/lib/zlib/inflate.js');
var constants = require('pako/lib/zlib/constants');

for (var key in constants) {
  exports[key] = constants[key];
}

// zlib modes
exports.NONE = 0;
exports.DEFLATE = 1;
exports.INFLATE = 2;
exports.GZIP = 3;
exports.GUNZIP = 4;
exports.DEFLATERAW = 5;
exports.INFLATERAW = 6;
exports.UNZIP = 7;

/**
 * Emulate Node's zlib C++ layer for use by the JS layer in index.js
 */
function Zlib(mode) {
  if (mode < exports.DEFLATE || mode > exports.UNZIP)
    throw new TypeError("Bad argument");
    
  this.mode = mode;
  this.init_done = false;
  this.write_in_progress = false;
  this.pending_close = false;
  this.windowBits = 0;
  this.level = 0;
  this.memLevel = 0;
  this.strategy = 0;
  this.dictionary = null;
}

Zlib.prototype.init = function(windowBits, level, memLevel, strategy, dictionary) {
  this.windowBits = windowBits;
  this.level = level;
  this.memLevel = memLevel;
  this.strategy = strategy;
  // dictionary not supported.
  
  if (this.mode === exports.GZIP || this.mode === exports.GUNZIP)
    this.windowBits += 16;
    
  if (this.mode === exports.UNZIP)
    this.windowBits += 32;
    
  if (this.mode === exports.DEFLATERAW || this.mode === exports.INFLATERAW)
    this.windowBits = -this.windowBits;
    
  this.strm = new zstream();
  
  switch (this.mode) {
    case exports.DEFLATE:
    case exports.GZIP:
    case exports.DEFLATERAW:
      var status = zlib_deflate.deflateInit2(
        this.strm,
        this.level,
        exports.Z_DEFLATED,
        this.windowBits,
        this.memLevel,
        this.strategy
      );
      break;
    case exports.INFLATE:
    case exports.GUNZIP:
    case exports.INFLATERAW:
    case exports.UNZIP:
      var status  = zlib_inflate.inflateInit2(
        this.strm,
        this.windowBits
      );
      break;
    default:
      throw new Error("Unknown mode " + this.mode);
  }
  
  if (status !== exports.Z_OK) {
    this._error(status);
    return;
  }
  
  this.write_in_progress = false;
  this.init_done = true;
};

Zlib.prototype.params = function() {
  throw new Error("deflateParams Not supported");
};

Zlib.prototype._writeCheck = function() {
  if (!this.init_done)
    throw new Error("write before init");
    
  if (this.mode === exports.NONE)
    throw new Error("already finalized");
    
  if (this.write_in_progress)
    throw new Error("write already in progress");
    
  if (this.pending_close)
    throw new Error("close is pending");
};

Zlib.prototype.write = function(flush, input, in_off, in_len, out, out_off, out_len) {    
  this._writeCheck();
  this.write_in_progress = true;
  
  var self = this;
  process.nextTick(function() {
    self.write_in_progress = false;
    var res = self._write(flush, input, in_off, in_len, out, out_off, out_len);
    self.callback(res[0], res[1]);
    
    if (self.pending_close)
      self.close();
  });
  
  return this;
};

// set method for Node buffers, used by pako
function bufferSet(data, offset) {
  for (var i = 0; i < data.length; i++) {
    this[offset + i] = data[i];
  }
}

Zlib.prototype.writeSync = function(flush, input, in_off, in_len, out, out_off, out_len) {
  this._writeCheck();
  return this._write(flush, input, in_off, in_len, out, out_off, out_len);
};

Zlib.prototype._write = function(flush, input, in_off, in_len, out, out_off, out_len) {
  this.write_in_progress = true;
  
  if (flush !== exports.Z_NO_FLUSH &&
      flush !== exports.Z_PARTIAL_FLUSH &&
      flush !== exports.Z_SYNC_FLUSH &&
      flush !== exports.Z_FULL_FLUSH &&
      flush !== exports.Z_FINISH &&
      flush !== exports.Z_BLOCK) {
    throw new Error("Invalid flush value");
  }
  
  if (input == null) {
    input = new Buffer(0);
    in_len = 0;
    in_off = 0;
  }
  
  if (out._set)
    out.set = out._set;
  else
    out.set = bufferSet;
  
  var strm = this.strm;
  strm.avail_in = in_len;
  strm.input = input;
  strm.next_in = in_off;
  strm.avail_out = out_len;
  strm.output = out;
  strm.next_out = out_off;
  
  switch (this.mode) {
    case exports.DEFLATE:
    case exports.GZIP:
    case exports.DEFLATERAW:
      var status = zlib_deflate.deflate(strm, flush);
      break;
    case exports.UNZIP:
    case exports.INFLATE:
    case exports.GUNZIP:
    case exports.INFLATERAW:
      var status = zlib_inflate.inflate(strm, flush);
      break;
    default:
      throw new Error("Unknown mode " + this.mode);
  }
  
  if (status !== exports.Z_STREAM_END && status !== exports.Z_OK) {
    this._error(status);
  }
  
  this.write_in_progress = false;
  return [strm.avail_in, strm.avail_out];
};

Zlib.prototype.close = function() {
  if (this.write_in_progress) {
    this.pending_close = true;
    return;
  }
  
  this.pending_close = false;
  
  if (this.mode === exports.DEFLATE || this.mode === exports.GZIP || this.mode === exports.DEFLATERAW) {
    zlib_deflate.deflateEnd(this.strm);
  } else {
    zlib_inflate.inflateEnd(this.strm);
  }
  
  this.mode = exports.NONE;
};

Zlib.prototype.reset = function() {
  switch (this.mode) {
    case exports.DEFLATE:
    case exports.DEFLATERAW:
      var status = zlib_deflate.deflateReset(this.strm);
      break;
    case exports.INFLATE:
    case exports.INFLATERAW:
      var status = zlib_inflate.inflateReset(this.strm);
      break;
  }
  
  if (status !== exports.Z_OK) {
    this._error(status);
  }
};

Zlib.prototype._error = function(status) {
  this.onerror(msg[status] + ': ' + this.strm.msg, status);
  
  this.write_in_progress = false;
  if (this.pending_close)
    this.close();
};

exports.Zlib = Zlib;

}).call(this,require('_process'),require("buffer").Buffer)

},{"_process":68,"buffer":20,"pako/lib/zlib/constants":8,"pako/lib/zlib/deflate.js":10,"pako/lib/zlib/inflate.js":12,"pako/lib/zlib/messages":14,"pako/lib/zlib/zstream":16}],18:[function(require,module,exports){
(function (process,Buffer){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var Transform = require('_stream_transform');

var binding = require('./binding');
var util = require('util');
var assert = require('assert').ok;

// zlib doesn't provide these, so kludge them in following the same
// const naming scheme zlib uses.
binding.Z_MIN_WINDOWBITS = 8;
binding.Z_MAX_WINDOWBITS = 15;
binding.Z_DEFAULT_WINDOWBITS = 15;

// fewer than 64 bytes per chunk is stupid.
// technically it could work with as few as 8, but even 64 bytes
// is absurdly low.  Usually a MB or more is best.
binding.Z_MIN_CHUNK = 64;
binding.Z_MAX_CHUNK = Infinity;
binding.Z_DEFAULT_CHUNK = (16 * 1024);

binding.Z_MIN_MEMLEVEL = 1;
binding.Z_MAX_MEMLEVEL = 9;
binding.Z_DEFAULT_MEMLEVEL = 8;

binding.Z_MIN_LEVEL = -1;
binding.Z_MAX_LEVEL = 9;
binding.Z_DEFAULT_LEVEL = binding.Z_DEFAULT_COMPRESSION;

// expose all the zlib constants
Object.keys(binding).forEach(function(k) {
  if (k.match(/^Z/)) exports[k] = binding[k];
});

// translation table for return codes.
exports.codes = {
  Z_OK: binding.Z_OK,
  Z_STREAM_END: binding.Z_STREAM_END,
  Z_NEED_DICT: binding.Z_NEED_DICT,
  Z_ERRNO: binding.Z_ERRNO,
  Z_STREAM_ERROR: binding.Z_STREAM_ERROR,
  Z_DATA_ERROR: binding.Z_DATA_ERROR,
  Z_MEM_ERROR: binding.Z_MEM_ERROR,
  Z_BUF_ERROR: binding.Z_BUF_ERROR,
  Z_VERSION_ERROR: binding.Z_VERSION_ERROR
};

Object.keys(exports.codes).forEach(function(k) {
  exports.codes[exports.codes[k]] = k;
});

exports.Deflate = Deflate;
exports.Inflate = Inflate;
exports.Gzip = Gzip;
exports.Gunzip = Gunzip;
exports.DeflateRaw = DeflateRaw;
exports.InflateRaw = InflateRaw;
exports.Unzip = Unzip;

exports.createDeflate = function(o) {
  return new Deflate(o);
};

exports.createInflate = function(o) {
  return new Inflate(o);
};

exports.createDeflateRaw = function(o) {
  return new DeflateRaw(o);
};

exports.createInflateRaw = function(o) {
  return new InflateRaw(o);
};

exports.createGzip = function(o) {
  return new Gzip(o);
};

exports.createGunzip = function(o) {
  return new Gunzip(o);
};

exports.createUnzip = function(o) {
  return new Unzip(o);
};


// Convenience methods.
// compress/decompress a string or buffer in one step.
exports.deflate = function(buffer, opts, callback) {
  if (typeof opts === 'function') {
    callback = opts;
    opts = {};
  }
  return zlibBuffer(new Deflate(opts), buffer, callback);
};

exports.deflateSync = function(buffer, opts) {
  return zlibBufferSync(new Deflate(opts), buffer);
};

exports.gzip = function(buffer, opts, callback) {
  if (typeof opts === 'function') {
    callback = opts;
    opts = {};
  }
  return zlibBuffer(new Gzip(opts), buffer, callback);
};

exports.gzipSync = function(buffer, opts) {
  return zlibBufferSync(new Gzip(opts), buffer);
};

exports.deflateRaw = function(buffer, opts, callback) {
  if (typeof opts === 'function') {
    callback = opts;
    opts = {};
  }
  return zlibBuffer(new DeflateRaw(opts), buffer, callback);
};

exports.deflateRawSync = function(buffer, opts) {
  return zlibBufferSync(new DeflateRaw(opts), buffer);
};

exports.unzip = function(buffer, opts, callback) {
  if (typeof opts === 'function') {
    callback = opts;
    opts = {};
  }
  return zlibBuffer(new Unzip(opts), buffer, callback);
};

exports.unzipSync = function(buffer, opts) {
  return zlibBufferSync(new Unzip(opts), buffer);
};

exports.inflate = function(buffer, opts, callback) {
  if (typeof opts === 'function') {
    callback = opts;
    opts = {};
  }
  return zlibBuffer(new Inflate(opts), buffer, callback);
};

exports.inflateSync = function(buffer, opts) {
  return zlibBufferSync(new Inflate(opts), buffer);
};

exports.gunzip = function(buffer, opts, callback) {
  if (typeof opts === 'function') {
    callback = opts;
    opts = {};
  }
  return zlibBuffer(new Gunzip(opts), buffer, callback);
};

exports.gunzipSync = function(buffer, opts) {
  return zlibBufferSync(new Gunzip(opts), buffer);
};

exports.inflateRaw = function(buffer, opts, callback) {
  if (typeof opts === 'function') {
    callback = opts;
    opts = {};
  }
  return zlibBuffer(new InflateRaw(opts), buffer, callback);
};

exports.inflateRawSync = function(buffer, opts) {
  return zlibBufferSync(new InflateRaw(opts), buffer);
};

function zlibBuffer(engine, buffer, callback) {
  var buffers = [];
  var nread = 0;

  engine.on('error', onError);
  engine.on('end', onEnd);

  engine.end(buffer);
  flow();

  function flow() {
    var chunk;
    while (null !== (chunk = engine.read())) {
      buffers.push(chunk);
      nread += chunk.length;
    }
    engine.once('readable', flow);
  }

  function onError(err) {
    engine.removeListener('end', onEnd);
    engine.removeListener('readable', flow);
    callback(err);
  }

  function onEnd() {
    var buf = Buffer.concat(buffers, nread);
    buffers = [];
    callback(null, buf);
    engine.close();
  }
}

function zlibBufferSync(engine, buffer) {
  if (typeof buffer === 'string')
    buffer = new Buffer(buffer);
  if (!Buffer.isBuffer(buffer))
    throw new TypeError('Not a string or buffer');

  var flushFlag = binding.Z_FINISH;

  return engine._processChunk(buffer, flushFlag);
}

// generic zlib
// minimal 2-byte header
function Deflate(opts) {
  if (!(this instanceof Deflate)) return new Deflate(opts);
  Zlib.call(this, opts, binding.DEFLATE);
}

function Inflate(opts) {
  if (!(this instanceof Inflate)) return new Inflate(opts);
  Zlib.call(this, opts, binding.INFLATE);
}



// gzip - bigger header, same deflate compression
function Gzip(opts) {
  if (!(this instanceof Gzip)) return new Gzip(opts);
  Zlib.call(this, opts, binding.GZIP);
}

function Gunzip(opts) {
  if (!(this instanceof Gunzip)) return new Gunzip(opts);
  Zlib.call(this, opts, binding.GUNZIP);
}



// raw - no header
function DeflateRaw(opts) {
  if (!(this instanceof DeflateRaw)) return new DeflateRaw(opts);
  Zlib.call(this, opts, binding.DEFLATERAW);
}

function InflateRaw(opts) {
  if (!(this instanceof InflateRaw)) return new InflateRaw(opts);
  Zlib.call(this, opts, binding.INFLATERAW);
}


// auto-detect header.
function Unzip(opts) {
  if (!(this instanceof Unzip)) return new Unzip(opts);
  Zlib.call(this, opts, binding.UNZIP);
}


// the Zlib class they all inherit from
// This thing manages the queue of requests, and returns
// true or false if there is anything in the queue when
// you call the .write() method.

function Zlib(opts, mode) {
  this._opts = opts = opts || {};
  this._chunkSize = opts.chunkSize || exports.Z_DEFAULT_CHUNK;

  Transform.call(this, opts);

  if (opts.flush) {
    if (opts.flush !== binding.Z_NO_FLUSH &&
        opts.flush !== binding.Z_PARTIAL_FLUSH &&
        opts.flush !== binding.Z_SYNC_FLUSH &&
        opts.flush !== binding.Z_FULL_FLUSH &&
        opts.flush !== binding.Z_FINISH &&
        opts.flush !== binding.Z_BLOCK) {
      throw new Error('Invalid flush flag: ' + opts.flush);
    }
  }
  this._flushFlag = opts.flush || binding.Z_NO_FLUSH;

  if (opts.chunkSize) {
    if (opts.chunkSize < exports.Z_MIN_CHUNK ||
        opts.chunkSize > exports.Z_MAX_CHUNK) {
      throw new Error('Invalid chunk size: ' + opts.chunkSize);
    }
  }

  if (opts.windowBits) {
    if (opts.windowBits < exports.Z_MIN_WINDOWBITS ||
        opts.windowBits > exports.Z_MAX_WINDOWBITS) {
      throw new Error('Invalid windowBits: ' + opts.windowBits);
    }
  }

  if (opts.level) {
    if (opts.level < exports.Z_MIN_LEVEL ||
        opts.level > exports.Z_MAX_LEVEL) {
      throw new Error('Invalid compression level: ' + opts.level);
    }
  }

  if (opts.memLevel) {
    if (opts.memLevel < exports.Z_MIN_MEMLEVEL ||
        opts.memLevel > exports.Z_MAX_MEMLEVEL) {
      throw new Error('Invalid memLevel: ' + opts.memLevel);
    }
  }

  if (opts.strategy) {
    if (opts.strategy != exports.Z_FILTERED &&
        opts.strategy != exports.Z_HUFFMAN_ONLY &&
        opts.strategy != exports.Z_RLE &&
        opts.strategy != exports.Z_FIXED &&
        opts.strategy != exports.Z_DEFAULT_STRATEGY) {
      throw new Error('Invalid strategy: ' + opts.strategy);
    }
  }

  if (opts.dictionary) {
    if (!Buffer.isBuffer(opts.dictionary)) {
      throw new Error('Invalid dictionary: it should be a Buffer instance');
    }
  }

  this._binding = new binding.Zlib(mode);

  var self = this;
  this._hadError = false;
  this._binding.onerror = function(message, errno) {
    // there is no way to cleanly recover.
    // continuing only obscures problems.
    self._binding = null;
    self._hadError = true;

    var error = new Error(message);
    error.errno = errno;
    error.code = exports.codes[errno];
    self.emit('error', error);
  };

  var level = exports.Z_DEFAULT_COMPRESSION;
  if (typeof opts.level === 'number') level = opts.level;

  var strategy = exports.Z_DEFAULT_STRATEGY;
  if (typeof opts.strategy === 'number') strategy = opts.strategy;

  this._binding.init(opts.windowBits || exports.Z_DEFAULT_WINDOWBITS,
                     level,
                     opts.memLevel || exports.Z_DEFAULT_MEMLEVEL,
                     strategy,
                     opts.dictionary);

  this._buffer = new Buffer(this._chunkSize);
  this._offset = 0;
  this._closed = false;
  this._level = level;
  this._strategy = strategy;

  this.once('end', this.close);
}

util.inherits(Zlib, Transform);

Zlib.prototype.params = function(level, strategy, callback) {
  if (level < exports.Z_MIN_LEVEL ||
      level > exports.Z_MAX_LEVEL) {
    throw new RangeError('Invalid compression level: ' + level);
  }
  if (strategy != exports.Z_FILTERED &&
      strategy != exports.Z_HUFFMAN_ONLY &&
      strategy != exports.Z_RLE &&
      strategy != exports.Z_FIXED &&
      strategy != exports.Z_DEFAULT_STRATEGY) {
    throw new TypeError('Invalid strategy: ' + strategy);
  }

  if (this._level !== level || this._strategy !== strategy) {
    var self = this;
    this.flush(binding.Z_SYNC_FLUSH, function() {
      self._binding.params(level, strategy);
      if (!self._hadError) {
        self._level = level;
        self._strategy = strategy;
        if (callback) callback();
      }
    });
  } else {
    process.nextTick(callback);
  }
};

Zlib.prototype.reset = function() {
  return this._binding.reset();
};

// This is the _flush function called by the transform class,
// internally, when the last chunk has been written.
Zlib.prototype._flush = function(callback) {
  this._transform(new Buffer(0), '', callback);
};

Zlib.prototype.flush = function(kind, callback) {
  var ws = this._writableState;

  if (typeof kind === 'function' || (kind === void 0 && !callback)) {
    callback = kind;
    kind = binding.Z_FULL_FLUSH;
  }

  if (ws.ended) {
    if (callback)
      process.nextTick(callback);
  } else if (ws.ending) {
    if (callback)
      this.once('end', callback);
  } else if (ws.needDrain) {
    var self = this;
    this.once('drain', function() {
      self.flush(callback);
    });
  } else {
    this._flushFlag = kind;
    this.write(new Buffer(0), '', callback);
  }
};

Zlib.prototype.close = function(callback) {
  if (callback)
    process.nextTick(callback);

  if (this._closed)
    return;

  this._closed = true;

  this._binding.close();

  var self = this;
  process.nextTick(function() {
    self.emit('close');
  });
};

Zlib.prototype._transform = function(chunk, encoding, cb) {
  var flushFlag;
  var ws = this._writableState;
  var ending = ws.ending || ws.ended;
  var last = ending && (!chunk || ws.length === chunk.length);

  if (!chunk === null && !Buffer.isBuffer(chunk))
    return cb(new Error('invalid input'));

  // If it's the last chunk, or a final flush, we use the Z_FINISH flush flag.
  // If it's explicitly flushing at some other time, then we use
  // Z_FULL_FLUSH. Otherwise, use Z_NO_FLUSH for maximum compression
  // goodness.
  if (last)
    flushFlag = binding.Z_FINISH;
  else {
    flushFlag = this._flushFlag;
    // once we've flushed the last of the queue, stop flushing and
    // go back to the normal behavior.
    if (chunk.length >= ws.length) {
      this._flushFlag = this._opts.flush || binding.Z_NO_FLUSH;
    }
  }

  var self = this;
  this._processChunk(chunk, flushFlag, cb);
};

Zlib.prototype._processChunk = function(chunk, flushFlag, cb) {
  var availInBefore = chunk && chunk.length;
  var availOutBefore = this._chunkSize - this._offset;
  var inOff = 0;

  var self = this;

  var async = typeof cb === 'function';

  if (!async) {
    var buffers = [];
    var nread = 0;

    var error;
    this.on('error', function(er) {
      error = er;
    });

    do {
      var res = this._binding.writeSync(flushFlag,
                                        chunk, // in
                                        inOff, // in_off
                                        availInBefore, // in_len
                                        this._buffer, // out
                                        this._offset, //out_off
                                        availOutBefore); // out_len
    } while (!this._hadError && callback(res[0], res[1]));

    if (this._hadError) {
      throw error;
    }

    var buf = Buffer.concat(buffers, nread);
    this.close();

    return buf;
  }

  var req = this._binding.write(flushFlag,
                                chunk, // in
                                inOff, // in_off
                                availInBefore, // in_len
                                this._buffer, // out
                                this._offset, //out_off
                                availOutBefore); // out_len

  req.buffer = chunk;
  req.callback = callback;

  function callback(availInAfter, availOutAfter) {
    if (self._hadError)
      return;

    var have = availOutBefore - availOutAfter;
    assert(have >= 0, 'have should not go down');

    if (have > 0) {
      var out = self._buffer.slice(self._offset, self._offset + have);
      self._offset += have;
      // serve some output to the consumer.
      if (async) {
        self.push(out);
      } else {
        buffers.push(out);
        nread += out.length;
      }
    }

    // exhausted the output buffer, or used all the input create a new one.
    if (availOutAfter === 0 || self._offset >= self._chunkSize) {
      availOutBefore = self._chunkSize;
      self._offset = 0;
      self._buffer = new Buffer(self._chunkSize);
    }

    if (availOutAfter === 0) {
      // Not actually done.  Need to reprocess.
      // Also, update the availInBefore to the availInAfter value,
      // so that if we have to hit it a third (fourth, etc.) time,
      // it'll have the correct byte counts.
      inOff += (availInBefore - availInAfter);
      availInBefore = availInAfter;

      if (!async)
        return true;

      var newReq = self._binding.write(flushFlag,
                                       chunk,
                                       inOff,
                                       availInBefore,
                                       self._buffer,
                                       self._offset,
                                       self._chunkSize);
      newReq.callback = callback; // this same function
      newReq.buffer = chunk;
      return;
    }

    if (!async)
      return false;

    // finished with the chunk.
    cb();
  }
};

util.inherits(Deflate, Zlib);
util.inherits(Inflate, Zlib);
util.inherits(Gzip, Zlib);
util.inherits(Gunzip, Zlib);
util.inherits(DeflateRaw, Zlib);
util.inherits(InflateRaw, Zlib);
util.inherits(Unzip, Zlib);

}).call(this,require('_process'),require("buffer").Buffer)

},{"./binding":17,"_process":68,"_stream_transform":79,"assert":3,"buffer":20,"util":86}],19:[function(require,module,exports){
(function (global){
'use strict';

var buffer = require('buffer');
var Buffer = buffer.Buffer;
var SlowBuffer = buffer.SlowBuffer;
var MAX_LEN = buffer.kMaxLength || 2147483647;
exports.alloc = function alloc(size, fill, encoding) {
  if (typeof Buffer.alloc === 'function') {
    return Buffer.alloc(size, fill, encoding);
  }
  if (typeof encoding === 'number') {
    throw new TypeError('encoding must not be number');
  }
  if (typeof size !== 'number') {
    throw new TypeError('size must be a number');
  }
  if (size > MAX_LEN) {
    throw new RangeError('size is too large');
  }
  var enc = encoding;
  var _fill = fill;
  if (_fill === undefined) {
    enc = undefined;
    _fill = 0;
  }
  var buf = new Buffer(size);
  if (typeof _fill === 'string') {
    var fillBuf = new Buffer(_fill, enc);
    var flen = fillBuf.length;
    var i = -1;
    while (++i < size) {
      buf[i] = fillBuf[i % flen];
    }
  } else {
    buf.fill(_fill);
  }
  return buf;
}
exports.allocUnsafe = function allocUnsafe(size) {
  if (typeof Buffer.allocUnsafe === 'function') {
    return Buffer.allocUnsafe(size);
  }
  if (typeof size !== 'number') {
    throw new TypeError('size must be a number');
  }
  if (size > MAX_LEN) {
    throw new RangeError('size is too large');
  }
  return new Buffer(size);
}
exports.from = function from(value, encodingOrOffset, length) {
  if (typeof Buffer.from === 'function' && (!global.Uint8Array || Uint8Array.from !== Buffer.from)) {
    return Buffer.from(value, encodingOrOffset, length);
  }
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number');
  }
  if (typeof value === 'string') {
    return new Buffer(value, encodingOrOffset);
  }
  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    var offset = encodingOrOffset;
    if (arguments.length === 1) {
      return new Buffer(value);
    }
    if (typeof offset === 'undefined') {
      offset = 0;
    }
    var len = length;
    if (typeof len === 'undefined') {
      len = value.byteLength - offset;
    }
    if (offset >= value.byteLength) {
      throw new RangeError('\'offset\' is out of bounds');
    }
    if (len > value.byteLength - offset) {
      throw new RangeError('\'length\' is out of bounds');
    }
    return new Buffer(value.slice(offset, offset + len));
  }
  if (Buffer.isBuffer(value)) {
    var out = new Buffer(value.length);
    value.copy(out, 0, 0, value.length);
    return out;
  }
  if (value) {
    if (Array.isArray(value) || (typeof ArrayBuffer !== 'undefined' && value.buffer instanceof ArrayBuffer) || 'length' in value) {
      return new Buffer(value);
    }
    if (value.type === 'Buffer' && Array.isArray(value.data)) {
      return new Buffer(value.data);
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ' + 'ArrayBuffer, Array, or array-like object.');
}
exports.allocUnsafeSlow = function allocUnsafeSlow(size) {
  if (typeof Buffer.allocUnsafeSlow === 'function') {
    return Buffer.allocUnsafeSlow(size);
  }
  if (typeof size !== 'number') {
    throw new TypeError('size must be a number');
  }
  if (size >= MAX_LEN) {
    throw new RangeError('size is too large');
  }
  return new SlowBuffer(size);
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"buffer":20}],20:[function(require,module,exports){
(function (global){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')
var isArray = require('isarray')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength()

function typedArraySupport () {
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length)
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length)
    }
    that.length = length
  }

  return that
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(this, arg)
  }
  return from(this, arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype
  return arr
}

function from (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length)
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    })
  }
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (that, size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding)
}

function allocUnsafe (that, size) {
  assertSize(size)
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size)
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  that = createBuffer(that, length)

  var actual = that.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual)
  }

  return that
}

function fromArrayLike (that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  that = createBuffer(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array, byteOffset, length) {
  array.byteLength // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array)
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset)
  } else {
    array = new Uint8Array(array, byteOffset, length)
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array)
  }
  return that
}

function fromObject (that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    that = createBuffer(that, len)

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len)
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end)
    newBuf.__proto__ = Buffer.prototype
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start]
    }
  }

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : utf8ToBytes(new Buffer(val, encoding).toString())
    var len = bytes.length
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"base64-js":4,"ieee754":27,"isarray":21}],21:[function(require,module,exports){
var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

},{}],22:[function(require,module,exports){
'use strict';

// VARIABLES //

var FLOAT32_VIEW = new Float32Array( 1 );
var UINT32_VIEW = new Uint32Array( FLOAT32_VIEW.buffer );

// 1 11111111 00000000000000000000000 => 4286578688 => 0xff800000 (see IEEE 754-2008)
var NINF = 0xff800000;

// Set the ArrayBuffer bit sequence:
UINT32_VIEW[ 0 ] = NINF;


// EXPORTS //

module.exports = FLOAT32_VIEW[ 0 ];

},{}],23:[function(require,module,exports){
'use strict';

// VARIABLES //

var FLOAT32_VIEW = new Float32Array( 1 );
var UINT32_VIEW = new Uint32Array( FLOAT32_VIEW.buffer );

// 0 11111111 00000000000000000000000 => 2139095040 => 0x7f800000 (see IEEE 754-2008)
var PINF = 0x7f800000;

// Set the ArrayBuffer bit sequence:
UINT32_VIEW[ 0 ] = PINF;


// EXPORTS //

module.exports = FLOAT32_VIEW[ 0 ];

},{}],24:[function(require,module,exports){
(function (Buffer){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.

function isArray(arg) {
  if (Array.isArray) {
    return Array.isArray(arg);
  }
  return objectToString(arg) === '[object Array]';
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = Buffer.isBuffer;

function objectToString(o) {
  return Object.prototype.toString.call(o);
}

}).call(this,{"isBuffer":require("../../is-buffer/index.js")})

},{"../../is-buffer/index.js":29}],25:[function(require,module,exports){
(function (Buffer){
/*! dicom-parser - v1.7.3 - 2016-08-18 | (c) 2014 Chris Hafey | https://github.com/chafey/dicomParser */
(function (root, factory) {

    // node.js
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = factory();
    }
    else if (typeof define === 'function' && define.amd) {
        // AMD. Register as an anonymous module.
        define([], factory);
    } else {
        // Browser globals
        if(typeof cornerstone === 'undefined'){
            dicomParser = {};

            // meteor
            if (typeof Package !== 'undefined') {
                root.dicomParser = dicomParser;
            }
        }
        dicomParser = factory();
    }
}(this, function () {

/**
 * Parses a DICOM P10 byte array and returns a DataSet object with the parsed elements.  If the options
 * argument is supplied and it contains the untilTag property, parsing will stop once that
 * tag is encoutered.  This can be used to parse partial byte streams.
 *
 * @param byteArray the byte array
 * @param options object to control parsing behavior (optional)
 * @returns {DataSet}
 * @throws error if an error occurs while parsing.  The exception object will contain a property dataSet with the
 *         elements successfully parsed before the error.
 */
var dicomParser = (function(dicomParser) {
    if(dicomParser === undefined)
    {
        dicomParser = {};
    }

    dicomParser.parseDicom = function(byteArray, options) {

        if(byteArray === undefined)
        {
            throw "dicomParser.parseDicom: missing required parameter 'byteArray'";
        }

        function readTransferSyntax(metaHeaderDataSet) {
            if(metaHeaderDataSet.elements.x00020010 === undefined) {
                throw 'dicomParser.parseDicom: missing required meta header attribute 0002,0010';
            }
            var transferSyntaxElement = metaHeaderDataSet.elements.x00020010;
            return dicomParser.readFixedString(byteArray, transferSyntaxElement.dataOffset, transferSyntaxElement.length);
        }

        function isExplicit(transferSyntax) {
            if(transferSyntax === '1.2.840.10008.1.2') // implicit little endian
            {
                return false;
            }
            // all other transfer syntaxes should be explicit
            return true;
        }

        function getDataSetByteStream(transferSyntax, position) {
            if(transferSyntax === '1.2.840.10008.1.2.1.99')
            {
                // if an infalter callback is registered, use it
                if (options && options.inflater) {
                    var fullByteArrayCallback = options.inflater(byteArray, position);
                    return new dicomParser.ByteStream(dicomParser.littleEndianByteArrayParser, fullByteArrayCallback, 0);
                }
                // if running on node, use the zlib library to inflate
                // http://stackoverflow.com/questions/4224606/how-to-check-whether-a-script-is-running-under-node-js
                else if (typeof module !== 'undefined' && this.module !== module) {
                    // inflate it
                    var zlib = require('zlib');
                    var deflatedBuffer = dicomParser.sharedCopy(byteArray, position, byteArray.length - position);
                    var inflatedBuffer = zlib.inflateRawSync(deflatedBuffer);

                    // create a single byte array with the full header bytes and the inflated bytes
                    var fullByteArrayBuffer = dicomParser.alloc(byteArray, inflatedBuffer.length + position);
                    byteArray.copy(fullByteArrayBuffer, 0, 0, position);
                    inflatedBuffer.copy(fullByteArrayBuffer, position);
                    return new dicomParser.ByteStream(dicomParser.littleEndianByteArrayParser, fullByteArrayBuffer, 0);
                }
                // if pako is defined - use it.  This is the web browser path
                // https://github.com/nodeca/pako
                else if(typeof pako !== "undefined") {
                    // inflate it
                    var deflated = byteArray.slice(position);
                    var inflated = pako.inflateRaw(deflated);

                    // create a single byte array with the full header bytes and the inflated bytes
                    var fullByteArray = dicomParser.alloc(byteArray, inflated.length + position);
                    fullByteArray.set(byteArray.slice(0, position), 0);
                    fullByteArray.set(inflated, position);
                    return new dicomParser.ByteStream(dicomParser.littleEndianByteArrayParser, fullByteArray, 0);
                }
                // throw exception since no inflater is available
                else {
                    throw 'dicomParser.parseDicom: no inflater available to handle deflate transfer syntax';
                }
            }
            if(transferSyntax === '1.2.840.10008.1.2.2') // explicit big endian
            {
                return new dicomParser.ByteStream(dicomParser.bigEndianByteArrayParser, byteArray, position);
            }
            else
            {
                // all other transfer syntaxes are little endian; only the pixel encoding differs
                // make a new stream so the metaheader warnings don't come along for the ride
                return new dicomParser.ByteStream(dicomParser.littleEndianByteArrayParser, byteArray, position);
            }
        }

        function mergeDataSets(metaHeaderDataSet, instanceDataSet)
        {
            for (var propertyName in metaHeaderDataSet.elements)
            {
                if(metaHeaderDataSet.elements.hasOwnProperty(propertyName))
                {
                    instanceDataSet.elements[propertyName] = metaHeaderDataSet.elements[propertyName];
                }
            }
            if (metaHeaderDataSet.warnings !== undefined) {
                instanceDataSet.warnings = metaHeaderDataSet.warnings.concat(instanceDataSet.warnings);
            }
            return instanceDataSet;
        }

        function readDataSet(metaHeaderDataSet)
        {
            var transferSyntax = readTransferSyntax(metaHeaderDataSet);
            var explicit = isExplicit(transferSyntax);
            var dataSetByteStream = getDataSetByteStream(transferSyntax, metaHeaderDataSet.position);

            var elements = {};
            var dataSet = new dicomParser.DataSet(dataSetByteStream.byteArrayParser, dataSetByteStream.byteArray, elements);
            dataSet.warnings = dataSetByteStream.warnings;

            try{
                if(explicit) {
                    dicomParser.parseDicomDataSetExplicit(dataSet, dataSetByteStream, dataSetByteStream.byteArray.length, options);
                }
                else
                {
                    dicomParser.parseDicomDataSetImplicit(dataSet, dataSetByteStream, dataSetByteStream.byteArray.length, options);
                }
            }
            catch(e) {
                var ex = {
                    exception: e,
                    dataSet: dataSet
                };
                throw ex;
            }
            return dataSet;
        }

        // main function here
        function parseTheByteStream() {
            var metaHeaderDataSet = dicomParser.readPart10Header(byteArray, options);

            var dataSet = readDataSet(metaHeaderDataSet);

            return mergeDataSets(metaHeaderDataSet, dataSet);
        }

        // This is where we actually start parsing
        return parseTheByteStream();
    };

    return dicomParser;
})(dicomParser);

/**
 * Utility function for creating a basic offset table for JPEG transfer syntaxes
 */

var dicomParser = (function (dicomParser)
{
  "use strict";

  if(dicomParser === undefined)
  {
    dicomParser = {};
  }

  // Each JPEG image has an end of image marker 0xFFD9
  function isEndOfImageMarker(dataSet, position) {
    return (dataSet.byteArray[position] === 0xFF &&
    dataSet.byteArray[position + 1] === 0xD9);
  }

  function isFragmentEndOfImage(dataSet, pixelDataElement, fragmentIndex) {
    var fragment = pixelDataElement.fragments[fragmentIndex];
    // Need to check the last two bytes and the last three bytes for marker since odd length
    // fragments are zero padded
    if(isEndOfImageMarker(dataSet, fragment.position + fragment.length - 2) ||
      isEndOfImageMarker(dataSet, fragment.position + fragment.length - 3)) {
      return true;
    }
    return false;
  }

  function findLastImageFrameFragmentIndex(dataSet, pixelDataElement, startFragment) {
    for(var fragmentIndex=startFragment; fragmentIndex < pixelDataElement.fragments.length; fragmentIndex++) {
      if(isFragmentEndOfImage(dataSet, pixelDataElement, fragmentIndex)) {
        return fragmentIndex;
      }
    }
  }

  /**
   * Creates a basic offset table by scanning fragments for JPEG start of image and end Of Image markers
   * @param {object} dataSet - the parsed dicom dataset
   * @param {object} pixelDataElement - the pixel data element
   * @param [fragments] - optional array of objects describing each fragment (offset, position, length)
   * @returns {Array} basic offset table (array of offsets to beginning of each frame)
   */
  dicomParser.createJPEGBasicOffsetTable = function(dataSet, pixelDataElement, fragments) {
    // Validate parameters
    if(dataSet === undefined) {
      throw 'dicomParser.createJPEGBasicOffsetTable: missing required parameter dataSet';
    }
    if(pixelDataElement === undefined) {
      throw 'dicomParser.createJPEGBasicOffsetTable: missing required parameter pixelDataElement';
    }
    if(pixelDataElement.tag !== 'x7fe00010') {
      throw "dicomParser.createJPEGBasicOffsetTable: parameter 'pixelDataElement' refers to non pixel data tag (expected tag = x7fe00010'";
    }
    if(pixelDataElement.encapsulatedPixelData !== true) {
      throw "dicomParser.createJPEGBasicOffsetTable: parameter 'pixelDataElement' refers to pixel data element that does not have encapsulated pixel data";
    }
    if(pixelDataElement.hadUndefinedLength !== true) {
      throw "dicomParser.createJPEGBasicOffsetTable: parameter 'pixelDataElement' refers to pixel data element that does not have encapsulated pixel data";
    }
    if(pixelDataElement.basicOffsetTable === undefined) {
      throw "dicomParser.createJPEGBasicOffsetTable: parameter 'pixelDataElement' refers to pixel data element that does not have encapsulated pixel data";
    }
    if(pixelDataElement.fragments === undefined) {
      throw "dicomParser.createJPEGBasicOffsetTable: parameter 'pixelDataElement' refers to pixel data element that does not have encapsulated pixel data";
    }
    if(pixelDataElement.fragments.length <= 0) {
      throw "dicomParser.createJPEGBasicOffsetTable: parameter 'pixelDataElement' refers to pixel data element that does not have encapsulated pixel data";
    }
    if(fragments && fragments.length <=0) {
      throw "dicomParser.createJPEGBasicOffsetTable: parameter 'fragments' must not be zero length";
    }

    // Default values
    fragments = fragments || pixelDataElement.fragments;

    var basicOffsetTable = [];

    var startFragmentIndex = 0;

    while(true) {
      // Add the offset for the start fragment
      basicOffsetTable.push(pixelDataElement.fragments[startFragmentIndex].offset);
      var endFragmentIndex = findLastImageFrameFragmentIndex(dataSet, pixelDataElement, startFragmentIndex);
      if(endFragmentIndex === undefined || endFragmentIndex === pixelDataElement.fragments.length -1) {
        return basicOffsetTable;
      }
      startFragmentIndex = endFragmentIndex + 1;
    }
  };

  return dicomParser;
}(dicomParser));
var dicomParser = (function (dicomParser) {
    "use strict";

    if (dicomParser === undefined) {
        dicomParser = {};
    }

    /**
     * converts an explicit dataSet to a javascript object
     * @param dataSet
     * @param options
     */
    dicomParser.explicitDataSetToJS = function (dataSet, options) {

        if(dataSet === undefined) {
            throw 'dicomParser.explicitDataSetToJS: missing required parameter dataSet';
        }

        options = options || {
            omitPrivateAttibutes: true, // true if private elements should be omitted
            maxElementLength : 128      // maximum element length to try and convert to string format
        };

        var result = {

        };

        for(var tag in dataSet.elements) {
            var element = dataSet.elements[tag];

            // skip this element if it a private element and our options specify that we should
            if(options.omitPrivateAttibutes === true && dicomParser.isPrivateTag(tag))
            {
                continue;
            }

            if(element.items) {
                // handle sequences
                var sequenceItems = [];
                for(var i=0; i < element.items.length; i++) {
                    sequenceItems.push(dicomParser.explicitDataSetToJS(element.items[i].dataSet, options));
                }
                result[tag] = sequenceItems;
            } else {
                var asString;
                asString = undefined;
                if(element.length < options.maxElementLength) {
                    asString = dicomParser.explicitElementToString(dataSet, element);
                }

                if(asString !== undefined) {
                    result[tag] = asString;
                }  else {
                    result[tag] = {
                        dataOffset: element.dataOffset,
                        length : element.length
                    };
                }
            }
        }

        return result;
    };


    return dicomParser;
}(dicomParser));
var dicomParser = (function (dicomParser) {
    "use strict";

    if (dicomParser === undefined) {
        dicomParser = {};
    }

    /**
     * Converts an explicit VR element to a string or undefined if it is not possible to convert.
     * Throws an error if an implicit element is supplied
     * @param dataSet
     * @param element
     * @returns {*}
     */
    dicomParser.explicitElementToString = function(dataSet, element)
    {
        if(dataSet === undefined || element === undefined) {
            throw 'dicomParser.explicitElementToString: missing required parameters';
        }
        if(element.vr === undefined) {
            throw 'dicomParser.explicitElementToString: cannot convert implicit element to string';
        }
        var vr = element.vr;
        var tag = element.tag;

        var textResult;

        function multiElementToString(numItems, func) {
            var result = "";
            for(var i=0; i < numItems; i++) {
                if(i !== 0) {
                    result += '/';
                }
                result += func.call(dataSet, tag, i).toString();
            }
            return result;
        }

        if(dicomParser.isStringVr(vr) === true)
        {
            textResult = dataSet.string(tag);
        }
        else if (vr == 'AT') {
            var num = dataSet.uint32(tag);
            if(num === undefined) {
                return undefined;
            }
            if (num < 0)
            {
                num = 0xFFFFFFFF + num + 1;
            }

            return 'x' + num.toString(16).toUpperCase();
        }
        else if (vr == 'US')
        {
            textResult = multiElementToString(element.length / 2, dataSet.uint16);
        }
        else if(vr === 'SS')
        {
            textResult = multiElementToString(element.length / 2, dataSet.int16);
        }
        else if (vr == 'UL')
        {
            textResult = multiElementToString(element.length / 4, dataSet.uint32);
        }
        else if(vr === 'SL')
        {
            textResult = multiElementToString(element.length / 4, dataSet.int32);
        }
        else if(vr == 'FD')
        {
            textResult = multiElementToString(element.length / 8, dataSet.double);
        }
        else if(vr == 'FL')
        {
            textResult = multiElementToString(element.length / 4, dataSet.float);
        }

        return textResult;
    };
    return dicomParser;
}(dicomParser));
/**
 * Utility functions for dealing with DICOM
 */

var dicomParser = (function (dicomParser)
{
  "use strict";

  if(dicomParser === undefined)
  {
    dicomParser = {};
  }

  // algorithm based on http://stackoverflow.com/questions/1433030/validate-number-of-days-in-a-given-month
  function daysInMonth(m, y) { // m is 0 indexed: 0-11
    switch (m) {
      case 2 :
        return (y % 4 == 0 && y % 100) || y % 400 == 0 ? 29 : 28;
      case 9 : case 4 : case 6 : case 11 :
      return 30;
      default :
        return 31
    }
  }

  function isValidDate(d, m, y) {
    // make year is a number
    if(isNaN(y)) {
      return false;
    }
    return m > 0 && m <= 12 && d > 0 && d <= daysInMonth(m, y);
  }


  /**
   * Parses a DA formatted string into a Javascript object
   * @param {string} date a string in the DA VR format
   * @param {boolean} [validate] - true if an exception should be thrown if the date is invalid
   * @returns {*} Javascript object with properties year, month and day or undefined if not present or not 8 bytes long
   */
  dicomParser.parseDA = function(date, validate)
  {
    if(date && date.length === 8)
    {
      var yyyy = parseInt(date.substring(0, 4), 10);
      var mm = parseInt(date.substring(4, 6), 10);
      var dd = parseInt(date.substring(6, 8), 10);

      if(validate) {
        if (isValidDate(dd, mm, yyyy) !== true) {
          throw "invalid DA '" + date + "'";
        }
      }
      return {
        year: yyyy,
        month: mm,
        day: dd
      };
    }
    if(validate) {
      throw "invalid DA '" + date + "'";
    }
    return undefined;
  };

  return dicomParser;
}(dicomParser));
/**
 * Utility functions for dealing with DICOM
 */

var dicomParser = (function (dicomParser)
{
  "use strict";

  if(dicomParser === undefined)
  {
    dicomParser = {};
  }

  /**
   * Parses a TM formatted string into a javascript object with properties for hours, minutes, seconds and fractionalSeconds
   * @param {string} time - a string in the TM VR format
   * @param {boolean} [validate] - true if an exception should be thrown if the date is invalid
   * @returns {*} javascript object with properties for hours, minutes, seconds and fractionalSeconds or undefined if no element or data.  Missing fields are set to undefined
   */
  dicomParser.parseTM = function(time, validate) {

    if (time.length >= 2) // must at least have HH
    {
      // 0123456789
      // HHMMSS.FFFFFF
      var hh = parseInt(time.substring(0, 2), 10);
      var mm = time.length >= 4 ? parseInt(time.substring(2, 4), 10) : undefined;
      var ss = time.length >= 6 ? parseInt(time.substring(4, 6), 10) : undefined;
      var ffffff = time.length >= 8 ? parseInt(time.substring(7, 13), 10) : undefined;

      if(validate) {
        if((isNaN(hh)) ||
          (mm !== undefined && isNaN(mm)) ||
          (ss !== undefined && isNaN(ss)) ||
          (ffffff !== undefined && isNaN(ffffff)) ||
          (hh < 0 || hh > 23) ||
          (mm && (mm <0 || mm > 59))  ||
          (ss && (ss <0 || ss > 59))  ||
          (ffffff && (ffffff <0 || ffffff > 999999)))
        {
          throw "invalid TM '" + time + "'";
        }
      }

      return {
        hours: hh,
        minutes: mm,
        seconds: ss,
        fractionalSeconds: ffffff
      };
    }

    if(validate) {
      throw "invalid TM '" + time + "'";
    }

    return undefined;
  };

  return dicomParser;
}(dicomParser));
/**
 * Utility functions for dealing with DICOM
 */

var dicomParser = (function (dicomParser)
{
    "use strict";

    if(dicomParser === undefined)
    {
        dicomParser = {};
    }

    var stringVrs = {
        AE: true,
        AS: true,
        AT: false,
        CS: true,
        DA: true,
        DS: true,
        DT: true,
        FL: false,
        FD: false,
        IS: true,
        LO: true,
        LT: true,
        OB: false,
        OD: false,
        OF: false,
        OW: false,
        PN: true,
        SH: true,
        SL: false,
        SQ: false,
        SS: false,
        ST: true,
        TM: true,
        UI: true,
        UL: false,
        UN: undefined, // dunno
        UR: true,
        US: false,
        UT: true
    };

    /**
     * Tests to see if vr is a string or not.
     * @param vr
     * @returns true if string, false it not string, undefined if unknown vr or UN type
     */
    dicomParser.isStringVr = function(vr)
    {
        return stringVrs[vr];
    };

    /**
     * Tests to see if a given tag in the format xggggeeee is a private tag or not
     * @param tag
     * @returns {boolean}
     */
    dicomParser.isPrivateTag = function(tag)
    {
        var lastGroupDigit = parseInt(tag[4]);
        var groupIsOdd = (lastGroupDigit % 2) === 1;
        return groupIsOdd;
    };

    /**
     * Parses a PN formatted string into a javascript object with properties for givenName, familyName, middleName, prefix and suffix
     * @param personName a string in the PN VR format
     * @param index
     * @returns {*} javascript object with properties for givenName, familyName, middleName, prefix and suffix or undefined if no element or data
     */
    dicomParser.parsePN = function(personName) {
        if(personName === undefined) {
            return undefined;
        }
        var stringValues = personName.split('^');
        return {
            familyName: stringValues[0],
            givenName: stringValues[1],
            middleName: stringValues[2],
            prefix: stringValues[3],
            suffix: stringValues[4]
        };
    };



    return dicomParser;
}(dicomParser));
/**
 * Functionality for extracting encapsulated pixel data
 */

var dicomParser = (function (dicomParser)
{
    "use strict";

    if(dicomParser === undefined)
    {
        dicomParser = {};
    }

    var deprecatedNoticeLogged = false;

    /**
     * Returns the pixel data for the specified frame in an encapsulated pixel data element.  If no basic offset
     * table is present, it assumes that all fragments are for one frame.  Note that this assumption/logic is not
     * valid for multi-frame instances so this function has been deprecated and will eventually be removed.  Code
     * should be updated to use readEncapsulatedPixelDataFromFragments() or readEncapsulatedImageFrame()
     *
     * @deprecated since version 1.6 - use readEncapsulatedPixelDataFromFragments() or readEncapsulatedImageFrame()
     * @param dataSet - the dataSet containing the encapsulated pixel data
     * @param pixelDataElement - the pixel data element (x7fe00010) to extract the frame from
     * @param frame - the zero based frame index
     * @returns {object} with the encapsulated pixel data
     */


    dicomParser.readEncapsulatedPixelData = function(dataSet, pixelDataElement, frame)
    {
        if(!deprecatedNoticeLogged) {
            deprecatedNoticeLogged = true;
            if(console && console.log) {
                console.log("WARNING: dicomParser.readEncapsulatedPixelData() has been deprecated");
            }
        }

        if(dataSet === undefined) {
            throw "dicomParser.readEncapsulatedPixelData: missing required parameter 'dataSet'";
        }
        if(pixelDataElement === undefined) {
            throw "dicomParser.readEncapsulatedPixelData: missing required parameter 'element'";
        }
        if(frame === undefined) {
            throw "dicomParser.readEncapsulatedPixelData: missing required parameter 'frame'";
        }
        if(pixelDataElement.tag !== 'x7fe00010') {
            throw "dicomParser.readEncapsulatedPixelData: parameter 'element' refers to non pixel data tag (expected tag = x7fe00010'";
        }
        if(pixelDataElement.encapsulatedPixelData !== true) {
            throw "dicomParser.readEncapsulatedPixelData: parameter 'element' refers to pixel data element that does not have encapsulated pixel data";
        }
        if(pixelDataElement.hadUndefinedLength !== true) {
            throw "dicomParser.readEncapsulatedPixelData: parameter 'element' refers to pixel data element that does not have encapsulated pixel data";
        }
        if(pixelDataElement.basicOffsetTable === undefined) {
            throw "dicomParser.readEncapsulatedPixelData: parameter 'element' refers to pixel data element that does not have encapsulated pixel data";
        }
        if(pixelDataElement.fragments === undefined) {
            throw "dicomParser.readEncapsulatedPixelData: parameter 'element' refers to pixel data element that does not have encapsulated pixel data";
        }
        if(frame < 0) {
            throw "dicomParser.readEncapsulatedPixelData: parameter 'frame' must be >= 0";
        }

        // If the basic offset table is not empty, we can extract the frame
        if(pixelDataElement.basicOffsetTable.length !== 0)
        {
            return dicomParser.readEncapsulatedImageFrame(dataSet, pixelDataElement, frame);
        }
        else
        {
            // No basic offset table, assume all fragments are for one frame - NOTE that this is NOT a valid
            // assumption but is the original behavior so we are keeping it for now
            return dicomParser.readEncapsulatedPixelDataFromFragments(dataSet, pixelDataElement, 0, pixelDataElement.fragments.length);
        }
    };

    return dicomParser;
}(dicomParser));

/**
 *
 * Internal helper function to allocate new byteArray buffers
 */
var dicomParser = (function (dicomParser)
{
  "use strict";

  if(dicomParser === undefined)
  {
    dicomParser = {};
  }

  /**
   * Creates a new byteArray of the same type (Uint8Array or Buffer) of the specified length.
   * @param byteArray the underlying byteArray (either Uint8Array or Buffer)
   * @param length number of bytes of the Byte Array
   * @returns {object} Uint8Array or Buffer depending on the type of byteArray
   */
  dicomParser.alloc = function(byteArray, length) {
    if (typeof Buffer !== 'undefined' && byteArray instanceof Buffer) {
      return Buffer.alloc(length);
    }
    else if(byteArray instanceof Uint8Array) {
      return new Uint8Array(length);
    } else {
      throw 'dicomParser.alloc: unknown type for byteArray';
    }
  };

  return dicomParser;
}(dicomParser));
/**
 * Internal helper functions for parsing different types from a big-endian byte array
 */

var dicomParser = (function (dicomParser)
{
    "use strict";

    if(dicomParser === undefined)
    {
        dicomParser = {};
    }

    dicomParser.bigEndianByteArrayParser = {
        /**
         *
         * Parses an unsigned int 16 from a big-endian byte array
         *
         * @param byteArray the byte array to read from
         * @param position the position in the byte array to read from
         * @returns {*} the parsed unsigned int 16
         * @throws error if buffer overread would occur
         * @access private
         */
        readUint16: function (byteArray, position) {
            if (position < 0) {
                throw 'bigEndianByteArrayParser.readUint16: position cannot be less than 0';
            }
            if (position + 2 > byteArray.length) {
                throw 'bigEndianByteArrayParser.readUint16: attempt to read past end of buffer';
            }
            return (byteArray[position] << 8) + byteArray[position + 1];
        },

        /**
         *
         * Parses a signed int 16 from a big-endian byte array
         *
         * @param byteArray the byte array to read from
         * @param position the position in the byte array to read from
         * @returns {*} the parsed signed int 16
         * @throws error if buffer overread would occur
         * @access private
         */
        readInt16: function (byteArray, position) {
            if (position < 0) {
                throw 'bigEndianByteArrayParser.readInt16: position cannot be less than 0';
            }
            if (position + 2 > byteArray.length) {
                throw 'bigEndianByteArrayParser.readInt16: attempt to read past end of buffer';
            }
            var int16 = (byteArray[position] << 8) + byteArray[position + 1];
            // fix sign
            if (int16 & 0x8000) {
                int16 = int16 - 0xFFFF - 1;
            }
            return int16;
        },

        /**
         * Parses an unsigned int 32 from a big-endian byte array
         *
         * @param byteArray the byte array to read from
         * @param position the position in the byte array to read from
         * @returns {*} the parsed unsigned int 32
         * @throws error if buffer overread would occur
         * @access private
         */
        readUint32: function (byteArray, position) {
            if (position < 0) {
                throw 'bigEndianByteArrayParser.readUint32: position cannot be less than 0';
            }

            if (position + 4 > byteArray.length) {
                throw 'bigEndianByteArrayParser.readUint32: attempt to read past end of buffer';
            }

            var uint32 = (256 * (256 * (256 * byteArray[position] +
                                              byteArray[position + 1]) +
                                              byteArray[position + 2]) +
                                              byteArray[position + 3]);

            return uint32;
        },

        /**
         * Parses a signed int 32 from a big-endian byte array
         *
         * @param byteArray the byte array to read from
         * @param position the position in the byte array to read from
         * @returns {*} the parsed signed int 32
         * @throws error if buffer overread would occur
         * @access private
         */
        readInt32: function (byteArray, position) {
            if (position < 0) {
                throw 'bigEndianByteArrayParser.readInt32: position cannot be less than 0';
            }

            if (position + 4 > byteArray.length) {
                throw 'bigEndianByteArrayParser.readInt32: attempt to read past end of buffer';
            }

            var int32 = ((byteArray[position] << 24) +
                         (byteArray[position + 1] << 16) +
                         (byteArray[position + 2] << 8) +
                          byteArray[position + 3]);

            return int32;
        },

        /**
         * Parses 32-bit float from a big-endian byte array
         *
         * @param byteArray the byte array to read from
         * @param position the position in the byte array to read from
         * @returns {*} the parsed 32-bit float
         * @throws error if buffer overread would occur
         * @access private
         */
        readFloat: function (byteArray, position) {
            if (position < 0) {
                throw 'bigEndianByteArrayParser.readFloat: position cannot be less than 0';
            }

            if (position + 4 > byteArray.length) {
                throw 'bigEndianByteArrayParser.readFloat: attempt to read past end of buffer';
            }

            // I am sure there is a better way than this but this should be safe
            var byteArrayForParsingFloat = new Uint8Array(4);
            byteArrayForParsingFloat[3] = byteArray[position];
            byteArrayForParsingFloat[2] = byteArray[position + 1];
            byteArrayForParsingFloat[1] = byteArray[position + 2];
            byteArrayForParsingFloat[0] = byteArray[position + 3];
            var floatArray = new Float32Array(byteArrayForParsingFloat.buffer);
            return floatArray[0];
        },

        /**
         * Parses 64-bit float from a big-endian byte array
         *
         * @param byteArray the byte array to read from
         * @param position the position in the byte array to read from
         * @returns {*} the parsed 64-bit float
         * @throws error if buffer overread would occur
         * @access private
         */
        readDouble: function (byteArray, position) {
            if (position < 0) {
                throw 'bigEndianByteArrayParser.readDouble: position cannot be less than 0';
            }

            if (position + 8 > byteArray.length) {
                throw 'bigEndianByteArrayParser.readDouble: attempt to read past end of buffer';
            }

            // I am sure there is a better way than this but this should be safe
            var byteArrayForParsingFloat = new Uint8Array(8);
            byteArrayForParsingFloat[7] = byteArray[position];
            byteArrayForParsingFloat[6] = byteArray[position + 1];
            byteArrayForParsingFloat[5] = byteArray[position + 2];
            byteArrayForParsingFloat[4] = byteArray[position + 3];
            byteArrayForParsingFloat[3] = byteArray[position + 4];
            byteArrayForParsingFloat[2] = byteArray[position + 5];
            byteArrayForParsingFloat[1] = byteArray[position + 6];
            byteArrayForParsingFloat[0] = byteArray[position + 7];
            var floatArray = new Float64Array(byteArrayForParsingFloat.buffer);
            return floatArray[0];
        }
    };

    return dicomParser;
}(dicomParser));
/**
 * Internal helper functions common to parsing byte arrays of any type
 */

var dicomParser = (function (dicomParser)
{
    "use strict";

    if(dicomParser === undefined)
    {
        dicomParser = {};
    }

    /**
     * Reads a string of 8-bit characters from an array of bytes and advances
     * the position by length bytes.  A null terminator will end the string
     * but will not effect advancement of the position.  Trailing and leading
     * spaces are preserved (not trimmed)
     * @param byteArray the byteArray to read from
     * @param position the position in the byte array to read from
     * @param length the maximum number of bytes to parse
     * @returns {string} the parsed string
     * @throws error if buffer overread would occur
     * @access private
     */
    dicomParser.readFixedString = function(byteArray, position, length)
    {
        if(length < 0)
        {
            throw 'dicomParser.readFixedString - length cannot be less than 0';
        }

        if(position + length > byteArray.length) {
            throw 'dicomParser.readFixedString: attempt to read past end of buffer';
        }

        var result = "";
        var byte;
        for(var i=0; i < length; i++)
        {
            byte = byteArray[position + i];
            if(byte === 0) {
                position +=  length;
                return result;
            }
            result += String.fromCharCode(byte);
        }

        return result;
    };


    return dicomParser;
}(dicomParser));
/**
 *
 * Internal helper class to assist with parsing. Supports reading from a byte
 * stream contained in a Uint8Array.  Example usage:
 *
 *  var byteArray = new Uint8Array(32);
 *  var byteStream = new dicomParser.ByteStream(dicomParser.littleEndianByteArrayParser, byteArray);
 *
 * */
var dicomParser = (function (dicomParser)
{
    "use strict";

    if(dicomParser === undefined)
    {
        dicomParser = {};
    }

    /**
     * Constructor for ByteStream objects.
     * @param byteArrayParser a parser for parsing the byte array
     * @param byteArray a Uint8Array containing the byte stream
     * @param position (optional) the position to start reading from.  0 if not specified
     * @constructor
     * @throws will throw an error if the byteArrayParser parameter is not present
     * @throws will throw an error if the byteArray parameter is not present or invalid
     * @throws will throw an error if the position parameter is not inside the byte array
     */
    dicomParser.ByteStream = function(byteArrayParser, byteArray, position) {
        if(byteArrayParser === undefined)
        {
            throw "dicomParser.ByteStream: missing required parameter 'byteArrayParser'";
        }
        if(byteArray === undefined)
        {
            throw "dicomParser.ByteStream: missing required parameter 'byteArray'";
        }
        if((byteArray instanceof Uint8Array) === false &&
          (byteArray instanceof Buffer) === false ) {
            throw 'dicomParser.ByteStream: parameter byteArray is not of type Uint8Array or Buffer';
        }
        if(position < 0)
        {
            throw "dicomParser.ByteStream: parameter 'position' cannot be less than 0";
        }
        if(position >= byteArray.length)
        {
            throw "dicomParser.ByteStream: parameter 'position' cannot be greater than or equal to 'byteArray' length";

        }
        this.byteArrayParser = byteArrayParser;
        this.byteArray = byteArray;
        this.position = position ? position : 0;
        this.warnings = []; // array of string warnings encountered while parsing
    };

    /**
     * Safely seeks through the byte stream.  Will throw an exception if an attempt
     * is made to seek outside of the byte array.
     * @param offset the number of bytes to add to the position
     * @throws error if seek would cause position to be outside of the byteArray
     */
    dicomParser.ByteStream.prototype.seek = function(offset)
    {
        if(this.position + offset < 0)
        {
            throw "dicomParser.ByteStream.prototype.seek: cannot seek to position < 0";
        }
        this.position += offset;
    };

    /**
     * Returns a new ByteStream object from the current position and of the requested number of bytes
     * @param numBytes the length of the byte array for the ByteStream to contain
     * @returns {dicomParser.ByteStream}
     * @throws error if buffer overread would occur
     */
    dicomParser.ByteStream.prototype.readByteStream = function(numBytes)
    {
        if(this.position + numBytes > this.byteArray.length) {
            throw 'dicomParser.ByteStream.prototype.readByteStream: readByteStream - buffer overread';
        }
        var byteArrayView = dicomParser.sharedCopy(this.byteArray, this.position, numBytes);
        this.position += numBytes;
        return new dicomParser.ByteStream(this.byteArrayParser, byteArrayView);
    };

    /**
     *
     * Parses an unsigned int 16 from a byte array and advances
     * the position by 2 bytes
     *
     * @returns {*} the parsed unsigned int 16
     * @throws error if buffer overread would occur
     */
    dicomParser.ByteStream.prototype.readUint16 = function()
    {
        var result = this.byteArrayParser.readUint16(this.byteArray, this.position);
        this.position += 2;
        return result;
    };

    /**
     * Parses an unsigned int 32 from a byte array and advances
     * the position by 2 bytes
     *
     * @returns {*} the parse unsigned int 32
     * @throws error if buffer overread would occur
     */
    dicomParser.ByteStream.prototype.readUint32 = function()
    {
        var result = this.byteArrayParser.readUint32(this.byteArray, this.position);
        this.position += 4;
        return result;
    };

    /**
     * Reads a string of 8-bit characters from an array of bytes and advances
     * the position by length bytes.  A null terminator will end the string
     * but will not effect advancement of the position.
     * @param length the maximum number of bytes to parse
     * @returns {string} the parsed string
     * @throws error if buffer overread would occur
     */
    dicomParser.ByteStream.prototype.readFixedString = function(length)
    {
        var result = dicomParser.readFixedString(this.byteArray, this.position, length);
        this.position += length;
        return result;
    };

    return dicomParser;
}(dicomParser));
/**
 *
 * The DataSet class encapsulates a collection of DICOM Elements and provides various functions
 * to access the data in those elements
 *
 * Rules for handling padded spaces:
 * DS = Strip leading and trailing spaces
 * DT = Strip trailing spaces
 * IS = Strip leading and trailing spaces
 * PN = Strip trailing spaces
 * TM = Strip trailing spaces
 * AE = Strip leading and trailing spaces
 * CS = Strip leading and trailing spaces
 * SH = Strip leading and trailing spaces
 * LO = Strip leading and trailing spaces
 * LT = Strip trailing spaces
 * ST = Strip trailing spaces
 * UT = Strip trailing spaces
 *
 */
var dicomParser = (function (dicomParser)
{
    "use strict";

    if(dicomParser === undefined)
    {
        dicomParser = {};
    }

    function getByteArrayParser(element, defaultParser)
    {
        return (element.parser !== undefined ? element.parser : defaultParser);
    }

    /**
     * Constructs a new DataSet given byteArray and collection of elements
     * @param byteArrayParser
     * @param byteArray
     * @param elements
     * @constructor
     */
    dicomParser.DataSet = function(byteArrayParser, byteArray, elements)
    {
        this.byteArrayParser = byteArrayParser;
        this.byteArray = byteArray;
        this.elements = elements;
    };

    /**
     * Finds the element for tag and returns an unsigned int 16 if it exists and has data
     * @param tag The DICOM tag in the format xGGGGEEEE
     * @param index the index of the value in a multivalued element.  Default is index 0 if not supplied
     * @returns {*} unsigned int 16 or undefined if the attribute is not present or has data of length 0
     */
    dicomParser.DataSet.prototype.uint16 = function(tag, index)
    {
        var element = this.elements[tag];
        index = (index !== undefined) ? index : 0;
        if(element && element.length !== 0)
        {
            return getByteArrayParser(element, this.byteArrayParser).readUint16(this.byteArray, element.dataOffset + (index *2));
        }
        return undefined;
    };

    /**
     * Finds the element for tag and returns an signed int 16 if it exists and has data
     * @param tag The DICOM tag in the format xGGGGEEEE
     * @param index the index of the value in a multivalued element.  Default is index 0 if not supplied
     * @returns {*} signed int 16 or undefined if the attribute is not present or has data of length 0
     */
    dicomParser.DataSet.prototype.int16 = function(tag, index)
    {
        var element = this.elements[tag];
        index = (index !== undefined) ? index : 0;
        if(element && element.length !== 0)
        {
            return getByteArrayParser(element, this.byteArrayParser).readInt16(this.byteArray, element.dataOffset + (index * 2));
        }
        return undefined;
    };

    /**
     * Finds the element for tag and returns an unsigned int 32 if it exists and has data
     * @param tag The DICOM tag in the format xGGGGEEEE
     * @param index the index of the value in a multivalued element.  Default is index 0 if not supplied
     * @returns {*} unsigned int 32 or undefined if the attribute is not present or has data of length 0
     */
    dicomParser.DataSet.prototype.uint32 = function(tag, index)
    {
        var element = this.elements[tag];
        index = (index !== undefined) ? index : 0;
        if(element && element.length !== 0)
        {
            return getByteArrayParser(element, this.byteArrayParser).readUint32(this.byteArray, element.dataOffset + (index * 4));
        }
        return undefined;
    };

    /**
     * Finds the element for tag and returns an signed int 32 if it exists and has data
     * @param tag The DICOM tag in the format xGGGGEEEE
     * @param index the index of the value in a multivalued element.  Default is index 0 if not supplied
     * @returns {*} signed int 32 or undefined if the attribute is not present or has data of length 0
     */
    dicomParser.DataSet.prototype.int32 = function(tag, index)
    {
        var element = this.elements[tag];
        index = (index !== undefined) ? index : 0;
        if(element && element.length !== 0)
        {
            return getByteArrayParser(element, this.byteArrayParser).readInt32(this.byteArray, element.dataOffset + (index * 4));
        }
        return undefined;
    };

    /**
     * Finds the element for tag and returns a 32 bit floating point number (VR=FL) if it exists and has data
     * @param tag The DICOM tag in the format xGGGGEEEE
     * @param index the index of the value in a multivalued element.  Default is index 0 if not supplied
     * @returns {*} float or undefined if the attribute is not present or has data of length 0
     */
    dicomParser.DataSet.prototype.float = function(tag, index)
    {
        var element = this.elements[tag];
        index = (index !== undefined) ? index : 0;
        if(element && element.length !== 0)
        {
            return getByteArrayParser(element, this.byteArrayParser).readFloat(this.byteArray, element.dataOffset + (index * 4));
        }
        return undefined;
    };

    /**
     * Finds the element for tag and returns a 64 bit floating point number (VR=FD) if it exists and has data
     * @param tag The DICOM tag in the format xGGGGEEEE
     * @param index the index of the value in a multivalued element.  Default is index 0 if not supplied
     * @returns {*} float or undefined if the attribute is not present or doesn't has data of length 0
     */
    dicomParser.DataSet.prototype.double = function(tag, index)
    {
        var element = this.elements[tag];
        index = (index !== undefined) ? index : 0;
        if(element && element.length !== 0)
        {
            return getByteArrayParser(element, this.byteArrayParser).readDouble(this.byteArray, element.dataOffset + (index * 8));
        }
        return undefined;
    };

    /**
     * Returns the number of string values for the element
     * @param tag The DICOM tag in the format xGGGGEEEE
     * @returns {*} the number of string values or undefined if the attribute is not present or has zero length data
     */
    dicomParser.DataSet.prototype.numStringValues = function(tag)
    {
        var element = this.elements[tag];
        if(element && element.length > 0)
        {
            var fixedString = dicomParser.readFixedString(this.byteArray, element.dataOffset, element.length);
            var numMatching = fixedString.match(/\\/g);
            if(numMatching === null)
            {
                return 1;
            }
            return numMatching.length + 1;
        }
        return undefined;
    };

    /**
     * Returns a string for the element.  If index is provided, the element is assumed to be
     * multi-valued and will return the component specified by index.  Undefined is returned
     * if there is no component with the specified index, the element does not exist or is zero length.
     *
     * Use this function for VR types of AE, CS, SH and LO
     *
     * @param tag The DICOM tag in the format xGGGGEEEE
     * @param index the index of the desired value in a multi valued string or undefined for the entire string
     * @returns {*}
     */
    dicomParser.DataSet.prototype.string = function(tag, index)
    {
        var element = this.elements[tag];
        if(element && element.length > 0)
        {
            var fixedString = dicomParser.readFixedString(this.byteArray, element.dataOffset, element.length);
            if(index >= 0)
            {
                var values = fixedString.split('\\');
                // trim trailing spaces
                return values[index].trim();
            }
            else
            {
                // trim trailing spaces
                return fixedString.trim();
            }
        }
        return undefined;
    };

    /**
     * Returns a string with the leading spaces preserved and trailing spaces removed.
     *
     * Use this function to access data for VRs of type UT, ST and LT
     *
     * @param tag
     * @param index
     * @returns {*}
     */
    dicomParser.DataSet.prototype.text = function(tag, index)
    {
        var element = this.elements[tag];
        if(element && element.length > 0)
        {
            var fixedString = dicomParser.readFixedString(this.byteArray, element.dataOffset, element.length);
            if(index >= 0)
            {
                var values = fixedString.split('\\');
                return values[index].replace(/ +$/, '');
            }
            else
            {
                return fixedString.replace(/ +$/, '');
            }
        }
        return undefined;
    };

    /**
     * Parses a string to a float for the specified index in a multi-valued element.  If index is not specified,
     * the first value in a multi-valued VR will be parsed if present.
     * @param tag The DICOM tag in the format xGGGGEEEE
     * @param index the index of the desired value in a multi valued string or undefined for the first value
     * @returns {*} a floating point number or undefined if not present or data not long enough
     */
    dicomParser.DataSet.prototype.floatString = function(tag, index)
    {
        var element = this.elements[tag];
        if(element && element.length > 0)
        {
            index = (index !== undefined) ? index : 0;
            var value = this.string(tag, index);
            if(value !== undefined) {
                return parseFloat(value);
            }
        }
        return undefined;
    };

    /**
     * Parses a string to an integer for the specified index in a multi-valued element.  If index is not specified,
     * the first value in a multi-valued VR will be parsed if present.
     * @param tag The DICOM tag in the format xGGGGEEEE
     * @param index the index of the desired value in a multi valued string or undefined for the first value
     * @returns {*} an integer or undefined if not present or data not long enough
     */
    dicomParser.DataSet.prototype.intString = function(tag, index)
    {
        var element = this.elements[tag];
        if(element && element.length > 0) {
            index = (index !== undefined) ? index : 0;
            var value = this.string(tag, index);
            if(value !== undefined) {
                return parseInt(value);
            }
        }
        return undefined;
    };

    //dicomParser.DataSet = DataSet;

    return dicomParser;
}(dicomParser));
/**
 * Internal helper functions for parsing DICOM elements
 */

var dicomParser = (function (dicomParser)
{
  "use strict";

  if(dicomParser === undefined)
  {
    dicomParser = {};
  }

  /**
   * reads from the byte stream until it finds the magic number for the Sequence Delimitation Item item
   * and then sets the length of the element
   * @param byteStream
   * @param element
   */
  dicomParser.findAndSetUNElementLength = function(byteStream, element)
  {
    if(byteStream === undefined)
    {
      throw "dicomParser.findAndSetUNElementLength: missing required parameter 'byteStream'";
    }

    var itemDelimitationItemLength = 8; // group, element, length
    var maxPosition = byteStream.byteArray.length - itemDelimitationItemLength;
    while(byteStream.position <= maxPosition)
    {
      var groupNumber;
      groupNumber = byteStream.readUint16();
      if(groupNumber === 0xfffe)
      {
        var elementNumber;
        elementNumber = byteStream.readUint16();
        if(elementNumber === 0xe0dd)
        {
          // NOTE: It would be better to also check for the length to be 0 as part of the check above
          // but we will just log a warning for now
          var itemDelimiterLength;
          itemDelimiterLength = byteStream.readUint32(); // the length
          if(itemDelimiterLength !== 0) {
            byteStream.warnings('encountered non zero length following item delimiter at position' + byteStream.position - 4 + " while reading element of undefined length with tag ' + element.tag");
          }
          element.length = byteStream.position - element.dataOffset;
          return;
        }
      }
    }

    // No item delimitation item - silently set the length to the end of the buffer and set the position past the end of the buffer
    element.length = byteStream.byteArray.length - element.dataOffset;
    byteStream.seek(byteStream.byteArray.length - byteStream.position);
  };


  return dicomParser;
}(dicomParser));
/**
 * Internal helper functions for parsing DICOM elements
 */

var dicomParser = (function (dicomParser)
{
    "use strict";

    if(dicomParser === undefined)
    {
        dicomParser = {};
    }

    /**
     * Reads an encapsulated pixel data element and adds an array of fragments to the element
     * containing the offset and length of each fragment and any offsets from the basic offset
     * table
     * @param byteStream
     * @param element
     */
    dicomParser.findEndOfEncapsulatedElement = function(byteStream, element, warnings)
    {
        if(byteStream === undefined)
        {
            throw "dicomParser.findEndOfEncapsulatedElement: missing required parameter 'byteStream'";
        }
        if(element === undefined)
        {
            throw "dicomParser.findEndOfEncapsulatedElement: missing required parameter 'element'";
        }

        element.encapsulatedPixelData = true;
        element.basicOffsetTable = [];
        element.fragments = [];
        var basicOffsetTableItemTag = dicomParser.readTag(byteStream);
        if(basicOffsetTableItemTag !== 'xfffee000') {
            throw "dicomParser.findEndOfEncapsulatedElement: basic offset table not found";
        }
        var basicOffsetTableItemlength = byteStream.readUint32();
        var numFragments = basicOffsetTableItemlength / 4;
        for(var i =0; i < numFragments; i++) {
            var offset = byteStream.readUint32();
            element.basicOffsetTable.push(offset);
        }
        var baseOffset = byteStream.position;

        while(byteStream.position < byteStream.byteArray.length)
        {
            var tag = dicomParser.readTag(byteStream);
            var length = byteStream.readUint32();
            if(tag === 'xfffee0dd')
            {
                byteStream.seek(length);
                element.length = byteStream.position - element.dataOffset;
                return;
            }
            else if(tag === 'xfffee000')
            {
                element.fragments.push({
                    offset: byteStream.position - baseOffset - 8,
                    position : byteStream.position,
                    length : length
                });
            }
            else {
                if(warnings) {
                    warnings.push('unexpected tag ' + tag + ' while searching for end of pixel data element with undefined length');
                }
                if(length > byteStream.byteArray.length - byteStream.position)
                {
                    // fix length
                    length = byteStream.byteArray.length - byteStream.position;
                }
                element.fragments.push({
                    offset: byteStream.position - baseOffset - 8,
                    position : byteStream.position,
                    length : length
                });
                byteStream.seek(length);
                element.length = byteStream.position - element.dataOffset;
                return;
            }

            byteStream.seek(length);
        }

        if(warnings) {
            warnings.push("pixel data element " + element.tag + " missing sequence delimiter tag xfffee0dd");
        }
    };


    return dicomParser;
}(dicomParser));
/**
 * Internal helper functions for parsing DICOM elements
 */

var dicomParser = (function (dicomParser)
{
    "use strict";

    if(dicomParser === undefined)
    {
        dicomParser = {};
    }

    /**
     * reads from the byte stream until it finds the magic numbers for the item delimitation item
     * and then sets the length of the element
     * @param byteStream
     * @param element
     */
    dicomParser.findItemDelimitationItemAndSetElementLength = function(byteStream, element)
    {
        if(byteStream === undefined)
        {
            throw "dicomParser.readDicomElementImplicit: missing required parameter 'byteStream'";
        }

        var itemDelimitationItemLength = 8; // group, element, length
        var maxPosition = byteStream.byteArray.length - itemDelimitationItemLength;
        while(byteStream.position <= maxPosition)
        {
            var groupNumber = byteStream.readUint16();
            if(groupNumber === 0xfffe)
            {
                var elementNumber = byteStream.readUint16();
                if(elementNumber === 0xe00d)
                {
                    // NOTE: It would be better to also check for the length to be 0 as part of the check above
                    // but we will just log a warning for now
                    var itemDelimiterLength = byteStream.readUint32(); // the length
                    if(itemDelimiterLength !== 0) {
                        byteStream.warnings('encountered non zero length following item delimiter at position' + byteStream.position - 4 + " while reading element of undefined length with tag ' + element.tag");
                    }
                    element.length = byteStream.position - element.dataOffset;
                    return;
                }
            }
        }

        // No item delimitation item - silently set the length to the end of the buffer and set the position past the end of the buffer
        element.length = byteStream.byteArray.length - element.dataOffset;
        byteStream.seek(byteStream.byteArray.length - byteStream.position);
    };


    return dicomParser;
}(dicomParser));
/**
 * Internal helper functions for parsing different types from a little-endian byte array
 */

var dicomParser = (function (dicomParser)
{
    "use strict";

    if(dicomParser === undefined)
    {
        dicomParser = {};
    }

    dicomParser.littleEndianByteArrayParser = {
        /**
         *
         * Parses an unsigned int 16 from a little-endian byte array
         *
         * @param byteArray the byte array to read from
         * @param position the position in the byte array to read from
         * @returns {*} the parsed unsigned int 16
         * @throws error if buffer overread would occur
         * @access private
         */
        readUint16: function (byteArray, position) {
            if (position < 0) {
                throw 'littleEndianByteArrayParser.readUint16: position cannot be less than 0';
            }
            if (position + 2 > byteArray.length) {
                throw 'littleEndianByteArrayParser.readUint16: attempt to read past end of buffer';
            }
            return byteArray[position] + (byteArray[position + 1] * 256);
        },

        /**
         *
         * Parses a signed int 16 from a little-endian byte array
         *
         * @param byteArray the byte array to read from
         * @param position the position in the byte array to read from
         * @returns {*} the parsed signed int 16
         * @throws error if buffer overread would occur
         * @access private
         */
        readInt16: function (byteArray, position) {
            if (position < 0) {
                throw 'littleEndianByteArrayParser.readInt16: position cannot be less than 0';
            }
            if (position + 2 > byteArray.length) {
                throw 'littleEndianByteArrayParser.readInt16: attempt to read past end of buffer';
            }
            var int16 = byteArray[position] + (byteArray[position + 1] << 8);
            // fix sign
            if (int16 & 0x8000) {
                int16 = int16 - 0xFFFF - 1;
            }
            return int16;
        },


        /**
         * Parses an unsigned int 32 from a little-endian byte array
         *
         * @param byteArray the byte array to read from
         * @param position the position in the byte array to read from
         * @returns {*} the parsed unsigned int 32
         * @throws error if buffer overread would occur
         * @access private
         */
        readUint32: function (byteArray, position) {
            if (position < 0) {
                throw 'littleEndianByteArrayParser.readUint32: position cannot be less than 0';
            }

            if (position + 4 > byteArray.length) {
                throw 'littleEndianByteArrayParser.readUint32: attempt to read past end of buffer';
            }

            var uint32 = (byteArray[position] +
            (byteArray[position + 1] * 256) +
            (byteArray[position + 2] * 256 * 256) +
            (byteArray[position + 3] * 256 * 256 * 256 ));

            return uint32;
        },

        /**
         * Parses a signed int 32 from a little-endian byte array
         *
         * @param byteArray the byte array to read from
         * @param position the position in the byte array to read from
         * @returns {*} the parsed unsigned int 32
         * @throws error if buffer overread would occur
         * @access private
         */
        readInt32: function (byteArray, position) {
            if (position < 0) {
                throw 'littleEndianByteArrayParser.readInt32: position cannot be less than 0';
            }

            if (position + 4 > byteArray.length) {
                throw 'littleEndianByteArrayParser.readInt32: attempt to read past end of buffer';
            }

            var int32 = (byteArray[position] +
            (byteArray[position + 1] << 8) +
            (byteArray[position + 2] << 16) +
            (byteArray[position + 3] << 24));

            return int32;

        },

        /**
         * Parses 32-bit float from a little-endian byte array
         *
         * @param byteArray the byte array to read from
         * @param position the position in the byte array to read from
         * @returns {*} the parsed 32-bit float
         * @throws error if buffer overread would occur
         * @access private
         */
        readFloat: function (byteArray, position) {
            if (position < 0) {
                throw 'littleEndianByteArrayParser.readFloat: position cannot be less than 0';
            }

            if (position + 4 > byteArray.length) {
                throw 'littleEndianByteArrayParser.readFloat: attempt to read past end of buffer';
            }

            // I am sure there is a better way than this but this should be safe
            var byteArrayForParsingFloat = new Uint8Array(4);
            byteArrayForParsingFloat[0] = byteArray[position];
            byteArrayForParsingFloat[1] = byteArray[position + 1];
            byteArrayForParsingFloat[2] = byteArray[position + 2];
            byteArrayForParsingFloat[3] = byteArray[position + 3];
            var floatArray = new Float32Array(byteArrayForParsingFloat.buffer);
            return floatArray[0];
        },

        /**
         * Parses 64-bit float from a little-endian byte array
         *
         * @param byteArray the byte array to read from
         * @param position the position in the byte array to read from
         * @returns {*} the parsed 64-bit float
         * @throws error if buffer overread would occur
         * @access private
         */
        readDouble: function (byteArray, position) {
            if (position < 0) {
                throw 'littleEndianByteArrayParser.readDouble: position cannot be less than 0';
            }

            if (position + 8 > byteArray.length) {
                throw 'littleEndianByteArrayParser.readDouble: attempt to read past end of buffer';
            }

            // I am sure there is a better way than this but this should be safe
            var byteArrayForParsingFloat = new Uint8Array(8);
            byteArrayForParsingFloat[0] = byteArray[position];
            byteArrayForParsingFloat[1] = byteArray[position + 1];
            byteArrayForParsingFloat[2] = byteArray[position + 2];
            byteArrayForParsingFloat[3] = byteArray[position + 3];
            byteArrayForParsingFloat[4] = byteArray[position + 4];
            byteArrayForParsingFloat[5] = byteArray[position + 5];
            byteArrayForParsingFloat[6] = byteArray[position + 6];
            byteArrayForParsingFloat[7] = byteArray[position + 7];
            var floatArray = new Float64Array(byteArrayForParsingFloat.buffer);
            return floatArray[0];
        }
    };

    return dicomParser;
}(dicomParser));
/**
 * Internal helper functions for parsing implicit and explicit DICOM data sets
 */

var dicomParser = (function (dicomParser)
{
    "use strict";

    if(dicomParser === undefined)
    {
        dicomParser = {};
    }

    /**
     * reads an explicit data set
     * @param byteStream the byte stream to read from
     * @param maxPosition the maximum position to read up to (optional - only needed when reading sequence items)
     */
    dicomParser.parseDicomDataSetExplicit = function (dataSet, byteStream, maxPosition, options) {

        maxPosition = (maxPosition === undefined) ? byteStream.byteArray.length : maxPosition ;
        options = options || {};

        if(byteStream === undefined)
        {
            throw "dicomParser.parseDicomDataSetExplicit: missing required parameter 'byteStream'";
        }
        if(maxPosition < byteStream.position || maxPosition > byteStream.byteArray.length)
        {
            throw "dicomParser.parseDicomDataSetExplicit: invalid value for parameter 'maxPosition'";
        }
        var elements = dataSet.elements;

        while(byteStream.position < maxPosition)
        {
            var element = dicomParser.readDicomElementExplicit(byteStream, dataSet.warnings, options.untilTag);
            elements[element.tag] = element;
            if(element.tag === options.untilTag) {
                return;
            }
        }
        if(byteStream.position > maxPosition) {
            throw "dicomParser:parseDicomDataSetExplicit: buffer overrun";
        }
    };

    /**
     * reads an implicit data set
     * @param byteStream the byte stream to read from
     * @param maxPosition the maximum position to read up to (optional - only needed when reading sequence items)
     */
    dicomParser.parseDicomDataSetImplicit = function(dataSet, byteStream, maxPosition, options)
    {
        maxPosition = (maxPosition === undefined) ? dataSet.byteArray.length : maxPosition ;
        options = options || {};

        if(byteStream === undefined)
        {
            throw "dicomParser.parseDicomDataSetImplicit: missing required parameter 'byteStream'";
        }
        if(maxPosition < byteStream.position || maxPosition > byteStream.byteArray.length)
        {
            throw "dicomParser.parseDicomDataSetImplicit: invalid value for parameter 'maxPosition'";
        }

        var elements = dataSet.elements;

        while(byteStream.position < maxPosition)
        {
            var element = dicomParser.readDicomElementImplicit(byteStream, options.untilTag, options.vrCallback);
            elements[element.tag] = element;
            if(element.tag === options.untilTag) {
                return;
            }
        }
    };

    return dicomParser;
}(dicomParser));

/**
 * Internal helper functions for for parsing DICOM elements
 */

var dicomParser = (function (dicomParser)
{
    "use strict";

    if(dicomParser === undefined)
    {
        dicomParser = {};
    }

    function getDataLengthSizeInBytesForVR(vr)
    {
        if( vr === 'OB' ||
            vr === 'OW' ||
            vr === 'SQ' ||
            vr === 'OF' ||
            vr === 'UT' ||
            vr === 'UN')
        {
            return 4;
        }
        else
        {
            return 2;
        }
    }

    dicomParser.readDicomElementExplicit = function(byteStream, warnings, untilTag)
    {
        if(byteStream === undefined)
        {
            throw "dicomParser.readDicomElementExplicit: missing required parameter 'byteStream'";
        }

        var element = {
            tag : dicomParser.readTag(byteStream),
            vr : byteStream.readFixedString(2)
            // length set below based on VR
            // dataOffset set below based on VR and size of length
        };

        var dataLengthSizeBytes = getDataLengthSizeInBytesForVR(element.vr);
        if(dataLengthSizeBytes === 2)
        {
            element.length = byteStream.readUint16();
            element.dataOffset = byteStream.position;
        }
        else
        {
            byteStream.seek(2);
            element.length = byteStream.readUint32();
            element.dataOffset = byteStream.position;
        }

        if(element.length === 4294967295)
        {
            element.hadUndefinedLength = true;
        }

        if(element.tag === untilTag) {
            return element;
        }

        // if VR is SQ, parse the sequence items
        if(element.vr === 'SQ')
        {
            dicomParser.readSequenceItemsExplicit(byteStream, element, warnings);
            return element;
        }


        if(element.length === 4294967295)
        {
            if(element.tag === 'x7fe00010') {
                dicomParser.findEndOfEncapsulatedElement(byteStream, element, warnings);
                return element;
            }   else if(element.vr === 'UN') {
                dicomParser.findAndSetUNElementLength(byteStream, element);
                return element;
            } else {
                dicomParser.readSequenceItemsImplicit(byteStream, element);
                //dicomParser.findItemDelimitationItemAndSetElementLength(byteStream, element);
                return element;
            }
        }

        byteStream.seek(element.length);
        return element;
    };

    return dicomParser;
}(dicomParser));
/**
 * Internal helper functions for for parsing DICOM elements
 */

var dicomParser = (function (dicomParser)
{
    "use strict";

    if(dicomParser === undefined)
    {
        dicomParser = {};
    }

    function isSequence(element, byteStream, vrCallback) {
        // if a data dictionary callback was provided, use that to verify that the element is a sequence.
        if (typeof vrCallback !== 'undefined') {
            return (vrCallback(element.tag) === 'SQ');
        }
        if ((byteStream.position + 4) <= byteStream.byteArray.length) {
            var nextTag = dicomParser.readTag(byteStream);
            byteStream.seek(-4);
            // Item start tag (fffe,e000) or sequence delimiter (i.e. end of sequence) tag (0fffe,e0dd)
            // These are the tags that could potentially be found directly after a sequence start tag (the delimiter
            // is found in the case of an empty sequence). This is not 100% safe because a non-sequence item
            // could have data that has these bytes, but this is how to do it without a data dictionary.
            return (nextTag === 'xfffee000') || (nextTag === 'xfffee0dd');
        }
        byteStream.warnings.push('eof encountered before finding sequence item tag or sequence delimiter tag in peeking to determine VR');
        return false;
    }

    dicomParser.readDicomElementImplicit = function(byteStream, untilTag, vrCallback)
    {
        if(byteStream === undefined)
        {
            throw "dicomParser.readDicomElementImplicit: missing required parameter 'byteStream'";
        }

        var element = {
            tag : dicomParser.readTag(byteStream),
            length: byteStream.readUint32(),
            dataOffset :  byteStream.position
        };

        if(element.length === 4294967295) {
            element.hadUndefinedLength = true;
        }

        if(element.tag === untilTag) {
            return element;
        }

        if (isSequence(element, byteStream, vrCallback)) {
            // parse the sequence
            dicomParser.readSequenceItemsImplicit(byteStream, element);
            return element;
        }

        // if element is not a sequence and has undefined length, we have to
        // scan the data for a magic number to figure out when it ends.
        if(element.hadUndefinedLength)
        {
            dicomParser.findItemDelimitationItemAndSetElementLength(byteStream, element);
            return element;
        }

        // non sequence element with known length, skip over the data part
        byteStream.seek(element.length);
        return element;
    };


    return dicomParser;
}(dicomParser));
/**
 * Functionality for extracting encapsulated pixel data
 */

var dicomParser = (function (dicomParser)
{
  "use strict";

  if(dicomParser === undefined)
  {
    dicomParser = {};
  }

  function findFragmentIndexWithOffset(fragments, offset) {
    for(var i=0; i < fragments.length; i++) {
      if(fragments[i].offset === offset) {
        return i;
      }
    }
  }

  function calculateNumberOfFragmentsForFrame(frameIndex, basicOffsetTable, fragments, startFragmentIndex) {
    // special case for last frame
    if(frameIndex === basicOffsetTable.length -1) {
      return fragments.length - startFragmentIndex;
    }

    // iterate through each fragment looking for the one matching the offset for the next frame
    var nextFrameOffset = basicOffsetTable[frameIndex + 1];
    for(var i=startFragmentIndex + 1; i < fragments.length; i++) {
      if(fragments[i].offset === nextFrameOffset) {
        return i - startFragmentIndex;
      }
    }

    throw "dicomParser.calculateNumberOfFragmentsForFrame: could not find fragment with offset matching basic offset table";
  }

  /**
   * Returns the pixel data for the specified frame in an encapsulated pixel data element that has a non
   * empty basic offset table.  Note that this function will fail if the basic offset table is empty - in that
   * case you need to determine which fragments map to which frames and read them using
   * readEncapsulatedPixelDataFromFragments().  Also see the function createJEPGBasicOffsetTable() to see
   * how a basic offset table can be created for JPEG images
   *
   * @param dataSet - the dataSet containing the encapsulated pixel data
   * @param pixelDataElement - the pixel data element (x7fe00010) to extract the frame from
   * @param frameIndex - the zero based frame index
   * @param [basicOffsetTable] - optional array of starting offsets for frames
   * @param [fragments] - optional array of objects describing each fragment (offset, position, length)
   * @returns {object} with the encapsulated pixel data
   */
  dicomParser.readEncapsulatedImageFrame = function(dataSet, pixelDataElement, frameIndex, basicOffsetTable, fragments)
  {
    // default parameters
    basicOffsetTable = basicOffsetTable || pixelDataElement.basicOffsetTable;
    fragments = fragments || pixelDataElement.fragments;

    // Validate parameters
    if(dataSet === undefined) {
      throw "dicomParser.readEncapsulatedImageFrame: missing required parameter 'dataSet'";
    }
    if(pixelDataElement === undefined) {
      throw "dicomParser.readEncapsulatedImageFrame: missing required parameter 'pixelDataElement'";
    }
    if(frameIndex === undefined) {
      throw "dicomParser.readEncapsulatedImageFrame: missing required parameter 'frameIndex'";
    }
    if(basicOffsetTable === undefined) {
      throw "dicomParser.readEncapsulatedImageFrame: parameter 'pixelDataElement' does not have basicOffsetTable";
    }
    if(pixelDataElement.tag !== 'x7fe00010') {
      throw "dicomParser.readEncapsulatedImageFrame: parameter 'pixelDataElement' refers to non pixel data tag (expected tag = x7fe00010'";
    }
    if(pixelDataElement.encapsulatedPixelData !== true) {
      throw "dicomParser.readEncapsulatedImageFrame: parameter 'pixelDataElement' refers to pixel data element that does not have encapsulated pixel data";
    }
    if(pixelDataElement.hadUndefinedLength !== true) {
      throw "dicomParser.readEncapsulatedImageFrame: parameter 'pixelDataElement' refers to pixel data element that does not have undefined length";
    }
    if(pixelDataElement.fragments === undefined) {
      throw "dicomParser.readEncapsulatedImageFrame: parameter 'pixelDataElement' refers to pixel data element that does not have fragments";
    }
    if(basicOffsetTable.length === 0) {
      throw "dicomParser.readEncapsulatedImageFrame: basicOffsetTable has zero entries";
    }
    if(frameIndex < 0) {
      throw "dicomParser.readEncapsulatedImageFrame: parameter 'frameIndex' must be >= 0";
    }
    if(frameIndex >= basicOffsetTable.length) {
      throw "dicomParser.readEncapsulatedImageFrame: parameter 'frameIndex' must be < basicOffsetTable.length";
    }

    // find starting fragment based on the offset for the frame in the basic offset table
    var offset = basicOffsetTable[frameIndex];
    var startFragmentIndex = findFragmentIndexWithOffset(fragments, offset);
    if(startFragmentIndex === undefined) {
      throw "dicomParser.readEncapsulatedImageFrame: unable to find fragment that matches basic offset table entry";
    }

    // calculate the number of fragments for this frame
    var numFragments = calculateNumberOfFragmentsForFrame(frameIndex, basicOffsetTable, fragments, startFragmentIndex);

    // now extract the frame from the fragments
    return dicomParser.readEncapsulatedPixelDataFromFragments(dataSet, pixelDataElement, startFragmentIndex, numFragments, fragments);
  };

  return dicomParser;
}(dicomParser));

/**
 * Functionality for extracting encapsulated pixel data
 */

var dicomParser = (function (dicomParser)
{
  "use strict";

  if(dicomParser === undefined)
  {
    dicomParser = {};
  }

  function calculateBufferSize(fragments, startFragment, numFragments) {
    var bufferSize = 0;
    for(var i=startFragment; i < startFragment + numFragments; i++) {
      bufferSize += fragments[i].length;
    }
    return bufferSize;
  }

  /**
   * Returns the encapsulated pixel data from the specified fragments.  Use this function when you know
   * the fragments you want to extract data from.  See
   *
   * @param dataSet - the dataSet containing the encapsulated pixel data
   * @param pixelDataElement - the pixel data element (x7fe00010) to extract the fragment data from
   * @param startFragmentIndex - zero based index of the first fragment to extract from
   * @param [numFragments] - the number of fragments to extract from, default is 1
   * @param [fragments] - optional array of objects describing each fragment (offset, position, length)
   * @returns {object} byte array with the encapsulated pixel data
   */
  dicomParser.readEncapsulatedPixelDataFromFragments = function(dataSet, pixelDataElement, startFragmentIndex, numFragments, fragments)
  {
    // default values
    numFragments = numFragments || 1;
    fragments = fragments || pixelDataElement.fragments;

    // check parameters
    if(dataSet === undefined) {
      throw "dicomParser.readEncapsulatedPixelDataFromFragments: missing required parameter 'dataSet'";
    }
    if(pixelDataElement === undefined) {
      throw "dicomParser.readEncapsulatedPixelDataFromFragments: missing required parameter 'pixelDataElement'";
    }
    if(startFragmentIndex === undefined) {
      throw "dicomParser.readEncapsulatedPixelDataFromFragments: missing required parameter 'startFragmentIndex'";
    }
    if(numFragments === undefined) {
      throw "dicomParser.readEncapsulatedPixelDataFromFragments: missing required parameter 'numFragments'";
    }
    if(pixelDataElement.tag !== 'x7fe00010') {
      throw "dicomParser.readEncapsulatedPixelDataFromFragments: parameter 'pixelDataElement' refers to non pixel data tag (expected tag = x7fe00010'";
    }
    if(pixelDataElement.encapsulatedPixelData !== true) {
      throw "dicomParser.readEncapsulatedPixelDataFromFragments: parameter 'pixelDataElement' refers to pixel data element that does not have encapsulated pixel data";
    }
    if(pixelDataElement.hadUndefinedLength !== true) {
      throw "dicomParser.readEncapsulatedPixelDataFromFragments: parameter 'pixelDataElement' refers to pixel data element that does not have encapsulated pixel data";
    }
    if(pixelDataElement.basicOffsetTable === undefined) {
      throw "dicomParser.readEncapsulatedPixelDataFromFragments: parameter 'pixelDataElement' refers to pixel data element that does not have encapsulated pixel data";
    }
    if(pixelDataElement.fragments === undefined) {
      throw "dicomParser.readEncapsulatedPixelDataFromFragments: parameter 'pixelDataElement' refers to pixel data element that does not have encapsulated pixel data";
    }
    if(pixelDataElement.fragments.length <= 0) {
      throw "dicomParser.readEncapsulatedPixelDataFromFragments: parameter 'pixelDataElement' refers to pixel data element that does not have encapsulated pixel data";
    }
    if(startFragmentIndex < 0) {
      throw "dicomParser.readEncapsulatedPixelDataFromFragments: parameter 'startFragmentIndex' must be >= 0";
    }
    if(startFragmentIndex >= pixelDataElement.fragments.length) {
      throw "dicomParser.readEncapsulatedPixelDataFromFragments: parameter 'startFragmentIndex' must be < number of fragments";
    }
    if(numFragments < 1) {
      throw "dicomParser.readEncapsulatedPixelDataFromFragments: parameter 'numFragments' must be > 0";
    }
    if(startFragmentIndex + numFragments > pixelDataElement.fragments.length) {
      throw "dicomParser.readEncapsulatedPixelDataFromFragments: parameter 'startFragment' + 'numFragments' < number of fragments";
    }

    // create byte stream on the data for this pixel data element
    var byteStream = new dicomParser.ByteStream(dataSet.byteArrayParser, dataSet.byteArray, pixelDataElement.dataOffset);

    // seek past the basic offset table (no need to parse it again since we already have)
    var basicOffsetTable = dicomParser.readSequenceItem(byteStream);
    if(basicOffsetTable.tag !== 'xfffee000')
    {
      throw "dicomParser.readEncapsulatedPixelData: missing basic offset table xfffee000";
    }
    byteStream.seek(basicOffsetTable.length);

    var fragmentZeroPosition = byteStream.position;
    var fragmentHeaderSize = 8; // tag + length

    // if there is only one fragment, return a view on this array to avoid copying
    if(numFragments === 1) {
      return dicomParser.sharedCopy(byteStream.byteArray, fragmentZeroPosition + fragments[startFragmentIndex].offset + fragmentHeaderSize, fragments[startFragmentIndex].length);
    }

    // more than one fragment, combine all of the fragments into one buffer
    var bufferSize = calculateBufferSize(fragments, startFragmentIndex, numFragments);

    var pixelData = dicomParser.alloc(byteStream.byteArray, bufferSize);

    var pixelDataIndex = 0;
    for(var i=startFragmentIndex; i < startFragmentIndex + numFragments; i++) {
      var fragmentOffset = fragmentZeroPosition + fragments[i].offset + fragmentHeaderSize;
      for(var j=0; j < fragments[i].length; j++) {
        pixelData[pixelDataIndex++] = byteStream.byteArray[fragmentOffset++];
      }
    }

    return pixelData;
  };

  return dicomParser;
}(dicomParser));

/**
 * Parses a DICOM P10 byte array and returns a DataSet object with the parsed elements.  If the options
 * argument is supplied and it contains the untilTag property, parsing will stop once that
 * tag is encoutered.  This can be used to parse partial byte streams.
 *
 * @param byteArray the byte array
 * @param options object to control parsing behavior (optional)
 * @returns {DataSet}
 * @throws error if an error occurs while parsing.  The exception object will contain a property dataSet with the
 *         elements successfully parsed before the error.
 */
var dicomParser = (function(dicomParser) {
  if(dicomParser === undefined)
  {
    dicomParser = {};
  }

  dicomParser.readPart10Header = function(byteArray, options) {

    if(byteArray === undefined)
    {
      throw "dicomParser.readPart10Header: missing required parameter 'byteArray'";
    }

    var littleEndianByteStream = new dicomParser.ByteStream(dicomParser.littleEndianByteArrayParser, byteArray);

    function readPrefix()
    {
      littleEndianByteStream.seek(128);
      var prefix = littleEndianByteStream.readFixedString(4);
      if(prefix !== "DICM")
      {
        throw "dicomParser.readPart10Header: DICM prefix not found at location 132 - this is not a valid DICOM P10 file.";
      }
    }

    // main function here
    function readTheHeader() {
      // Per the DICOM standard, the header is always encoded in Explicit VR Little Endian (see PS3.10, section 7.1)
      // so use littleEndianByteStream throughout this method regardless of the transfer syntax
      readPrefix();

      var warnings = [];
      var elements = {};
      while(littleEndianByteStream.position < littleEndianByteStream.byteArray.length) {
        var position = littleEndianByteStream.position;
        var element = dicomParser.readDicomElementExplicit(littleEndianByteStream, warnings);
        if(element.tag > 'x0002ffff') {
          littleEndianByteStream.position = position;
          break;
        }
        // Cache the littleEndianByteArrayParser for meta header elements, since the rest of the data set may be big endian
        // and this parser will be needed later if the meta header values are to be read.
        element.parser = dicomParser.littleEndianByteArrayParser;
        elements[element.tag] = element;
      }
      var metaHeaderDataSet = new dicomParser.DataSet(littleEndianByteStream.byteArrayParser, littleEndianByteStream.byteArray, elements);
      metaHeaderDataSet.warnings = littleEndianByteStream.warnings;
      metaHeaderDataSet.position = littleEndianByteStream.position;
      return metaHeaderDataSet;
    }

    // This is where we actually start parsing
    return readTheHeader();
  };

  return dicomParser;
})(dicomParser);

/**
 * Internal helper functions for parsing DICOM elements
 */

var dicomParser = (function (dicomParser)
{
    "use strict";

    if(dicomParser === undefined)
    {
        dicomParser = {};
    }

    function readDicomDataSetExplicitUndefinedLength(byteStream, warnings)
    {
        var elements = {};

        while(byteStream.position < byteStream.byteArray.length)
        {
            var element = dicomParser.readDicomElementExplicit(byteStream, warnings);
            elements[element.tag] = element;

            // we hit an item delimiter tag, return the current offset to mark
            // the end of this sequence item
            if(element.tag === 'xfffee00d')
            {
                return new dicomParser.DataSet(byteStream.byteArrayParser, byteStream.byteArray, elements);
            }

        }

        // eof encountered - log a warning and return what we have for the element
        warnings.push('eof encountered before finding item delimiter tag while reading sequence item of undefined length');
        return new dicomParser.DataSet(byteStream.byteArrayParser, byteStream.byteArray, elements);
    }

    function readSequenceItemExplicit(byteStream, warnings)
    {
        var item = dicomParser.readSequenceItem(byteStream);

        if(item.length === 4294967295)
        {
            item.hadUndefinedLength = true;
            item.dataSet = readDicomDataSetExplicitUndefinedLength(byteStream, warnings);
            item.length = byteStream.position - item.dataOffset;
        }
        else
        {
            item.dataSet = new dicomParser.DataSet(byteStream.byteArrayParser, byteStream.byteArray, {});
            dicomParser.parseDicomDataSetExplicit(item.dataSet, byteStream, byteStream.position + item.length);
        }
        return item;
    }

    function readSQElementUndefinedLengthExplicit(byteStream, element, warnings)
    {
        while((byteStream.position + 4) <= byteStream.byteArray.length)
        {
          // end reading this sequence if the next tag is the sequence delimitation item
          var nextTag = dicomParser.readTag(byteStream);
          byteStream.seek(-4);
          if (nextTag === 'xfffee0dd') {
            // set the correct length
            element.length = byteStream.position - element.dataOffset;
            byteStream.seek(8);
            return element;
          }

            var item = readSequenceItemExplicit(byteStream, warnings);
            element.items.push(item);
        }
        warnings.push('eof encountered before finding sequence delimitation tag while reading sequence of undefined length');
        element.length = byteStream.position - element.dataOffset;
    }

    function readSQElementKnownLengthExplicit(byteStream, element, warnings)
    {
        var maxPosition = element.dataOffset + element.length;
        while(byteStream.position < maxPosition)
        {
            var item = readSequenceItemExplicit(byteStream, warnings);
            element.items.push(item);
        }
    }

    dicomParser.readSequenceItemsExplicit = function(byteStream, element, warnings)
    {
        if(byteStream === undefined)
        {
            throw "dicomParser.readSequenceItemsExplicit: missing required parameter 'byteStream'";
        }
        if(element === undefined)
        {
            throw "dicomParser.readSequenceItemsExplicit: missing required parameter 'element'";
        }

        element.items = [];

        if(element.length === 4294967295)
        {
            readSQElementUndefinedLengthExplicit(byteStream, element, warnings);
        }
        else
        {
            readSQElementKnownLengthExplicit(byteStream, element, warnings);
        }
    };


    return dicomParser;
}(dicomParser));
/**
 * Internal helper functions for parsing DICOM elements
 */

var dicomParser = (function (dicomParser)
{
    "use strict";

    if(dicomParser === undefined)
    {
        dicomParser = {};
    }

    function readDicomDataSetImplicitUndefinedLength(byteStream, vrCallback)
    {
        var elements = {};

        while(byteStream.position < byteStream.byteArray.length)
        {
            var element = dicomParser.readDicomElementImplicit(byteStream, undefined, vrCallback);
            elements[element.tag] = element;

            // we hit an item delimiter tag, return the current offset to mark
            // the end of this sequence item
            if(element.tag === 'xfffee00d')
            {
                return new dicomParser.DataSet(byteStream.byteArrayParser, byteStream.byteArray, elements);
            }
        }
        // eof encountered - log a warning and return what we have for the element
        byteStream.warnings.push('eof encountered before finding sequence item delimiter in sequence item of undefined length');
        return new dicomParser.DataSet(byteStream.byteArrayParser, byteStream.byteArray, elements);
    }

    function readSequenceItemImplicit(byteStream, vrCallback)
    {
        var item = dicomParser.readSequenceItem(byteStream);

        if(item.length === 4294967295)
        {
            item.hadUndefinedLength = true;
            item.dataSet = readDicomDataSetImplicitUndefinedLength(byteStream, vrCallback);
            item.length = byteStream.position - item.dataOffset;
        }
        else
        {
            item.dataSet = new dicomParser.DataSet(byteStream.byteArrayParser, byteStream.byteArray, {});
            dicomParser.parseDicomDataSetImplicit(item.dataSet, byteStream, byteStream.position + item.length, {vrCallback: vrCallback});
        }
        return item;
    }

    function readSQElementUndefinedLengthImplicit(byteStream, element, vrCallback)
    {
        while((byteStream.position + 4) <= byteStream.byteArray.length)
        {
          // end reading this sequence if the next tag is the sequence delimitation item
          var nextTag = dicomParser.readTag(byteStream);
          byteStream.seek(-4);
          if (nextTag === 'xfffee0dd') {
            // set the correct length
            element.length = byteStream.position - element.dataOffset;
            byteStream.seek(8);
            return element;
          }

          var item = readSequenceItemImplicit(byteStream, vrCallback);
          element.items.push(item);
        }
        byteStream.warnings.push('eof encountered before finding sequence delimiter in sequence of undefined length');
        element.length = byteStream.byteArray.length - element.dataOffset;
    }

    function readSQElementKnownLengthImplicit(byteStream, element, vrCallback)
    {
        var maxPosition = element.dataOffset + element.length;
        while(byteStream.position < maxPosition)
        {
            var item = readSequenceItemImplicit(byteStream, vrCallback);
            element.items.push(item);
        }
    }

    /**
     * Reads sequence items for an element in an implicit little endian byte stream
     * @param byteStream the implicit little endian byte stream
     * @param element the element to read the sequence items for
     * @param vrCallback an optional method that returns a VR string given a tag
     */
    dicomParser.readSequenceItemsImplicit = function(byteStream, element, vrCallback)
    {
        if(byteStream === undefined)
        {
            throw "dicomParser.readSequenceItemsImplicit: missing required parameter 'byteStream'";
        }
        if(element === undefined)
        {
            throw "dicomParser.readSequenceItemsImplicit: missing required parameter 'element'";
        }

        element.items = [];

        if(element.length === 4294967295)
        {
            readSQElementUndefinedLengthImplicit(byteStream, element, vrCallback);
        }
        else
        {
            readSQElementKnownLengthImplicit(byteStream, element, vrCallback);
        }
    };

    return dicomParser;
}(dicomParser));
/**
 * Internal helper functions for parsing DICOM elements
 */

var dicomParser = (function (dicomParser)
{
    "use strict";

    if(dicomParser === undefined)
    {
        dicomParser = {};
    }

    /**
     * Reads the tag and length of a sequence item and returns them as an object with the following properties
     *  tag : string for the tag of this element in the format xggggeeee
     *  length: the number of bytes in this item or 4294967295 if undefined
     *  dataOffset: the offset into the byteStream of the data for this item
     * @param byteStream the byte
     * @returns {{tag: string, length: integer, dataOffset: integer}}
     */
    dicomParser.readSequenceItem = function(byteStream)
    {
        if(byteStream === undefined)
        {
            throw "dicomParser.readSequenceItem: missing required parameter 'byteStream'";
        }

        var element = {
            tag : dicomParser.readTag(byteStream),
            length : byteStream.readUint32(),
            dataOffset :  byteStream.position
        };

        if (element.tag !== 'xfffee000') {
            var startPosition = byteStream.position;
            throw "dicomParser.readSequenceItem: item tag (FFFE,E000) not found at offset " + startPosition;
        }

        return element;
    };


    return dicomParser;
}(dicomParser));
/**
 * Internal helper functions for parsing DICOM elements
 */

var dicomParser = (function (dicomParser)
{
    "use strict";

    if(dicomParser === undefined)
    {
        dicomParser = {};
    }

    /**
     * Reads a tag (group number and element number) from a byteStream
     * @param byteStream the byte stream to read from
     * @returns {string} the tag in format xggggeeee where gggg is the lowercase hex value of the group number
     * and eeee is the lower case hex value of the element number
     */
    dicomParser.readTag = function(byteStream)
    {
        if(byteStream === undefined)
        {
            throw "dicomParser.readTag: missing required parameter 'byteStream'";
        }

        var groupNumber =  byteStream.readUint16() * 256 * 256;
        var elementNumber = byteStream.readUint16();
        var tag = "x" + ('00000000' + (groupNumber + elementNumber).toString(16)).substr(-8);
        return tag;
    };

    return dicomParser;
}(dicomParser));
/**
 *
 * Internal helper function to create a shared copy of a byteArray
 *
 */
var dicomParser = (function (dicomParser)
{
  "use strict";

  if(dicomParser === undefined)
  {
    dicomParser = {};
  }

  /**
   * Creates a view of the underlying byteArray.  The view is of the same type as the byteArray (e.g.
   * Uint8Array or Buffer) and shares the same underlying memory (changing one changes the other)
   * @param byteArray the underlying byteArray (either Uint8Array or Buffer)
   * @param byteOffset offset into the underlying byteArray to create the view of
   * @param length number of bytes in the view
   * @returns {object} Uint8Array or Buffer depending on the type of byteArray
   */
  dicomParser.sharedCopy = function(byteArray, byteOffset, length) {
    if (typeof Buffer !== 'undefined' && byteArray instanceof Buffer) {
      return byteArray.slice(byteOffset, byteOffset + length);
    }
    else if(byteArray instanceof Uint8Array) {
      return new Uint8Array(byteArray.buffer, byteArray.byteOffset + byteOffset, length);
    } else {
      throw 'dicomParser.from: unknown type for byteArray';
    }
  };

  return dicomParser;
}(dicomParser));
/**
 * Version
 */

var dicomParser = (function (dicomParser)
{
  "use strict";

  if(dicomParser === undefined)
  {
    dicomParser = {};
  }

  dicomParser.version = "1.7.3";

  return dicomParser;
}(dicomParser));
    return dicomParser;
}));

}).call(this,require("buffer").Buffer)

},{"buffer":20,"zlib":18}],26:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      } else {
        // At least give some kind of context to the user
        var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
        err.context = er;
        throw err;
      }
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        args = Array.prototype.slice.call(arguments, 1);
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    args = Array.prototype.slice.call(arguments, 1);
    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else if (listeners) {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.prototype.listenerCount = function(type) {
  if (this._events) {
    var evlistener = this._events[type];

    if (isFunction(evlistener))
      return 1;
    else if (evlistener)
      return evlistener.length;
  }
  return 0;
};

EventEmitter.listenerCount = function(emitter, type) {
  return emitter.listenerCount(type);
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}

},{}],27:[function(require,module,exports){
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],28:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],29:[function(require,module,exports){
/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */

// The _isBuffer check is for Safari 5-7 support, because it's missing
// Object.prototype.constructor. Remove this eventually
module.exports = function (obj) {
  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)
}

function isBuffer (obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
}

// For Node v0.10 support. Remove this eventually.
function isSlowBuffer (obj) {
  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))
}

},{}],30:[function(require,module,exports){
/*
 * Copyright (C) 2015 Michael Martinez
 * Changes: Added support for selection values 2-7, fixed minor bugs &
 * warnings, split into multiple class files, and general clean up.
 *
 * 08-25-2015: Helmut Dersch agreed to a license change from LGPL to MIT.
 */

/*
 * Copyright (C) Helmut Dersch
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:

 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/*jslint browser: true, node: true */
/*global require, module */

"use strict";

/*** Imports ***/
var jpeg = jpeg || {};
jpeg.lossless = jpeg.lossless || {};


/*** Constructor ***/
jpeg.lossless.ComponentSpec = jpeg.lossless.ComponentSpec || function () {
    this.hSamp = 0; // Horizontal sampling factor
    this.quantTableSel = 0; // Quantization table destination selector
    this.vSamp = 0; // Vertical
};


/*** Exports ***/

var moduleType = typeof module;
if ((moduleType !== 'undefined') && module.exports) {
    module.exports = jpeg.lossless.ComponentSpec;
}

},{}],31:[function(require,module,exports){
/*
 * Copyright (C) 2015 Michael Martinez
 * Changes: Added support for selection values 2-7, fixed minor bugs &
 * warnings, split into multiple class files, and general clean up.
 *
 * 08-25-2015: Helmut Dersch agreed to a license change from LGPL to MIT.
 */

/*
 * Copyright (C) Helmut Dersch
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:

 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/*jslint browser: true, node: true */
/*global require, module */

"use strict";

/*** Imports ***/
var jpeg = jpeg || {};
jpeg.lossless = jpeg.lossless || {};


/*** Constructor ***/
jpeg.lossless.DataStream = jpeg.lossless.DataStream || function (data, offset, length) {
    this.buffer = new DataView(data, offset, length);
    this.index = 0;
};



jpeg.lossless.DataStream.prototype.get16 = function () {
    var value = this.buffer.getUint16(this.index, false);
    this.index += 2;
    return value;
};



jpeg.lossless.DataStream.prototype.get8 = function () {
    var value = this.buffer.getUint8(this.index);
    this.index += 1;
    return value;
};


/*** Exports ***/

var moduleType = typeof module;
if ((moduleType !== 'undefined') && module.exports) {
    module.exports = jpeg.lossless.DataStream;
}

},{}],32:[function(require,module,exports){
/*
 * Copyright (C) 2015 Michael Martinez
 * Changes: Added support for selection values 2-7, fixed minor bugs &
 * warnings, split into multiple class files, and general clean up.
 *
 * 08-25-2015: Helmut Dersch agreed to a license change from LGPL to MIT.
 */

/*
 * Copyright (C) Helmut Dersch
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:

 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/*jslint browser: true, node: true */
/*global require, module */

"use strict";

/*** Imports ***/
var jpeg = jpeg || {};
jpeg.lossless = jpeg.lossless || {};
jpeg.lossless.DataStream = jpeg.lossless.DataStream || ((typeof require !== 'undefined') ? require('./data-stream.js') : null);
jpeg.lossless.HuffmanTable = jpeg.lossless.HuffmanTable || ((typeof require !== 'undefined') ? require('./huffman-table.js') : null);
jpeg.lossless.QuantizationTable = jpeg.lossless.QuantizationTable || ((typeof require !== 'undefined') ? require('./quantization-table.js') : null);
jpeg.lossless.ScanHeader = jpeg.lossless.ScanHeader || ((typeof require !== 'undefined') ? require('./scan-header.js') : null);
jpeg.lossless.FrameHeader = jpeg.lossless.FrameHeader || ((typeof require !== 'undefined') ? require('./frame-header.js') : null);
jpeg.lossless.Utils = jpeg.lossless.Utils || ((typeof require !== 'undefined') ? require('./utils.js') : null);


/*** Constructor ***/
jpeg.lossless.Decoder = jpeg.lossless.Decoder || function (buffer, numBytes) {
    this.buffer = buffer;
    this.frame = new jpeg.lossless.FrameHeader();
    this.huffTable = new jpeg.lossless.HuffmanTable();
    this.quantTable = new jpeg.lossless.QuantizationTable();
    this.scan = new jpeg.lossless.ScanHeader();
    this.DU = jpeg.lossless.Utils.createArray(10, 4, 64); // at most 10 data units in a MCU, at most 4 data units in one component
    this.HuffTab = jpeg.lossless.Utils.createArray(4, 2, 50 * 256);
    this.IDCT_Source = [];
    this.nBlock = []; // number of blocks in the i-th Comp in a scan
    this.acTab = jpeg.lossless.Utils.createArray(10, 1); // ac HuffTab for the i-th Comp in a scan
    this.dcTab = jpeg.lossless.Utils.createArray(10, 1); // dc HuffTab for the i-th Comp in a scan
    this.qTab = jpeg.lossless.Utils.createArray(10, 1); // quantization table for the i-th Comp in a scan
    this.marker = 0;
    this.markerIndex = 0;
    this.numComp = 0;
    this.restartInterval = 0;
    this.selection = 0;
    this.xDim = 0;
    this.yDim = 0;
    this.xLoc = 0;
    this.yLoc = 0;
    this.numBytes = 0;
    this.outputData = null;
    this.restarting = false;
    this.mask = 0;

    if (typeof numBytes !== "undefined") {
        this.numBytes = numBytes;
    }
};


/*** Static Pseudo-constants ***/

jpeg.lossless.Decoder.IDCT_P = [0, 5, 40, 16, 45, 2, 7, 42, 21, 56, 8, 61, 18, 47, 1, 4, 41, 23, 58, 13, 32, 24, 37, 10, 63, 17, 44, 3, 6, 43, 20,
    57, 15, 34, 29, 48, 53, 26, 39, 9, 60, 19, 46, 22, 59, 12, 33, 31, 50, 55, 25, 36, 11, 62, 14, 35, 28, 49, 52, 27, 38, 30, 51, 54];
jpeg.lossless.Decoder.TABLE = [0, 1, 5, 6, 14, 15, 27, 28, 2, 4, 7, 13, 16, 26, 29, 42, 3, 8, 12, 17, 25, 30, 41, 43, 9, 11, 18, 24, 31, 40, 44, 53,
    10, 19, 23, 32, 39, 45, 52, 54, 20, 22, 33, 38, 46, 51, 55, 60, 21, 34, 37, 47, 50, 56, 59, 61, 35, 36, 48, 49, 57, 58, 62, 63];
jpeg.lossless.Decoder.MAX_HUFFMAN_SUBTREE = 50;
jpeg.lossless.Decoder.MSB = 0x80000000;
jpeg.lossless.Decoder.RESTART_MARKER_BEGIN = 0xFFD0;
jpeg.lossless.Decoder.RESTART_MARKER_END = 0xFFD7;

/*** Prototype Methods ***/

jpeg.lossless.Decoder.prototype.decompress = function (buffer, offset, length) {
    return this.decode(buffer, offset, length).buffer;
};



jpeg.lossless.Decoder.prototype.decode = function (buffer, offset, length, numBytes) {
    /*jslint bitwise: true */

    var current, scanNum = 0, pred = [], i, compN, temp = [], index = [], mcuNum;

    if (typeof buffer !== "undefined") {
        this.buffer = buffer;
    }

    if (typeof numBytes !== "undefined") {
        this.numBytes = numBytes;
    }

    this.stream = new jpeg.lossless.DataStream(this.buffer, offset, length);
    this.buffer = null;

    this.xLoc = 0;
    this.yLoc = 0;
    current = this.stream.get16();

    if (current !== 0xFFD8) { // SOI
        throw new Error("Not a JPEG file");
    }

    current = this.stream.get16();

    while ((((current >> 4) !== 0x0FFC) || (current === 0xFFC4))) { // SOF 0~15
        switch (current) {
            case 0xFFC4: // DHT
                this.huffTable.read(this.stream, this.HuffTab);
                break;
            case 0xFFCC: // DAC
                throw new Error("Program doesn't support arithmetic coding. (format throw new IOException)");
            case 0xFFDB:
                this.quantTable.read(this.stream, jpeg.lossless.Decoder.TABLE);
                break;
            case 0xFFDD:
                this.restartInterval = this.readNumber();
                break;
            case 0xFFE0:
            case 0xFFE1:
            case 0xFFE2:
            case 0xFFE3:
            case 0xFFE4:
            case 0xFFE5:
            case 0xFFE6:
            case 0xFFE7:
            case 0xFFE8:
            case 0xFFE9:
            case 0xFFEA:
            case 0xFFEB:
            case 0xFFEC:
            case 0xFFED:
            case 0xFFEE:
            case 0xFFEF:
                this.readApp();
                break;
            case 0xFFFE:
                this.readComment();
                break;
            default:
                if ((current >> 8) !== 0xFF) {
                    throw new Error("ERROR: format throw new IOException! (decode)");
                }
        }

        current = this.stream.get16();
    }

    if ((current < 0xFFC0) || (current > 0xFFC7)) {
        throw new Error("ERROR: could not handle arithmetic code!");
    }

    this.frame.read(this.stream);
    current = this.stream.get16();

    do {
        while (current !== 0x0FFDA) { // SOS
            switch (current) {
                case 0xFFC4: // DHT
                    this.huffTable.read(this.stream, this.HuffTab);
                    break;
                case 0xFFCC: // DAC
                    throw new Error("Program doesn't support arithmetic coding. (format throw new IOException)");
                case 0xFFDB:
                    this.quantTable.read(this.stream, jpeg.lossless.Decoder.TABLE);
                    break;
                case 0xFFDD:
                    this.restartInterval = this.readNumber();
                    break;
                case 0xFFE0:
                case 0xFFE1:
                case 0xFFE2:
                case 0xFFE3:
                case 0xFFE4:
                case 0xFFE5:
                case 0xFFE6:
                case 0xFFE7:
                case 0xFFE8:
                case 0xFFE9:
                case 0xFFEA:
                case 0xFFEB:
                case 0xFFEC:
                case 0xFFED:
                case 0xFFEE:
                case 0xFFEF:
                    this.readApp();
                    break;
                case 0xFFFE:
                    this.readComment();
                    break;
                default:
                    if ((current >> 8) !== 0xFF) {
                        throw new Error("ERROR: format throw new IOException! (Parser.decode)");
                    }
            }

            current = this.stream.get16();
        }

        this.precision = this.frame.precision;
        this.components = this.frame.components;

        if (!this.numBytes) {
            this.numBytes = parseInt(Math.ceil(this.precision / 8));
        }

        if (this.numBytes == 1) {
            this.mask = 0xFF;
        } else {
            this.mask = 0xFFFF;
        }

        this.scan.read(this.stream);
        this.numComp = this.scan.numComp;
        this.selection = this.scan.selection;

        if (this.numBytes === 1) {
            if (this.numComp === 3) {
                this.getter = this.getValueRGB;
                this.setter = this.setValueRGB;
                this.output = this.outputRGB;
            } else {
                this.getter = this.getValue8;
                this.setter = this.setValue8;
                this.output = this.outputSingle;
            }
        } else {
            this.getter = this.getValue16;
            this.setter = this.setValue16;
            this.output = this.outputSingle;
        }

        switch (this.selection) {
            case 2:
                this.selector = this.select2;
                break;
            case 3:
                this.selector = this.select3;
                break;
            case 4:
                this.selector = this.select4;
                break;
            case 5:
                this.selector = this.select5;
                break;
            case 6:
                this.selector = this.select6;
                break;
            case 7:
                this.selector = this.select7;
                break;
            default:
                this.selector = this.select1;
                break;
        }

        this.scanComps = this.scan.components;
        this.quantTables = this.quantTable.quantTables;

        for (i = 0; i < this.numComp; i+=1) {
            compN = this.scanComps[i].scanCompSel;
            this.qTab[i] = this.quantTables[this.components[compN].quantTableSel];
            this.nBlock[i] = this.components[compN].vSamp * this.components[compN].hSamp;
            this.dcTab[i] = this.HuffTab[this.scanComps[i].dcTabSel][0];
            this.acTab[i] = this.HuffTab[this.scanComps[i].acTabSel][1];
        }

        this.xDim = this.frame.dimX;
        this.yDim = this.frame.dimY;
        this.outputData = new DataView(new ArrayBuffer(this.xDim * this.yDim * this.numBytes * this.numComp));

        scanNum+=1;

        while (true) { // Decode one scan
            temp[0] = 0;
            index[0] = 0;

            for (i = 0; i < 10; i+=1) {
                pred[i] = (1 << (this.precision - 1));
            }

            if (this.restartInterval === 0) {
                current = this.decodeUnit(pred, temp, index);

                while ((current === 0) && ((this.xLoc < this.xDim) && (this.yLoc < this.yDim))) {
                    this.output(pred);
                    current = this.decodeUnit(pred, temp, index);
                }

                break; //current=MARKER
            }

            for (mcuNum = 0; mcuNum < this.restartInterval; mcuNum+=1) {
                this.restarting = (mcuNum == 0);
                current = this.decodeUnit(pred, temp, index);
                this.output(pred);

                if (current !== 0) {
                    break;
                }
            }

            if (current === 0) {
                if (this.markerIndex !== 0) {
                    current = (0xFF00 | this.marker);
                    this.markerIndex = 0;
                } else {
                    current = this.stream.get16();
                }
            }

            if (!((current >= jpeg.lossless.Decoder.RESTART_MARKER_BEGIN) &&
                (current <= jpeg.lossless.Decoder.RESTART_MARKER_END))) {
                break; //current=MARKER
            }
        }

        if ((current === 0xFFDC) && (scanNum === 1)) { //DNL
            this.readNumber();
            current = this.stream.get16();
        }
    } while ((current !== 0xFFD9) && ((this.xLoc < this.xDim) && (this.yLoc < this.yDim)) && (scanNum === 0));

    return this.outputData;
};



jpeg.lossless.Decoder.prototype.decodeUnit = function (prev, temp, index) {
    if (this.numComp == 1) {
        return this.decodeSingle(prev, temp, index);
    } else if (this.numComp == 3) {
        return this.decodeRGB(prev, temp, index);
    } else {
        return -1;
    }
};



jpeg.lossless.Decoder.prototype.select1 = function (compOffset) {
    return this.getPreviousX(compOffset);
};



jpeg.lossless.Decoder.prototype.select2 = function (compOffset) {
    return this.getPreviousY(compOffset);
};



jpeg.lossless.Decoder.prototype.select3 = function (compOffset) {
    return this.getPreviousXY(compOffset);
};



jpeg.lossless.Decoder.prototype.select4 = function (compOffset) {
    return (this.getPreviousX(compOffset) + this.getPreviousY(compOffset)) - this.getPreviousXY(compOffset);
};



jpeg.lossless.Decoder.prototype.select5 = function (compOffset) {
    return this.getPreviousX(compOffset) + ((this.getPreviousY(compOffset) - this.getPreviousXY(compOffset)) >> 1);
};



jpeg.lossless.Decoder.prototype.select6 = function (compOffset) {
    return this.getPreviousY(compOffset) + ((this.getPreviousX(compOffset) - this.getPreviousXY(compOffset)) >> 1);
};



jpeg.lossless.Decoder.prototype.select7 = function (compOffset) {
    return ((this.getPreviousX(compOffset) + this.getPreviousY(compOffset)) / 2);
};



jpeg.lossless.Decoder.prototype.decodeRGB = function (prev, temp, index) {
    /*jslint bitwise: true */

    var value, actab, dctab, qtab, ctrC, i, k, j;

    prev[0] = this.selector(0);
    prev[1] = this.selector(1);
    prev[2] = this.selector(2);

    for (ctrC = 0; ctrC < this.numComp; ctrC+=1) {
        qtab = this.qTab[ctrC];
        actab = this.acTab[ctrC];
        dctab = this.dcTab[ctrC];
        for (i = 0; i < this.nBlock[ctrC]; i+=1) {
            for (k = 0; k < this.IDCT_Source.length; k+=1) {
                this.IDCT_Source[k] = 0;
            }

            value = this.getHuffmanValue(dctab, temp, index);

            if (value >= 0xFF00) {
                return value;
            }

            prev[ctrC] = this.IDCT_Source[0] = prev[ctrC] + this.getn(index, value, temp, index);
            this.IDCT_Source[0] *= qtab[0];

            for (j = 1; j < 64; j+=1) {
                value = this.getHuffmanValue(actab, temp, index);

                if (value >= 0xFF00) {
                    return value;
                }

                j += (value >> 4);

                if ((value & 0x0F) === 0) {
                    if ((value >> 4) === 0) {
                        break;
                    }
                } else {
                    this.IDCT_Source[jpeg.lossless.Decoder.IDCT_P[j]] = this.getn(index, value & 0x0F, temp, index) * qtab[j];
                }
            }
        }
    }

    return 0;
};



jpeg.lossless.Decoder.prototype.decodeSingle = function (prev, temp, index) {
    /*jslint bitwise: true */

    var value, i, n, nRestart;

    if (this.restarting) {
        this.restarting = false;
        prev[0] = (1 << (this.frame.precision - 1));
    } else {
        prev[0] = this.selector();
    }

    for (i = 0; i < this.nBlock[0]; i+=1) {
        value = this.getHuffmanValue(this.dcTab[0], temp, index);
        if (value >= 0xFF00) {
            return value;
        }

        n = this.getn(prev, value, temp, index);
        nRestart = (n >> 8);

        if ((nRestart >= jpeg.lossless.Decoder.RESTART_MARKER_BEGIN) && (nRestart <= jpeg.lossless.Decoder.RESTART_MARKER_END)) {
            return nRestart;
        }

        prev[0] += n;
    }

    return 0;
};



//	Huffman table for fast search: (HuffTab) 8-bit Look up table 2-layer search architecture, 1st-layer represent 256 node (8 bits) if codeword-length > 8
//	bits, then the entry of 1st-layer = (# of 2nd-layer table) | MSB and it is stored in the 2nd-layer Size of tables in each layer are 256.
//	HuffTab[*][*][0-256] is always the only 1st-layer table.
//
//	An entry can be: (1) (# of 2nd-layer table) | MSB , for code length > 8 in 1st-layer (2) (Code length) << 8 | HuffVal
//
//	HuffmanValue(table   HuffTab[x][y] (ex) HuffmanValue(HuffTab[1][0],...)
//	                ):
//	    return: Huffman Value of table
//	            0xFF?? if it receives a MARKER
//	    Parameter:  table   HuffTab[x][y] (ex) HuffmanValue(HuffTab[1][0],...)
//	                temp    temp storage for remainded bits
//	                index   index to bit of temp
//	                in      FILE pointer
//	    Effect:
//	        temp  store new remainded bits
//	        index change to new index
//	        in    change to new position
//	    NOTE:
//	      Initial by   temp=0; index=0;
//	    NOTE: (explain temp and index)
//	      temp: is always in the form at calling time or returning time
//	       |  byte 4  |  byte 3  |  byte 2  |  byte 1  |
//	       |     0    |     0    | 00000000 | 00000??? |  if not a MARKER
//	                                               ^index=3 (from 0 to 15)
//	                                               321
//	    NOTE (marker and marker_index):
//	      If get a MARKER from 'in', marker=the low-byte of the MARKER
//	        and marker_index=9
//	      If marker_index=9 then index is always > 8, or HuffmanValue()
//	        will not be called
jpeg.lossless.Decoder.prototype.getHuffmanValue = function (table, temp, index) {
    /*jslint bitwise: true */

    var code, input, mask;
    mask = 0xFFFF;

    if (index[0] < 8) {
        temp[0] <<= 8;
        input = this.stream.get8();
        if (input === 0xFF) {
            this.marker = this.stream.get8();
            if (this.marker !== 0) {
                this.markerIndex = 9;
            }
        }
        temp[0] |= input;
    } else {
        index[0] -= 8;
    }

    code = table[temp[0] >> index[0]];

    if ((code & jpeg.lossless.Decoder.MSB) !== 0) {
        if (this.markerIndex !== 0) {
            this.markerIndex = 0;
            return 0xFF00 | this.marker;
        }

        temp[0] &= (mask >> (16 - index[0]));
        temp[0] <<= 8;
        input = this.stream.get8();

        if (input === 0xFF) {
            this.marker = this.stream.get8();
            if (this.marker !== 0) {
                this.markerIndex = 9;
            }
        }

        temp[0] |= input;
        code = table[((code & 0xFF) * 256) + (temp[0] >> index[0])];
        index[0] += 8;
    }

    index[0] += 8 - (code >> 8);

    if (index[0] < 0) {
        throw new Error("index=" + index[0] + " temp=" + temp[0] + " code=" + code + " in HuffmanValue()");
    }

    if (index[0] < this.markerIndex) {
        this.markerIndex = 0;
        return 0xFF00 | this.marker;
    }

    temp[0] &= (mask >> (16 - index[0]));
    return code & 0xFF;
};



jpeg.lossless.Decoder.prototype.getn = function (PRED, n, temp, index) {
    /*jslint bitwise: true */

    var result, one, n_one, mask, input;
    one = 1;
    n_one = -1;
    mask = 0xFFFF;

    if (n === 0) {
        return 0;
    }

    if (n === 16) {
        if (PRED[0] >= 0) {
            return -32768;
        } else {
            return 32768;
        }
    }

    index[0] -= n;

    if (index[0] >= 0) {
        if ((index[0] < this.markerIndex) && !this.isLastPixel()) { // this was corrupting the last pixel in some cases
            this.markerIndex = 0;
            return (0xFF00 | this.marker) << 8;
        }

        result = temp[0] >> index[0];
        temp[0] &= (mask >> (16 - index[0]));
    } else {
        temp[0] <<= 8;
        input = this.stream.get8();

        if (input === 0xFF) {
            this.marker = this.stream.get8();
            if (this.marker !== 0) {
                this.markerIndex = 9;
            }
        }

        temp[0] |= input;
        index[0] += 8;

        if (index[0] < 0) {
            if (this.markerIndex !== 0) {
                this.markerIndex = 0;
                return (0xFF00 | this.marker) << 8;
            }

            temp[0] <<= 8;
            input = this.stream.get8();

            if (input === 0xFF) {
                this.marker = this.stream.get8();
                if (this.marker !== 0) {
                    this.markerIndex = 9;
                }
            }

            temp[0] |= input;
            index[0] += 8;
        }

        if (index[0] < 0) {
            throw new Error("index=" + index[0] + " in getn()");
        }

        if (index[0] < this.markerIndex) {
            this.markerIndex = 0;
            return (0xFF00 | this.marker) << 8;
        }

        result = temp[0] >> index[0];
        temp[0] &= (mask >> (16 - index[0]));
    }

    if (result < (one << (n - 1))) {
        result += (n_one << n) + 1;
    }

    return result;
};



jpeg.lossless.Decoder.prototype.getPreviousX = function (compOffset) {
    /*jslint bitwise: true */

    if (this.xLoc > 0) {
        return this.getter((((this.yLoc * this.xDim) + this.xLoc) - 1), compOffset);
    } else if (this.yLoc > 0) {
        return this.getPreviousY(compOffset);
    } else {
        return (1 << (this.frame.precision - 1));
    }
};



jpeg.lossless.Decoder.prototype.getPreviousXY = function (compOffset) {
    /*jslint bitwise: true */

    if ((this.xLoc > 0) && (this.yLoc > 0)) {
        return this.getter(((((this.yLoc - 1) * this.xDim) + this.xLoc) - 1), compOffset);
    } else {
        return this.getPreviousY(compOffset);
    }
};



jpeg.lossless.Decoder.prototype.getPreviousY = function (compOffset) {
    /*jslint bitwise: true */

    if (this.yLoc > 0) {
        return this.getter((((this.yLoc - 1) * this.xDim) + this.xLoc), compOffset);
    } else {
        return this.getPreviousX(compOffset);
    }
};



jpeg.lossless.Decoder.prototype.isLastPixel = function () {
    return (this.xLoc === (this.xDim - 1)) && (this.yLoc === (this.yDim - 1));
};



jpeg.lossless.Decoder.prototype.outputSingle = function (PRED) {
    if ((this.xLoc < this.xDim) && (this.yLoc < this.yDim)) {
        this.setter((((this.yLoc * this.xDim) + this.xLoc)), this.mask & PRED[0]);

        this.xLoc+=1;

        if (this.xLoc >= this.xDim) {
            this.yLoc+=1;
            this.xLoc = 0;
        }
    }
};



jpeg.lossless.Decoder.prototype.outputRGB = function (PRED) {
    var offset = ((this.yLoc * this.xDim) + this.xLoc);

    if ((this.xLoc < this.xDim) && (this.yLoc < this.yDim)) {
        this.setter(offset, PRED[0], 0);
        this.setter(offset, PRED[1], 1);
        this.setter(offset, PRED[2], 2);

        this.xLoc+=1;

        if (this.xLoc >= this.xDim) {
            this.yLoc+=1;
            this.xLoc = 0;
        }
    }
};



jpeg.lossless.Decoder.prototype.setValue16 = function (index, val) {
    this.outputData.setInt16(index * 2, val, true);
};



jpeg.lossless.Decoder.prototype.getValue16 = function (index) {
    return this.outputData.getInt16(index * 2, true);
};



jpeg.lossless.Decoder.prototype.setValue8 = function (index, val) {
    this.outputData.setInt8(index, val);
};



jpeg.lossless.Decoder.prototype.getValue8 = function (index) {
    return this.outputData.getInt8(index);
};



jpeg.lossless.Decoder.prototype.setValueRGB = function (index, val, compOffset) {
    this.outputData.setUint8(index * 3 + compOffset, val);
};



jpeg.lossless.Decoder.prototype.getValueRGB = function (index, compOffset) {
    return this.outputData.getUint8(index * 3 + compOffset);
};



jpeg.lossless.Decoder.prototype.readApp = function() {
    var count = 0, length = this.stream.get16();
    count += 2;

    while (count < length) {
        this.stream.get8();
        count+=1;
    }

    return length;
};



jpeg.lossless.Decoder.prototype.readComment = function () {
    var sb = "", count = 0, length;

    length = this.stream.get16();
    count += 2;

    while (count < length) {
        sb += this.stream.get8();
        count+=1;
    }

    return sb;
};



jpeg.lossless.Decoder.prototype.readNumber = function() {
    var Ld = this.stream.get16();

    if (Ld !== 4) {
        throw new Error("ERROR: Define number format throw new IOException [Ld!=4]");
    }

    return this.stream.get16();
};



/*** Exports ***/

var moduleType = typeof module;
if ((moduleType !== 'undefined') && module.exports) {
    module.exports = jpeg.lossless.Decoder;
}

},{"./data-stream.js":31,"./frame-header.js":33,"./huffman-table.js":34,"./quantization-table.js":36,"./scan-header.js":38,"./utils.js":39}],33:[function(require,module,exports){
/*
 * Copyright (C) 2015 Michael Martinez
 * Changes: Added support for selection values 2-7, fixed minor bugs &
 * warnings, split into multiple class files, and general clean up.
 *
 * 08-25-2015: Helmut Dersch agreed to a license change from LGPL to MIT.
 */

/*
 * Copyright (C) Helmut Dersch
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:

 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/*jslint browser: true, node: true */
/*global require, module */

"use strict";

/*** Imports ***/
var jpeg = jpeg || {};
jpeg.lossless = jpeg.lossless || {};
jpeg.lossless.ComponentSpec = jpeg.lossless.ComponentSpec || ((typeof require !== 'undefined') ? require('./component-spec.js') : null);
jpeg.lossless.DataStream = jpeg.lossless.DataStream || ((typeof require !== 'undefined') ? require('./data-stream.js') : null);


/*** Constructor ***/
jpeg.lossless.FrameHeader = jpeg.lossless.FrameHeader || function () {
    this.components = []; // Components
    this.dimX = 0; // Number of samples per line
    this.dimY = 0; // Number of lines
    this.numComp = 0; // Number of component in the frame
    this.precision = 0; // Sample Precision (from the original image)
};



/*** Prototype Methods ***/

jpeg.lossless.FrameHeader.prototype.read = function (data) {
    /*jslint bitwise: true */

    var count = 0, length, i, c, temp;

    length = data.get16();
    count += 2;

    this.precision = data.get8();
    count+=1;

    this.dimY = data.get16();
    count += 2;

    this.dimX = data.get16();
    count += 2;

    this.numComp = data.get8();
    count+=1;
    for (i = 1; i <= this.numComp; i+=1) {
        if (count > length) {
            throw new Error("ERROR: frame format error");
        }

        c = data.get8();
        count+=1;

        if (count >= length) {
            throw new Error("ERROR: frame format error [c>=Lf]");
        }

        temp = data.get8();
        count+=1;

        if (!this.components[c]) {
            this.components[c] = new jpeg.lossless.ComponentSpec();
        }

        this.components[c].hSamp = temp >> 4;
        this.components[c].vSamp = temp & 0x0F;
        this.components[c].quantTableSel = data.get8();
        count+=1;
    }

    if (count !== length) {
        throw new Error("ERROR: frame format error [Lf!=count]");
    }

    return 1;
};


/*** Exports ***/

var moduleType = typeof module;
if ((moduleType !== 'undefined') && module.exports) {
    module.exports = jpeg.lossless.FrameHeader;
}

},{"./component-spec.js":30,"./data-stream.js":31}],34:[function(require,module,exports){
/*
 * Copyright (C) 2015 Michael Martinez
 * Changes: Added support for selection values 2-7, fixed minor bugs &
 * warnings, split into multiple class files, and general clean up.
 *
 * 08-25-2015: Helmut Dersch agreed to a license change from LGPL to MIT.
 */

/*
 * Copyright (C) Helmut Dersch
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:

 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/*jslint browser: true, node: true */
/*global require, module */

"use strict";

/*** Imports ***/
var jpeg = jpeg || {};
jpeg.lossless = jpeg.lossless || {};
jpeg.lossless.DataStream = jpeg.lossless.DataStream || ((typeof require !== 'undefined') ? require('./data-stream.js') : null);
jpeg.lossless.Utils = jpeg.lossless.Utils || ((typeof require !== 'undefined') ? require('./utils.js') : null);


/*** Constructor ***/
jpeg.lossless.HuffmanTable = jpeg.lossless.HuffmanTable || function () {
    this.l = jpeg.lossless.Utils.createArray(4, 2, 16);
    this.th = [];
    this.v = jpeg.lossless.Utils.createArray(4, 2, 16, 200);
    this.tc = jpeg.lossless.Utils.createArray(4, 2);

    this.tc[0][0] = 0;
    this.tc[1][0] = 0;
    this.tc[2][0] = 0;
    this.tc[3][0] = 0;
    this.tc[0][1] = 0;
    this.tc[1][1] = 0;
    this.tc[2][1] = 0;
    this.tc[3][1] = 0;
    this.th[0] = 0;
    this.th[1] = 0;
    this.th[2] = 0;
    this.th[3] = 0;
};



/*** Static Pseudo-constants ***/

jpeg.lossless.HuffmanTable.MSB = 0x80000000;


/*** Prototype Methods ***/

jpeg.lossless.HuffmanTable.prototype.read = function(data, HuffTab) {
    /*jslint bitwise: true */

    var count = 0, length, temp, t, c, i, j;

    length = data.get16();
    count += 2;

    while (count < length) {
        temp = data.get8();
        count+=1;
        t = temp & 0x0F;
        if (t > 3) {
            throw new Error("ERROR: Huffman table ID > 3");
        }

        c = temp >> 4;
        if (c > 2) {
            throw new Error("ERROR: Huffman table [Table class > 2 ]");
        }

        this.th[t] = 1;
        this.tc[t][c] = 1;

        for (i = 0; i < 16; i+=1) {
            this.l[t][c][i] = data.get8();
            count+=1;
        }

        for (i = 0; i < 16; i+=1) {
            for (j = 0; j < this.l[t][c][i]; j+=1) {
                if (count > length) {
                    throw new Error("ERROR: Huffman table format error [count>Lh]");
                }

                this.v[t][c][i][j] = data.get8();
                count+=1;
            }
        }
    }

    if (count !== length) {
        throw new Error("ERROR: Huffman table format error [count!=Lf]");
    }

    for (i = 0; i < 4; i+=1) {
        for (j = 0; j < 2; j+=1) {
            if (this.tc[i][j] !== 0) {
                this.buildHuffTable(HuffTab[i][j], this.l[i][j], this.v[i][j]);
            }
        }
    }

    return 1;
};



//	Build_HuffTab()
//	Parameter:  t       table ID
//	            c       table class ( 0 for DC, 1 for AC )
//	            L[i]    # of codewords which length is i
//	            V[i][j] Huffman Value (length=i)
//	Effect:
//	    build up HuffTab[t][c] using L and V.
jpeg.lossless.HuffmanTable.prototype.buildHuffTable = function(tab, L, V) {
    /*jslint bitwise: true */

    var currentTable, temp, k, i, j, n;
    temp = 256;
    k = 0;

    for (i = 0; i < 8; i+=1) { // i+1 is Code length
        for (j = 0; j < L[i]; j+=1) {
            for (n = 0; n < (temp >> (i + 1)); n+=1) {
                tab[k] = V[i][j] | ((i + 1) << 8);
                k+=1;
            }
        }
    }

    for (i = 1; k < 256; i+=1, k+=1) {
        tab[k] = i | jpeg.lossless.HuffmanTable.MSB;
    }

    currentTable = 1;
    k = 0;

    for (i = 8; i < 16; i+=1) { // i+1 is Code length
        for (j = 0; j < L[i]; j+=1) {
            for (n = 0; n < (temp >> (i - 7)); n+=1) {
                tab[(currentTable * 256) + k] = V[i][j] | ((i + 1) << 8);
                k+=1;
            }

            if (k >= 256) {
                if (k > 256) {
                    throw new Error("ERROR: Huffman table error(1)!");
                }

                k = 0;
                currentTable+=1;
            }
        }
    }
};


/*** Exports ***/

var moduleType = typeof module;
if ((moduleType !== 'undefined') && module.exports) {
    module.exports = jpeg.lossless.HuffmanTable;
}

},{"./data-stream.js":31,"./utils.js":39}],35:[function(require,module,exports){
/*jslint browser: true, node: true */
/*global require, module */

"use strict";

/*** Imports ***/
var jpeg = jpeg || {};
jpeg.lossless = jpeg.lossless || {};
jpeg.lossless.ComponentSpec = jpeg.lossless.ComponentSpec || ((typeof require !== 'undefined') ? require('./component-spec.js') : null);
jpeg.lossless.DataStream = jpeg.lossless.DataStream || ((typeof require !== 'undefined') ? require('./data-stream.js') : null);
jpeg.lossless.Decoder = jpeg.lossless.Decoder || ((typeof require !== 'undefined') ? require('./decoder.js') : null);
jpeg.lossless.FrameHeader = jpeg.lossless.FrameHeader || ((typeof require !== 'undefined') ? require('./frame-header.js') : null);
jpeg.lossless.HuffmanTable = jpeg.lossless.HuffmanTable || ((typeof require !== 'undefined') ? require('./huffman-table.js') : null);
jpeg.lossless.QuantizationTable = jpeg.lossless.QuantizationTable || ((typeof require !== 'undefined') ? require('./quantization-table.js') : null);
jpeg.lossless.ScanComponent = jpeg.lossless.ScanComponent || ((typeof require !== 'undefined') ? require('./scan-component.js') : null);
jpeg.lossless.ScanHeader = jpeg.lossless.ScanHeader || ((typeof require !== 'undefined') ? require('./scan-header.js') : null);
jpeg.lossless.Utils = jpeg.lossless.Utils || ((typeof require !== 'undefined') ? require('./utils.js') : null);


/*** Exports ***/
var moduleType = typeof module;
if ((moduleType !== 'undefined') && module.exports) {
    module.exports = jpeg;
}

},{"./component-spec.js":30,"./data-stream.js":31,"./decoder.js":32,"./frame-header.js":33,"./huffman-table.js":34,"./quantization-table.js":36,"./scan-component.js":37,"./scan-header.js":38,"./utils.js":39}],36:[function(require,module,exports){
/*
 * Copyright (C) 2015 Michael Martinez
 * Changes: Added support for selection values 2-7, fixed minor bugs &
 * warnings, split into multiple class files, and general clean up.
 *
 * 08-25-2015: Helmut Dersch agreed to a license change from LGPL to MIT.
 */

/*
 * Copyright (C) Helmut Dersch
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:

 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/*jslint browser: true, node: true */
/*global require, module */

"use strict";

/*** Imports ***/
var jpeg = jpeg || {};
jpeg.lossless = jpeg.lossless || {};
jpeg.lossless.DataStream = jpeg.lossless.DataStream || ((typeof require !== 'undefined') ? require('./data-stream.js') : null);
jpeg.lossless.Utils = jpeg.lossless.Utils || ((typeof require !== 'undefined') ? require('./utils.js') : null);


/*** Constructor ***/
jpeg.lossless.QuantizationTable = jpeg.lossless.QuantizationTable || function () {
    this.precision = []; // Quantization precision 8 or 16
    this.tq = []; // 1: this table is presented
    this.quantTables = jpeg.lossless.Utils.createArray(4, 64); // Tables

    this.tq[0] = 0;
    this.tq[1] = 0;
    this.tq[2] = 0;
    this.tq[3] = 0;
};



/*** Static Methods ***/

jpeg.lossless.QuantizationTable.enhanceQuantizationTable = function(qtab, table) {
    /*jslint bitwise: true */

    var i;

    for (i = 0; i < 8; i+=1) {
        qtab[table[(0 * 8) + i]] *= 90;
        qtab[table[(4 * 8) + i]] *= 90;
        qtab[table[(2 * 8) + i]] *= 118;
        qtab[table[(6 * 8) + i]] *= 49;
        qtab[table[(5 * 8) + i]] *= 71;
        qtab[table[(1 * 8) + i]] *= 126;
        qtab[table[(7 * 8) + i]] *= 25;
        qtab[table[(3 * 8) + i]] *= 106;
    }

    for (i = 0; i < 8; i+=1) {
        qtab[table[0 + (8 * i)]] *= 90;
        qtab[table[4 + (8 * i)]] *= 90;
        qtab[table[2 + (8 * i)]] *= 118;
        qtab[table[6 + (8 * i)]] *= 49;
        qtab[table[5 + (8 * i)]] *= 71;
        qtab[table[1 + (8 * i)]] *= 126;
        qtab[table[7 + (8 * i)]] *= 25;
        qtab[table[3 + (8 * i)]] *= 106;
    }

    for (i = 0; i < 64; i+=1) {
        qtab[i] >>= 6;
    }
};


/*** Prototype Methods ***/

jpeg.lossless.QuantizationTable.prototype.read = function (data, table) {
    /*jslint bitwise: true */

    var count = 0, length, temp, t, i;

    length = data.get16();
    count += 2;

    while (count < length) {
        temp = data.get8();
        count+=1;
        t = temp & 0x0F;

        if (t > 3) {
            throw new Error("ERROR: Quantization table ID > 3");
        }

        this.precision[t] = temp >> 4;

        if (this.precision[t] === 0) {
            this.precision[t] = 8;
        } else if (this.precision[t] === 1) {
            this.precision[t] = 16;
        } else {
            throw new Error("ERROR: Quantization table precision error");
        }

        this.tq[t] = 1;

        if (this.precision[t] === 8) {
            for (i = 0; i < 64; i+=1) {
                if (count > length) {
                    throw new Error("ERROR: Quantization table format error");
                }

                this.quantTables[t][i] = data.get8();
                count+=1;
            }

            jpeg.lossless.QuantizationTable.enhanceQuantizationTable(this.quantTables[t], table);
        } else {
            for (i = 0; i < 64; i+=1) {
                if (count > length) {
                    throw new Error("ERROR: Quantization table format error");
                }

                this.quantTables[t][i] = data.get16();
                count += 2;
            }

            jpeg.lossless.QuantizationTable.enhanceQuantizationTable(this.quantTables[t], table);
        }
    }

    if (count !== length) {
        throw new Error("ERROR: Quantization table error [count!=Lq]");
    }

    return 1;
};



/*** Exports ***/

var moduleType = typeof module;
if ((moduleType !== 'undefined') && module.exports) {
    module.exports = jpeg.lossless.QuantizationTable;
}

},{"./data-stream.js":31,"./utils.js":39}],37:[function(require,module,exports){
/*
 * Copyright (C) 2015 Michael Martinez
 * Changes: Added support for selection values 2-7, fixed minor bugs &
 * warnings, split into multiple class files, and general clean up.
 *
 * 08-25-2015: Helmut Dersch agreed to a license change from LGPL to MIT.
 */

/*
 * Copyright (C) Helmut Dersch
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:

 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/*jslint browser: true, node: true */
/*global require, module */

"use strict";

/*** Imports ***/
var jpeg = jpeg || {};
jpeg.lossless = jpeg.lossless || {};


/*** Constructor ***/
jpeg.lossless.ScanComponent = jpeg.lossless.ScanComponent || function () {
    this.acTabSel = 0; // AC table selector
    this.dcTabSel = 0; // DC table selector
    this.scanCompSel = 0; // Scan component selector
};



/*** Exports ***/

var moduleType = typeof module;
if ((moduleType !== 'undefined') && module.exports) {
    module.exports = jpeg.lossless.ScanComponent;
}

},{}],38:[function(require,module,exports){
/*
 * Copyright (C) 2015 Michael Martinez
 * Changes: Added support for selection values 2-7, fixed minor bugs &
 * warnings, split into multiple class files, and general clean up.
 *
 * 08-25-2015: Helmut Dersch agreed to a license change from LGPL to MIT.
 */

/*
 * Copyright (C) Helmut Dersch
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:

 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/*jslint browser: true, node: true */
/*global require, module */

"use strict";

/*** Imports ***/
var jpeg = jpeg || {};
jpeg.lossless = jpeg.lossless || {};
jpeg.lossless.DataStream = jpeg.lossless.DataStream || ((typeof require !== 'undefined') ? require('./data-stream.js') : null);
jpeg.lossless.ScanComponent = jpeg.lossless.ScanComponent || ((typeof require !== 'undefined') ? require('./scan-component.js') : null);


/*** Constructor ***/
jpeg.lossless.ScanHeader = jpeg.lossless.ScanHeader || function () {
    this.ah = 0;
    this.al = 0;
    this.numComp = 0; // Number of components in the scan
    this.selection = 0; // Start of spectral or predictor selection
    this.spectralEnd = 0; // End of spectral selection
    this.components = [];
};


/*** Prototype Methods ***/

jpeg.lossless.ScanHeader.prototype.read = function(data) {
    /*jslint bitwise: true */

    var count = 0, length, i, temp;

    length = data.get16();
    count += 2;

    this.numComp = data.get8();
    count+=1;

    for (i = 0; i < this.numComp; i+=1) {
        this.components[i] = new jpeg.lossless.ScanComponent();

        if (count > length) {
            throw new Error("ERROR: scan header format error");
        }

        this.components[i].scanCompSel = data.get8();
        count+=1;

        temp = data.get8();
        count+=1;

        this.components[i].dcTabSel = (temp >> 4);
        this.components[i].acTabSel = (temp & 0x0F);
    }

    this.selection = data.get8();
    count+=1;

    this.spectralEnd = data.get8();
    count+=1;

    temp = data.get8();
    this.ah = (temp >> 4);
    this.al = (temp & 0x0F);
    count+=1;

    if (count !== length) {
        throw new Error("ERROR: scan header format error [count!=Ns]");
    }

    return 1;
};



/*** Exports ***/

var moduleType = typeof module;
if ((moduleType !== 'undefined') && module.exports) {
    module.exports = jpeg.lossless.ScanHeader;
}

},{"./data-stream.js":31,"./scan-component.js":37}],39:[function(require,module,exports){
/*
 * Copyright (C) 2015 Michael Martinez
 * Changes: Added support for selection values 2-7, fixed minor bugs &
 * warnings, split into multiple class files, and general clean up.
 *
 * 08-25-2015: Helmut Dersch agreed to a license change from LGPL to MIT.
 */

/*
 * Copyright (C) Helmut Dersch
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:

 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/*jslint browser: true, node: true */
/*global require, module */

"use strict";

/*** Imports ***/
var jpeg = jpeg || {};
jpeg.lossless = jpeg.lossless || {};


/*** Constructor ***/
jpeg.lossless.Utils = jpeg.lossless.Utils || {};


/*** Static methods ***/

// http://stackoverflow.com/questions/966225/how-can-i-create-a-two-dimensional-array-in-javascript
jpeg.lossless.Utils.createArray = function (length) {
    var arr = new Array(length || 0),
        i = length;

    if (arguments.length > 1) {
        var args = Array.prototype.slice.call(arguments, 1);
        while(i--) arr[length-1 - i] = jpeg.lossless.Utils.createArray.apply(this, args);
    }

    return arr;
};


// http://stackoverflow.com/questions/18638900/javascript-crc32
jpeg.lossless.Utils.makeCRCTable = function(){
    var c;
    var crcTable = [];
    for(var n =0; n < 256; n++){
        c = n;
        for(var k =0; k < 8; k++){
            c = ((c&1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));
        }
        crcTable[n] = c;
    }
    return crcTable;
};

jpeg.lossless.Utils.crc32 = function(dataView) {
    var crcTable = jpeg.lossless.Utils.crcTable || (jpeg.lossless.Utils.crcTable = jpeg.lossless.Utils.makeCRCTable());
    var crc = 0 ^ (-1);

    for (var i = 0; i < dataView.byteLength; i++ ) {
        crc = (crc >>> 8) ^ crcTable[(crc ^ dataView.getUint8(i)) & 0xFF];
    }

    return (crc ^ (-1)) >>> 0;
};


/*** Exports ***/

var moduleType = typeof module;
if ((moduleType !== 'undefined') && module.exports) {
    module.exports = jpeg.lossless.Utils;
}

},{}],40:[function(require,module,exports){
'use strict';

/**
* FUNCTION: abs( x )
*	Computes the absolute value of `x`.
*
* @param {Number} x - input value
* @returns {Number} absolute value
*/
function abs( x ) {
	if ( x < 0 ) {
		return -x;
	}
	if ( x === 0 ) {
		return 0; // handle negative zero
	}
	return x;
} // end FUNCTION abs()


// EXPORTS //

module.exports = abs;

},{}],41:[function(require,module,exports){
'use strict';

// EXPORTS //

module.exports = Math.ceil;

},{}],42:[function(require,module,exports){
'use strict';

// MODULES //

var floor = require( 'math-floor' );


// DIV2 //

/**
* FUNCTION: div2( x )
*	Converts a nonnegative integer to a literal bit representation using the divide-by-2 algorithm.
*
* @param {Number} x - nonnegative integer
* @returns {String} bit representation
*/
function div2( x ) {
	var str = '';
	var y;

	// We repeatedly divide by 2 and check for a remainder. If a remainder exists, the number is odd and we add a '1' bit...
	while ( x > 0 ) {
		y = x / 2;
		x = floor( y );
		if ( y === x ) {
			str = '0' + str;
		} else {
			str = '1' + str;
		}
	}
	return str;
} // end FUNCTION div2()


// EXPORTS //

module.exports = div2;

},{"math-floor":45}],43:[function(require,module,exports){
'use strict';

// MODULES //

var pinf = require( 'const-pinf-float32' );
var ninf = require( 'const-ninf-float32' );
var abs = require( 'math-abs' );
var floor = require( 'math-floor' );
var rpad = require( 'utils-right-pad-string' );
var lpad = require( 'utils-left-pad-string' );
var repeat = require( 'utils-repeat-string' );
var div2 = require( './div2.js' );
var mult2 = require( './mult2.js' );


// CONSTANTS //

var BIAS = 127; // exponent bias => (2**8)/2 - 1


// BINARY STRING //

/**
* FUNCTION: binaryString( x )
*	Returns a string giving the literal bit representation of a single-precision floating-point number.
*
* @param {Number} x - input value
* @returns {String} bit representation
*/
function binaryString( x ) {
	var nbits;
	var sign;
	var str;
	var exp;
	var n;
	var f;
	var i;

	// Check for a negative value or negative zero...
	if ( x < 0 || 1/x === ninf ) {
		sign = '1';
	} else {
		sign = '0';
	}
	// Special case: +-infinity
	if ( x === pinf || x === ninf ) {
		// Based on IEEE 754-2008...
		exp = repeat( '1', 8 ); // all 1s
		str = repeat( '0', 23 ); // all 0s
		return sign + exp + str;
	}
	// Special case: NaN
	if ( x !== x ) {
		// Based on IEEE 754-2008...
		exp = repeat( '1', 8 ); // all 1s
		str = '1' + repeat( '0', 22 ); // can't be all 0s
		return sign + exp + str;
	}
	// Special case: +-0
	if ( x === 0 ) {
		// Based on IEEE 754-2008...
		exp = repeat( '0', 8 ); // all 0s
		str = repeat( '0', 23 ); // all 0s
		return sign + exp + str;
	}
	x = abs( x );

	// Isolate the integer part (digits before the decimal):
	n = floor( x );

	// Isolate the fractional part (digits after the decimal):
	f = x - n;

	// Convert the integer and fractional parts to bit strings:
	n = div2( n );
	f = mult2( f );

	// Determine the exponent needed to normalize the integer+fractional parts...
	if ( n ) {
		// Move the decimal `d` digits to the left:
		exp = n.length - 1;
	} else {
		// Find the first '1' bit...
		for ( i = 0; i < f.length; i++ ) {
			if ( f[ i ] === '1' ) {
				nbits = i + 1;
				break;
			}
		}
		// Move the decimal `d` digits to the right:
		exp = -nbits;
	}
	// Normalize the combined integer+fractional string...
	str = n + f;
	if ( exp < 0 ) {
		// Handle subnormals...
		if ( exp <= -BIAS ) {
			// Cap the number of bits removed:
			nbits = BIAS - 1;
		}
		// Remove all leading zeros and the first '1' for normal values, and, for subnormals, remove at most BIAS-1 leading bits:
		str = str.substring( nbits );
	} else {
		// Remove the leading '1' (implicit/hidden bit):
		str = str.substring( 1 );
	}
	// Convert the exponent to a bit string:
	exp = div2( exp + BIAS );
	exp = lpad( exp, 8, '0' );

	// Fill in any trailing zeros and ensure we have only 23 fraction bits:
	str = rpad( str, 23, '0' ).substring( 0, 23 );

	// Return a bit representation:
	return sign + exp + str;
} // end FUNCTION binaryString()


// EXPORTS //

module.exports = binaryString;

},{"./div2.js":42,"./mult2.js":44,"const-ninf-float32":22,"const-pinf-float32":23,"math-abs":40,"math-floor":45,"utils-left-pad-string":87,"utils-repeat-string":88,"utils-right-pad-string":89}],44:[function(require,module,exports){
'use strict';

// VARIABLES //

var MAX_ITER = 149; // 127+22 (subnormals)
var MAX_BITS = 24; // only 23 bits for fraction


// MULT2 //

/**
* FUNCTION: mult2( x )
*	Converts a fraction to a literal bit representation using the multiply-by-2 algorithm.
*
* @param {Number} x - number less than 1
* @returns {String} bit representation
*/
function mult2( x ) {
	var str;
	var y;
	var i;
	var j;

	str = '';
	if ( x === 0 ) {
		return str;
	}
	j = MAX_ITER;

	// Each time we multiply by 2 and find a ones digit, add a '1'; otherwise, add a '0'..
	for ( i = 0; i < MAX_ITER; i++ ) {
		y = x * 2;
		if ( y >= 1 ) {
			x = y - 1;
			str += '1';
			if ( j === MAX_ITER ) {
				j = i; // first '1'
			}
		} else {
			x = y;
			str += '0';
		}
		// Stop when we have no more decimals to process or in the event we found a fraction which cannot be represented in a finite number of bits...
		if ( y === 1 || i-j > MAX_BITS ) {
			break;
		}
	}
	return str;
} // end FUNCTION mult2()


// EXPORTS //

module.exports = mult2;

},{}],45:[function(require,module,exports){
'use strict';

// EXPORTS //

module.exports = Math.floor;

},{}],46:[function(require,module,exports){

/*jslint browser: true, node: true */
/*global require, module */

"use strict";

/*** Imports ***/

/**
 * nifti
 * @type {*|{}}
 */
var nifti = nifti || {};
nifti.NIFTI1 = nifti.NIFTI1 || ((typeof require !== 'undefined') ? require('./nifti1.js') : null);
nifti.NIFTI2 = nifti.NIFTI2 || ((typeof require !== 'undefined') ? require('./nifti2.js') : null);
nifti.Utils = nifti.Utils || ((typeof require !== 'undefined') ? require('./utilities.js') : null);

var pako = pako || ((typeof require !== 'undefined') ? require('pako') : null);



/*** Static Methods ***/

/**
 * Returns true if this data represents a NIFTI-1 header.
 * @param {ArrayBuffer} data
 * @returns {boolean}
 */
nifti.isNIFTI1 = function (data) {
    var buf, mag1, mag2, mag3;

    buf = new DataView(data);
    mag1 = buf.getUint8(nifti.NIFTI1.MAGIC_NUMBER_LOCATION);
    mag2 = buf.getUint8(nifti.NIFTI1.MAGIC_NUMBER_LOCATION + 1);
    mag3 = buf.getUint8(nifti.NIFTI1.MAGIC_NUMBER_LOCATION + 2);

    return !!((mag1 === nifti.NIFTI1.MAGIC_NUMBER[0]) && (mag2 === nifti.NIFTI1.MAGIC_NUMBER[1]) &&
        (mag3 === nifti.NIFTI1.MAGIC_NUMBER[2]));
};


/**
 * Returns true if this data represents a NIFTI-2 header.
 * @param {ArrayBuffer} data
 * @returns {boolean}
 */
nifti.isNIFTI2 = function (data) {
    var buf, mag1, mag2, mag3;

    buf = new DataView(data);
    mag1 = buf.getUint8(nifti.NIFTI2.MAGIC_NUMBER_LOCATION);
    mag2 = buf.getUint8(nifti.NIFTI2.MAGIC_NUMBER_LOCATION + 1);
    mag3 = buf.getUint8(nifti.NIFTI2.MAGIC_NUMBER_LOCATION + 2);

    return !!((mag1 === nifti.NIFTI2.MAGIC_NUMBER[0]) && (mag2 === nifti.NIFTI2.MAGIC_NUMBER[1]) &&
    (mag3 === nifti.NIFTI2.MAGIC_NUMBER[2]));
};



/**
 * Returns true if this data represents a NIFTI header.
 * @param {ArrayBuffer} data
 * @returns {boolean}
 */
nifti.isNIFTI = function (data) {
    return (nifti.isNIFTI1(data) || nifti.isNIFTI2(data));
};



/**
 * Returns true if this data is GZIP compressed.
 * @param {ArrayBuffer} data
 * @returns {boolean}
 */
nifti.isCompressed = function (data) {
    var buf, magicCookie1, magicCookie2;

    if (data) {
        buf = new DataView(data);

        magicCookie1 = buf.getUint8(0);
        magicCookie2 = buf.getUint8(1);

        if (magicCookie1 === nifti.Utils.GUNZIP_MAGIC_COOKIE1) {
            return true;
        }

        if (magicCookie2 === nifti.Utils.GUNZIP_MAGIC_COOKIE2) {
            return true;
        }
    }

    return false;
};



/**
 * Returns decompressed data.
 * @param {ArrayBuffer} data
 * @returns {ArrayBuffer}
 */
nifti.decompress = function (data) {
    return pako.inflate(data).buffer;
};



/**
 * Reads and returns the header object.
 * @param {ArrayBuffer} data
 * @returns {nifti.NIFTI1|nifti.NIFTI2|null}
 */
nifti.readHeader = function (data) {
    var header = null;

    if (nifti.isCompressed(data)) {
        data = nifti.decompress(data);
    }

    if (nifti.isNIFTI1(data)) {
        header = new nifti.NIFTI1();
    } else if (nifti.isNIFTI2(data)) {
        header = new nifti.NIFTI2();
    }

    if (header) {
        header.readHeader(data);
    } else {
        console.error("That file does not appear to be NIFTI!");
    }

    return header;
};



/**
 * Returns true if this header contains an extension.
 * @param {nifti.NIFTI1|nifti.NIFTI2} header
 * @returns {boolean}
 */
nifti.hasExtension = function (header) {
    return (header.extensionFlag[0] != 0);
};



/**
 * Returns the image data.
 * @param {nifti.NIFTI1|nifti.NIFTI2} header
 * @param {ArrayBuffer} data
 * @returns {ArrayBuffer}
 */
nifti.readImage = function (header, data) {
    var imageOffset = header.vox_offset,
        timeDim = 1,
        statDim = 1;

    if (header.dims[4]) {
        timeDim = header.dims[4];
    }

    if (header.dims[5]) {
        statDim = header.dims[5];
    }

    var imageSize = header.dims[1] * header.dims[2] * header.dims[3] * timeDim * statDim * (header.numBitsPerVoxel / 8);
    return data.slice(imageOffset, imageOffset + imageSize);
};



/**
 * Returns the extension data (including extension header).
 * @param {nifti.NIFTI1|nifti.NIFTI2} header
 * @param {ArrayBuffer} data
 * @returns {ArrayBuffer}
 */
nifti.readExtension = function (header, data) {
    var loc = header.getExtensionLocation(),
        size = header.extensionSize;

    return data.slice(loc, loc + size);
};



/**
 * Returns the extension data.
 * @param {nifti.NIFTI1|nifti.NIFTI2} header
 * @param {ArrayBuffer} data
 * @returns {ArrayBuffer}
 */
nifti.readExtensionData = function (header, data) {
    var loc = header.getExtensionLocation(),
        size = header.extensionSize;

    return data.slice(loc + 8, loc + size - 8);
};


/*** Exports ***/

var moduleType = typeof module;
if ((moduleType !== 'undefined') && module.exports) {
    module.exports = nifti;
}

},{"./nifti1.js":47,"./nifti2.js":48,"./utilities.js":49,"pako":51}],47:[function(require,module,exports){

/*jslint browser: true, node: true */
/*global */

"use strict";

/*** Imports ***/

var nifti = nifti || {};
nifti.Utils = nifti.Utils || ((typeof require !== 'undefined') ? require('./utilities.js') : null);



/*** Constructor ***/

/**
 * The NIFTI1 constructor.
 * @constructor
 * @property {boolean} littleEndian
 * @property {number} dim_info
 * @property {number[]} dims - image dimensions
 * @property {number} intent_p1
 * @property {number} intent_p2
 * @property {number} intent_p3
 * @property {number} intent_code
 * @property {number} datatypeCode
 * @property {number} numBitsPerVoxel
 * @property {number} slice_start
 * @property {number} slice_end
 * @property {number} slice_code
 * @property {number[]} pixDims - voxel dimensions
 * @property {number} vox_offset
 * @property {number} scl_slope
 * @property {number} scl_inter
 * @property {number} xyzt_units
 * @property {number} cal_max
 * @property {number} cal_min
 * @property {number} slice_duration
 * @property {number} toffset
 * @property {string} description
 * @property {string} aux_file
 * @property {string} intent_name
 * @property {number} qform_code
 * @property {number} sform_code
 * @property {number} quatern_b
 * @property {number} quatern_c
 * @property {number} quatern_d
 * @property {number} quatern_x
 * @property {number} quatern_y
 * @property {number} quatern_z
 * @property {Array.<Array.<number>>} affine
 * @property {string} magic
 * @property {boolean} isHDR - if hdr/img format
 * @property {number[]} extensionFlag
 * @property {number} extensionSize
 * @property {number} extensionCode
 * @type {Function}
 */
nifti.NIFTI1 = nifti.NIFTI1 || function () {
    this.littleEndian = false;
    this.dim_info = 0;
    this.dims = [];
    this.intent_p1 = 0;
    this.intent_p2 = 0;
    this.intent_p3 = 0;
    this.intent_code = 0;
    this.datatypeCode = 0;
    this.numBitsPerVoxel = 0;
    this.slice_start = 0;
    this.slice_end = 0;
    this.slice_code = 0;
    this.pixDims = [];
    this.vox_offset = 0;
    this.scl_slope = 1;
    this.scl_inter = 0;
    this.xyzt_units = 0;
    this.cal_max = 0;
    this.cal_min = 0;
    this.slice_duration = 0;
    this.toffset = 0;
    this.description = "";
    this.aux_file = "";
    this.intent_name = "";
    this.qform_code = 0;
    this.sform_code = 0;
    this.quatern_b = 0;
    this.quatern_c = 0;
    this.quatern_d = 0;
    this.qoffset_x = 0;
    this.qoffset_y = 0;
    this.qoffset_z = 0;
    this.affine = [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]];
    this.magic = 0;
    this.isHDR = false;
    this.extensionFlag = [0, 0, 0, 0];
    this.extensionSize = 0;
    this.extensionCode = 0;
};



/*** Static Pseudo-constants ***/

// datatype codes
nifti.NIFTI1.TYPE_NONE            = 0;
nifti.NIFTI1.TYPE_BINARY          = 1;
nifti.NIFTI1.TYPE_UINT8           = 2;
nifti.NIFTI1.TYPE_INT16           = 4;
nifti.NIFTI1.TYPE_INT32           = 8;
nifti.NIFTI1.TYPE_FLOAT32        = 16;
nifti.NIFTI1.TYPE_COMPLEX64      = 32;
nifti.NIFTI1.TYPE_FLOAT64        = 64;
nifti.NIFTI1.TYPE_RGB24         = 128;
nifti.NIFTI1.TYPE_INT8          = 256;
nifti.NIFTI1.TYPE_UINT16        = 512;
nifti.NIFTI1.TYPE_UINT32        = 768;
nifti.NIFTI1.TYPE_INT64        = 1024;
nifti.NIFTI1.TYPE_UINT64       = 1280;
nifti.NIFTI1.TYPE_FLOAT128     = 1536;
nifti.NIFTI1.TYPE_COMPLEX128   = 1792;
nifti.NIFTI1.TYPE_COMPLEX256   = 2048;

// transform codes
nifti.NIFTI1.XFORM_UNKNOWN        = 0;
nifti.NIFTI1.XFORM_SCANNER_ANAT   = 1;
nifti.NIFTI1.XFORM_ALIGNED_ANAT   = 2;
nifti.NIFTI1.XFORM_TALAIRACH      = 3;
nifti.NIFTI1.XFORM_MNI_152        = 4;

// unit codes
nifti.NIFTI1.SPATIAL_UNITS_MASK = 0x07;
nifti.NIFTI1.TEMPORAL_UNITS_MASK = 0x38;
nifti.NIFTI1.UNITS_UNKNOWN        = 0;
nifti.NIFTI1.UNITS_METER          = 1;
nifti.NIFTI1.UNITS_MM             = 2;
nifti.NIFTI1.UNITS_MICRON         = 3;
nifti.NIFTI1.UNITS_SEC            = 8;
nifti.NIFTI1.UNITS_MSEC          = 16;
nifti.NIFTI1.UNITS_USEC          = 24;
nifti.NIFTI1.UNITS_HZ            = 32;
nifti.NIFTI1.UNITS_PPM           = 40;
nifti.NIFTI1.UNITS_RADS          = 48;

// nifti1 codes
nifti.NIFTI1.MAGIC_COOKIE = 348;
nifti.NIFTI1.MAGIC_NUMBER_LOCATION = 344;
nifti.NIFTI1.MAGIC_NUMBER = [0x6E, 0x2B, 0x31];  // n+1 (.nii)
nifti.NIFTI1.MAGIC_NUMBER2 = [0x6E, 0x69, 0x31];  // ni1 (.hdr/.img)
nifti.NIFTI1.EXTENSION_HEADER_SIZE = 8;


/*** Prototype Methods ***/

/**
 * Reads the header data.
 * @param {ArrayBuffer} data
 */
nifti.NIFTI1.prototype.readHeader = function (data) {
    var rawData = new DataView(data),
        magicCookieVal = nifti.Utils.getIntAt(rawData, 0, this.littleEndian),
        ctr,
        ctrOut,
        ctrIn,
        index;

    if (magicCookieVal !== nifti.NIFTI1.MAGIC_COOKIE) {  // try as little endian
        this.littleEndian = true;
        magicCookieVal = nifti.Utils.getIntAt(rawData, 0, this.littleEndian);
    }

    if (magicCookieVal !== nifti.NIFTI1.MAGIC_COOKIE) {
        throw new Error("This does not appear to be a NIFTI file!");
    }

    this.dim_info = nifti.Utils.getByteAt(rawData, 39);

    for (ctr = 0; ctr < 8; ctr += 1) {
        index = 40 + (ctr * 2);
        this.dims[ctr] = nifti.Utils.getShortAt(rawData, index, this.littleEndian);
    }

    this.intent_p1 = nifti.Utils.getFloatAt(rawData, 56, this.littleEndian);
    this.intent_p2 = nifti.Utils.getFloatAt(rawData, 60, this.littleEndian);
    this.intent_p3 = nifti.Utils.getFloatAt(rawData, 64, this.littleEndian);
    this.intent_code = nifti.Utils.getShortAt(rawData, 68, this.littleEndian);

    this.datatypeCode = nifti.Utils.getShortAt(rawData, 70, this.littleEndian);
    this.numBitsPerVoxel = nifti.Utils.getShortAt(rawData, 72, this.littleEndian);

    this.slice_start = nifti.Utils.getShortAt(rawData, 74, this.littleEndian);

    for (ctr = 0; ctr < 8; ctr += 1) {
        index = 76 + (ctr * 4);
        this.pixDims[ctr] = nifti.Utils.getFloatAt(rawData, index, this.littleEndian);
    }

    this.vox_offset = nifti.Utils.getFloatAt(rawData, 108, this.littleEndian);

    this.scl_slope = nifti.Utils.getFloatAt(rawData, 112, this.littleEndian);
    this.scl_inter = nifti.Utils.getFloatAt(rawData, 116, this.littleEndian);

    this.slice_end = nifti.Utils.getShortAt(rawData, 120, this.littleEndian);
    this.slice_code = nifti.Utils.getByteAt(rawData, 122);

    this.xyzt_units = nifti.Utils.getByteAt(rawData, 123);

    this.cal_max = nifti.Utils.getFloatAt(rawData, 124, this.littleEndian);
    this.cal_min = nifti.Utils.getFloatAt(rawData, 128, this.littleEndian);

    this.slice_duration = nifti.Utils.getFloatAt(rawData, 132, this.littleEndian);
    this.toffset = nifti.Utils.getFloatAt(rawData, 136, this.littleEndian);

    this.description = nifti.Utils.getStringAt(rawData, 148, 228);
    this.aux_file = nifti.Utils.getStringAt(rawData, 228, 252);

    this.qform_code = nifti.Utils.getShortAt(rawData, 252, this.littleEndian);
    this.sform_code = nifti.Utils.getShortAt(rawData, 254, this.littleEndian);

    this.quatern_b = nifti.Utils.getFloatAt(rawData, 256, this.littleEndian);
    this.quatern_c = nifti.Utils.getFloatAt(rawData, 260, this.littleEndian);
    this.quatern_d = nifti.Utils.getFloatAt(rawData, 264, this.littleEndian);
    this.qoffset_x = nifti.Utils.getFloatAt(rawData, 268, this.littleEndian);
    this.qoffset_y = nifti.Utils.getFloatAt(rawData, 272, this.littleEndian);
    this.qoffset_z = nifti.Utils.getFloatAt(rawData, 276, this.littleEndian);

    for (ctrOut = 0; ctrOut < 3; ctrOut += 1) {
        for (ctrIn = 0; ctrIn < 4; ctrIn += 1) {
            index = 280 + (((ctrOut * 4) + ctrIn) * 4);
            this.affine[ctrOut][ctrIn] = nifti.Utils.getFloatAt(rawData, index, this.littleEndian);
        }
    }

    this.affine[3][0] = 0;
    this.affine[3][1] = 0;
    this.affine[3][2] = 0;
    this.affine[3][3] = 1;

    this.intent_name = nifti.Utils.getStringAt(rawData, 328, 344);
    this.magic = nifti.Utils.getStringAt(rawData, 344, 348);

    this.isHDR = (this.magic === nifti.NIFTI1.MAGIC_NUMBER2);

    if (rawData.byteLength > nifti.NIFTI1.MAGIC_COOKIE) {
        this.extensionFlag[0] = nifti.Utils.getByteAt(rawData, 348);
        this.extensionFlag[1] = nifti.Utils.getByteAt(rawData, 348 + 1);
        this.extensionFlag[2] = nifti.Utils.getByteAt(rawData, 348 + 2);
        this.extensionFlag[3] = nifti.Utils.getByteAt(rawData, 348 + 3);

        if (this.extensionFlag[0]) {
            this.extensionSize = this.getExtensionSize(rawData);
            this.extensionCode = this.getExtensionCode(rawData);
        }
    }
};


/**
 * Returns a formatted string of header fields.
 * @returns {string}
 */
nifti.NIFTI1.prototype.toFormattedString = function () {
    var fmt = nifti.Utils.formatNumber,
        string = "";

    string += ("Dim Info = " + this.dim_info + "\n");

    string += ("Image Dimensions (1-8): " +
        this.dims[0] + ", " +
        this.dims[1] + ", " +
        this.dims[2] + ", " +
        this.dims[3] + ", " +
        this.dims[4] + ", " +
        this.dims[5] + ", " +
        this.dims[6] + ", " +
        this.dims[7] + "\n");

    string += ("Intent Parameters (1-3): " +
        this.intent_p1 + ", " +
        this.intent_p2 + ", " +
        this.intent_p3) + "\n";

    string += ("Intent Code = " + this.intent_code + "\n");
    string += ("Datatype = " + this.datatypeCode +  " (" + this.getDatatypeCodeString(this.datatypeCode) + ")\n");
    string += ("Bits Per Voxel = " + this.numBitsPerVoxel + "\n");
    string += ("Slice Start = " + this.slice_start + "\n");
    string += ("Voxel Dimensions (1-8): " +
        fmt(this.pixDims[0]) + ", " +
        fmt(this.pixDims[1]) + ", " +
        fmt(this.pixDims[2]) + ", " +
        fmt(this.pixDims[3]) + ", " +
        fmt(this.pixDims[4]) + ", " +
        fmt(this.pixDims[5]) + ", " +
        fmt(this.pixDims[6]) + ", " +
        fmt(this.pixDims[7]) + "\n");

    string += ("Image Offset = " + this.vox_offset + "\n");
    string += ("Data Scale:  Slope = " + fmt(this.scl_slope) + "  Intercept = " + fmt(this.scl_inter) + "\n");
    string += ("Slice End = " + this.slice_end + "\n");
    string += ("Slice Code = " + this.slice_code + "\n");
    string += ("Units Code = " + this.xyzt_units + " (" + this.getUnitsCodeString(nifti.NIFTI1.SPATIAL_UNITS_MASK & this.xyzt_units) + ", " + this.getUnitsCodeString(nifti.NIFTI1.TEMPORAL_UNITS_MASK & this.xyzt_units) + ")\n");
    string += ("Display Range:  Max = " + fmt(this.cal_max) + "  Min = " + fmt(this.cal_min) + "\n");
    string += ("Slice Duration = " + this.slice_duration + "\n");
    string += ("Time Axis Shift = " + this.toffset + "\n");
    string += ("Description: \"" + this.description + "\"\n");
    string += ("Auxiliary File: \"" + this.aux_file + "\"\n");
    string += ("Q-Form Code = " + this.qform_code + " (" + this.getTransformCodeString(this.qform_code) + ")\n");
    string += ("S-Form Code = " + this.sform_code + " (" + this.getTransformCodeString(this.sform_code) + ")\n");
    string += ("Quaternion Parameters:  " +
        "b = " + fmt(this.quatern_b) + "  " +
        "c = " + fmt(this.quatern_c) + "  " +
        "d = " + fmt(this.quatern_d) + "\n");

    string += ("Quaternion Offsets:  " +
        "x = " + this.qoffset_x + "  " +
        "y = " + this.qoffset_y + "  " +
        "z = " + this.qoffset_z + "\n");

    string += ("S-Form Parameters X: " +
        fmt(this.affine[0][0]) + ", " +
        fmt(this.affine[0][1]) + ", " +
        fmt(this.affine[0][2]) + ", " +
        fmt(this.affine[0][3]) + "\n");

    string += ("S-Form Parameters Y: " +
        fmt(this.affine[1][0]) + ", " +
        fmt(this.affine[1][1]) + ", " +
        fmt(this.affine[1][2]) + ", " +
        fmt(this.affine[1][3]) + "\n");

    string += ("S-Form Parameters Z: " +
        fmt(this.affine[2][0]) + ", " +
        fmt(this.affine[2][1]) + ", " +
        fmt(this.affine[2][2]) + ", " +
        fmt(this.affine[2][3]) + "\n");

    string += ("Intent Name: \"" + this.intent_name + "\"\n");

    if (this.extensionFlag[0]) {
        string += ("Extension: Size = " + this.extensionSize + "  Code = " + this.extensionCode + "\n");

    }

    return string;
};


/**
 * Returns a human-readable string of datatype.
 * @param {number} code
 * @returns {string}
 */
nifti.NIFTI1.prototype.getDatatypeCodeString = function (code) {
    if (code === nifti.NIFTI1.TYPE_UINT8) {
        return "1-Byte Unsigned Integer";
    } else if (code === nifti.NIFTI1.TYPE_INT16) {
        return "2-Byte Signed Integer";
    } else if (code === nifti.NIFTI1.TYPE_INT32) {
        return "4-Byte Signed Integer";
    } else if (code === nifti.NIFTI1.TYPE_FLOAT32) {
        return "4-Byte Float";
    } else if (code === nifti.NIFTI1.TYPE_FLOAT64) {
        return "8-Byte Float";
    } else if (code === nifti.NIFTI1.TYPE_RGB24) {
        return "RGB";
    } else if (code === nifti.NIFTI1.TYPE_INT8) {
        return "1-Byte Signed Integer";
    } else if (code === nifti.NIFTI1.TYPE_UINT16) {
        return "2-Byte Unsigned Integer";
    } else if (code === nifti.NIFTI1.TYPE_UINT32) {
        return "4-Byte Unsigned Integer";
    } else if (code === nifti.NIFTI1.TYPE_INT64) {
        return "8-Byte Signed Integer";
    } else if (code === nifti.NIFTI1.TYPE_UINT64) {
        return "8-Byte Unsigned Integer";
    } else {
        return "Unknown";
    }
};


/**
 * Returns a human-readable string of transform type.
 * @param {number} code
 * @returns {string}
 */
nifti.NIFTI1.prototype.getTransformCodeString = function (code) {
    if (code === nifti.NIFTI1.XFORM_SCANNER_ANAT) {
        return "Scanner";
    } else if (code === nifti.NIFTI1.XFORM_ALIGNED_ANAT) {
        return "Aligned";
    } else if (code === nifti.NIFTI1.XFORM_TALAIRACH) {
        return "Talairach";
    } else if (code === nifti.NIFTI1.XFORM_MNI_152) {
        return "MNI";
    } else {
        return "Unknown";
    }
};


/**
 * Returns a human-readable string of spatial and temporal units.
 * @param {number} code
 * @returns {string}
 */
nifti.NIFTI1.prototype.getUnitsCodeString = function (code) {
    if (code === nifti.NIFTI1.UNITS_METER) {
        return "Meters";
    } else if (code === nifti.NIFTI1.UNITS_MM) {
        return "Millimeters";
    } else if (code === nifti.NIFTI1.UNITS_MICRON) {
        return "Microns";
    } else if (code === nifti.NIFTI1.UNITS_SEC) {
        return "Seconds";
    } else if (code === nifti.NIFTI1.UNITS_MSEC) {
        return "Milliseconds";
    } else if (code === nifti.NIFTI1.UNITS_USEC) {
        return "Microseconds";
    } else if (code === nifti.NIFTI1.UNITS_HZ) {
        return "Hz";
    } else if (code === nifti.NIFTI1.UNITS_PPM) {
        return "PPM";
    } else if (code === nifti.NIFTI1.UNITS_RADS) {
        return "Rads";
    } else {
        return "Unknown";
    }
};


/**
 * Returns the qform matrix.
 * @returns {Array.<Array.<number>>}
 */
nifti.NIFTI1.prototype.getQformMat = function () {
    return this.convertNiftiQFormToNiftiSForm(this.quatern_b, this.quatern_c, this.quatern_d, this.qoffset_x,
        this.qoffset_y, this.qoffset_z, this.pixDims[1], this.pixDims[2], this.pixDims[3], this.pixDims[0]);
};



/**
 * Converts qform to an affine.  (See http://nifti.nimh.nih.gov/pub/dist/src/niftilib/nifti1_io.c)
 * @param {number} qb
 * @param {number} qc
 * @param {number} qd
 * @param {number} qx
 * @param {number} qy
 * @param {number} qz
 * @param {number} dx
 * @param {number} dy
 * @param {number} dz
 * @param {number} qfac
 * @returns {Array.<Array.<number>>}
 */
nifti.NIFTI1.prototype.convertNiftiQFormToNiftiSForm = function (qb, qc, qd, qx, qy, qz, dx, dy, dz,
                                                qfac) {
    var R = [[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]],
        a,
        b = qb,
        c = qc,
        d = qd,
        xd,
        yd,
        zd;

    // last row is always [ 0 0 0 1 ]
    R[3][0] = R[3][1] = R[3][2] = 0.0;
    R[3][3] = 1.0;

    // compute a parameter from b,c,d
    a = 1.0 - (b * b + c * c + d * d);
    if (a < 0.0000001) {                   /* special case */

        a = 1.0 / Math.sqrt(b * b + c * c + d * d);
        b *= a;
        c *= a;
        d *= a;        /* normalize (b,c,d) vector */
        a = 0.0;                        /* a = 0 ==> 180 degree rotation */
    } else {

        a = Math.sqrt(a);                     /* angle = 2*arccos(a) */
    }

    // load rotation matrix, including scaling factors for voxel sizes
    xd = (dx > 0.0) ? dx : 1.0;       /* make sure are positive */
    yd = (dy > 0.0) ? dy : 1.0;
    zd = (dz > 0.0) ? dz : 1.0;

    if (qfac < 0.0) {
        zd = -zd;         /* left handedness? */
    }

    R[0][0] =       (a * a + b * b - c * c - d * d) * xd;
    R[0][1] = 2.0 * (b * c - a * d) * yd;
    R[0][2] = 2.0 * (b * d + a * c) * zd;
    R[1][0] = 2.0 * (b * c + a * d) * xd;
    R[1][1] =       (a * a + c * c - b * b - d * d) * yd;
    R[1][2] = 2.0 * (c * d - a * b) * zd;
    R[2][0] = 2.0 * (b * d - a * c) * xd;
    R[2][1] = 2.0 * (c * d + a * b) * yd;
    R[2][2] =       (a * a + d * d - c * c - b * b) * zd;

    // load offsets
    R[0][3] = qx;
    R[1][3] = qy;
    R[2][3] = qz;

    return R;
};



/**
 * Converts sform to an orientation string (e.g., XYZ+--).  (See http://nifti.nimh.nih.gov/pub/dist/src/niftilib/nifti1_io.c)
 * @param {Array.<Array.<number>>} R
 * @returns {string}
 */
nifti.NIFTI1.prototype.convertNiftiSFormToNEMA = function (R) {
    var xi, xj, xk, yi, yj, yk, zi, zj, zk, val, detQ, detP, i, j, k, p, q, r, ibest, jbest, kbest, pbest, qbest, rbest,
        M, vbest, Q, P, iChar, jChar, kChar, iSense, jSense, kSense;
    k = 0;

    Q = [[0, 0, 0], [0, 0, 0], [0, 0, 0]];
    P = [[0, 0, 0], [0, 0, 0], [0, 0, 0]];

    //if( icod == NULL || jcod == NULL || kcod == NULL ) return ; /* bad */

    //*icod = *jcod = *kcod = 0 ; /* this.errorMessage returns, if sh*t happens */

    /* load column vectors for each (i,j,k) direction from matrix */

    /*-- i axis --*/ /*-- j axis --*/ /*-- k axis --*/

    xi = R[0][0];
    xj = R[0][1];
    xk = R[0][2];

    yi = R[1][0];
    yj = R[1][1];
    yk = R[1][2];

    zi = R[2][0];
    zj = R[2][1];
    zk = R[2][2];

    /* normalize column vectors to get unit vectors along each ijk-axis */

    /* normalize i axis */
    val = Math.sqrt(xi * xi + yi * yi + zi * zi);
    if (val === 0.0) {  /* stupid input */
        return null;
    }

    xi /= val;
    yi /= val;
    zi /= val;

    /* normalize j axis */
    val = Math.sqrt(xj * xj + yj * yj + zj * zj);
    if (val === 0.0) {  /* stupid input */
        return null;
    }

    xj /= val;
    yj /= val;
    zj /= val;

    /* orthogonalize j axis to i axis, if needed */
    val = xi * xj + yi * yj + zi * zj;    /* dot product between i and j */
    if (Math.abs(val) > 1.E-4) {
        xj -= val * xi;
        yj -= val * yi;
        zj -= val * zi;
        val = Math.sqrt(xj * xj + yj * yj + zj * zj);  /* must renormalize */
        if (val === 0.0) {              /* j was parallel to i? */
            return null;
        }
        xj /= val;
        yj /= val;
        zj /= val;
    }

    /* normalize k axis; if it is zero, make it the cross product i x j */
    val = Math.sqrt(xk * xk + yk * yk + zk * zk);
    if (val === 0.0) {
        xk = yi * zj - zi * yj;
        yk = zi * xj - zj * xi;
        zk = xi * yj - yi * xj;
    } else {
        xk /= val;
        yk /= val;
        zk /= val;
    }

    /* orthogonalize k to i */
    val = xi * xk + yi * yk + zi * zk;    /* dot product between i and k */
    if (Math.abs(val) > 1.E-4) {
        xk -= val * xi;
        yk -= val * yi;
        zk -= val * zi;
        val = Math.sqrt(xk * xk + yk * yk + zk * zk);
        if (val === 0.0) {    /* bad */
            return null;
        }
        xk /= val;
        yk /= val;
        zk /= val;
    }

    /* orthogonalize k to j */
    val = xj * xk + yj * yk + zj * zk;    /* dot product between j and k */
    if (Math.abs(val) > 1.e-4) {
        xk -= val * xj;
        yk -= val * yj;
        zk -= val * zj;
        val = Math.sqrt(xk * xk + yk * yk + zk * zk);
        if (val === 0.0) {     /* bad */
            return null;
        }
        xk /= val;
        yk /= val;
        zk /= val;
    }

    Q[0][0] = xi;
    Q[0][1] = xj;
    Q[0][2] = xk;
    Q[1][0] = yi;
    Q[1][1] = yj;
    Q[1][2] = yk;
    Q[2][0] = zi;
    Q[2][1] = zj;
    Q[2][2] = zk;

    /* at this point, Q is the rotation matrix from the (i,j,k) to (x,y,z) axes */

    detQ = this.nifti_mat33_determ(Q);
    if (detQ === 0.0) { /* shouldn't happen unless user is a DUFIS */
        return null;
    }

    /* Build and test all possible +1/-1 coordinate permutation matrices P;
     then find the P such that the rotation matrix M=PQ is closest to the
     identity, in the sense of M having the smallest total rotation angle. */

    /* Despite the formidable looking 6 nested loops, there are
     only 3*3*3*2*2*2 = 216 passes, which will run very quickly. */

    vbest = -666.0;
    ibest = pbest = qbest = rbest = 1;
    jbest = 2;
    kbest = 3;

    for (i = 1; i <= 3; i += 1) {     /* i = column number to use for row #1 */
        for (j = 1; j <= 3; j += 1) {    /* j = column number to use for row #2 */
            if (i !== j) {
                for (k = 1; k <= 3; k += 1) {  /* k = column number to use for row #3 */
                    if (!(i === k || j === k)) {
                        P[0][0] = P[0][1] = P[0][2] = P[1][0] = P[1][1] = P[1][2] = P[2][0] = P[2][1] = P[2][2] = 0.0;
                        for (p = -1; p <= 1; p += 2) {    /* p,q,r are -1 or +1      */
                            for (q = -1; q <= 1; q += 2) {   /* and go into rows #1,2,3 */
                                for (r = -1; r <= 1; r += 2) {
                                    P[0][i - 1] = p;
                                    P[1][j - 1] = q;
                                    P[2][k - 1] = r;
                                    detP = this.nifti_mat33_determ(P);           /* sign of permutation */
                                    if ((detP * detQ) > 0.0) {
                                        M = this.nifti_mat33_mul(P, Q);

                                        /* angle of M rotation = 2.0*acos(0.5*sqrt(1.0+trace(M)))       */
                                        /* we want largest trace(M) == smallest angle == M nearest to I */

                                        val = M[0][0] + M[1][1] + M[2][2]; /* trace */
                                        if (val > vbest) {
                                            vbest = val;
                                            ibest = i;
                                            jbest = j;
                                            kbest = k;
                                            pbest = p;
                                            qbest = q;
                                            rbest = r;
                                        }
                                    }  /* doesn't match sign of Q */
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    /* At this point ibest is 1 or 2 or 3; pbest is -1 or +1; etc.

     The matrix P that corresponds is the best permutation approximation
     to Q-inverse; that is, P (approximately) takes (x,y,z) coordinates
     to the (i,j,k) axes.

     For example, the first row of P (which contains pbest in column ibest)
     determines the way the i axis points relative to the anatomical
     (x,y,z) axes.  If ibest is 2, then the i axis is along the y axis,
     which is direction P2A (if pbest > 0) or A2P (if pbest < 0).

     So, using ibest and pbest, we can assign the output code for
     the i axis.  Mutatis mutandis for the j and k axes, of course. */

    iChar = jChar = kChar = iSense = jSense = kSense = 0;

    switch (ibest * pbest) {
        case 1: /*i = NIFTI_L2R*/
            iChar = 'X';
            iSense = '+';
            break;
        case -1: /*i = NIFTI_R2L*/
            iChar = 'X';
            iSense = '-';
            break;
        case 2: /*i = NIFTI_P2A*/
            iChar = 'Y';
            iSense = '+';
            break;
        case -2: /*i = NIFTI_A2P*/
            iChar = 'Y';
            iSense = '-';
            break;
        case 3: /*i = NIFTI_I2S*/
            iChar = 'Z';
            iSense = '+';
            break;
        case -3: /*i = NIFTI_S2I*/
            iChar = 'Z';
            iSense = '-';
            break;
    }

    switch (jbest * qbest) {
        case 1: /*j = NIFTI_L2R*/
            jChar = 'X';
            jSense = '+';
            break;
        case -1: /*j = NIFTI_R2L*/
            jChar = 'X';
            jSense = '-';
            break;
        case 2: /*j = NIFTI_P2A*/
            jChar = 'Y';
            jSense = '+';
            break;
        case -2: /*j = NIFTI_A2P*/
            jChar = 'Y';
            jSense = '-';
            break;
        case 3: /*j = NIFTI_I2S*/
            jChar = 'Z';
            jSense = '+';
            break;
        case -3: /*j = NIFTI_S2I*/
            jChar = 'Z';
            jSense = '-';
            break;
    }

    switch (kbest * rbest) {
        case 1: /*k = NIFTI_L2R*/
            kChar = 'X';
            kSense = '+';
            break;
        case -1: /*k = NIFTI_R2L*/
            kChar = 'X';
            kSense = '-';
            break;
        case 2: /*k = NIFTI_P2A*/
            kChar = 'Y';
            kSense = '+';
            break;
        case -2: /*k = NIFTI_A2P*/
            kChar = 'Y';
            kSense = '-';
            break;
        case 3: /*k = NIFTI_I2S*/
            kChar = 'Z';
            kSense = '+';
            break;
        case -3: /*k = NIFTI_S2I*/
            kChar = 'Z';
            kSense = '-';
            break;
    }

    return (iChar + jChar + kChar + iSense + jSense + kSense);
};



nifti.NIFTI1.prototype.nifti_mat33_mul = function (A, B) {
    var C = [[0, 0, 0], [0, 0, 0], [0, 0, 0]],
        i,
        j;

    for (i = 0; i < 3; i += 1) {
        for (j = 0; j < 3; j += 1) {
            C[i][j] =  A[i][0] * B[0][j]  + A[i][1] * B[1][j] + A[i][2] * B[2][j];
        }
    }

    return C;
};



nifti.NIFTI1.prototype.nifti_mat33_determ = function (R) {
    var r11, r12, r13, r21, r22, r23, r31, r32, r33;
    /*  INPUT MATRIX:  */
    r11 = R[0][0];
    r12 = R[0][1];
    r13 = R[0][2];
    r21 = R[1][0];
    r22 = R[1][1];
    r23 = R[1][2];
    r31 = R[2][0];
    r32 = R[2][1];
    r33 = R[2][2];

    return (r11 * r22 * r33 - r11 * r32 * r23 - r21 * r12 * r33 + r21 * r32 * r13 + r31 * r12 * r23 - r31 * r22 * r13);
};


/**
 * Returns the byte index of the extension.
 * @returns {number}
 */
nifti.NIFTI1.prototype.getExtensionLocation = function() {
    return nifti.NIFTI1.MAGIC_COOKIE + 4;
};


/**
 * Returns the extension size.
 * @param {DataView} data
 * @returns {number}
 */
nifti.NIFTI1.prototype.getExtensionSize = function(data) {
    return nifti.Utils.getIntAt(data, this.getExtensionLocation(), this.littleEndian);
};



/**
 * Returns the extension code.
 * @param {DataView} data
 * @returns {number}
 */
nifti.NIFTI1.prototype.getExtensionCode = function(data) {
    return nifti.Utils.getIntAt(data, this.getExtensionLocation() + 4, this.littleEndian);
};



/*** Exports ***/

var moduleType = typeof module;
if ((moduleType !== 'undefined') && module.exports) {
    module.exports = nifti.NIFTI1;
}

},{"./utilities.js":49}],48:[function(require,module,exports){

/*jslint browser: true, node: true */
/*global */

"use strict";

/*** Imports ***/

var nifti = nifti || {};
nifti.Utils = nifti.Utils || ((typeof require !== 'undefined') ? require('./utilities.js') : null);
nifti.NIFTI1 = nifti.NIFTI1 || ((typeof require !== 'undefined') ? require('./nifti1.js') : null);


/*** Constructor ***/

/**
 * The NIFTI2 constructor.
 * @constructor
 * @property {boolean} littleEndian
 * @property {number} dim_info
 * @property {number[]} dims - image dimensions
 * @property {number} intent_p1
 * @property {number} intent_p2
 * @property {number} intent_p3
 * @property {number} intent_code
 * @property {number} datatypeCode
 * @property {number} numBitsPerVoxel
 * @property {number} slice_start
 * @property {number} slice_end
 * @property {number} slice_code
 * @property {number[]} pixDims - voxel dimensions
 * @property {number} vox_offset
 * @property {number} scl_slope
 * @property {number} scl_inter
 * @property {number} xyzt_units
 * @property {number} cal_max
 * @property {number} cal_min
 * @property {number} slice_duration
 * @property {number} toffset
 * @property {string} description
 * @property {string} aux_file
 * @property {string} intent_name
 * @property {number} qform_code
 * @property {number} sform_code
 * @property {number} quatern_b
 * @property {number} quatern_c
 * @property {number} quatern_d
 * @property {number} quatern_x
 * @property {number} quatern_y
 * @property {number} quatern_z
 * @property {Array.<Array.<number>>} affine
 * @property {string} magic
 * @property {number[]} extensionFlag
 * @type {Function}
 */
nifti.NIFTI2 = nifti.NIFTI2 || function () {
    this.littleEndian = false;
    this.dim_info = 0;
    this.dims = [];
    this.intent_p1 = 0;
    this.intent_p2 = 0;
    this.intent_p3 = 0;
    this.intent_code = 0;
    this.datatypeCode = 0;
    this.numBitsPerVoxel = 0;
    this.slice_start = 0;
    this.slice_end = 0;
    this.slice_code = 0;
    this.pixDims = [];
    this.vox_offset = 0;
    this.scl_slope = 1;
    this.scl_inter = 0;
    this.xyzt_units = 0;
    this.cal_max = 0;
    this.cal_min = 0;
    this.slice_duration = 0;
    this.toffset = 0;
    this.description = "";
    this.aux_file = "";
    this.intent_name = "";
    this.qform_code = 0;
    this.sform_code = 0;
    this.quatern_b = 0;
    this.quatern_c = 0;
    this.quatern_d = 0;
    this.qoffset_x = 0;
    this.qoffset_y = 0;
    this.qoffset_z = 0;
    this.affine = [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]];
    this.magic = 0;
    this.extensionFlag = [0, 0, 0, 0];
};



/*** Static Pseudo-constants ***/

nifti.NIFTI2.MAGIC_COOKIE = 540;
nifti.NIFTI2.MAGIC_NUMBER_LOCATION = 4;
nifti.NIFTI2.MAGIC_NUMBER = [0x6E, 0x2B, 0x32, 0, 0x0D, 0x0A, 0x1A, 0x0A];  // n+2\0



/*** Prototype Methods ***/

/**
 * Reads the header data.
 * @param {ArrayBuffer} data
 */
nifti.NIFTI2.prototype.readHeader = function (data) {
    var rawData = new DataView(data),
        magicCookieVal = nifti.Utils.getIntAt(rawData, 0, this.littleEndian),
        ctr,
        ctrOut,
        ctrIn,
        index,
        array;

    if (magicCookieVal !== nifti.NIFTI2.MAGIC_COOKIE) {  // try as little endian
        this.littleEndian = true;
        magicCookieVal = nifti.Utils.getIntAt(rawData, 0, this.littleEndian);
    }

    if (magicCookieVal !== nifti.NIFTI2.MAGIC_COOKIE) {
        throw new Error("This does not appear to be a NIFTI file!");
    }

    this.datatypeCode = nifti.Utils.getShortAt(rawData, 12, this.littleEndian);
    this.numBitsPerVoxel = nifti.Utils.getShortAt(rawData, 14, this.littleEndian);

    for (ctr = 0; ctr < 8; ctr += 1) {
        index = 16 + (ctr * 8);
        this.dims[ctr] = nifti.Utils.getLongAt(rawData, index, this.littleEndian);
    }

    this.intent_p1 = nifti.Utils.getDoubleAt(rawData, 80, this.littleEndian);
    this.intent_p2 = nifti.Utils.getDoubleAt(rawData, 88, this.littleEndian);
    this.intent_p3 = nifti.Utils.getDoubleAt(rawData, 96, this.littleEndian);

    for (ctr = 0; ctr < 8; ctr += 1) {
        index = 104 + (ctr * 8);
        this.pixDims[ctr] = nifti.Utils.getDoubleAt(rawData, index, this.littleEndian);
    }

    this.vox_offset = nifti.Utils.getLongAt(rawData, 168, this.littleEndian);

    this.scl_slope = nifti.Utils.getDoubleAt(rawData, 176, this.littleEndian);
    this.scl_inter = nifti.Utils.getDoubleAt(rawData, 184, this.littleEndian);

    this.cal_max = nifti.Utils.getDoubleAt(rawData, 192, this.littleEndian);
    this.cal_min = nifti.Utils.getDoubleAt(rawData, 200, this.littleEndian);

    this.slice_duration = nifti.Utils.getDoubleAt(rawData, 208, this.littleEndian);

    this.toffset = nifti.Utils.getDoubleAt(rawData, 216, this.littleEndian);

    this.slice_start = nifti.Utils.getLongAt(rawData, 224, this.littleEndian);
    this.slice_end = nifti.Utils.getLongAt(rawData, 232, this.littleEndian);

    this.description = nifti.Utils.getStringAt(rawData, 240, 240 + 80);
    this.aux_file = nifti.Utils.getStringAt(rawData, 320, 320 + 24);

    this.qform_code = nifti.Utils.getIntAt(rawData, 344, this.littleEndian);
    this.sform_code = nifti.Utils.getIntAt(rawData, 348, this.littleEndian);

    this.quatern_b = nifti.Utils.getDoubleAt(rawData, 352, this.littleEndian);
    this.quatern_c = nifti.Utils.getDoubleAt(rawData, 360, this.littleEndian);
    this.quatern_d = nifti.Utils.getDoubleAt(rawData, 368, this.littleEndian);
    this.qoffset_x = nifti.Utils.getDoubleAt(rawData, 376, this.littleEndian);
    this.qoffset_y = nifti.Utils.getDoubleAt(rawData, 384, this.littleEndian);
    this.qoffset_z = nifti.Utils.getDoubleAt(rawData, 392, this.littleEndian);

    for (ctrOut = 0; ctrOut < 3; ctrOut += 1) {
        for (ctrIn = 0; ctrIn < 4; ctrIn += 1) {
            index = 400 + (((ctrOut * 4) + ctrIn) * 8);
            this.affine[ctrOut][ctrIn] = nifti.Utils.getDoubleAt(rawData, index, this.littleEndian);
        }
    }

    this.affine[3][0] = 0;
    this.affine[3][1] = 0;
    this.affine[3][2] = 0;
    this.affine[3][3] = 1;

    this.slice_code = nifti.Utils.getIntAt(rawData, 496, this.littleEndian);
    this.xyzt_units = nifti.Utils.getIntAt(rawData, 500, this.littleEndian);
    this.intent_code = nifti.Utils.getIntAt(rawData, 504, this.littleEndian);
    this.intent_name = nifti.Utils.getStringAt(rawData, 508, 508 + 16);

    this.dim_info = nifti.Utils.getByteAt(rawData, 524);

    if (rawData.byteLength > nifti.NIFTI2.MAGIC_COOKIE) {
        this.extensionFlag[0] = nifti.Utils.getByteAt(rawData, 540);
        this.extensionFlag[1] = nifti.Utils.getByteAt(rawData, 540 + 1);
        this.extensionFlag[2] = nifti.Utils.getByteAt(rawData, 540 + 2);
        this.extensionFlag[3] = nifti.Utils.getByteAt(rawData, 540 + 3);

        if (this.extensionFlag[0]) {
            this.extensionSize = this.getExtensionSize(rawData);
            this.extensionCode = this.getExtensionCode(rawData);
        }
    }
};



/**
 * Returns a formatted string of header fields.
 * @returns {string}
 */
nifti.NIFTI2.prototype.toFormattedString = function () {
    var fmt = nifti.Utils.formatNumber,
        string = "";

    string += ("Datatype = " +  + this.datatypeCode + " (" + this.getDatatypeCodeString(this.datatypeCode) + ")\n");
    string += ("Bits Per Voxel = " + " = " + this.numBitsPerVoxel + "\n");
    string += ("Image Dimensions" + " (1-8): " +
        this.dims[0] + ", " +
        this.dims[1] + ", " +
        this.dims[2] + ", " +
        this.dims[3] + ", " +
        this.dims[4] + ", " +
        this.dims[5] + ", " +
        this.dims[6] + ", " +
        this.dims[7] + "\n");

    string += ("Intent Parameters (1-3): " +
        this.intent_p1 + ", " +
        this.intent_p2 + ", " +
        this.intent_p3) + "\n";

    string += ("Voxel Dimensions (1-8): " +
        fmt(this.pixDims[0]) + ", " +
        fmt(this.pixDims[1]) + ", " +
        fmt(this.pixDims[2]) + ", " +
        fmt(this.pixDims[3]) + ", " +
        fmt(this.pixDims[4]) + ", " +
        fmt(this.pixDims[5]) + ", " +
        fmt(this.pixDims[6]) + ", " +
        fmt(this.pixDims[7]) + "\n");

    string += ("Image Offset = " + this.vox_offset + "\n");
    string += ("Data Scale:  Slope = " + fmt(this.scl_slope) + "  Intercept = " + fmt(this.scl_inter) + "\n");
    string += ("Display Range:  Max = " + fmt(this.cal_max) + "  Min = " + fmt(this.cal_min) + "\n");
    string += ("Slice Duration = " + this.slice_duration + "\n");
    string += ("Time Axis Shift = " + this.toffset + "\n");
    string += ("Slice Start = " + this.slice_start + "\n");
    string += ("Slice End = " + this.slice_end + "\n");
    string += ("Description: \"" + this.description + "\"\n");
    string += ("Auxiliary File: \"" + this.aux_file + "\"\n");
    string += ("Q-Form Code = " + this.qform_code + " (" + this.getTransformCodeString(this.qform_code) + ")\n");
    string += ("S-Form Code = " + this.sform_code + " (" + this.getTransformCodeString(this.sform_code) + ")\n");
    string += ("Quaternion Parameters:  " +
    "b = " + fmt(this.quatern_b) + "  " +
    "c = " + fmt(this.quatern_c) + "  " +
    "d = " + fmt(this.quatern_d) + "\n");

    string += ("Quaternion Offsets:  " +
    "x = " + this.qoffset_x + "  " +
    "y = " + this.qoffset_y + "  " +
    "z = " + this.qoffset_z + "\n");

    string += ("S-Form Parameters X: " +
    fmt(this.affine[0][0]) + ", " +
    fmt(this.affine[0][1]) + ", " +
    fmt(this.affine[0][2]) + ", " +
    fmt(this.affine[0][3]) + "\n");

    string += ("S-Form Parameters Y: " +
    fmt(this.affine[1][0]) + ", " +
    fmt(this.affine[1][1]) + ", " +
    fmt(this.affine[1][2]) + ", " +
    fmt(this.affine[1][3]) + "\n");

    string += ("S-Form Parameters Z: " +
    fmt(this.affine[2][0]) + ", " +
    fmt(this.affine[2][1]) + ", " +
    fmt(this.affine[2][2]) + ", " +
    fmt(this.affine[2][3]) + "\n");

    string += ("Slice Code = " + this.slice_code + "\n");
    string += ("Units Code = " + this.xyzt_units + " (" + this.getUnitsCodeString(nifti.NIFTI1.SPATIAL_UNITS_MASK & this.xyzt_units) + ", " + this.getUnitsCodeString(nifti.NIFTI1.TEMPORAL_UNITS_MASK & this.xyzt_units) + ")\n");
    string += ("Intent Code = " + this.intent_code + "\n");
    string += ("Intent Name: \"" + this.intent_name + "\"\n");

    string += ("Dim Info = " + this.dim_info + "\n");

    return string;
};



/**
 * Returns the byte index of the extension.
 * @returns {number}
 */
nifti.NIFTI2.prototype.getExtensionLocation = function() {
    return nifti.NIFTI2.MAGIC_COOKIE + 4;
};



/**
 * Returns the extension size.
 * @param {DataView} data
 * @returns {number}
 */
nifti.NIFTI2.prototype.getExtensionSize = nifti.NIFTI1.prototype.getExtensionSize;



/**
 * Returns the extension code.
 * @param {DataView} data
 * @returns {number}
 */
nifti.NIFTI2.prototype.getExtensionCode = nifti.NIFTI1.prototype.getExtensionCode;



/**
 * Returns a human-readable string of datatype.
 * @param {number} code
 * @returns {string}
 */
nifti.NIFTI2.prototype.getDatatypeCodeString = nifti.NIFTI1.prototype.getDatatypeCodeString;



/**
 * Returns a human-readable string of transform type.
 * @param {number} code
 * @returns {string}
 */
nifti.NIFTI2.prototype.getTransformCodeString = nifti.NIFTI1.prototype.getTransformCodeString;



/**
 * Returns a human-readable string of spatial and temporal units.
 * @param {number} code
 * @returns {string}
 */
nifti.NIFTI2.prototype.getUnitsCodeString = nifti.NIFTI1.prototype.getUnitsCodeString;



/**
 * Returns the qform matrix.
 * @returns {Array.<Array.<number>>}
 */
nifti.NIFTI2.prototype.getQformMat = nifti.NIFTI1.prototype.getQformMat;



/**
 * Converts qform to an affine.  (See http://nifti.nimh.nih.gov/pub/dist/src/niftilib/nifti1_io.c)
 * @param {number} qb
 * @param {number} qc
 * @param {number} qd
 * @param {number} qx
 * @param {number} qy
 * @param {number} qz
 * @param {number} dx
 * @param {number} dy
 * @param {number} dz
 * @param {number} qfac
 * @returns {Array.<Array.<number>>}
 */
nifti.NIFTI2.prototype.convertNiftiQFormToNiftiSForm = nifti.NIFTI1.prototype.convertNiftiQFormToNiftiSForm;



/**
 * Converts sform to an orientation string (e.g., XYZ+--).  (See http://nifti.nimh.nih.gov/pub/dist/src/niftilib/nifti1_io.c)
 * @param {Array.<Array.<number>>} R
 * @returns {string}
 */
nifti.NIFTI2.prototype.convertNiftiSFormToNEMA = nifti.NIFTI1.prototype.convertNiftiSFormToNEMA;



nifti.NIFTI2.prototype.nifti_mat33_mul = nifti.NIFTI1.prototype.nifti_mat33_mul;



nifti.NIFTI2.prototype.nifti_mat33_determ = nifti.NIFTI1.prototype.nifti_mat33_determ;



/*** Exports ***/

var moduleType = typeof module;
if ((moduleType !== 'undefined') && module.exports) {
    module.exports = nifti.NIFTI2;
}

},{"./nifti1.js":47,"./utilities.js":49}],49:[function(require,module,exports){

/*jslint browser: true, node: true */
/*global require, module */

"use strict";

/*** Imports ***/

var nifti = nifti || {};
nifti.Utils = nifti.Utils || {};



/*** Static Pseudo-constants ***/

nifti.Utils.crcTable = null;
nifti.Utils.GUNZIP_MAGIC_COOKIE1 = 31;
nifti.Utils.GUNZIP_MAGIC_COOKIE2 = 139;



/*** Static methods ***/

nifti.Utils.getStringAt = function (data, start, end) {
    var str = "", ctr, ch;

    for (ctr = start; ctr < end; ctr += 1) {
        ch = data.getUint8(ctr);

        if (ch !== 0) {
            str += String.fromCharCode(ch);
        }
    }

    return str;
};



nifti.Utils.getByteAt = function (data, start) {
    return data.getInt8(start);
};



nifti.Utils.getShortAt = function (data, start, littleEndian) {
    return data.getInt16(start, littleEndian);
};



nifti.Utils.getIntAt = function (data, start, littleEndian) {
    return data.getInt32(start, littleEndian);
};



nifti.Utils.getFloatAt = function (data, start, littleEndian) {
    return data.getFloat32(start, littleEndian);
};



nifti.Utils.getDoubleAt = function (data, start, littleEndian) {
    return data.getFloat64(start, littleEndian);
};



nifti.Utils.getLongAt = function (data, start, littleEndian) {
    var ctr, array = [], value = 0;

    for (ctr = 0; ctr < 8; ctr += 1) {
        array[ctr] = nifti.Utils.getByteAt(data, start + ctr, littleEndian);
    }

    for (ctr = array.length - 1; ctr >= 0; ctr--) {
        value = (value * 256) + array[ctr];
    }

    return value;
};



nifti.Utils.toArrayBuffer = function (buffer) {
    var ab, view, i;

    ab = new ArrayBuffer(buffer.length);
    view = new Uint8Array(ab);
    for (i = 0; i < buffer.length; i += 1) {
        view[i] = buffer[i];
    }
    return ab;
};



nifti.Utils.isString = function (obj) {
    return (typeof obj === "string" || obj instanceof String);
};


nifti.Utils.formatNumber = function (num, shortFormat) {
    var val = 0;

    if (nifti.Utils.isString(num)) {
        val = Number(num);
    } else {
        val = num;
    }

    if (shortFormat) {
        val = val.toPrecision(5);
    } else {
        val = val.toPrecision(7);
    }

    return parseFloat(val);
};



// http://stackoverflow.com/questions/18638900/javascript-crc32
nifti.Utils.makeCRCTable = function(){
    var c;
    var crcTable = [];
    for(var n =0; n < 256; n++){
        c = n;
        for(var k =0; k < 8; k++){
            c = ((c&1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));
        }
        crcTable[n] = c;
    }
    return crcTable;
};



nifti.Utils.crc32 = function(dataView) {
    var crcTable = nifti.Utils.crcTable || (nifti.Utils.crcTable = nifti.Utils.makeCRCTable());
    var crc = 0 ^ (-1);

    for (var i = 0; i < dataView.byteLength; i++ ) {
        crc = (crc >>> 8) ^ crcTable[(crc ^ dataView.getUint8(i)) & 0xFF];
    }

    return (crc ^ (-1)) >>> 0;
};



/*** Exports ***/

var moduleType = typeof module;
if ((moduleType !== 'undefined') && module.exports) {
    module.exports = nifti.Utils;
}

},{}],50:[function(require,module,exports){
"use strict";
var assert = require('assert');

var lineSeparatorRE = /[ \f\t\v]*\r?\n/;
var NRRDMagicRE = /^NRRD\d{4}$/;
var lineRE = /^([^:]*)(:[ =])(.*)$/;
var dataFileListRE = /^LIST(?: (\d+))?$/;

// The minimal object this accepts is formed like this:
//   {data: SomeTypedArray, sizes: [...]}
// On the other hand, if data is not given it must have a form like this:
//   {buffer: SomeArrayBuffer, type: ..., endian: ..., sizes: [...]}
// Of course, if 'type' is an 8-bit type, endian is not needed, and if 'type' equals 'block', 'blockSize' should be set instead of 'endian'. In this case, no interpretation of buffer is done (at all, it is written serialized directly to the buffer).
// TODO: For now this only supports serializing "inline" files, or files for which you have already prepared the data.
module.exports.serialize = function (nrrdOrg) {
    var i, buffer, arr, totalLen = 1, nrrd = {}, prop, nativeType, nativeSize, bufferData, arrData, line, lines = [], header;
    
    // Copy nrrdOrg to nrrd to allow modifications without altering the original
    for(prop in nrrdOrg) {
        nrrd[prop] = nrrdOrg[prop];
    }
    
    // For saving files we allow inferring certain information if it is not explicitly given.
    // Also we normalize some fields to make our own lives easier.
    if (nrrd.sizes===undefined) { // 'sizes' should ALWAYS be given
        throw new Error("Sizes missing from NRRD file!");
    } else if (nrrd.dimension===undefined) {
        nrrd.dimension = nrrd.sizes.length;
    }
    if (nrrd.data instanceof Int8Array) {
        nativeType = "int8";
    } else if (nrrd.data instanceof Uint8Array) {
        nativeType = "uint8";
    } else if (nrrd.data instanceof Int16Array) {
        nativeType = "int16";
    } else if (nrrd.data instanceof Uint16Array) {
        nativeType = "uint16";
    } else if (nrrd.data instanceof Int32Array) {
        nativeType = "int32";
    } else if (nrrd.data instanceof Uint32Array) {
        nativeType = "uint32";
    //} else if (nrrd.data instanceof Int64Array) {
    //    nativeType = "int64";
    //} else if (nrrd.data instanceof Uint64Array) {
    //    nativeType = "uint64";
    } else if (nrrd.data instanceof Float32Array) {
        nativeType = "float";
    } else if (nrrd.data instanceof Float64Array) {
        nativeType = "double";
    }
    if (nrrd.type===undefined && nativeType!==undefined) {
        nrrd.type = nativeType;
    } else if (nrrd.type===undefined) {
        throw new Error("Type of data is not given and cannot be inferred!");
    } else if ((typeof nrrd.type) == "string" || nrrd.type instanceof String) {
        nrrd.type = parseNRRDType(nrrd.type);
    }
    if (nrrd.encoding===undefined) {
        nrrd.encoding = "raw";
    } else if ((typeof nrrd.encoding) == "string" || nrrd.encoding instanceof String) {
        nrrd.encoding = parseNRRDEncoding(nrrd.encoding);
    }
    if (nrrd.data && nrrd.type != 'block' && nrrd.type != 'int8' && nrrd.type != 'uint8' && nrrd.encoding != 'ascii') {
        nrrd.endian = systemEndianness;
    } else if (nrrd.type == 'block' || nrrd.type == 'int8' || nrrd.type == 'uint8' || nrrd.encoding == 'ascii') {
        nrrd.endian = undefined;
    } else if ((typeof nrrd.endian) == "string" || nrrd.endian instanceof String) {
        nrrd.endian = parseNRRDEndian(nrrd.endian);
    }
    
    // Try to infer spatial dimension
    var spaceDimension = undefined;
    if (nrrd.spaceDimension!==undefined) {
        spaceDimension = nrrd.spaceDimension;
    } else if (nrrd.space!==undefined) {
        switch(nrrd.space) {
        case "right-anterior-superior":
        case "RAS":
            spaceDimension = 3;
            break;
        case "left-anterior-superior":
        case "LAS":
            spaceDimension = 3;
            break;
        case "left-posterior-superior":
        case "LPS":
            spaceDimension = 3;
            break;
     	  case "right-anterior-superior-time":
     	  case "RAST":
     	      spaceDimension = 4;
     	      break;
        case "left-anterior-superior-time":
        case "LAST":
            spaceDimension = 4;
            break;
        case "left-posterior-superior-time":
        case "LPST":
            spaceDimension = 4;
            break;
        case "scanner-xyz":
            spaceDimension = 3;
            break;
        case "scanner-xyz-time":
            spaceDimension = 4;
            break;
        case "3D-right-handed":
            spaceDimension = 3;
            break;
        case "3D-left-handed":
            spaceDimension = 3;
            break;
        case "3D-right-handed-time":
            spaceDimension = 4;
            break;
        case "3D-left-handed-time":
            spaceDimension = 4;
            break;
        default:
            console.warn("Unrecognized space: " + nrrd.space);
        }
    }
    
    // Now check that we have a valid nrrd structure.
    checkNRRD(nrrd);

    // Determine number of elements and check that we have enough data (if possible)
    for(i=0; i<nrrd.sizes.length; i++) {
        if (nrrd.sizes[i]<=0) throw new Error("Sizes should be a list of positive (>0) integers!");
        totalLen *= nrrd.sizes[i];
    }
    if (nrrd.data) {
        if (nrrd.data.length < totalLen) {
            throw new Error("Missing data to serialize!");
        }
    } else if (nrrd.buffer) {
        if (nrrd.encoding == "raw") {
            if (nrrd.type=="block" && nrrd.blockSize!==undefined) {
                nativeSize = nrrd.blockSize;
            } else {
                nativeSize = getNRRDTypeSize(nrrd.type);
            }
            if (nrrd.buffer.byteLength < totalLen*nativeSize) {
                throw new Error("Missing data to serialize!");
            }
        }
    } else if (nrrd.dataFile) {
        // Okay, if you have your data ready, we'll just write a header.
    } else {
        throw new Error("Will not serialize an empty NRRD file!");
    }
    
    // Make sure we have the correct buffer in bufferData.
    if (nrrd.data) {
        switch(nrrd.encoding) {
        case 'raw':
            if (nrrd.type == nativeType && nrrd.endian == systemEndianness) {
                bufferData = nrrd.data.buffer.slice(nrrd.data.byteOffset, nrrd.data.byteOffset+nrrd.data.byteLength);
            } else if (nrrd.endian == systemEndianness) {
                bufferData = castTypedArray(nrrd.data, nrrd.type);
                bufferData = bufferData.buffer.slice(bufferData.byteOffset, bufferData.byteOffset+bufferData.byteLength);
            } else {
                bufferData = serializeToBuffer(nrrd.data, nrrd.type, nrrd.endian);
            }
            break;
        case 'ascii':
            if (nrrd.type == nativeType) {
                bufferData = serializeToTextBuffer(nrrd.data);
            } else {
                bufferData = serializeToTextBuffer(castTypedArray(nrrd.data, nrrd.type));
            }
            break;
        default:
            throw new Error("Unsupported NRRD encoding: " + nrrd.encoding);
        }
    } else if (nrrd.buffer) {
        bufferData = nrrd.buffer;
    }
    
    // Start header
    lines.push("NRRD0005"); // TODO: Adjust version based on features that are actually used and/or the version specified by the user (if any).
    lines.push("# Generated by nrrd-js");
    
    // Put in dimension and space dimension (the NRRD spec requires that these are present before any lists whose length depends on them)
    var firstProps = ['dimension', 'spaceDimension', 'space'];
    for(i=0; i<firstProps.length; i++) {
        prop = firstProps[i];
        if (nrrd[prop] === undefined) continue; // Skip things we explicitly set to undefined.
        line = serializeField(prop, nrrd[prop], nrrd.dimension, spaceDimension);
        if (line!==undefined) lines.push(line);
    }
    
    // Put in field specifications
    for(prop in nrrd) {
        if (nrrd[prop] === undefined) continue; // Skip things we explicitly set to undefined.
        if (firstProps.indexOf(prop)>=0) continue; // Skip the fields we already output.
        line = serializeField(prop, nrrd[prop], nrrd.dimension, spaceDimension);
        if (line!==undefined) lines.push(line);
    }
    
    // Put in keys (if any)
    if (nrrd.keys) for(prop in nrrd.keys) {
        if (prop.indexOf(":=")>=0) throw new Error("The combination ':=' is not allowed in an NRRD key!");
        lines.push(prop + ":=" + escapeValue(nrrd[prop]));
    }
    
    // Put in data file list (if any)
    if (nrrd.dataFile && nrrd.dataFile.length) {
        lines.push("data file: LIST");
        Array.prototype.push.apply(lines, nrrd.dataFile);
    } else if (nrrd.dataFile && nrrd.dataFile.files && 'subdim' in nrrd.dataFile) {
        lines.push("data file: LIST " + nrrd.dataFile.subdim);
        Array.prototype.push.apply(lines, nrrd.dataFile.files);
    }
    
    // Put in empty line and inline data (if we have inline data) and convert lines to buffer
    if (bufferData && !('dataFile' in nrrd)) {
        lines.push("");
        lines.push(""); // We actually need an extra blank line to make sure the previous is terminated.
        header = lines.join("\n");
        buffer = new ArrayBuffer(header.length + bufferData.byteLength);
        arr = new Uint8Array(buffer);
        for(i=0; i<header.length; i++) {
            arr[i] = header.charCodeAt(i);
        }
        arrData = new Uint8Array(bufferData);
        arr.set(arrData, header.length);
    } else {
        lines.push(""); // Blank line to at least terminate the last line.
        header = lines.join("\n");
        buffer = new ArrayBuffer(header.length);
        arr = new Uint8Array(buffer);
        for(i=0; i<header.length; i++) {
            arr[i] = header.charCodeAt(i);
        }
    }
    
    return buffer;
};

// This expects an ArrayBuffer.
module.exports.parse = function (buffer) {
    var i, header, dataStart, ret = {data: undefined/* parsed data */, buffer: undefined/* raw buffer holding data */, keys: {}, version: undefined},
        lines, match, match2,
        buf8 = new Uint8Array(buffer);

    // A work-around for incompatibilities between Node's Buffer and ArrayBuffer.
    if (buf8.buffer !== buffer) buffer = buf8.buffer;

    // First find the separation between the header and the data (if there is one)
    // Note that we need to deal with with LF and CRLF as possible line endings.
    // Luckily this means the line always ends with LF, so we only need to consider
    // LFLF and LFCRLF as patterns for the separating empty line.
    i=2; // It is safe to start at position 2 (in fact, we could start even later), as the file HAS to start with a magic word.
    while(i<buf8.length) {
        if (buf8[i] == 10) { // We hit an LF
            if (buf8[i-1] == 10 || (buf8[i-1] == 13 && buf8[i-2] == 10)) { // Safe because we start at position 2 and never move backwards
                dataStart = i+1;
                break;
            } else {
                i++; // Move forward just once
            }
        } else if (buf8[i] == 13) { // We hit a CR
            i++; // Move forward just once
        } else {
            i += 2; // Move forward two places, 
        }
    }
    
    // Now split up the header and data
    if (dataStart === undefined) {
        header = String.fromCharCode.apply(null, buf8);
    } else {
        header = String.fromCharCode.apply(null, buf8.subarray(0,dataStart));
        ret.buffer = buffer.slice(dataStart);
    }
    
    // Split header into lines, remove comments (and blank lines) and check magic.
    // All remaining lines except the first should be field specifications or key/value pairs.
    // TODO: This explicitly removes any whitespace at the end of lines, however, I am not sure that this is actually desired behaviour for all kinds of lines.
    lines = header.split(lineSeparatorRE);
    lines = lines.filter(function (l) { return l.length>0 && l[0] != '#'; }); // Remove comment lines
    if (!NRRDMagicRE.test(lines[0])) {
        throw new Error("File is not an NRRD file!");
    }
    ret.version = parseInt(lines[0].substring(4, 8), 10);
    if (ret.version>5) {
        console.warn("Reading an unsupported version of the NRRD format; things may go haywire.");
    }

    // Parse lines
    for(i=1; i<lines.length; i++) {
        match = lineRE.exec(lines[i]);
        if (!match) {
            console.warn("Unrecognized line in NRRD header: " + lines[i]);
            continue;
        }
        if (match[2] == ': ') { // Field specification
            match[1] = mapNRRDToJavascript(match[1]);
            if ( match[1] == 'dataFile' &&
                 (match2 = dataFileListRE.exec(match[3]))) {
                // This should be the last field specification,
                // and the rest of the lines should contain file names.
                if (match2.length == 2 && match2[1]) { // subdim specification
                    ret[match[1]] = {
                        files: lines.slice(i+1),
                        subdim: parseNRRDInteger(match2[1])
                    };
                } else {
                    ret[match[1]] = lines.slice(i+1);
                }
                lines.length = i;
            } else {
                ret[match[1]] = parseField(match[1], match[3]);
            }
        } else if (match[2] == ':=') { // Key/value pair
            ret.keys[match[1]] = unescapeValue(match[3]);
        } else {
            throw new Error("Logic error in NRRD parser."); // This should never happen (unless the NRRD syntax is extended and the regexp is updated, but this section is not, or some other programmer error).
        }
    }

    // Make sure the file satisfies the requirements of the NRRD format
    checkNRRD(ret);
    
    // "Parse" data
    if ('dataFile' in ret) {
        console.warn("No support for external data yet!");
    } else {
        switch(ret.encoding) {
        case 'raw':
            ret.data = parseNRRDRawData(ret.buffer, ret.type, ret.sizes, {
                endian: ret.endian, blockSize: ret.blockSize
            });
            break;
        case 'ascii':
            ret.data = parseNRRDTextData(ret.buffer, ret.type, ret.sizes);
            break;
        default:
            console.warn("Unsupported NRRD encoding: " + ret.encoding);
        }
    }
    
    return ret;
};

function escapeValue(val) {
    return val.replace('\\', '\\\\').replace('\n', '\\n');
}

function unescapeValue(val) {
    return val.split('\\\\').map(
        function(s) { return s.replace('\\n', '\n'); }
        ).join('\\');
}

// Serializes NRRD fields
function serializeField(prop, value, dimension, spaceDimension) {
    var line;
    var propNRRD = mapJavascriptToNRRD(prop);
    switch(prop) {
    // nrrd-js stuff: skip
    case 'data':
    case 'buffer':
    case 'keys':
    case 'version':
        break;
    // Literal (uninterpreted) fields
    case 'content':
    case 'number':
    case 'sampleUnits':
    case 'space':
        line = propNRRD + ": " + value;
        break;
    // Integers (no infinity or whatever, just a plain integer, so the default serialization is good enough)
    case 'blockSize':
    case 'lineSkip':
    case 'byteSkip':
    case 'dimension':
    case 'spaceDimension':
        assert((typeof value) == "number" || value instanceof Number, "Field " + prop + " should at least contain a number!");
        line = propNRRD + ": " + value;
        break;
    // Floats (default serialization is good enough, as NaN contains nan, ignoring case, and similarly for Infinity inf)
    case 'min':
    case 'max':
    case 'oldMin':
    case 'oldMax':
        assert((typeof value) == "number" || value instanceof Number, "Field " + prop + " should contain a number!");
        line = propNRRD + ": " + value;
        break;
    // Vectors
    case 'spaceOrigin':
        assert(value.length === spaceDimension, "Field " + prop + " should be a list with length equal to the space dimension!");
        value.forEach(function (val) { assert((typeof val) == "number" || val instanceof Number, "Field " + prop + " should be a list of numbers!"); });
        line = propNRRD + ": (" + value.join(",") + ")";
        break;
    // Lists of strings
    case 'labels':
    case 'units':
    case 'spaceUnits':
        assert(value.length !== undefined && value.length == dimension, "Field " + prop + " should be a list with length equal to the dimension!");
        value.forEach(function (val) { assert((typeof val) == "string" || val instanceof String, "Field " + prop + " should be a list of numbers!"); });
        line = propNRRD + ": " + value.map(serializeNRRDQuotedString).join(" ");
        break;
    // Lists of integers
    case 'sizes':
        assert(value.length !== undefined && value.length == dimension, "Field " + prop + " should be a list with length equal to the dimension!");
        value.forEach(function (val) { assert((typeof val) == "number" || val instanceof Number, "Field " + prop + " should be a list of numbers!"); });
        line = propNRRD + ": " + value.join(" ");
        break;
    // Lists of floats
    case 'spacings':
    case 'thicknesses':
    case 'axisMins':
    case 'axisMaxs':
        assert(value.length !== undefined && value.length == dimension, "Field " + prop + " should be a list with length equal to the dimension!");
        value.forEach(function (val) { assert((typeof val) == "number" || val instanceof Number, "Field " + prop + " should be a list of numbers!"); });
        line = propNRRD + ": " + value.join(" ");
        break;
    // Lists of vectors (dimension sized)
    case 'spaceDirections':
        assert(value.length !== undefined && value.length === dimension, "Field " + prop + " should be a list with length equal to the dimension!");
        value.forEach(function (vec) {
          assert(vec === null || (vec.length !== undefined && vec.length === spaceDimension), "The elements of field " + prop + " should be lists with length equal to the space dimension!");
          if (vec !== null) vec.forEach(function (val) { assert((typeof val) == "number" || val instanceof Number, "The elements of field " + prop + " should be lists of numbers!"); });
        });
        line = propNRRD + ": " + value.map(function(vec) { return vec === null ? "none" : ("(" + vec.join(",") + ")"); }).join(" ");
        break;
    // Lists of vectors (space dimension sized)
    case 'measurementFrame':
        assert(value.length !== undefined && value.length === spaceDimension, "Field " + prop + " should be a list with length equal to the space dimension!");
        value.forEach(function (vec) {
          assert(vec === null || (vec.length !== undefined && vec.length === spaceDimension), "The elements of field " + prop + " should be lists with length equal to the space dimension!");
          if (vec !== null) vec.forEach(function (val) { assert((typeof val) == "number" || val instanceof Number, "The elements of field " + prop + " should be lists of numbers!"); });
        });
        line = propNRRD + ": " + value.map(function(vec) { return vec === null ? "none" : ("(" + vec.join(",") + ")"); }).join(" ");
        break;
    // One-of-a-kind fields
    case 'type':
        assert((typeof value) == "string" || value instanceof String, "Field " + prop + " should contain a string!");
        line = propNRRD + ": " + value;
        break;
    case 'encoding':
        assert((typeof value) == "string" || value instanceof String, "Field " + prop + " should contain a string!");
        line = propNRRD + ": " + value;
        break;
    case 'endian':
        assert((typeof value) == "string" || value instanceof String, "Field " + prop + " should contain a string!");
        line = propNRRD + ": " + value;
        break;
    case 'dataFile':
        if (value.length || (value.files && 'subdim' in value)) {
            // List of data files: skip for now
        } else {
            line = propNRRD + ": " + serializeNRRDDataFile(value);
        }
        break;
    case 'centers':
        assert(value.length !== undefined && value.length == dimension, "Field " + prop + " should be a list with length equal to the dimension!");
        line = propNRRD + ": " + value.map(serializeNRRDOptional).join(" ");
        break;
    case 'kinds':
        assert(value.length !== undefined && value.length == dimension, "Field " + prop + " should be a list with length equal to the dimension!");
        line = propNRRD + ": " + value.map(serializeNRRDOptional).join(" ");
        break;
    // Something unknown
    default:
        console.warn("Unrecognized NRRD field: " + prop + ", skipping.");
    }
    return line;
}

// Parses and normalizes NRRD fields, assumes the field names are already lower case.
function parseField(identifier, descriptor) {
    switch(identifier) {
    // Literal (uninterpreted) fields
    case 'content':
    case 'number':
    case 'sampleUnits':
        break;
    // Integers
    case 'dimension':
    case 'blockSize':
    case 'lineSkip':
    case 'byteSkip':
    case 'spaceDimension':
        descriptor = parseNRRDInteger(descriptor);
        break;
    // Floats
    case 'min':
    case 'max':
    case 'oldMin':
    case 'oldMax':
        descriptor = parseNRRDFloat(descriptor);
        break;
    // Vectors
    case 'spaceOrigin':
        descriptor = parseNRRDVector(descriptor);
        break;
    // Lists of strings
    case 'labels':
    case 'units':
    case 'spaceUnits':
        descriptor = parseNRRDWhitespaceSeparatedList(descriptor, parseNRRDQuotedString);
        break;
    // Lists of integers
    case 'sizes':
        descriptor = parseNRRDWhitespaceSeparatedList(descriptor, parseNRRDInteger);
        break;
    // Lists of floats
    case 'spacings':
    case 'thicknesses':
    case 'axisMins':
    case 'axisMaxs':
        descriptor = parseNRRDWhitespaceSeparatedList(descriptor, parseNRRDFloat);
        break;
    // Lists of vectors
    case 'spaceDirections':
    case 'measurementFrame':
        descriptor = parseNRRDWhitespaceSeparatedList(descriptor, parseNRRDVector);
        break;
    // One-of-a-kind fields
    case 'type':
        descriptor = parseNRRDType(descriptor);
        break;
    case 'encoding':
        descriptor = parseNRRDEncoding(descriptor);
        break;
    case 'endian':
        descriptor = parseNRRDEndian(descriptor);
        break;
    case 'dataFile':
        descriptor = parseNRRDDataFile(descriptor);
        break;
    case 'centers':
        descriptor = parseNRRDWhitespaceSeparatedList(descriptor, parseNRRDCenter);
        break;
    case 'kinds':
        descriptor = parseNRRDWhitespaceSeparatedList(descriptor, parseNRRDKind);
        break;
    case 'space':
        descriptor = parseNRRDSpace(descriptor);
        break;
    // Something unknown
    default:
        console.warn("Unrecognized NRRD field: " + identifier);
    }
    return descriptor;
}

// This only includes names whose lower case form is different from the Javascript form.
var mapNRRDToJavascriptStatic = {
    'block size': 'blockSize',
    'blocksize': 'blockSize',
    'old min': 'oldMin',
    'oldmin': 'oldMin',
    'old max': 'oldMax',
    'oldmax': 'oldMax',
    'data file': 'dataFile',
    'datafile': 'dataFile',
    'line skip': 'lineSkip',
    'lineskip': 'lineSkip',
    'byte skip': 'byteSkip',
    'byteskip': 'byteSkip',
    'sample units': 'sampleUnits',
    'sampleunits': 'sampleUnits',
    'axis mins': 'axisMins',
    'axis maxs': 'axisMaxs',
    'centers': 'centers', // Not different, just included so it is clear why centerings maps to centers
    'centerings': 'centers',
    'space dimension': 'spaceDimension',
    'space units': 'spaceUnits',
    'space origin': 'spaceOrigin',
    'space directions': 'spaceDirections',
    'measurement frame': 'measurementFrame'
};
var mapJavascriptToNRRDStatic = function() {
  var id, m = {};
  for(id in mapNRRDToJavascriptStatic) {
    m[mapNRRDToJavascriptStatic[id]] = id;
  }
  return m;
}();
function mapNRRDToJavascript(id) {
    // In any case, use the lower case version of the id
    id = id.toLowerCase();
    // Filter out any fields for which we have an explicit Javascript name
    if (id in mapNRRDToJavascriptStatic) return mapNRRDToJavascriptStatic[id];
    // Otherwise, just return the (lower case) id
    return id;
}
function mapJavascriptToNRRD(id) {
    // Filter out any fields for which we have an explicit NRRD name
    if (id in mapJavascriptToNRRDStatic) return mapJavascriptToNRRDStatic[id];
    // Otherwise, just return the id
    return id;
}

function parseNRRDInteger(str) {
    var val = parseInt(str, 10);
    if (Number.isNaN(val)) throw new Error("Malformed NRRD integer: " + str);
    return val;
}

function parseNRRDFloat(str) {
    str = str.toLowerCase();
    if (str.indexOf('nan')>=0) return NaN;
    if (str.indexOf('-inf')>=0) return -Infinity;
    if (str.indexOf('inf')>=0) return Infinity;
    var val = parseFloat(str);
    if (Number.isNaN(val)) throw new Error("Malformed NRRD float: " + str);
    return val;
}

function parseNRRDVector(str) {
    if (str == "none") return null;
    if (str.length<2 || str[0]!=="(" || str[str.length-1]!==")") throw new Error("Malformed NRRD vector: " + str);
    return str.slice(1, -1).split(",").map(parseNRRDFloat);
}

function parseNRRDQuotedString(str) {
    if (length<2 || str[0]!='"' || str[str.length-1]!='"') {
        throw new Error("Invalid NRRD quoted string: " + str);
    }
    return str.slice(1, -1).replace('\\"', '"');
}

function serializeNRRDQuotedString(str) {
    return '"' + str.replace('"', '\\"') + '"';
}

var whitespaceListSeparator = /[ \t]+/; // Note that this excludes other types of whitespace on purpose!
function parseNRRDWhitespaceSeparatedList(str, parseElement) {
    return str.split(whitespaceListSeparator).map(parseElement);
}

function parseNRRDType(descriptor) {
    switch(descriptor.toLowerCase()) {
    case "signed char":
    case "int8":
    case "int8_t":
        return 'int8';
    case "uchar":
    case "unsigned char":
    case "uint8":
    case "uint8_t":
        return 'uint8';
    case "short":
    case "short int":
    case "signed short":
    case "signed short int":
    case "int16":
    case "int16_t":
        return 'int16';
    case "ushort":
    case "unsigned short":
    case "unsigned short int":
    case "uint16":
    case "uint16_t":
        return 'uint16';
    case "int":
    case "signed int":
    case "int32":
    case "int32_t":
        return 'int32';
    case "uint":
    case "unsigned int":
    case "uint32":
    case "uint32_t":
        return 'uint32';
    case "longlong":
    case "long long":
    case "long long int":
    case "signed long long":
    case "signed long long int":
    case "int64":
    case "int64_t":
        return 'int64';
    case "ulonglong":
    case "unsigned long long":
    case "unsigned long long int":
    case "uint64":
    case "uint64_t":
        return 'uint64';
    case "float":
        return 'float';
    case "double":
        return 'double';
    case "block":
        return 'block';
    default:
        console.warn("Unrecognized NRRD type: " + descriptor);
        return descriptor;
    }
}

function parseNRRDEncoding(encoding) {
    switch(encoding.toLowerCase()) {
    case "raw":
        return "raw";
    case "txt":
    case "text":
    case "ascii":
        return "ascii";
    case "hex":
        return "hex";
    case "gz":
    case "gzip":
        return "gzip";
    case "bz2":
    case "bzip2":
        return "bzip2";
    default:
        console.warn("Unrecognized NRRD encoding: " + encoding);
        return encoding;
    }
}

function parseNRRDSpace(space) {
    switch(space.toLowerCase()) {
    case "right-anterior-superior":
    case "ras":
        return "right-anterior-superior";
    case "left-anterior-superior":
    case "las":
        return "left-anterior-superior";
    case "left-posterior-superior":
    case "lps":
        return "left-posterior-superior";
 	  case "right-anterior-superior-time":
 	  case "rast":
        return "right-anterior-superior-time";
    case "left-anterior-superior-time":
    case "last":
        return "left-anterior-superior-time";
    case "left-posterior-superior-time":
    case "lpst":
        return "left-posterior-superior-time";
    case "scanner-xyz":
        return "scanner-xyz";
    case "scanner-xyz-time":
        return "scanner-xyz-time";
    case "3d-right-handed":
        return "3D-right-handed";
    case "3d-left-handed":
        return "3D-left-handed";
    case "3d-right-handed-time":
        return "3D-right-handed-time";
    case "3d-left-handed-time":
        return "3D-left-handed-time";
    default:
        console.warn("Unrecognized space: " + space);
        return space;
    }
}

function parseNRRDEndian(endian) {
    switch(endian.toLowerCase()) {
    case 'little':
        return 'little';
    case 'big':
        return 'big';
    default:
        console.warn("Unrecognized NRRD endianness: " + endian);
        return endian;
    }
}

// Note that this function will never encounter the LIST data file specification format, as this is handled elsewhere.
var dataFileFormatRE = / (-?\d+) (-?\d+) (-?\d+)(?: (\d+))?$/;
function parseNRRDDataFile(dataFile) {
    var match = dataFileFormatRE.exec(dataFile);
    if (match) { // We have a format specification
        if (match.length == 5 && match[4]) { // subdim specification
            return {
                format: dataFile.substring(0, match.index),
                min: parseNRRDInteger(match[1]),
                max: parseNRRDInteger(match[2]),
                step: parseNRRDInteger(match[3]),
                subdim: parseNRRDInteger(match[4])
            };
        } else {
            return {
                format: dataFile.substring(0, match.index),
                min: parseNRRDInteger(match[1]),
                max: parseNRRDInteger(match[2]),
                step: parseNRRDInteger(match[3])
            };
        }
    } else { // Just a file
        return dataFile;
    }
}

function serializeNRRDDataFile(dataFile) {
    if ((typeof dataFile) == "string" || dataFile instanceof String) {
        return dataFile;
    } else if ('format' in dataFile && 'min' in dataFile && 'max' in dataFile && 'step' in dataFile) {
        if ('subdim' in dataFile) {
            return dataFile.format + " " + dataFile.min + " " + dataFile.max + " " + dataFile.step + " " + dataFile.subdim;
        } else {
            return dataFile.format + " " + dataFile.min + " " + dataFile.max + " " + dataFile.step;
        }
    } else {
        throw new Error("Unrecognized data file format!");
    }
}

function parseNRRDCenter(center) {
    switch(center.toLowerCase()) {
    case "cell":
        return "cell";
    case "node":
        return "node";
    case "???":
    case "none":
        return null;
    default:
        console.warn("Unrecognized NRRD center: " + center);
        return center;
    }
}

var NRRDKinds = {
    "domain": "domain",
    "space": "space",
    "time": "time",
    "list": "list",
    "point": "point",
    "vector": "vector",
    "covariant-vector": "covariant-vector",
    "normal": "normal",
    "stub": "stub",
    "scalar": "scalar",
    "complex": "complex",
    "2-vector": "2-vector",
    "3-color": "3-color",
    "rgb-color": "RGB-color",
    "hsv-color": "HSV-color",
    "xyz-color": "XYZ-color",
    "4-color": "4-color",
    "rgba-color": "RGBA-color",
    "3-vector": "3-vector",
    "3-gradient": "3-gradient",
    "3-normal": "3-normal",
    "4-vector": "4-vector",
    "quaternion": "quaternion",
    "2d-symmetric-matrix": "2D-symmetric-matrix",
    "2d-masked-symmetric-matrix": "2D-masked-symmetric-matrix",
    "2d-matrix": "2D-matrix",
    "2d-masked-matrix": "2D-masked-matrix",
    "3d-symmetric-matrix": "3D-symmetric-matrix",
    "3d-masked-symmetric-matrix": "3D-masked-symmetric-matrix",
    "3d-matrix": "3D-matrix",
    "3d-masked-matrix": "3D-masked-matrix",
    "???": null,
    "none": null
};
function parseNRRDKind(kind) {
    var kindLC = kind.toLowerCase();
    if (kindLC in NRRDKinds) return NRRDKinds[kindLC];
    console.warn("Unrecognized NRRD kind: " + kind);
    return kind;
}

function serializeNRRDOptional(a) {
    return a===null ? "???" : a;
}

var systemEndianness = (function() {
    var buf = new ArrayBuffer(4),
        intArr = new Uint32Array(buf),
        byteArr = new Uint8Array(buf);
    intArr[0] = 0x01020304;
    if (byteArr[0]==1 && byteArr[1]==2 && byteArr[2]==3 && byteArr[3]==4) {
        return 'big';
    } else if (byteArr[0]==4 && byteArr[1]==3 && byteArr[2]==2 && byteArr[3]==1) {
        return 'little';
    }
    console.warn("Unrecognized system endianness!");
    return undefined;
})();

function parseNRRDRawData(buffer, type, sizes, options) {
    var i, arr, view, totalLen = 1, endianFlag;
    for(i=0; i<sizes.length; i++) {
        if (sizes[i]<=0) throw new Error("Sizes should be a list of positive (>0) integers!");
        totalLen *= sizes[i];
    }
    if (type == 'block') {
        // Don't do anything special, just return the slice containing all blocks.
        return buffer.slice(0,totalLen*options.blockSize);
    } else if (type == 'int8' || type == 'uint8' || options.endian == systemEndianness) {
        switch(type) {
        case "int8":
            checkSize(1);
            return new Int8Array(buffer.slice(0,totalLen));
        case "uint8":
            checkSize(1);
            return new Uint8Array(buffer.slice(0,totalLen));
        case "int16":
            checkSize(2);
            return new Int16Array(buffer.slice(0,totalLen*2));
        case "uint16":
            checkSize(2);
            return new Uint16Array(buffer.slice(0,totalLen*2));
        case "int32":
            checkSize(4);
            return new Int32Array(buffer.slice(0,totalLen*4));
        case "uint32":
            checkSize(4);
            return new Uint32Array(buffer.slice(0,totalLen*4));
        //case "int64":
        //    checkSize(8);
        //    return new Int64Array(buffer.slice(0,totalLen*8));
        //case "uint64":
        //    checkSize(8);
        //    return new Uint64Array(buffer.slice(0,totalLen*8));
        case "float":
            checkSize(4);
            return new Float32Array(buffer.slice(0,totalLen*4));
        case "double":
            checkSize(8);
            return new Float64Array(buffer.slice(0,totalLen*8));
        default:
            console.warn("Unsupported NRRD type: " + type + ", returning raw buffer.");
            return undefined;
        }
    } else {
        switch(options.endian) {
        case 'big':
            endianFlag = false;
            break;
        case 'little':
            endianFlag = true;
            break;
        default:
            console.warn("Unsupported endianness in NRRD file: " + options.endian);
            return undefined;
        }
        view = new DataView(buffer);
        switch(type) {
        case "int8": // Note that here we do not need to check the size of the buffer, as the DataView.get methods should throw an exception if we read beyond the buffer.
            arr = new Int8Array(totalLen);
            for(i=0; i<totalLen; i++) {
                arr[i] = view.getInt8(i);
            }
            return arr;
        case "uint8":
            arr = new Uint8Array(totalLen);
            for(i=0; i<totalLen; i++) {
                arr[i] = view.getUint8(i);
            }
            return arr;
        case "int16":
            arr = new Int16Array(totalLen);
            for(i=0; i<totalLen; i++) {
                arr[i] = view.getInt16(i*2);
            }
            return arr;
        case "uint16":
            arr = new Uint16Array(totalLen);
            for(i=0; i<totalLen; i++) {
                arr[i] = view.getUint16(i*2);
            }
            return arr;
        case "int32":
            arr = new Int32Array(totalLen);
            for(i=0; i<totalLen; i++) {
                arr[i] = view.getInt32(i*4);
            }
            return arr;
        case "uint32":
            arr = new Uint32Array(totalLen);
            for(i=0; i<totalLen; i++) {
                arr[i] = view.getUint32(i*4);
            }
            return arr;
        //case "int64":
        //    arr = new Int64Array(totalLen);
        //    for(i=0; i<totalLen; i++) {
        //        arr[i] = view.getInt64(i*8);
        //    }
        //    return arr;
        //case "uint64":
        //    arr = new Uint64Array(totalLen);
        //    for(i=0; i<totalLen; i++) {
        //        arr[i] = view.getUint64(i*8);
        //    }
        //    return arr;
        case "float":
            arr = new Float32Array(totalLen);
            for(i=0; i<totalLen; i++) {
                arr[i] = view.getFloat32(i*4);
            }
            return arr;
        case "double":
            arr = new Float64Array(totalLen);
            for(i=0; i<totalLen; i++) {
                arr[i] = view.getFloat64(i*8);
            }
            return arr;
        default:
            console.warn("Unsupported NRRD type: " + type + ", returning raw buffer.");
            return undefined;
        }
    }
    function checkSize(sizeOfType) {
        if (buffer.byteLength<totalLen*sizeOfType) throw new Error("NRRD file does not contain enough data!");
    }
}

var whitespaceDataValueListSeparatorRE = /[ \t\n\r\v\f]+/;
function parseNRRDTextData(buffer, type, sizes) {
    var i, buf8, str, strList, totalLen = 1;
    for(i=0; i<sizes.length; i++) {
        if (sizes[i]<=0) throw new Error("Sizes should be a list of positive (>0) integers!");
        totalLen *= sizes[i];
    }
    buf8 = new Uint8Array(buffer);
    str = String.fromCharCode.apply(null, buf8);
    strList = str.split(whitespaceDataValueListSeparatorRE);
    if (strList.length<totalLen) {
        throw new Error("Not enough data in NRRD file!");
    } else if (strList.length>totalLen) {
        if (strList[0] === '') strList = strList.slice(1); // Strictly speaking the spec doesn't (explicitly) allow whitespace in front of the first number, but let's be lenient.
        strList = strList.slice(0, totalLen);
    }
    switch(type) {
    case "int8":
        return new Int8Array(strList.map(parseNRRDInteger));
    case "uint8":
        return new Uint8Array(strList.map(parseNRRDInteger));
    case "int16":
        return new Int16Array(strList.map(parseNRRDInteger));
    case "uint16":
        return new Uint16Array(strList.map(parseNRRDInteger));
    case "int32":
        return new Int32Array(strList.map(parseNRRDInteger));
    case "uint32":
        return new Uint32Array(strList.map(parseNRRDInteger));
    //case "int64":
    //    return new Int64Array(strList.map(parseNRRDInteger));
    //case "uint64":
    //    return new Uint64Array(strList.map(parseNRRDInteger));
    case "float":
        return new Float32Array(strList.map(parseNRRDFloat));
    case "double":
        return new Float64Array(strList.map(parseNRRDFloat));
    default:
        console.warn("Unsupported NRRD type: " + type + ".");
        return undefined;
    }
}

// This ALWAYS returns an integer, or throws an exception.
function getNRRDTypeSize(type) {
    switch(type) {
    case "int8":
        return 1;
    case "uint8":
        return 1;
    case "int16":
        return 2;
    case "uint16":
        return 2;
    case "int32":
        return 4;
    case "uint32":
        return 4;
    case "int64":
        return 8;
    case "uint64":
        return 8;
    case "float":
        return 4;
    case "double":
        return 8;
    default:
        throw new Error("Do not know the size of NRRD type: " + type);
    }
}

function checkNRRD(ret) {
    // Always necessary fields
    if (ret.dimension===undefined) {
        throw new Error("Dimension missing from NRRD file!");
    } else if (ret.type===undefined) {
        throw new Error("Type missing from NRRD file!");
    } else if (ret.encoding===undefined) {
        throw new Error("Encoding missing from NRRD file!");
    } else if (ret.sizes===undefined) {
        throw new Error("Sizes missing from NRRD file!");
    }
    
    // Sometimes necessary fields
    if (ret.type != 'block' && ret.type != 'int8' && ret.type != 'uint8' &&
          ret.encoding != 'ascii' && ret.endian === undefined) {
        throw new Error("Endianness missing from NRRD file!");
    } else if (ret.type == 'block' && ret.blockSize === undefined) {
        throw new Error("Missing block size in NRRD file!");
    }
    
    // Check dimension and per-axis field lengths
    if (ret.dimension === 0) {
        throw new Error("Zero-dimensional NRRD file?");
    } else if (ret.dimension != ret.sizes.length) {
        throw new Error("Length of 'sizes' is different from 'dimension' in an NRRD file!");
    } else if (ret.spacings && ret.dimension != ret.spacings.length) {
        throw new Error("Length of 'spacings' is different from 'dimension' in an NRRD file!");
    } else if (ret.thicknesses && ret.dimension != ret.thicknesses.length) {
        throw new Error("Length of 'thicknesses' is different from 'dimension' in an NRRD file!");
    } else if (ret.axisMins && ret.dimension != ret.axisMins.length) {
        throw new Error("Length of 'axis mins' is different from 'dimension' in an NRRD file!");
    } else if (ret.axisMaxs && ret.dimension != ret.axisMaxs.length) {
        throw new Error("Length of 'axis maxs' is different from 'dimension' in an NRRD file!");
    } else if (ret.centers && ret.dimension != ret.centers.length) {
        throw new Error("Length of 'centers' is different from 'dimension' in an NRRD file!");
    } else if (ret.labels && ret.dimension != ret.labels.length) {
        throw new Error("Length of 'labels' is different from 'dimension' in an NRRD file!");
    } else if (ret.units && ret.dimension != ret.units.length) {
        throw new Error("Length of 'units' is different from 'dimension' in an NRRD file!");
    } else if (ret.kinds && ret.dimension != ret.kinds.length) {
        throw new Error("Length of 'kinds' is different from 'dimension' in an NRRD file!");
    }
    
    // TODO: Check space/orientation fields.
    
    // We should either have inline data or external data
    if ((ret.data === undefined || ret.data.length === 0) && (ret.buffer === undefined || ret.buffer.byteLength === 0) && ret.dataFile === undefined) {
        throw new Error("NRRD file has neither inline or external data!");
    }
}

function castTypedArray(data, type) {
    switch(type) {
    case "int8":
        return new Int8Array(data);
    case "uint8":
        return new Uint8Array(data);
    case "int16":
        return new Int16Array(data);
    case "uint16":
        return new Uint16Array(data);
    case "int32":
        return new Int32Array(data);
    case "uint32":
        return new Uint32Array(data);
    //case "int64":
    //    return new Int64Array(data);
    //case "uint64":
    //    return new Uint64Array(data);
    case "float":
        return new Float32Array(data);
    case "double":
        return new Float64Array(data);
    default:
        throw new Error("Cannot cast to NRRD type: " + type);
    }
}

function serializeToBuffer(data, type, endian) {
    var i, endianFlag, view, nativeSize = getNRRDTypeSize(type), buffer = new ArrayBuffer(data.length*nativeSize);
    switch(endian) {
    case 'big':
        endianFlag = false;
        break;
    case 'little':
        endianFlag = true;
        break;
    default:
        console.warn("Unsupported endianness in NRRD file: " + endian);
        return undefined;
    }
    view = new DataView(buffer);
    switch(type) {
    case "int8": // Note that here we do not need to check the size of the buffer, as the DataView.get methods should throw an exception if we read beyond the buffer.
        for(i=0; i<data.length; i++) {
            view.setInt8(i, data[i], endianFlag);
        }
        return buffer;
    case "uint8":
        for(i=0; i<data.length; i++) {
            view.setUint8(i, data[i], endianFlag);
        }
        return buffer;
    case "int16":
        for(i=0; i<data.length; i++) {
            view.setInt16(i*2, data[i], endianFlag);
        }
        return buffer;
    case "uint16":
        for(i=0; i<data.length; i++) {
            view.setUint16(i*2, data[i], endianFlag);
        }
        return buffer;
    case "int32":
        for(i=0; i<data.length; i++) {
            view.setInt32(i*4, data[i], endianFlag);
        }
        return buffer;
    case "uint32":
        for(i=0; i<data.length; i++) {
            view.setUint32(i*4, data[i], endianFlag);
        }
        return buffer;
    //case "int64":
    //    for(i=0; i<data.length; i++) {
    //        view.setInt64(i*8, data[i], endianFlag);
    //    }
    //    return buffer;
    //case "uint64":
    //    for(i=0; i<data.length; i++) {
    //        view.setUint64(i*8, data[i], endianFlag);
    //    }
    //    return buffer;
    case "float":
        for(i=0; i<data.length; i++) {
            view.setFloat32(i*4, data[i], endianFlag);
        }
        return buffer;
    case "double":
        for(i=0; i<data.length; i++) {
            view.setFloat64(i*8, data[i], endianFlag);
        }
        return buffer;
    default:
        console.warn("Cannot serialize NRRD type: " + type + ".");
        return undefined;
    }
}

function serializeToTextBuffer(data) {
    var i, strs = new Array(data.length), str, buffer, arr;
    for(i=0; i<data.length; i++) {
        strs[i] = '' + data[i];
    }
    str = strs.join(" ");
    buffer = new ArrayBuffer(str.length);
    arr = new Uint8Array(buffer);
    for(i=0; i<arr.length; i++) {
        arr[i] = str.charCodeAt(i);
    }
    return buffer;
}

},{"assert":3}],51:[function(require,module,exports){
// Top level file is just a mixin of submodules & constants
'use strict';

var assign    = require('./lib/utils/common').assign;

var deflate   = require('./lib/deflate');
var inflate   = require('./lib/inflate');
var constants = require('./lib/zlib/constants');

var pako = {};

assign(pako, deflate, inflate, constants);

module.exports = pako;

},{"./lib/deflate":52,"./lib/inflate":53,"./lib/utils/common":54,"./lib/zlib/constants":57}],52:[function(require,module,exports){
'use strict';


var zlib_deflate = require('./zlib/deflate');
var utils        = require('./utils/common');
var strings      = require('./utils/strings');
var msg          = require('./zlib/messages');
var ZStream      = require('./zlib/zstream');

var toString = Object.prototype.toString;

/* Public constants ==========================================================*/
/* ===========================================================================*/

var Z_NO_FLUSH      = 0;
var Z_FINISH        = 4;

var Z_OK            = 0;
var Z_STREAM_END    = 1;
var Z_SYNC_FLUSH    = 2;

var Z_DEFAULT_COMPRESSION = -1;

var Z_DEFAULT_STRATEGY    = 0;

var Z_DEFLATED  = 8;

/* ===========================================================================*/


/**
 * class Deflate
 *
 * Generic JS-style wrapper for zlib calls. If you don't need
 * streaming behaviour - use more simple functions: [[deflate]],
 * [[deflateRaw]] and [[gzip]].
 **/

/* internal
 * Deflate.chunks -> Array
 *
 * Chunks of output data, if [[Deflate#onData]] not overriden.
 **/

/**
 * Deflate.result -> Uint8Array|Array
 *
 * Compressed result, generated by default [[Deflate#onData]]
 * and [[Deflate#onEnd]] handlers. Filled after you push last chunk
 * (call [[Deflate#push]] with `Z_FINISH` / `true` param)  or if you
 * push a chunk with explicit flush (call [[Deflate#push]] with
 * `Z_SYNC_FLUSH` param).
 **/

/**
 * Deflate.err -> Number
 *
 * Error code after deflate finished. 0 (Z_OK) on success.
 * You will not need it in real life, because deflate errors
 * are possible only on wrong options or bad `onData` / `onEnd`
 * custom handlers.
 **/

/**
 * Deflate.msg -> String
 *
 * Error message, if [[Deflate.err]] != 0
 **/


/**
 * new Deflate(options)
 * - options (Object): zlib deflate options.
 *
 * Creates new deflator instance with specified params. Throws exception
 * on bad params. Supported options:
 *
 * - `level`
 * - `windowBits`
 * - `memLevel`
 * - `strategy`
 * - `dictionary`
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Additional options, for internal needs:
 *
 * - `chunkSize` - size of generated data chunks (16K by default)
 * - `raw` (Boolean) - do raw deflate
 * - `gzip` (Boolean) - create gzip wrapper
 * - `to` (String) - if equal to 'string', then result will be "binary string"
 *    (each char code [0..255])
 * - `header` (Object) - custom header for gzip
 *   - `text` (Boolean) - true if compressed data believed to be text
 *   - `time` (Number) - modification time, unix timestamp
 *   - `os` (Number) - operation system code
 *   - `extra` (Array) - array of bytes with extra data (max 65536)
 *   - `name` (String) - file name (binary string)
 *   - `comment` (String) - comment (binary string)
 *   - `hcrc` (Boolean) - true if header crc should be added
 *
 * ##### Example:
 *
 * ```javascript
 * var pako = require('pako')
 *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])
 *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);
 *
 * var deflate = new pako.Deflate({ level: 3});
 *
 * deflate.push(chunk1, false);
 * deflate.push(chunk2, true);  // true -> last chunk
 *
 * if (deflate.err) { throw new Error(deflate.err); }
 *
 * console.log(deflate.result);
 * ```
 **/
function Deflate(options) {
  if (!(this instanceof Deflate)) return new Deflate(options);

  this.options = utils.assign({
    level: Z_DEFAULT_COMPRESSION,
    method: Z_DEFLATED,
    chunkSize: 16384,
    windowBits: 15,
    memLevel: 8,
    strategy: Z_DEFAULT_STRATEGY,
    to: ''
  }, options || {});

  var opt = this.options;

  if (opt.raw && (opt.windowBits > 0)) {
    opt.windowBits = -opt.windowBits;
  }

  else if (opt.gzip && (opt.windowBits > 0) && (opt.windowBits < 16)) {
    opt.windowBits += 16;
  }

  this.err    = 0;      // error code, if happens (0 = Z_OK)
  this.msg    = '';     // error message
  this.ended  = false;  // used to avoid multiple onEnd() calls
  this.chunks = [];     // chunks of compressed data

  this.strm = new ZStream();
  this.strm.avail_out = 0;

  var status = zlib_deflate.deflateInit2(
    this.strm,
    opt.level,
    opt.method,
    opt.windowBits,
    opt.memLevel,
    opt.strategy
  );

  if (status !== Z_OK) {
    throw new Error(msg[status]);
  }

  if (opt.header) {
    zlib_deflate.deflateSetHeader(this.strm, opt.header);
  }

  if (opt.dictionary) {
    var dict;
    // Convert data if needed
    if (typeof opt.dictionary === 'string') {
      // If we need to compress text, change encoding to utf8.
      dict = strings.string2buf(opt.dictionary);
    } else if (toString.call(opt.dictionary) === '[object ArrayBuffer]') {
      dict = new Uint8Array(opt.dictionary);
    } else {
      dict = opt.dictionary;
    }

    status = zlib_deflate.deflateSetDictionary(this.strm, dict);

    if (status !== Z_OK) {
      throw new Error(msg[status]);
    }

    this._dict_set = true;
  }
}

/**
 * Deflate#push(data[, mode]) -> Boolean
 * - data (Uint8Array|Array|ArrayBuffer|String): input data. Strings will be
 *   converted to utf8 byte sequence.
 * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.
 *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` meansh Z_FINISH.
 *
 * Sends input data to deflate pipe, generating [[Deflate#onData]] calls with
 * new compressed chunks. Returns `true` on success. The last data block must have
 * mode Z_FINISH (or `true`). That will flush internal pending buffers and call
 * [[Deflate#onEnd]]. For interim explicit flushes (without ending the stream) you
 * can use mode Z_SYNC_FLUSH, keeping the compression context.
 *
 * On fail call [[Deflate#onEnd]] with error code and return false.
 *
 * We strongly recommend to use `Uint8Array` on input for best speed (output
 * array format is detected automatically). Also, don't skip last param and always
 * use the same type in your code (boolean or number). That will improve JS speed.
 *
 * For regular `Array`-s make sure all elements are [0..255].
 *
 * ##### Example
 *
 * ```javascript
 * push(chunk, false); // push one of data chunks
 * ...
 * push(chunk, true);  // push last chunk
 * ```
 **/
Deflate.prototype.push = function (data, mode) {
  var strm = this.strm;
  var chunkSize = this.options.chunkSize;
  var status, _mode;

  if (this.ended) { return false; }

  _mode = (mode === ~~mode) ? mode : ((mode === true) ? Z_FINISH : Z_NO_FLUSH);

  // Convert data if needed
  if (typeof data === 'string') {
    // If we need to compress text, change encoding to utf8.
    strm.input = strings.string2buf(data);
  } else if (toString.call(data) === '[object ArrayBuffer]') {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }

  strm.next_in = 0;
  strm.avail_in = strm.input.length;

  do {
    if (strm.avail_out === 0) {
      strm.output = new utils.Buf8(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }
    status = zlib_deflate.deflate(strm, _mode);    /* no bad return value */

    if (status !== Z_STREAM_END && status !== Z_OK) {
      this.onEnd(status);
      this.ended = true;
      return false;
    }
    if (strm.avail_out === 0 || (strm.avail_in === 0 && (_mode === Z_FINISH || _mode === Z_SYNC_FLUSH))) {
      if (this.options.to === 'string') {
        this.onData(strings.buf2binstring(utils.shrinkBuf(strm.output, strm.next_out)));
      } else {
        this.onData(utils.shrinkBuf(strm.output, strm.next_out));
      }
    }
  } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== Z_STREAM_END);

  // Finalize on the last chunk.
  if (_mode === Z_FINISH) {
    status = zlib_deflate.deflateEnd(this.strm);
    this.onEnd(status);
    this.ended = true;
    return status === Z_OK;
  }

  // callback interim results if Z_SYNC_FLUSH.
  if (_mode === Z_SYNC_FLUSH) {
    this.onEnd(Z_OK);
    strm.avail_out = 0;
    return true;
  }

  return true;
};


/**
 * Deflate#onData(chunk) -> Void
 * - chunk (Uint8Array|Array|String): ouput data. Type of array depends
 *   on js engine support. When string output requested, each chunk
 *   will be string.
 *
 * By default, stores data blocks in `chunks[]` property and glue
 * those in `onEnd`. Override this handler, if you need another behaviour.
 **/
Deflate.prototype.onData = function (chunk) {
  this.chunks.push(chunk);
};


/**
 * Deflate#onEnd(status) -> Void
 * - status (Number): deflate status. 0 (Z_OK) on success,
 *   other if not.
 *
 * Called once after you tell deflate that the input stream is
 * complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)
 * or if an error happened. By default - join collected chunks,
 * free memory and fill `results` / `err` properties.
 **/
Deflate.prototype.onEnd = function (status) {
  // On success - join
  if (status === Z_OK) {
    if (this.options.to === 'string') {
      this.result = this.chunks.join('');
    } else {
      this.result = utils.flattenChunks(this.chunks);
    }
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};


/**
 * deflate(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to compress.
 * - options (Object): zlib deflate options.
 *
 * Compress `data` with deflate algorithm and `options`.
 *
 * Supported options are:
 *
 * - level
 * - windowBits
 * - memLevel
 * - strategy
 * - dictionary
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Sugar (options):
 *
 * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify
 *   negative windowBits implicitly.
 * - `to` (String) - if equal to 'string', then result will be "binary string"
 *    (each char code [0..255])
 *
 * ##### Example:
 *
 * ```javascript
 * var pako = require('pako')
 *   , data = Uint8Array([1,2,3,4,5,6,7,8,9]);
 *
 * console.log(pako.deflate(data));
 * ```
 **/
function deflate(input, options) {
  var deflator = new Deflate(options);

  deflator.push(input, true);

  // That will never happens, if you don't cheat with options :)
  if (deflator.err) { throw deflator.msg; }

  return deflator.result;
}


/**
 * deflateRaw(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to compress.
 * - options (Object): zlib deflate options.
 *
 * The same as [[deflate]], but creates raw data, without wrapper
 * (header and adler32 crc).
 **/
function deflateRaw(input, options) {
  options = options || {};
  options.raw = true;
  return deflate(input, options);
}


/**
 * gzip(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to compress.
 * - options (Object): zlib deflate options.
 *
 * The same as [[deflate]], but create gzip wrapper instead of
 * deflate one.
 **/
function gzip(input, options) {
  options = options || {};
  options.gzip = true;
  return deflate(input, options);
}


exports.Deflate = Deflate;
exports.deflate = deflate;
exports.deflateRaw = deflateRaw;
exports.gzip = gzip;

},{"./utils/common":54,"./utils/strings":55,"./zlib/deflate":59,"./zlib/messages":64,"./zlib/zstream":66}],53:[function(require,module,exports){
'use strict';


var zlib_inflate = require('./zlib/inflate');
var utils        = require('./utils/common');
var strings      = require('./utils/strings');
var c            = require('./zlib/constants');
var msg          = require('./zlib/messages');
var ZStream      = require('./zlib/zstream');
var GZheader     = require('./zlib/gzheader');

var toString = Object.prototype.toString;

/**
 * class Inflate
 *
 * Generic JS-style wrapper for zlib calls. If you don't need
 * streaming behaviour - use more simple functions: [[inflate]]
 * and [[inflateRaw]].
 **/

/* internal
 * inflate.chunks -> Array
 *
 * Chunks of output data, if [[Inflate#onData]] not overriden.
 **/

/**
 * Inflate.result -> Uint8Array|Array|String
 *
 * Uncompressed result, generated by default [[Inflate#onData]]
 * and [[Inflate#onEnd]] handlers. Filled after you push last chunk
 * (call [[Inflate#push]] with `Z_FINISH` / `true` param) or if you
 * push a chunk with explicit flush (call [[Inflate#push]] with
 * `Z_SYNC_FLUSH` param).
 **/

/**
 * Inflate.err -> Number
 *
 * Error code after inflate finished. 0 (Z_OK) on success.
 * Should be checked if broken data possible.
 **/

/**
 * Inflate.msg -> String
 *
 * Error message, if [[Inflate.err]] != 0
 **/


/**
 * new Inflate(options)
 * - options (Object): zlib inflate options.
 *
 * Creates new inflator instance with specified params. Throws exception
 * on bad params. Supported options:
 *
 * - `windowBits`
 * - `dictionary`
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Additional options, for internal needs:
 *
 * - `chunkSize` - size of generated data chunks (16K by default)
 * - `raw` (Boolean) - do raw inflate
 * - `to` (String) - if equal to 'string', then result will be converted
 *   from utf8 to utf16 (javascript) string. When string output requested,
 *   chunk length can differ from `chunkSize`, depending on content.
 *
 * By default, when no options set, autodetect deflate/gzip data format via
 * wrapper header.
 *
 * ##### Example:
 *
 * ```javascript
 * var pako = require('pako')
 *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])
 *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);
 *
 * var inflate = new pako.Inflate({ level: 3});
 *
 * inflate.push(chunk1, false);
 * inflate.push(chunk2, true);  // true -> last chunk
 *
 * if (inflate.err) { throw new Error(inflate.err); }
 *
 * console.log(inflate.result);
 * ```
 **/
function Inflate(options) {
  if (!(this instanceof Inflate)) return new Inflate(options);

  this.options = utils.assign({
    chunkSize: 16384,
    windowBits: 0,
    to: ''
  }, options || {});

  var opt = this.options;

  // Force window size for `raw` data, if not set directly,
  // because we have no header for autodetect.
  if (opt.raw && (opt.windowBits >= 0) && (opt.windowBits < 16)) {
    opt.windowBits = -opt.windowBits;
    if (opt.windowBits === 0) { opt.windowBits = -15; }
  }

  // If `windowBits` not defined (and mode not raw) - set autodetect flag for gzip/deflate
  if ((opt.windowBits >= 0) && (opt.windowBits < 16) &&
      !(options && options.windowBits)) {
    opt.windowBits += 32;
  }

  // Gzip header has no info about windows size, we can do autodetect only
  // for deflate. So, if window size not set, force it to max when gzip possible
  if ((opt.windowBits > 15) && (opt.windowBits < 48)) {
    // bit 3 (16) -> gzipped data
    // bit 4 (32) -> autodetect gzip/deflate
    if ((opt.windowBits & 15) === 0) {
      opt.windowBits |= 15;
    }
  }

  this.err    = 0;      // error code, if happens (0 = Z_OK)
  this.msg    = '';     // error message
  this.ended  = false;  // used to avoid multiple onEnd() calls
  this.chunks = [];     // chunks of compressed data

  this.strm   = new ZStream();
  this.strm.avail_out = 0;

  var status  = zlib_inflate.inflateInit2(
    this.strm,
    opt.windowBits
  );

  if (status !== c.Z_OK) {
    throw new Error(msg[status]);
  }

  this.header = new GZheader();

  zlib_inflate.inflateGetHeader(this.strm, this.header);
}

/**
 * Inflate#push(data[, mode]) -> Boolean
 * - data (Uint8Array|Array|ArrayBuffer|String): input data
 * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.
 *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` meansh Z_FINISH.
 *
 * Sends input data to inflate pipe, generating [[Inflate#onData]] calls with
 * new output chunks. Returns `true` on success. The last data block must have
 * mode Z_FINISH (or `true`). That will flush internal pending buffers and call
 * [[Inflate#onEnd]]. For interim explicit flushes (without ending the stream) you
 * can use mode Z_SYNC_FLUSH, keeping the decompression context.
 *
 * On fail call [[Inflate#onEnd]] with error code and return false.
 *
 * We strongly recommend to use `Uint8Array` on input for best speed (output
 * format is detected automatically). Also, don't skip last param and always
 * use the same type in your code (boolean or number). That will improve JS speed.
 *
 * For regular `Array`-s make sure all elements are [0..255].
 *
 * ##### Example
 *
 * ```javascript
 * push(chunk, false); // push one of data chunks
 * ...
 * push(chunk, true);  // push last chunk
 * ```
 **/
Inflate.prototype.push = function (data, mode) {
  var strm = this.strm;
  var chunkSize = this.options.chunkSize;
  var dictionary = this.options.dictionary;
  var status, _mode;
  var next_out_utf8, tail, utf8str;
  var dict;

  // Flag to properly process Z_BUF_ERROR on testing inflate call
  // when we check that all output data was flushed.
  var allowBufError = false;

  if (this.ended) { return false; }
  _mode = (mode === ~~mode) ? mode : ((mode === true) ? c.Z_FINISH : c.Z_NO_FLUSH);

  // Convert data if needed
  if (typeof data === 'string') {
    // Only binary strings can be decompressed on practice
    strm.input = strings.binstring2buf(data);
  } else if (toString.call(data) === '[object ArrayBuffer]') {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }

  strm.next_in = 0;
  strm.avail_in = strm.input.length;

  do {
    if (strm.avail_out === 0) {
      strm.output = new utils.Buf8(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }

    status = zlib_inflate.inflate(strm, c.Z_NO_FLUSH);    /* no bad return value */

    if (status === c.Z_NEED_DICT && dictionary) {
      // Convert data if needed
      if (typeof dictionary === 'string') {
        dict = strings.string2buf(dictionary);
      } else if (toString.call(dictionary) === '[object ArrayBuffer]') {
        dict = new Uint8Array(dictionary);
      } else {
        dict = dictionary;
      }

      status = zlib_inflate.inflateSetDictionary(this.strm, dict);

    }

    if (status === c.Z_BUF_ERROR && allowBufError === true) {
      status = c.Z_OK;
      allowBufError = false;
    }

    if (status !== c.Z_STREAM_END && status !== c.Z_OK) {
      this.onEnd(status);
      this.ended = true;
      return false;
    }

    if (strm.next_out) {
      if (strm.avail_out === 0 || status === c.Z_STREAM_END || (strm.avail_in === 0 && (_mode === c.Z_FINISH || _mode === c.Z_SYNC_FLUSH))) {

        if (this.options.to === 'string') {

          next_out_utf8 = strings.utf8border(strm.output, strm.next_out);

          tail = strm.next_out - next_out_utf8;
          utf8str = strings.buf2string(strm.output, next_out_utf8);

          // move tail
          strm.next_out = tail;
          strm.avail_out = chunkSize - tail;
          if (tail) { utils.arraySet(strm.output, strm.output, next_out_utf8, tail, 0); }

          this.onData(utf8str);

        } else {
          this.onData(utils.shrinkBuf(strm.output, strm.next_out));
        }
      }
    }

    // When no more input data, we should check that internal inflate buffers
    // are flushed. The only way to do it when avail_out = 0 - run one more
    // inflate pass. But if output data not exists, inflate return Z_BUF_ERROR.
    // Here we set flag to process this error properly.
    //
    // NOTE. Deflate does not return error in this case and does not needs such
    // logic.
    if (strm.avail_in === 0 && strm.avail_out === 0) {
      allowBufError = true;
    }

  } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== c.Z_STREAM_END);

  if (status === c.Z_STREAM_END) {
    _mode = c.Z_FINISH;
  }

  // Finalize on the last chunk.
  if (_mode === c.Z_FINISH) {
    status = zlib_inflate.inflateEnd(this.strm);
    this.onEnd(status);
    this.ended = true;
    return status === c.Z_OK;
  }

  // callback interim results if Z_SYNC_FLUSH.
  if (_mode === c.Z_SYNC_FLUSH) {
    this.onEnd(c.Z_OK);
    strm.avail_out = 0;
    return true;
  }

  return true;
};


/**
 * Inflate#onData(chunk) -> Void
 * - chunk (Uint8Array|Array|String): ouput data. Type of array depends
 *   on js engine support. When string output requested, each chunk
 *   will be string.
 *
 * By default, stores data blocks in `chunks[]` property and glue
 * those in `onEnd`. Override this handler, if you need another behaviour.
 **/
Inflate.prototype.onData = function (chunk) {
  this.chunks.push(chunk);
};


/**
 * Inflate#onEnd(status) -> Void
 * - status (Number): inflate status. 0 (Z_OK) on success,
 *   other if not.
 *
 * Called either after you tell inflate that the input stream is
 * complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)
 * or if an error happened. By default - join collected chunks,
 * free memory and fill `results` / `err` properties.
 **/
Inflate.prototype.onEnd = function (status) {
  // On success - join
  if (status === c.Z_OK) {
    if (this.options.to === 'string') {
      // Glue & convert here, until we teach pako to send
      // utf8 alligned strings to onData
      this.result = this.chunks.join('');
    } else {
      this.result = utils.flattenChunks(this.chunks);
    }
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};


/**
 * inflate(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * Decompress `data` with inflate/ungzip and `options`. Autodetect
 * format via wrapper header by default. That's why we don't provide
 * separate `ungzip` method.
 *
 * Supported options are:
 *
 * - windowBits
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information.
 *
 * Sugar (options):
 *
 * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify
 *   negative windowBits implicitly.
 * - `to` (String) - if equal to 'string', then result will be converted
 *   from utf8 to utf16 (javascript) string. When string output requested,
 *   chunk length can differ from `chunkSize`, depending on content.
 *
 *
 * ##### Example:
 *
 * ```javascript
 * var pako = require('pako')
 *   , input = pako.deflate([1,2,3,4,5,6,7,8,9])
 *   , output;
 *
 * try {
 *   output = pako.inflate(input);
 * } catch (err)
 *   console.log(err);
 * }
 * ```
 **/
function inflate(input, options) {
  var inflator = new Inflate(options);

  inflator.push(input, true);

  // That will never happens, if you don't cheat with options :)
  if (inflator.err) { throw inflator.msg; }

  return inflator.result;
}


/**
 * inflateRaw(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * The same as [[inflate]], but creates raw data, without wrapper
 * (header and adler32 crc).
 **/
function inflateRaw(input, options) {
  options = options || {};
  options.raw = true;
  return inflate(input, options);
}


/**
 * ungzip(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * Just shortcut to [[inflate]], because it autodetects format
 * by header.content. Done for convenience.
 **/


exports.Inflate = Inflate;
exports.inflate = inflate;
exports.inflateRaw = inflateRaw;
exports.ungzip  = inflate;

},{"./utils/common":54,"./utils/strings":55,"./zlib/constants":57,"./zlib/gzheader":60,"./zlib/inflate":62,"./zlib/messages":64,"./zlib/zstream":66}],54:[function(require,module,exports){
arguments[4][6][0].apply(exports,arguments)
},{"dup":6}],55:[function(require,module,exports){
// String encode/decode helpers
'use strict';


var utils = require('./common');


// Quick check if we can use fast array to bin string conversion
//
// - apply(Array) can fail on Android 2.2
// - apply(Uint8Array) can fail on iOS 5.1 Safary
//
var STR_APPLY_OK = true;
var STR_APPLY_UIA_OK = true;

try { String.fromCharCode.apply(null, [ 0 ]); } catch (__) { STR_APPLY_OK = false; }
try { String.fromCharCode.apply(null, new Uint8Array(1)); } catch (__) { STR_APPLY_UIA_OK = false; }


// Table with utf8 lengths (calculated by first byte of sequence)
// Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,
// because max possible codepoint is 0x10ffff
var _utf8len = new utils.Buf8(256);
for (var q = 0; q < 256; q++) {
  _utf8len[q] = (q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1);
}
_utf8len[254] = _utf8len[254] = 1; // Invalid sequence start


// convert string to array (typed, when possible)
exports.string2buf = function (str) {
  var buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;

  // count binary size
  for (m_pos = 0; m_pos < str_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 0xfc00) === 0xdc00) {
        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);
        m_pos++;
      }
    }
    buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;
  }

  // allocate buffer
  buf = new utils.Buf8(buf_len);

  // convert
  for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 0xfc00) === 0xdc00) {
        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);
        m_pos++;
      }
    }
    if (c < 0x80) {
      /* one byte */
      buf[i++] = c;
    } else if (c < 0x800) {
      /* two bytes */
      buf[i++] = 0xC0 | (c >>> 6);
      buf[i++] = 0x80 | (c & 0x3f);
    } else if (c < 0x10000) {
      /* three bytes */
      buf[i++] = 0xE0 | (c >>> 12);
      buf[i++] = 0x80 | (c >>> 6 & 0x3f);
      buf[i++] = 0x80 | (c & 0x3f);
    } else {
      /* four bytes */
      buf[i++] = 0xf0 | (c >>> 18);
      buf[i++] = 0x80 | (c >>> 12 & 0x3f);
      buf[i++] = 0x80 | (c >>> 6 & 0x3f);
      buf[i++] = 0x80 | (c & 0x3f);
    }
  }

  return buf;
};

// Helper (used in 2 places)
function buf2binstring(buf, len) {
  // use fallback for big arrays to avoid stack overflow
  if (len < 65537) {
    if ((buf.subarray && STR_APPLY_UIA_OK) || (!buf.subarray && STR_APPLY_OK)) {
      return String.fromCharCode.apply(null, utils.shrinkBuf(buf, len));
    }
  }

  var result = '';
  for (var i = 0; i < len; i++) {
    result += String.fromCharCode(buf[i]);
  }
  return result;
}


// Convert byte array to binary string
exports.buf2binstring = function (buf) {
  return buf2binstring(buf, buf.length);
};


// Convert binary string (typed, when possible)
exports.binstring2buf = function (str) {
  var buf = new utils.Buf8(str.length);
  for (var i = 0, len = buf.length; i < len; i++) {
    buf[i] = str.charCodeAt(i);
  }
  return buf;
};


// convert array to string
exports.buf2string = function (buf, max) {
  var i, out, c, c_len;
  var len = max || buf.length;

  // Reserve max possible length (2 words per char)
  // NB: by unknown reasons, Array is significantly faster for
  //     String.fromCharCode.apply than Uint16Array.
  var utf16buf = new Array(len * 2);

  for (out = 0, i = 0; i < len;) {
    c = buf[i++];
    // quick process ascii
    if (c < 0x80) { utf16buf[out++] = c; continue; }

    c_len = _utf8len[c];
    // skip 5 & 6 byte codes
    if (c_len > 4) { utf16buf[out++] = 0xfffd; i += c_len - 1; continue; }

    // apply mask on first byte
    c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;
    // join the rest
    while (c_len > 1 && i < len) {
      c = (c << 6) | (buf[i++] & 0x3f);
      c_len--;
    }

    // terminated by end of string?
    if (c_len > 1) { utf16buf[out++] = 0xfffd; continue; }

    if (c < 0x10000) {
      utf16buf[out++] = c;
    } else {
      c -= 0x10000;
      utf16buf[out++] = 0xd800 | ((c >> 10) & 0x3ff);
      utf16buf[out++] = 0xdc00 | (c & 0x3ff);
    }
  }

  return buf2binstring(utf16buf, out);
};


// Calculate max possible position in utf8 buffer,
// that will not break sequence. If that's not possible
// - (very small limits) return max size as is.
//
// buf[] - utf8 bytes array
// max   - length limit (mandatory);
exports.utf8border = function (buf, max) {
  var pos;

  max = max || buf.length;
  if (max > buf.length) { max = buf.length; }

  // go back from last position, until start of sequence found
  pos = max - 1;
  while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) { pos--; }

  // Fuckup - very small and broken sequence,
  // return max, because we should return something anyway.
  if (pos < 0) { return max; }

  // If we came to start of buffer - that means vuffer is too small,
  // return max too.
  if (pos === 0) { return max; }

  return (pos + _utf8len[buf[pos]] > max) ? pos : max;
};

},{"./common":54}],56:[function(require,module,exports){
arguments[4][7][0].apply(exports,arguments)
},{"dup":7}],57:[function(require,module,exports){
arguments[4][8][0].apply(exports,arguments)
},{"dup":8}],58:[function(require,module,exports){
arguments[4][9][0].apply(exports,arguments)
},{"dup":9}],59:[function(require,module,exports){
'use strict';

var utils   = require('../utils/common');
var trees   = require('./trees');
var adler32 = require('./adler32');
var crc32   = require('./crc32');
var msg     = require('./messages');

/* Public constants ==========================================================*/
/* ===========================================================================*/


/* Allowed flush values; see deflate() and inflate() below for details */
var Z_NO_FLUSH      = 0;
var Z_PARTIAL_FLUSH = 1;
//var Z_SYNC_FLUSH    = 2;
var Z_FULL_FLUSH    = 3;
var Z_FINISH        = 4;
var Z_BLOCK         = 5;
//var Z_TREES         = 6;


/* Return codes for the compression/decompression functions. Negative values
 * are errors, positive values are used for special but normal events.
 */
var Z_OK            = 0;
var Z_STREAM_END    = 1;
//var Z_NEED_DICT     = 2;
//var Z_ERRNO         = -1;
var Z_STREAM_ERROR  = -2;
var Z_DATA_ERROR    = -3;
//var Z_MEM_ERROR     = -4;
var Z_BUF_ERROR     = -5;
//var Z_VERSION_ERROR = -6;


/* compression levels */
//var Z_NO_COMPRESSION      = 0;
//var Z_BEST_SPEED          = 1;
//var Z_BEST_COMPRESSION    = 9;
var Z_DEFAULT_COMPRESSION = -1;


var Z_FILTERED            = 1;
var Z_HUFFMAN_ONLY        = 2;
var Z_RLE                 = 3;
var Z_FIXED               = 4;
var Z_DEFAULT_STRATEGY    = 0;

/* Possible values of the data_type field (though see inflate()) */
//var Z_BINARY              = 0;
//var Z_TEXT                = 1;
//var Z_ASCII               = 1; // = Z_TEXT
var Z_UNKNOWN             = 2;


/* The deflate compression method */
var Z_DEFLATED  = 8;

/*============================================================================*/


var MAX_MEM_LEVEL = 9;
/* Maximum value for memLevel in deflateInit2 */
var MAX_WBITS = 15;
/* 32K LZ77 window */
var DEF_MEM_LEVEL = 8;


var LENGTH_CODES  = 29;
/* number of length codes, not counting the special END_BLOCK code */
var LITERALS      = 256;
/* number of literal bytes 0..255 */
var L_CODES       = LITERALS + 1 + LENGTH_CODES;
/* number of Literal or Length codes, including the END_BLOCK code */
var D_CODES       = 30;
/* number of distance codes */
var BL_CODES      = 19;
/* number of codes used to transfer the bit lengths */
var HEAP_SIZE     = 2 * L_CODES + 1;
/* maximum heap size */
var MAX_BITS  = 15;
/* All codes must not exceed MAX_BITS bits */

var MIN_MATCH = 3;
var MAX_MATCH = 258;
var MIN_LOOKAHEAD = (MAX_MATCH + MIN_MATCH + 1);

var PRESET_DICT = 0x20;

var INIT_STATE = 42;
var EXTRA_STATE = 69;
var NAME_STATE = 73;
var COMMENT_STATE = 91;
var HCRC_STATE = 103;
var BUSY_STATE = 113;
var FINISH_STATE = 666;

var BS_NEED_MORE      = 1; /* block not completed, need more input or more output */
var BS_BLOCK_DONE     = 2; /* block flush performed */
var BS_FINISH_STARTED = 3; /* finish started, need only more output at next deflate */
var BS_FINISH_DONE    = 4; /* finish done, accept no more input or output */

var OS_CODE = 0x03; // Unix :) . Don't detect, use this default.

function err(strm, errorCode) {
  strm.msg = msg[errorCode];
  return errorCode;
}

function rank(f) {
  return ((f) << 1) - ((f) > 4 ? 9 : 0);
}

function zero(buf) { var len = buf.length; while (--len >= 0) { buf[len] = 0; } }


/* =========================================================================
 * Flush as much pending output as possible. All deflate() output goes
 * through this function so some applications may wish to modify it
 * to avoid allocating a large strm->output buffer and copying into it.
 * (See also read_buf()).
 */
function flush_pending(strm) {
  var s = strm.state;

  //_tr_flush_bits(s);
  var len = s.pending;
  if (len > strm.avail_out) {
    len = strm.avail_out;
  }
  if (len === 0) { return; }

  utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);
  strm.next_out += len;
  s.pending_out += len;
  strm.total_out += len;
  strm.avail_out -= len;
  s.pending -= len;
  if (s.pending === 0) {
    s.pending_out = 0;
  }
}


function flush_block_only(s, last) {
  trees._tr_flush_block(s, (s.block_start >= 0 ? s.block_start : -1), s.strstart - s.block_start, last);
  s.block_start = s.strstart;
  flush_pending(s.strm);
}


function put_byte(s, b) {
  s.pending_buf[s.pending++] = b;
}


/* =========================================================================
 * Put a short in the pending buffer. The 16-bit value is put in MSB order.
 * IN assertion: the stream state is correct and there is enough room in
 * pending_buf.
 */
function putShortMSB(s, b) {
//  put_byte(s, (Byte)(b >> 8));
//  put_byte(s, (Byte)(b & 0xff));
  s.pending_buf[s.pending++] = (b >>> 8) & 0xff;
  s.pending_buf[s.pending++] = b & 0xff;
}


/* ===========================================================================
 * Read a new buffer from the current input stream, update the adler32
 * and total number of bytes read.  All deflate() input goes through
 * this function so some applications may wish to modify it to avoid
 * allocating a large strm->input buffer and copying from it.
 * (See also flush_pending()).
 */
function read_buf(strm, buf, start, size) {
  var len = strm.avail_in;

  if (len > size) { len = size; }
  if (len === 0) { return 0; }

  strm.avail_in -= len;

  // zmemcpy(buf, strm->next_in, len);
  utils.arraySet(buf, strm.input, strm.next_in, len, start);
  if (strm.state.wrap === 1) {
    strm.adler = adler32(strm.adler, buf, len, start);
  }

  else if (strm.state.wrap === 2) {
    strm.adler = crc32(strm.adler, buf, len, start);
  }

  strm.next_in += len;
  strm.total_in += len;

  return len;
}


/* ===========================================================================
 * Set match_start to the longest match starting at the given string and
 * return its length. Matches shorter or equal to prev_length are discarded,
 * in which case the result is equal to prev_length and match_start is
 * garbage.
 * IN assertions: cur_match is the head of the hash chain for the current
 *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1
 * OUT assertion: the match length is not greater than s->lookahead.
 */
function longest_match(s, cur_match) {
  var chain_length = s.max_chain_length;      /* max hash chain length */
  var scan = s.strstart; /* current string */
  var match;                       /* matched string */
  var len;                           /* length of current match */
  var best_len = s.prev_length;              /* best match length so far */
  var nice_match = s.nice_match;             /* stop if match long enough */
  var limit = (s.strstart > (s.w_size - MIN_LOOKAHEAD)) ?
      s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0/*NIL*/;

  var _win = s.window; // shortcut

  var wmask = s.w_mask;
  var prev  = s.prev;

  /* Stop when cur_match becomes <= limit. To simplify the code,
   * we prevent matches with the string of window index 0.
   */

  var strend = s.strstart + MAX_MATCH;
  var scan_end1  = _win[scan + best_len - 1];
  var scan_end   = _win[scan + best_len];

  /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
   * It is easy to get rid of this optimization if necessary.
   */
  // Assert(s->hash_bits >= 8 && MAX_MATCH == 258, "Code too clever");

  /* Do not waste too much time if we already have a good match: */
  if (s.prev_length >= s.good_match) {
    chain_length >>= 2;
  }
  /* Do not look for matches beyond the end of the input. This is necessary
   * to make deflate deterministic.
   */
  if (nice_match > s.lookahead) { nice_match = s.lookahead; }

  // Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, "need lookahead");

  do {
    // Assert(cur_match < s->strstart, "no future");
    match = cur_match;

    /* Skip to next match if the match length cannot increase
     * or if the match length is less than 2.  Note that the checks below
     * for insufficient lookahead only occur occasionally for performance
     * reasons.  Therefore uninitialized memory will be accessed, and
     * conditional jumps will be made that depend on those values.
     * However the length of the match is limited to the lookahead, so
     * the output of deflate is not affected by the uninitialized values.
     */

    if (_win[match + best_len]     !== scan_end  ||
        _win[match + best_len - 1] !== scan_end1 ||
        _win[match]                !== _win[scan] ||
        _win[++match]              !== _win[scan + 1]) {
      continue;
    }

    /* The check at best_len-1 can be removed because it will be made
     * again later. (This heuristic is not always a win.)
     * It is not necessary to compare scan[2] and match[2] since they
     * are always equal when the other bytes match, given that
     * the hash keys are equal and that HASH_BITS >= 8.
     */
    scan += 2;
    match++;
    // Assert(*scan == *match, "match[2]?");

    /* We check for insufficient lookahead only every 8th comparison;
     * the 256th check will be made at strstart+258.
     */
    do {
      /*jshint noempty:false*/
    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             scan < strend);

    // Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");

    len = MAX_MATCH - (strend - scan);
    scan = strend - MAX_MATCH;

    if (len > best_len) {
      s.match_start = cur_match;
      best_len = len;
      if (len >= nice_match) {
        break;
      }
      scan_end1  = _win[scan + best_len - 1];
      scan_end   = _win[scan + best_len];
    }
  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);

  if (best_len <= s.lookahead) {
    return best_len;
  }
  return s.lookahead;
}


/* ===========================================================================
 * Fill the window when the lookahead becomes insufficient.
 * Updates strstart and lookahead.
 *
 * IN assertion: lookahead < MIN_LOOKAHEAD
 * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD
 *    At least one byte has been read, or avail_in == 0; reads are
 *    performed for at least two bytes (required for the zip translate_eol
 *    option -- not supported here).
 */
function fill_window(s) {
  var _w_size = s.w_size;
  var p, n, m, more, str;

  //Assert(s->lookahead < MIN_LOOKAHEAD, "already enough lookahead");

  do {
    more = s.window_size - s.lookahead - s.strstart;

    // JS ints have 32 bit, block below not needed
    /* Deal with !@#$% 64K limit: */
    //if (sizeof(int) <= 2) {
    //    if (more == 0 && s->strstart == 0 && s->lookahead == 0) {
    //        more = wsize;
    //
    //  } else if (more == (unsigned)(-1)) {
    //        /* Very unlikely, but possible on 16 bit machine if
    //         * strstart == 0 && lookahead == 1 (input done a byte at time)
    //         */
    //        more--;
    //    }
    //}


    /* If the window is almost full and there is insufficient lookahead,
     * move the upper half to the lower one to make room in the upper half.
     */
    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {

      utils.arraySet(s.window, s.window, _w_size, _w_size, 0);
      s.match_start -= _w_size;
      s.strstart -= _w_size;
      /* we now have strstart >= MAX_DIST */
      s.block_start -= _w_size;

      /* Slide the hash table (could be avoided with 32 bit values
       at the expense of memory usage). We slide even when level == 0
       to keep the hash table consistent if we switch back to level > 0
       later. (Using level 0 permanently is not an optimal usage of
       zlib, so we don't care about this pathological case.)
       */

      n = s.hash_size;
      p = n;
      do {
        m = s.head[--p];
        s.head[p] = (m >= _w_size ? m - _w_size : 0);
      } while (--n);

      n = _w_size;
      p = n;
      do {
        m = s.prev[--p];
        s.prev[p] = (m >= _w_size ? m - _w_size : 0);
        /* If n is not on any hash chain, prev[n] is garbage but
         * its value will never be used.
         */
      } while (--n);

      more += _w_size;
    }
    if (s.strm.avail_in === 0) {
      break;
    }

    /* If there was no sliding:
     *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&
     *    more == window_size - lookahead - strstart
     * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)
     * => more >= window_size - 2*WSIZE + 2
     * In the BIG_MEM or MMAP case (not yet supported),
     *   window_size == input_size + MIN_LOOKAHEAD  &&
     *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.
     * Otherwise, window_size == 2*WSIZE so more >= 2.
     * If there was sliding, more >= WSIZE. So in all cases, more >= 2.
     */
    //Assert(more >= 2, "more < 2");
    n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
    s.lookahead += n;

    /* Initialize the hash value now that we have some input: */
    if (s.lookahead + s.insert >= MIN_MATCH) {
      str = s.strstart - s.insert;
      s.ins_h = s.window[str];

      /* UPDATE_HASH(s, s->ins_h, s->window[str + 1]); */
      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + 1]) & s.hash_mask;
//#if MIN_MATCH != 3
//        Call update_hash() MIN_MATCH-3 more times
//#endif
      while (s.insert) {
        /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;

        s.prev[str & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = str;
        str++;
        s.insert--;
        if (s.lookahead + s.insert < MIN_MATCH) {
          break;
        }
      }
    }
    /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,
     * but this is not important since only literal bytes will be emitted.
     */

  } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);

  /* If the WIN_INIT bytes after the end of the current data have never been
   * written, then zero those bytes in order to avoid memory check reports of
   * the use of uninitialized (or uninitialised as Julian writes) bytes by
   * the longest match routines.  Update the high water mark for the next
   * time through here.  WIN_INIT is set to MAX_MATCH since the longest match
   * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.
   */
//  if (s.high_water < s.window_size) {
//    var curr = s.strstart + s.lookahead;
//    var init = 0;
//
//    if (s.high_water < curr) {
//      /* Previous high water mark below current data -- zero WIN_INIT
//       * bytes or up to end of window, whichever is less.
//       */
//      init = s.window_size - curr;
//      if (init > WIN_INIT)
//        init = WIN_INIT;
//      zmemzero(s->window + curr, (unsigned)init);
//      s->high_water = curr + init;
//    }
//    else if (s->high_water < (ulg)curr + WIN_INIT) {
//      /* High water mark at or above current data, but below current data
//       * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up
//       * to end of window, whichever is less.
//       */
//      init = (ulg)curr + WIN_INIT - s->high_water;
//      if (init > s->window_size - s->high_water)
//        init = s->window_size - s->high_water;
//      zmemzero(s->window + s->high_water, (unsigned)init);
//      s->high_water += init;
//    }
//  }
//
//  Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,
//    "not enough room for search");
}

/* ===========================================================================
 * Copy without compression as much as possible from the input stream, return
 * the current block state.
 * This function does not insert new strings in the dictionary since
 * uncompressible data is probably not useful. This function is used
 * only for the level=0 compression option.
 * NOTE: this function should be optimized to avoid extra copying from
 * window to pending_buf.
 */
function deflate_stored(s, flush) {
  /* Stored blocks are limited to 0xffff bytes, pending_buf is limited
   * to pending_buf_size, and each stored block has a 5 byte header:
   */
  var max_block_size = 0xffff;

  if (max_block_size > s.pending_buf_size - 5) {
    max_block_size = s.pending_buf_size - 5;
  }

  /* Copy as much as possible from input to output: */
  for (;;) {
    /* Fill the window as much as possible: */
    if (s.lookahead <= 1) {

      //Assert(s->strstart < s->w_size+MAX_DIST(s) ||
      //  s->block_start >= (long)s->w_size, "slide too late");
//      if (!(s.strstart < s.w_size + (s.w_size - MIN_LOOKAHEAD) ||
//        s.block_start >= s.w_size)) {
//        throw  new Error("slide too late");
//      }

      fill_window(s);
      if (s.lookahead === 0 && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }

      if (s.lookahead === 0) {
        break;
      }
      /* flush the current block */
    }
    //Assert(s->block_start >= 0L, "block gone");
//    if (s.block_start < 0) throw new Error("block gone");

    s.strstart += s.lookahead;
    s.lookahead = 0;

    /* Emit a stored block if pending_buf will be full: */
    var max_start = s.block_start + max_block_size;

    if (s.strstart === 0 || s.strstart >= max_start) {
      /* strstart == 0 is possible when wraparound on 16-bit machine */
      s.lookahead = s.strstart - max_start;
      s.strstart = max_start;
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/


    }
    /* Flush if we may have to slide, otherwise block_start may become
     * negative and the data will be gone:
     */
    if (s.strstart - s.block_start >= (s.w_size - MIN_LOOKAHEAD)) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }

  s.insert = 0;

  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }

  if (s.strstart > s.block_start) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }

  return BS_NEED_MORE;
}

/* ===========================================================================
 * Compress as much as possible from the input stream, return the current
 * block state.
 * This function does not perform lazy evaluation of matches and inserts
 * new strings in the dictionary only for unmatched strings or for short
 * matches. It is used only for the fast compression options.
 */
function deflate_fast(s, flush) {
  var hash_head;        /* head of the hash chain */
  var bflush;           /* set if current block must be flushed */

  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the next match, plus MIN_MATCH bytes to insert the
     * string following the next match.
     */
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break; /* flush the current block */
      }
    }

    /* Insert the string window[strstart .. strstart+2] in the
     * dictionary, and set hash_head to the head of the hash chain:
     */
    hash_head = 0/*NIL*/;
    if (s.lookahead >= MIN_MATCH) {
      /*** INSERT_STRING(s, s.strstart, hash_head); ***/
      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
      /***/
    }

    /* Find the longest match, discarding those <= prev_length.
     * At this point we have always match_length < MIN_MATCH
     */
    if (hash_head !== 0/*NIL*/ && ((s.strstart - hash_head) <= (s.w_size - MIN_LOOKAHEAD))) {
      /* To simplify the code, we prevent matches with the string
       * of window index 0 (in particular we have to avoid a match
       * of the string with itself at the start of the input file).
       */
      s.match_length = longest_match(s, hash_head);
      /* longest_match() sets match_start */
    }
    if (s.match_length >= MIN_MATCH) {
      // check_match(s, s.strstart, s.match_start, s.match_length); // for debug only

      /*** _tr_tally_dist(s, s.strstart - s.match_start,
                     s.match_length - MIN_MATCH, bflush); ***/
      bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);

      s.lookahead -= s.match_length;

      /* Insert new strings in the hash table only if the match length
       * is not too large. This saves time but degrades compression.
       */
      if (s.match_length <= s.max_lazy_match/*max_insert_length*/ && s.lookahead >= MIN_MATCH) {
        s.match_length--; /* string at strstart already in table */
        do {
          s.strstart++;
          /*** INSERT_STRING(s, s.strstart, hash_head); ***/
          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
          /***/
          /* strstart never exceeds WSIZE-MAX_MATCH, so there are
           * always MIN_MATCH bytes ahead.
           */
        } while (--s.match_length !== 0);
        s.strstart++;
      } else
      {
        s.strstart += s.match_length;
        s.match_length = 0;
        s.ins_h = s.window[s.strstart];
        /* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); */
        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + 1]) & s.hash_mask;

//#if MIN_MATCH != 3
//                Call UPDATE_HASH() MIN_MATCH-3 more times
//#endif
        /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not
         * matter since it will be recomputed at next deflate call.
         */
      }
    } else {
      /* No match, output a literal byte */
      //Tracevv((stderr,"%c", s.window[s.strstart]));
      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);

      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = ((s.strstart < (MIN_MATCH - 1)) ? s.strstart : MIN_MATCH - 1);
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
}

/* ===========================================================================
 * Same as above, but achieves better compression. We use a lazy
 * evaluation for matches: a match is finally adopted only if there is
 * no better match at the next window position.
 */
function deflate_slow(s, flush) {
  var hash_head;          /* head of hash chain */
  var bflush;              /* set if current block must be flushed */

  var max_insert;

  /* Process the input block. */
  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the next match, plus MIN_MATCH bytes to insert the
     * string following the next match.
     */
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) { break; } /* flush the current block */
    }

    /* Insert the string window[strstart .. strstart+2] in the
     * dictionary, and set hash_head to the head of the hash chain:
     */
    hash_head = 0/*NIL*/;
    if (s.lookahead >= MIN_MATCH) {
      /*** INSERT_STRING(s, s.strstart, hash_head); ***/
      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
      /***/
    }

    /* Find the longest match, discarding those <= prev_length.
     */
    s.prev_length = s.match_length;
    s.prev_match = s.match_start;
    s.match_length = MIN_MATCH - 1;

    if (hash_head !== 0/*NIL*/ && s.prev_length < s.max_lazy_match &&
        s.strstart - hash_head <= (s.w_size - MIN_LOOKAHEAD)/*MAX_DIST(s)*/) {
      /* To simplify the code, we prevent matches with the string
       * of window index 0 (in particular we have to avoid a match
       * of the string with itself at the start of the input file).
       */
      s.match_length = longest_match(s, hash_head);
      /* longest_match() sets match_start */

      if (s.match_length <= 5 &&
         (s.strategy === Z_FILTERED || (s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096/*TOO_FAR*/))) {

        /* If prev_match is also MIN_MATCH, match_start is garbage
         * but we will ignore the current match anyway.
         */
        s.match_length = MIN_MATCH - 1;
      }
    }
    /* If there was a match at the previous step and the current
     * match is not better, output the previous match:
     */
    if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
      max_insert = s.strstart + s.lookahead - MIN_MATCH;
      /* Do not insert strings in hash table beyond this. */

      //check_match(s, s.strstart-1, s.prev_match, s.prev_length);

      /***_tr_tally_dist(s, s.strstart - 1 - s.prev_match,
                     s.prev_length - MIN_MATCH, bflush);***/
      bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
      /* Insert in hash table all strings up to the end of the match.
       * strstart-1 and strstart are already inserted. If there is not
       * enough lookahead, the last two strings are not inserted in
       * the hash table.
       */
      s.lookahead -= s.prev_length - 1;
      s.prev_length -= 2;
      do {
        if (++s.strstart <= max_insert) {
          /*** INSERT_STRING(s, s.strstart, hash_head); ***/
          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
          /***/
        }
      } while (--s.prev_length !== 0);
      s.match_available = 0;
      s.match_length = MIN_MATCH - 1;
      s.strstart++;

      if (bflush) {
        /*** FLUSH_BLOCK(s, 0); ***/
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
        /***/
      }

    } else if (s.match_available) {
      /* If there was no match at the previous position, output a
       * single literal. If there was a match but the current match
       * is longer, truncate the previous match to a single literal.
       */
      //Tracevv((stderr,"%c", s->window[s->strstart-1]));
      /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
      bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);

      if (bflush) {
        /*** FLUSH_BLOCK_ONLY(s, 0) ***/
        flush_block_only(s, false);
        /***/
      }
      s.strstart++;
      s.lookahead--;
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    } else {
      /* There is no previous match to compare with, wait for
       * the next step to decide.
       */
      s.match_available = 1;
      s.strstart++;
      s.lookahead--;
    }
  }
  //Assert (flush != Z_NO_FLUSH, "no flush?");
  if (s.match_available) {
    //Tracevv((stderr,"%c", s->window[s->strstart-1]));
    /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
    bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);

    s.match_available = 0;
  }
  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }

  return BS_BLOCK_DONE;
}


/* ===========================================================================
 * For Z_RLE, simply look for runs of bytes, generate matches only of distance
 * one.  Do not maintain a hash table.  (It will be regenerated if this run of
 * deflate switches away from Z_RLE.)
 */
function deflate_rle(s, flush) {
  var bflush;            /* set if current block must be flushed */
  var prev;              /* byte at distance one to match */
  var scan, strend;      /* scan goes up to strend for length of run */

  var _win = s.window;

  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the longest run, plus one for the unrolled loop.
     */
    if (s.lookahead <= MAX_MATCH) {
      fill_window(s);
      if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) { break; } /* flush the current block */
    }

    /* See how many times the previous byte repeats */
    s.match_length = 0;
    if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
      scan = s.strstart - 1;
      prev = _win[scan];
      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
        strend = s.strstart + MAX_MATCH;
        do {
          /*jshint noempty:false*/
        } while (prev === _win[++scan] && prev === _win[++scan] &&
                 prev === _win[++scan] && prev === _win[++scan] &&
                 prev === _win[++scan] && prev === _win[++scan] &&
                 prev === _win[++scan] && prev === _win[++scan] &&
                 scan < strend);
        s.match_length = MAX_MATCH - (strend - scan);
        if (s.match_length > s.lookahead) {
          s.match_length = s.lookahead;
        }
      }
      //Assert(scan <= s->window+(uInt)(s->window_size-1), "wild scan");
    }

    /* Emit match if have run of MIN_MATCH or longer, else emit literal */
    if (s.match_length >= MIN_MATCH) {
      //check_match(s, s.strstart, s.strstart - 1, s.match_length);

      /*** _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ***/
      bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);

      s.lookahead -= s.match_length;
      s.strstart += s.match_length;
      s.match_length = 0;
    } else {
      /* No match, output a literal byte */
      //Tracevv((stderr,"%c", s->window[s->strstart]));
      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);

      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
}

/* ===========================================================================
 * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.
 * (It will be regenerated if this run of deflate switches away from Huffman.)
 */
function deflate_huff(s, flush) {
  var bflush;             /* set if current block must be flushed */

  for (;;) {
    /* Make sure that we have a literal to write. */
    if (s.lookahead === 0) {
      fill_window(s);
      if (s.lookahead === 0) {
        if (flush === Z_NO_FLUSH) {
          return BS_NEED_MORE;
        }
        break;      /* flush the current block */
      }
    }

    /* Output a literal byte */
    s.match_length = 0;
    //Tracevv((stderr,"%c", s->window[s->strstart]));
    /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
    bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
    s.lookahead--;
    s.strstart++;
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
}

/* Values for max_lazy_match, good_match and max_chain_length, depending on
 * the desired pack level (0..9). The values given below have been tuned to
 * exclude worst case performance for pathological files. Better values may be
 * found for specific files.
 */
function Config(good_length, max_lazy, nice_length, max_chain, func) {
  this.good_length = good_length;
  this.max_lazy = max_lazy;
  this.nice_length = nice_length;
  this.max_chain = max_chain;
  this.func = func;
}

var configuration_table;

configuration_table = [
  /*      good lazy nice chain */
  new Config(0, 0, 0, 0, deflate_stored),          /* 0 store only */
  new Config(4, 4, 8, 4, deflate_fast),            /* 1 max speed, no lazy matches */
  new Config(4, 5, 16, 8, deflate_fast),           /* 2 */
  new Config(4, 6, 32, 32, deflate_fast),          /* 3 */

  new Config(4, 4, 16, 16, deflate_slow),          /* 4 lazy matches */
  new Config(8, 16, 32, 32, deflate_slow),         /* 5 */
  new Config(8, 16, 128, 128, deflate_slow),       /* 6 */
  new Config(8, 32, 128, 256, deflate_slow),       /* 7 */
  new Config(32, 128, 258, 1024, deflate_slow),    /* 8 */
  new Config(32, 258, 258, 4096, deflate_slow)     /* 9 max compression */
];


/* ===========================================================================
 * Initialize the "longest match" routines for a new zlib stream
 */
function lm_init(s) {
  s.window_size = 2 * s.w_size;

  /*** CLEAR_HASH(s); ***/
  zero(s.head); // Fill with NIL (= 0);

  /* Set the default configuration parameters:
   */
  s.max_lazy_match = configuration_table[s.level].max_lazy;
  s.good_match = configuration_table[s.level].good_length;
  s.nice_match = configuration_table[s.level].nice_length;
  s.max_chain_length = configuration_table[s.level].max_chain;

  s.strstart = 0;
  s.block_start = 0;
  s.lookahead = 0;
  s.insert = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  s.ins_h = 0;
}


function DeflateState() {
  this.strm = null;            /* pointer back to this zlib stream */
  this.status = 0;            /* as the name implies */
  this.pending_buf = null;      /* output still pending */
  this.pending_buf_size = 0;  /* size of pending_buf */
  this.pending_out = 0;       /* next pending byte to output to the stream */
  this.pending = 0;           /* nb of bytes in the pending buffer */
  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */
  this.gzhead = null;         /* gzip header information to write */
  this.gzindex = 0;           /* where in extra, name, or comment */
  this.method = Z_DEFLATED; /* can only be DEFLATED */
  this.last_flush = -1;   /* value of flush param for previous deflate call */

  this.w_size = 0;  /* LZ77 window size (32K by default) */
  this.w_bits = 0;  /* log2(w_size)  (8..16) */
  this.w_mask = 0;  /* w_size - 1 */

  this.window = null;
  /* Sliding window. Input bytes are read into the second half of the window,
   * and move to the first half later to keep a dictionary of at least wSize
   * bytes. With this organization, matches are limited to a distance of
   * wSize-MAX_MATCH bytes, but this ensures that IO is always
   * performed with a length multiple of the block size.
   */

  this.window_size = 0;
  /* Actual size of window: 2*wSize, except when the user input buffer
   * is directly used as sliding window.
   */

  this.prev = null;
  /* Link to older string with same hash index. To limit the size of this
   * array to 64K, this link is maintained only for the last 32K strings.
   * An index in this array is thus a window index modulo 32K.
   */

  this.head = null;   /* Heads of the hash chains or NIL. */

  this.ins_h = 0;       /* hash index of string to be inserted */
  this.hash_size = 0;   /* number of elements in hash table */
  this.hash_bits = 0;   /* log2(hash_size) */
  this.hash_mask = 0;   /* hash_size-1 */

  this.hash_shift = 0;
  /* Number of bits by which ins_h must be shifted at each input
   * step. It must be such that after MIN_MATCH steps, the oldest
   * byte no longer takes part in the hash key, that is:
   *   hash_shift * MIN_MATCH >= hash_bits
   */

  this.block_start = 0;
  /* Window position at the beginning of the current output block. Gets
   * negative when the window is moved backwards.
   */

  this.match_length = 0;      /* length of best match */
  this.prev_match = 0;        /* previous match */
  this.match_available = 0;   /* set if previous match exists */
  this.strstart = 0;          /* start of string to insert */
  this.match_start = 0;       /* start of matching string */
  this.lookahead = 0;         /* number of valid bytes ahead in window */

  this.prev_length = 0;
  /* Length of the best match at previous step. Matches not greater than this
   * are discarded. This is used in the lazy match evaluation.
   */

  this.max_chain_length = 0;
  /* To speed up deflation, hash chains are never searched beyond this
   * length.  A higher limit improves compression ratio but degrades the
   * speed.
   */

  this.max_lazy_match = 0;
  /* Attempt to find a better match only when the current match is strictly
   * smaller than this value. This mechanism is used only for compression
   * levels >= 4.
   */
  // That's alias to max_lazy_match, don't use directly
  //this.max_insert_length = 0;
  /* Insert new strings in the hash table only if the match length is not
   * greater than this length. This saves time but degrades compression.
   * max_insert_length is used only for compression levels <= 3.
   */

  this.level = 0;     /* compression level (1..9) */
  this.strategy = 0;  /* favor or force Huffman coding*/

  this.good_match = 0;
  /* Use a faster search when the previous match is longer than this */

  this.nice_match = 0; /* Stop searching when current match exceeds this */

              /* used by trees.c: */

  /* Didn't use ct_data typedef below to suppress compiler warning */

  // struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */
  // struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */
  // struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */

  // Use flat array of DOUBLE size, with interleaved fata,
  // because JS does not support effective
  this.dyn_ltree  = new utils.Buf16(HEAP_SIZE * 2);
  this.dyn_dtree  = new utils.Buf16((2 * D_CODES + 1) * 2);
  this.bl_tree    = new utils.Buf16((2 * BL_CODES + 1) * 2);
  zero(this.dyn_ltree);
  zero(this.dyn_dtree);
  zero(this.bl_tree);

  this.l_desc   = null;         /* desc. for literal tree */
  this.d_desc   = null;         /* desc. for distance tree */
  this.bl_desc  = null;         /* desc. for bit length tree */

  //ush bl_count[MAX_BITS+1];
  this.bl_count = new utils.Buf16(MAX_BITS + 1);
  /* number of codes at each bit length for an optimal tree */

  //int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */
  this.heap = new utils.Buf16(2 * L_CODES + 1);  /* heap used to build the Huffman trees */
  zero(this.heap);

  this.heap_len = 0;               /* number of elements in the heap */
  this.heap_max = 0;               /* element of largest frequency */
  /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.
   * The same heap array is used to build all trees.
   */

  this.depth = new utils.Buf16(2 * L_CODES + 1); //uch depth[2*L_CODES+1];
  zero(this.depth);
  /* Depth of each subtree used as tie breaker for trees of equal frequency
   */

  this.l_buf = 0;          /* buffer index for literals or lengths */

  this.lit_bufsize = 0;
  /* Size of match buffer for literals/lengths.  There are 4 reasons for
   * limiting lit_bufsize to 64K:
   *   - frequencies can be kept in 16 bit counters
   *   - if compression is not successful for the first block, all input
   *     data is still in the window so we can still emit a stored block even
   *     when input comes from standard input.  (This can also be done for
   *     all blocks if lit_bufsize is not greater than 32K.)
   *   - if compression is not successful for a file smaller than 64K, we can
   *     even emit a stored file instead of a stored block (saving 5 bytes).
   *     This is applicable only for zip (not gzip or zlib).
   *   - creating new Huffman trees less frequently may not provide fast
   *     adaptation to changes in the input data statistics. (Take for
   *     example a binary file with poorly compressible code followed by
   *     a highly compressible string table.) Smaller buffer sizes give
   *     fast adaptation but have of course the overhead of transmitting
   *     trees more frequently.
   *   - I can't count above 4
   */

  this.last_lit = 0;      /* running index in l_buf */

  this.d_buf = 0;
  /* Buffer index for distances. To simplify the code, d_buf and l_buf have
   * the same number of elements. To use different lengths, an extra flag
   * array would be necessary.
   */

  this.opt_len = 0;       /* bit length of current block with optimal trees */
  this.static_len = 0;    /* bit length of current block with static trees */
  this.matches = 0;       /* number of string matches in current block */
  this.insert = 0;        /* bytes at end of window left to insert */


  this.bi_buf = 0;
  /* Output buffer. bits are inserted starting at the bottom (least
   * significant bits).
   */
  this.bi_valid = 0;
  /* Number of valid bits in bi_buf.  All bits above the last valid bit
   * are always zero.
   */

  // Used for window memory init. We safely ignore it for JS. That makes
  // sense only for pointers and memory check tools.
  //this.high_water = 0;
  /* High water mark offset in window for initialized bytes -- bytes above
   * this are set to zero in order to avoid memory check warnings when
   * longest match routines access bytes past the input.  This is then
   * updated to the new high water mark.
   */
}


function deflateResetKeep(strm) {
  var s;

  if (!strm || !strm.state) {
    return err(strm, Z_STREAM_ERROR);
  }

  strm.total_in = strm.total_out = 0;
  strm.data_type = Z_UNKNOWN;

  s = strm.state;
  s.pending = 0;
  s.pending_out = 0;

  if (s.wrap < 0) {
    s.wrap = -s.wrap;
    /* was made negative by deflate(..., Z_FINISH); */
  }
  s.status = (s.wrap ? INIT_STATE : BUSY_STATE);
  strm.adler = (s.wrap === 2) ?
    0  // crc32(0, Z_NULL, 0)
  :
    1; // adler32(0, Z_NULL, 0)
  s.last_flush = Z_NO_FLUSH;
  trees._tr_init(s);
  return Z_OK;
}


function deflateReset(strm) {
  var ret = deflateResetKeep(strm);
  if (ret === Z_OK) {
    lm_init(strm.state);
  }
  return ret;
}


function deflateSetHeader(strm, head) {
  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  if (strm.state.wrap !== 2) { return Z_STREAM_ERROR; }
  strm.state.gzhead = head;
  return Z_OK;
}


function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
  if (!strm) { // === Z_NULL
    return Z_STREAM_ERROR;
  }
  var wrap = 1;

  if (level === Z_DEFAULT_COMPRESSION) {
    level = 6;
  }

  if (windowBits < 0) { /* suppress zlib wrapper */
    wrap = 0;
    windowBits = -windowBits;
  }

  else if (windowBits > 15) {
    wrap = 2;           /* write gzip wrapper instead */
    windowBits -= 16;
  }


  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED ||
    windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||
    strategy < 0 || strategy > Z_FIXED) {
    return err(strm, Z_STREAM_ERROR);
  }


  if (windowBits === 8) {
    windowBits = 9;
  }
  /* until 256-byte window bug fixed */

  var s = new DeflateState();

  strm.state = s;
  s.strm = strm;

  s.wrap = wrap;
  s.gzhead = null;
  s.w_bits = windowBits;
  s.w_size = 1 << s.w_bits;
  s.w_mask = s.w_size - 1;

  s.hash_bits = memLevel + 7;
  s.hash_size = 1 << s.hash_bits;
  s.hash_mask = s.hash_size - 1;
  s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);

  s.window = new utils.Buf8(s.w_size * 2);
  s.head = new utils.Buf16(s.hash_size);
  s.prev = new utils.Buf16(s.w_size);

  // Don't need mem init magic for JS.
  //s.high_water = 0;  /* nothing written to s->window yet */

  s.lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */

  s.pending_buf_size = s.lit_bufsize * 4;
  s.pending_buf = new utils.Buf8(s.pending_buf_size);

  s.d_buf = s.lit_bufsize >> 1;
  s.l_buf = (1 + 2) * s.lit_bufsize;

  s.level = level;
  s.strategy = strategy;
  s.method = method;

  return deflateReset(strm);
}

function deflateInit(strm, level) {
  return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
}


function deflate(strm, flush) {
  var old_flush, s;
  var beg, val; // for gzip header write only

  if (!strm || !strm.state ||
    flush > Z_BLOCK || flush < 0) {
    return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
  }

  s = strm.state;

  if (!strm.output ||
      (!strm.input && strm.avail_in !== 0) ||
      (s.status === FINISH_STATE && flush !== Z_FINISH)) {
    return err(strm, (strm.avail_out === 0) ? Z_BUF_ERROR : Z_STREAM_ERROR);
  }

  s.strm = strm; /* just in case */
  old_flush = s.last_flush;
  s.last_flush = flush;

  /* Write the header */
  if (s.status === INIT_STATE) {

    if (s.wrap === 2) { // GZIP header
      strm.adler = 0;  //crc32(0L, Z_NULL, 0);
      put_byte(s, 31);
      put_byte(s, 139);
      put_byte(s, 8);
      if (!s.gzhead) { // s->gzhead == Z_NULL
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, s.level === 9 ? 2 :
                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?
                     4 : 0));
        put_byte(s, OS_CODE);
        s.status = BUSY_STATE;
      }
      else {
        put_byte(s, (s.gzhead.text ? 1 : 0) +
                    (s.gzhead.hcrc ? 2 : 0) +
                    (!s.gzhead.extra ? 0 : 4) +
                    (!s.gzhead.name ? 0 : 8) +
                    (!s.gzhead.comment ? 0 : 16)
                );
        put_byte(s, s.gzhead.time & 0xff);
        put_byte(s, (s.gzhead.time >> 8) & 0xff);
        put_byte(s, (s.gzhead.time >> 16) & 0xff);
        put_byte(s, (s.gzhead.time >> 24) & 0xff);
        put_byte(s, s.level === 9 ? 2 :
                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?
                     4 : 0));
        put_byte(s, s.gzhead.os & 0xff);
        if (s.gzhead.extra && s.gzhead.extra.length) {
          put_byte(s, s.gzhead.extra.length & 0xff);
          put_byte(s, (s.gzhead.extra.length >> 8) & 0xff);
        }
        if (s.gzhead.hcrc) {
          strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);
        }
        s.gzindex = 0;
        s.status = EXTRA_STATE;
      }
    }
    else // DEFLATE header
    {
      var header = (Z_DEFLATED + ((s.w_bits - 8) << 4)) << 8;
      var level_flags = -1;

      if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
        level_flags = 0;
      } else if (s.level < 6) {
        level_flags = 1;
      } else if (s.level === 6) {
        level_flags = 2;
      } else {
        level_flags = 3;
      }
      header |= (level_flags << 6);
      if (s.strstart !== 0) { header |= PRESET_DICT; }
      header += 31 - (header % 31);

      s.status = BUSY_STATE;
      putShortMSB(s, header);

      /* Save the adler32 of the preset dictionary: */
      if (s.strstart !== 0) {
        putShortMSB(s, strm.adler >>> 16);
        putShortMSB(s, strm.adler & 0xffff);
      }
      strm.adler = 1; // adler32(0L, Z_NULL, 0);
    }
  }

//#ifdef GZIP
  if (s.status === EXTRA_STATE) {
    if (s.gzhead.extra/* != Z_NULL*/) {
      beg = s.pending;  /* start of bytes to update crc */

      while (s.gzindex < (s.gzhead.extra.length & 0xffff)) {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            break;
          }
        }
        put_byte(s, s.gzhead.extra[s.gzindex] & 0xff);
        s.gzindex++;
      }
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (s.gzindex === s.gzhead.extra.length) {
        s.gzindex = 0;
        s.status = NAME_STATE;
      }
    }
    else {
      s.status = NAME_STATE;
    }
  }
  if (s.status === NAME_STATE) {
    if (s.gzhead.name/* != Z_NULL*/) {
      beg = s.pending;  /* start of bytes to update crc */
      //int val;

      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            val = 1;
            break;
          }
        }
        // JS specific: little magic to add zero terminator to end of string
        if (s.gzindex < s.gzhead.name.length) {
          val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);

      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (val === 0) {
        s.gzindex = 0;
        s.status = COMMENT_STATE;
      }
    }
    else {
      s.status = COMMENT_STATE;
    }
  }
  if (s.status === COMMENT_STATE) {
    if (s.gzhead.comment/* != Z_NULL*/) {
      beg = s.pending;  /* start of bytes to update crc */
      //int val;

      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            val = 1;
            break;
          }
        }
        // JS specific: little magic to add zero terminator to end of string
        if (s.gzindex < s.gzhead.comment.length) {
          val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);

      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (val === 0) {
        s.status = HCRC_STATE;
      }
    }
    else {
      s.status = HCRC_STATE;
    }
  }
  if (s.status === HCRC_STATE) {
    if (s.gzhead.hcrc) {
      if (s.pending + 2 > s.pending_buf_size) {
        flush_pending(strm);
      }
      if (s.pending + 2 <= s.pending_buf_size) {
        put_byte(s, strm.adler & 0xff);
        put_byte(s, (strm.adler >> 8) & 0xff);
        strm.adler = 0; //crc32(0L, Z_NULL, 0);
        s.status = BUSY_STATE;
      }
    }
    else {
      s.status = BUSY_STATE;
    }
  }
//#endif

  /* Flush as much pending output as possible */
  if (s.pending !== 0) {
    flush_pending(strm);
    if (strm.avail_out === 0) {
      /* Since avail_out is 0, deflate will be called again with
       * more output space, but possibly with both pending and
       * avail_in equal to zero. There won't be anything to do,
       * but this is not an error situation so make sure we
       * return OK instead of BUF_ERROR at next call of deflate:
       */
      s.last_flush = -1;
      return Z_OK;
    }

    /* Make sure there is something to do and avoid duplicate consecutive
     * flushes. For repeated and useless calls with Z_FINISH, we keep
     * returning Z_STREAM_END instead of Z_BUF_ERROR.
     */
  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) &&
    flush !== Z_FINISH) {
    return err(strm, Z_BUF_ERROR);
  }

  /* User must not provide more input after the first FINISH: */
  if (s.status === FINISH_STATE && strm.avail_in !== 0) {
    return err(strm, Z_BUF_ERROR);
  }

  /* Start a new block or continue the current one.
   */
  if (strm.avail_in !== 0 || s.lookahead !== 0 ||
    (flush !== Z_NO_FLUSH && s.status !== FINISH_STATE)) {
    var bstate = (s.strategy === Z_HUFFMAN_ONLY) ? deflate_huff(s, flush) :
      (s.strategy === Z_RLE ? deflate_rle(s, flush) :
        configuration_table[s.level].func(s, flush));

    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
      s.status = FINISH_STATE;
    }
    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
      if (strm.avail_out === 0) {
        s.last_flush = -1;
        /* avoid BUF_ERROR next call, see above */
      }
      return Z_OK;
      /* If flush != Z_NO_FLUSH && avail_out == 0, the next call
       * of deflate should use the same flush parameter to make sure
       * that the flush is complete. So we don't have to output an
       * empty block here, this will be done at next call. This also
       * ensures that for a very small output buffer, we emit at most
       * one empty block.
       */
    }
    if (bstate === BS_BLOCK_DONE) {
      if (flush === Z_PARTIAL_FLUSH) {
        trees._tr_align(s);
      }
      else if (flush !== Z_BLOCK) { /* FULL_FLUSH or SYNC_FLUSH */

        trees._tr_stored_block(s, 0, 0, false);
        /* For a full flush, this empty block will be recognized
         * as a special marker by inflate_sync().
         */
        if (flush === Z_FULL_FLUSH) {
          /*** CLEAR_HASH(s); ***/             /* forget history */
          zero(s.head); // Fill with NIL (= 0);

          if (s.lookahead === 0) {
            s.strstart = 0;
            s.block_start = 0;
            s.insert = 0;
          }
        }
      }
      flush_pending(strm);
      if (strm.avail_out === 0) {
        s.last_flush = -1; /* avoid BUF_ERROR at next call, see above */
        return Z_OK;
      }
    }
  }
  //Assert(strm->avail_out > 0, "bug2");
  //if (strm.avail_out <= 0) { throw new Error("bug2");}

  if (flush !== Z_FINISH) { return Z_OK; }
  if (s.wrap <= 0) { return Z_STREAM_END; }

  /* Write the trailer */
  if (s.wrap === 2) {
    put_byte(s, strm.adler & 0xff);
    put_byte(s, (strm.adler >> 8) & 0xff);
    put_byte(s, (strm.adler >> 16) & 0xff);
    put_byte(s, (strm.adler >> 24) & 0xff);
    put_byte(s, strm.total_in & 0xff);
    put_byte(s, (strm.total_in >> 8) & 0xff);
    put_byte(s, (strm.total_in >> 16) & 0xff);
    put_byte(s, (strm.total_in >> 24) & 0xff);
  }
  else
  {
    putShortMSB(s, strm.adler >>> 16);
    putShortMSB(s, strm.adler & 0xffff);
  }

  flush_pending(strm);
  /* If avail_out is zero, the application will call deflate again
   * to flush the rest.
   */
  if (s.wrap > 0) { s.wrap = -s.wrap; }
  /* write the trailer only once! */
  return s.pending !== 0 ? Z_OK : Z_STREAM_END;
}

function deflateEnd(strm) {
  var status;

  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {
    return Z_STREAM_ERROR;
  }

  status = strm.state.status;
  if (status !== INIT_STATE &&
    status !== EXTRA_STATE &&
    status !== NAME_STATE &&
    status !== COMMENT_STATE &&
    status !== HCRC_STATE &&
    status !== BUSY_STATE &&
    status !== FINISH_STATE
  ) {
    return err(strm, Z_STREAM_ERROR);
  }

  strm.state = null;

  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
}


/* =========================================================================
 * Initializes the compression dictionary from the given byte
 * sequence without producing any compressed output.
 */
function deflateSetDictionary(strm, dictionary) {
  var dictLength = dictionary.length;

  var s;
  var str, n;
  var wrap;
  var avail;
  var next;
  var input;
  var tmpDict;

  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {
    return Z_STREAM_ERROR;
  }

  s = strm.state;
  wrap = s.wrap;

  if (wrap === 2 || (wrap === 1 && s.status !== INIT_STATE) || s.lookahead) {
    return Z_STREAM_ERROR;
  }

  /* when using zlib wrappers, compute Adler-32 for provided dictionary */
  if (wrap === 1) {
    /* adler32(strm->adler, dictionary, dictLength); */
    strm.adler = adler32(strm.adler, dictionary, dictLength, 0);
  }

  s.wrap = 0;   /* avoid computing Adler-32 in read_buf */

  /* if dictionary would fill window, just replace the history */
  if (dictLength >= s.w_size) {
    if (wrap === 0) {            /* already empty otherwise */
      /*** CLEAR_HASH(s); ***/
      zero(s.head); // Fill with NIL (= 0);
      s.strstart = 0;
      s.block_start = 0;
      s.insert = 0;
    }
    /* use the tail */
    // dictionary = dictionary.slice(dictLength - s.w_size);
    tmpDict = new utils.Buf8(s.w_size);
    utils.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0);
    dictionary = tmpDict;
    dictLength = s.w_size;
  }
  /* insert dictionary into window and hash */
  avail = strm.avail_in;
  next = strm.next_in;
  input = strm.input;
  strm.avail_in = dictLength;
  strm.next_in = 0;
  strm.input = dictionary;
  fill_window(s);
  while (s.lookahead >= MIN_MATCH) {
    str = s.strstart;
    n = s.lookahead - (MIN_MATCH - 1);
    do {
      /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;

      s.prev[str & s.w_mask] = s.head[s.ins_h];

      s.head[s.ins_h] = str;
      str++;
    } while (--n);
    s.strstart = str;
    s.lookahead = MIN_MATCH - 1;
    fill_window(s);
  }
  s.strstart += s.lookahead;
  s.block_start = s.strstart;
  s.insert = s.lookahead;
  s.lookahead = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  strm.next_in = next;
  strm.input = input;
  strm.avail_in = avail;
  s.wrap = wrap;
  return Z_OK;
}


exports.deflateInit = deflateInit;
exports.deflateInit2 = deflateInit2;
exports.deflateReset = deflateReset;
exports.deflateResetKeep = deflateResetKeep;
exports.deflateSetHeader = deflateSetHeader;
exports.deflate = deflate;
exports.deflateEnd = deflateEnd;
exports.deflateSetDictionary = deflateSetDictionary;
exports.deflateInfo = 'pako deflate (from Nodeca project)';

/* Not implemented
exports.deflateBound = deflateBound;
exports.deflateCopy = deflateCopy;
exports.deflateParams = deflateParams;
exports.deflatePending = deflatePending;
exports.deflatePrime = deflatePrime;
exports.deflateTune = deflateTune;
*/

},{"../utils/common":54,"./adler32":56,"./crc32":58,"./messages":64,"./trees":65}],60:[function(require,module,exports){
'use strict';


function GZheader() {
  /* true if compressed data believed to be text */
  this.text       = 0;
  /* modification time */
  this.time       = 0;
  /* extra flags (not used when writing a gzip file) */
  this.xflags     = 0;
  /* operating system */
  this.os         = 0;
  /* pointer to extra field or Z_NULL if none */
  this.extra      = null;
  /* extra field length (valid if extra != Z_NULL) */
  this.extra_len  = 0; // Actually, we don't need it in JS,
                       // but leave for few code modifications

  //
  // Setup limits is not necessary because in js we should not preallocate memory
  // for inflate use constant limit in 65536 bytes
  //

  /* space at extra (only when reading header) */
  // this.extra_max  = 0;
  /* pointer to zero-terminated file name or Z_NULL */
  this.name       = '';
  /* space at name (only when reading header) */
  // this.name_max   = 0;
  /* pointer to zero-terminated comment or Z_NULL */
  this.comment    = '';
  /* space at comment (only when reading header) */
  // this.comm_max   = 0;
  /* true if there was or will be a header crc */
  this.hcrc       = 0;
  /* true when done reading gzip header (not used when writing a gzip file) */
  this.done       = false;
}

module.exports = GZheader;

},{}],61:[function(require,module,exports){
arguments[4][11][0].apply(exports,arguments)
},{"dup":11}],62:[function(require,module,exports){
arguments[4][12][0].apply(exports,arguments)
},{"../utils/common":54,"./adler32":56,"./crc32":58,"./inffast":61,"./inftrees":63,"dup":12}],63:[function(require,module,exports){
arguments[4][13][0].apply(exports,arguments)
},{"../utils/common":54,"dup":13}],64:[function(require,module,exports){
arguments[4][14][0].apply(exports,arguments)
},{"dup":14}],65:[function(require,module,exports){
arguments[4][15][0].apply(exports,arguments)
},{"../utils/common":54,"dup":15}],66:[function(require,module,exports){
arguments[4][16][0].apply(exports,arguments)
},{"dup":16}],67:[function(require,module,exports){
(function (process){
'use strict';

if (!process.version ||
    process.version.indexOf('v0.') === 0 ||
    process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {
  module.exports = nextTick;
} else {
  module.exports = process.nextTick;
}

function nextTick(fn, arg1, arg2, arg3) {
  if (typeof fn !== 'function') {
    throw new TypeError('"callback" argument must be a function');
  }
  var len = arguments.length;
  var args, i;
  switch (len) {
  case 0:
  case 1:
    return process.nextTick(fn);
  case 2:
    return process.nextTick(function afterTickOne() {
      fn.call(null, arg1);
    });
  case 3:
    return process.nextTick(function afterTickTwo() {
      fn.call(null, arg1, arg2);
    });
  case 4:
    return process.nextTick(function afterTickThree() {
      fn.call(null, arg1, arg2, arg3);
    });
  default:
    args = new Array(len - 1);
    i = 0;
    while (i < args.length) {
      args[i++] = arguments[i];
    }
    return process.nextTick(function afterTick() {
      fn.apply(null, args);
    });
  }
}

}).call(this,require('_process'))

},{"_process":68}],68:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],69:[function(require,module,exports){
(function (global){
/*! https://mths.be/punycode v1.4.1 by @mathias */
;(function(root) {

	/** Detect free variables */
	var freeExports = typeof exports == 'object' && exports &&
		!exports.nodeType && exports;
	var freeModule = typeof module == 'object' && module &&
		!module.nodeType && module;
	var freeGlobal = typeof global == 'object' && global;
	if (
		freeGlobal.global === freeGlobal ||
		freeGlobal.window === freeGlobal ||
		freeGlobal.self === freeGlobal
	) {
		root = freeGlobal;
	}

	/**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */
	var punycode,

	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	tMin = 1,
	tMax = 26,
	skew = 38,
	damp = 700,
	initialBias = 72,
	initialN = 128, // 0x80
	delimiter = '-', // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},

	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	floor = Math.floor,
	stringFromCharCode = String.fromCharCode,

	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */
	function error(type) {
		throw new RangeError(errors[type]);
	}

	/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */
	function map(array, fn) {
		var length = array.length;
		var result = [];
		while (length--) {
			result[length] = fn(array[length]);
		}
		return result;
	}

	/**
	 * A simple `Array#map`-like wrapper to work with domain name strings or email
	 * addresses.
	 * @private
	 * @param {String} domain The domain name or email address.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */
	function mapDomain(string, fn) {
		var parts = string.split('@');
		var result = '';
		if (parts.length > 1) {
			// In email addresses, only the domain name should be punycoded. Leave
			// the local part (i.e. everything up to `@`) intact.
			result = parts[0] + '@';
			string = parts[1];
		}
		// Avoid `split(regex)` for IE8 compatibility. See #17.
		string = string.replace(regexSeparators, '\x2E');
		var labels = string.split('.');
		var encoded = map(labels, fn).join('.');
		return result + encoded;
	}

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */
	function ucs2encode(array) {
		return map(array, function(value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * https://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,
		    /** Cached calculation results */
		    baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;

			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);

		}

		return ucs2encode(output);
	}

	/**
	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
	 * Punycode string of ASCII-only symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],
		    /** `inputLength` will hold the number of code points in `input`. */
		    inputLength,
		    /** Cached calculation results */
		    handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base; /* no condition */; k += base) {
						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(
							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
						);
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;

		}
		return output.join('');
	}

	/**
	 * Converts a Punycode string representing a domain name or an email address
	 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
	 * it doesn't matter if you call it on a string that has already been
	 * converted to Unicode.
	 * @memberOf punycode
	 * @param {String} input The Punycoded domain name or email address to
	 * convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */
	function toUnicode(input) {
		return mapDomain(input, function(string) {
			return regexPunycode.test(string)
				? decode(string.slice(4).toLowerCase())
				: string;
		});
	}

	/**
	 * Converts a Unicode string representing a domain name or an email address to
	 * Punycode. Only the non-ASCII parts of the domain name will be converted,
	 * i.e. it doesn't matter if you call it with a domain that's already in
	 * ASCII.
	 * @memberOf punycode
	 * @param {String} input The domain name or email address to convert, as a
	 * Unicode string.
	 * @returns {String} The Punycode representation of the given domain name or
	 * email address.
	 */
	function toASCII(input) {
		return mapDomain(input, function(string) {
			return regexNonASCII.test(string)
				? 'xn--' + encode(string)
				: string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */
		'version': '1.4.1',
		/**
		 * An object of methods to convert from JavaScript's internal character
		 * representation (UCS-2) to Unicode code points, and back.
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode
		 * @type Object
		 */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		typeof define == 'function' &&
		typeof define.amd == 'object' &&
		define.amd
	) {
		define('punycode', function() {
			return punycode;
		});
	} else if (freeExports && freeModule) {
		if (module.exports == freeExports) {
			// in Node.js, io.js, or RingoJS v0.8.0+
			freeModule.exports = punycode;
		} else {
			// in Narwhal or RingoJS v0.7.0-
			for (key in punycode) {
				punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
			}
		}
	} else {
		// in Rhino or a web browser
		root.punycode = punycode;
	}

}(this));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],70:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function(qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr, vstr, k, v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

},{}],71:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var stringifyPrimitive = function(v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function(obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return map(objectKeys(obj), function(k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (isArray(obj[k])) {
        return map(obj[k], function(v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);

  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq +
         encodeURIComponent(stringifyPrimitive(obj));
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

function map (xs, f) {
  if (xs.map) return xs.map(f);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    res.push(f(xs[i], i));
  }
  return res;
}

var objectKeys = Object.keys || function (obj) {
  var res = [];
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
  }
  return res;
};

},{}],72:[function(require,module,exports){
'use strict';

exports.decode = exports.parse = require('./decode');
exports.encode = exports.stringify = require('./encode');

},{"./decode":70,"./encode":71}],73:[function(require,module,exports){
// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.

'use strict';

/*<replacement>*/

var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    keys.push(key);
  }return keys;
};
/*</replacement>*/

module.exports = Duplex;

/*<replacement>*/
var processNextTick = require('process-nextick-args');
/*</replacement>*/

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

var Readable = require('./_stream_readable');
var Writable = require('./_stream_writable');

util.inherits(Duplex, Readable);

var keys = objectKeys(Writable.prototype);
for (var v = 0; v < keys.length; v++) {
  var method = keys[v];
  if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
}

function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);

  Readable.call(this, options);
  Writable.call(this, options);

  if (options && options.readable === false) this.readable = false;

  if (options && options.writable === false) this.writable = false;

  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;

  this.once('end', onend);
}

// the no-half-open enforcer
function onend() {
  // if we allow half-open state, or if the writable side ended,
  // then we're ok.
  if (this.allowHalfOpen || this._writableState.ended) return;

  // no more data can be written.
  // But allow more writes to happen in this tick.
  processNextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

function forEach(xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}
},{"./_stream_readable":74,"./_stream_writable":76,"core-util-is":24,"inherits":28,"process-nextick-args":67}],74:[function(require,module,exports){
(function (process){
'use strict';

module.exports = Readable;

/*<replacement>*/
var processNextTick = require('process-nextick-args');
/*</replacement>*/

/*<replacement>*/
var isArray = require('isarray');
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;

/*<replacement>*/
var EE = require('events').EventEmitter;

var EElistenerCount = function (emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/
var Stream;
(function () {
  try {
    Stream = require('st' + 'ream');
  } catch (_) {} finally {
    if (!Stream) Stream = require('events').EventEmitter;
  }
})();
/*</replacement>*/

var Buffer = require('buffer').Buffer;
/*<replacement>*/
var bufferShim = require('buffer-shims');
/*</replacement>*/

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

/*<replacement>*/
var debugUtil = require('util');
var debug = void 0;
if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function () {};
}
/*</replacement>*/

var BufferList = require('./internal/streams/BufferList');
var StringDecoder;

util.inherits(Readable, Stream);

function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') {
    return emitter.prependListener(event, fn);
  } else {
    // This is a hack to make sure that our error handler is attached before any
    // userland ones.  NEVER DO THIS. This is here only because this code needs
    // to continue to work with older versions of Node.js that do not include
    // the prependListener() method. The goal is to eventually remove this hack.
    if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
  }
}

function ReadableState(options, stream) {
  Duplex = Duplex || require('./_stream_duplex');

  options = options || {};

  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;

  if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.readableObjectMode;

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  var hwm = options.highWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;

  // cast to ints.
  this.highWaterMark = ~~this.highWaterMark;

  // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()
  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // when piping, we only care about 'readable' events that happen
  // after read()ing all the bytes and not getting any pushback.
  this.ranOut = false;

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;

  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  Duplex = Duplex || require('./_stream_duplex');

  if (!(this instanceof Readable)) return new Readable(options);

  this._readableState = new ReadableState(options, this);

  // legacy
  this.readable = true;

  if (options && typeof options.read === 'function') this._read = options.read;

  Stream.call(this);
}

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;

  if (!state.objectMode && typeof chunk === 'string') {
    encoding = encoding || state.defaultEncoding;
    if (encoding !== state.encoding) {
      chunk = bufferShim.from(chunk, encoding);
      encoding = '';
    }
  }

  return readableAddChunk(this, state, chunk, encoding, false);
};

// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function (chunk) {
  var state = this._readableState;
  return readableAddChunk(this, state, chunk, '', true);
};

Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
};

function readableAddChunk(stream, state, chunk, encoding, addToFront) {
  var er = chunkInvalid(state, chunk);
  if (er) {
    stream.emit('error', er);
  } else if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else if (state.objectMode || chunk && chunk.length > 0) {
    if (state.ended && !addToFront) {
      var e = new Error('stream.push() after EOF');
      stream.emit('error', e);
    } else if (state.endEmitted && addToFront) {
      var _e = new Error('stream.unshift() after end event');
      stream.emit('error', _e);
    } else {
      var skipAdd;
      if (state.decoder && !addToFront && !encoding) {
        chunk = state.decoder.write(chunk);
        skipAdd = !state.objectMode && chunk.length === 0;
      }

      if (!addToFront) state.reading = false;

      // Don't add to the buffer if we've decoded to an empty string chunk and
      // we're not in object mode
      if (!skipAdd) {
        // if we want the data now, just emit it.
        if (state.flowing && state.length === 0 && !state.sync) {
          stream.emit('data', chunk);
          stream.read(0);
        } else {
          // update the buffer info.
          state.length += state.objectMode ? 1 : chunk.length;
          if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);

          if (state.needReadable) emitReadable(stream);
        }
      }

      maybeReadMore(stream, state);
    }
  } else if (!addToFront) {
    state.reading = false;
  }

  return needMoreData(state);
}

// if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.
function needMoreData(state) {
  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
}

// backwards compatibility.
Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
  return this;
};

// Don't raise the hwm > 8MB
var MAX_HWM = 0x800000;
function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }
  return n;
}

// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;
  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  }
  // If we're asking for more than the current hwm, then raise the hwm.
  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n;
  // Don't have enough
  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }
  return state.length;
}

// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;

  if (n !== 0) state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;
  debug('need readable', doRead);

  // if we currently have less than the highWaterMark, then also read some
  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  }

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0) state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
    // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.
    if (!state.reading) n = howMuchToRead(nOrig, state);
  }

  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;

  if (ret === null) {
    state.needReadable = true;
    n = 0;
  } else {
    state.length -= n;
  }

  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true;

    // If we tried to read() past the EOF, then emit end on the next tick.
    if (nOrig !== n && state.ended) endReadable(this);
  }

  if (ret !== null) this.emit('data', ret);

  return ret;
};

function chunkInvalid(state, chunk) {
  var er = null;
  if (!Buffer.isBuffer(chunk) && typeof chunk !== 'string' && chunk !== null && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  return er;
}

function onEofChunk(stream, state) {
  if (state.ended) return;
  if (state.decoder) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;

  // emit 'readable' now to make sure it gets picked up.
  emitReadable(stream);
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;
  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    if (state.sync) processNextTick(emitReadable_, stream);else emitReadable_(stream);
  }
}

function emitReadable_(stream) {
  debug('emit readable');
  stream.emit('readable');
  flow(stream);
}

// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    processNextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;else len = state.length;
  }
  state.readingMore = false;
}

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function (n) {
  this.emit('error', new Error('_read() is not implemented'));
};

Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;

  var endFn = doEnd ? onend : cleanup;
  if (state.endEmitted) processNextTick(endFn);else src.once('end', endFn);

  dest.on('unpipe', onunpipe);
  function onunpipe(readable) {
    debug('onunpipe');
    if (readable === src) {
      cleanup();
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);

  var cleanedUp = false;
  function cleanup() {
    debug('cleanup');
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', cleanup);
    src.removeListener('data', ondata);

    cleanedUp = true;

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }

  // If the user pushes more data while we're writing to dest then we'll end up
  // in ondata again. However, we only want to increase awaitDrain once because
  // dest will only emit one 'drain' event for the multiple writes.
  // => Introduce a guard on increasing awaitDrain.
  var increasedAwaitDrain = false;
  src.on('data', ondata);
  function ondata(chunk) {
    debug('ondata');
    increasedAwaitDrain = false;
    var ret = dest.write(chunk);
    if (false === ret && !increasedAwaitDrain) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', src._readableState.awaitDrain);
        src._readableState.awaitDrain++;
        increasedAwaitDrain = true;
      }
      src.pause();
    }
  }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);
  }

  // Make sure our error handler is attached before userland ones.
  prependListener(dest, 'error', onerror);

  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  }

  // tell the dest that it's being piped to
  dest.emit('pipe', src);

  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function () {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;
    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;

  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0) return this;

  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;

    if (!dest) dest = state.pipes;

    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this);
    return this;
  }

  // slow case. multiple pipe destinations.

  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++) {
      dests[i].emit('unpipe', this);
    }return this;
  }

  // try to find the right one.
  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;

  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];

  dest.emit('unpipe', this);

  return this;
};

// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);

  if (ev === 'data') {
    // Start flowing on next tick if stream isn't explicitly paused
    if (this._readableState.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    var state = this._readableState;
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.emittedReadable = false;
      if (!state.reading) {
        processNextTick(nReadingNextTick, this);
      } else if (state.length) {
        emitReadable(this, state);
      }
    }
  }

  return res;
};
Readable.prototype.addListener = Readable.prototype.on;

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
}

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function () {
  var state = this._readableState;
  if (!state.flowing) {
    debug('resume');
    state.flowing = true;
    resume(this, state);
  }
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    processNextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  if (!state.reading) {
    debug('resume read 0');
    stream.read(0);
  }

  state.resumeScheduled = false;
  state.awaitDrain = 0;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}

Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);
  if (false !== this._readableState.flowing) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);
  while (state.flowing && stream.read() !== null) {}
}

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function (stream) {
  var state = this._readableState;
  var paused = false;

  var self = this;
  stream.on('end', function () {
    debug('wrapped end');
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) self.push(chunk);
    }

    self.push(null);
  });

  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk);

    // don't skip over falsy values in objectMode
    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

    var ret = self.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function (method) {
        return function () {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  }

  // proxy certain important events.
  var events = ['error', 'close', 'destroy', 'pause', 'resume'];
  forEach(events, function (ev) {
    stream.on(ev, self.emit.bind(self, ev));
  });

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  self._read = function (n) {
    debug('wrapped _read', n);
    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return self;
};

// exposed for testing purposes only.
Readable._fromList = fromList;

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;

  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = fromListPartial(n, state.buffer, state.decoder);
  }

  return ret;
}

// Extracts only enough buffered data to satisfy the amount requested.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromListPartial(n, list, hasStrings) {
  var ret;
  if (n < list.head.data.length) {
    // slice is the same for buffers and strings
    ret = list.head.data.slice(0, n);
    list.head.data = list.head.data.slice(n);
  } else if (n === list.head.data.length) {
    // first chunk is a perfect match
    ret = list.shift();
  } else {
    // result spans more than one buffer
    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
  }
  return ret;
}

// Copies a specified amount of characters from the list of buffered data
// chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBufferString(n, list) {
  var p = list.head;
  var c = 1;
  var ret = p.data;
  n -= ret.length;
  while (p = p.next) {
    var str = p.data;
    var nb = n > str.length ? str.length : n;
    if (nb === str.length) ret += str;else ret += str.slice(0, n);
    n -= nb;
    if (n === 0) {
      if (nb === str.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = str.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

// Copies a specified amount of bytes from the list of buffered data chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBuffer(n, list) {
  var ret = bufferShim.allocUnsafe(n);
  var p = list.head;
  var c = 1;
  p.data.copy(ret);
  n -= p.data.length;
  while (p = p.next) {
    var buf = p.data;
    var nb = n > buf.length ? buf.length : n;
    buf.copy(ret, ret.length - n, 0, nb);
    n -= nb;
    if (n === 0) {
      if (nb === buf.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = buf.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;

  // If we get here before consuming all the bytes, then that is a
  // bug in node.  Should never happen.
  if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');

  if (!state.endEmitted) {
    state.ended = true;
    processNextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  // Check that we didn't get one last unshift.
  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');
  }
}

function forEach(xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}

function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}
}).call(this,require('_process'))

},{"./_stream_duplex":73,"./internal/streams/BufferList":77,"_process":68,"buffer":20,"buffer-shims":19,"core-util-is":24,"events":26,"inherits":28,"isarray":78,"process-nextick-args":67,"string_decoder/":80,"util":5}],75:[function(require,module,exports){
// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.

'use strict';

module.exports = Transform;

var Duplex = require('./_stream_duplex');

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(Transform, Duplex);

function TransformState(stream) {
  this.afterTransform = function (er, data) {
    return afterTransform(stream, er, data);
  };

  this.needTransform = false;
  this.transforming = false;
  this.writecb = null;
  this.writechunk = null;
  this.writeencoding = null;
}

function afterTransform(stream, er, data) {
  var ts = stream._transformState;
  ts.transforming = false;

  var cb = ts.writecb;

  if (!cb) return stream.emit('error', new Error('no writecb in Transform class'));

  ts.writechunk = null;
  ts.writecb = null;

  if (data !== null && data !== undefined) stream.push(data);

  cb(er);

  var rs = stream._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    stream._read(rs.highWaterMark);
  }
}

function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);

  Duplex.call(this, options);

  this._transformState = new TransformState(this);

  var stream = this;

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;

    if (typeof options.flush === 'function') this._flush = options.flush;
  }

  // When the writable side finishes, then flush out anything remaining.
  this.once('prefinish', function () {
    if (typeof this._flush === 'function') this._flush(function (er, data) {
      done(stream, er, data);
    });else done(stream);
  });
}

Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function (chunk, encoding, cb) {
  throw new Error('_transform() is not implemented');
};

Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
};

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function (n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};

function done(stream, er, data) {
  if (er) return stream.emit('error', er);

  if (data !== null && data !== undefined) stream.push(data);

  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  var ws = stream._writableState;
  var ts = stream._transformState;

  if (ws.length) throw new Error('Calling transform done when ws.length != 0');

  if (ts.transforming) throw new Error('Calling transform done when still transforming');

  return stream.push(null);
}
},{"./_stream_duplex":73,"core-util-is":24,"inherits":28}],76:[function(require,module,exports){
(function (process){
// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.

'use strict';

module.exports = Writable;

/*<replacement>*/
var processNextTick = require('process-nextick-args');
/*</replacement>*/

/*<replacement>*/
var asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : processNextTick;
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

/*<replacement>*/
var internalUtil = {
  deprecate: require('util-deprecate')
};
/*</replacement>*/

/*<replacement>*/
var Stream;
(function () {
  try {
    Stream = require('st' + 'ream');
  } catch (_) {} finally {
    if (!Stream) Stream = require('events').EventEmitter;
  }
})();
/*</replacement>*/

var Buffer = require('buffer').Buffer;
/*<replacement>*/
var bufferShim = require('buffer-shims');
/*</replacement>*/

util.inherits(Writable, Stream);

function nop() {}

function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
}

function WritableState(options, stream) {
  Duplex = Duplex || require('./_stream_duplex');

  options = options || {};

  // object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!options.objectMode;

  if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.writableObjectMode;

  // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()
  var hwm = options.highWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;

  // cast to ints.
  this.highWaterMark = ~~this.highWaterMark;

  // drain event flag.
  this.needDrain = false;
  // at the start of calling end()
  this.ending = false;
  // when end() has been called, and returned
  this.ended = false;
  // when 'finish' is emitted
  this.finished = false;

  // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0;

  // a flag to see when we're in the middle of a write.
  this.writing = false;

  // when true all writes will be buffered until .uncork() call
  this.corked = 0;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false;

  // the callback that's passed to _write(chunk,cb)
  this.onwrite = function (er) {
    onwrite(stream, er);
  };

  // the callback that the user supplies to write(chunk,encoding,cb)
  this.writecb = null;

  // the amount that is being written when _write is called.
  this.writelen = 0;

  this.bufferedRequest = null;
  this.lastBufferedRequest = null;

  // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted
  this.pendingcb = 0;

  // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams
  this.prefinished = false;

  // True if the error was already emitted and should not be thrown again
  this.errorEmitted = false;

  // count buffered requests
  this.bufferedRequestCount = 0;

  // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two
  this.corkedRequestsFree = new CorkedRequest(this);
}

WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];
  while (current) {
    out.push(current);
    current = current.next;
  }
  return out;
};

(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function () {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.')
    });
  } catch (_) {}
})();

// Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.
var realHasInstance;
if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function (object) {
      if (realHasInstance.call(this, object)) return true;

      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function (object) {
    return object instanceof this;
  };
}

function Writable(options) {
  Duplex = Duplex || require('./_stream_duplex');

  // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.

  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.
  if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
    return new Writable(options);
  }

  this._writableState = new WritableState(options, this);

  // legacy.
  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') this._write = options.write;

    if (typeof options.writev === 'function') this._writev = options.writev;
  }

  Stream.call(this);
}

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function () {
  this.emit('error', new Error('Cannot pipe, not readable'));
};

function writeAfterEnd(stream, cb) {
  var er = new Error('write after end');
  // TODO: defer error events consistently everywhere, not just the cb
  stream.emit('error', er);
  processNextTick(cb, er);
}

// Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.
function validChunk(stream, state, chunk, cb) {
  var valid = true;
  var er = false;

  if (chunk === null) {
    er = new TypeError('May not write null values to stream');
  } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  if (er) {
    stream.emit('error', er);
    processNextTick(cb, er);
    valid = false;
  }
  return valid;
}

Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;
  var isBuf = Buffer.isBuffer(chunk);

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;

  if (typeof cb !== 'function') cb = nop;

  if (state.ended) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }

  return ret;
};

Writable.prototype.cork = function () {
  var state = this._writableState;

  state.corked++;
};

Writable.prototype.uncork = function () {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;

    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = bufferShim.from(chunk, encoding);
  }
  return chunk;
}

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    chunk = decodeChunk(state, chunk, encoding);
    if (Buffer.isBuffer(chunk)) encoding = 'buffer';
  }
  var len = state.objectMode ? 1 : chunk.length;

  state.length += len;

  var ret = state.length < state.highWaterMark;
  // we must ensure that previous needDrain will not be reset to false.
  if (!ret) state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = new WriteReq(chunk, encoding, cb);
    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }
    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;
  if (sync) processNextTick(cb, er);else cb(er);

  stream._writableState.errorEmitted = true;
  stream.emit('error', er);
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;

  onwriteStateUpdate(state);

  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state);

    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      /*<replacement>*/
      asyncWrite(afterWrite, stream, state, finished, cb);
      /*</replacement>*/
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
}

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
}

// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;

    var count = 0;
    while (entry) {
      buffer[count] = entry;
      entry = entry.next;
      count += 1;
    }

    doWrite(stream, state, true, state.length, buffer, '', holder.finish);

    // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite
    state.pendingcb++;
    state.lastBufferedRequest = null;
    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;

      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.
      if (state.writing) {
        break;
      }
    }

    if (entry === null) state.lastBufferedRequest = null;
  }

  state.bufferedRequestCount = 0;
  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new Error('_write() is not implemented'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);

  // .end() fully uncorks
  if (state.corked) {
    state.corked = 1;
    this.uncork();
  }

  // ignore unnecessary end() calls.
  if (!state.ending && !state.finished) endWritable(this, state, cb);
};

function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}

function prefinish(stream, state) {
  if (!state.prefinished) {
    state.prefinished = true;
    stream.emit('prefinish');
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);
  if (need) {
    if (state.pendingcb === 0) {
      prefinish(stream, state);
      state.finished = true;
      stream.emit('finish');
    } else {
      prefinish(stream, state);
    }
  }
  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished) processNextTick(cb);else stream.once('finish', cb);
  }
  state.ended = true;
  stream.writable = false;
}

// It seems a linked list but it is not
// there will be only 2 of these for each stream
function CorkedRequest(state) {
  var _this = this;

  this.next = null;
  this.entry = null;
  this.finish = function (err) {
    var entry = _this.entry;
    _this.entry = null;
    while (entry) {
      var cb = entry.callback;
      state.pendingcb--;
      cb(err);
      entry = entry.next;
    }
    if (state.corkedRequestsFree) {
      state.corkedRequestsFree.next = _this;
    } else {
      state.corkedRequestsFree = _this;
    }
  };
}
}).call(this,require('_process'))

},{"./_stream_duplex":73,"_process":68,"buffer":20,"buffer-shims":19,"core-util-is":24,"events":26,"inherits":28,"process-nextick-args":67,"util-deprecate":83}],77:[function(require,module,exports){
'use strict';

var Buffer = require('buffer').Buffer;
/*<replacement>*/
var bufferShim = require('buffer-shims');
/*</replacement>*/

module.exports = BufferList;

function BufferList() {
  this.head = null;
  this.tail = null;
  this.length = 0;
}

BufferList.prototype.push = function (v) {
  var entry = { data: v, next: null };
  if (this.length > 0) this.tail.next = entry;else this.head = entry;
  this.tail = entry;
  ++this.length;
};

BufferList.prototype.unshift = function (v) {
  var entry = { data: v, next: this.head };
  if (this.length === 0) this.tail = entry;
  this.head = entry;
  ++this.length;
};

BufferList.prototype.shift = function () {
  if (this.length === 0) return;
  var ret = this.head.data;
  if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
  --this.length;
  return ret;
};

BufferList.prototype.clear = function () {
  this.head = this.tail = null;
  this.length = 0;
};

BufferList.prototype.join = function (s) {
  if (this.length === 0) return '';
  var p = this.head;
  var ret = '' + p.data;
  while (p = p.next) {
    ret += s + p.data;
  }return ret;
};

BufferList.prototype.concat = function (n) {
  if (this.length === 0) return bufferShim.alloc(0);
  if (this.length === 1) return this.head.data;
  var ret = bufferShim.allocUnsafe(n >>> 0);
  var p = this.head;
  var i = 0;
  while (p) {
    p.data.copy(ret, i);
    i += p.data.length;
    p = p.next;
  }
  return ret;
};
},{"buffer":20,"buffer-shims":19}],78:[function(require,module,exports){
arguments[4][21][0].apply(exports,arguments)
},{"dup":21}],79:[function(require,module,exports){
module.exports = require("./lib/_stream_transform.js")

},{"./lib/_stream_transform.js":75}],80:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var Buffer = require('buffer').Buffer;

var isBufferEncoding = Buffer.isEncoding
  || function(encoding) {
       switch (encoding && encoding.toLowerCase()) {
         case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;
         default: return false;
       }
     }


function assertEncoding(encoding) {
  if (encoding && !isBufferEncoding(encoding)) {
    throw new Error('Unknown encoding: ' + encoding);
  }
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters. CESU-8 is handled as part of the UTF-8 encoding.
//
// @TODO Handling all encodings inside a single object makes it very difficult
// to reason about this code, so it should be split up in the future.
// @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code
// points as used by CESU-8.
var StringDecoder = exports.StringDecoder = function(encoding) {
  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');
  assertEncoding(encoding);
  switch (this.encoding) {
    case 'utf8':
      // CESU-8 represents each of Surrogate Pair by 3-bytes
      this.surrogateSize = 3;
      break;
    case 'ucs2':
    case 'utf16le':
      // UTF-16 represents each of Surrogate Pair by 2-bytes
      this.surrogateSize = 2;
      this.detectIncompleteChar = utf16DetectIncompleteChar;
      break;
    case 'base64':
      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.
      this.surrogateSize = 3;
      this.detectIncompleteChar = base64DetectIncompleteChar;
      break;
    default:
      this.write = passThroughWrite;
      return;
  }

  // Enough space to store all bytes of a single character. UTF-8 needs 4
  // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).
  this.charBuffer = new Buffer(6);
  // Number of bytes received for the current incomplete multi-byte character.
  this.charReceived = 0;
  // Number of bytes expected for the current incomplete multi-byte character.
  this.charLength = 0;
};


// write decodes the given buffer and returns it as JS string that is
// guaranteed to not contain any partial multi-byte characters. Any partial
// character found at the end of the buffer is buffered up, and will be
// returned when calling write again with the remaining bytes.
//
// Note: Converting a Buffer containing an orphan surrogate to a String
// currently works, but converting a String to a Buffer (via `new Buffer`, or
// Buffer#write) will replace incomplete surrogates with the unicode
// replacement character. See https://codereview.chromium.org/121173009/ .
StringDecoder.prototype.write = function(buffer) {
  var charStr = '';
  // if our last write ended with an incomplete multibyte character
  while (this.charLength) {
    // determine how many remaining bytes this buffer has to offer for this char
    var available = (buffer.length >= this.charLength - this.charReceived) ?
        this.charLength - this.charReceived :
        buffer.length;

    // add the new bytes to the char buffer
    buffer.copy(this.charBuffer, this.charReceived, 0, available);
    this.charReceived += available;

    if (this.charReceived < this.charLength) {
      // still not enough chars in this buffer? wait for more ...
      return '';
    }

    // remove bytes belonging to the current character from the buffer
    buffer = buffer.slice(available, buffer.length);

    // get the character that was split
    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);

    // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
    var charCode = charStr.charCodeAt(charStr.length - 1);
    if (charCode >= 0xD800 && charCode <= 0xDBFF) {
      this.charLength += this.surrogateSize;
      charStr = '';
      continue;
    }
    this.charReceived = this.charLength = 0;

    // if there are no more bytes in this buffer, just emit our char
    if (buffer.length === 0) {
      return charStr;
    }
    break;
  }

  // determine and set charLength / charReceived
  this.detectIncompleteChar(buffer);

  var end = buffer.length;
  if (this.charLength) {
    // buffer the incomplete character bytes we got
    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
    end -= this.charReceived;
  }

  charStr += buffer.toString(this.encoding, 0, end);

  var end = charStr.length - 1;
  var charCode = charStr.charCodeAt(end);
  // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
  if (charCode >= 0xD800 && charCode <= 0xDBFF) {
    var size = this.surrogateSize;
    this.charLength += size;
    this.charReceived += size;
    this.charBuffer.copy(this.charBuffer, size, 0, size);
    buffer.copy(this.charBuffer, 0, 0, size);
    return charStr.substring(0, end);
  }

  // or just emit the charStr
  return charStr;
};

// detectIncompleteChar determines if there is an incomplete UTF-8 character at
// the end of the given buffer. If so, it sets this.charLength to the byte
// length that character, and sets this.charReceived to the number of bytes
// that are available for this character.
StringDecoder.prototype.detectIncompleteChar = function(buffer) {
  // determine how many bytes we have to check at the end of this buffer
  var i = (buffer.length >= 3) ? 3 : buffer.length;

  // Figure out if one of the last i bytes of our buffer announces an
  // incomplete char.
  for (; i > 0; i--) {
    var c = buffer[buffer.length - i];

    // See http://en.wikipedia.org/wiki/UTF-8#Description

    // 110XXXXX
    if (i == 1 && c >> 5 == 0x06) {
      this.charLength = 2;
      break;
    }

    // 1110XXXX
    if (i <= 2 && c >> 4 == 0x0E) {
      this.charLength = 3;
      break;
    }

    // 11110XXX
    if (i <= 3 && c >> 3 == 0x1E) {
      this.charLength = 4;
      break;
    }
  }
  this.charReceived = i;
};

StringDecoder.prototype.end = function(buffer) {
  var res = '';
  if (buffer && buffer.length)
    res = this.write(buffer);

  if (this.charReceived) {
    var cr = this.charReceived;
    var buf = this.charBuffer;
    var enc = this.encoding;
    res += buf.slice(0, cr).toString(enc);
  }

  return res;
};

function passThroughWrite(buffer) {
  return buffer.toString(this.encoding);
}

function utf16DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 2;
  this.charLength = this.charReceived ? 2 : 0;
}

function base64DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 3;
  this.charLength = this.charReceived ? 3 : 0;
}

},{"buffer":20}],81:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var punycode = require('punycode');
var util = require('./util');

exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;

exports.Url = Url;

function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,

    // Special case for a simple path URL
    simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,

    // RFC 2396: characters reserved for delimiting URLs.
    // We actually just auto-escape these.
    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],

    // RFC 2396: characters not allowed for various reasons.
    unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),

    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
    autoEscape = ['\''].concat(unwise),
    // Characters that are never ever allowed in a hostname.
    // Note that any invalid chars are also handled, but these
    // are the ones that are *expected* to be seen, so we fast-path
    // them.
    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
    hostEndingChars = ['/', '?', '#'],
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
    // protocols that can allow "unsafe" and "unwise" chars.
    unsafeProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that never have a hostname.
    hostlessProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that always contain a // bit.
    slashedProtocol = {
      'http': true,
      'https': true,
      'ftp': true,
      'gopher': true,
      'file': true,
      'http:': true,
      'https:': true,
      'ftp:': true,
      'gopher:': true,
      'file:': true
    },
    querystring = require('querystring');

function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && util.isObject(url) && url instanceof Url) return url;

  var u = new Url;
  u.parse(url, parseQueryString, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
  if (!util.isString(url)) {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
  }

  // Copy chrome, IE, opera backslash-handling behavior.
  // Back slashes before the query string get converted to forward slashes
  // See: https://code.google.com/p/chromium/issues/detail?id=25916
  var queryIndex = url.indexOf('?'),
      splitter =
          (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#',
      uSplit = url.split(splitter),
      slashRegex = /\\/g;
  uSplit[0] = uSplit[0].replace(slashRegex, '/');
  url = uSplit.join(splitter);

  var rest = url;

  // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"
  rest = rest.trim();

  if (!slashesDenoteHost && url.split('#').length === 1) {
    // Try fast path regexp
    var simplePath = simplePathPattern.exec(rest);
    if (simplePath) {
      this.path = rest;
      this.href = rest;
      this.pathname = simplePath[1];
      if (simplePath[2]) {
        this.search = simplePath[2];
        if (parseQueryString) {
          this.query = querystring.parse(this.search.substr(1));
        } else {
          this.query = this.search.substr(1);
        }
      } else if (parseQueryString) {
        this.search = '';
        this.query = {};
      }
      return this;
    }
  }

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    this.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }

  // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] &&
      (slashes || (proto && !slashedProtocol[proto]))) {

    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ => user:a@b host:c
    // http://a@b?@c => user:a host:c path:/?@c

    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.

    // find the first instance of any hostEndingChars
    var hostEnd = -1;
    for (var i = 0; i < hostEndingChars.length; i++) {
      var hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }

    // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.
    var auth, atSign;
    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      // atSign must be in auth portion.
      // http://a@b/c@d => host:b auth:a path:/c@d
      atSign = rest.lastIndexOf('@', hostEnd);
    }

    // Now we have a portion which is definitely the auth.
    // Pull that off.
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = decodeURIComponent(auth);
    }

    // the host is the remaining to the left of the first non-host char
    hostEnd = -1;
    for (var i = 0; i < nonHostChars.length; i++) {
      var hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }
    // if we still have not hit it, then the entire thing is a host.
    if (hostEnd === -1)
      hostEnd = rest.length;

    this.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);

    // pull out port.
    this.parseHost();

    // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.
    this.hostname = this.hostname || '';

    // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.
    var ipv6Hostname = this.hostname[0] === '[' &&
        this.hostname[this.hostname.length - 1] === ']';

    // validate a little.
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (var i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) continue;
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = '/' + notHost.join('.') + rest;
            }
            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    } else {
      // hostnames are always lower case.
      this.hostname = this.hostname.toLowerCase();
    }

    if (!ipv6Hostname) {
      // IDNA Support: Returns a punycoded representation of "domain".
      // It only converts parts of the domain name that
      // have non-ASCII characters, i.e. it doesn't matter if
      // you call it with a domain that already is ASCII-only.
      this.hostname = punycode.toASCII(this.hostname);
    }

    var p = this.port ? ':' + this.port : '';
    var h = this.hostname || '';
    this.host = h + p;
    this.href += this.host;

    // strip [ and ] from the hostname
    // the host field still retains them, though
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
      if (rest[0] !== '/') {
        rest = '/' + rest;
      }
    }
  }

  // now rest is set to the post-host stuff.
  // chop off any delim chars.
  if (!unsafeProtocol[lowerProto]) {

    // First, make 100% sure that any "autoEscape" chars get
    // escaped, even if encodeURIComponent doesn't think they
    // need to be.
    for (var i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      if (rest.indexOf(ae) === -1)
        continue;
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }
  }


  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    this.search = rest.substr(qm);
    this.query = rest.substr(qm + 1);
    if (parseQueryString) {
      this.query = querystring.parse(this.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
    this.search = '';
    this.query = {};
  }
  if (rest) this.pathname = rest;
  if (slashedProtocol[lowerProto] &&
      this.hostname && !this.pathname) {
    this.pathname = '/';
  }

  //to support http.request
  if (this.pathname || this.search) {
    var p = this.pathname || '';
    var s = this.search || '';
    this.path = p + s;
  }

  // finally, reconstruct the href based on what has been validated.
  this.href = this.format();
  return this;
};

// format a parsed object into a url string
function urlFormat(obj) {
  // ensure it's an object, and not a string url.
  // If it's an obj, this is a no-op.
  // this way, you can call url_format() on strings
  // to clean up potentially wonky urls.
  if (util.isString(obj)) obj = urlParse(obj);
  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
  return obj.format();
}

Url.prototype.format = function() {
  var auth = this.auth || '';
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ':');
    auth += '@';
  }

  var protocol = this.protocol || '',
      pathname = this.pathname || '',
      hash = this.hash || '',
      host = false,
      query = '';

  if (this.host) {
    host = auth + this.host;
  } else if (this.hostname) {
    host = auth + (this.hostname.indexOf(':') === -1 ?
        this.hostname :
        '[' + this.hostname + ']');
    if (this.port) {
      host += ':' + this.port;
    }
  }

  if (this.query &&
      util.isObject(this.query) &&
      Object.keys(this.query).length) {
    query = querystring.stringify(this.query);
  }

  var search = this.search || (query && ('?' + query)) || '';

  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
  // unless they had them to begin with.
  if (this.slashes ||
      (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
  if (search && search.charAt(0) !== '?') search = '?' + search;

  pathname = pathname.replace(/[?#]/g, function(match) {
    return encodeURIComponent(match);
  });
  search = search.replace('#', '%23');

  return protocol + host + pathname + search + hash;
};

function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}

Url.prototype.resolve = function(relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};

function urlResolveObject(source, relative) {
  if (!source) return relative;
  return urlParse(source, false, true).resolveObject(relative);
}

Url.prototype.resolveObject = function(relative) {
  if (util.isString(relative)) {
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  }

  var result = new Url();
  var tkeys = Object.keys(this);
  for (var tk = 0; tk < tkeys.length; tk++) {
    var tkey = tkeys[tk];
    result[tkey] = this[tkey];
  }

  // hash is always overridden, no matter what.
  // even href="" will remove it.
  result.hash = relative.hash;

  // if the relative url is empty, then there's nothing left to do here.
  if (relative.href === '') {
    result.href = result.format();
    return result;
  }

  // hrefs like //foo/bar always cut to the protocol.
  if (relative.slashes && !relative.protocol) {
    // take everything except the protocol from relative
    var rkeys = Object.keys(relative);
    for (var rk = 0; rk < rkeys.length; rk++) {
      var rkey = rkeys[rk];
      if (rkey !== 'protocol')
        result[rkey] = relative[rkey];
    }

    //urlParse appends trailing / to urls like http://www.example.com
    if (slashedProtocol[result.protocol] &&
        result.hostname && !result.pathname) {
      result.path = result.pathname = '/';
    }

    result.href = result.format();
    return result;
  }

  if (relative.protocol && relative.protocol !== result.protocol) {
    // if it's a known url protocol, then changing
    // the protocol does weird things
    // first, if it's not file:, then we MUST have a host,
    // and if there was a path
    // to begin with, then we MUST have a path.
    // if it is file:, then the host is dropped,
    // because that's known to be hostless.
    // anything else is assumed to be absolute.
    if (!slashedProtocol[relative.protocol]) {
      var keys = Object.keys(relative);
      for (var v = 0; v < keys.length; v++) {
        var k = keys[v];
        result[k] = relative[k];
      }
      result.href = result.format();
      return result;
    }

    result.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || '').split('/');
      while (relPath.length && !(relative.host = relPath.shift()));
      if (!relative.host) relative.host = '';
      if (!relative.hostname) relative.hostname = '';
      if (relPath[0] !== '') relPath.unshift('');
      if (relPath.length < 2) relPath.unshift('');
      result.pathname = relPath.join('/');
    } else {
      result.pathname = relative.pathname;
    }
    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || '';
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port;
    // to support http.request
    if (result.pathname || result.search) {
      var p = result.pathname || '';
      var s = result.search || '';
      result.path = p + s;
    }
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }

  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
      isRelAbs = (
          relative.host ||
          relative.pathname && relative.pathname.charAt(0) === '/'
      ),
      mustEndAbs = (isRelAbs || isSourceAbs ||
                    (result.host && relative.pathname)),
      removeAllDots = mustEndAbs,
      srcPath = result.pathname && result.pathname.split('/') || [],
      relPath = relative.pathname && relative.pathname.split('/') || [],
      psychotic = result.protocol && !slashedProtocol[result.protocol];

  // if the url is a non-slashed url, then relative
  // links like ../.. should be able
  // to crawl up to the hostname, as well.  This is strange.
  // result.protocol has already been set by now.
  // Later on, put the first path part into the host field.
  if (psychotic) {
    result.hostname = '';
    result.port = null;
    if (result.host) {
      if (srcPath[0] === '') srcPath[0] = result.host;
      else srcPath.unshift(result.host);
    }
    result.host = '';
    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;
      if (relative.host) {
        if (relPath[0] === '') relPath[0] = relative.host;
        else relPath.unshift(relative.host);
      }
      relative.host = null;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  }

  if (isRelAbs) {
    // it's absolute.
    result.host = (relative.host || relative.host === '') ?
                  relative.host : result.host;
    result.hostname = (relative.hostname || relative.hostname === '') ?
                      relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath;
    // fall through to the dot-handling below.
  } else if (relPath.length) {
    // it's relative
    // throw away the existing file, and take the new path instead.
    if (!srcPath) srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (!util.isNullOrUndefined(relative.search)) {
    // just pull out the search.
    // like href='?foo'.
    // Put this after the other two cases because it simplifies the booleans
    if (psychotic) {
      result.hostname = result.host = srcPath.shift();
      //occationaly the auth can get stuck only in host
      //this especially happens in cases like
      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
      var authInHost = result.host && result.host.indexOf('@') > 0 ?
                       result.host.split('@') : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }
    result.search = relative.search;
    result.query = relative.query;
    //to support http.request
    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
      result.path = (result.pathname ? result.pathname : '') +
                    (result.search ? result.search : '');
    }
    result.href = result.format();
    return result;
  }

  if (!srcPath.length) {
    // no path at all.  easy.
    // we've already handled the other stuff above.
    result.pathname = null;
    //to support http.request
    if (result.search) {
      result.path = '/' + result.search;
    } else {
      result.path = null;
    }
    result.href = result.format();
    return result;
  }

  // if a url ENDs in . or .., then it must get a trailing slash.
  // however, if it ends in anything else non-slashy,
  // then it must NOT get a trailing slash.
  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (
      (result.host || relative.host || srcPath.length > 1) &&
      (last === '.' || last === '..') || last === '');

  // strip single dots, resolve double dots to parent dir
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];
    if (last === '.') {
      srcPath.splice(i, 1);
    } else if (last === '..') {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift('..');
    }
  }

  if (mustEndAbs && srcPath[0] !== '' &&
      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
    srcPath.unshift('');
  }

  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
    srcPath.push('');
  }

  var isAbsolute = srcPath[0] === '' ||
      (srcPath[0] && srcPath[0].charAt(0) === '/');

  // put the host back
  if (psychotic) {
    result.hostname = result.host = isAbsolute ? '' :
                                    srcPath.length ? srcPath.shift() : '';
    //occationaly the auth can get stuck only in host
    //this especially happens in cases like
    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
    var authInHost = result.host && result.host.indexOf('@') > 0 ?
                     result.host.split('@') : false;
    if (authInHost) {
      result.auth = authInHost.shift();
      result.host = result.hostname = authInHost.shift();
    }
  }

  mustEndAbs = mustEndAbs || (result.host && srcPath.length);

  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift('');
  }

  if (!srcPath.length) {
    result.pathname = null;
    result.path = null;
  } else {
    result.pathname = srcPath.join('/');
  }

  //to support request.http
  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
    result.path = (result.pathname ? result.pathname : '') +
                  (result.search ? result.search : '');
  }
  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};

Url.prototype.parseHost = function() {
  var host = this.host;
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) this.hostname = host;
};

},{"./util":82,"punycode":69,"querystring":72}],82:[function(require,module,exports){
'use strict';

module.exports = {
  isString: function(arg) {
    return typeof(arg) === 'string';
  },
  isObject: function(arg) {
    return typeof(arg) === 'object' && arg !== null;
  },
  isNull: function(arg) {
    return arg === null;
  },
  isNullOrUndefined: function(arg) {
    return arg == null;
  }
};

},{}],83:[function(require,module,exports){
(function (global){

/**
 * Module exports.
 */

module.exports = deprecate;

/**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */

function deprecate (fn, msg) {
  if (config('noDeprecation')) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (config('throwDeprecation')) {
        throw new Error(msg);
      } else if (config('traceDeprecation')) {
        console.trace(msg);
      } else {
        console.warn(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
}

/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */

function config (name) {
  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
  try {
    if (!global.localStorage) return false;
  } catch (_) {
    return false;
  }
  var val = global.localStorage[name];
  if (null == val) return false;
  return String(val).toLowerCase() === 'true';
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],84:[function(require,module,exports){
arguments[4][28][0].apply(exports,arguments)
},{"dup":28}],85:[function(require,module,exports){
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}
},{}],86:[function(require,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = require('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = require('inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./support/isBuffer":85,"_process":68,"inherits":84}],87:[function(require,module,exports){
'use strict';

// MODULES //

var isString = require( 'validate.io-string-primitive' );
var isNonNegativeInteger = require( 'validate.io-nonnegative-integer' );
var ceil = require( 'math-ceil' );
var repeat = require( 'utils-repeat-string' );


// CONSTANTS //

var MAX_SAFE_INTEGER = 9007199254740991; // 2**53 - 1


// LEFT PAD //

/**
* FUNCTION: lpad( str, len[, pad] )
*	Left pads a string such that the padded string has a length of at least `len`.
*
* @param {String} str - string to pad
* @param {Number} len - minimum string length
* @param {String} [pad=' '] - string used to pad
* @returns {String} padded string
*/
function lpad( str, len, pad ) {
	var n;
	var p;
	if ( !isString( str ) ) {
		throw new TypeError( 'invalid input argument. First argument must be a string. Value: `' + str + '`.' );
	}
	if ( !isNonNegativeInteger( len ) ) {
		throw new TypeError( 'invalid input argument. Second argument must be a nonnegative integer. Value: `' + len + '`.' );
	}
	if ( arguments.length > 2 ) {
		p = pad;
		if ( !isString( p ) ) {
			throw new TypeError( 'invalid input argument. Third argument must be a string. Value: `' + p + '`.' );
		}
		if ( p.length === 0 ) {
			throw new RangeError( 'invalid input argument. Pad string must not be an empty string.' );
		}
	} else {
		p = ' ';
	}
	if ( len > MAX_SAFE_INTEGER ) {
		throw new RangeError( 'invalid input argument. Output string length exceeds maximum allowed string length.' );
	}
	n = ( len - str.length ) / p.length;
	if ( n <= 0 ) {
		return str;
	}
	n = ceil( n );
	return repeat( p, n ) + str;
} // end FUNCTION lpad()


// EXPORTS //

module.exports = lpad;

},{"math-ceil":41,"utils-repeat-string":88,"validate.io-nonnegative-integer":91,"validate.io-string-primitive":93}],88:[function(require,module,exports){
'use strict';

// MODULES //

var isString = require( 'validate.io-string-primitive' );
var isNonNegativeInteger = require( 'validate.io-nonnegative-integer' );


// NOTES //

/**
* The algorithmic trick used in the implementation is to treat string concatenation the same as binary addition (i.e., any natural number (nonnegative integer) can be expressed as a sum of powers of two).
*
* For example,
*
*  n = 10 => 1010 => 2^3 + 2^0 + 2^1 + 2^0
*
* We can produce a 10-repeat string by "adding" the results of a 8-repeat string and a 2-repeat string.
*
* The implementation is then as follows:
*  : Let `s` be the string to be repeated and `o` be an output string.
*  0) Initialize an output string `o`.
*  1) Check the least significant bit to determine if the current `s` string should be "added" to the output "total".
*     - if the bit is a one, add
*     - otherwise, move on
*  2) Double the string `s` by adding `s` to `s`.
*  3) Right-shift the bits of `n`.
*  4) Check if we have shifted off all bits.
*     - if yes, done.
*     - otherwise, move on
*  5) Repeat 1-4.
*
* The result is that, as the string is repeated, we continually check to see if the doubled string is one which we want to add to our "total".
*
* The algorithm runs in O(log_2(n)) compared to O(n).
*/


// CONSTANTS //

var MAX_SAFE_INTEGER = 9007199254740991; // 2**53 - 1


// REPEAT //

/**
* FUNCTION: repeat( str, n )
*	Repeats a string a specified number of times and returns the concatenated result.
*
* @param {String} str - string to repeat
* @param {Number} n - number of times to repeat the string
* @returns {String}
*/
function repeat( str, n ) {
	var rpt;
	var cnt;
	if ( !isString( str ) ) {
		throw new TypeError( 'invalid input argument. First argument must be a string. Value: `' + str + '`.' );
	}
	if ( !isNonNegativeInteger( n ) ) {
		throw new TypeError( 'invalid input argument. Second argument must be a nonnegative integer. Value: `' + n + '`.' );
	}
	if ( str.length === 0 || n === 0 ) {
		return '';
	}
	// Check that output string will not exceed the maximum string length:
	if ( str.length * n > MAX_SAFE_INTEGER ) {
		throw new RangeError( 'invalid input argument. Output string length exceeds maximum allowed string length.' );
	}
	rpt = '';
	cnt = n;
	for( ; ; ) {
		// If the count is odd, append the current concatenated string:
		if ( (cnt&1) === 1 ) {
			rpt += str;
		}
		// Right-shift the bits:
		cnt >>>= 1;
		if ( cnt === 0 ) {
			break;
		}
		// Double the string:
		str += str;
	}
	return rpt;
} // end FUNCTION repeat()


// EXPORTS //

module.exports = repeat;

},{"validate.io-nonnegative-integer":91,"validate.io-string-primitive":93}],89:[function(require,module,exports){
'use strict';

// MODULES //

var isString = require( 'validate.io-string-primitive' );
var isNonNegativeInteger = require( 'validate.io-nonnegative-integer' );
var ceil = require( 'math-ceil' );
var repeat = require( 'utils-repeat-string' );


// CONSTANTS //

var MAX_SAFE_INTEGER = 9007199254740991; // 2**53 - 1


// RIGHT PAD //

/**
* FUNCTION: rpad( str, len[, pad] )
*	Right pads a string such that the padded string has a length of at least `len`.
*
* @param {String} str - string to pad
* @param {Number} len - minimum string length
* @param {String} [pad=' '] - string used to pad
* @returns {String} padded string
*/
function rpad( str, len, pad ) {
	var n;
	var p;
	if ( !isString( str ) ) {
		throw new TypeError( 'invalid input argument. First argument must be a string. Value: `' + str + '`.' );
	}
	if ( !isNonNegativeInteger( len ) ) {
		throw new TypeError( 'invalid input argument. Second argument must be a nonnegative integer. Value: `' + len + '`.' );
	}
	if ( arguments.length > 2 ) {
		p = pad;
		if ( !isString( p ) ) {
			throw new TypeError( 'invalid input argument. Third argument must be a string. Value: `' + p + '`.' );
		}
		if ( p.length === 0 ) {
			throw new RangeError( 'invalid input argument. Pad string must not be an empty string.' );
		}
	} else {
		p = ' ';
	}
	if ( len > MAX_SAFE_INTEGER ) {
		throw new RangeError( 'invalid input argument. Output string length exceeds maximum allowed string length.' );
	}
	n = ( len - str.length ) / p.length;
	if ( n <= 0 ) {
		return str;
	}
	n = ceil( n );
	return str + repeat( p, n );
} // end FUNCTION rpad()


// EXPORTS //

module.exports = rpad;

},{"math-ceil":41,"utils-repeat-string":88,"validate.io-nonnegative-integer":91,"validate.io-string-primitive":93}],90:[function(require,module,exports){
/**
*
*	VALIDATE: integer
*
*
*	DESCRIPTION:
*		- Validates if a value is an integer.
*
*
*	NOTES:
*		[1]
*
*
*	TODO:
*		[1]
*
*
*	LICENSE:
*		MIT
*
*	Copyright (c) 2014. Athan Reines.
*
*
*	AUTHOR:
*		Athan Reines. kgryte@gmail.com. 2014.
*
*/

'use strict';

// MODULES //

var isNumber = require( 'validate.io-number' );


// ISINTEGER //

/**
* FUNCTION: isInteger( value )
*	Validates if a value is an integer.
*
* @param {Number} value - value to be validated
* @returns {Boolean} boolean indicating whether value is an integer
*/
function isInteger( value ) {
	return isNumber( value ) && value%1 === 0;
} // end FUNCTION isInteger()


// EXPORTS //

module.exports = isInteger;

},{"validate.io-number":92}],91:[function(require,module,exports){
/**
*
*	VALIDATE: nonnegative-integer
*
*
*	DESCRIPTION:
*		- Validates if a value is a nonnegative integer.
*
*
*	NOTES:
*		[1]
*
*
*	TODO:
*		[1]
*
*
*	LICENSE:
*		MIT
*
*	Copyright (c) 2015. Athan Reines.
*
*
*	AUTHOR:
*		Athan Reines. kgryte@gmail.com. 2015.
*
*/

'use strict';

// MODULES //

var isInteger = require( 'validate.io-integer' );


// IS NONNEGATIVE INTEGER //

/**
* FUNCTION: isNonNegativeInteger( value )
*	Validates if a value is a nonnegative integer.
*
* @param {*} value - value to be validated
* @returns {Boolean} boolean indicating if a value is a nonnegative integer
*/
function isNonNegativeInteger( value ) {
	return isInteger( value ) && value >= 0;
} // end FUNCTION isNonNegativeInteger()


// EXPORTS //

module.exports = isNonNegativeInteger;

},{"validate.io-integer":90}],92:[function(require,module,exports){
/**
*
*	VALIDATE: number
*
*
*	DESCRIPTION:
*		- Validates if a value is a number.
*
*
*	NOTES:
*		[1]
*
*
*	TODO:
*		[1]
*
*
*	LICENSE:
*		MIT
*
*	Copyright (c) 2014. Athan Reines.
*
*
*	AUTHOR:
*		Athan Reines. kgryte@gmail.com. 2014.
*
*/

'use strict';

/**
* FUNCTION: isNumber( value )
*	Validates if a value is a number.
*
* @param {*} value - value to be validated
* @returns {Boolean} boolean indicating whether value is a number
*/
function isNumber( value ) {
	return ( typeof value === 'number' || Object.prototype.toString.call( value ) === '[object Number]' ) && value.valueOf() === value.valueOf();
} // end FUNCTION isNumber()


// EXPORTS //

module.exports = isNumber;

},{}],93:[function(require,module,exports){
'use strict';

/**
* Tests if a value is a string primitive.
*
* @param {*} value - value to test
* @returns {Boolean} boolean indicating if a value is a string primitive
*/
function isString( value ) {
	return typeof value === 'string';
} // end FUNCTION isString()


// EXPORTS //

module.exports = isString;

},{}],94:[function(require,module,exports){
module.exports={
  "name": "ami.js",
  "version": "0.0.16",
  "main": "lib/ami.js",
  "keywords": [
    "ami",
    "ami.js",
    "three.js",
    "webgl",
    "dicom",
    "nifti",
    "awesome",
    "medical",
    "imaging",
    "xtk",
    "nrrd",
    "vtk",
    "stl",
    "trk"
  ],
  "author": {
    "name": "Nicolas Rannou",
    "email": "nicolas@eunate.ch",
    "url": "https://eunate.ch"
  },
  "license": "Apache-2.0",
  "repository": {
    "type": "git",
    "url": "https://fnndsc.github.io/ami"
  },
  "config": {
    "threeVersion": "86",
    "amiCDN": "https://cdnjs.cloudflare.com/ajax/libs/ami.js/",
    "gaKey": "UA-39303022-3",
    "transforms": "-t [babelify --presets [ es2015 ] ]"
  },
  "dependencies": {
    "dicom-parser": "1.7.3",
    "image-JPEG2000": "OHIF/image-JPEG2000#master",
    "jpeg-lossless-decoder-js": "1.2.3",
    "math-float32-to-binary-string": "^1.0.0",
    "nifti-reader-js": "v0.5.3",
    "nrrd-js": "^0.2.1",
    "pako": "1.0.1"
  },
  "scripts": {
    "dist:prepare": "node ./scripts/$npm_package_config_mode.js --dist",
    "dist:watchAmi": "watchify -d src/ami $npm_package_config_transforms --standalone AMI -o dist/build/ami.js -v",
    "dist:watch": "watchify $npm_package_config_target -d $npm_package_config_transforms -o dist/$npm_package_config_target -v",
    "dist": "npm run dist:prepare --ami.js:mode=$npm_package_config_mode && (live-server dist --open=$npm_package_config_open & npm run dist:watch --ami.js:target=$npm_package_config_target)",
    "example": "npm run clean && node ./scripts/router.js examples ",
    "lesson": "npm run clean && mkdir dist/build && touch dist/build/ami.js && node ./scripts/router.js lessons ",
    "demo": "node ./scripts/lessons.js --demo",
    "lint": "eslint **/*.js --quiet",
    "build:examples": "npm run dist:prepare --ami.js:mode=examples && find examples -name '*.js' -print0 | xargs -0 -n1 -I{} bash -c \"echo Building {}; browserify {} -d -v $npm_package_config_transforms > dist/{} \"",
    "build:ami": "browserify src/ami.js -d -v $npm_package_config_transforms --standalone AMI > build/ami.js && uglifyjs build/ami.js -o build/ami.min.js",
    "build": "npm run clean && cp index.html dist/index.html && npm run build:examples && npm run doc",
    "build-cjs": "rimraf lib && cross-env BABEL_ENV=cjs babel ./src -d lib",
    "clean": "rimraf -rf dist/*",
    "test": "karma start",
    "doc": "jsdoc -p -r -R README.md -c jsdoc.conf -d dist/doc src",
    "ami": "npm run lint && npm run demo && npm run build:ami && npm run test",
    "deploy": "npm run build && gh-pages -d dist"
  },
  "devDependencies": {
    "babel-cli": "latest",
    "babel-plugin-add-module-exports": "^0.2.1",
    "babel-polyfill": "^6.13.0",
    "babel-preset-es2015": "^6.13.2",
    "babelify": "7.3.0",
    "browserify": "^13.1.0",
    "cross-env": "^3.2.3",
    "eslint": "latest",
    "eslint-config-google": "latest",
    "gh-pages": "latest",
    "glslify": "5.1.0",
    "jasmine-core": "latest",
    "jsdoc": "jsdoc3/jsdoc#master",
    "karma": "latest",
    "karma-browserify": "latest",
    "karma-jasmine": "latest",
    "karma-phantomjs-launcher": "1.0.4",
    "karma-sinon": "^1.0.5",
    "karma-spec-reporter": "latest",
    "live-server": "^1.1.0",
    "phantomjs-prebuilt": "2.1.14",
    "rimraf": "^2.6.1",
    "shelljs": "latest",
    "sinon": "^2.0.0",
    "uglify-js": "^2.7.3",
    "watchify": "3.7.0"
  },
  "engines": {
    "node": ">=6.9.0"
  },
  "browserify": {
    "transform": [
      "babelify"
    ]
  }
}

},{}],95:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _cameras = require('./cameras/cameras');

var _cameras2 = _interopRequireDefault(_cameras);

var _controls = require('./controls/controls');

var _controls2 = _interopRequireDefault(_controls);

var _core = require('./core/core');

var _core2 = _interopRequireDefault(_core);

var _geometries = require('./geometries/geometries');

var _geometries2 = _interopRequireDefault(_geometries);

var _helpers = require('./helpers/helpers');

var _helpers2 = _interopRequireDefault(_helpers);

var _loaders = require('./loaders/loaders');

var _loaders2 = _interopRequireDefault(_loaders);

var _models = require('./models/models');

var _models2 = _interopRequireDefault(_models);

var _parsers = require('./parsers/parsers');

var _parsers2 = _interopRequireDefault(_parsers);

var _shaders = require('./shaders/shaders');

var _shaders2 = _interopRequireDefault(_shaders);

var _widgets = require('./widgets/widgets');

var _widgets2 = _interopRequireDefault(_widgets);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var pckg = require('../package.json');

exports.default = {
  Cameras: _cameras2.default,
  Controls: _controls2.default,
  Core: _core2.default,
  Geometries: _geometries2.default,
  Helpers: _helpers2.default,
  Loaders: _loaders2.default,
  Models: _models2.default,
  Parsers: _parsers2.default,
  Shaders: _shaders2.default,
  Widgets: _widgets2.default
};

window.console.log('AMI ' + pckg.version + ' ( ThreeJS ' + pckg.config.threeVersion + ')');

},{"../package.json":94,"./cameras/cameras":96,"./controls/controls":98,"./core/core":103,"./geometries/geometries":107,"./helpers/helpers":112,"./loaders/loaders":128,"./models/models":132,"./parsers/parsers":137,"./shaders/shaders":155,"./widgets/widgets":169}],96:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _cameras = require('./cameras.orthographic');

var _cameras2 = _interopRequireDefault(_cameras);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

/**
 * @module cameras
 */
exports.default = {
  Orthographic: _cameras2.default
};

},{"./cameras.orthographic":97}],97:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

var _core = require('../core/core.intersections');

var _core2 = _interopRequireDefault(_core);

var _core3 = require('../core/core.validators');

var _core4 = _interopRequireDefault(_core3);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

/**
 * Orthographic camera from THREE.JS with some extra convenience
 * functionalities.
 *
 * @example
 * //
 * //
 *
 * @module cameras/orthographic
 */
var CamerasOrthographic = function (_THREE$OrthographicCa) {
  _inherits(CamerasOrthographic, _THREE$OrthographicCa);

  function CamerasOrthographic(left, right, top, bottom, near, far) {
    _classCallCheck(this, CamerasOrthographic);

    var _this = _possibleConstructorReturn(this, (CamerasOrthographic.__proto__ || Object.getPrototypeOf(CamerasOrthographic)).call(this, left, right, top, bottom, near, far));

    _this._front = null;
    _this._back = null;

    _this._directions = [new THREE.Vector3(1, 0, 0), new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, 0, 1)];

    _this._directionsLabel = ['A', 'P', // TOP/BOTTOM
    'L', 'R', // LEFT/RIGHT
    'I', 'S'];

    _this._orientation = 'default';
    _this._convention = 'radio';
    _this._stackOrientation = 0;

    _this._right = null;
    _this._up = null;
    _this._direction = null;

    _this._controls = null;
    _this._box = null;
    _this._canvas = {
      width: null,
      height: null
    };

    _this._fromFront = true;
    _this._angle = 0;
    return _this;
  }

  /**
   * Initialize orthographic camera variables
   */

  _createClass(CamerasOrthographic, [{
    key: 'init',
    value: function init(xCosine, yCosine, zCosine, controls, box, canvas) {
      // DEPRECATED
      console.warn('cameras.orthographic.init(...) is deprecated.\n      Use .cosines, .controls, .box and .canvas instead.');

      //
      if (!(_core4.default.vector3(xCosine) && _core4.default.vector3(yCosine) && _core4.default.vector3(zCosine) && _core4.default.box(box) && controls)) {
        window.console.log('Invalid input provided.');

        return false;
      }

      this._right = xCosine;
      this._up = this._adjustTopDirection(xCosine, yCosine);
      this._direction = new THREE.Vector3().crossVectors(this._right, this._up);
      this._controls = controls;
      this._box = box;
      this._canvas = canvas;

      var ray = {
        position: this._box.center,
        direction: this._direction
      };

      var intersections = this._orderIntersections(_core2.default.rayBox(ray, this._box), this._direction);
      this._front = intersections[0];
      this._back = intersections[1];

      // set default values
      this.up.set(this._up.x, this._up.y, this._up.z);
      this._updateCanvas();
      this._updatePositionAndTarget(this._front, this._back);
      this._updateMatrices();
      this._updateDirections();
    }
  }, {
    key: 'update',
    value: function update() {
      // http://www.grahamwideman.com/gw/brain/orientation/orientterms.htm
      // do magics depending on orientation and convention
      // also needs a default mode

      if (this._orientation === 'default') {
        switch (this._getMaxIndex(this._directions[2])) {

          case 0:
            this._orientation = 'sagittal';
            break;

          case 1:
            this._orientation = 'coronal';
            break;

          case 2:
            this._orientation = 'axial';
            break;

          default:
            this._orientation = 'free';
            break;
        }
      }

      if (this._orientation === 'free') {
        this._right = this._directions[0];
        this._up = this._directions[1];
        this._direction = this._directions[2];
      } else {
        var leftIndex = this.leftDirection();
        var leftDirection = this._directions[leftIndex];
        var posteriorIndex = this.posteriorDirection();
        var posteriorDirection = this._directions[posteriorIndex];
        var superiorIndex = this.superiorDirection();
        var superiorDirection = this._directions[superiorIndex];

        if (this._convention === 'radio') {
          switch (this._orientation) {

            case 'axial':
              // up vector is 'anterior'
              if (posteriorDirection.y > 0) {
                posteriorDirection.negate();
              }

              // looking towards superior
              if (superiorDirection.z < 0) {
                superiorDirection.negate();
              }

              //
              this._right = leftDirection; // does not matter right/left
              this._up = posteriorDirection;
              this._direction = superiorDirection;
              break;

            case 'coronal':
              // up vector is 'superior'
              if (superiorDirection.z < 0) {
                superiorDirection.negate();
              }

              // looking towards posterior
              if (posteriorDirection.y < 0) {
                posteriorDirection.negate();
              }

              //
              this._right = leftDirection; // does not matter right/left
              this._up = superiorDirection;
              this._direction = posteriorDirection;
              break;

            case 'sagittal':
              // up vector is 'superior'
              if (superiorDirection.z < 0) {
                superiorDirection.negate();
              }

              // looking towards right
              if (leftDirection.x > 0) {
                leftDirection.negate();
              }

              //
              this._right = posteriorDirection; // does not matter right/left
              this._up = superiorDirection;
              this._direction = leftDirection;

              break;

            default:
              console.warn('"' + this._orientation + '" orientation is not valid.\n                (choices: axial, coronal, sagittal)');
              break;

          }
        } else if (this._convention === 'neuro') {
          switch (this._orientation) {

            case 'axial':
              // up vector is 'anterior'
              if (posteriorDirection.y > 0) {
                posteriorDirection.negate();
              }

              // looking towards inferior
              if (superiorDirection.z > 0) {
                superiorDirection.negate();
              }

              //
              this._right = leftDirection; // does not matter right/left
              this._up = posteriorDirection;
              this._direction = superiorDirection;
              break;

            case 'coronal':
              // up vector is 'superior'
              if (superiorDirection.z < 0) {
                superiorDirection.negate();
              }

              // looking towards anterior
              if (posteriorDirection.y > 0) {
                posteriorDirection.negate();
              }

              //
              this._right = leftDirection; // does not matter right/left
              this._up = superiorDirection;
              this._direction = posteriorDirection;
              break;

            case 'sagittal':
              // up vector is 'superior'
              if (superiorDirection.z < 0) {
                superiorDirection.negate();
              }

              // looking towards right
              if (leftDirection.x > 0) {
                leftDirection.negate();
              }

              //
              this._right = posteriorDirection; // does not matter right/left
              this._up = superiorDirection;
              this._direction = leftDirection;

              break;

            default:
              console.warn('"' + this._orientation + '" orientation is not valid.\n                (choices: axial, coronal, sagittal)');
              break;
          }
        } else {
          console.warn(this._convention + ' is not valid (choices: radio, neuro)');
        }
      }

      // that is what determines left/right
      var ray = {
        position: this._box.center,
        direction: this._direction
      };

      var intersections = this._orderIntersections(_core2.default.rayBox(ray, this._box), this._direction);
      this._front = intersections[0];
      this._back = intersections[1];

      // set default values
      this.up.set(this._up.x, this._up.y, this._up.z);
      this._updateCanvas();
      this._updatePositionAndTarget(this._front, this._back);
      this._updateMatrices();
      this._updateDirections();
    }
  }, {
    key: 'leftDirection',
    value: function leftDirection() {
      return this._findMaxIndex(this._directions, 0);
    }
  }, {
    key: 'posteriorDirection',
    value: function posteriorDirection() {
      return this._findMaxIndex(this._directions, 1);
    }
  }, {
    key: 'superiorDirection',
    value: function superiorDirection() {
      return this._findMaxIndex(this._directions, 2);
    }

    /**
     * Invert rows in the current slice.
     * Inverting rows in 2 steps:
     *   * Flip the "up" vector
     *   * Look at the slice from the other side
     */

  }, {
    key: 'invertRows',
    value: function invertRows() {
      // flip "up" vector
      // we flip up first because invertColumns update projectio matrices
      this.up.multiplyScalar(-1);
      this.invertColumns();

      this._updateDirections();
    }

    /**
     * Invert rows in the current slice.
     * Inverting rows in 1 step:
     *   * Look at the slice from the other side
     */

  }, {
    key: 'invertColumns',
    value: function invertColumns() {
      this.center();
      // rotate 180 degrees around the up vector...
      var oppositePosition = this._oppositePosition(this.position);

      // update posistion and target
      // clone is needed because this.position is overwritten in method
      this._updatePositionAndTarget(oppositePosition, this.position.clone());
      this._updateMatrices();
      this._fromFront = !this._fromFront;

      this._angle %= 360;
      this._angle = 360 - this._angle;

      this._updateDirections();
    }

    /**
     * Center slice in the camera FOV.
     * It also updates the controllers properly.
     * We can center a camera from the front or from the back.
     */

  }, {
    key: 'center',
    value: function center() {
      if (this._fromFront) {
        this._updatePositionAndTarget(this._front, this._back);
      } else {
        this._updatePositionAndTarget(this._back, this._front);
      }

      this._updateMatrices();
      this._updateDirections();
    }

    /**
     * Pi/2 rotation around the zCosine axis.
     * Clock-wise rotation from the user point of view.
     */

  }, {
    key: 'rotate',
    value: function rotate() {
      var angle = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

      this.center();

      var computedAngle = 90;

      var clockwise = 1;
      if (!this._fromFront) {
        clockwise = -1;
      }

      if (angle === null) {
        computedAngle *= -clockwise;
        this._angle += 90;
      } else {
        computedAngle = 360 - clockwise * (angle - this._angle);
        this._angle = angle;
      }

      this._angle %= 360;

      // Rotate the up vector around the "zCosine"
      var rotation = new THREE.Matrix4().makeRotationAxis(this._direction, computedAngle * Math.PI / 180);
      this.up.applyMatrix4(rotation);

      this._updateMatrices();
      this._updateDirections();
    }

    // dimensions[0] // width
    // dimensions[1] // height
    // direction= 0 width, 1 height, 2 best
    // factor

  }, {
    key: 'fitBox',
    value: function fitBox() {
      var direction = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var factor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1.5;

      //
      // if (!(dimensions && dimensions.length >= 2)) {
      //   window.console.log('Invalid dimensions container.');
      //   window.console.log(dimensions);

      //   return false;
      // }

      //
      var zoom = 1;

      // update zoom
      switch (direction) {
        case 0:
          zoom = factor * this._computeZoom(this._canvas.width, this._right);
          break;
        case 1:
          zoom = factor * this._computeZoom(this._canvas.height, this._up);
          break;
        case 2:
          zoom = factor * Math.min(this._computeZoom(this._canvas.width, this._right), this._computeZoom(this._canvas.height, this._up));
          break;
        default:
          break;
      }

      if (!zoom) {
        return false;
      }

      this.zoom = zoom;

      this.center();
    }
  }, {
    key: '_adjustTopDirection',
    value: function _adjustTopDirection(horizontalDirection, verticalDirection) {
      var vMaxIndex = this._getMaxIndex(verticalDirection);

      // should handle vMax index === 0
      if (vMaxIndex === 2 && verticalDirection.getComponent(vMaxIndex) < 0 || vMaxIndex === 1 && verticalDirection.getComponent(vMaxIndex) > 0 || vMaxIndex === 0 && verticalDirection.getComponent(vMaxIndex) > 0) {
        verticalDirection.negate();
      }

      return verticalDirection;
    }
  }, {
    key: '_getMaxIndex',
    value: function _getMaxIndex(vector) {
      // init with X value
      var maxValue = Math.abs(vector.x);
      var index = 0;

      if (Math.abs(vector.y) > maxValue) {
        maxValue = Math.abs(vector.y);
        index = 1;
      }

      if (Math.abs(vector.z) > maxValue) {
        index = 2;
      }

      return index;
    }
  }, {
    key: '_findMaxIndex',
    value: function _findMaxIndex(directions, target) {
      // get index of the most superior direction
      var maxIndices = this._getMaxIndices(directions);

      for (var i = 0; i < maxIndices.length; i++) {
        if (maxIndices[i] === target) {
          return i;
        }
      }
    }
  }, {
    key: '_getMaxIndices',
    value: function _getMaxIndices(directions) {
      var indices = [];
      indices.push(this._getMaxIndex(directions[0]));
      indices.push(this._getMaxIndex(directions[1]));
      indices.push(this._getMaxIndex(directions[2]));

      return indices;
    }
  }, {
    key: '_orderIntersections',
    value: function _orderIntersections(intersections, direction) {
      var ordered = intersections[0].dot(direction) < intersections[1].dot(direction);

      if (!ordered) {
        return [intersections[1], intersections[0]];
      }

      return intersections;
    }
  }, {
    key: '_updateCanvas',
    value: function _updateCanvas() {
      var camFactor = 2;
      this.left = -this._canvas.width / camFactor;
      this.right = this._canvas.width / camFactor;
      this.top = this._canvas.height / camFactor;
      this.bottom = -this._canvas.height / camFactor;

      this._updateMatrices();
      this.controls.handleResize();
    }
  }, {
    key: '_oppositePosition',
    value: function _oppositePosition(position) {
      var oppositePosition = position.clone();
      // center world postion around box center
      oppositePosition.sub(this._box.center);
      // rotate
      var rotation = new THREE.Matrix4().makeRotationAxis(this.up, Math.PI);

      oppositePosition.applyMatrix4(rotation);
      // translate back to world position
      oppositePosition.add(this._box.center);
      return oppositePosition;
    }
  }, {
    key: '_computeZoom',
    value: function _computeZoom(dimension, direction) {
      if (!(dimension && dimension > 0)) {
        window.console.log('Invalid dimension provided.');
        window.console.log(dimension);
        return false;
      }

      // ray
      var ray = {
        position: this._box.center.clone(),
        direction: direction
      };

      var intersections = _core2.default.rayBox(ray, this._box);
      if (intersections.length < 2) {
        window.console.log('Can not adjust the camera ( < 2 intersections).');
        window.console.log(ray);
        window.console.log(this._box);
        return false;
      }

      return dimension / intersections[0].distanceTo(intersections[1]);
    }
  }, {
    key: '_updatePositionAndTarget',
    value: function _updatePositionAndTarget(position, target) {
      // position
      this.position.set(position.x, position.y, position.z);

      // targets
      this.lookAt(target.x, target.y, target.z);
      this._controls.target.set(target.x, target.y, target.z);
    }
  }, {
    key: '_updateMatrices',
    value: function _updateMatrices() {
      this._controls.update();
      // THEN camera
      this.updateProjectionMatrix();
      this.updateMatrixWorld();
    }
  }, {
    key: '_updateLabels',
    value: function _updateLabels() {
      this._directionsLabel = [this._vector2Label(this._up), this._vector2Label(this._up.clone().negate()), this._vector2Label(this._right), this._vector2Label(this._right.clone().negate()), this._vector2Label(this._direction), this._vector2Label(this._direction.clone().negate())];
    }
  }, {
    key: '_vector2Label',
    value: function _vector2Label(direction) {
      var index = this._getMaxIndex(direction);
      // set vector max value to 1
      var scaledDirection = direction.clone().divideScalar(Math.abs(direction.getComponent(index)));
      var delta = 0.2;
      var label = '';

      // loop through components of the vector
      for (var i = 0; i < 3; i++) {
        if (i === 0) {
          if (scaledDirection.getComponent(i) + delta >= 1) {
            label += 'L';
          } else if (scaledDirection.getComponent(i) - delta <= -1) {
            label += 'R';
          }
        }

        if (i === 1) {
          if (scaledDirection.getComponent(i) + delta >= 1) {
            label += 'P';
          } else if (scaledDirection.getComponent(i) - delta <= -1) {
            label += 'A';
          }
        }

        if (i === 2) {
          if (scaledDirection.getComponent(i) + delta >= 1) {
            label += 'S';
          } else if (scaledDirection.getComponent(i) - delta <= -1) {
            label += 'I';
          }
        }
      }

      return label;
    }
  }, {
    key: '_updateDirections',
    value: function _updateDirections() {
      // up is correct
      this._up = this.up.clone();

      // direction
      var pLocal = new THREE.Vector3(0, 0, -1);
      var pWorld = pLocal.applyMatrix4(this.matrixWorld);
      this._direction = pWorld.sub(this.position).normalize();

      // right
      this._right = new THREE.Vector3().crossVectors(this._direction, this.up);

      // update labels accordingly
      this._updateLabels();
    }
  }, {
    key: 'controls',
    set: function set(controls) {
      this._controls = controls;
    },
    get: function get() {
      return this._controls;
    }
  }, {
    key: 'box',
    set: function set(box) {
      this._box = box;
    },
    get: function get() {
      return this._box;
    }
  }, {
    key: 'canvas',
    set: function set(canvas) {
      this._canvas = canvas;
      this._updateCanvas();
    },
    get: function get() {
      return this._canvas;
    }
  }, {
    key: 'angle',
    set: function set(angle) {
      this.rotate(angle);
    },
    get: function get() {
      return this._angle;
    }
  }, {
    key: 'directions',
    set: function set(directions) {
      this._directions = directions;
    },
    get: function get() {
      return this._directions;
    }
  }, {
    key: 'convention',
    set: function set(convention) {
      this._convention = convention;
    },
    get: function get() {
      return this._convention;
    }
  }, {
    key: 'orientation',
    set: function set(orientation) {
      this._orientation = orientation;
    },
    get: function get() {
      return this._orientation;
    }
  }, {
    key: 'directionsLabel',
    set: function set(directionsLabel) {
      this._directionsLabel = directionsLabel;
    },
    get: function get() {
      return this._directionsLabel;
    }
  }, {
    key: 'stackOrientation',
    set: function set(stackOrientation) {
      this._stackOrientation = stackOrientation;

      if (this._stackOrientation === 0) {
        this._orientation = 'default';
      } else {
        var maxIndex = this._getMaxIndex(this._directions[(this._stackOrientation + 2) % 3]);

        if (maxIndex === 0) {
          this._orientation = 'sagittal';
        } else if (maxIndex === 1) {
          this._orientation = 'coronal';
        } else if (maxIndex === 2) {
          this._orientation = 'axial';
        }
      }
    },
    get: function get() {
      //
      if (this._orientation === 'default') {
        this._stackOrientation = 0;
      } else {
        var maxIndex = this._getMaxIndex(this._direction);

        if (maxIndex === this._getMaxIndex(this._directions[2])) {
          this._stackOrientation = 0;
        } else if (maxIndex === this._getMaxIndex(this._directions[0])) {
          this._stackOrientation = 1;
        } else if (maxIndex === this._getMaxIndex(this._directions[1])) {
          this._stackOrientation = 2;
        }
      }

      return this._stackOrientation;
    }
  }]);

  return CamerasOrthographic;
}(THREE.OrthographicCamera);

exports.default = CamerasOrthographic;

},{"../core/core.intersections":102,"../core/core.validators":106}],98:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _controls = require('./controls.trackball');

var _controls2 = _interopRequireDefault(_controls);

var _controls3 = require('./controls.trackballortho');

var _controls4 = _interopRequireDefault(_controls3);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

exports.default = {
  Trackball: _controls2.default,
  TrackballOrtho: _controls4.default
};

},{"./controls.trackball":99,"./controls.trackballortho":100}],99:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", {
  value: true
});

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

/**
 * Original authors from THREEJS repo
 * @author Eberhard Graether / http://egraether.com/
 * @author Mark Lundin  / http://mark-lundin.com
 * @author Simone Manini / http://daron1337.github.io
 * @author Luca Antiga  / http://lantiga.github.io
 */

var Trackball = function (_THREE$EventDispatche) {
  _inherits(Trackball, _THREE$EventDispatche);

  function Trackball(object, domElement) {
    _classCallCheck(this, Trackball);

    var _this2 = _possibleConstructorReturn(this, (Trackball.__proto__ || Object.getPrototypeOf(Trackball)).call(this));

    var _this = _this2;
    var STATE = { NONE: -1, ROTATE: 0, ZOOM: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_ZOOM: 4, TOUCH_PAN: 5, CUSTOM: 99 };

    _this2.object = object;
    _this2.domElement = domElement !== undefined ? domElement : document;

    // API

    _this2.enabled = true;

    _this2.screen = { left: 0, top: 0, width: 0, height: 0 };

    _this2.rotateSpeed = 1.0;
    _this2.zoomSpeed = 1.2;
    _this2.panSpeed = 0.3;

    _this2.noRotate = false;
    _this2.noZoom = false;
    _this2.noPan = false;
    _this2.noCustom = false;

    _this2.forceState = -1;

    _this2.staticMoving = false;
    _this2.dynamicDampingFactor = 0.2;

    _this2.minDistance = 0;
    _this2.maxDistance = Infinity;

    _this2.keys = [65 /* A*/, 83 /* S*/, 68];

    // internals

    _this2.target = new THREE.Vector3();

    var EPS = 0.000001;

    var lastPosition = new THREE.Vector3();

    var _state = STATE.NONE,
        _prevState = STATE.NONE,
        _eye = new THREE.Vector3(),
        _movePrev = new THREE.Vector2(),
        _moveCurr = new THREE.Vector2(),
        _lastAxis = new THREE.Vector3(),
        _lastAngle = 0,
        _zoomStart = new THREE.Vector2(),
        _zoomEnd = new THREE.Vector2(),
        _touchZoomDistanceStart = 0,
        _touchZoomDistanceEnd = 0,
        _panStart = new THREE.Vector2(),
        _panEnd = new THREE.Vector2(),
        _customStart = new THREE.Vector2(),
        _customEnd = new THREE.Vector2();

    // for reset

    _this2.target0 = _this2.target.clone();
    _this2.position0 = _this2.object.position.clone();
    _this2.up0 = _this2.object.up.clone();

    // events

    var changeEvent = { type: 'change' };
    var startEvent = { type: 'start' };
    var endEvent = { type: 'end' };

    // methods

    _this2.handleResize = function () {
      if (this.domElement === document) {
        this.screen.left = 0;
        this.screen.top = 0;
        this.screen.width = window.innerWidth;
        this.screen.height = window.innerHeight;
      } else {
        var box = this.domElement.getBoundingClientRect();
        // adjustments come from similar code in the jquery offset() function
        var d = this.domElement.ownerDocument.documentElement;
        this.screen.left = box.left + window.pageXOffset - d.clientLeft;
        this.screen.top = box.top + window.pageYOffset - d.clientTop;
        this.screen.width = box.width;
        this.screen.height = box.height;
      }
    };

    _this2.handleEvent = function (event) {
      if (typeof this[event.type] == 'function') {
        this[event.type](event);
      }
    };

    var getMouseOnScreen = function () {
      var vector = new THREE.Vector2();

      return function (pageX, pageY) {
        vector.set((pageX - _this.screen.left) / _this.screen.width, (pageY - _this.screen.top) / _this.screen.height);

        return vector;
      };
    }();

    var getMouseOnCircle = function () {
      var vector = new THREE.Vector2();

      return function (pageX, pageY) {
        vector.set((pageX - _this.screen.width * 0.5 - _this.screen.left) / (_this.screen.width * 0.5), (_this.screen.height + 2 * (_this.screen.top - pageY)) / _this.screen.width);

        return vector;
      };
    }();

    _this2.rotateCamera = function () {
      var axis = new THREE.Vector3(),
          quaternion = new THREE.Quaternion(),
          eyeDirection = new THREE.Vector3(),
          objectUpDirection = new THREE.Vector3(),
          objectSidewaysDirection = new THREE.Vector3(),
          moveDirection = new THREE.Vector3(),
          angle = void 0;

      return function () {
        moveDirection.set(_moveCurr.x - _movePrev.x, _moveCurr.y - _movePrev.y, 0);
        angle = moveDirection.length();

        if (angle) {
          _eye.copy(_this.object.position).sub(_this.target);

          eyeDirection.copy(_eye).normalize();
          objectUpDirection.copy(_this.object.up).normalize();
          objectSidewaysDirection.crossVectors(objectUpDirection, eyeDirection).normalize();

          objectUpDirection.setLength(_moveCurr.y - _movePrev.y);
          objectSidewaysDirection.setLength(_moveCurr.x - _movePrev.x);

          moveDirection.copy(objectUpDirection.add(objectSidewaysDirection));

          axis.crossVectors(moveDirection, _eye).normalize();

          angle *= _this.rotateSpeed;
          quaternion.setFromAxisAngle(axis, angle);

          _eye.applyQuaternion(quaternion);
          _this.object.up.applyQuaternion(quaternion);

          _lastAxis.copy(axis);
          _lastAngle = angle;
        } else if (!_this.staticMoving && _lastAngle) {
          _lastAngle *= Math.sqrt(1.0 - _this.dynamicDampingFactor);
          _eye.copy(_this.object.position).sub(_this.target);
          quaternion.setFromAxisAngle(_lastAxis, _lastAngle);
          _eye.applyQuaternion(quaternion);
          _this.object.up.applyQuaternion(quaternion);
        }

        _movePrev.copy(_moveCurr);
      };
    }();

    _this2.zoomCamera = function () {
      var factor = void 0;

      if (_state === STATE.TOUCH_ZOOM) {
        factor = _touchZoomDistanceStart / _touchZoomDistanceEnd;
        _touchZoomDistanceStart = _touchZoomDistanceEnd;
        _eye.multiplyScalar(factor);
      } else {
        factor = 1.0 + (_zoomEnd.y - _zoomStart.y) * _this.zoomSpeed;

        if (factor !== 1.0 && factor > 0.0) {
          _eye.multiplyScalar(factor);

          if (_this.staticMoving) {
            _zoomStart.copy(_zoomEnd);
          } else {
            _zoomStart.y += (_zoomEnd.y - _zoomStart.y) * this.dynamicDampingFactor;
          }
        }
      }
    };

    _this2.panCamera = function () {
      var mouseChange = new THREE.Vector2(),
          objectUp = new THREE.Vector3(),
          pan = new THREE.Vector3();

      return function () {
        mouseChange.copy(_panEnd).sub(_panStart);

        if (mouseChange.lengthSq()) {
          mouseChange.multiplyScalar(_eye.length() * _this.panSpeed);

          pan.copy(_eye).cross(_this.object.up).setLength(mouseChange.x);
          pan.add(objectUp.copy(_this.object.up).setLength(mouseChange.y));

          _this.object.position.add(pan);
          _this.target.add(pan);

          if (_this.staticMoving) {
            _panStart.copy(_panEnd);
          } else {
            _panStart.add(mouseChange.subVectors(_panEnd, _panStart).multiplyScalar(_this.dynamicDampingFactor));
          }
        }
      };
    }();

    _this2.checkDistances = function () {
      if (!_this.noZoom || !_this.noPan) {
        if (_eye.lengthSq() > _this.maxDistance * _this.maxDistance) {
          _this.object.position.addVectors(_this.target, _eye.setLength(_this.maxDistance));
        }

        if (_eye.lengthSq() < _this.minDistance * _this.minDistance) {
          _this.object.position.addVectors(_this.target, _eye.setLength(_this.minDistance));
        }
      }
    };

    _this2.update = function () {
      _eye.subVectors(_this.object.position, _this.target);

      if (!_this.noRotate) {
        _this.rotateCamera();
      }

      if (!_this.noZoom) {
        _this.zoomCamera();
      }

      if (!_this.noPan) {
        _this.panCamera();
      }

      if (!_this.noCustom) {
        _this.custom(_customStart, _customEnd);
      }

      _this.object.position.addVectors(_this.target, _eye);

      _this.checkDistances();

      _this.object.lookAt(_this.target);

      if (lastPosition.distanceToSquared(_this.object.position) > EPS) {
        _this.dispatchEvent(changeEvent);

        lastPosition.copy(_this.object.position);
      }
    };

    _this2.reset = function () {
      _state = STATE.NONE;
      _prevState = STATE.NONE;

      _this.target.copy(_this.target0);
      _this.object.position.copy(_this.position0);
      _this.object.up.copy(_this.up0);

      _eye.subVectors(_this.object.position, _this.target);

      _this.object.lookAt(_this.target);

      _this.dispatchEvent(changeEvent);

      lastPosition.copy(_this.object.position);
    };

    _this2.setState = function (targetState) {
      _this.forceState = targetState;
      _prevState = targetState;
      _state = targetState;
    };

    _this2.custom = function (customStart, customEnd) {};

    // listeners

    function keydown(event) {
      if (_this.enabled === false) return;

      window.removeEventListener('keydown', keydown);

      _prevState = _state;

      if (_state !== STATE.NONE) {
        return;
      } else if (event.keyCode === _this.keys[STATE.ROTATE] && !_this.noRotate) {
        _state = STATE.ROTATE;
      } else if (event.keyCode === _this.keys[STATE.ZOOM] && !_this.noZoom) {
        _state = STATE.ZOOM;
      } else if (event.keyCode === _this.keys[STATE.PAN] && !_this.noPan) {
        _state = STATE.PAN;
      }
    }

    function keyup(event) {
      if (_this.enabled === false) return;

      _state = _prevState;

      window.addEventListener('keydown', keydown, false);
    }

    function mousedown(event) {
      if (_this.enabled === false) return;

      event.preventDefault();
      event.stopPropagation();

      if (_state === STATE.NONE) {
        _state = event.button;
      }

      if (_state === STATE.ROTATE && !_this.noRotate) {
        _moveCurr.copy(getMouseOnCircle(event.pageX, event.pageY));
        _movePrev.copy(_moveCurr);
      } else if (_state === STATE.ZOOM && !_this.noZoom) {
        _zoomStart.copy(getMouseOnScreen(event.pageX, event.pageY));
        _zoomEnd.copy(_zoomStart);
      } else if (_state === STATE.PAN && !_this.noPan) {
        _panStart.copy(getMouseOnScreen(event.pageX, event.pageY));
        _panEnd.copy(_panStart);
      } else if (_state === STATE.CUSTOM && !_this.noCustom) {
        _customStart.copy(getMouseOnScreen(event.pageX, event.pageY));
        _customEnd.copy(_panStart);
      }

      document.addEventListener('mousemove', mousemove, false);
      document.addEventListener('mouseup', mouseup, false);

      _this.dispatchEvent(startEvent);
    }

    function mousemove(event) {
      if (_this.enabled === false) return;

      event.preventDefault();
      event.stopPropagation();

      if (_state === STATE.ROTATE && !_this.noRotate) {
        _movePrev.copy(_moveCurr);
        _moveCurr.copy(getMouseOnCircle(event.pageX, event.pageY));
      } else if (_state === STATE.ZOOM && !_this.noZoom) {
        _zoomEnd.copy(getMouseOnScreen(event.pageX, event.pageY));
      } else if (_state === STATE.PAN && !_this.noPan) {
        _panEnd.copy(getMouseOnScreen(event.pageX, event.pageY));
      } else if (_state === STATE.CUSTOM && !_this.noCustom) {
        _customEnd.copy(getMouseOnScreen(event.pageX, event.pageY));
      }
    }

    function mouseup(event) {
      if (_this.enabled === false) return;

      event.preventDefault();
      event.stopPropagation();

      if (_this.forceState === -1) {
        _state = STATE.NONE;
      }

      document.removeEventListener('mousemove', mousemove);
      document.removeEventListener('mouseup', mouseup);
      _this.dispatchEvent(endEvent);
    }

    function mousewheel(event) {
      if (_this.enabled === false) return;

      event.preventDefault();
      event.stopPropagation();

      var delta = 0;

      if (event.wheelDelta) {
        // WebKit / Opera / Explorer 9

        delta = event.wheelDelta / 40;
      } else if (event.detail) {
        // Firefox

        delta = -event.detail / 3;
      }

      if (_state !== STATE.CUSTOM) {
        _zoomStart.y += delta * 0.01;
      } else if (_state === STATE.CUSTOM) {
        _customStart.y += delta * 0.01;
      }

      _this.dispatchEvent(startEvent);
      _this.dispatchEvent(endEvent);
    }

    function touchstart(event) {
      if (_this.enabled === false) return;

      if (_this.forceState === -1) {
        switch (event.touches.length) {

          case 1:
            _state = STATE.TOUCH_ROTATE;
            _moveCurr.copy(getMouseOnCircle(event.touches[0].pageX, event.touches[0].pageY));
            _movePrev.copy(_moveCurr);
            break;

          case 2:
            _state = STATE.TOUCH_ZOOM;
            var dx = event.touches[0].pageX - event.touches[1].pageX;
            var dy = event.touches[0].pageY - event.touches[1].pageY;
            _touchZoomDistanceEnd = _touchZoomDistanceStart = Math.sqrt(dx * dx + dy * dy);

            var x = (event.touches[0].pageX + event.touches[1].pageX) / 2;
            var y = (event.touches[0].pageY + event.touches[1].pageY) / 2;
            _panStart.copy(getMouseOnScreen(x, y));
            _panEnd.copy(_panStart);
            break;

          default:
            _state = STATE.NONE;

        }
      } else {
        // { NONE: -1, ROTATE: 0, ZOOM: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_ZOOM_PAN: 4, CUSTOM: 99 };
        switch (_state) {

          case 0:
            // 1 or 2 fingers, smae behavior
            _state = STATE.TOUCH_ROTATE;
            _moveCurr.copy(getMouseOnCircle(event.touches[0].pageX, event.touches[0].pageY));
            _movePrev.copy(_moveCurr);
            break;

          case 1:
          case 4:
            if (event.touches.length >= 2) {
              _state = STATE.TOUCH_ZOOM;
              var dx = event.touches[0].pageX - event.touches[1].pageX;
              var dy = event.touches[0].pageY - event.touches[1].pageY;
              _touchZoomDistanceEnd = _touchZoomDistanceStart = Math.sqrt(dx * dx + dy * dy);
            } else {
              _state = STATE.ZOOM;
              _zoomStart.copy(getMouseOnScreen(event.touches[0].pageX, event.touches[0].pageY));
              _zoomEnd.copy(_zoomStart);
            }
            break;

          case 2:
          case 5:
            if (event.touches.length >= 2) {
              _state = STATE.TOUCH_PAN;
              var x = (event.touches[0].pageX + event.touches[1].pageX) / 2;
              var y = (event.touches[0].pageY + event.touches[1].pageY) / 2;
              _panStart.copy(getMouseOnScreen(x, y));
              _panEnd.copy(_panStart);
            } else {
              _state = STATE.PAN;
              _panStart.copy(getMouseOnScreen(event.touches[0].pageX, event.touches[0].pageY));
              _panEnd.copy(_panStart);
            }
            break;

          case 99:
            _state = STATE.CUSTOM;
            var x = (event.touches[0].pageX + event.touches[1].pageX) / 2;
            var y = (event.touches[0].pageY + event.touches[1].pageY) / 2;
            _customStart.copy(getMouseOnScreen(x, y));
            _customEnd.copy(_customStart);
            break;

          default:
            _state = STATE.NONE;

        }
      }

      _this.dispatchEvent(startEvent);
    }

    function touchmove(event) {
      if (_this.enabled === false) return;

      event.preventDefault();
      event.stopPropagation();

      if (_this.forceState === -1) {
        switch (event.touches.length) {

          case 1:
            _movePrev.copy(_moveCurr);
            _moveCurr.copy(getMouseOnCircle(event.touches[0].pageX, event.touches[0].pageY));
            break;

          case 2:
            var dx = event.touches[0].pageX - event.touches[1].pageX;
            var dy = event.touches[0].pageY - event.touches[1].pageY;
            _touchZoomDistanceEnd = Math.sqrt(dx * dx + dy * dy);

            var x = (event.touches[0].pageX + event.touches[1].pageX) / 2;
            var y = (event.touches[0].pageY + event.touches[1].pageY) / 2;
            _panEnd.copy(getMouseOnScreen(x, y));
            break;

          default:
            _state = STATE.NONE;
        }
      } else {
        // { NONE: -1, ROTATE: 0, ZOOM: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_ZOOM_PAN: 4, CUSTOM: 99 };
        switch (_state) {

          case 0:
            _movePrev.copy(_moveCurr);
            _moveCurr.copy(getMouseOnCircle(event.touches[0].pageX, event.touches[0].pageY));
            break;

          case 1:
            _zoomEnd.copy(getMouseOnScreen(event.touches[0].pageX, event.touches[0].pageY));
            break;

          case 2:
            _panEnd.copy(getMouseOnScreen(event.touches[0].pageX, event.touches[0].pageY));
            break;

          case 4:
            // 2 fingers!
            // TOUCH ZOOM
            var dx = event.touches[0].pageX - event.touches[1].pageX;
            var dy = event.touches[0].pageY - event.touches[1].pageY;
            _touchZoomDistanceEnd = Math.sqrt(dx * dx + dy * dy);
            break;

          case 5:
            // 2 fingers
            // TOUCH_PAN
            var x = (event.touches[0].pageX + event.touches[1].pageX) / 2;
            var y = (event.touches[0].pageY + event.touches[1].pageY) / 2;
            _panEnd.copy(getMouseOnScreen(x, y));
            break;

          case 99:
            var x = (event.touches[0].pageX + event.touches[1].pageX) / 2;
            var y = (event.touches[0].pageY + event.touches[1].pageY) / 2;
            _customEnd.copy(getMouseOnScreen(x, y));
            break;

          default:
            _state = STATE.NONE;

        }
      }
    }

    function touchend(event) {
      if (_this.enabled === false) return;

      if (_this.forceState === -1) {
        switch (event.touches.length) {

          case 1:
            _movePrev.copy(_moveCurr);
            _moveCurr.copy(getMouseOnCircle(event.touches[0].pageX, event.touches[0].pageY));
            break;

          case 2:
            _touchZoomDistanceStart = _touchZoomDistanceEnd = 0;

            var x = (event.touches[0].pageX + event.touches[1].pageX) / 2;
            var y = (event.touches[0].pageY + event.touches[1].pageY) / 2;
            _panEnd.copy(getMouseOnScreen(x, y));
            _panStart.copy(_panEnd);
            break;

        }

        _state = STATE.NONE;
      } else {
        switch (_state) {

          case 0:
            _movePrev.copy(_moveCurr);
            _moveCurr.copy(getMouseOnCircle(event.touches[0].pageX, event.touches[0].pageY));
            break;

          case 1:
          case 2:
            break;

          case 4:
            // TOUCH ZOOM
            _touchZoomDistanceStart = _touchZoomDistanceEnd = 0;
            _state = STATE.ZOOM;
            break;

          case 5:
            // TOUCH ZOOM
            if (event.touches.length >= 2) {
              var x = (event.touches[0].pageX + event.touches[1].pageX) / 2;
              var y = (event.touches[0].pageY + event.touches[1].pageY) / 2;
              _panEnd.copy(getMouseOnScreen(x, y));
              _panStart.copy(_panEnd);
            }
            _state = STATE.PAN;
            break;

          case 99:
            var x = (event.touches[0].pageX + event.touches[1].pageX) / 2;
            var y = (event.touches[0].pageY + event.touches[1].pageY) / 2;
            _customEnd.copy(getMouseOnScreen(x, y));
            _customStart.copy(_customEnd);
            break;

          default:
            _state = STATE.NONE;

        }
      }

      _this.dispatchEvent(endEvent);
    }

    _this2.domElement.addEventListener('contextmenu', function (event) {
      event.preventDefault();
    }, false);

    _this2.domElement.addEventListener('mousedown', mousedown, false);

    _this2.domElement.addEventListener('mousewheel', mousewheel, false);
    _this2.domElement.addEventListener('DOMMouseScroll', mousewheel, false); // firefox

    _this2.domElement.addEventListener('touchstart', touchstart, false);
    _this2.domElement.addEventListener('touchend', touchend, false);
    _this2.domElement.addEventListener('touchmove', touchmove, false);

    window.addEventListener('keydown', keydown, false);
    window.addEventListener('keyup', keyup, false);

    _this2.handleResize();

    // force an update at start
    _this2.update();
    return _this2;
  }

  return Trackball;
}(THREE.EventDispatcher);

exports.default = Trackball;

},{}],100:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", {
  value: true
});

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

/**
 * @author Eberhard Graether / http://egraether.com/
 * @author Mark Lundin  / http://mark-lundin.com
 * @author Patrick Fuller / http://patrick-fuller.com
 * @author Max Smolens / https://github.com/msmolens
 */

var Trackballortho = function (_THREE$EventDispatche) {
  _inherits(Trackballortho, _THREE$EventDispatche);

  function Trackballortho(object, domElement) {
    var state = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : { NONE: -1, ROTATE: 1, ZOOM: 2, PAN: 0, SCROLL: 4, TOUCH_ROTATE: 4, TOUCH_ZOOM_PAN: 5 };

    _classCallCheck(this, Trackballortho);

    var _this2 = _possibleConstructorReturn(this, (Trackballortho.__proto__ || Object.getPrototypeOf(Trackballortho)).call(this));

    var _this = _this2;
    var STATE = state;

    _this2.object = object;
    _this2.domElement = domElement !== undefined ? domElement : document;

    // API

    _this2.enabled = true;

    _this2.screen = { left: 0, top: 0, width: 0, height: 0 };

    _this2.radius = 0;

    _this2.zoomSpeed = 1.2;

    _this2.noZoom = false;
    _this2.noPan = false;

    _this2.staticMoving = false;
    _this2.dynamicDampingFactor = 0.2;

    _this2.keys = [65 /* A*/, 83 /* S*/, 68];

    // internals

    _this2.target = new THREE.Vector3();

    var EPS = 0.000001;

    var _changed = true;

    var _state = STATE.NONE,
        _prevState = STATE.NONE,
        _eye = new THREE.Vector3(),
        _zoomStart = new THREE.Vector2(),
        _zoomEnd = new THREE.Vector2(),
        _touchZoomDistanceStart = 0,
        _touchZoomDistanceEnd = 0,
        _panStart = new THREE.Vector2(),
        _panEnd = new THREE.Vector2();

    // window level fire after...

    // for reset

    _this2.target0 = _this2.target.clone();
    _this2.position0 = _this2.object.position.clone();
    _this2.up0 = _this2.object.up.clone();

    _this2.left0 = _this2.object.left;
    _this2.right0 = _this2.object.right;
    _this2.top0 = _this2.object.top;
    _this2.bottom0 = _this2.object.bottom;

    // events

    var changeEvent = { type: 'change' };
    var startEvent = { type: 'start' };
    var endEvent = { type: 'end' };

    // methods

    _this2.handleResize = function () {
      if (this.domElement === document) {
        this.screen.left = 0;
        this.screen.top = 0;
        this.screen.width = window.innerWidth;
        this.screen.height = window.innerHeight;
      } else {
        var box = this.domElement.getBoundingClientRect();
        // adjustments come from similar code in the jquery offset() function
        var d = this.domElement.ownerDocument.documentElement;
        this.screen.left = box.left + window.pageXOffset - d.clientLeft;
        this.screen.top = box.top + window.pageYOffset - d.clientTop;
        this.screen.width = box.width;
        this.screen.height = box.height;
      }

      this.radius = 0.5 * Math.min(this.screen.width, this.screen.height);

      this.left0 = this.object.left;
      this.right0 = this.object.right;
      this.top0 = this.object.top;
      this.bottom0 = this.object.bottom;
    };

    _this2.handleEvent = function (event) {
      if (typeof this[event.type] == 'function') {
        this[event.type](event);
      }
    };

    var getMouseOnScreen = function () {
      var vector = new THREE.Vector2();

      return function getMouseOnScreen(pageX, pageY) {
        vector.set((pageX - _this.screen.left) / _this.screen.width, (pageY - _this.screen.top) / _this.screen.height);

        return vector;
      };
    }();

    _this2.zoomCamera = function () {
      if (_state === STATE.TOUCH_ZOOM_PAN) {
        var factor = _touchZoomDistanceEnd / _touchZoomDistanceStart;
        _touchZoomDistanceStart = _touchZoomDistanceEnd;

        _this.object.zoom *= factor;

        _changed = true;
      } else {
        var factor = 1.0 + (_zoomEnd.y - _zoomStart.y) * _this.zoomSpeed;

        if (Math.abs(factor - 1.0) > EPS && factor > 0.0) {
          _this.object.zoom /= factor;

          if (_this.staticMoving) {
            _zoomStart.copy(_zoomEnd);
          } else {
            _zoomStart.y += (_zoomEnd.y - _zoomStart.y) * this.dynamicDampingFactor;
          }

          _changed = true;
        }
      }
    };

    _this2.panCamera = function () {
      var mouseChange = new THREE.Vector2(),
          objectUp = new THREE.Vector3(),
          pan = new THREE.Vector3();

      return function panCamera() {
        mouseChange.copy(_panEnd).sub(_panStart);

        if (mouseChange.lengthSq()) {
          // Scale movement to keep clicked/dragged position under cursor
          var scale_x = (_this.object.right - _this.object.left) / _this.object.zoom;
          var scale_y = (_this.object.top - _this.object.bottom) / _this.object.zoom;
          mouseChange.x *= scale_x;
          mouseChange.y *= scale_y;

          pan.copy(_eye).cross(_this.object.up).setLength(mouseChange.x);
          pan.add(objectUp.copy(_this.object.up).setLength(mouseChange.y));

          _this.object.position.add(pan);
          _this.target.add(pan);

          if (_this.staticMoving) {
            _panStart.copy(_panEnd);
          } else {
            _panStart.add(mouseChange.subVectors(_panEnd, _panStart).multiplyScalar(_this.dynamicDampingFactor));
          }

          _changed = true;
        }
      };
    }();

    _this2.update = function () {
      _eye.subVectors(_this.object.position, _this.target);

      if (!_this.noZoom) {
        _this.zoomCamera();

        if (_changed) {
          _this.object.updateProjectionMatrix();
        }
      }

      if (!_this.noPan) {
        _this.panCamera();
      }

      _this.object.position.addVectors(_this.target, _eye);

      _this.object.lookAt(_this.target);

      if (_changed) {
        _this.dispatchEvent(changeEvent);

        _changed = false;
      }
    };

    _this2.reset = function () {
      _state = STATE.NONE;
      _prevState = STATE.NONE;

      _this.target.copy(_this.target0);
      _this.object.position.copy(_this.position0);
      _this.object.up.copy(_this.up0);

      _eye.subVectors(_this.object.position, _this.target);

      _this.object.left = _this.left0;
      _this.object.right = _this.right0;
      _this.object.top = _this.top0;
      _this.object.bottom = _this.bottom0;

      _this.object.lookAt(_this.target);

      _this.dispatchEvent(changeEvent);

      _changed = false;
    };

    // listeners

    function keydown(event) {
      if (_this.enabled === false) return;

      window.removeEventListener('keydown', keydown);

      _prevState = _state;

      if (_state !== STATE.NONE) {
        return;
      } else if (event.keyCode === _this.keys[STATE.ROTATE] && !_this.noRotate) {
        _state = STATE.ROTATE;
      } else if (event.keyCode === _this.keys[STATE.ZOOM] && !_this.noZoom) {
        _state = STATE.ZOOM;
      } else if (event.keyCode === _this.keys[STATE.PAN] && !_this.noPan) {
        _state = STATE.PAN;
      }
    }

    function keyup(event) {
      if (_this.enabled === false) return;

      _state = _prevState;

      window.addEventListener('keydown', keydown, false);
    }

    function mousedown(event) {
      if (_this.enabled === false) return;

      event.preventDefault();
      event.stopPropagation();

      if (_state === STATE.NONE) {
        _state = event.button;
      }

      if (_state === STATE.ROTATE && !_this.noRotate) {} else if (_state === STATE.ZOOM && !_this.noZoom) {
        _zoomStart.copy(getMouseOnScreen(event.pageX, event.pageY));
        _zoomEnd.copy(_zoomStart);
      } else if (_state === STATE.PAN && !_this.noPan) {
        _panStart.copy(getMouseOnScreen(event.pageX, event.pageY));
        _panEnd.copy(_panStart);
      }

      document.addEventListener('mousemove', mousemove, false);
      document.addEventListener('mouseup', mouseup, false);

      _this.dispatchEvent(startEvent);
    }

    function mousemove(event) {
      if (_this.enabled === false) return;

      event.preventDefault();
      event.stopPropagation();

      if (_state === STATE.ROTATE && !_this.noRotate) {} else if (_state === STATE.ZOOM && !_this.noZoom) {
        _zoomEnd.copy(getMouseOnScreen(event.pageX, event.pageY));
      } else if (_state === STATE.PAN && !_this.noPan) {
        _panEnd.copy(getMouseOnScreen(event.pageX, event.pageY));
      }
    }

    function mouseup(event) {
      if (_this.enabled === false) return;

      event.preventDefault();
      event.stopPropagation();

      _state = STATE.NONE;

      document.removeEventListener('mousemove', mousemove);
      document.removeEventListener('mouseup', mouseup);
      _this.dispatchEvent(endEvent);
    }

    function mousewheel(event) {
      if (_this.enabled === false) return;

      event.preventDefault();
      event.stopPropagation();

      var delta = 0;

      if (event.wheelDelta) {
        // WebKit / Opera / Explorer 9

        delta = event.wheelDelta / 40;
      } else if (event.detail) {
        // Firefox

        delta = -event.detail / 3;
      }

      // FIRE SCROLL EVENT

      _this.dispatchEvent({
        type: 'OnScroll',
        delta: delta
      });

      // _zoomStart.y += delta * 0.01;
      _this.dispatchEvent(startEvent);
      _this.dispatchEvent(endEvent);
    }

    function touchstart(event) {
      if (_this.enabled === false) return;

      switch (event.touches.length) {

        case 1:
          _state = STATE.TOUCH_ROTATE;

          break;

        case 2:
          _state = STATE.TOUCH_ZOOM_PAN;
          var dx = event.touches[0].pageX - event.touches[1].pageX;
          var dy = event.touches[0].pageY - event.touches[1].pageY;
          _touchZoomDistanceEnd = _touchZoomDistanceStart = Math.sqrt(dx * dx + dy * dy);

          var x = (event.touches[0].pageX + event.touches[1].pageX) / 2;
          var y = (event.touches[0].pageY + event.touches[1].pageY) / 2;
          _panStart.copy(getMouseOnScreen(x, y));
          _panEnd.copy(_panStart);
          break;

        default:
          _state = STATE.NONE;

      }
      _this.dispatchEvent(startEvent);
    }

    function touchmove(event) {
      if (_this.enabled === false) return;

      event.preventDefault();
      event.stopPropagation();

      switch (event.touches.length) {

        case 1:

          break;

        case 2:
          var dx = event.touches[0].pageX - event.touches[1].pageX;
          var dy = event.touches[0].pageY - event.touches[1].pageY;
          _touchZoomDistanceEnd = Math.sqrt(dx * dx + dy * dy);

          var x = (event.touches[0].pageX + event.touches[1].pageX) / 2;
          var y = (event.touches[0].pageY + event.touches[1].pageY) / 2;
          _panEnd.copy(getMouseOnScreen(x, y));
          break;

        default:
          _state = STATE.NONE;

      }
    }

    function touchend(event) {
      if (_this.enabled === false) return;

      switch (event.touches.length) {

        case 1:

          break;

        case 2:
          _touchZoomDistanceStart = _touchZoomDistanceEnd = 0;

          var x = (event.touches[0].pageX + event.touches[1].pageX) / 2;
          var y = (event.touches[0].pageY + event.touches[1].pageY) / 2;
          _panEnd.copy(getMouseOnScreen(x, y));
          _panStart.copy(_panEnd);
          break;

      }

      _state = STATE.NONE;
      _this.dispatchEvent(endEvent);
    }

    function contextmenu(event) {
      event.preventDefault();
    }

    _this2.dispose = function () {
      this.domElement.removeEventListener('contextmenu', contextmenu, false);
      this.domElement.removeEventListener('mousedown', mousedown, false);
      this.domElement.removeEventListener('mousewheel', mousewheel, false);
      this.domElement.removeEventListener('MozMousePixelScroll', mousewheel, false); // firefox

      this.domElement.removeEventListener('touchstart', touchstart, false);
      this.domElement.removeEventListener('touchend', touchend, false);
      this.domElement.removeEventListener('touchmove', touchmove, false);

      document.removeEventListener('mousemove', mousemove, false);
      document.removeEventListener('mouseup', mouseup, false);

      window.removeEventListener('keydown', keydown, false);
      window.removeEventListener('keyup', keyup, false);
    };

    _this2.domElement.addEventListener('contextmenu', contextmenu, false);
    _this2.domElement.addEventListener('mousedown', mousedown, false);
    _this2.domElement.addEventListener('mousewheel', mousewheel, false);
    _this2.domElement.addEventListener('MozMousePixelScroll', mousewheel, false); // firefox

    _this2.domElement.addEventListener('touchstart', touchstart, false);
    _this2.domElement.addEventListener('touchend', touchend, false);
    _this2.domElement.addEventListener('touchmove', touchmove, false);

    window.addEventListener('keydown', keydown, false);
    window.addEventListener('keyup', keyup, false);

    _this2.handleResize();

    // force an update at start
    _this2.update();
    return _this2;
  }

  return Trackballortho;
}(THREE.EventDispatcher);

exports.default = Trackballortho;

},{}],101:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

function _toConsumableArray(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
      arr2[i] = arr[i];
    }return arr2;
  } else {
    return Array.from(arr);
  }
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

/**
 * Colors utility functions
 */
var Colors = function () {
  function Colors() {
    _classCallCheck(this, Colors);
  }

  _createClass(Colors, null, [{
    key: "cielab2XYZ",

    /**
     * Convert LAB to XYZ
     * http://www.easyrgb.com/index.php?X=MATH&H=08#text8
     *
     * @param {*} l
     * @param {*} a
     * @param {*} b
     *
     * @return {*}
     */
    value: function cielab2XYZ(l, a, b) {
      var refX = 95.047;
      var refY = 100.00;
      var refZ = 108.883;

      var y = (l + 16) / 116;
      var x = a / 500 + y;
      var z = y - b / 200;

      if (Math.pow(y, 3) > 0.008856) {
        y = Math.pow(y, 3);
      } else {
        y = (y - 16 / 116) / 7.787;
      }

      if (Math.pow(x, 3) > 0.008856) {
        x = Math.pow(x, 3);
      } else {
        x = (x - 16 / 116) / 7.787;
      }

      if (Math.pow(z, 3) > 0.008856) {
        z = Math.pow(z, 3);
      } else {
        z = (z - 16 / 116) / 7.787;
      }

      return [refX * x, refY * y, refZ * z];
    }

    /**
     * Convert XYZ to RGB space
     *
     * @param {*} x
     * @param {*} y
     * @param {*} z
     *
     * @return {*}
     */

  }, {
    key: "xyz2RGB",
    value: function xyz2RGB(x, y, z) {
      x /= 100;
      y /= 100;
      z /= 100;
      var r = x * 3.2406 + y * -1.5372 + z * -0.4986;
      var g = x * -0.9689 + y * 1.8758 + z * 0.0415;
      var b = x * 0.0557 + y * -0.2040 + z * 1.0570;

      if (r > 0.0031308) {
        r = 1.055 * Math.pow(r, 1 / 2.4) - 0.055;
      } else {
        r = 12.92 * r;
      }

      if (g > 0.0031308) {
        g = 1.055 * Math.pow(g, 1 / 2.4) - 0.055;
      } else {
        g = 12.92 * g;
      }

      if (b > 0.0031308) {
        b = 1.055 * Math.pow(b, 1 / 2.4) - 0.055;
      } else {
        b = 12.92 * b;
      }

      r = r * 255;
      g = g * 255;
      b = b * 255;

      return [r, g, b];
    }

    /**
     * Convert LAB to RGB
     *
     * @param {*} l
     * @param {*} a
     * @param {*} b
     *
     * @return {*}
     */

  }, {
    key: "cielab2RGB",
    value: function cielab2RGB() {
      var l = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 50;
      var a = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var b = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

      if (!(l >= 0 && l <= 100)) {
        return null;
      }

      var xyz = this.cielab2XYZ(l, a, b);
      return this.xyz2RGB.apply(this, _toConsumableArray(xyz));
    }
  }]);

  return Colors;
}();

exports.default = Colors;

},{}],102:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

var _core = require('./core.utils');

var _core2 = _interopRequireDefault(_core);

var _core3 = require('./core.validators');

var _core4 = _interopRequireDefault(_core3);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

/**
 * Compute/test intersection between different objects.
 *
 * @module core/intersections
 */

var Intersections = function () {
  function Intersections() {
    _classCallCheck(this, Intersections);
  }

  _createClass(Intersections, null, [{
    key: 'aabbPlane',

    /**
     * Compute intersection between oriented bounding box and a plane.
     *
     * Returns intersection in plane's space.
     *
     * Should return at least 3 intersections. If not, the plane and the box do not
     * intersect.
     *
     * @param {Object} aabb - Axe Aligned Bounding Box representation.
     * @param {THREE.Vector3} aabb.halfDimensions - Half dimensions of the box.
     * @param {THREE.Vector3} aabb.center - Center of the box.
     * @param {THREE.Matrix4} aabb.toAABB - Transform to go from plane space to box space.
     * @param {Object} plane - Plane representation
     * @param {THREE.Vector3} plane.position - position of normal which describes the plane.
     * @param {THREE.Vector3} plane.direction - Direction of normal which describes the plane.
     *
     * @returns {Array<THREE.Vector3>} List of all intersections in plane's space.
     * @returns {boolean} false is invalid input provided.
     *
     * @example
     * //Returns array with intersection N intersections
     * let aabb = {
     *   center: new THREE.Vector3(150, 150, 150),
     *   halfDimensions: new THREE.Vector3(50, 60, 70),
     *   toAABB: new THREE.Matrix4()
     * }
     * let plane = {
     *   position: new THREE.Vector3(110, 120, 130),
     *   direction: new THREE.Vector3(1, 0, 0)
     * }
     *
     * let intersections = CoreIntersections.aabbPlane(aabb, plane);
     * // intersections ==
     * //[ { x : 110, y : 90,  z : 80 },
     * //  { x : 110, y : 210, z : 220 },
     * //  { x : 110, y : 210, z : 80 },
     * //  { x : 110, y : 90,  z : 220 } ]
     *
     * //Returns empty array with 0 intersections
     * let aabb = {
     *
     * }
     * let plane = {
     *
     * }
     *
     * let intersections = VJS.Core.Validators.matrix4(new THREE.Vector3());
     *
     * //Returns false if invalid input?
     *
     */
    value: function aabbPlane(aabb, plane) {
      //
      // obb = { halfDimensions, orientation, center, toAABB }
      // plane = { position, direction }
      //
      //
      // LOGIC:
      //
      // Test intersection of each edge of the Oriented Bounding Box with the Plane
      //
      // ALL EDGES
      //
      //      .+-------+
      //    .' |     .'|
      //   +---+---+'  |
      //   |   |   |   |
      //   |  ,+---+---+
      //   |.'     | .'
      //   +-------+'
      //
      // SPACE ORIENTATION
      //
      //       +
      //     j |
      //       |
      //       |   i
      //   k  ,+-------+
      //    .'
      //   +
      //
      //
      // 1- Move Plane position and orientation in IJK space
      // 2- Test Edges/ IJK Plane intersections
      // 3- Return intersection Edge/ IJK Plane if it touches the Oriented BBox

      var intersections = [];

      if (!(this.validateAabb(aabb) && this.validatePlane(plane))) {
        window.console.log('Invalid aabb or plane provided.');
        return false;
      }

      // invert space matrix
      var fromAABB = new THREE.Matrix4();
      fromAABB.getInverse(aabb.toAABB);

      var t1 = plane.direction.clone().applyMatrix4(aabb.toAABB);
      var t0 = new THREE.Vector3(0, 0, 0).applyMatrix4(aabb.toAABB);

      var planeAABB = this.posdir(plane.position.clone().applyMatrix4(aabb.toAABB), new THREE.Vector3(t1.x - t0.x, t1.y - t0.y, t1.z - t0.z).normalize());

      var bbox = _core2.default.bbox(aabb.center, aabb.halfDimensions);

      var orientation = new THREE.Vector3(new THREE.Vector3(1, 0, 0), new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, 0, 1));

      // 12 edges (i.e. ray)/plane intersection tests
      // RAYS STARTING FROM THE FIRST CORNER (0, 0, 0)
      //
      //       +
      //       |
      //       |
      //       |
      //      ,+---+---+
      //    .'
      //   +

      var ray = this.posdir(new THREE.Vector3(aabb.center.x - aabb.halfDimensions.x, aabb.center.y - aabb.halfDimensions.y, aabb.center.z - aabb.halfDimensions.z), orientation.x);
      this.rayPlaneInBBox(ray, planeAABB, bbox, intersections);

      ray.direction = orientation.y;
      this.rayPlaneInBBox(ray, planeAABB, bbox, intersections);

      ray.direction = orientation.z;
      this.rayPlaneInBBox(ray, planeAABB, bbox, intersections);

      // RAYS STARTING FROM THE LAST CORNER
      //
      //               +
      //             .'
      //   +-------+'
      //           |
      //           |
      //           |
      //           +
      //

      var ray2 = this.posdir(new THREE.Vector3(aabb.center.x + aabb.halfDimensions.x, aabb.center.y + aabb.halfDimensions.y, aabb.center.z + aabb.halfDimensions.z), orientation.x);
      this.rayPlaneInBBox(ray2, planeAABB, bbox, intersections);

      ray2.direction = orientation.y;
      this.rayPlaneInBBox(ray2, planeAABB, bbox, intersections);

      ray2.direction = orientation.z;
      this.rayPlaneInBBox(ray2, planeAABB, bbox, intersections);

      // RAYS STARTING FROM THE SECOND CORNER
      //
      //               +
      //               |
      //               |
      //               |
      //               +
      //             .'
      //           +'

      var ray3 = this.posdir(new THREE.Vector3(aabb.center.x + aabb.halfDimensions.x, aabb.center.y - aabb.halfDimensions.y, aabb.center.z - aabb.halfDimensions.z), orientation.y);
      this.rayPlaneInBBox(ray3, planeAABB, bbox, intersections);

      ray3.direction = orientation.z;
      this.rayPlaneInBBox(ray3, planeAABB, bbox, intersections);

      // RAYS STARTING FROM THE THIRD CORNER
      //
      //      .+-------+
      //    .'
      //   +
      //
      //
      //
      //

      var ray4 = this.posdir(new THREE.Vector3(aabb.center.x - aabb.halfDimensions.x, aabb.center.y + aabb.halfDimensions.y, aabb.center.z - aabb.halfDimensions.z), orientation.x);
      this.rayPlaneInBBox(ray4, planeAABB, bbox, intersections);

      ray4.direction = orientation.z;
      this.rayPlaneInBBox(ray4, planeAABB, bbox, intersections);

      // RAYS STARTING FROM THE FOURTH CORNER
      //
      //
      //
      //   +
      //   |
      //   |
      //   |
      //   +-------+

      var ray5 = this.posdir(new THREE.Vector3(aabb.center.x - aabb.halfDimensions.x, aabb.center.y - aabb.halfDimensions.y, aabb.center.z + aabb.halfDimensions.z), orientation.x);
      this.rayPlaneInBBox(ray5, planeAABB, bbox, intersections);

      ray5.direction = orientation.y;
      this.rayPlaneInBBox(ray5, planeAABB, bbox, intersections);

      // @todo make sure objects are unique...

      // back to original space
      intersections.map(function (element) {
        return element.applyMatrix4(fromAABB);
      });

      return intersections;
    }

    /**
     * Compute intersection between a ray and a plane.
     *
     * @memberOf this
     * @public
     *
     * @param {Object} ray - Ray representation.
     * @param {THREE.Vector3} ray.position - position of normal which describes the ray.
     * @param {THREE.Vector3} ray.direction - Direction of normal which describes the ray.
     * @param {Object} plane - Plane representation
     * @param {THREE.Vector3} plane.position - position of normal which describes the plane.
     * @param {THREE.Vector3} plane.direction - Direction of normal which describes the plane.
     *
     * @returns {THREE.Vector3|null} Intersection between ray and plane or null.
     */

  }, {
    key: 'rayPlane',
    value: function rayPlane(ray, plane) {
      // ray: {position, direction}
      // plane: {position, direction}

      if (ray.direction.dot(plane.direction) !== 0) {
        //
        // not parallel, move forward
        //
        // LOGIC:
        //
        // Ray equation: P = P0 + tV
        // P = <Px, Py, Pz>
        // P0 = <ray.position.x, ray.position.y, ray.position.z>
        // V = <ray.direction.x, ray.direction.y, ray.direction.z>
        //
        // Therefore:
        // Px = ray.position.x + t*ray.direction.x
        // Py = ray.position.y + t*ray.direction.y
        // Pz = ray.position.z + t*ray.direction.z
        //
        //
        //
        // Plane equation: ax + by + cz + d = 0
        // a = plane.direction.x
        // b = plane.direction.y
        // c = plane.direction.z
        // d = -( plane.direction.x*plane.position.x +
        //        plane.direction.y*plane.position.y +
        //        plane.direction.z*plane.position.z )
        //
        //
        // 1- in the plane equation, we replace x, y and z by Px, Py and Pz
        // 2- find t
        // 3- replace t in Px, Py and Pz to get the coordinate of the intersection
        //
        var t = (plane.direction.x * (plane.position.x - ray.position.x) + plane.direction.y * (plane.position.y - ray.position.y) + plane.direction.z * (plane.position.z - ray.position.z)) / (plane.direction.x * ray.direction.x + plane.direction.y * ray.direction.y + plane.direction.z * ray.direction.z);

        var intersection = new THREE.Vector3(ray.position.x + t * ray.direction.x, ray.position.y + t * ray.direction.y, ray.position.z + t * ray.direction.z);

        return intersection;
      }

      return null;
    }

    /**
     * Compute intersection between a ray and a box
     * @param {Object} ray
     * @param {Object} box
     * @return {Array}
     */

  }, {
    key: 'rayBox',
    value: function rayBox(ray, box) {
      // should also do the space transforms here
      // ray: {position, direction}
      // box: {halfDimensions, center}

      var intersections = [];

      var bbox = _core2.default.bbox(box.center, box.halfDimensions);

      // window.console.log(bbox);

      // X min
      var plane = this.posdir(new THREE.Vector3(bbox.min.x, box.center.y, box.center.z), new THREE.Vector3(-1, 0, 0));
      this.rayPlaneInBBox(ray, plane, bbox, intersections);

      // X max
      plane = this.posdir(new THREE.Vector3(bbox.max.x, box.center.y, box.center.z), new THREE.Vector3(1, 0, 0));
      this.rayPlaneInBBox(ray, plane, bbox, intersections);

      // Y min
      plane = this.posdir(new THREE.Vector3(box.center.x, bbox.min.y, box.center.z), new THREE.Vector3(0, -1, 0));
      this.rayPlaneInBBox(ray, plane, bbox, intersections);

      // Y max
      plane = this.posdir(new THREE.Vector3(box.center.x, bbox.max.y, box.center.z), new THREE.Vector3(0, 1, 0));
      this.rayPlaneInBBox(ray, plane, bbox, intersections);

      // Z min
      plane = this.posdir(new THREE.Vector3(box.center.x, box.center.y, bbox.min.z), new THREE.Vector3(0, 0, -1));
      this.rayPlaneInBBox(ray, plane, bbox, intersections);

      // Z max
      plane = this.posdir(new THREE.Vector3(box.center.x, box.center.y, bbox.max.z), new THREE.Vector3(0, 0, 1));
      this.rayPlaneInBBox(ray, plane, bbox, intersections);

      return intersections;
    }

    /**
     * Intersection between ray and a plane that are in a box.
     * @param {*} ray
     * @param {*} planeAABB
     * @param {*} bbox
     * @param {*} intersections
     */

  }, {
    key: 'rayPlaneInBBox',
    value: function rayPlaneInBBox(ray, planeAABB, bbox, intersections) {
      var intersection = this.rayPlane(ray, planeAABB);
      // window.console.log(intersection);
      if (intersection && this.inBBox(intersection, bbox)) {
        if (!intersections.find(this.findIntersection(intersection))) {
          intersections.push(intersection);
        }
      }
    }

    /**
     * Find intersection in array
     * @param {*} myintersection
     */

  }, {
    key: 'findIntersection',
    value: function findIntersection(myintersection) {
      return function found(element, index, array) {
        if (myintersection.x === element.x && myintersection.y === element.y && myintersection.z === element.z) {
          return true;
        }

        return false;
      };
    }

    /**
     * Is point in box.
     * @param {Object} point
     * @param {Object} bbox
     * @return {Boolean}
     */

  }, {
    key: 'inBBox',
    value: function inBBox(point, bbox) {
      //
      var epsilon = 0.0001;
      if (point && point.x >= bbox.min.x - epsilon && point.y >= bbox.min.y - epsilon && point.z >= bbox.min.z - epsilon && point.x <= bbox.max.x + epsilon && point.y <= bbox.max.y + epsilon && point.z <= bbox.max.z + epsilon) {
        return true;
      }
      return false;
    }
  }, {
    key: 'posdir',
    value: function posdir(position, direction) {
      return { position: position, direction: direction };
    }
  }, {
    key: 'validatePlane',
    value: function validatePlane(plane) {
      //
      if (plane === null) {
        window.console.log('Invalid plane.');
        window.console.log(plane);

        return false;
      }

      if (!_core4.default.vector3(plane.position)) {
        window.console.log('Invalid plane.position.');
        window.console.log(plane.position);

        return false;
      }

      if (!_core4.default.vector3(plane.direction)) {
        window.console.log('Invalid plane.direction.');
        window.console.log(plane.direction);

        return false;
      }

      return true;
    }
  }, {
    key: 'validateAabb',
    value: function validateAabb(aabb) {
      //
      if (aabb === null) {
        window.console.log('Invalid aabb.');
        window.console.log(aabb);
        return false;
      }

      if (!_core4.default.matrix4(aabb.toAABB)) {
        window.console.log('Invalid aabb.toAABB: ');
        window.console.log(aabb.toAABB);

        return false;
      }

      if (!_core4.default.vector3(aabb.center)) {
        window.console.log('Invalid aabb.center.');
        window.console.log(aabb.center);

        return false;
      }

      if (!(_core4.default.vector3(aabb.halfDimensions) && aabb.halfDimensions.x >= 0 && aabb.halfDimensions.y >= 0 && aabb.halfDimensions.z >= 0)) {
        window.console.log('Invalid aabb.halfDimensions.');
        window.console.log(aabb.halfDimensions);

        return false;
      }

      return true;
    }
  }]);

  return Intersections;
}();

exports.default = Intersections;

},{"./core.utils":105,"./core.validators":106}],103:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _core = require('./core.colors');

var _core2 = _interopRequireDefault(_core);

var _core3 = require('./core.intersections');

var _core4 = _interopRequireDefault(_core3);

var _core5 = require('./core.pack');

var _core6 = _interopRequireDefault(_core5);

var _core7 = require('./core.validators');

var _core8 = _interopRequireDefault(_core7);

var _core9 = require('./core.utils');

var _core10 = _interopRequireDefault(_core9);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

/**
 * @module core
 */
exports.default = {
  Colors: _core2.default,
  Intersections: _core4.default,
  Utils: _core10.default,
  Validators: _core8.default
};

},{"./core.colors":101,"./core.intersections":102,"./core.pack":104,"./core.utils":105,"./core.validators":106}],104:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

/**
 * Packing functions.
 *
 * @module core/pack */

var Pack = function Pack() {
  _classCallCheck(this, Pack);
};

exports.default = Pack;

},{}],105:[function(require,module,exports){
'use strict';

var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
  return typeof obj === "undefined" ? "undefined" : _typeof2(obj);
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof2(obj);
};

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

var _core = require('./core.validators');

var _core2 = _interopRequireDefault(_core);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

var URL = require('url');

/**
 * General purpose functions.
 *
 * @module core/utils
 */
var CoreUtils = function () {
  function CoreUtils() {
    _classCallCheck(this, CoreUtils);
  }

  _createClass(CoreUtils, null, [{
    key: 'bbox',

    /**
     * Generate a bouding box object.
     * @param {THREE.Vector3} center - Center of the box.
     * @param {THREE.Vector3} halfDimensions - Half Dimensions of the box.
     * @return {Object} The bounding box object. {Object.min} is a {THREE.Vector3}
     * containing the min bounds. {Object.max} is a {THREE.Vector3} containing the
     * max bounds.
     * @return {boolean} False input NOT valid.
     * @example
     * // Returns
     * //{ min: { x : 0, y : 0,  z : 0 },
     * //  max: { x : 2, y : 4,  z : 6 }
     * //}
     * VJS.Core.Utils.bbox(
     *   new THREE.Vector3(1, 2, 3), new THREE.Vector3(1, 2, 3));
     *
     * //Returns false
     * VJS.Core.Utils.bbox(new THREE.Vector3(), new THREE.Matrix4());
     *
     */
    value: function bbox(center, halfDimensions) {
      // make sure we have valid inputs
      if (!(_core2.default.vector3(center) && _core2.default.vector3(halfDimensions))) {
        window.console.log('Invalid center or plane halfDimensions.');
        return false;
      }

      // make sure half dimensions are >= 0
      if (!(halfDimensions.x >= 0 && halfDimensions.y >= 0 && halfDimensions.z >= 0)) {
        window.console.log('halfDimensions must be >= 0.');
        window.console.log(halfDimensions);
        return false;
      }

      // min/max bound
      var min = center.clone().sub(halfDimensions);
      var max = center.clone().add(halfDimensions);

      return {
        min: min,
        max: max
      };
    }

    /**
     * Find min/max values in an array
     * @param {Array} data
     * @return {Array}
     */

  }, {
    key: 'minMax',
    value: function minMax() {
      var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

      var minMax = [65535, -32768];
      var numPixels = data.length;

      for (var index = 0; index < numPixels; index++) {
        var spv = data[index];
        minMax[0] = Math.min(minMax[0], spv);
        minMax[1] = Math.max(minMax[1], spv);
      }

      return minMax;
    }

    /**
     * Check HTMLElement
     * @param {HTMLElement} obj
     * @return {boolean}
     */

  }, {
    key: 'isElement',
    value: function isElement(obj) {
      try {
        // Using W3 DOM2 (works for FF, Opera and Chrom)
        return obj instanceof HTMLElement;
      } catch (e) {
        // Browsers not supporting W3 DOM2 don't have HTMLElement and
        // an exception is thrown and we end up here. Testing some
        // properties that all elements have. (works on IE7)
        return (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object' && obj.nodeType === 1 && _typeof(obj.style) === 'object' && _typeof(obj.ownerDocument) === 'object';
      }
    }

    /**
     * Check string
     * @param {String} str
     * @return {Boolean}
     */

  }, {
    key: 'isString',
    value: function isString(str) {
      return typeof str === 'string' || str instanceof String;
    }

    /**
     * Parse url
     * @param {*} url
     * @return {Object}
     */

  }, {
    key: 'parseUrl',
    value: function parseUrl(url) {
      //
      var data = {};
      data.filename = '';
      data.extension = '';
      data.pathname = '';
      data.query = '';

      var parsedUrl = URL.parse(url);
      data.pathname = parsedUrl.pathname;
      data.query = parsedUrl.query;

      // get file name
      data.filename = data.pathname.split('/').pop();

      // find extension
      var splittedName = data.filename.split('.');
      if (splittedName.length <= 1) {
        data.extension = 'dicom';
      } else {
        data.extension = data.filename.split('.').pop();
      }

      if (!isNaN(data.extension)) {
        data.extension = 'dicom';
      }

      if (data.query && data.query.includes('contentType=application%2Fdicom')) {
        data.extension = 'dicom';
      }

      return data;
    }

    /**
     * Compute IJK to LPS tranform.
     *
     * @param {*} xCos
     * @param {*} yCos
     * @param {*} zCos
     * @param {*} spacing
     * @param {*} origin
     * @param {*} registrationMatrix
     *
     * @return {*}
     */

  }, {
    key: 'ijk2LPS',
    value: function ijk2LPS(xCos, yCos, zCos, spacing, origin) {
      var registrationMatrix = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : new THREE.Matrix4();

      var ijk2LPS = new THREE.Matrix4();
      ijk2LPS.set(xCos.x * spacing.x, yCos.x * spacing.y, zCos.x * spacing.z, origin.x, xCos.y * spacing.x, yCos.y * spacing.y, zCos.y * spacing.z, origin.y, xCos.z * spacing.x, yCos.z * spacing.y, zCos.z * spacing.z, origin.z, 0, 0, 0, 1);
      ijk2LPS.premultiply(registrationMatrix);

      return ijk2LPS;
    }

    /**
     * Compute AABB to LPS transform.
     * AABB: Axe Aligned Bounding Box.
     *
     * @param {*} xCos
     * @param {*} yCos
     * @param {*} zCos
     * @param {*} origin
     *
     * @return {*}
     */

  }, {
    key: 'aabb2LPS',
    value: function aabb2LPS(xCos, yCos, zCos, origin) {
      var aabb2LPS = new THREE.Matrix4();
      aabb2LPS.set(xCos.x, yCos.x, zCos.x, origin.x, xCos.y, yCos.y, zCos.y, origin.y, xCos.z, yCos.z, zCos.z, origin.z, 0, 0, 0, 1);

      return aabb2LPS;
    }

    /**
     * Transform coordinates from world coordinate to data
     *
     * @param {*} lps2IJK
     * @param {*} worldCoordinates
     *
     * @return {*}
     */

  }, {
    key: 'worldToData',
    value: function worldToData(lps2IJK, worldCoordinates) {
      var dataCoordinate = new THREE.Vector3().copy(worldCoordinates).applyMatrix4(lps2IJK);

      // same rounding in the shaders
      dataCoordinate.addScalar(0.5).floor();

      return dataCoordinate;
    }

    /**
     * Get voxel value
     *
     * @param {*} stack
     * @param {*} coordinate
     *
     * @return {*}
     */

  }, {
    key: 'value',
    value: function value(stack, coordinate) {
      if (coordinate.z >= 0 && coordinate.z < stack._frame.length) {
        return stack._frame[coordinate.z].value(coordinate.x, coordinate.y);
      } else {
        return null;
      }
    }

    /**
     * Apply slope/intercept to a value
     *
     * @param {*} value
     * @param {*} slope
     * @param {*} intercept
     *
     * @return {*}
     */

  }, {
    key: 'rescaleSlopeIntercept',
    value: function rescaleSlopeIntercept(value, slope, intercept) {
      return value * slope + intercept;
    }
  }]);

  return CoreUtils;
}();

exports.default = CoreUtils;

},{"./core.validators":106,"url":81}],106:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

/**
 * Validate basic structures.
 *
 * @example
 * //Returns true
 * VJS.Core.Validators.matrix4(new THREE.Matrix4());
 *
 * //Returns false
 * VJS.Core.Validators.matrix4(new THREE.Vector3());
 *
 * @module core/validators
 */

var Validators = function () {
  function Validators() {
    _classCallCheck(this, Validators);
  }

  _createClass(Validators, null, [{
    key: 'matrix4',

    /**
     * Validates a matrix as a THREEJS.Matrix4
     * link
     * @param {Object} objectToTest - The object to be tested.
     * @return {boolean} True if valid Matrix4, false if NOT.
     */
    value: function matrix4(objectToTest) {
      if (!(objectToTest !== null && typeof objectToTest !== 'undefined' && objectToTest.hasOwnProperty('elements') && objectToTest.elements.length === 16 && typeof objectToTest.identity === 'function' && typeof objectToTest.copy === 'function' && typeof objectToTest.determinant === 'function')) {
        return false;
      }

      return true;
    }

    /**
    * Validates a vector as a THREEJS.Vector3
    * @param {Object} objectToTest - The object to be tested.
    * @return {boolean} True if valid Vector3, false if NOT.
    */

  }, {
    key: 'vector3',
    value: function vector3(objectToTest) {
      if (!(objectToTest !== null && typeof objectToTest !== 'undefined' && objectToTest.hasOwnProperty('x') && objectToTest.hasOwnProperty('y') && objectToTest.hasOwnProperty('z') && !objectToTest.hasOwnProperty('w'))) {
        return false;
      }

      return true;
    }

    /**
     * Validates a box.
     *
     * @example
     * // a box is defined as
     * let box = {
     *   center: THREE.Vector3,
     *   halfDimensions: THREE.Vector3
     * }
     *
     * @param {Object} objectToTest - The object to be tested.
     * @return {boolean} True if valid box, false if NOT.
     */

  }, {
    key: 'box',
    value: function box(objectToTest) {
      if (!(objectToTest !== null && typeof objectToTest !== 'undefined' && objectToTest.hasOwnProperty('center') && this.vector3(objectToTest.center) && objectToTest.hasOwnProperty('halfDimensions') && this.vector3(objectToTest.halfDimensions) && objectToTest.halfDimensions.x >= 0 && objectToTest.halfDimensions.y >= 0 && objectToTest.halfDimensions.z >= 0)) {
        return false;
      }

      return true;
    }

    /**
     * Validates a ray.
     *
     * @example
     * // a ray is defined as
     * let ray = {
     *   postion: THREE.Vector3,
     *   direction: THREE.Vector3
     * }
     *
     * @param {Object} objectToTest - The object to be tested.
     * @return {boolean} True if valid ray, false if NOT.
     */

  }, {
    key: 'ray',
    value: function ray(objectToTest) {
      if (!(objectToTest !== null && typeof objectToTest !== 'undefined' && objectToTest.hasOwnProperty('position') && this.vector3(objectToTest.position) && objectToTest.hasOwnProperty('direction') && this.vector3(objectToTest.direction))) {
        return false;
      }

      return true;
    }
  }]);

  return Validators;
}();

exports.default = Validators;

},{}],107:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _geometries = require('./geometries.slice');

var _geometries2 = _interopRequireDefault(_geometries);

var _geometries3 = require('./geometries.voxel');

var _geometries4 = _interopRequireDefault(_geometries3);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

/**
 * @module geometries
 */

exports.default = {
  Slice: _geometries2.default,
  Voxel: _geometries4.default
};

},{"./geometries.slice":108,"./geometries.voxel":109}],108:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

var _core = require('../core/core.intersections');

var _core2 = _interopRequireDefault(_core);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
} /** * Imports ***/

/**
 *
 * It is typically used for creating an irregular 3D planar shape given a box and the cut-plane.
 *
 * Demo: {@link https://fnndsc.github.io/vjs#geometry_slice}
 *
 * @module geometries/slice
 *
 * @param {THREE.Vector3} halfDimensions - Half-dimensions of the box to be sliced.
 * @param {THREE.Vector3} center - Center of the box to be sliced.
 * @param {THREE.Vector3<THREE.Vector3>} orientation - Orientation of the box to be sliced. (might not be necessary..?)
 * @param {THREE.Vector3} position - Position of the cutting plane.
 * @param {THREE.Vector3} direction - Cross direction of the cutting plane.
 *
 * @example
 * // Define box to be sliced
 * let halfDimensions = new THREE.Vector(123, 45, 67);
 * let center = new THREE.Vector3(0, 0, 0);
 * let orientation = new THREE.Vector3(
 *   new THREE.Vector3(1, 0, 0),
 *   new THREE.Vector3(0, 1, 0),
 *   new THREE.Vector3(0, 0, 1)
 * );
 *
 * // Define slice plane
 * let position = center.clone();
 * let direction = new THREE.Vector3(-0.2, 0.5, 0.3);
 *
 * // Create the slice geometry & materials
 * let sliceGeometry = new VJS.geometries.slice(halfDimensions, center, orientation, position, direction);
 * let sliceMaterial = new THREE.MeshBasicMaterial({
 *   'side': THREE.DoubleSide,
 *   'color': 0xFF5722
 * });
 *
 *  // Create mesh and add it to the scene
 *  let slice = new THREE.Mesh(sliceGeometry, sliceMaterial);
 *  scene.add(slice);
 */

var GeometriesSlice = function (_THREE$ShapeGeometry) {
  _inherits(GeometriesSlice, _THREE$ShapeGeometry);

  function GeometriesSlice(halfDimensions, center, position, direction) {
    var toAABB = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : new THREE.Matrix4();

    _classCallCheck(this, GeometriesSlice);

    //
    // prepare data for the shape!
    //
    var aabb = {
      halfDimensions: halfDimensions,
      center: center,
      toAABB: toAABB
    };

    var plane = {
      position: position,
      direction: direction
    };

    // BOOM!
    var intersections = _core2.default.aabbPlane(aabb, plane);

    // can not exist before calling the constructor
    if (intersections.length < 3) {
      window.console.log('WARNING: Less than 3 intersections between AABB and Plane.');
      window.console.log('AABB');
      window.console.log(aabb);
      window.console.log('Plane');
      window.console.log(plane);
      window.console.log('exiting...');
      // or throw error?
      throw 'geometries.slice has less than 3 intersections, can not create a valid geometry.';
    }

    var orderedIntersections = GeometriesSlice.orderIntersections(intersections, direction);
    var sliceShape = GeometriesSlice.shape(orderedIntersections);

    //
    // Generate Geometry from shape
    // It does triangulation for us!
    //

    var _this = _possibleConstructorReturn(this, (GeometriesSlice.__proto__ || Object.getPrototypeOf(GeometriesSlice)).call(this, sliceShape));

    _this.type = 'SliceGeometry';

    // update real position of each vertex! (not in 2d)
    _this.vertices = orderedIntersections;
    _this.verticesNeedUpdate = true;
    return _this;
  }

  _createClass(GeometriesSlice, null, [{
    key: 'shape',
    value: function shape(points) {
      //
      // Create Shape
      //
      var shape = new THREE.Shape();
      // move to first point!
      shape.moveTo(points[0].xy.x, points[0].xy.y);

      // loop through all points!
      for (var l = 1; l < points.length; l++) {
        // project each on plane!
        shape.lineTo(points[l].xy.x, points[l].xy.y);
      }

      // close the shape!
      shape.lineTo(points[0].xy.x, points[0].xy.y);
      return shape;
    }

    /**
     *
     * Convenience function to extract center of mass from list of points.
     *
     * @private
     *
     * @param {Array<THREE.Vector3>} points - Set of points from which we want to extract the center of mass.
     *
     * @returns {THREE.Vector3} Center of mass from given points.
     */

  }, {
    key: 'centerOfMass',
    value: function centerOfMass(points) {
      var centerOfMass = new THREE.Vector3(0, 0, 0);
      for (var i = 0; i < points.length; i++) {
        centerOfMass.x += points[i].x;
        centerOfMass.y += points[i].y;
        centerOfMass.z += points[i].z;
      }
      centerOfMass.divideScalar(points.length);

      return centerOfMass;
    }

    /**
     *
     * Order 3D planar points around a refence point.
     *
     * @private
     *
     * @param {Array<THREE.Vector3>} points - Set of planar 3D points to be ordered.
     * @param {THREE.Vector3} direction - Direction of the plane in which points and reference are sitting.
     *
     * @returns {Array<Object>} Set of object representing the ordered points.
     */

  }, {
    key: 'orderIntersections',
    value: function orderIntersections(points, direction) {
      var reference = GeometriesSlice.centerOfMass(points);
      // direction from first point to reference
      var referenceDirection = new THREE.Vector3(points[0].x - reference.x, points[0].y - reference.y, points[0].z - reference.z).normalize();

      var base = new THREE.Vector3(0, 0, 0).crossVectors(referenceDirection, direction).normalize();

      var orderedpoints = [];

      // other lines // if inter, return location + angle
      for (var j = 0; j < points.length; j++) {
        var point = new THREE.Vector3(points[j].x, points[j].y, points[j].z);
        point.direction = new THREE.Vector3(points[j].x - reference.x, points[j].y - reference.y, points[j].z - reference.z).normalize();

        var x = referenceDirection.dot(point.direction);
        var y = base.dot(point.direction);
        point.xy = { x: x, y: y };

        var theta = Math.atan2(y, x) * (180 / Math.PI);
        point.angle = theta;

        orderedpoints.push(point);
      }

      orderedpoints.sort(function (a, b) {
        return a.angle - b.angle;
      });

      var noDups = [orderedpoints[0]];
      var epsilon = 0.0001;
      for (var i = 1; i < orderedpoints.length; i++) {
        if (Math.abs(orderedpoints[i - 1].angle - orderedpoints[i].angle) > epsilon) {
          noDups.push(orderedpoints[i]);
        }
      }

      return noDups;
    }
  }]);

  return GeometriesSlice;
}(THREE.ShapeGeometry);

exports.default = GeometriesSlice;

},{"../core/core.intersections":102}],109:[function(require,module,exports){
"use strict";

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

/**
 *
 * @module geometries/voxel
 */

var GeometriesVoxel = function (_THREE$BoxGeometry) {
  _inherits(GeometriesVoxel, _THREE$BoxGeometry);

  function GeometriesVoxel(dataPosition) {
    _classCallCheck(this, GeometriesVoxel);

    var _this = _possibleConstructorReturn(this, (GeometriesVoxel.__proto__ || Object.getPrototypeOf(GeometriesVoxel)).call(this, 1, 1, 1));

    _this._location = dataPosition;

    _this.applyMatrix(new THREE.Matrix4().makeTranslation(_this._location.x, _this._location.y, _this._location.z));

    _this.verticesNeedUpdate = true;
    return _this;
  }

  _createClass(GeometriesVoxel, [{
    key: "resetVertices",
    value: function resetVertices() {
      this.vertices[0].set(0.5, 0.5, 0.5);
      this.vertices[1].set(0.5, 0.5, -0.5);
      this.vertices[2].set(0.5, -0.5, 0.5);
      this.vertices[3].set(0.5, -0.5, -0.5);
      this.vertices[4].set(-0.5, 0.5, -0.5);
      this.vertices[5].set(-0.5, 0.5, 0.5);
      this.vertices[6].set(-0.5, -0.5, -0.5);
      this.vertices[7].set(-0.5, -0.5, 0.5);
    }
  }, {
    key: "location",
    set: function set(location) {
      this._location = location;

      // update vertices from location
      this.vertices[0].set(+0.5, +0.5, +0.5);
      this.vertices[1].set(+0.5, +0.5, -0.5);
      this.vertices[2].set(+0.5, -0.5, +0.5);
      this.vertices[3].set(+0.5, -0.5, -0.5);
      this.vertices[4].set(-0.5, +0.5, -0.5);
      this.vertices[5].set(-0.5, +0.5, +0.5);
      this.vertices[6].set(-0.5, -0.5, -0.5);
      this.vertices[7].set(-0.5, -0.5, +0.5);

      this.applyMatrix(new THREE.Matrix4().makeTranslation(this._location.x, this._location.y, this._location.z));

      this.verticesNeedUpdate = true;
    },
    get: function get() {
      return this._location;
    }
  }]);

  return GeometriesVoxel;
}(THREE.BoxGeometry);

exports.default = GeometriesVoxel;

},{}],110:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

/** * Imports ***/

/**
 * @module helpers/border
 */
var HelpersBorder = function (_THREE$Object3D) {
  _inherits(HelpersBorder, _THREE$Object3D);

  function HelpersBorder(helpersSlice) {
    _classCallCheck(this, HelpersBorder);

    var _this = _possibleConstructorReturn(this, (HelpersBorder.__proto__ || Object.getPrototypeOf(HelpersBorder)).call(this));
    //


    _this._helpersSlice = helpersSlice;

    _this._visible = true;
    _this._color = 0xff0000;
    _this._material = null;
    _this._geometry = null;
    _this._mesh = null;

    _this._create();
    return _this;
  }

  _createClass(HelpersBorder, [{
    key: '_create',
    value: function _create() {
      if (!this._material) {
        this._material = new THREE.LineBasicMaterial({
          color: this._color,
          linewidth: 1
        });
      }

      //
      if (!this._helpersSlice.geometry.vertices) {
        return;
      }

      this._geometry = new THREE.Geometry();
      for (var i = 0; i < this._helpersSlice.geometry.vertices.length; i++) {
        this._geometry.vertices.push(this._helpersSlice.geometry.vertices[i]);
      }
      this._geometry.vertices.push(this._helpersSlice.geometry.vertices[0]);

      this._mesh = new THREE.Line(this._geometry, this._material);
      if (this._helpersSlice.aabbSpace === 'IJK') {
        this._mesh.applyMatrix(this._helpersSlice.stack.ijk2LPS);
      }
      this._mesh.visible = this._visible;

      // and add it!
      this.add(this._mesh);
    }
  }, {
    key: '_update',
    value: function _update() {
      // update slice
      if (this._mesh) {
        this.remove(this._mesh);
        this._mesh.geometry.dispose();
        this._mesh = null;
      }

      this._create();
    }
  }, {
    key: 'dispose',
    value: function dispose() {
      this._mesh.material.dispose();
      this._mesh.material = null;
      this._geometry.dispose();
      this._geometry = null;
      this._material.dispose();
      this._material = null;
    }
  }, {
    key: 'helpersSlice',
    set: function set(helpersSlice) {
      this._helpersSlice = helpersSlice;
      this._update();
    },
    get: function get() {
      return this._helpersSlice;
    }
  }, {
    key: 'visible',
    set: function set(visible) {
      this._visible = visible;
      if (this._mesh) {
        this._mesh.visible = this._visible;
      }
    },
    get: function get() {
      return this._visible;
    }
  }, {
    key: 'color',
    set: function set(color) {
      this._color = color;
      if (this._material) {
        this._material.color.set(this._color);
      }
    },
    get: function get() {
      return this._color;
    }
  }]);

  return HelpersBorder;
}(THREE.Object3D);

exports.default = HelpersBorder;

},{}],111:[function(require,module,exports){
"use strict";

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

/**
 * @module helpers/boundingbox
 */

var HelpersBoundingBox = function (_THREE$Object3D) {
  _inherits(HelpersBoundingBox, _THREE$Object3D);

  function HelpersBoundingBox(stack) {
    _classCallCheck(this, HelpersBoundingBox);

    // private vars
    var _this = _possibleConstructorReturn(this, (HelpersBoundingBox.__proto__ || Object.getPrototypeOf(HelpersBoundingBox)).call(this));
    //


    _this._stack = stack;
    _this._visible = true;
    _this._color = 0xFFFFFF;
    _this._material = null;
    _this._geometry = null;
    _this._mesh = null;

    // create object
    _this._create();
    return _this;
  }

  // getters/setters


  _createClass(HelpersBoundingBox, [{
    key: "_create",

    // private methods
    value: function _create() {
      // Convenience vars
      var dimensions = this._stack.dimensionsIJK;
      var halfDimensions = this._stack.halfDimensionsIJK;
      var offset = new THREE.Vector3(-0.5, -0.5, -0.5);

      // Geometry
      this._geometry = new THREE.BoxGeometry(dimensions.x, dimensions.y, dimensions.z);
      // position bbox in image space
      this._geometry.applyMatrix(new THREE.Matrix4().makeTranslation(halfDimensions.x + offset.x, halfDimensions.y + offset.y, halfDimensions.z + offset.z));

      // Mesh
      var boxMesh = new THREE.Mesh(this._geometry, new THREE.MeshBasicMaterial(0xff0000));
      this._mesh = new THREE.BoxHelper(boxMesh, this._color);

      // Material
      this._material = this._mesh.material;

      // position bbox in world space
      this._mesh.applyMatrix(this._stack.ijk2LPS);
      this._mesh.visible = this._visible;

      // and add it!
      this.add(this._mesh);
    }
  }, {
    key: "_update",
    value: function _update() {
      // update slice
      if (this._mesh) {
        this.remove(this._mesh);
        this._mesh.geometry.dispose();
        this._mesh.geometry = null;
        this._mesh.material.dispose();
        this._mesh.material = null;
        this._mesh = null;
      }

      this._create();
    }
  }, {
    key: "dispose",
    value: function dispose() {
      this._mesh.material.dispose();
      this._mesh.material = null;
      this._geometry.dispose();
      this._geometry = null;
      this._material.dispose();
      this._material = null;
    }
  }, {
    key: "visible",
    set: function set(visible) {
      this._visible = visible;
      if (this._mesh) {
        this._mesh.visible = this._visible;
      }
    },
    get: function get() {
      return this._visible;
    }
  }, {
    key: "color",
    set: function set(color) {
      this._color = color;
      if (this._material) {
        this._material.color.set(this._color);
      }
    },
    get: function get() {
      return this._color;
    }
  }]);

  return HelpersBoundingBox;
}(THREE.Object3D);

exports.default = HelpersBoundingBox;

},{}],112:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _helpers = require('./helpers.border');

var _helpers2 = _interopRequireDefault(_helpers);

var _helpers3 = require('./helpers.boundingbox');

var _helpers4 = _interopRequireDefault(_helpers3);

var _helpers5 = require('./helpers.localizer');

var _helpers6 = _interopRequireDefault(_helpers5);

var _helpers7 = require('./helpers.lut');

var _helpers8 = _interopRequireDefault(_helpers7);

var _helpers9 = require('./helpers.progressbar');

var _helpers10 = _interopRequireDefault(_helpers9);

var _helpersProgressbar = require('./helpers.progressbar.eventbased');

var _helpersProgressbar2 = _interopRequireDefault(_helpersProgressbar);

var _helpers11 = require('./helpers.slice');

var _helpers12 = _interopRequireDefault(_helpers11);

var _helpers13 = require('./helpers.stack');

var _helpers14 = _interopRequireDefault(_helpers13);

var _helpers15 = require('./helpers.volumerendering');

var _helpers16 = _interopRequireDefault(_helpers15);

var _helpers17 = require('./x/helpers.x');

var _helpers18 = _interopRequireDefault(_helpers17);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

/**
 * @module helpers
 */

exports.default = {
  Border: _helpers2.default,
  BoundingBox: _helpers4.default,
  Localizer: _helpers6.default,
  Lut: _helpers8.default,
  ProgressBar: _helpers10.default,
  ProgressBarEventBased: _helpersProgressbar2.default,
  Slice: _helpers12.default,
  Stack: _helpers14.default,
  VolumeRendering: _helpers16.default,
  X: _helpers18.default
};

},{"./helpers.border":110,"./helpers.boundingbox":111,"./helpers.localizer":113,"./helpers.lut":114,"./helpers.progressbar":117,"./helpers.progressbar.eventbased":116,"./helpers.slice":118,"./helpers.stack":119,"./helpers.volumerendering":120,"./x/helpers.x":122}],113:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

var _shadersLocalizer = require('../shaders/shaders.localizer.uniform');

var _shadersLocalizer2 = _interopRequireDefault(_shadersLocalizer);

var _shadersLocalizer3 = require('../shaders/shaders.localizer.vertex');

var _shadersLocalizer4 = _interopRequireDefault(_shadersLocalizer3);

var _shadersLocalizer5 = require('../shaders/shaders.localizer.fragment');

var _shadersLocalizer6 = _interopRequireDefault(_shadersLocalizer5);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
} /** * Imports ***/

/**
 * @module helpers/localizer
 */

var HelpersLocalizer = function (_THREE$Object3D) {
  _inherits(HelpersLocalizer, _THREE$Object3D);

  function HelpersLocalizer(stack, geometry, referencePlane) {
    _classCallCheck(this, HelpersLocalizer);

    var _this = _possibleConstructorReturn(this, (HelpersLocalizer.__proto__ || Object.getPrototypeOf(HelpersLocalizer)).call(this));
    //


    _this._stack = stack;
    _this._referencePlane = referencePlane;
    _this._plane1 = null;
    _this._color1 = null;
    _this._plane2 = null;
    _this._color2 = null;
    _this._plane3 = null;
    _this._color3 = null;
    _this._canvasWidth = 0;
    _this._canvasHeight = 0;
    _this._shadersFragment = _shadersLocalizer6.default;
    _this._shadersVertex = _shadersLocalizer4.default;
    _this._uniforms = _shadersLocalizer2.default.uniforms();
    _this._material = null;
    _this._geometry = geometry;

    _this._create();
    return _this;
  }

  _createClass(HelpersLocalizer, [{
    key: '_create',
    value: function _create() {
      this._prepareMaterial();
      this._mesh = new THREE.Mesh(this._geometry, this._material);
      this._mesh.applyMatrix(this._stack._ijk2LPS);
      this.add(this._mesh);
    }
  }, {
    key: '_prepareMaterial',
    value: function _prepareMaterial() {
      if (!this.material) {
        // reference plane
        this._uniforms.uSlice.value = this._referencePlane;

        // localizer planes
        if (this._plane1) {
          this._uniforms.uPlane1.value = this._plane1;
          this._uniforms.uPlaneColor1.value = this._color1;
        }

        if (this._plane2) {
          this._uniforms.uPlane2.value = this._plane2;
          this._uniforms.uPlaneColor2.value = this._color2;
        }

        if (this._plane3) {
          this._uniforms.uPlane3.value = this._plane3;
          this._uniforms.uPlaneColor3.value = this._color3;
        }

        //
        this._uniforms.uCanvasWidth.value = this._canvasWidth;
        this._uniforms.uCanvasHeight.value = this._canvasHeight;

        // generate material
        var fs = new _shadersLocalizer6.default(this._uniforms);
        var vs = new _shadersLocalizer4.default();
        this._material = new THREE.ShaderMaterial({ side: THREE.DoubleSide,
          uniforms: this._uniforms,
          vertexShader: vs.compute(),
          fragmentShader: fs.compute()
        });
        this._material.transparent = true;
      }
    }
  }, {
    key: 'update',
    value: function update() {
      if (this._mesh) {
        this.remove(this._mesh);
        this._mesh.geometry.dispose();
        this._mesh.geometry = null;
        this._mesh = null;
      }

      this._create();
    }
  }, {
    key: 'geometry',
    get: function get() {
      return this._geometry;
    },
    set: function set(geometry) {
      this._geometry = geometry;

      if (this._mesh) {
        this.remove(this._mesh);
        this._mesh.geometry.dispose();
        this._mesh.geometry = null;
        this._mesh = null;
      }

      this._create();
    }
  }, {
    key: 'referencePlane',
    get: function get() {
      return this._referencePlane;
    },
    set: function set(referencePlane) {
      this._referencePlane = referencePlane;
      this._uniforms.uSlice.value = this._referencePlane;
    }
  }, {
    key: 'plane1',
    get: function get() {
      return this._plane1;
    },
    set: function set(plane1) {
      this._plane1 = plane1;
      this._uniforms.uPlane1.value = this._plane1;
    }
  }, {
    key: 'color1',
    get: function get() {
      return this._color1;
    },
    set: function set(color1) {
      this._color1 = color1;
      this._uniforms.uPlaneColor1.value = this._color1;
    }
  }, {
    key: 'plane2',
    get: function get() {
      return this._plane2;
    },
    set: function set(plane2) {
      this._plane2 = plane2;
      this._uniforms.uPlane2.value = this._plane2;
    }
  }, {
    key: 'color2',
    get: function get() {
      return this._color2;
    },
    set: function set(color2) {
      this._color2 = color2;
      this._uniforms.uPlaneColor2.value = this._color2;
    }
  }, {
    key: 'plane3',
    get: function get() {
      return this._plane3;
    },
    set: function set(plane3) {
      this._plane3 = plane3;
      this._uniforms.uPlane3.value = this._plane3;
    }
  }, {
    key: 'color3',
    get: function get() {
      return this._color3;
    },
    set: function set(color3) {
      this._color3 = color3;
      this._uniforms.uPlaneColor3.value = this._color3;
    }
  }, {
    key: 'canvasWidth',
    get: function get() {
      return this._canvasWidth;
    },
    set: function set(canvasWidth) {
      this._canvasWidth = canvasWidth;
      this._uniforms.uCanvasWidth.value = this._canvasWidth;
    }
  }, {
    key: 'canvasHeight',
    get: function get() {
      return this._canvasHeight;
    },
    set: function set(canvasHeight) {
      this._canvasHeight = canvasHeight;
      this._uniforms.uCanvasHeight.value = this._canvasHeight;
    }
  }]);

  return HelpersLocalizer;
}(THREE.Object3D);

exports.default = HelpersLocalizer;

},{"../shaders/shaders.localizer.fragment":159,"../shaders/shaders.localizer.uniform":160,"../shaders/shaders.localizer.vertex":161}],114:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }return obj;
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

/**
 * @module helpers/lut
 */

var HelpersLut = function () {
  function HelpersLut(containerID) {
    var lut = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'default';
    var lutO = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'linear';
    var color = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [[0, 0, 0, 0], [1, 1, 1, 1]];
    var opacity = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [[0, 0], [1, 1]];
    var discrete = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;

    _classCallCheck(this, HelpersLut);

    // min/max (0-1 or real intensities)
    // show/hide
    // horizontal/vertical
    this._containerID = containerID;

    this._discrete = discrete;
    this._color = color;
    this._lut = lut;
    this._luts = _defineProperty({}, lut, color);

    this._opacity = opacity;
    this._lutO = lutO;
    this._lutsO = _defineProperty({}, lutO, opacity);

    this.initCanvas();
    this.paintCanvas();
  }

  _createClass(HelpersLut, [{
    key: 'initCanvas',
    value: function initCanvas() {
      // container
      this._canvasContainer = this.initCanvasContainer(this._containerID);
      // background
      this._canvasBg = this.createCanvas();
      this._canvasContainer.appendChild(this._canvasBg);
      // foreground
      this._canvas = this.createCanvas();
      this._canvasContainer.appendChild(this._canvas);
    }
  }, {
    key: 'initCanvasContainer',
    value: function initCanvasContainer(canvasContainerId) {
      var canvasContainer = document.getElementById(canvasContainerId);
      canvasContainer.style.width = '256 px';
      canvasContainer.style.height = '128 px';
      canvasContainer.style.border = '1px solid #F9F9F9';
      return canvasContainer;
    }
  }, {
    key: 'createCanvas',
    value: function createCanvas() {
      var canvas = document.createElement('canvas');
      canvas.height = 16;
      canvas.width = 256;
      return canvas;
    }
  }, {
    key: 'paintCanvas',
    value: function paintCanvas() {
      // setup context
      var ctx = this._canvas.getContext('2d');
      ctx.clearRect(0, 0, this._canvas.width, this._canvas.height);
      ctx.globalCompositeOperation = 'source-over';

      // apply color
      if (!this._discrete) {
        var color = ctx.createLinearGradient(0, 0, this._canvas.width, this._canvas.height);
        for (var i = 0; i < this._color.length; i++) {
          color.addColorStop(this._color[i][0], 'rgba( ' + Math.round(this._color[i][1] * 255) + ', ' + Math.round(this._color[i][2] * 255) + ', ' + Math.round(this._color[i][3] * 255) + ', 1)');
        }

        ctx.fillStyle = color;
        ctx.fillRect(0, 0, this._canvas.width, this._canvas.height);
      } else {
        ctx.lineWidth = 2 * this._canvas.height;

        for (var _i = 0; _i < this._color.length; _i++) {
          var currentPos = this._color[_i][0];
          var nextPos = 1;
          if (_i < this._color.length - 1) {
            nextPos = this._color[_i + 1][0];
          }
          var previousPos = 0;
          if (_i > 0) {
            previousPos = this._color[_i - 1][0];
          }

          var from = previousPos + (currentPos - previousPos) / 2;
          var to = currentPos + (nextPos - currentPos) / 2;
          var _color = this._color[_i];
          var opacity = this._opacity[_i] ? this._opacity[_i][1] : 1;

          ctx.beginPath();
          ctx.strokeStyle = 'rgba( ' + Math.round(_color[1] * 255) + ', ' + Math.round(_color[2] * 255) + ', ' + Math.round(_color[3] * 255) + ', ' + opacity + ')';
          ctx.moveTo(from * this._canvas.width, 0);
          ctx.lineTo(to * this._canvas.width, 0);
          ctx.stroke();
          ctx.closePath();
        }
      }

      if (!this._discrete) {
        // if discrete, we already took care of the opacity.
        // setup context
        ctx.globalCompositeOperation = 'destination-in';

        // apply opacity
        var _opacity = ctx.createLinearGradient(0, 0, this._canvas.width, this._canvas.height);
        for (var _i2 = 0; _i2 < this._opacity.length; _i2++) {
          _opacity.addColorStop(this._opacity[_i2][0], 'rgba(255, 255, 255, ' + this._opacity[_i2][1] + ')');
        }
        ctx.fillStyle = _opacity;
        ctx.fillRect(0, 0, this._canvas.width, this._canvas.height);
      }
    }
  }, {
    key: 'lutsAvailable',
    value: function lutsAvailable() {
      var type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'color';

      var available = [];
      var luts = this._luts;

      if (type !== 'color') {
        luts = this._lutsO;
      }

      for (var i in luts) {
        available.push(i);
      }

      return available;
    }

    // add luts to class' lut (so a user can add its own as well)

  }, {
    key: 'texture',
    get: function get() {
      var texture = new THREE.Texture(this._canvas);
      texture.mapping = THREE.UVMapping;
      texture.wrapS = texture.wrapT = THREE.ClampToEdgeWrapping;
      texture.magFilter = texture.minFilter = THREE.NearestFilter;
      texture.premultiplyAlpha = true;
      texture.needsUpdate = true;
      return texture;
    }
  }, {
    key: 'lut',
    set: function set(targetLUT) {
      this._color = this._luts[targetLUT];
      this._lut = targetLUT;

      this.paintCanvas();
    },
    get: function get() {
      return this._lut;
    }
  }, {
    key: 'luts',
    set: function set(newLuts) {
      this._luts = newLuts;
    },
    get: function get() {
      return this._luts;
    }
  }, {
    key: 'lutO',
    set: function set(targetLUTO) {
      this._opacity = this._lutsO[targetLUTO];
      this._lutO = targetLUTO;

      this.paintCanvas();
    },
    get: function get() {
      return this._lutO;
    }
  }, {
    key: 'lutsO',
    set: function set(newLutsO) {
      this._lutsO = newLutsO;
    },
    get: function get() {
      return this._lutsO;
    }
  }, {
    key: 'discrete',
    set: function set(discrete) {
      this._discrete = discrete;

      this.paintCanvas();
    },
    get: function get() {
      return this._discrete;
    }
  }], [{
    key: 'presetLuts',
    value: function presetLuts() {
      return {
        'default': [[0, 0, 0, 0], [1, 1, 1, 1]],
        'spectrum': [[0, 0, 0, 0], [0.1, 0, 0, 1], [0.33, 0, 1, 1], [0.5, 0, 1, 0], [0.66, 1, 1, 0], [0.9, 1, 0, 0], [1, 1, 1, 1]],
        'hot_and_cold': [[0, 0, 0, 1], [0.15, 0, 1, 1], [0.3, 0, 1, 0], [0.45, 0, 0, 0], [0.5, 0, 0, 0], [0.55, 0, 0, 0], [0.7, 1, 1, 0], [0.85, 1, 0, 0], [1, 1, 1, 1]],
        'gold': [[0, 0, 0, 0], [0.13, 0.19, 0.03, 0], [0.25, 0.39, 0.12, 0], [0.38, 0.59, 0.26, 0], [0.50, 0.80, 0.46, 0.08], [0.63, 0.99, 0.71, 0.21], [0.75, 0.99, 0.88, 0.34], [0.88, 0.99, 0.99, 0.48], [1, 0.90, 0.95, 0.61]],
        'red': [[0, 0.75, 0, 0], [0.5, 1, 0.5, 0], [0.95, 1, 1, 0], [1, 1, 1, 1]],
        'green': [[0, 0, 0.75, 0], [0.5, 0.5, 1, 0], [0.95, 1, 1, 0], [1, 1, 1, 1]],
        'blue': [[0, 0, 0, 1], [0.5, 0, 0.5, 1], [0.95, 0, 1, 1], [1, 1, 1, 1]],
        'walking_dead': [[0, 0.1, 1, 1], [1, 1, 1, 1]],
        'random': [[0, 0, 0, 0], [0.27, 0.18, 0.18, 0.18], [0.41, 1, 1, 1], [0.7, 1, 0, 0], [1, 1, 1, 1]]
      };
    }
  }, {
    key: 'presetLutsO',
    value: function presetLutsO() {
      return {
        'linear': [[0, 0], [1, 1]],
        'lowpass': [[0, 0.8], [0.2, 0.6], [0.3, 0.1], [1, 0]],
        'bandpass': [[0, 0], [0.4, 0.8], [0.6, 0.8], [1, 0]],
        'highpass': [[0, 0], [0.7, 0.1], [0.8, 0.6], [1, 0.8]],
        'flat': [[0, .7], [1, 1]],
        'random': [[0, 0.], [0.38, 0.], [0.55, 1.], [0.72, 1.], [1, 0.05]]
      };
    }
  }]);

  return HelpersLut;
}();

exports.default = HelpersLut;

},{}],115:[function(require,module,exports){
"use strict";

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

/**
 * Helpers material mixin.
 *
 * @module helpers/material/mixin
 */

var HerlpersMaterialMixin = function HerlpersMaterialMixin(superclass) {
  return function (_superclass) {
    _inherits(_class, _superclass);

    function _class() {
      _classCallCheck(this, _class);

      return _possibleConstructorReturn(this, (_class.__proto__ || Object.getPrototypeOf(_class)).apply(this, arguments));
    }

    _createClass(_class, [{
      key: "_createMaterial",
      value: function _createMaterial(extraOptions) {
        // generate shaders on-demand!
        var fs = new this._shadersFragment(this._uniforms);
        var vs = new this._shadersVertex();

        // material
        var globalOptions = {
          uniforms: this._uniforms,
          vertexShader: vs.compute(),
          fragmentShader: fs.compute()
        };

        var options = Object.assign(extraOptions, globalOptions);
        this._material = new THREE.ShaderMaterial(options);
        this._material.needsUpdate = true;
      }
    }, {
      key: "_updateMaterial",
      value: function _updateMaterial() {
        // generate shaders on-demand!
        var fs = new this._shadersFragment(this._uniforms);
        var vs = new this._shadersVertex();

        this._material.vertexShader = vs.compute();
        this._material.fragmentShader = fs.compute();

        this._material.needsUpdate = true;
      }
    }, {
      key: "_prepareTexture",
      value: function _prepareTexture() {
        this._textures = [];
        for (var m = 0; m < this._stack._rawData.length; m++) {
          var tex = new THREE.DataTexture(this._stack.rawData[m], this._stack.textureSize, this._stack.textureSize, this._stack.textureType, THREE.UnsignedByteType, THREE.UVMapping, THREE.ClampToEdgeWrapping, THREE.ClampToEdgeWrapping, THREE.NearestFilter, THREE.NearestFilter);
          tex.needsUpdate = true;
          tex.flipY = true;
          this._textures.push(tex);
        }
      }
    }]);

    return _class;
  }(superclass);
};

exports.default = HerlpersMaterialMixin;

},{}],116:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

var _core = require('../core/core.utils');

var _core2 = _interopRequireDefault(_core);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

/**
 * Event Based progressbar
 * @module helpers/progressBar
 *
 * @example
 *
 * let loader = new LoadersVolume();
 * const domContainer = document.getElementById('progressbar');
 * const pb = new HelpersProgressBarEventBased(loader, domContainer);
 */

var HelpersProgressBarEventBased = function () {
  function HelpersProgressBarEventBased(emitter, domTarget) {
    _classCallCheck(this, HelpersProgressBarEventBased);

    if (!emitter || !this._isFunction(emitter.emit)) {
      console.error('please give the this._emitter instance');
      return;
    }

    if (_core2.default.isString(domTarget)) {
      this._dom = document.getElementById(domTarget);
    } else {
      this._dom = domTarget;
    }

    if (!_core2.default.isElement(this._dom)) {
      console.error('please give the id of container dom or directly a dom instance');
      return;
    }
    this._emitter = emitter;
    this.initContainerDom();
    this.initEventListenner();
    this.loaded = 0;
    this.totalFile = 0;
  }

  _createClass(HelpersProgressBarEventBased, [{
    key: '_isFunction',
    value: function _isFunction(fn) {
      return Object.prototype.toString.call(fn) === '[object Function]';
    }
  }, {
    key: 'initEventListenner',
    value: function initEventListenner() {
      var self = this;

      this._emitter.on('load-start', function (event) {
        var totalFiles = event.totalFiles;
        self.totalFile = totalFiles;
        self._domTotalFile.innerHTML = totalFiles;
      });

      this._emitter.on('fetch-start', function (event) {
        var fetchLi = document.createElement('li');

        var fileTag = document.createElement('div');
        fileTag.innerHTML = 'file: ' + event.file;
        fileTag.style.color = '#ffffff';
        fetchLi.append(fileTag);

        fetchLi.className = 'fetch-file';
        fetchLi.id = 'file-' + event.file;
        fetchLi.style.marginBottom = '7px';
        fetchLi.style.border = '1px solid #ffffff;';
        fetchLi.style.width = '60%';
        var fetchprogress = document.createElement('div');
        fetchprogress.id = 'file-fetch-' + event.file;
        fetchprogress.style.width = '0%';
        fetchLi.append(fetchprogress);
        self._domProcessList.append(fetchLi);
      });

      this._emitter.on('fetch-progress', function (event) {
        var id = 'file-fetch-' + event.file;
        var fileFetchDom = document.getElementById(id);
        fileFetchDom.style.width = event.loaded / event.total * 100 + '%';
        fileFetchDom.style.border = '1px solid red';
      });

      this._emitter.on('fetch-success', function (event) {
        // show result
        var liParent = document.getElementById('file-' + event.file);
        var result = document.createElement('div');
        result.id = 'file-result-' + event.file;
        result.innerHTML = 'fetch-success';
        result.style.color = '#ffffff';
        liParent.append(result);
      });

      this._emitter.on('fetch-error', function (event) {
        // console.log(event);
      });

      this._emitter.on('fetch-abort', function (event) {
        // console.log(event);
      });

      this._emitter.on('fetch-end', function (event) {
        // console.log(event);
      });

      this._emitter.on('fetch-timeout', function (event) {
        // console.log(event);
      });

      this._emitter.on('parse-start', function (event) {
        var liParent = document.getElementById('file-' + event.file);
        var parseprogress = document.createElement('div');
        parseprogress.id = 'file-parse-' + event.file;
        parseprogress.style.width = '0%';
        liParent.append(parseprogress);
      });

      this._emitter.on('parsing', function (event) {
        var id = 'file-parse-' + event.file;
        var fileParseDom = document.getElementById(id);
        fileParseDom.style.width = event.parsed / event.total * 100 + '%';
        fileParseDom.style.border = '1px solid yellow';
      });

      this._emitter.on('parse-success', function (event) {
        self.loaded += 1;
        self._domCurrentFile.innerHTML = self.loaded;
        self._domCurrentProgress.style.width = self.loaded / self.totalFile * 100 + '%';
        // show result
        var liParent = document.getElementById('file-' + event.file);
        var result = document.createElement('div');
        result.id = 'file-result-' + event.file;
        result.innerHTML = 'parse-success';
        result.style.color = '#ffffff';
        liParent.append(result);
      });
    }
  }, {
    key: 'initContainerDom',
    value: function initContainerDom() {
      var containerDom = "<div id='ami-progress-bar-container' style='background-color: rgb(33, 33, 33); color: #ffffff;'>" + "<div>" + "<label for='progress-bar' id='progress-label' style='width: 60%; border: 1px solid #ffffff; text-align: center;'>" + "<span id='current-file-index'>0</span>" + "/" + "<span id='total-file'>0</span>" + "</label>" + "<div id='progress-bar' style='width: 60%; border: 1px solid #ffffff; text-align: center;'>" + "<div id='current-progress' style='border: 1px solid red; width: 0%;'></div>" + "</div>" + "</div>" + "<ul id='process-list' style='list-style-type: none; padding: 0; overflow-y: auto;'>" +
      // "<li class='fetch-file'>" +
      // "<div id='file-fetch-xxxxxid'></div>" +
      // "<div id='file-parse-xxxxxid'></div>" +
      // "</li>" +
      "</ul>" + "</div>";
      var wrap = document.createElement('div');
      wrap.innerHTML = containerDom;
      this._dom.append(wrap);
      // dom interface
      this._domCurrentFile = document.getElementById('current-file-index');
      this._domTotalFile = document.getElementById('total-file');
      this._domProcessList = document.getElementById('process-list');
      this._domCurrentProgress = document.getElementById('current-progress');
    }
  }]);

  return HelpersProgressBarEventBased;
}();

exports.default = HelpersProgressBarEventBased;

},{"../core/core.utils":105}],117:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

/**
 * @module helpers/progressBar
 */

var HelpersProgressBar = function () {
  function HelpersProgressBar(container) {
    _classCallCheck(this, HelpersProgressBar);

    this._container = container;
    this._modes = {
      'load': {
        'name': 'load',
        'color': '#FFF56F'
      },
      'parse': {
        'name': 'parse',
        'color': '#2196F3'
      }
    };

    this.requestAnimationFrameID = null;

    this._mode = null;
    this._value = null;
    this._total = null;

    this.init();
  }

  _createClass(HelpersProgressBar, [{
    key: 'free',
    value: function free() {
      var progressContainers = this._container.getElementsByClassName('progress container');
      if (progressContainers.length > 0) {
        progressContainers[0].parentNode.removeChild(progressContainers[0]);
      }
      progressContainers = null;
      // stop rendering loop
      window.cancelAnimationFrame(this.requestAnimationFrameID);
    }
  }, {
    key: 'init',
    value: function init() {
      var progressContainer = this._domContainer();

      for (var mode in this._modes) {
        if (this._modes.hasOwnProperty(mode)) {
          var bar = this._domBar(this._modes[mode]);
          progressContainer.appendChild(bar);
          bar = null;
        }
      }

      this._container.appendChild(progressContainer);
      progressContainer = null;

      // start rendering loop
      this.updateUI();
    }
  }, {
    key: 'update',
    value: function update(value, total, mode) {
      this._mode = mode;
      this._value = value;
      // depending on CDN, total return to XHTTPRequest can be 0.
      // In this case, we generate a random number to animate the progressbar
      if (total === 0) {
        this._total = value;
        this._value = Math.random() * value;
      } else {
        this._total = total;
      }
    }
  }, {
    key: 'updateUI',
    value: function updateUI() {
      var _this = this;

      this.requestAnimationFrameID = requestAnimationFrame(function () {
        _this.updateUI();
      });

      if (!(this._modes.hasOwnProperty(this._mode) && this._modes[this._mode].hasOwnProperty('name') && this._modes[this._mode].hasOwnProperty('color'))) {
        return false;
      }

      var message = '';
      var progress = Math.round(this._value / this._total * 100);
      var color = this._modes[this._mode].color;

      var progressBar = this._container.getElementsByClassName('progress ' + this._modes[this._mode].name);
      if (progressBar.length > 0) {
        progressBar[0].style.borderColor = color;
        progressBar[0].style.width = progress + '%';
      }
      progressBar = null;
    }
  }, {
    key: '_domContainer',
    value: function _domContainer() {
      var container = document.createElement('div');

      // class it
      container.classList.add('progress');
      container.classList.add('container');

      // style it
      container.style.width = '100%';
      container.style.height = '8px';
      container.style.position = 'absolute';
      container.style.backgroundColor = 'rgba(158, 158, 158, 0.5)';
      container.style.top = '0';
      container.style.zIndex = '1';

      return container;
    }
  }, {
    key: '_domBar',
    value: function _domBar(mode) {
      if (!(mode.hasOwnProperty('name') && mode.hasOwnProperty('color'))) {
        window.console.log('Invalid mode provided.');
        window.console.log(mode);

        return false;
      }

      var bar = document.createElement('div');

      // class it
      bar.classList.add(mode.name);
      bar.classList.add('progress');

      // style it
      bar.style.border = '2px solid ' + mode.color;
      bar.style.width = '0%';

      return bar;
    }
  }]);

  return HelpersProgressBar;
}();

exports.default = HelpersProgressBar;

},{}],118:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

var _geometries = require('../geometries/geometries.slice');

var _geometries2 = _interopRequireDefault(_geometries);

var _shadersData = require('../shaders/shaders.data.uniform');

var _shadersData2 = _interopRequireDefault(_shadersData);

var _shadersData3 = require('../shaders/shaders.data.vertex');

var _shadersData4 = _interopRequireDefault(_shadersData3);

var _shadersData5 = require('../shaders/shaders.data.fragment');

var _shadersData6 = _interopRequireDefault(_shadersData5);

var _helpersMaterial = require('../helpers/helpers.material.mixin');

var _helpersMaterial2 = _interopRequireDefault(_helpersMaterial);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
} /** * Imports ***/

/**
 * @module helpers/slice
 */

var HelpersSlice = function (_HelpersMaterialMixin) {
  _inherits(HelpersSlice, _HelpersMaterialMixin);

  function HelpersSlice(stack) {
    var index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var position = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new THREE.Vector3(0, 0, 0);
    var direction = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new THREE.Vector3(0, 0, 1);
    var aabbSpace = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 'IJK';

    _classCallCheck(this, HelpersSlice);

    // private vars
    var _this = _possibleConstructorReturn(this, (HelpersSlice.__proto__ || Object.getPrototypeOf(HelpersSlice)).call(this));
    //


    _this._stack = stack;

    // image settings
    // index only used to grab window/level and intercept/slope
    _this._invert = _this._stack.invert;

    _this._lut = 'none';
    _this._lutTexture = null;
    // if auto === true, get from index
    // else from stack which holds the default values
    _this._intensityAuto = true;
    _this._interpolation = 1; // default to trilinear interpolation
    // starts at 0
    _this._index = index;
    _this._windowWidth = null;
    _this._windowCenter = null;
    _this._rescaleSlope = null;
    _this._rescaleIntercept = null;

    _this._canvasWidth = 0;
    _this._canvasHeight = 0;
    _this._borderColor = null;

    // Object3D settings
    // shape
    _this._planePosition = position;
    _this._planeDirection = direction;
    // change aaBBSpace changes the box dimensions
    // also changes the transform
    // there is also a switch to move back mesh to LPS space automatically
    _this._aaBBspace = aabbSpace; // or LPS -> different transforms, esp for the geometry/mesh
    _this._material = null;
    _this._textures = [];
    _this._shadersFragment = _shadersData6.default;
    _this._shadersVertex = _shadersData4.default;
    _this._uniforms = _shadersData2.default.uniforms();
    _this._geometry = null;
    _this._mesh = null;
    _this._visible = true;

    // update dimensions, center, etc.
    // depending on aaBBSpace
    _this._init();

    // update object
    _this._create();
    return _this;
  }

  // getters/setters

  _createClass(HelpersSlice, [{
    key: '_init',
    value: function _init() {
      if (!this._stack || !this._stack._prepared || !this._stack._packed) {
        return;
      }

      if (this._aaBBspace === 'IJK') {
        this._halfDimensions = this._stack.halfDimensionsIJK;
        this._center = new THREE.Vector3(this._stack.halfDimensionsIJK.x - 0.5, this._stack.halfDimensionsIJK.y - 0.5, this._stack.halfDimensionsIJK.z - 0.5);
        this._toAABB = new THREE.Matrix4();
      } else {
        // LPS
        var aaBBox = this._stack.AABBox();
        this._halfDimensions = aaBBox.clone().multiplyScalar(0.5);
        this._center = this._stack.centerAABBox();
        this._toAABB = this._stack.lps2AABB;
      }
    }

    // private methods

  }, {
    key: '_create',
    value: function _create() {
      if (!this._stack || !this._stack.prepared || !this._stack.packed) {
        return;
      }

      // Convenience vars
      try {
        this._geometry = new _geometries2.default(this._halfDimensions, this._center, this._planePosition, this._planeDirection, this._toAABB);
      } catch (e) {
        window.console.log(e);
        window.console.log('invalid slice geometry - exiting...');
        return;
      }

      if (!this._geometry.vertices) {
        return;
      }

      if (!this._material) {
        //
        this._uniforms.uTextureSize.value = this._stack.textureSize;
        this._uniforms.uDataDimensions.value = [this._stack.dimensionsIJK.x, this._stack.dimensionsIJK.y, this._stack.dimensionsIJK.z];
        this._uniforms.uWorldToData.value = this._stack.lps2IJK;
        this._uniforms.uNumberOfChannels.value = this._stack.numberOfChannels;
        this._uniforms.uPixelType.value = this._stack.pixelType;
        this._uniforms.uBitsAllocated.value = this._stack.bitsAllocated;
        this._uniforms.uPackedPerPixel.value = this._stack.packedPerPixel;
        // compute texture if material exist
        this._prepareTexture();
        this._uniforms.uTextureContainer.value = this._textures;

        this._createMaterial({
          side: THREE.DoubleSide
        });
      }

      // update intensity related stuff
      this.updateIntensitySettings();
      this.updateIntensitySettingsUniforms();

      // create the mesh!
      this._mesh = new THREE.Mesh(this._geometry, this._material);
      if (this._aaBBspace === 'IJK') {
        this._mesh.applyMatrix(this._stack.ijk2LPS);
      }

      this._mesh.visible = this._visible;

      // and add it!
      this.add(this._mesh);
    }
  }, {
    key: 'updateIntensitySettings',
    value: function updateIntensitySettings() {
      // if auto, get from frame index
      if (this._intensityAuto) {
        this.updateIntensitySetting('windowCenter');
        this.updateIntensitySetting('windowWidth');
        this.updateIntensitySetting('rescaleSlope');
        this.updateIntensitySetting('rescaleIntercept');
      } else {
        if (this._windowCenter === null) {
          this._windowCenter = this._stack.windowCenter;
        }

        if (this.__windowWidth === null) {
          this._windowWidth = this._stack.windowWidth;
        }

        if (this._rescaleSlope === null) {
          this._rescaleSlope = this._stack.rescaleSlope;
        }

        if (this._rescaleIntercept === null) {
          this._rescaleIntercept = this._stack.rescaleIntercept;
        }
      }
    }
  }, {
    key: 'updateIntensitySettingsUniforms',
    value: function updateIntensitySettingsUniforms() {
      // compensate for the offset to only pass > 0 values to shaders
      // models > models.stack.js : _packTo8Bits
      var offset = 0;
      if (this._stack._minMax[0] < 0) {
        offset -= this._stack._minMax[0];
      }

      // set slice window center and width
      this._uniforms.uRescaleSlopeIntercept.value = [this._rescaleSlope, this._rescaleIntercept];
      this._uniforms.uWindowCenterWidth.value = [offset + this._windowCenter, this._windowWidth];

      // invert
      this._uniforms.uInvert.value = this._invert === true ? 1 : 0;

      // interpolation
      this._uniforms.uInterpolation.value = this._interpolation;

      // lut
      if (this._lut === 'none') {
        this._uniforms.uLut.value = 0;
      } else {
        this._uniforms.uLut.value = 1;
        this._uniforms.uTextureLUT.value = this._lutTexture;
      }
    }
  }, {
    key: 'updateIntensitySetting',
    value: function updateIntensitySetting(setting) {
      if (this._stack.frame[this._index] && this._stack.frame[this._index][setting]) {
        this['_' + setting] = this._stack.frame[this._index][setting];
      } else {
        this['_' + setting] = this._stack[setting];
      }
    }
  }, {
    key: '_update',
    value: function _update() {
      // update slice
      if (this._mesh) {
        this.remove(this._mesh);
        this._mesh.geometry.dispose();
        this._mesh.geometry = null;
        // we do not want to dispose the texture!
        // this._mesh.material.dispose();
        // this._mesh.material = null;
        this._mesh = null;
      }

      this._create();
    }
  }, {
    key: 'dispose',
    value: function dispose() {
      // Release memory
      for (var j = 0; j < this._textures.length; j++) {
        this._textures[j].dispose();
        this._textures[j] = null;
      }
      this._textures = null;
      this._shadersFragment = null;
      this._shadersVertex = null;

      this._uniforms = null;

      // material, geometry and mesh
      this.remove(this._mesh);
      this._mesh.geometry.dispose();
      this._mesh.geometry = null;
      this._mesh.material.dispose();
      this._mesh.material = null;
      this._mesh = null;

      this._geometry.dispose();
      this._geometry = null;
      this._material.vertexShader = null;
      this._material.fragmentShader = null;
      this._material.uniforms = null;
      this._material.dispose();
      this._material = null;

      this._stack = null;
    }
  }, {
    key: 'cartesianEquation',
    value: function cartesianEquation() {
      // Make sure we have a geometry
      if (!this._geometry || !this._geometry.vertices || this._geometry.vertices.length < 3) {
        return new THREE.Vector4();
      }

      var vertices = this._geometry.vertices;
      var dataToWorld = this._stack.ijk2LPS;
      var p1 = new THREE.Vector3(vertices[0].x, vertices[0].y, vertices[0].z).applyMatrix4(dataToWorld);
      var p2 = new THREE.Vector3(vertices[1].x, vertices[1].y, vertices[1].z).applyMatrix4(dataToWorld);
      var p3 = new THREE.Vector3(vertices[2].x, vertices[2].y, vertices[2].z).applyMatrix4(dataToWorld);
      var v1 = new THREE.Vector3();
      var v2 = new THREE.Vector3();
      var normal = v1.subVectors(p3, p2).cross(v2.subVectors(p1, p2)).normalize();

      return new THREE.Vector4(normal.x, normal.y, normal.z, -normal.dot(p1));
    }
  }, {
    key: 'stack',
    get: function get() {
      return this._stack;
    },
    set: function set(stack) {
      this._stack = stack;
    }
  }, {
    key: 'windowWidth',
    get: function get() {
      return this._windowWidth;
    },
    set: function set(windowWidth) {
      this._windowWidth = windowWidth;
      this.updateIntensitySettingsUniforms();
    }
  }, {
    key: 'windowCenter',
    get: function get() {
      return this._windowCenter;
    },
    set: function set(windowCenter) {
      this._windowCenter = windowCenter;
      this.updateIntensitySettingsUniforms();
    }
  }, {
    key: 'rescaleSlope',
    get: function get() {
      return this._rescaleSlope;
    },
    set: function set(rescaleSlope) {
      this._rescaleSlope = rescaleSlope;
      this.updateIntensitySettingsUniforms();
    }
  }, {
    key: 'rescaleIntercept',
    get: function get() {
      return this._rescaleIntercept;
    },
    set: function set(rescaleIntercept) {
      this._rescaleIntercept = rescaleIntercept;
      this.updateIntensitySettingsUniforms();
    }
  }, {
    key: 'invert',
    get: function get() {
      return this._invert;
    },
    set: function set(invert) {
      this._invert = invert;
      this.updateIntensitySettingsUniforms();
    }
  }, {
    key: 'lut',
    get: function get() {
      return this._lut;
    },
    set: function set(lut) {
      this._lut = lut;
    }
  }, {
    key: 'lutTexture',
    get: function get() {
      return this._lutTexture;
    },
    set: function set(lutTexture) {
      this._lutTexture = lutTexture;
      this.updateIntensitySettingsUniforms();
    }
  }, {
    key: 'intensityAuto',
    get: function get() {
      return this._intensityAuto;
    },
    set: function set(intensityAuto) {
      this._intensityAuto = intensityAuto;
      this.updateIntensitySettings();
      this.updateIntensitySettingsUniforms();
    }
  }, {
    key: 'interpolation',
    get: function get() {
      return this._interpolation;
    },
    set: function set(interpolation) {
      this._interpolation = interpolation;
      this.updateIntensitySettingsUniforms();
      this._updateMaterial();
    }
  }, {
    key: 'index',
    get: function get() {
      return this._index;
    },
    set: function set(index) {
      this._index = index;
      this._update();
    }
  }, {
    key: 'planePosition',
    set: function set(position) {
      this._planePosition = position;
      this._update();
    },
    get: function get() {
      return this._planePosition;
    }
  }, {
    key: 'planeDirection',
    set: function set(direction) {
      this._planeDirection = direction;
      this._update();
    },
    get: function get() {
      return this._planeDirection;
    }
  }, {
    key: 'halfDimensions',
    set: function set(halfDimensions) {
      this._halfDimensions = halfDimensions;
    },
    get: function get() {
      return this._halfDimensions;
    }
  }, {
    key: 'center',
    set: function set(center) {
      this._center = center;
    },
    get: function get() {
      return this._center;
    }
  }, {
    key: 'aabbSpace',
    set: function set(aabbSpace) {
      this._aaBBspace = aabbSpace;
      this._init();
    },
    get: function get() {
      return this._aaBBspace;
    }
  }, {
    key: 'mesh',
    set: function set(mesh) {
      this._mesh = mesh;
    },
    get: function get() {
      return this._mesh;
    }
  }, {
    key: 'geometry',
    set: function set(geometry) {
      this._geometry = geometry;
    },
    get: function get() {
      return this._geometry;
    }
  }, {
    key: 'canvasWidth',
    set: function set(canvasWidth) {
      this._canvasWidth = canvasWidth;
      this._uniforms.uCanvasWidth.value = this._canvasWidth;
    },
    get: function get() {
      return this._canvasWidth;
    }
  }, {
    key: 'canvasHeight',
    set: function set(canvasHeight) {
      this._canvasHeight = canvasHeight;
      this._uniforms.uCanvasHeight.value = this._canvasHeight;
    },
    get: function get() {
      return this._canvasHeight;
    }
  }, {
    key: 'borderColor',
    set: function set(borderColor) {
      this._borderColor = borderColor;
      this._uniforms.uBorderColor.value = new THREE.Color(borderColor);
    },
    get: function get() {
      return this._borderColor;
    }
  }]);

  return HelpersSlice;
}((0, _helpersMaterial2.default)(THREE.Object3D));

exports.default = HelpersSlice;

},{"../geometries/geometries.slice":108,"../helpers/helpers.material.mixin":115,"../shaders/shaders.data.fragment":152,"../shaders/shaders.data.uniform":153,"../shaders/shaders.data.vertex":154}],119:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

var _helpers = require('../helpers/helpers.border');

var _helpers2 = _interopRequireDefault(_helpers);

var _helpers3 = require('../helpers/helpers.boundingbox');

var _helpers4 = _interopRequireDefault(_helpers3);

var _helpers5 = require('../helpers/helpers.slice');

var _helpers6 = _interopRequireDefault(_helpers5);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
} /** * Imports ***/

/**
 * Helper to easily display and interact with a stack.<br>
 *<br>
 * Defaults:<br>
 *   - orientation: 0 (acquisition direction)<br>
 *   - index: middle slice in acquisition direction<br>
 *<br>
 * Features:<br>
 *   - slice from the stack (in any direction)<br>
 *   - slice border<br>
 *   - stack bounding box<br>
 *<br>
 * Live demo at: {@link http://jsfiddle.net/gh/get/library/pure/fnndsc/ami/tree/master/lessons/01#run|Lesson 01}
 *
 * @example
 * let stack = new VJS.Models.Stack();
 * ... // prepare the stack
 *
 * let stackHelper = new VJS.Helpers.Stack(stack);
 * stackHelper.bbox.color = 0xF9F9F9;
 * stackHelper.border.color = 0xF9F9F9;
 *
 * let scene = new THREE.Scene();
 * scene.add(stackHelper);
 *
 * @extends THREE.Object3D
 *
 * @see module:helpers/border
 * @see module:helpers/boundingbox
 * @see module:helpers/slice
 *
 * @module helpers/stack
 */
var HelpersStack = function (_THREE$Object3D) {
  _inherits(HelpersStack, _THREE$Object3D);

  function HelpersStack(stack) {
    _classCallCheck(this, HelpersStack);

    var _this = _possibleConstructorReturn(this, (HelpersStack.__proto__ || Object.getPrototypeOf(HelpersStack)).call(this));
    //


    _this._stack = stack;
    _this._bBox = null;
    _this._slice = null;
    _this._border = null;
    _this._dummy = null;

    _this._orientation = 0;
    _this._index = 0;

    _this._uniforms = null;
    _this._autoWindowLevel = false;
    _this._outOfBounds = false;
    _this._orientationMaxIndex = 0;

    _this._canvasWidth = 0;
    _this._canvasHeight = 0;
    _this._borderColor = null;

    // this._arrow = {
    //   visible: true,
    //   color: 0xFFF336,
    //   length: 20,
    //   material: null,
    //   geometry: null,
    //   mesh: null
    // };
    _this._create();
    return _this;
  }

  //
  // PUBLIC METHODS
  //

  //
  // SETTERS/GETTERS
  //

  /**
   * Get stack.
   *
   * @type {ModelsStack}
   */

  _createClass(HelpersStack, [{
    key: '_create',

    //
    // PRIVATE METHODS
    //

    /**
     * Initial setup, including stack prepare, bbox prepare, slice prepare and
     * border prepare.
     *
     * @private
     */
    value: function _create() {
      if (this._stack) {
        // prepare sthe stack internals
        this._prepareStack();

        // prepare visual objects
        this._prepareBBox();
        this._prepareSlice();
        this._prepareBorder();
        // todo: Arrow
      } else {
        window.console.log('no stack to be prepared...');
      }
    }
  }, {
    key: '_computeOrientationMaxIndex',
    value: function _computeOrientationMaxIndex() {
      var dimensionsIJK = this._stack.dimensionsIJK;
      this._orientationMaxIndex = 0;
      switch (this._orientation) {
        case 0:
          this._orientationMaxIndex = dimensionsIJK.z - 1;
          break;
        case 1:
          this._orientationMaxIndex = dimensionsIJK.x - 1;
          break;
        case 2:
          this._orientationMaxIndex = dimensionsIJK.y - 1;
          break;
        default:
          // do nothing!
          break;
      }
    }

    /**
     * Given orientation, check if index is in/out of bounds.
     *
     * @private
     */

  }, {
    key: '_isIndexOutOfBounds',
    value: function _isIndexOutOfBounds() {
      this._computeOrientationMaxIndex();
      if (this._index >= this._orientationMaxIndex || this._index < 0) {
        this._outOfBounds = true;
      } else {
        this._outOfBounds = false;
      }
    }

    /**
     * Prepare a stack for visualization. (image to world transform, frames order,
     * pack data into 8 bits textures, etc.)
     *
     * @private
     */

  }, {
    key: '_prepareStack',
    value: function _prepareStack() {
      // make sure there is something, if not throw an error
      // compute image to workd transform, order frames, etc.
      if (!this._stack.prepared) {
        this._stack.prepare();
      }
      // pack data into 8 bits rgba texture for the shader
      // this one can be slow...
      if (!this._stack.packed) {
        this._stack.pack();
      }
    }

    /**
     * Setup bounding box helper given prepared stack and add bounding box helper
     * to stack helper.
     *
     * @private
     */

  }, {
    key: '_prepareBBox',
    value: function _prepareBBox() {
      this._bBox = new _helpers4.default(this._stack);
      this.add(this._bBox);
    }

    /**
     * Setup border helper given slice helper and add border helper
     * to stack helper.
     *
     * @private
     */

  }, {
    key: '_prepareBorder',
    value: function _prepareBorder() {
      this._border = new _helpers2.default(this._slice);
      this.add(this._border);
    }

    /**
     * Setup slice helper given prepared stack helper and add slice helper
     * to stack helper.
     *
     * @private
     */

  }, {
    key: '_prepareSlice',
    value: function _prepareSlice() {
      var halfDimensionsIJK = this._stack.halfDimensionsIJK;
      // compute initial index given orientation
      this._index = this._prepareSliceIndex(halfDimensionsIJK);
      // compute initial position given orientation and index
      var position = this._prepareSlicePosition(halfDimensionsIJK, this._index);
      // compute initial direction orientation
      var direction = this._prepareDirection(this._orientation);

      this._slice = new _helpers6.default(this._stack, this._index, position, direction);
      this.add(this._slice);
    }

    /**
     * Compute slice index depending on orientation.
     *
     * @param {THREE.Vector3} indices - Indices in each direction.
     *
     * @returns {number} Slice index according to current orientation.
     *
     * @private
     */

  }, {
    key: '_prepareSliceIndex',
    value: function _prepareSliceIndex(indices) {
      var index = 0;
      switch (this._orientation) {
        case 0:
          index = Math.floor(indices.z);
          break;
        case 1:
          index = Math.floor(indices.x);
          break;
        case 2:
          index = Math.floor(indices.y);
          break;
        default:
          // do nothing!
          break;
      }
      return index;
    }

    /**
     * Compute slice position depending on orientation.
     * Sets index in proper location of reference position.
     *
     * @param {THREE.Vector3} rPosition - Reference position.
     * @param {number} index - Current index.
     *
     * @returns {number} Slice index according to current orientation.
     *
     * @private
     */

  }, {
    key: '_prepareSlicePosition',
    value: function _prepareSlicePosition(rPosition, index) {
      var position = new THREE.Vector3(0, 0, 0);
      switch (this._orientation) {
        case 0:
          position = new THREE.Vector3(Math.floor(rPosition.x), Math.floor(rPosition.y), index);
          break;
        case 1:
          position = new THREE.Vector3(index, Math.floor(rPosition.y), Math.floor(rPosition.z));
          break;
        case 2:
          position = new THREE.Vector3(Math.floor(rPosition.x), index, Math.floor(rPosition.z));
          break;
        default:
          // do nothing!
          break;
      }
      return position;
    }

    /**
     * Compute slice direction depending on orientation.
     *
     * @param {number} orientation - Slice orientation.
     *
     * @returns {THREE.Vector3} Slice direction
     *
     * @private
     */

  }, {
    key: '_prepareDirection',
    value: function _prepareDirection(orientation) {
      var direction = new THREE.Vector3(0, 0, 1);
      switch (orientation) {
        case 0:
          direction = new THREE.Vector3(0, 0, 1);
          break;
        case 1:
          direction = new THREE.Vector3(1, 0, 0);
          break;
        case 2:
          direction = new THREE.Vector3(0, 1, 0);
          break;
        default:
          // do nothing!
          break;
      }

      return direction;
    }

    /**
     * Release the stack helper memory including the slice memory.
     *
     * @public
     */

  }, {
    key: 'dispose',
    value: function dispose() {
      this.remove(this._slice);
      this._slice.dispose();
      this._slice = null;
      this._bBox.dispose();
      this._bBox = null;
      this._border.dispose();
      this._border = null;
    }
  }, {
    key: 'stack',
    get: function get() {
      return this._stack;
    }

    /**
     * Set stack.
     *
     * @type {ModelsStack}
     */

    , set: function set(stack) {
      this._stack = stack;
    }

    /**
     * Get bounding box helper.
     *
     * @type {HelpersBoundingBox}
     */

  }, {
    key: 'bbox',
    get: function get() {
      return this._bBox;
    }

    /**
     * Get slice helper.
     *
     * @type {HelpersSlice}
     */

  }, {
    key: 'slice',
    get: function get() {
      return this._slice;
    }

    /**
     * Get border helper.
     *
     * @type {HelpersSlice}
     */

  }, {
    key: 'border',
    get: function get() {
      return this._border;
    }

    /**
     * Set/get current slice index.<br>
     * Sets outOfBounds flag to know if target index is in/out stack bounding box.<br>
     * <br>
     * Internally updates the sliceHelper index and position. Also updates the
     * borderHelper with the updated sliceHelper.
     *
     * @type {number}
     */

  }, {
    key: 'index',
    get: function get() {
      return this._index;
    },
    set: function set(index) {
      this._index = index;

      // update the slice
      this._slice.index = index;
      var halfDimensions = this._stack.halfDimensionsIJK;
      this._slice.planePosition = this._prepareSlicePosition(halfDimensions, this._index);

      // also update the border
      this._border.helpersSlice = this._slice;

      // update ourOfBounds flag
      this._isIndexOutOfBounds();
    }

    /**
     * Set/get current slice orientation.<br>
     * Values: <br>
     *   - 0: acquisition direction (slice normal is z_cosine)<br>
     *   - 1: next direction (slice normal is x_cosine)<br>
     *   - 2: next direction (slice normal is y_cosine)<br>
     *   - n: set orientation to 0<br>
     * <br>
     * Internally updates the sliceHelper direction. Also updates the
     * borderHelper with the updated sliceHelper.
     *
     * @type {number}
     */

  }, {
    key: 'orientation',
    set: function set(orientation) {
      this._orientation = orientation;
      this._computeOrientationMaxIndex();

      this._slice.planeDirection = this._prepareDirection(this._orientation);

      // also update the border
      this._border.helpersSlice = this._slice;
    },
    get: function get() {
      return this._orientation;
    }

    /**
     * Set/get the outOfBound flag.
     *
     * @type {boolean}
     */

  }, {
    key: 'outOfBounds',
    set: function set(outOfBounds) {
      this._outOfBounds = outOfBounds;
    },
    get: function get() {
      return this._outOfBounds;
    }

    /**
     * Set/get the orientationMaxIndex flag.
     *
     * @type {boolean}
     */

  }, {
    key: 'orientationMaxIndex',
    set: function set(orientationMaxIndex) {
      this._orientationMaxIndex = orientationMaxIndex;
    },
    get: function get() {
      return this._orientationMaxIndex;
    }
  }, {
    key: 'canvasWidth',
    set: function set(canvasWidth) {
      this._canvasWidth = canvasWidth;
      this._slice.canvasWidth = this._canvasWidth;
    },
    get: function get() {
      return this._canvasWidth;
    }
  }, {
    key: 'canvasHeight',
    set: function set(canvasHeight) {
      this._canvasHeight = canvasHeight;
      this._slice.canvasHeight = this._canvasHeight;
    },
    get: function get() {
      return this._canvasHeight;
    }
  }, {
    key: 'borderColor',
    set: function set(borderColor) {
      this._borderColor = borderColor;
      this._border.color = borderColor;
      this._slice.borderColor = this._borderColor;
    },
    get: function get() {
      return this._borderColor;
    }
  }]);

  return HelpersStack;
}(THREE.Object3D);

exports.default = HelpersStack;

},{"../helpers/helpers.border":110,"../helpers/helpers.boundingbox":111,"../helpers/helpers.slice":118}],120:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

var _shadersVr = require('../shaders/shaders.vr.uniform');

var _shadersVr2 = _interopRequireDefault(_shadersVr);

var _shadersVr3 = require('../shaders/shaders.vr.vertex');

var _shadersVr4 = _interopRequireDefault(_shadersVr3);

var _shadersVr5 = require('../shaders/shaders.vr.fragment');

var _shadersVr6 = _interopRequireDefault(_shadersVr5);

var _helpersMaterial = require('../helpers/helpers.material.mixin');

var _helpersMaterial2 = _interopRequireDefault(_helpersMaterial);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
} /** * Imports ***/

/**
 * @module helpers/volumerendering
 */

var HelpersVolumeRendering = function (_HelpersMaterialMixin) {
  _inherits(HelpersVolumeRendering, _HelpersMaterialMixin);

  function HelpersVolumeRendering(stack) {
    _classCallCheck(this, HelpersVolumeRendering);

    var _this = _possibleConstructorReturn(this, (HelpersVolumeRendering.__proto__ || Object.getPrototypeOf(HelpersVolumeRendering)).call(this));
    //


    _this._stack = stack;
    _this._textures = [];
    _this._shadersFragment = _shadersVr6.default;
    _this._shadersVertex = _shadersVr4.default;
    _this._uniforms = _shadersVr2.default.uniforms();
    _this._material = null;
    _this._geometry = null;

    _this._interpolation = 1; // default to trilinear interpolation

    _this._create();
    return _this;
  }

  _createClass(HelpersVolumeRendering, [{
    key: '_create',
    value: function _create() {
      this._prepareStack();
      this._prepareTexture();
      this._prepareMaterial();
      this._prepareGeometry();

      this._mesh = new THREE.Mesh(this._geometry, this._material);
      this.add(this._mesh);
    }
  }, {
    key: '_prepareStack',
    value: function _prepareStack() {
      if (!this._stack.prepared) {
        this._stack.prepare();
      }

      if (!this._stack.packed) {
        this._stack.pack();
      }
    }
  }, {
    key: '_prepareMaterial',
    value: function _prepareMaterial() {
      // compensate for the offset to only pass > 0 values to shaders
      // models > models.stack.js : _packTo8Bits
      var offset = 0;
      if (this._stack._minMax[0] < 0) {
        offset = this._stack._minMax[0];
      }

      // uniforms
      this._uniforms = _shadersVr2.default.uniforms();
      this._uniforms.uWorldBBox.value = this._stack.worldBoundingBox();
      this._uniforms.uTextureSize.value = this._stack.textureSize;
      this._uniforms.uTextureContainer.value = this._textures;
      this._uniforms.uWorldToData.value = this._stack.lps2IJK;
      this._uniforms.uNumberOfChannels.value = this._stack.numberOfChannels;
      this._uniforms.uPixelType.value = this._stack.pixelType;
      this._uniforms.uBitsAllocated.value = this._stack.bitsAllocated;
      this._uniforms.uPackedPerPixel.value = this._stack.packedPerPixel;
      this._uniforms.uWindowCenterWidth.value = [offset + this._stack.windowCenter, this._stack.windowWidth * 0.8];
      this._uniforms.uRescaleSlopeIntercept.value = [this._stack.rescaleSlope, this._stack.rescaleIntercept];
      this._uniforms.uDataDimensions.value = [this._stack.dimensionsIJK.x, this._stack.dimensionsIJK.y, this._stack.dimensionsIJK.z];
      this._uniforms.uInterpolation.value = this._interpolation;

      this._createMaterial({
        side: THREE.FrontSide,
        transparent: true
      });
    }
  }, {
    key: '_prepareGeometry',
    value: function _prepareGeometry() {
      var worldBBox = this._stack.worldBoundingBox();
      var centerLPS = this._stack.worldCenter();

      this._geometry = new THREE.BoxGeometry(worldBBox[1] - worldBBox[0], worldBBox[3] - worldBBox[2], worldBBox[5] - worldBBox[4]);
      this._geometry.applyMatrix(new THREE.Matrix4().makeTranslation(centerLPS.x, centerLPS.y, centerLPS.z));
    }
  }, {
    key: 'uniforms',
    get: function get() {
      return this._uniforms;
    },
    set: function set(uniforms) {
      this._uniforms = uniforms;
    }
  }, {
    key: 'stack',
    get: function get() {
      return this._stack;
    },
    set: function set(stack) {
      this._stack = stack;
    }
  }, {
    key: 'interpolation',
    get: function get() {
      return this._interpolation;
    },
    set: function set(interpolation) {
      this._interpolation = interpolation;
      this._uniforms.uInterpolation.value = this._interpolation;
      this._updateMaterial();
    }
  }]);

  return HelpersVolumeRendering;
}((0, _helpersMaterial2.default)(THREE.Object3D));

exports.default = HelpersVolumeRendering;

},{"../helpers/helpers.material.mixin":115,"../shaders/shaders.vr.fragment":162,"../shaders/shaders.vr.uniform":163,"../shaders/shaders.vr.vertex":164}],121:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

/**
 * @module helpers/x/interactor
 */
var Interactor = function () {
  function Interactor() {
    _classCallCheck(this, Interactor);
  }

  // private methods


  _createClass(Interactor, [{
    key: "_create",
    value: function _create() {}
  }, {
    key: "_update",
    value: function _update() {}
  }]);

  return Interactor;
}();

exports.default = Interactor;

},{}],122:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _helpersX = require('./helpers.x.interactor');

var _helpersX2 = _interopRequireDefault(_helpersX);

var _helpersX3 = require('./helpers.x.mesh');

var _helpersX4 = _interopRequireDefault(_helpersX3);

var _helpersX5 = require('./helpers.x.renderer3d');

var _helpersX6 = _interopRequireDefault(_helpersX5);

var _helpersX7 = require('./helpers.x.renderer2d');

var _helpersX8 = _interopRequireDefault(_helpersX7);

var _helpersX9 = require('./helpers.x.volume');

var _helpersX10 = _interopRequireDefault(_helpersX9);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

/**
 * @module helpers
 */

exports.default = {
  Interactor: _helpersX2.default,
  Mesh: _helpersX4.default,
  Renderer3D: _helpersX6.default,
  Renderer2D: _helpersX8.default,
  Volume: _helpersX10.default
};

},{"./helpers.x.interactor":121,"./helpers.x.mesh":123,"./helpers.x.renderer2d":124,"./helpers.x.renderer3d":125,"./helpers.x.volume":126}],123:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

/**
 * @module helpers/x/mesh
 */
var _class = function () {
  function _class() {
    _classCallCheck(this, _class);

    this._file = null;

    this._3jsVTK_loader = new THREE.VTKLoader();
    this._mesh = null;
    this._materialColor = 0xE91E63;
    this._RAStoLPS = null;
    this._material = new THREE.MeshLambertMaterial({
      shading: THREE.SmoothShading,
      color: this._materialColor,
      side: THREE.DoubleSide });
  }

  // accessor properties


  _createClass(_class, [{
    key: "load",

    // load function
    value: function load() {
      var _this = this;

      if (this.file) {
        return new Promise(function (resolve, reject) {
          _this._3jsVTK_loader.load(_this.file, function (geometry) {
            geometry.computeVertexNormals();
            _this._mesh = new THREE.Mesh(geometry, _this._material);
            _this._RAStoLPS = new THREE.Matrix4();
            _this._RAStoLPS.set(-1, 0, 0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
            _this._mesh.applyMatrix(_this._RAStoLPS);
            // resolve the promise and return the mesh
            resolve(_this._mesh);
          }, function () {}, function (error) {
            console.log(error);
            reject({
              message: "Couldn't load file: " + _this.file + ".",
              error: error
            });
          });
        });
      }

      return Promise.reject({ message: "File is not defined: " + this.file + "." });
    }
  }, {
    key: "file",
    get: function get() {
      return this._file;
    },
    set: function set(fname) {
      this._file = fname;
    }
  }, {
    key: "materialColor",
    get: function get() {
      return this._materialColor;
    },
    set: function set(color) {
      this._materialColor = color;
    }
  }]);

  return _class;
}();

exports.default = _class;

},{}],124:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}(); /**
      * @module helpers/x/renderer2d
      */

var _cameras = require('../../cameras/cameras.orthographic');

var _cameras2 = _interopRequireDefault(_cameras);

var _controls = require('../../controls/controls.trackballortho');

var _controls2 = _interopRequireDefault(_controls);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

var _class = function () {
  function _class() {
    var containerId = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'r2d';
    var orientation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'default';

    _classCallCheck(this, _class);

    this._container = null;
    this._renderer = null;
    this._camera = null;
    this._controls = null;
    this._orientation = orientation;
    this._scene = null;
    this._object = null;

    this._initRenderer(containerId);
    this._initCamera();
    this._initScene();
    this._initControls();

    // setup event listeners
    this._onScroll = this._onScroll.bind(this);
    this._onWindowResize = this._onWindowResize.bind(this);
    this.addEventListeners();
  }

  _createClass(_class, [{
    key: 'add',
    value: function add(object) {
      this._object = object;
      this._scene.add(this._object);

      this._setupCamera(this._object.stack);
      this._orientCamera(this._object, this._orientation);

      this._object.canvasWidth = this._container.clientWidth;
      this._object.canvasHeight = this._container.clientHeight;
    }
  }, {
    key: 'addEventListeners',
    value: function addEventListeners() {
      this._controls.addEventListener('OnScroll', this._onScroll, false);
      window.addEventListener('resize', this._onWindowResize, false);
    }
  }, {
    key: 'removeEventListeners',
    value: function removeEventListeners() {
      this._controls.removeEventListener('OnScroll', this._onScroll, false);
      window.removeEventListener('resize', this._onWindowResize, false);
    }
  }, {
    key: 'animate',
    value: function animate() {
      this._controls.update();
      this._renderer.render(this._scene, this._camera);

      // request new frame
      requestAnimationFrame(this.animate.bind(this));
    }

    // private methods

  }, {
    key: '_initRenderer',
    value: function _initRenderer(containerId) {
      // renderer
      this._container = document.getElementById(containerId);
      this._renderer = new THREE.WebGLRenderer({
        antialias: true
      });
      this._renderer.setSize(this._container.clientWidth, this._container.clientHeight);
      this._renderer.setClearColor(0x212121, 1);
      this._renderer.setPixelRatio(window.devicePixelRatio);
      this._container.appendChild(this._renderer.domElement);
    }
  }, {
    key: '_initCamera',
    value: function _initCamera() {
      this._camera = new _cameras2.default(this._container.clientWidth / -2, this._container.clientWidth / 2, this._container.clientHeight / 2, this._container.clientHeight / -2, 1, 1000);
    }
  }, {
    key: '_initScene',
    value: function _initScene() {
      this._scene = new THREE.Scene();
    }
  }, {
    key: '_initControls',
    value: function _initControls() {
      // controls
      this._controls = new _controls2.default(this._camera, this._container);
      this._controls.staticMoving = true;
      this._controls.noRotate = true;
      this._camera.controls = this._controls;
    }
  }, {
    key: '_setupCamera',
    value: function _setupCamera(stack) {
      // set camera
      var worldbb = stack.worldBoundingBox();
      var lpsDims = new THREE.Vector3(worldbb[1] - worldbb[0], worldbb[3] - worldbb[2], worldbb[5] - worldbb[4]);

      // box: {halfDimensions, center}
      var box = {
        center: stack.worldCenter().clone(),
        halfDimensions: new THREE.Vector3(lpsDims.x + 10, lpsDims.y + 10, lpsDims.z + 10)
      };

      // init and zoom
      var canvas = {
        width: this._container.clientWidth,
        height: this._container.clientHeight
      };

      this._camera.directions = [stack.xCosine, stack.yCosine, stack.zCosine];
      this._camera.box = box;
      this._camera.canvas = canvas;
      this._camera.update();
      this._camera.fitBox(2);
    }
  }, {
    key: '_orientCamera',
    value: function _orientCamera(target) {
      var orientation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'default';

      this._camera.orientation = orientation;
      this._camera.update();
      this._camera.fitBox(2);
      target.orientation = this._camera.stackOrientation;
    }
  }, {
    key: '_onWindowResize',
    value: function _onWindowResize() {
      this._camera.canvas = {
        width: this._container.clientWidth,
        height: this._container.clientHeight
      };
      this._camera.fitBox(2);
      this._renderer.setSize(this._container.clientWidth, this._container.clientHeight);
      this._object.canvasWidth = this._container.clientWidth;
      this._object.canvasHeight = this._container.clientHeight;
    }
  }, {
    key: '_onScroll',
    value: function _onScroll(event) {
      if (event.delta > 0) {
        if (this._object.index >= this._object.orientationMaxIndex) {
          return false;
        }
        this._object.index += 1;
      } else {
        if (this._object.index <= 0) {
          return false;
        }
        this._object.index -= 1;
      }
    }
  }]);

  return _class;
}();

exports.default = _class;

},{"../../cameras/cameras.orthographic":97,"../../controls/controls.trackballortho":100}],125:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}(); /**
      * @module helpers/x/renderer3d
      */

var _controls = require('../../controls/controls.trackball');

var _controls2 = _interopRequireDefault(_controls);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

var _class = function () {
  function _class() {
    var containerId = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'r3d';

    _classCallCheck(this, _class);

    this._container = null;
    this._renderer = null;
    this._camera = null;
    this._controls = null;
    this._scene = null;

    this._initRenderer(containerId);
    this._initCamera();
    this._initScene();
    this._initControls();

    // setup event listeners
    this._onWindowResize = this._onWindowResize.bind(this);
    this.addEventListeners();
  }

  _createClass(_class, [{
    key: 'add',
    value: function add(obj) {
      this._scene.add(obj);
    }
  }, {
    key: 'addEventListeners',
    value: function addEventListeners() {
      window.addEventListener('resize', this._onWindowResize, false);
    }
  }, {
    key: 'removeEventListeners',
    value: function removeEventListeners() {
      window.removeEventListener('resize', this._onWindowResize, false);
    }
  }, {
    key: 'center',
    value: function center(worldPosition) {
      // update camrea's and control's target
      this._camera.lookAt(worldPosition.x, worldPosition.y, worldPosition.z);
      this._camera.updateProjectionMatrix();
      this._controls.target.set(worldPosition.x, worldPosition.y, worldPosition.z);
    }
  }, {
    key: 'animate',
    value: function animate() {
      this._controls.update();
      this._renderer.render(this._scene, this._camera);

      // request new frame
      requestAnimationFrame(this.animate.bind(this));
    }

    // private methods

  }, {
    key: '_onWindowResize',
    value: function _onWindowResize() {
      this._camera.aspect = this._container.clientWidth / this._container.clientHeight;
      this._camera.updateProjectionMatrix();

      this._renderer.setSize(this._container.clientWidth, this._container.clientHeight);
    }
  }, {
    key: '_initRenderer',
    value: function _initRenderer(containerId) {
      // renderer
      this._container = document.getElementById(containerId);
      this._renderer = new THREE.WebGLRenderer({
        antialias: true
      });
      this._renderer.setSize(this._container.clientWidth, this._container.clientHeight);
      this._renderer.setClearColor(0x424242, 1);
      this._renderer.setPixelRatio(window.devicePixelRatio);
      this._container.appendChild(this._renderer.domElement);
    }
  }, {
    key: '_initCamera',
    value: function _initCamera() {
      this._camera = new THREE.PerspectiveCamera(45, this._container.clientWidth / this._container.clientHeight, 1, 10000000);
      this._camera.position.x = 250;
      this._camera.position.y = 250;
      this._camera.position.z = 250;
    }
  }, {
    key: '_initScene',
    value: function _initScene() {
      // add some lights to the scene by default
      this._scene = new THREE.Scene();

      // ambient
      this._scene.add(new THREE.AmbientLight(0x353535));

      // directional 1
      var directionalLight = new THREE.DirectionalLight(0xffffff, 1);
      directionalLight.position.set(200, 200, 1000).normalize();
      this._scene.add(directionalLight);

      // directional 2
      var directionalLight2 = new THREE.DirectionalLight(0xffffff, 1);
      directionalLight2.position.set(-200, -200, -1000).normalize();
      this._scene.add(directionalLight2);
    }
  }, {
    key: '_initControls',
    value: function _initControls() {
      // controls
      this._controls = new _controls2.default(this._camera, this._container);
      this._controls.rotateSpeed = 1.4;
      this._controls.zoomSpeed = 1.2;
      this._controls.panSpeed = 0.8;
    }
  }, {
    key: 'container',
    set: function set(container) {
      this._container = container;
    },
    get: function get() {
      return this._container;
    }
  }]);

  return _class;
}();

exports.default = _class;

},{"../../controls/controls.trackball":99}],126:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

var _helpers = require('../helpers.stack');

var _helpers2 = _interopRequireDefault(_helpers);

var _loaders = require('../../loaders/loaders.volume');

var _loaders2 = _interopRequireDefault(_loaders);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
} /**
   * @module helpers/x/volume
   */

var _class = function (_THREE$Object3D) {
  _inherits(_class, _THREE$Object3D);

  function _class() {
    _classCallCheck(this, _class);

    var _this = _possibleConstructorReturn(this, (_class.__proto__ || Object.getPrototypeOf(_class)).call(this));

    _this._file = null;
    _this._progressbarContainer = null;
    _this._stack = null;
    _this._centerLPS = null;
    _this._xSlice = null;
    _this._ySlice = null;
    _this._zSlice = null;
    return _this;
  }

  // accessor properties


  _createClass(_class, [{
    key: '_createSlice',

    // private methods
    value: function _createSlice(orientation) {
      if (this._stack) {
        var stackHelper = new _helpers2.default(this._stack);
        stackHelper.orientation = orientation;

        if (orientation === 0) {
          stackHelper.border.color = 0xF44336;
          this._xSlice = stackHelper;
        } else if (orientation === 1) {
          stackHelper.bbox.visible = false;
          stackHelper.border.color = 0x4CAF50;
          this._ySlice = stackHelper;
        } else {
          stackHelper.bbox.visible = false;
          stackHelper.border.color = 0x2196F3;
          this._zSlice = stackHelper;
        }

        this._centerLPS = stackHelper.stack.worldCenter();
      }
    }

    // public methods

  }, {
    key: 'load',
    value: function load() {
      var _this2 = this;

      if (this.file) {
        // instantiate the loader
        // it loads and parses the dicom image
        var loader = new _loaders2.default(this._progressbarContainer);
        return loader.load(this.file).then(function () {
          return new Promise(function (resolve, reject) {
            if (loader.data.length <= 0) {
              return reject({ message: 'No data loaded: ' + loader.data + '.' });
            }

            // create the three slices when all files have been loaded
            var series = loader.data[0].mergeSeries(loader.data)[0];
            loader.free();

            _this2._stack = series.stack[0];
            _this2._createSlice(0);
            _this2.add(_this2._xSlice);
            _this2._createSlice(1);
            _this2.add(_this2._ySlice);
            _this2._createSlice(2);
            _this2.add(_this2._zSlice);

            return resolve(_this2);
          });
        }).catch(function (error) {
          loader.free();
          window.console.log('Something went wrong loading the volume...');
          window.console.log(error);
        });
      }

      return Promise.reject({ message: 'File not defined: ' + this.file + '.' });
    }
  }, {
    key: 'file',
    get: function get() {
      return this._file;
    },
    set: function set(fname) {
      this._file = fname;
    }
  }, {
    key: 'progressbarContainer',
    set: function set(container) {
      this._progressbarContainer = container;
    }
  }, {
    key: 'centerLPS',
    get: function get() {
      return this._centerLPS;
    }
  }, {
    key: 'stack',
    get: function get() {
      return this._stack;
    }
  }]);

  return _class;
}(THREE.Object3D);

exports.default = _class;

},{"../../loaders/loaders.volume":129,"../helpers.stack":119}],127:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

var _helpers = require('../helpers/helpers.progressbar');

var _helpers2 = _interopRequireDefault(_helpers);

var _events = require('events');

var _events2 = _interopRequireDefault(_events);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
} /** Imports **/

/**
 *
 * It is typically used to load a DICOM image. Use loading manager for
 * advanced usage, such as multiple files handling.
 *
 * Demo: {@link https://fnndsc.github.io/vjs#loader_dicom}
 *
 * @module loaders/base
 * @extends EventEmitter
 * @example
 * var files = ['/data/dcm/fruit'];
 *
 * // Instantiate a dicom loader
 * var lDicomoader = new dicom();
 *
 * // load a resource
 * loader.load(
 *   // resource URL
 *   files[0],
 *   // Function when resource is loaded
 *   function(object) {
 *     //scene.add( object );
 *     window.console.log(object);
 *   }
 * );
 */
var LoadersBase = function (_EventEmitter) {
  _inherits(LoadersBase, _EventEmitter);

  /**
   * Create a Loader.
   * @param {dom} container - The dom container of loader.
   * @param {object} ProgressBar - The progressbar of loader.
   */
  function LoadersBase() {
    var container = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    var ProgressBar = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _helpers2.default;

    _classCallCheck(this, LoadersBase);

    var _this = _possibleConstructorReturn(this, (LoadersBase.__proto__ || Object.getPrototypeOf(LoadersBase)).call(this));

    _this._loaded = -1;
    _this._totalLoaded = -1;
    _this._parsed = -1;
    _this._totalParsed = -1;

    _this._data = [];

    _this._container = container;
    _this._progressBar = null;
    if (_this._container && ProgressBar) {
      _this._progressBar = new ProgressBar(_this._container);
    }
    return _this;
  }

  /**
   * free the reference.
   */

  _createClass(LoadersBase, [{
    key: 'free',
    value: function free() {
      this._container = null;
      // this._helpersProgressBar = null;

      if (this._progressBar) {
        this._progressBar.free();
        this._progressBar = null;
      }
    }

    /**
     * load the resource by url.
     * @param {string} url - resource url.
     * @return {promise} promise.
     */

  }, {
    key: 'fetch',
    value: function fetch(url) {
      var _this2 = this;

      return new Promise(function (resolve, reject) {
        var request = new XMLHttpRequest();
        request.open('GET', url);
        request.crossOrigin = true;
        request.responseType = 'arraybuffer';

        request.onloadstart = function (event) {
          // emit 'fetch-start' event
          _this2.emit('fetch-start', {
            file: url,
            time: new Date()
          });
        };

        request.onload = function (event) {
          if (request.status === 200) {
            _this2._loaded = event.loaded;
            _this2._totalLoaded = event.total;

            // will be removed after eventer set up
            if (_this2._progressBar) {
              _this2._progressBar.update(_this2._loaded, _this2._totalLoaded, 'load');
            }

            var buffer = request.response;
            var response = {
              url: url,
              buffer: buffer
            };

            // emit 'fetch-success' event
            _this2.emit('fetch-success', {
              file: url,
              time: new Date(),
              totalLoaded: event.total
            });

            resolve(response);
          } else {
            reject(request.statusText);
          }
        };

        request.onerror = function () {
          // emit 'fetch-error' event
          _this2.emit('fetch-error', {
            file: url,
            time: new Date()
          });

          reject(request.statusText);
        };

        request.onabort = function (event) {
          // emit 'fetch-start' event
          _this2.emit('fetch-abort', {
            file: url,
            time: new Date()
          });

          reject(request.statusText);
        };

        request.ontimeout = function () {
          // emit 'fetch-timeout' event
          _this2.emit('fetch-timeout', {
            file: url,
            time: new Date()
          });

          reject(request.statusText);
        };

        request.onprogress = function (event) {
          _this2._loaded = event.loaded;
          _this2._totalLoaded = event.total;
          // emit 'fetch-progress' event
          _this2.emit('fetch-progress', {
            file: url,
            total: event.total,
            loaded: event.loaded,
            time: new Date()
          });
          // will be removed after eventer set up
          if (_this2._progressBar) {
            _this2._progressBar.update(_this2._loaded, _this2._totalLoaded, 'load');
          }
        };

        request.onloadend = function (event) {
          // emit 'fetch-end' event
          _this2.emit('fetch-end', {
            file: url,
            time: new Date()
          });
          // just use onload when success and onerror when failure, etc onabort
          // reject(request.statusText);
        };

        request.send();
      });
    }

    /**
     * parse the data loaded
     * SHOULD BE implementd by detail loader.
     * @param {object} response - loaded data.
     * @return {promise} promise.
     */

  }, {
    key: 'parse',
    value: function parse(response) {
      return new Promise(function (resolve, reject) {
        resolve(response);
      });
    }

    /**
     * default load sequence group promise.
     * @param {array} url - resource url.
     * @return {promise} promise.
     */

  }, {
    key: 'loadSequenceGroup',
    value: function loadSequenceGroup(url) {
      var _this3 = this;

      var fetchSequence = [];

      url.forEach(function (file) {
        fetchSequence.push(_this3.fetch(file));
      });

      return Promise.all(fetchSequence).then(function (rawdata) {
        return _this3.parse(rawdata);
      }).then(function (data) {
        _this3._data.push(data);
        return data;
      }).catch(function (error) {
        window.console.log('oops... something went wrong...');
        window.console.log(error);
      });
    }

    /**
     * default load sequence promise.
     * @param {string} url - resource url.
     * @return {promise} promise.
     */

  }, {
    key: 'loadSequence',
    value: function loadSequence(url) {
      var _this4 = this;

      return this.fetch(url).then(function (rawdata) {
        return _this4.parse(rawdata);
      }).then(function (data) {
        _this4._data.push(data);
        return data;
      }).catch(function (error) {
        window.console.log('oops... something went wrong...');
        window.console.log(error);
      });
    }

    /**
     * load the data by url(urls)
     * @param {string|array} url - resource url.
     * @return {promise} promise
     */

  }, {
    key: 'load',
    value: function load(url) {
      var _this5 = this;

      // if we load a single file, convert it to an array
      if (!Array.isArray(url)) {
        url = [url];
      }

      // emit 'load-start' event
      this.emit('load-start', {
        files: url,
        time: new Date()
      });

      var loadSequences = [];
      url.forEach(function (file) {
        if (!Array.isArray(file)) {
          loadSequences.push(_this5.loadSequence(file));
        } else {
          loadSequences.push(_this5.loadSequenceGroup(file));
        }
      });
      return Promise.all(loadSequences);
    }

    /**
     * Set data
     * @param {array} data
     */

  }, {
    key: 'data',
    set: function set(data) {
      this._data = data;
    }

    /**
     * Get data
     * @return {array} data loaded
     */

    , get: function get() {
      return this._data;
    }
  }]);

  return LoadersBase;
}(_events2.default);

exports.default = LoadersBase;

},{"../helpers/helpers.progressbar":117,"events":26}],128:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _loaders = require('./loaders.volume');

var _loaders2 = _interopRequireDefault(_loaders);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

/**
 * @module loaders
 */

exports.default = {
  Volume: _loaders2.default
};

},{"./loaders.volume":129}],129:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

var _loaders = require('./loaders.base');

var _loaders2 = _interopRequireDefault(_loaders);

var _core = require('../core/core.utils');

var _core2 = _interopRequireDefault(_core);

var _models = require('../models/models.series');

var _models2 = _interopRequireDefault(_models);

var _models3 = require('../models/models.stack');

var _models4 = _interopRequireDefault(_models3);

var _models5 = require('../models/models.frame');

var _models6 = _interopRequireDefault(_models5);

var _parsers = require('../parsers/parsers.dicom');

var _parsers2 = _interopRequireDefault(_parsers);

var _parsers3 = require('../parsers/parsers.mhd');

var _parsers4 = _interopRequireDefault(_parsers3);

var _parsers5 = require('../parsers/parsers.nifti');

var _parsers6 = _interopRequireDefault(_parsers5);

var _parsers7 = require('../parsers/parsers.nrrd');

var _parsers8 = _interopRequireDefault(_parsers7);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

/** * Imports ***/
var PAKO = require('pako');

/**
 *
 * It is typically used to load a DICOM image. Use loading manager for
 * advanced usage, such as multiple files handling.
 *
 * Demo: {@link https://fnndsc.github.io/vjs#loader_dicom}
 *
 * @module loaders/volumes
 * @extends LoadersBase
 * @example
 * var files = ['/data/dcm/fruit'];
 *
 * // Instantiate a dicom loader
 * var lDicomoader = new dicom();
 *
 * // load a resource
 * loader.load(
 *   // resource URL
 *   files[0],
 *   // Function when resource is loaded
 *   function(object) {
 *     //scene.add( object );
 *     window.console.log(object);
 *   }
 * );
 */
var LoadersVolumes = function (_LoadersBase) {
  _inherits(LoadersVolumes, _LoadersBase);

  function LoadersVolumes() {
    _classCallCheck(this, LoadersVolumes);

    return _possibleConstructorReturn(this, (LoadersVolumes.__proto__ || Object.getPrototypeOf(LoadersVolumes)).apply(this, arguments));
  }

  _createClass(LoadersVolumes, [{
    key: 'parse',

    /**
     * Parse response.
     * response is formated as:
     *    {
     *      url: 'resource url',
     *      buffer: xmlresponse,
     *    }
     * @param {object} response - response
     * @return {promise} promise
     */
    value: function parse(response) {
      var _this2 = this;

      // emit 'parse-start' event
      this.emit('parse-start', {
        file: response.url,
        time: new Date()
      });
      // give a chance to the UI to update because
      // after the rendering will be blocked with intensive JS
      // will be removed after eventer set up
      if (this._progressBar) {
        this._progressBar.update(0, 100, 'parse');
      }

      return new Promise(function (resolve, reject) {
        window.setTimeout(function () {
          resolve(new Promise(function (resolve, reject) {
            var data = response;

            if (!Array.isArray(data)) {
              data = [data];
            }

            data.forEach(function (dataset) {
              _this2._preprocess(dataset);
            });

            if (data.length === 1) {
              data = data[0];
            } else {
              // if raw/mhd pair
              var mhdFile = data.filter(_this2._filterByExtension.bind(null, 'MHD'));
              var rawFile = data.filter(_this2._filterByExtension.bind(null, 'RAW'));
              if (data.length === 2 && mhdFile.length === 1 && rawFile.length === 1) {
                data.url = mhdFile[0].url;
                data.extension = mhdFile[0].extension;
                data.mhdBuffer = mhdFile[0].buffer;
                data.rawBuffer = rawFile[0].buffer;
              }
            }

            var Parser = _this2._parser(data.extension);
            if (!Parser) {
              // emit 'parse-error' event
              _this2.emit('parse-error', {
                file: response.url,
                time: new Date(),
                error: data.filename + 'can not be parsed.'
              });
              reject(data.filename + ' can not be parsed.');
            }

            // check extension
            var volumeParser = null;
            try {
              volumeParser = new Parser(data, 0);
            } catch (e) {
              window.console.log(e);
              // emit 'parse-error' event
              _this2.emit('parse-error', {
                file: response.url,
                time: new Date(),
                error: e
              });
              reject(e);
            }

            // create a series
            var series = new _models2.default();
            // global information
            series.seriesInstanceUID = volumeParser.seriesInstanceUID();
            series.transferSyntaxUID = volumeParser.transferSyntaxUID();
            series.seriesDescription = volumeParser.seriesDescription();
            series.studyDescription = volumeParser.studyDescription();
            series.numberOfFrames = volumeParser.numberOfFrames();
            if (!series.numberOfFrames) {
              series.numberOfFrames = 1;
            }
            series.numberOfChannels = volumeParser.numberOfChannels();
            series.modality = volumeParser.modality();
            // if it is a segmentation, attach extra information
            if (series.modality === 'SEG') {
              // colors
              // labels
              // etc.
              series.segmentationType = volumeParser.segmentationType();
              series.segmentationSegments = volumeParser.segmentationSegments();
            }
            // patient information
            series.patientID = volumeParser.patientID();
            series.patientName = volumeParser.patientName();
            series.patientAge = volumeParser.patientAge();
            series.patientBirthdate = volumeParser.patientBirthdate();
            series.patientSex = volumeParser.patientSex();

            // just create 1 dummy stack for now
            var stack = new _models4.default();
            stack.numberOfChannels = volumeParser.numberOfChannels();
            stack.pixelRepresentation = volumeParser.pixelRepresentation();
            stack.pixelType = volumeParser.pixelType();
            stack.invert = volumeParser.invert();
            stack.spacingBetweenSlices = volumeParser.spacingBetweenSlices();
            stack.modality = series.modality;
            // if it is a segmentation, attach extra information
            if (stack.modality === 'SEG') {
              // colors
              // labels
              // etc.
              stack.segmentationType = series.segmentationType;
              stack.segmentationSegments = series.segmentationSegments;
            }
            series.stack.push(stack);
            // recursive call for each frame
            // better than for loop to be able
            // to update dom with "progress" callback
            setTimeout(_this2.parseFrame(series, stack, response.url, 0, volumeParser, resolve, reject), 0);
          }));
        }, 10);
      });
    }

    /**
     * recursive parse frame
     * @param {ModelsSeries} series - data series
     * @param {ModelsStack} stack - data stack
     * @param {string} url - resource url
     * @param {number} i - frame index
     * @param {parser} dataParser - selected parser
     * @param {promise.resolve} resolve - promise resolve args
     * @param {promise.reject} reject - promise reject args
     */

  }, {
    key: 'parseFrame',
    value: function parseFrame(series, stack, url, i, dataParser, resolve, reject) {
      var frame = new _models6.default();
      frame.sopInstanceUID = dataParser.sopInstanceUID(i);
      frame.url = url;
      frame.index = i;
      frame.rows = dataParser.rows(i);
      frame.columns = dataParser.columns(i);
      frame.numberOfChannels = stack.numberOfChannels;
      frame.pixelRepresentation = stack.pixelRepresentation;
      frame.pixelType = stack.pixelType;
      frame.pixelData = dataParser.extractPixelData(i);
      frame.pixelSpacing = dataParser.pixelSpacing(i);
      frame.spacingBetweenSlices = dataParser.spacingBetweenSlices(i);
      frame.sliceThickness = dataParser.sliceThickness(i);
      frame.imageOrientation = dataParser.imageOrientation(i);
      frame.rightHanded = dataParser.rightHanded();
      stack.rightHanded = frame.rightHanded;
      if (frame.imageOrientation === null) {
        frame.imageOrientation = [1, 0, 0, 0, 1, 0];
      }
      frame.imagePosition = dataParser.imagePosition(i);
      if (frame.imagePosition === null) {
        frame.imagePosition = [0, 0, i];
      }
      frame.dimensionIndexValues = dataParser.dimensionIndexValues(i);
      frame.bitsAllocated = dataParser.bitsAllocated(i);
      frame.instanceNumber = dataParser.instanceNumber(i);
      frame.windowCenter = dataParser.windowCenter(i);
      frame.windowWidth = dataParser.windowWidth(i);
      frame.rescaleSlope = dataParser.rescaleSlope(i);
      frame.rescaleIntercept = dataParser.rescaleIntercept(i);
      // should pass frame index for consistency...
      frame.minMax = dataParser.minMaxPixelData(frame.pixelData);

      // if series.mo
      if (series.modality === 'SEG') {
        frame.referencedSegmentNumber = dataParser.referencedSegmentNumber(i);
      }

      stack.frame.push(frame);

      // update status
      this._parsed = i + 1;
      this._totalParsed = series.numberOfFrames;

      // will be removed after eventer set up
      if (this._progressBar) {
        this._progressBar.update(this._parsed, this._totalParsed, 'parse');
      }

      // emit 'parsing' event
      this.emit('parsing', {
        file: url,
        total: this._totalParsed,
        parsed: this._parsed,
        time: new Date()
      });

      if (this._parsed === this._totalParsed) {
        // emit 'parse-success' event
        this.emit('parse-success', {
          file: url,
          total: this._totalParsed,
          parsed: this._parsed,
          time: new Date()
        });

        resolve(series);
      } else {
        setTimeout(this.parseFrame(series, stack, url, this._parsed, dataParser, resolve, reject), 0);
      }
    }

    /**
     * Return parser given an extension
     * @param {string} extension - extension
     * @return {parser} selected parser
     */

  }, {
    key: '_parser',
    value: function _parser(extension) {
      var Parser = null;

      switch (extension.toUpperCase()) {
        case 'NII':
        case 'NII_':
          Parser = _parsers6.default;
          break;
        case 'DCM':
        case 'DICOM':
        case 'IMA':
        case '':
          Parser = _parsers2.default;
          break;
        case 'MHD':
          Parser = _parsers4.default;
          break;
        case 'NRRD':
          Parser = _parsers8.default;
          break;
        default:
          window.console.log('unsupported extension: ' + extension);
          return false;
      }
      return Parser;
    }

    /**
     * Pre-process data to be parsed (find data type and de-compress)
     * @param {*} data
     */

  }, {
    key: '_preprocess',
    value: function _preprocess(data) {
      var parsedUrl = _core2.default.parseUrl(data.url);
      // update data
      data.filename = parsedUrl.filename;
      data.extension = parsedUrl.extension;
      data.pathname = parsedUrl.pathname;
      data.query = parsedUrl.query;

      // unzip if extension is '.gz'
      if (data.extension === 'gz') {
        data.gzcompressed = true;
        data.extension = data.filename.split('.gz').shift().split('.').pop();
        var decompressedData = PAKO.inflate(data.buffer);
        data.buffer = decompressedData.buffer;
      } else {
        data.gzcompressed = false;
      }
    }

    /**
     * Filter data by extension
     * @param {*} extension
     * @param {*} item
     * @returns Boolean
     */

  }, {
    key: '_filterByExtension',
    value: function _filterByExtension(extension, item) {
      if (item.extension.toUpperCase() === extension.toUpperCase()) {
        return true;
      }
      return false;
    }
  }]);

  return LoadersVolumes;
}(_loaders2.default);

exports.default = LoadersVolumes;

},{"../core/core.utils":105,"../models/models.frame":131,"../models/models.series":133,"../models/models.stack":134,"../parsers/parsers.dicom":136,"../parsers/parsers.mhd":138,"../parsers/parsers.nifti":139,"../parsers/parsers.nrrd":140,"./loaders.base":127,"pako":51}],130:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

/**
 * Base object.
 *
 * @module models/base
 */

var ModelsBase = function () {
  function ModelsBase() {
    _classCallCheck(this, ModelsBase);

    this._id = -1;
  }
  /**
   * Merge 2 arrays of models.
   * Merge the target array into the reference array.
   *
   * @param {Array.<Models>} referenceArray - Array to be merge against
   * @param {Array.<Models>} targetArray - Array to be merged against reference.
   *
   * @return {boolean} True if merge was sucessful. False if something went wrong.
   */

  _createClass(ModelsBase, [{
    key: 'mergeModels',
    value: function mergeModels(referenceArray, targetArray) {
      if (!(this._validateModelArray(referenceArray) && this._validateModelArray(targetArray))) {
        window.console.log('invalid inputs provided.');
        return false;
      }

      for (var i = 0; i < targetArray.length; i++) {
        // test targetArray against existing targetArray
        for (var j = 0; j < referenceArray.length; j++) {
          if (referenceArray[j].merge(targetArray[i])) {
            // merged successfully
            break;
          } else if (j === referenceArray.length - 1) {
            // last merge was not successful
            // this is a new targetArray
            referenceArray.push(targetArray[i]);
          }
        }
      }

      return true;
    }

    /**
     * Merge model against current model.
     */

  }, {
    key: 'merge',
    value: function merge(model) {
      // make sure model is valid
      if (!this.validate(model)) {
        return false;
      }

      // they can be merged if they match
      if (this._id === model._id) {
        return true;
      }
      return false;
    }

    /**
     * Validate a model.
     *
     * @return {boolean} True if model is valid. False if not.
     */

  }, {
    key: 'validate',
    value: function validate(model) {
      if (!(model && model !== null && typeof model.merge === 'function')) {
        return false;
      }

      return true;
    }

    /**
     * Validate array of models.
     *
     * @param {Array.<Models>} modelArray - Array containing models.
     *
     * @return {boolean} True if array is valid. False if not.
     */

  }, {
    key: '_validateModelArray',
    value: function _validateModelArray(modelArray) {
      if (!(modelArray !== null && Array === modelArray.constructor)) {
        window.console.log('invalid model array provided.');
        return false;
      }

      for (var i = 0; i < modelArray.length; i++) {
        if (!(modelArray[i] && modelArray[i] !== null && typeof modelArray[i].validate === 'function' && modelArray[i].validate(modelArray[i]))) {
          return false;
        }
      }

      return true;
    }
  }]);

  return ModelsBase;
}();

exports.default = ModelsBase;

},{}],131:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

var _get = function get(object, property, receiver) {
  if (object === null) object = Function.prototype;var desc = Object.getOwnPropertyDescriptor(object, property);if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);if (parent === null) {
      return undefined;
    } else {
      return get(parent, property, receiver);
    }
  } else if ("value" in desc) {
    return desc.value;
  } else {
    var getter = desc.get;if (getter === undefined) {
      return undefined;
    }return getter.call(receiver);
  }
};

var _models = require('../models/models.base');

var _models2 = _interopRequireDefault(_models);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
} /** * Imports ***/

/**
 * Frame object.
 *
 * @module models/frame
 */
var ModelsFrame = function (_ModelsBase) {
  _inherits(ModelsFrame, _ModelsBase);

  /**
   * Constructor
   */
  function ModelsFrame() {
    _classCallCheck(this, ModelsFrame);

    var _this = _possibleConstructorReturn(this, (ModelsFrame.__proto__ || Object.getPrototypeOf(ModelsFrame)).call(this));

    _this._sopInstanceUID = null;
    _this._url = null;
    _this._stackID = -1;
    _this._rows = 0;
    _this._columns = 0;
    _this._dimensionIndexValues = [];
    _this._imagePosition = null;
    _this._imageOrientation = null;
    _this._rightHanded = true;
    _this._sliceThickness = 1;
    _this._spacingBetweenSlices = null;
    _this._pixelRepresentation = 0;
    _this._pixelType = 0;
    _this._pixelSpacing = null;
    _this._pixelAspectRatio = null;
    _this._pixelData = null;

    _this._instanceNumber = null;
    _this._windowCenter = null;
    _this._windowWidth = null;
    _this._rescaleSlope = null;
    _this._rescaleIntercept = null;

    _this._bitsAllocated = 8;

    _this._minMax = null;
    _this._dist = null;

    _this._index = -1;

    _this._referencedSegmentNumber = -1;
    return _this;
  }

  /**
   * Validate the frame.
   *
   * @param {*} model
   *
   * @return {*}
   */

  _createClass(ModelsFrame, [{
    key: 'validate',
    value: function validate(model) {
      if (!(_get(ModelsFrame.prototype.__proto__ || Object.getPrototypeOf(ModelsFrame.prototype), 'validate', this).call(this, model) && typeof model.cosines === 'function' && typeof model.spacingXY === 'function' && model.hasOwnProperty('_sopInstanceUID') && model.hasOwnProperty('_dimensionIndexValues') && model.hasOwnProperty('_imageOrientation') && model.hasOwnProperty('_imagePosition'))) {
        return false;
      }

      return true;
    }

    /**
     * Merge current frame with provided frame.
     *
     * Frames can be merged (i.e. are identical) if following are equals:
     *  - dimensionIndexValues
     *  - imageOrientation
     *  - imagePosition
     *  - instanceNumber
     *  - sopInstanceUID
     *
     * @param {*} frame
     *
     * @return {boolean} True if frames could be merge. False if not.
     */

  }, {
    key: 'merge',
    value: function merge(frame) {
      if (!this.validate(frame)) {
        return false;
      }

      if (this._compareArrays(this._dimensionIndexValues, frame.dimensionIndexValues) && this._compareArrays(this._imageOrientation, frame.imageOrientation) && this._compareArrays(this._imagePosition, frame.imagePosition) && this._instanceNumber === frame.instanceNumber && this._sopInstanceUID === frame.sopInstanceUID) {
        return true;
      } else {
        return false;
      }
    }

    /**
     * Generate X, y and Z cosines from image orientation
     * Returns default orientation if _imageOrientation was invalid.
     *
     * @returns {array} Array[3] containing cosinesX, Y and Z.
     */

  }, {
    key: 'cosines',
    value: function cosines() {
      var cosines = [new THREE.Vector3(1, 0, 0), new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, 0, 1)];

      if (this._imageOrientation && this._imageOrientation.length === 6) {
        var xCos = new THREE.Vector3(this._imageOrientation[0], this._imageOrientation[1], this._imageOrientation[2]);
        var yCos = new THREE.Vector3(this._imageOrientation[3], this._imageOrientation[4], this._imageOrientation[5]);

        if (xCos.length() > 0 && yCos.length() > 0) {
          cosines[0] = xCos;
          cosines[1] = yCos;
          cosines[2] = new THREE.Vector3(0, 0, 0).crossVectors(cosines[0], cosines[1]).normalize();
        }
      } else {
        window.console.log('No valid image orientation for frame');
        window.console.log(this);
        window.console.log('Returning default orientation.');
      }

      if (!this._rightHanded) {
        cosines[2].negate();
      }

      return cosines;
    }

    /**
     * Get x/y spacing of a frame.
     *
     * @return {*}
     */

  }, {
    key: 'spacingXY',
    value: function spacingXY() {
      var spacingXY = [1.0, 1.0];

      if (this.pixelSpacing) {
        spacingXY[0] = this.pixelSpacing[0];

        spacingXY[1] = this.pixelSpacing[1];
      } else if (this.pixelAspectRatio) {
        spacingXY[0] = 1.0;
        spacingXY[1] = 1.0 * this.pixelAspectRatio[1] / this.pixelAspectRatio[0];
      }

      return spacingXY;
    }

    /**
     * Get data value
     *
     * @param {*} column
     * @param {*} row
     *
     * @return {*}
     */

  }, {
    key: 'value',
    value: function value(column, row) {
      return this.pixelData[column + this._columns * row];
    }

    /**
     * Compare 2 arrays.
     *
     * 2 null arrays return true.
     * Do no perform strict type checking.
     *
     * @param {*} reference
     * @param {*} target
     *
     * @return {boolean} True if arrays are identicals. False if not.
     */

  }, {
    key: '_compareArrays',
    value: function _compareArrays(reference, target) {
      // could both be null
      if (reference === target) {
        return true;
      }

      // if not null....
      if (reference && target && reference.join() === target.join()) {
        return true;
      }

      return false;
    }
  }, {
    key: 'rows',
    get: function get() {
      return this._rows;
    },
    set: function set(rows) {
      this._rows = rows;
    }
  }, {
    key: 'columns',
    get: function get() {
      return this._columns;
    },
    set: function set(columns) {
      this._columns = columns;
    }
  }, {
    key: 'spacingBetweenSlices',
    get: function get() {
      return this._spacingBetweenSlices;
    },
    set: function set(spacingBetweenSlices) {
      this._spacingBetweenSlices = spacingBetweenSlices;
    }
  }, {
    key: 'sliceThickness',
    get: function get() {
      return this._sliceThickness;
    },
    set: function set(sliceThickness) {
      this._sliceThickness = sliceThickness;
    }
  }, {
    key: 'imagePosition',
    get: function get() {
      return this._imagePosition;
    },
    set: function set(imagePosition) {
      this._imagePosition = imagePosition;
    }
  }, {
    key: 'imageOrientation',
    get: function get() {
      return this._imageOrientation;
    },
    set: function set(imageOrientation) {
      this._imageOrientation = imageOrientation;
    }
  }, {
    key: 'windowWidth',
    get: function get() {
      return this._windowWidth;
    },
    set: function set(windowWidth) {
      this._windowWidth = windowWidth;
    }
  }, {
    key: 'windowCenter',
    get: function get() {
      return this._windowCenter;
    },
    set: function set(windowCenter) {
      this._windowCenter = windowCenter;
    }
  }, {
    key: 'rescaleSlope',
    get: function get() {
      return this._rescaleSlope;
    },
    set: function set(rescaleSlope) {
      this._rescaleSlope = rescaleSlope;
    }
  }, {
    key: 'rescaleIntercept',
    get: function get() {
      return this._rescaleIntercept;
    },
    set: function set(rescaleIntercept) {
      this._rescaleIntercept = rescaleIntercept;
    }
  }, {
    key: 'bitsAllocated',
    get: function get() {
      return this._bitsAllocated;
    },
    set: function set(bitsAllocated) {
      this._bitsAllocated = bitsAllocated;
    }
  }, {
    key: 'dist',
    get: function get() {
      return this._dist;
    },
    set: function set(dist) {
      this._dist = dist;
    }
  }, {
    key: 'pixelSpacing',
    get: function get() {
      return this._pixelSpacing;
    },
    set: function set(pixelSpacing) {
      this._pixelSpacing = pixelSpacing;
    }
  }, {
    key: 'pixelAspectRatio',
    get: function get() {
      return this._pixelAspectRatio;
    },
    set: function set(pixelAspectRatio) {
      this._pixelAspectRatio = pixelAspectRatio;
    }
  }, {
    key: 'minMax',
    get: function get() {
      return this._minMax;
    },
    set: function set(minMax) {
      this._minMax = minMax;
    }
  }, {
    key: 'dimensionIndexValues',
    get: function get() {
      return this._dimensionIndexValues;
    },
    set: function set(dimensionIndexValues) {
      this._dimensionIndexValues = dimensionIndexValues;
    }
  }, {
    key: 'instanceNumber',
    get: function get() {
      return this._instanceNumber;
    },
    set: function set(instanceNumber) {
      this._instanceNumber = instanceNumber;
    }
  }, {
    key: 'pixelData',
    get: function get() {
      return this._pixelData;
    },
    set: function set(pixelData) {
      this._pixelData = pixelData;
    }
  }, {
    key: 'sopInstanceUID',
    set: function set(sopInstanceUID) {
      this._sopInstanceUID = sopInstanceUID;
    },
    get: function get() {
      return this._sopInstanceUID;
    }
  }, {
    key: 'pixelRepresentation',
    get: function get() {
      return this._pixelRepresentation;
    },
    set: function set(pixelRepresentation) {
      this._pixelRepresentation = pixelRepresentation;
    }
  }, {
    key: 'pixelType',
    get: function get() {
      return this._pixelType;
    },
    set: function set(pixelType) {
      this._pixelType = pixelType;
    }
  }, {
    key: 'url',
    get: function get() {
      return this._url;
    },
    set: function set(url) {
      this._url = url;
    }
  }, {
    key: 'referencedSegmentNumber',
    get: function get() {
      return this._referencedSegmentNumber;
    },
    set: function set(referencedSegmentNumber) {
      this._referencedSegmentNumber = referencedSegmentNumber;
    }
  }, {
    key: 'rightHanded',
    get: function get() {
      return this._rightHanded;
    },
    set: function set(rightHanded) {
      this._rightHanded = rightHanded;
    }
  }, {
    key: 'index',
    get: function get() {
      return this._index;
    },
    set: function set(index) {
      this._index = index;
    }
  }]);

  return ModelsFrame;
}(_models2.default);

exports.default = ModelsFrame;

},{"../models/models.base":130}],132:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _models = require('./models.frame');

var _models2 = _interopRequireDefault(_models);

var _models3 = require('./models.stack');

var _models4 = _interopRequireDefault(_models3);

var _models5 = require('./models.series');

var _models6 = _interopRequireDefault(_models5);

var _models7 = require('./models.voxel');

var _models8 = _interopRequireDefault(_models7);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

/**
 * @module models
 */

exports.default = {
  Frame: _models2.default,
  Stack: _models4.default,
  Series: _models6.default,
  Voxel: _models8.default
};

},{"./models.frame":131,"./models.series":133,"./models.stack":134,"./models.voxel":135}],133:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

var _get = function get(object, property, receiver) {
  if (object === null) object = Function.prototype;var desc = Object.getOwnPropertyDescriptor(object, property);if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);if (parent === null) {
      return undefined;
    } else {
      return get(parent, property, receiver);
    }
  } else if ("value" in desc) {
    return desc.value;
  } else {
    var getter = desc.get;if (getter === undefined) {
      return undefined;
    }return getter.call(receiver);
  }
};

var _models = require('../models/models.base');

var _models2 = _interopRequireDefault(_models);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
} /** * Imports ***/

/**
 * Series object.
 *
 * @module models/series
 */
var ModelsSeries = function (_ModelsBase) {
  _inherits(ModelsSeries, _ModelsBase);

  /**
   * Models series constructor
   */
  function ModelsSeries() {
    _classCallCheck(this, ModelsSeries);

    var _this = _possibleConstructorReturn(this, (ModelsSeries.__proto__ || Object.getPrototypeOf(ModelsSeries)).call(this));

    _this._concatenationUID = -1;
    _this._seriesInstanceUID = -1;
    _this._transferSyntaxUID = '';
    _this._seriesNumber = -1;
    _this._seriesDescription = '';
    _this._studyDescription = '';
    _this._modality = 'Modality not set';
    _this._dimensionIndexSequence = [];
    // it is used in the loader in case a dicom/nifti contains multiple frames
    // should be updated after merge or renamed
    _this._numberOfFrames = 0;
    _this._numberOfChannels = 1;

    // patient information
    _this._patientID = '';
    _this._patientName = '';
    _this._patientAge = '';
    _this._patientBirthdate = '';
    _this._patientSex = '';

    // SEGMENTATION STUFF
    _this._segmentationType = null;
    _this._segmentationSegments = [];

    // STACK
    _this._stack = [];
    return _this;
  }

  /**
   * Validate a series.
   *
   * Requirements:
   *   - mergeSeries method
   *   - _seriesInstanceUID
   *   - _numberOfFrames
   *   - _numberOfChannels
   *   _ _stack
   *
   * @param {ModelsSeries} model - Model to be validated as series.
   *
   * @return {boolean} True if series is valid. False if not.
   *
   * @override
   */

  _createClass(ModelsSeries, [{
    key: 'validate',
    value: function validate(model) {
      if (!(_get(ModelsSeries.prototype.__proto__ || Object.getPrototypeOf(ModelsSeries.prototype), 'validate', this).call(this, model) && typeof model.mergeSeries === 'function' && model.hasOwnProperty('_seriesInstanceUID') && model.hasOwnProperty('_numberOfFrames') && model.hasOwnProperty('_numberOfChannels') && model.hasOwnProperty('_stack') && typeof model._stack !== 'undefined' && Array === model._stack.constructor)) {
        return false;
      }

      return true;
    }

    /**
     * Merge current series with provided series.
     * 2 series can ONLY be merge if they have the same SeriesInstanceUID.
     *
     * Also merges the stacks inside a series.
     *
     * @param {ModelsSeries} series - Series to be merged against current series.
     *
     * @return {boolean} True if series could be merge. False if not.
     *
     * @override
     */

  }, {
    key: 'merge',
    value: function merge(series) {
      if (!this.validate(series)) {
        return false;
      }

      if (this._seriesInstanceUID === series.seriesInstanceUID) {
        return this.mergeModels(this._stack, series.stack);
      } else {
        return false;
      }
    }

    /**
     * Merge current series with provided array of series.
     * 2 series can ONLY be merge if they have the same SeriesInstanceUID.
     *
     * Also merges the stacks inside a series.
     *
     * @param {Array.<ModelsSeries>} target - Series to be merged against current series.
     *
     * @return {Array.<ModelsSeries>} Array of series properly merged.
     */

  }, {
    key: 'mergeSeries',
    value: function mergeSeries(target) {
      var seriesContainer = [this];
      this.mergeModels(seriesContainer, target);
      return seriesContainer;
    }

    /**
     * Series instance UID setter
     *
     * @param {*} seriesInstanceUID
     */

  }, {
    key: 'seriesInstanceUID',
    set: function set(seriesInstanceUID) {
      this._seriesInstanceUID = seriesInstanceUID;
    }

    /**
     * Series instace UID getter
     *
     * @return {*}
     */

    , get: function get() {
      return this._seriesInstanceUID;
    }

    /**
     * Transfer syntax UID setter
     *
     * @param {*} transferSyntaxUID
     */

  }, {
    key: 'transferSyntaxUID',
    set: function set(transferSyntaxUID) {
      this._transferSyntaxUID = transferSyntaxUID;
    }

    /**
     * Transfer syntax UID getter
     *
     * @return {*}
     */

    , get: function get() {
      return this._transferSyntaxUID;
    }

    /**
     * Transfer syntax UID getter
     *
     * @return {*}
     */

  }, {
    key: 'transferSyntaxUIDLabel',
    get: function get() {
      switch (this._transferSyntaxUID) {
        case '1.2.840.10008.1.2.4.90':
          return 'JPEG 2000 Lossless';
        case '1.2.840.10008.1.2.4.91':
          return 'JPEG 2000 Lossy';
        case '1.2.840.10008.1.2.4.57':
          return 'JPEG Lossless, Nonhierarchical (Processes 14)';
        case '1.2.840.10008.1.2.4.70':
          return 'JPEG Lossless, Nonhierarchical (Processes 14 [Selection 1])';
        case '1.2.840.10008.1.2.4.50':
          return 'JPEG Baseline lossy process 1 (8 bit)';
        case '1.2.840.10008.1.2.4.51':
          return 'JPEG Baseline lossy process 2 & 4 (12 bit)';
        case '1.2.840.10008.1.2':
          return 'Implicit VR Little Endian';
        case '1.2.840.10008.1.2.1':
          return 'Explicit VR Little Endian';
        case '1.2.840.10008.1.2.2':
          return 'Explicit VR Big Endian';
        default:
          return 'Unknown transfersyntax: ' + this._transferSyntaxUID;
      }
    }

    /**
     * Study descripition setter
     *
     * @param {*} studyDescription
     */

  }, {
    key: 'studyDescription',
    set: function set(studyDescription) {
      this._studyDescription = studyDescription;
    }

    /**
     * Study description getter
     *
     * @return {*}
     */

    , get: function get() {
      return this._studyDescription;
    }

    /**
     * Series descripition setter
     *
     * @param {*} seriesDescription
     */

  }, {
    key: 'seriesDescription',
    set: function set(seriesDescription) {
      this._seriesDescription = seriesDescription;
    }

    /**
     * Series description getter
     *
     * @return {*}
     */

    , get: function get() {
      return this._seriesDescription;
    }

    /**
     * Patient ID setter
     *
     * @param {*} patientID
     */

  }, {
    key: 'patientID',
    set: function set(patientID) {
      this._patientID = patientID;
    }

    /**
     * Patient ID getter
     *
     * @return {*}
     */

    , get: function get() {
      return this._patientID;
    }

    /**
     * Patient name setter
     *
     * @param {*} patientName
     */

  }, {
    key: 'patientName',
    set: function set(patientName) {
      this._patientName = patientName;
    }

    /**
     * Patient name getter
     *
     * @return {*}
     */

    , get: function get() {
      return this._patientName;
    }

    /**
     * Patient age setter
     *
     * @param {*} patientAge
     */

  }, {
    key: 'patientAge',
    set: function set(patientAge) {
      this._patientAge = patientAge;
    }

    /**
     * Patient age getter
     *
     * @return {*}
     */

    , get: function get() {
      return this._patientAge;
    }

    /**
     * Patient birthdate setter
     *
     * @param {*} patientBirthdate
     */

  }, {
    key: 'patientBirthdate',
    set: function set(patientBirthdate) {
      this._patientBirthdate = patientBirthdate;
    }

    /**
     * Patient birthdate getter
     *
     * @return {*}
     */

    , get: function get() {
      return this._patientBirthdate;
    }

    /**
     * Patient sex setter
     *
     * @param {*} patientSex
     */

  }, {
    key: 'patientSex',
    set: function set(patientSex) {
      this._patientSex = patientSex;
    }

    /**
     * Patient sex getter
     *
     * @return {*}
     */

    , get: function get() {
      return this._patientSex;
    }

    /**
     * Number of frames setter
     *
     * @param {*} numberOfFrames
     */

  }, {
    key: 'numberOfFrames',
    set: function set(numberOfFrames) {
      this._numberOfFrames = numberOfFrames;
    }

    /**
     * Number of frames getter
     *
     * @return {*}
     */

    , get: function get() {
      return this._numberOfFrames;
    }

    /**
     * Number of channels setter
     *
     * @param {*} numberOfChannels
     */

  }, {
    key: 'numberOfChannels',
    set: function set(numberOfChannels) {
      this._numberOfChannels = numberOfChannels;
    }

    /**
     * Number of channels getter
     *
     * @return {*}
     */

    , get: function get() {
      return this._numberOfChannels;
    }
  }, {
    key: 'stack',
    set: function set(stack) {
      this._stack = stack;
    },
    get: function get() {
      return this._stack;
    }
  }, {
    key: 'modality',
    set: function set(modality) {
      this._modality = modality;
    },
    get: function get() {
      return this._modality;
    }
  }, {
    key: 'segmentationType',
    set: function set(segmentationType) {
      this._segmentationType = segmentationType;
    },
    get: function get() {
      return this._segmentationType;
    }
  }, {
    key: 'segmentationSegments',
    set: function set(segmentationSegments) {
      this._segmentationSegments = segmentationSegments;
    },
    get: function get() {
      return this._segmentationSegments;
    }
  }]);

  return ModelsSeries;
}(_models2.default);

exports.default = ModelsSeries;

},{"../models/models.base":130}],134:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

var _core = require('../core/core.colors');

var _core2 = _interopRequireDefault(_core);

var _core3 = require('../core/core.utils');

var _core4 = _interopRequireDefault(_core3);

var _models = require('../models/models.base');

var _models2 = _interopRequireDefault(_models);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function _toConsumableArray(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
      arr2[i] = arr[i];
    }return arr2;
  } else {
    return Array.from(arr);
  }
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
} /** * Imports ***/

var binaryString = require('math-float32-to-binary-string');

/**
 * Stack object.
 *
 * @module models/stack
 */

var ModelsStack = function (_ModelsBase) {
  _inherits(ModelsStack, _ModelsBase);

  /**
   * Models Stack constructor
   */
  function ModelsStack() {
    _classCallCheck(this, ModelsStack);

    var _this = _possibleConstructorReturn(this, (ModelsStack.__proto__ || Object.getPrototypeOf(ModelsStack)).call(this));

    _this._uid = null;
    _this._stackID = -1;

    _this._frame = [];
    _this._numberOfFrames = 0;

    _this._rows = 0;
    _this._columns = 0;
    _this._numberOfChannels = 1;
    _this._bitsAllocated = 8;
    _this._pixelType = 0;
    _this._pixelRepresentation = 0;

    _this._textureSize = 4096;
    _this._nbTextures = 7;
    _this._rawData = [];

    _this._windowCenter = 0;
    _this._windowWidth = 0;

    _this._rescaleSlope = 1;
    _this._rescaleIntercept = 0;

    _this._minMax = [65535, -32768];

    // TRANSFORMATION MATRICES
    _this._regMatrix = new THREE.Matrix4();

    _this._ijk2LPS = null;
    _this._lps2IJK = null;

    _this._aabb2LPS = null;
    _this._lps2AABB = null;

    //
    // IJK dimensions
    _this._dimensionsIJK = null;
    _this._halfDimensionsIJK = null;
    _this._spacing = new THREE.Vector3(1, 1, 1);
    _this._spacingBetweenSlices = 0;
    _this._sliceThickness = 0;
    _this._origin = null;
    _this._rightHanded = true;
    _this._xCosine = new THREE.Vector3(1, 0, 0);
    _this._yCosine = new THREE.Vector3(0, 1, 0);
    _this._zCosine = new THREE.Vector3(0, 0, 1);

    // convenience vars
    _this._prepared = false;
    _this._packed = false;
    _this._packedPerPixel = 1;

    //
    _this._modality = 'Modality not set';

    // SEGMENTATION STUFF
    _this._segmentationType = null;
    _this._segmentationSegments = [];
    _this._segmentationDefaultColor = [63, 174, 128];
    _this._frameSegment = [];
    _this._segmentationLUT = [];
    _this._segmentationLUTO = [];

    // photometricInterpretation Monochrome1 VS Monochrome2
    _this._invert = false;
    return _this;
  }

  /**
   * Prepare segmentation stack.
   * A segmentation stack can hold x frames that are at the same location
   * but segmentation specific information:
   * - Frame X contains voxels for segmentation A.
   * - Frame Y contains voxels for segmenttation B.
   * - Frame X and Y are at the same location.
   *
   * We currently merge overlaping frames into 1.
   */

  _createClass(ModelsStack, [{
    key: 'prepareSegmentation',
    value: function prepareSegmentation() {
      // store frame and do special pre-processing
      this._frameSegment = this._frame;
      var mergedFrames = [];

      // order frames
      this.computeCosines();
      this._frame.map(this._computeDistanceArrayMap.bind(null, this._zCosine));
      this._frame.sort(this._sortDistanceArraySort);

      // merge frames
      var prevIndex = -1;
      for (var i = 0; i < this._frame.length; i++) {
        if (!mergedFrames[prevIndex] || mergedFrames[prevIndex]._dist != this._frame[i]._dist) {
          mergedFrames.push(this._frame[i]);
          prevIndex++;

          // Scale frame
          // by default each frame contains binary data about a segmentation.
          // we scale it by the referenceSegmentNumber in order to have a
          // segmentation specific voxel value rather than 0 or 1.
          // That allows us to merge frames later on.
          // If we merge frames without scaling, then we can not differenciate
          // voxels from segmentation A or B as the value is 0 or 1 in both cases.
          for (var k = 0; k < mergedFrames[prevIndex]._rows * mergedFrames[prevIndex]._columns; k++) {
            mergedFrames[prevIndex]._pixelData[k] *= this._frame[i]._referencedSegmentNumber;
          }
        } else {
          // frame already exsits at this location.
          // merge data from this segmentation into existing frame
          for (var _k = 0; _k < mergedFrames[prevIndex]._rows * mergedFrames[prevIndex]._columns; _k++) {
            mergedFrames[prevIndex]._pixelData[_k] += this._frame[i].pixelData[_k] * this._frame[i]._referencedSegmentNumber;
          }
        }

        mergedFrames[prevIndex].minMax = _core4.default.minMax(mergedFrames[prevIndex]._pixelData);
      }

      // get information about segments
      var dict = {};
      var max = 0;
      for (var _i = 0; _i < this._segmentationSegments.length; _i++) {
        max = Math.max(max, parseInt(this._segmentationSegments[_i].segmentNumber, 10));

        var color = this._segmentationSegments[_i].recommendedDisplayCIELab;
        if (color === null) {
          dict[this._segmentationSegments[_i].segmentNumber] = this._segmentationDefaultColor;
        } else {
          dict[this._segmentationSegments[_i].segmentNumber] = _core2.default.cielab2RGB.apply(_core2.default, _toConsumableArray(color));
        }
      }

      // generate LUTs
      for (var _i2 = 0; _i2 <= max; _i2++) {
        var index = _i2 / max;
        var opacity = _i2 ? 1 : 0;
        var rgb = [0, 0, 0];
        if (dict.hasOwnProperty(_i2.toString())) {
          rgb = dict[_i2.toString()];
        }

        rgb[0] /= 255;
        rgb[1] /= 255;
        rgb[2] /= 255;

        this._segmentationLUT.push([index].concat(_toConsumableArray(rgb)));
        this._segmentationLUTO.push([index, opacity]);
      }

      this._frame = mergedFrames;
    }

    /**
     * Compute cosines
     * Order frames
     * computeSpacing
     * sanityCheck
     * init some vars
     * compute min/max
     * compute transformation matrices
     *
     * @return {*}
     */

  }, {
    key: 'prepare',
    value: function prepare() {
      // if segmentation, merge some frames...
      if (this._modality === 'SEG') {
        this.prepareSegmentation();
      }

      // we need at least 1 frame
      if (this._frame && this._frame.length > 0) {
        this._numberOfFrames = this._frame.length;
      } else {
        window.console.log('_frame doesn\'t contain anything....');
        window.console.log(this._frame);
        return false;
      }

      // pass parameters from frame to stack
      this._rows = this._frame[0].rows;
      this._columns = this._frame[0].columns;
      this._dimensionsIJK = new THREE.Vector3(this._columns, this._rows, this._numberOfFrames);
      this._halfDimensionsIJK = new THREE.Vector3(this._dimensionsIJK.x / 2, this._dimensionsIJK.y / 2, this._dimensionsIJK.z / 2);
      this._spacingBetweenSlices = this._frame[0].spacingBetweenSlices;
      this._sliceThickness = this._frame[0].sliceThickness;

      // compute direction cosines
      this.computeCosines();

      // order the frames
      this.orderFrames();

      // compute/guess spacing
      this.computeSpacing();
      // set extra vars if nulls
      // do it now because before we would think image position/orientation
      // are defined and we would use it to compute spacing.
      if (!this._frame[0].imagePosition) {
        this._frame[0].imagePosition = [0, 0, 0];
      }
      if (!this._frame[0].imageOrientation) {
        this._frame[0].imageOrientation = [1, 0, 0, 0, 1, 0];
      }

      this._origin = this._arrayToVector3(this._frame[0].imagePosition, 0);

      // compute transforms
      this.computeIJK2LPS();

      this.computeLPS2AABB();
      // this.packEchos();

      this._rescaleSlope = this._frame[0].rescaleSlope || 1;
      this._rescaleIntercept = this._frame[0].rescaleIntercept || 0;

      // rescale/slope min max
      this.computeMinMaxIntensities();
      this._minMax[0] = ModelsStack.valueRescaleSlopeIntercept(this._minMax[0], this._rescaleSlope, this._rescaleIntercept);
      this._minMax[1] = ModelsStack.valueRescaleSlopeIntercept(this._minMax[1], this._rescaleSlope, this._rescaleIntercept);

      var width = this._frame[0].windowWidth || this._minMax[1] - this._minMax[0];
      this._windowWidth = this._rescaleSlope * width + this._rescaleIntercept;

      var center = this._frame[0].windowCenter || this._minMax[0] + width / 2;
      this._windowCenter = this._rescaleSlope * center + this._rescaleIntercept;

      this._bitsAllocated = this._frame[0].bitsAllocated;
      this._prepared = true;
    }
  }, {
    key: 'packEchos',
    value: function packEchos() {
      // 4 echo times...
      var echos = 4;
      var packedEcho = [];
      for (var i = 0; i < this._frame.length; i += echos) {
        var frame = this._frame[i];
        for (var k = 0; k < this._rows * this._columns; k++) {
          for (var j = 1; j < echos; j++) {
            frame.pixelData[k] += this._frame[i + j].pixelData[k];
          }
          frame.pixelData[k] /= echos;
        }
        packedEcho.push(frame);
      }
      this._frame = packedEcho;
      this._numberOfFrames = this._frame.length;
      this._dimensionsIJK = new THREE.Vector3(this._columns, this._rows, this._numberOfFrames);
      this._halfDimensionsIJK = new THREE.Vector3(this._dimensionsIJK.x / 2, this._dimensionsIJK.y / 2, this._dimensionsIJK.z / 2);
    }

    // frame.cosines - returns array [x, y, z]

  }, {
    key: 'computeCosines',
    value: function computeCosines() {
      if (this._frame && this._frame[0]) {
        var cosines = this._frame[0].cosines();
        this._xCosine = cosines[0];
        this._yCosine = cosines[1];
        this._zCosine = cosines[2];
      }
    }
  }, {
    key: 'orderFrames',
    value: function orderFrames() {
      // order the frames based on theirs dimension indices
      // first index is the most important.
      // 1,1,1,1 willl be first
      // 1,1,2,1 will be next
      // 1,1,2,3 will be next
      // 1,1,3,1 wil be next
      if (this._frame[0].dimensionIndexValues) {
        this._frame.sort(this._orderFrameOnDimensionIndicesArraySort);

        // else order with image position and orientation
      } else if (this._frame[0].imagePosition && this._frame[0].imageOrientation && this._frame[1] && this._frame[1].imagePosition && this._frame[1].imageOrientation && this._frame[0].imagePosition.join() !== this._frame[1].imagePosition.join()) {
        // compute and sort by dist in this series
        this._frame.map(this._computeDistanceArrayMap.bind(null, this._zCosine));
        this._frame.sort(this._sortDistanceArraySort);
      } else if (this._frame[0].instanceNumber !== null && this._frame[1] && this._frame[1].instanceNumber !== null && this._frame[0].instanceNumber !== this._frame[1].instanceNumber) {
        this._frame.sort(this._sortInstanceNumberArraySort);
      } else if (this._frame[0].sopInstanceUID && this._frame[1] && this._frame[1].sopInstanceUID && this._frame[0].sopInstanceUID !== this._frame[1].sopInstanceUID) {
        this._frame.sort(this._sortSopInstanceUIDArraySort);
      } else {
        // window.console.log(this._frame[0]);
        // window.console.log(this._frame[1]);
        // window.console.log(this._frame[0].instanceNumber !== null && true);
        // window.console.log(
        // this._frame[0].instanceNumber !== this._frame[1].instanceNumber);
        window.console.log('do not know how to order the frames...');
        // else slice location
        // image number
        // ORDERING BASED ON instance number
        // _ordering = 'instance_number';
        // first_image.sort(function(a,b){
        // return a["instance_number"]-b["instance_number"]});
      }
    }
  }, {
    key: 'computeSpacing',
    value: function computeSpacing() {
      this.xySpacing();
      this.zSpacing();
    }

    /**
     * Compute stack z spacing
     */

  }, {
    key: 'zSpacing',
    value: function zSpacing() {
      if (this._numberOfFrames > 1) {
        if (this._frame[0].pixelSpacing && this._frame[0].pixelSpacing[2]) {
          this._spacing.z = this._frame[0].pixelSpacing[2];
        } else {
          // compute and sort by dist in this series
          this._frame.map(this._computeDistanceArrayMap.bind(null, this._zCosine));

          // if distances are different, re-sort array
          if (this._frame[1].dist !== this._frame[0].dist) {
            this._frame.sort(this._sortDistanceArraySort);
            this._spacing.z = this._frame[1].dist - this._frame[0].dist;
          } else if (this._spacingBetweenSlices) {
            this._spacing.z = this._spacingBetweenSlices;
          } else if (this._frame[0].sliceThickness) {
            this._spacing.z = this._frame[0].sliceThickness;
          }
        }
      }

      // Spacing
      // can not be 0 if not matrix can not be inverted.
      if (this._spacing.z === 0) {
        this._spacing.z = 1;
      }
    }

    /**
     *  FRAME CAN DO IT
     */

  }, {
    key: 'xySpacing',
    value: function xySpacing() {
      if (this._frame && this._frame[0]) {
        var spacingXY = this._frame[0].spacingXY();
        this._spacing.x = spacingXY[0];
        this._spacing.y = spacingXY[1];
      }
    }

    /**
     * Find min and max intensities among all frames.
     */

  }, {
    key: 'computeMinMaxIntensities',
    value: function computeMinMaxIntensities() {
      // what about colors!!!!?
      for (var i = 0; i < this._frame.length; i++) {
        // get min/max
        this._minMax[0] = Math.min(this._minMax[0], this._frame[i].minMax[0]);
        this._minMax[1] = Math.max(this._minMax[1], this._frame[i].minMax[1]);
      }
    }

    /**
     * Compute IJK to LPS and invert transforms
     */

  }, {
    key: 'computeIJK2LPS',
    value: function computeIJK2LPS() {
      // ijk to lps
      this._ijk2LPS = _core4.default.ijk2LPS(this._xCosine, this._yCosine, this._zCosine, this._spacing, this._origin, this._regMatrix);

      // lps 2 ijk
      this._lps2IJK = new THREE.Matrix4();
      this._lps2IJK.getInverse(this._ijk2LPS);
    }

    /**
     * Compute LPS to AABB and invert transforms
     */

  }, {
    key: 'computeLPS2AABB',
    value: function computeLPS2AABB() {
      this._aabb2LPS = _core4.default.aabb2LPS(this._xCosine, this._yCosine, this._zCosine, this._origin);

      this._lps2AABB = new THREE.Matrix4();
      this._lps2AABB.getInverse(this._aabb2LPS);
    }

    /**
     * Merge stacks
     *
     * @param {*} stack
     *
     * @return {*}
     */

  }, {
    key: 'merge',
    value: function merge(stack) {
      // also make sure x/y/z cosines are a match!
      if (this._stackID === stack.stackID) {
        return this.mergeModels(this._frame, stack.frame);
      } else {
        return false;
      }
    }

    /**
     * Pack current stack pixel data into 8 bits array buffers
     */

  }, {
    key: 'pack',
    value: function pack() {
      // Get total number of voxels
      var nbVoxels = this._dimensionsIJK.x * this._dimensionsIJK.y * this._dimensionsIJK.z;

      // Packing style
      if (this._bitsAllocated === 16 && this._numberOfChannels === 1) {
        this._packedPerPixel = 2;
      }

      // Loop through all the textures we need
      var textureDimension = this._textureSize * this._textureSize;
      var requiredTextures = Math.ceil(nbVoxels / (textureDimension * this._packedPerPixel));
      var voxelIndexStart = 0;
      var voxelIndexStop = this._packedPerPixel * textureDimension;
      if (voxelIndexStop > nbVoxels) {
        voxelIndexStop = nbVoxels;
      }

      for (var ii = 0; ii < requiredTextures; ii++) {
        var packed = this._packTo8Bits(this._numberOfChannels, this._frame, this._textureSize, voxelIndexStart, voxelIndexStop);
        this._textureType = packed.textureType;
        this._rawData.push(packed.data);

        voxelIndexStart += this._packedPerPixel * textureDimension;
        voxelIndexStop += this._packedPerPixel * textureDimension;
        if (voxelIndexStop > nbVoxels) {
          voxelIndexStop = nbVoxels;
        }
      }

      this._packed = true;
    }

    /**
     * Pack frame data to 32 bits texture
     * @param {*} channels
     * @param {*} frame
     * @param {*} textureSize
     * @param {*} startVoxel
     * @param {*} stopVoxel
     */

  }, {
    key: '_packTo8Bits',
    value: function _packTo8Bits(channels, frame, textureSize, startVoxel, stopVoxel) {
      var packed = {
        textureType: null,
        data: null
      };

      var bitsAllocated = frame[0].bitsAllocated;
      var pixelType = frame[0].pixelType;

      // transform signed to unsigned for convenience
      var offset = 0;
      if (this._minMax[0] < 0) {
        offset -= this._minMax[0];
      }

      var packIndex = 0;
      var frameIndex = 0;
      var inFrameIndex = 0;
      // frame should return it!
      var frameDimension = frame[0].rows * frame[0].columns;

      if (bitsAllocated === 8 && channels === 1 || bitsAllocated === 1) {
        var data = new Uint8Array(textureSize * textureSize * 1);
        for (var i = startVoxel; i < stopVoxel; i++) {
          frameIndex = ~~(i / frameDimension);
          inFrameIndex = i % frameDimension;

          data[packIndex] = offset + frame[frameIndex].pixelData[inFrameIndex];
          packIndex++;
        }
        packed.textureType = THREE.LuminanceFormat;
        packed.data = data;
      } else if (bitsAllocated === 16 && channels === 1) {
        var _data = new Uint8Array(textureSize * textureSize * 4);
        var coordinate = 0;
        var channelOffset = 0;

        for (var _i3 = startVoxel; _i3 < stopVoxel; _i3++) {
          frameIndex = ~~(_i3 / frameDimension);
          inFrameIndex = _i3 % frameDimension;

          var raw = offset + frame[frameIndex].pixelData[inFrameIndex];
          _data[4 * coordinate + 2 * channelOffset] = raw & 0x00FF;
          _data[4 * coordinate + 2 * channelOffset + 1] = raw >>> 8 & 0x00FF;

          packIndex++;
          coordinate = Math.floor(packIndex / 2);
          channelOffset = packIndex % 2;
        }

        packed.textureType = THREE.RGBAFormat;
        packed.data = _data;
      } else if (bitsAllocated === 32 && channels === 1 && pixelType === 0) {
        var _data2 = new Uint8Array(textureSize * textureSize * 4);
        for (var _i4 = startVoxel; _i4 < stopVoxel; _i4++) {
          frameIndex = ~~(_i4 / frameDimension);
          inFrameIndex = _i4 % frameDimension;

          var _raw = offset + frame[frameIndex].pixelData[inFrameIndex];
          _data2[4 * packIndex] = _raw & 0x000000FF;
          _data2[4 * packIndex + 1] = _raw >>> 8 & 0x000000FF;
          _data2[4 * packIndex + 2] = _raw >>> 16 & 0x000000FF;
          _data2[4 * packIndex + 3] = _raw >>> 24 & 0x000000FF;

          packIndex++;
        }
        packed.textureType = THREE.RGBAFormat;
        packed.data = _data2;
      } else if (bitsAllocated === 32 && channels === 1 && pixelType === 1) {
        var _data3 = new Uint8Array(textureSize * textureSize * 4);

        for (var _i5 = startVoxel; _i5 < stopVoxel; _i5++) {
          frameIndex = ~~(_i5 / frameDimension);
          inFrameIndex = _i5 % frameDimension;

          var _raw2 = offset + frame[frameIndex].pixelData[inFrameIndex];
          var bitString = binaryString(_raw2);
          var bitStringArray = bitString.match(/.{1,8}/g);

          _data3[4 * packIndex] = parseInt(bitStringArray[0], 2);
          _data3[4 * packIndex + 1] = parseInt(bitStringArray[1], 2);
          _data3[4 * packIndex + 2] = parseInt(bitStringArray[2], 2);
          _data3[4 * packIndex + 3] = parseInt(bitStringArray[3], 2);

          packIndex++;
        }

        packed.textureType = THREE.RGBAFormat;
        packed.data = _data3;
      } else if (bitsAllocated === 8 && channels === 3) {
        var _data4 = new Uint8Array(textureSize * textureSize * 3);

        for (var _i6 = startVoxel; _i6 < stopVoxel; _i6++) {
          frameIndex = ~~(_i6 / frameDimension);
          inFrameIndex = _i6 % frameDimension;

          _data4[3 * packIndex] = frame[frameIndex].pixelData[3 * inFrameIndex];
          _data4[3 * packIndex + 1] = frame[frameIndex].pixelData[3 * inFrameIndex + 1];
          _data4[3 * packIndex + 2] = frame[frameIndex].pixelData[3 * inFrameIndex + 2];
          packIndex++;
        }

        packed.textureType = THREE.RGBFormat;
        packed.data = _data4;
      }

      return packed;
    }

    /**
     * Get the stack world center
     *
     *@return {*}
     */

  }, {
    key: 'worldCenter',
    value: function worldCenter() {
      var center = this._halfDimensionsIJK.clone().addScalar(-0.5).applyMatrix4(this._ijk2LPS);
      return center;
    }

    /**
     * Get the stack world bounding box
     * @return {*}
     */

  }, {
    key: 'worldBoundingBox',
    value: function worldBoundingBox() {
      var bbox = [Number.MAX_VALUE, Number.MIN_VALUE, Number.MAX_VALUE, Number.MIN_VALUE, Number.MAX_VALUE, Number.MIN_VALUE];

      var dims = this._dimensionsIJK;

      for (var i = 0; i <= dims.x; i += dims.x) {
        for (var j = 0; j <= dims.y; j += dims.y) {
          for (var k = 0; k <= dims.z; k += dims.z) {
            var world = new THREE.Vector3(i, j, k).applyMatrix4(this._ijk2LPS);
            bbox = [Math.min(bbox[0], world.x), Math.max(bbox[1], world.x), // x min/max
            Math.min(bbox[2], world.y), Math.max(bbox[3], world.y), Math.min(bbox[4], world.z), Math.max(bbox[5], world.z)];
          }
        }
      }

      return bbox;
    }

    /**
     * Get AABB size in LPS space.
     *
     * @return {*}
     */

  }, {
    key: 'AABBox',
    value: function AABBox() {
      var world0 = new THREE.Vector3().addScalar(-0.5).applyMatrix4(this._ijk2LPS).applyMatrix4(this._lps2AABB);

      var world7 = this._dimensionsIJK.clone().addScalar(-0.5).applyMatrix4(this._ijk2LPS).applyMatrix4(this._lps2AABB);

      var minBBox = new THREE.Vector3(Math.abs(world0.x - world7.x), Math.abs(world0.y - world7.y), Math.abs(world0.z - world7.z));

      return minBBox;
    }

    /**
     * Get AABB center in LPS space
     */

  }, {
    key: 'centerAABBox',
    value: function centerAABBox() {
      var centerBBox = this.worldCenter();
      centerBBox.applyMatrix4(this._lps2AABB);
      return centerBBox;
    }
  }, {
    key: '_arrayToVector3',
    value: function _arrayToVector3(array, index) {
      return new THREE.Vector3(array[index], array[index + 1], array[index + 2]);
    }
  }, {
    key: '_orderFrameOnDimensionIndicesArraySort',
    value: function _orderFrameOnDimensionIndicesArraySort(a, b) {
      if ('dimensionIndexValues' in a && Object.prototype.toString.call(a.dimensionIndexValues) === '[object Array]' && 'dimensionIndexValues' in b && Object.prototype.toString.call(b.dimensionIndexValues) === '[object Array]') {
        for (var i = 0; i < a.dimensionIndexValues.length; i++) {
          if (parseInt(a.dimensionIndexValues[i], 10) > parseInt(b.dimensionIndexValues[i], 10)) {
            return 1;
          }
          if (parseInt(a.dimensionIndexValues[i], 10) < parseInt(b.dimensionIndexValues[i], 10)) {
            return -1;
          }
        }
      } else {
        window.console.log('One of the frames doesn\'t have a dimensionIndexValues array.');
        window.console.log(a);
        window.console.log(b);
      }

      return 0;
    }
  }, {
    key: '_computeDistanceArrayMap',
    value: function _computeDistanceArrayMap(normal, frame) {
      frame.dist = frame.imagePosition[0] * normal.x + frame.imagePosition[1] * normal.y + frame.imagePosition[2] * normal.z;
      return frame;
    }
  }, {
    key: '_sortDistanceArraySort',
    value: function _sortDistanceArraySort(a, b) {
      return a.dist - b.dist;
    }
  }, {
    key: '_sortInstanceNumberArraySort',
    value: function _sortInstanceNumberArraySort(a, b) {
      return a.instanceNumber - b.instanceNumber;
    }
  }, {
    key: '_sortSopInstanceUIDArraySort',
    value: function _sortSopInstanceUIDArraySort(a, b) {
      return a.sopInstanceUID - b.sopInstanceUID;
    }
  }, {
    key: 'numberOfChannels',
    set: function set(numberOfChannels) {
      this._numberOfChannels = numberOfChannels;
    },
    get: function get() {
      return this._numberOfChannels;
    }
  }, {
    key: 'frame',
    set: function set(frame) {
      this._frame = frame;
    },
    get: function get() {
      return this._frame;
    }
  }, {
    key: 'prepared',
    set: function set(prepared) {
      this._prepared = prepared;
    },
    get: function get() {
      return this._prepared;
    }
  }, {
    key: 'packed',
    set: function set(packed) {
      this._packed = packed;
    },
    get: function get() {
      return this._packed;
    }
  }, {
    key: 'packedPerPixel',
    set: function set(packedPerPixel) {
      this._packedPerPixel = packedPerPixel;
    },
    get: function get() {
      return this._packedPerPixel;
    }
  }, {
    key: 'dimensionsIJK',
    set: function set(dimensionsIJK) {
      this._dimensionsIJK = dimensionsIJK;
    },
    get: function get() {
      return this._dimensionsIJK;
    }
  }, {
    key: 'halfDimensionsIJK',
    set: function set(halfDimensionsIJK) {
      this._halfDimensionsIJK = halfDimensionsIJK;
    },
    get: function get() {
      return this._halfDimensionsIJK;
    }
  }, {
    key: 'regMatrix',
    set: function set(regMatrix) {
      this._regMatrix = regMatrix;
    },
    get: function get() {
      return this._regMatrix;
    }
  }, {
    key: 'ijk2LPS',
    set: function set(ijk2LPS) {
      this._ijk2LPS = ijk2LPS;
    },
    get: function get() {
      return this._ijk2LPS;
    }
  }, {
    key: 'lps2IJK',
    set: function set(lps2IJK) {
      this._lps2IJK = lps2IJK;
    },
    get: function get() {
      return this._lps2IJK;
    }
  }, {
    key: 'lps2AABB',
    set: function set(lps2AABB) {
      this._lps2AABB = lps2AABB;
    },
    get: function get() {
      return this._lps2AABB;
    }
  }, {
    key: 'textureSize',
    set: function set(textureSize) {
      this._textureSize = textureSize;
    },
    get: function get() {
      return this._textureSize;
    }
  }, {
    key: 'textureType',
    set: function set(textureType) {
      this._textureType = textureType;
    },
    get: function get() {
      return this._textureType;
    }
  }, {
    key: 'bitsAllocated',
    set: function set(bitsAllocated) {
      this._bitsAllocated = bitsAllocated;
    },
    get: function get() {
      return this._bitsAllocated;
    }
  }, {
    key: 'rawData',
    set: function set(rawData) {
      this._rawData = rawData;
    },
    get: function get() {
      return this._rawData;
    }
  }, {
    key: 'windowWidth',
    get: function get() {
      return this._windowWidth;
    },
    set: function set(windowWidth) {
      this._windowWidth = windowWidth;
    }
  }, {
    key: 'windowCenter',
    get: function get() {
      return this._windowCenter;
    },
    set: function set(windowCenter) {
      this._windowCenter = windowCenter;
    }
  }, {
    key: 'rescaleSlope',
    get: function get() {
      return this._rescaleSlope;
    },
    set: function set(rescaleSlope) {
      this._rescaleSlope = rescaleSlope;
    }
  }, {
    key: 'rescaleIntercept',
    get: function get() {
      return this._rescaleIntercept;
    },
    set: function set(rescaleIntercept) {
      this._rescaleIntercept = rescaleIntercept;
    }
  }, {
    key: 'xCosine',
    get: function get() {
      return this._xCosine;
    },
    set: function set(xCosine) {
      this._xCosine = xCosine;
    }
  }, {
    key: 'yCosine',
    get: function get() {
      return this._yCosine;
    },
    set: function set(yCosine) {
      this._yCosine = yCosine;
    }
  }, {
    key: 'zCosine',
    get: function get() {
      return this._zCosine;
    },
    set: function set(zCosine) {
      this._zCosine = zCosine;
    }
  }, {
    key: 'minMax',
    get: function get() {
      return this._minMax;
    },
    set: function set(minMax) {
      this._minMax = minMax;
    }
  }, {
    key: 'stackID',
    get: function get() {
      return this._stackID;
    },
    set: function set(stackID) {
      this._stackID = stackID;
    }
  }, {
    key: 'pixelType',
    get: function get() {
      return this._pixelType;
    },
    set: function set(pixelType) {
      this._pixelType = pixelType;
    }
  }, {
    key: 'pixelRepresentation',
    get: function get() {
      return this._pixelRepresentation;
    },
    set: function set(pixelRepresentation) {
      this._pixelRepresentation = pixelRepresentation;
    }
  }, {
    key: 'invert',
    set: function set(invert) {
      this._invert = invert;
    },
    get: function get() {
      return this._invert;
    }
  }, {
    key: 'modality',
    set: function set(modality) {
      this._modality = modality;
    },
    get: function get() {
      return this._modality;
    }
  }, {
    key: 'rightHanded',
    get: function get() {
      return this._rightHanded;
    },
    set: function set(rightHanded) {
      this._rightHanded = rightHanded;
    }
  }, {
    key: 'spacingBetweenSlices',
    get: function get() {
      return this._spacingBetweenSlices;
    },
    set: function set(spacingBetweenSlices) {
      this._spacingBetweenSlices = spacingBetweenSlices;
    }
  }, {
    key: 'segmentationSegments',
    set: function set(segmentationSegments) {
      this._segmentationSegments = segmentationSegments;
    },
    get: function get() {
      return this._segmentationSegments;
    }
  }, {
    key: 'segmentationType',
    set: function set(segmentationType) {
      this._segmentationType = segmentationType;
    },
    get: function get() {
      return this._segmentationType;
    }
  }, {
    key: 'segmentationLUT',
    set: function set(segmentationLUT) {
      this._segmentationLUT = segmentationLUT;
    },
    get: function get() {
      return this._segmentationLUT;
    }
  }, {
    key: 'segmentationLUTO',
    set: function set(segmentationLUTO) {
      this._segmentationLUTO = segmentationLUTO;
    },
    get: function get() {
      return this._segmentationLUTO;
    }

    // DEPRECATED FUNCTION

    /**
     * @deprecated for core.utils.value
     *
     * Get voxel value.
     *
     * @param {*} stack
     * @param {*} coordinate
     *
     * @return {*}
     */

  }], [{
    key: 'indexInDimensions',
    value: function indexInDimensions(index, dimensions) {
      if (index.x >= 0 && index.y >= 0 && index.z >= 0 && index.x < dimensions.x && index.y < dimensions.y && index.z < dimensions.z) {
        return true;
      }

      return false;
    }
  }, {
    key: 'value',
    value: function value(stack, coordinate) {
      console.warn('models.stack.value is deprecated.\n       Please use core.utils.value instead.');
      return _core4.default.value(stack, coordinate);
    }

    /**
     * @deprecated for core.utils.rescaleSlopeIntercept
     *
     * Apply slope/intercept to a value.
     *
     * @param {*} value
     * @param {*} slope
     * @param {*} intercept
     *
     * @return {*}
     */

  }, {
    key: 'valueRescaleSlopeIntercept',
    value: function valueRescaleSlopeIntercept(value, slope, intercept) {
      console.warn('models.stack.valueRescaleSlopeIntercept is deprecated.\n       Please use core.utils.rescaleSlopeIntercept instead.');
      return _core4.default.rescaleSlopeIntercept(value, slope, intercept);
    }

    /**
     * @deprecated for core.utils.worldToData
     *
     * Transform coordinates from world coordinate to data
     *
     * @param {*} stack
     * @param {*} worldCoordinates
     *
     * @return {*}
     */

  }, {
    key: 'worldToData',
    value: function worldToData(stack, worldCoordinates) {
      console.warn('models.stack.worldToData is deprecated.\n       Please use core.utils.worldToData instead.');

      return _core4.default.worldToData(stack._lps2IJK, worldCoordinates);
    }
  }]);

  return ModelsStack;
}(_models2.default);

// Slicer way to handle images
// should follow it...
// 897   if ( (this->IndexSeriesInstanceUIDs[k] != idxSeriesInstanceUID && this->IndexSeriesInstanceUIDs[k] >= 0 && idxSeriesInstanceUID >= 0) ||
// 898        (this->IndexContentTime[k] != idxContentTime && this->IndexContentTime[k] >= 0 && idxContentTime >= 0) ||
// 899        (this->IndexTriggerTime[k] != idxTriggerTime && this->IndexTriggerTime[k] >= 0 && idxTriggerTime >= 0) ||
// 900        (this->IndexEchoNumbers[k] != idxEchoNumbers && this->IndexEchoNumbers[k] >= 0 && idxEchoNumbers >= 0) ||
// 901        (this->IndexDiffusionGradientOrientation[k] != idxDiffusionGradientOrientation  && this->IndexDiffusionGradientOrientation[k] >= 0 && idxDiffusionGradientOrientation >= 0) ||
// 902        (this->IndexSliceLocation[k] != idxSliceLocation && this->IndexSliceLocation[k] >= 0 && idxSliceLocation >= 0) ||
// 903        (this->IndexImageOrientationPatient[k] != idxImageOrientationPatient && this->IndexImageOrientationPatient[k] >= 0 && idxImageOrientationPatient >= 0) )
// 904     {
// 905       continue;
// 906     }


exports.default = ModelsStack;

},{"../core/core.colors":101,"../core/core.utils":105,"../models/models.base":130,"math-float32-to-binary-string":43}],135:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

/**
 * @module models/voxel
 */

var ModelsVoxel = function () {
  function ModelsVoxel() {
    _classCallCheck(this, ModelsVoxel);

    this._id = -1;
    this._worldCoordinates = null;
    this._dataCoordinates = null;
    this._screenCoordinates = null;
    this._value = null;
  }

  _createClass(ModelsVoxel, [{
    key: "worldCoordinates",
    set: function set(worldCoordinates) {
      this._worldCoordinates = worldCoordinates;
    },
    get: function get() {
      return this._worldCoordinates;
    }
  }, {
    key: "dataCoordinates",
    set: function set(dataCoordinates) {
      this._dataCoordinates = dataCoordinates;
    },
    get: function get() {
      return this._dataCoordinates;
    }
  }, {
    key: "screenCoordinates",
    set: function set(screenCoordinates) {
      this._screenCoordinates = screenCoordinates;
    },
    get: function get() {
      return this._screenCoordinates;
    }
  }, {
    key: "value",
    set: function set(value) {
      this._value = value;
    },
    get: function get() {
      return this._value;
    }
  }, {
    key: "id",
    set: function set(id) {
      this._id = id;
    },
    get: function get() {
      return this._id;
    }
  }]);

  return ModelsVoxel;
}();

exports.default = ModelsVoxel;

},{}],136:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

var _parsers = require('./parsers.volume');

var _parsers2 = _interopRequireDefault(_parsers);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
} // ftp://medical.nema.org/MEDICAL/Dicom/2014c/output/chtml/part05/sect_6.2.html/

// Slicer way to handle images
// should follow it...
// 897   if ( (this->IndexSeriesInstanceUIDs[k] != idxSeriesInstanceUID && this->IndexSeriesInstanceUIDs[k] >= 0 && idxSeriesInstanceUID >= 0) ||
// 898        (this->IndexContentTime[k] != idxContentTime && this->IndexContentTime[k] >= 0 && idxContentTime >= 0) ||
// 899        (this->IndexTriggerTime[k] != idxTriggerTime && this->IndexTriggerTime[k] >= 0 && idxTriggerTime >= 0) ||
// 900        (this->IndexEchoNumbers[k] != idxEchoNumbers && this->IndexEchoNumbers[k] >= 0 && idxEchoNumbers >= 0) ||
// 901        (this->IndexDiffusionGradientOrientation[k] != idxDiffusionGradientOrientation  && this->IndexDiffusionGradientOrientation[k] >= 0 && idxDiffusionGradientOrientation >= 0) ||
// 902        (this->IndexSliceLocation[k] != idxSliceLocation && this->IndexSliceLocation[k] >= 0 && idxSliceLocation >= 0) ||
// 903        (this->IndexImageOrientationPatient[k] != idxImageOrientationPatient && this->IndexImageOrientationPatient[k] >= 0 && idxImageOrientationPatient >= 0) )
// 904     {
// 905       continue;
// 906     }

/** * Imports ***/

var DicomParser = require('dicom-parser');
var Jpeg = require('jpeg-lossless-decoder-js');
var JpegBaseline = require('../../external/scripts/jpeg');
var Jpx = require('../../external/scripts/jpx');

/**
 * Dicom parser is a combination of utilities to get a VJS image from dicom files.
 *scripts
 * Relies on dcmjs, jquery, HTML5 fetch API, HTML5 promise API.
 *
 * @module parsers/dicom
 *
 * @param arrayBuffer {arraybuffer} - List of files to be parsed. It is urls from which
 * VJS.parsers.dicom can pull the data from.
 */

var ParsersDicom = function (_ParsersVolume) {
  _inherits(ParsersDicom, _ParsersVolume);

  function ParsersDicom(data, id) {
    _classCallCheck(this, ParsersDicom);

    var _this = _possibleConstructorReturn(this, (ParsersDicom.__proto__ || Object.getPrototypeOf(ParsersDicom)).call(this));

    _this._id = id;

    _this._arrayBuffer = data.buffer;

    var byteArray = new Uint8Array(_this._arrayBuffer);

    // catch error
    // throw error if any!
    _this._dataSet = null;

    try {
      _this._dataSet = DicomParser.parseDicom(byteArray);
    } catch (e) {
      window.console.log(e);
      throw 'parsers.dicom could not parse the file';
    }
    return _this;
  }

  // image/frame specific


  _createClass(ParsersDicom, [{
    key: 'seriesInstanceUID',
    value: function seriesInstanceUID() {
      return this._dataSet.string('x0020000e');
    }
  }, {
    key: 'studyInstanceUID',
    value: function studyInstanceUID() {
      return this._dataSet.string('x0020000d');
    }
  }, {
    key: 'modality',
    value: function modality() {
      return this._dataSet.string('x00080060');
    }
  }, {
    key: 'segmentationType',
    value: function segmentationType() {
      return this._dataSet.string('x00620001');
    }
  }, {
    key: 'segmentationSegments',
    value: function segmentationSegments() {
      var segmentationSegments = [];
      var segmentSequence = this._dataSet.elements.x00620002;

      if (!segmentSequence) {
        return segmentationSegments;
      }

      for (var i = 0; i < segmentSequence.items.length; i++) {
        var recommendedDisplayCIELab = this._recommendedDisplayCIELab(segmentSequence.items[i]);
        var segmentationCode = this._segmentationCode(segmentSequence.items[i]);
        var segmentNumber = segmentSequence.items[i].dataSet.uint16('x00620004');
        var segmentLabel = segmentSequence.items[i].dataSet.string('x00620005');
        var segmentAlgorithmType = segmentSequence.items[i].dataSet.string('x00620008');

        segmentationSegments.push({
          recommendedDisplayCIELab: recommendedDisplayCIELab,
          segmentationCodeDesignator: segmentationCode['segmentationCodeDesignator'],
          segmentationCodeValue: segmentationCode['segmentationCodeValue'],
          segmentationCodeMeaning: segmentationCode['segmentationCodeMeaning'],
          segmentNumber: segmentNumber,
          segmentLabel: segmentLabel,
          segmentAlgorithmType: segmentAlgorithmType
        });
      }

      return segmentationSegments;
    }
  }, {
    key: '_segmentationCode',
    value: function _segmentationCode(segment) {
      var segmentationCodeDesignator = 'unknown';
      var segmentationCodeValue = 'unknown';
      var segmentationCodeMeaning = 'unknown';
      var element = segment.dataSet.elements.x00082218;

      if (element && element.items && element.items.length > 0) {
        segmentationCodeDesignator = element.items[0].dataSet.string('x00080102');
        segmentationCodeValue = element.items[0].dataSet.string('x00080100');
        segmentationCodeMeaning = element.items[0].dataSet.string('x00080104');
      }

      return {
        segmentationCodeDesignator: segmentationCodeDesignator,
        segmentationCodeValue: segmentationCodeValue,
        segmentationCodeMeaning: segmentationCodeMeaning
      };
    }
  }, {
    key: '_recommendedDisplayCIELab',
    value: function _recommendedDisplayCIELab(segment) {
      if (!segment.dataSet.elements.x0062000d) {
        return null;
      }

      var offset = segment.dataSet.elements.x0062000d.dataOffset;
      var length = segment.dataSet.elements.x0062000d.length;
      var byteArray = segment.dataSet.byteArray.slice(offset, offset + length);

      // https://www.dabsoft.ch/dicom/3/C.10.7.1.1/
      var CIELabScaled = new Uint16Array(length / 2);
      for (var i = 0; i < length / 2; i++) {
        CIELabScaled[i] = (byteArray[2 * i + 1] << 8) + byteArray[2 * i];
      }

      var CIELabNormalized = [CIELabScaled[0] / 65535 * 100, CIELabScaled[1] / 65535 * 255 - 128, CIELabScaled[2] / 65535 * 255 - 128];

      return CIELabNormalized;
    }

    /**
     * SOP Instance UID
     *
     * @param {*} frameIndex
     *
     * @return {*}
     */

  }, {
    key: 'sopInstanceUID',
    value: function sopInstanceUID() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      var sopInstanceUID = this._findStringEverywhere('x2005140f', 'x00080018', frameIndex);
      return sopInstanceUID;
    }

    /**
     * Transfer syntax UID
     *
     * @return {*}
     */

  }, {
    key: 'transferSyntaxUID',
    value: function transferSyntaxUID() {
      return this._dataSet.string('x00020010');
    }

    /**
     * Study description
     *
     * @return {*}
     */

  }, {
    key: 'studyDescription',
    value: function studyDescription() {
      return this._dataSet.string('x00081030');
    }

    /**
     * Series description
     *
     * @return {*}
     */

  }, {
    key: 'seriesDescription',
    value: function seriesDescription() {
      return this._dataSet.string('x0008103e');
    }

    /**
     * Patient name
     *
     * @return {*}
     */

  }, {
    key: 'patientName',
    value: function patientName() {
      return this._dataSet.string('x00100010');
    }

    /**
     * Patient ID
     *
     * @return {*}
     */

  }, {
    key: 'patientID',
    value: function patientID() {
      return this._dataSet.string('x00100020');
    }

    /**
     * Patient birthdate
     *
     * @return {*}
     */

  }, {
    key: 'patientBirthdate',
    value: function patientBirthdate() {
      return this._dataSet.string('x00100030');
    }

    /**
     * Patient sex
     *
     * @return {*}
     */

  }, {
    key: 'patientSex',
    value: function patientSex() {
      return this._dataSet.string('x00100040');
    }

    /**
     * Patient age
     *
     * @return {*}
     */

  }, {
    key: 'patientAge',
    value: function patientAge() {
      return this._dataSet.string('x00101010');
    }

    /**
     * Photometric interpretation
     *
     * @return {*}
     */

  }, {
    key: 'photometricInterpretation',
    value: function photometricInterpretation() {
      return this._dataSet.string('x00280004');
    }
  }, {
    key: 'planarConfiguration',
    value: function planarConfiguration() {
      var planarConfiguration = this._dataSet.uint16('x00280006');

      if (typeof planarConfiguration === 'undefined') {
        planarConfiguration = null;
      }

      return planarConfiguration;
    }
  }, {
    key: 'samplesPerPixel',
    value: function samplesPerPixel() {
      return this._dataSet.uint16('x00280002');
    }
  }, {
    key: 'numberOfFrames',
    value: function numberOfFrames() {
      var numberOfFrames = this._dataSet.intString('x00280008');

      // need something smarter!
      if (typeof numberOfFrames === 'undefined') {
        numberOfFrames = null;
      }

      return numberOfFrames;
    }
  }, {
    key: 'numberOfChannels',
    value: function numberOfChannels() {
      var numberOfChannels = 1;
      var photometricInterpretation = this.photometricInterpretation();

      if (!(photometricInterpretation !== 'RGB' && photometricInterpretation !== 'PALETTE COLOR' && photometricInterpretation !== 'YBR_FULL' && photometricInterpretation !== 'YBR_FULL_422' && photometricInterpretation !== 'YBR_PARTIAL_422' && photometricInterpretation !== 'YBR_PARTIAL_420' && photometricInterpretation !== 'YBR_RCT')) {
        numberOfChannels = 3;
      }

      // make sure we return a number! (not a string!)
      return numberOfChannels;
    }
  }, {
    key: 'invert',
    value: function invert() {
      var photometricInterpretation = this.photometricInterpretation();

      return photometricInterpretation === 'MONOCHROME1' ? true : false;
    }
  }, {
    key: 'imageOrientation',
    value: function imageOrientation() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      // expect frame index to start at 0!
      var imageOrientation = this._findStringEverywhere('x00209116', 'x00200037', frameIndex);

      // format image orientation ('1\0\0\0\1\0') to array containing 6 numbers
      if (imageOrientation) {
        // make sure we return a number! (not a string!)
        // might not need to split (floatString + index)
        imageOrientation = imageOrientation.split('\\').map(Number);
      }

      return imageOrientation;
    }
  }, {
    key: 'referencedSegmentNumber',
    value: function referencedSegmentNumber() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      var referencedSegmentNumber = -1;
      var referencedSegmentNumberElement = this._findInGroupSequence('x52009230', 'x0062000a', frameIndex);

      if (referencedSegmentNumberElement !== null) {
        referencedSegmentNumber = referencedSegmentNumberElement.uint16('x0062000b');
      }

      return referencedSegmentNumber;
    }
  }, {
    key: 'pixelAspectRatio',
    value: function pixelAspectRatio() {
      var pixelAspectRatio = [this._dataSet.intString('x00280034', 0), this._dataSet.intString('x00280034', 1)];

      // need something smarter!
      if (typeof pixelAspectRatio[0] === 'undefined') {
        pixelAspectRatio = null;
      }

      // make sure we return a number! (not a string!)
      return pixelAspectRatio;
    }
  }, {
    key: 'imagePosition',
    value: function imagePosition() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      var imagePosition = this._findStringEverywhere('x00209113', 'x00200032', frameIndex);

      // format image orientation ('1\0\0\0\1\0') to array containing 6 numbers
      if (imagePosition) {
        // make sure we return a number! (not a string!)
        imagePosition = imagePosition.split('\\').map(Number);
      }

      return imagePosition;
    }
  }, {
    key: 'instanceNumber',
    value: function instanceNumber() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      var instanceNumber = null;
      // first look for frame!
      // per frame functionnal group sequence
      var perFrameFunctionnalGroupSequence = this._dataSet.elements.x52009230;

      if (typeof perFrameFunctionnalGroupSequence !== 'undefined') {
        if (perFrameFunctionnalGroupSequence.items[frameIndex].dataSet.elements.x2005140f) {
          var planeOrientationSequence = perFrameFunctionnalGroupSequence.items[frameIndex].dataSet.elements.x2005140f.items[0].dataSet;
          instanceNumber = planeOrientationSequence.intString('x00200013');
        } else {
          instanceNumber = this._dataSet.intString('x00200013');

          if (typeof instanceNumber === 'undefined') {
            instanceNumber = null;
          }
        }
      } else {
        // should we default to undefined??
        // default orientation
        instanceNumber = this._dataSet.intString('x00200013');

        if (typeof instanceNumber === 'undefined') {
          instanceNumber = null;
        }
      }

      return instanceNumber;
    }
  }, {
    key: 'pixelSpacing',
    value: function pixelSpacing() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      // expect frame index to start at 0!
      var pixelSpacing = this._findStringEverywhere('x00289110', 'x00280030', frameIndex);

      // format image orientation ('1\0\0\0\1\0') to array containing 6 numbers
      // should we default to undefined??
      if (pixelSpacing) {
        // make sure we return array of numbers! (not strings!)
        pixelSpacing = pixelSpacing.split('\\').map(Number);
      }

      return pixelSpacing;
    }
  }, {
    key: 'rows',
    value: function rows() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      var rows = this._dataSet.uint16('x00280010');

      if (typeof rows === 'undefined') {
        rows = null;
        // print warning at least...
      }

      return rows;
    }
  }, {
    key: 'columns',
    value: function columns() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      var columns = this._dataSet.uint16('x00280011');

      if (typeof columns === 'undefined') {
        columns = null;
        // print warning at least...
      }

      return columns;
    }
  }, {
    key: 'pixelType',
    value: function pixelType() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      // 0 integer, 1 float
      // dicom only support integers
      return 0;
    }
  }, {
    key: 'pixelRepresentation',
    value: function pixelRepresentation() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      var pixelRepresentation = this._dataSet.uint16('x00280103');
      return pixelRepresentation;
    }
  }, {
    key: 'bitsAllocated',
    value: function bitsAllocated() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      // expect frame index to start at 0!
      var bitsAllocated = this._dataSet.uint16('x00280100');
      return bitsAllocated;
    }
  }, {
    key: 'highBit',
    value: function highBit() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      // expect frame index to start at 0!
      var highBit = this._dataSet.uint16('x00280102');
      return highBit;
    }
  }, {
    key: 'rescaleIntercept',
    value: function rescaleIntercept() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      return this._findFloatStringInFrameGroupSequence('x00289145', 'x00281052', frameIndex);
    }
  }, {
    key: 'rescaleSlope',
    value: function rescaleSlope() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      return this._findFloatStringInFrameGroupSequence('x00289145', 'x00281053', frameIndex);
    }
  }, {
    key: 'windowCenter',
    value: function windowCenter() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      return this._findFloatStringInFrameGroupSequence('x00289132', 'x00281050', frameIndex);
    }
  }, {
    key: 'windowWidth',
    value: function windowWidth() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      return this._findFloatStringInFrameGroupSequence('x00289132', 'x00281051', frameIndex);
    }
  }, {
    key: 'sliceThickness',
    value: function sliceThickness() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      return this._findFloatStringInFrameGroupSequence('x00289110', 'x00180050', frameIndex);
    }
  }, {
    key: 'spacingBetweenSlices',
    value: function spacingBetweenSlices() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      var spacing = this._dataSet.intString('x00180088');

      if (typeof spacing === 'undefined') {
        spacing = null;
      }

      return spacing;
    }
  }, {
    key: 'dimensionIndexValues',
    value: function dimensionIndexValues() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      var dimensionIndexValues = null;

      // try to get it from enhanced MR images
      // per-frame functionnal group sequence
      var perFrameFunctionnalGroupSequence = this._dataSet.elements.x52009230;

      if (typeof perFrameFunctionnalGroupSequence !== 'undefined') {
        var frameContentSequence = perFrameFunctionnalGroupSequence.items[frameIndex].dataSet.elements.x00209111;
        if (frameContentSequence !== undefined && frameContentSequence !== null) {
          frameContentSequence = frameContentSequence.items[0].dataSet;
          var dimensionIndexValuesElt = frameContentSequence.elements.x00209157;
          if (dimensionIndexValuesElt !== undefined && dimensionIndexValuesElt !== null) {
            // /4 because UL
            var nbValues = dimensionIndexValuesElt.length / 4;
            dimensionIndexValues = [];

            for (var i = 0; i < nbValues; i++) {
              dimensionIndexValues.push(frameContentSequence.uint32('x00209157', i));
            }
          }
        }
      }

      return dimensionIndexValues;
    }
  }, {
    key: 'inStackPositionNumber',
    value: function inStackPositionNumber() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      var inStackPositionNumber = null;

      // try to get it from enhanced MR images
      // per-frame functionnal group sequence
      var perFrameFunctionnalGroupSequence = this._dataSet.elements.x52009230;

      if (typeof perFrameFunctionnalGroupSequence !== 'undefined') {
        // NOT A PHILIPS TRICK!
        var philipsPrivateSequence = perFrameFunctionnalGroupSequence.items[frameIndex].dataSet.elements.x00209111.items[0].dataSet;
        inStackPositionNumber = philipsPrivateSequence.uint32('x00209057');
      } else {
        inStackPositionNumber = null;
      }

      console.log('instack position ' + inStackPositionNumber);

      return inStackPositionNumber;
    }
  }, {
    key: 'stackID',
    value: function stackID() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      var stackID = null;

      // try to get it from enhanced MR images
      // per-frame functionnal group sequence
      var perFrameFunctionnalGroupSequence = this._dataSet.elements.x52009230;

      if (typeof perFrameFunctionnalGroupSequence !== 'undefined') {
        // NOT A PHILIPS TRICK!
        var philipsPrivateSequence = perFrameFunctionnalGroupSequence.items[frameIndex].dataSet.elements.x00209111.items[0].dataSet;
        stackID = philipsPrivateSequence.intString('x00209056');
      } else {
        stackID = null;
      }

      return stackID;
    }
  }, {
    key: 'extractPixelData',
    value: function extractPixelData() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      // decompress
      var decompressedData = this._decodePixelData(frameIndex);

      var numberOfChannels = this.numberOfChannels();

      if (numberOfChannels > 1) {
        return this._convertColorSpace(decompressedData);
      } else {
        return decompressedData;
      }
    }
  }, {
    key: 'minMaxPixelData',
    value: function minMaxPixelData() {
      var pixelData = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

      var minMax = [65535, -32768];
      var numPixels = pixelData.length;

      for (var index = 0; index < numPixels; index++) {
        var spv = pixelData[index];
        minMax[0] = Math.min(minMax[0], spv);
        minMax[1] = Math.max(minMax[1], spv);
      }

      return minMax;
    }

    //
    // private methods
    //

  }, {
    key: '_findInGroupSequence',
    value: function _findInGroupSequence(sequence, subsequence, index) {
      var functionalGroupSequence = this._dataSet.elements[sequence];

      if (typeof functionalGroupSequence !== 'undefined') {
        var inSequence = functionalGroupSequence.items[index].dataSet.elements[subsequence];

        if (typeof inSequence !== 'undefined') {
          return inSequence.items[0].dataSet;
        }
      }

      return null;
    }
  }, {
    key: '_findStringInGroupSequence',
    value: function _findStringInGroupSequence(sequence, subsequence, tag, index) {
      // index = 0 if shared!!!
      var dataSet = this._findInGroupSequence(sequence, subsequence, index);

      if (dataSet !== null) {
        return dataSet.string(tag);
      }

      return null;
    }
  }, {
    key: '_findStringInFrameGroupSequence',
    value: function _findStringInFrameGroupSequence(subsequence, tag, index) {
      return this._findStringInGroupSequence('x52009229', subsequence, tag, 0) || this._findStringInGroupSequence('x52009230', subsequence, tag, index);
    }
  }, {
    key: '_findStringEverywhere',
    value: function _findStringEverywhere(subsequence, tag, index) {
      var targetString = this._findStringInFrameGroupSequence(subsequence, tag, index);

      if (targetString === null) {
        targetString = this._dataSet.string(tag);
      }

      if (typeof targetString === 'undefined') {
        targetString = null;
      }

      return targetString;
    }
  }, {
    key: '_findFloatStringInGroupSequence',
    value: function _findFloatStringInGroupSequence(sequence, subsequence, tag, index) {
      var dataInGroupSequence = this._dataSet.floatString(tag);

      // try to get it from enhanced MR images
      // per-frame functionnal group
      if (typeof dataInGroupSequence === 'undefined') {
        dataInGroupSequence = this._findInGroupSequence(sequence, subsequence, index);

        if (dataInGroupSequence !== null) {
          return dataInGroupSequence.floatString(tag);
        } else {
          return null;
        }
      }

      return dataInGroupSequence;
    }
  }, {
    key: '_findFloatStringInFrameGroupSequence',
    value: function _findFloatStringInFrameGroupSequence(subsequence, tag, index) {
      return this._findFloatStringInGroupSequence('x52009229', subsequence, tag, 0) || this._findFloatStringInGroupSequence('x52009230', subsequence, tag, index);
    }
  }, {
    key: '_decodePixelData',
    value: function _decodePixelData() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      // if compressed..?
      var transferSyntaxUID = this.transferSyntaxUID();

      // find compression scheme
      if (transferSyntaxUID === '1.2.840.10008.1.2.4.90' ||
      // JPEG 2000 Lossless
      transferSyntaxUID === '1.2.840.10008.1.2.4.91') {
        // JPEG 2000 Lossy
        return this._decodeJ2K(frameIndex);
      } else if (transferSyntaxUID === '1.2.840.10008.1.2.4.57' ||
      // JPEG Lossless, Nonhierarchical (Processes 14)
      transferSyntaxUID === '1.2.840.10008.1.2.4.70') {
        // JPEG Lossless, Nonhierarchical (Processes 14 [Selection 1])
        return this._decodeJPEGLossless(frameIndex);
      } else if (transferSyntaxUID === '1.2.840.10008.1.2.4.50' ||
      // JPEG Baseline lossy process 1 (8 bit)
      transferSyntaxUID === '1.2.840.10008.1.2.4.51') {
        // JPEG Baseline lossy process 2 & 4 (12 bit)
        return this._decodeJPEGBaseline(frameIndex);
      } else if (transferSyntaxUID === '1.2.840.10008.1.2' ||
      // Implicit VR Little Endian
      transferSyntaxUID === '1.2.840.10008.1.2.1') {
        // Explicit VR Little Endian
        return this._decodeUncompressed(frameIndex);
      } else if (transferSyntaxUID === '1.2.840.10008.1.2.2') {
        // Explicit VR Big Endian
        var frame = this._decodeUncompressed(frameIndex);
        // and sawp it!
        return this._swapFrame(frame);
      } else {
        throw {
          error: 'no decoder for transfer syntax ' + transferSyntaxUID
        };
      }
    }
  }, {
    key: '_decodeJ2K',
    value: function _decodeJ2K() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      var encodedPixelData = DicomParser.readEncapsulatedPixelData(this._dataSet, this._dataSet.elements.x7fe00010, frameIndex);
      // let pixelDataElement = this._dataSet.elements.x7fe00010;
      // let pixelData = new Uint8Array(this._dataSet.byteArray.buffer, pixelDataElement.dataOffset, pixelDataElement.length);
      var jpxImage = new Jpx();
      // https://github.com/OHIF/image-JPEG2000/issues/6
      // It currently returns either Int16 or Uint16 based on whether the codestream is signed or not.
      jpxImage.parse(encodedPixelData);

      // let j2kWidth = jpxImage.width;
      // let j2kHeight = jpxImage.height;

      var componentsCount = jpxImage.componentsCount;
      if (componentsCount !== 1) {
        throw 'JPEG2000 decoder returned a componentCount of ${componentsCount}, when 1 is expected';
      }
      var tileCount = jpxImage.tiles.length;

      if (tileCount !== 1) {
        throw 'JPEG2000 decoder returned a tileCount of ${tileCount}, when 1 is expected';
      }

      var tileComponents = jpxImage.tiles[0];
      var pixelData = tileComponents.items;

      // window.console.log(j2kWidth, j2kHeight);

      return pixelData;
    }

    // from cornerstone

  }, {
    key: '_decodeJPEGLossless',
    value: function _decodeJPEGLossless() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      var encodedPixelData = DicomParser.readEncapsulatedPixelData(this._dataSet, this._dataSet.elements.x7fe00010, frameIndex);
      var pixelRepresentation = this.pixelRepresentation(frameIndex);
      var bitsAllocated = this.bitsAllocated(frameIndex);
      var byteOutput = bitsAllocated <= 8 ? 1 : 2;
      var decoder = new Jpeg.lossless.Decoder();
      var decompressedData = decoder.decode(encodedPixelData.buffer, encodedPixelData.byteOffset, encodedPixelData.length, byteOutput);

      if (pixelRepresentation === 0) {
        if (byteOutput === 2) {
          return new Uint16Array(decompressedData.buffer);
        } else {
          // untested!
          return new Uint8Array(decompressedData.buffer);
        }
      } else {
        return new Int16Array(decompressedData.buffer);
      }
    }
  }, {
    key: '_decodeJPEGBaseline',
    value: function _decodeJPEGBaseline() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      var encodedPixelData = DicomParser.readEncapsulatedPixelData(this._dataSet, this._dataSet.elements.x7fe00010, frameIndex);
      var rows = this.rows(frameIndex);
      var columns = this.columns(frameIndex);
      var bitsAllocated = this.bitsAllocated(frameIndex);
      var jpegBaseline = new JpegBaseline();
      jpegBaseline.parse(encodedPixelData);

      if (bitsAllocated === 8) {
        return jpegBaseline.getData(columns, rows);
      } else if (bitsAllocated === 16) {
        return jpegBaseline.getData16(columns, rows);
      }
    }
  }, {
    key: '_decodeUncompressed',
    value: function _decodeUncompressed() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      var pixelRepresentation = this.pixelRepresentation(frameIndex);
      var bitsAllocated = this.bitsAllocated(frameIndex);
      var pixelDataElement = this._dataSet.elements.x7fe00010;
      var pixelDataOffset = pixelDataElement.dataOffset;
      var numberOfChannels = this.numberOfChannels();
      var numPixels = this.rows(frameIndex) * this.columns(frameIndex) * numberOfChannels;
      var frameOffset = 0;
      var buffer = this._dataSet.byteArray.buffer;

      if (pixelRepresentation === 0 && bitsAllocated === 8) {
        // unsigned 8 bit
        frameOffset = pixelDataOffset + frameIndex * numPixels;
        return new Uint8Array(buffer, frameOffset, numPixels);
      } else if (pixelRepresentation === 0 && bitsAllocated === 16) {
        // unsigned 16 bit
        frameOffset = pixelDataOffset + frameIndex * numPixels * 2;
        return new Uint16Array(buffer, frameOffset, numPixels);
      } else if (pixelRepresentation === 1 && bitsAllocated === 16) {
        // signed 16 bit
        frameOffset = pixelDataOffset + frameIndex * numPixels * 2;
        return new Int16Array(buffer, frameOffset, numPixels);
      } else if (pixelRepresentation === 0 && bitsAllocated === 32) {
        // unsigned 32 bit
        frameOffset = pixelDataOffset + frameIndex * numPixels * 4;
        return new Uint32Array(buffer, frameOffset, numPixels);
      } else if (pixelRepresentation === 0 && bitsAllocated === 1) {
        var newBuffer = new ArrayBuffer(numPixels);
        var newArray = new Uint8Array(newBuffer);

        frameOffset = pixelDataOffset + frameIndex * numPixels;
        var index = 0;

        var bitStart = frameIndex * numPixels;
        var bitEnd = frameIndex * numPixels + numPixels;

        var byteStart = Math.floor(bitStart / 8);
        var bitStartOffset = bitStart - byteStart * 8;
        var byteEnd = Math.ceil(bitEnd / 8);

        var targetBuffer = new Uint8Array(buffer, pixelDataOffset);

        for (var i = byteStart; i <= byteEnd; i++) {
          while (bitStartOffset < 8) {
            switch (bitStartOffset) {
              case 0:
                newArray[index] = targetBuffer[i] & 0x0001;
                break;
              case 1:
                newArray[index] = targetBuffer[i] >>> 1 & 0x0001;
                break;
              case 2:
                newArray[index] = targetBuffer[i] >>> 2 & 0x0001;
                break;
              case 3:
                newArray[index] = targetBuffer[i] >>> 3 & 0x0001;
                break;
              case 4:
                newArray[index] = targetBuffer[i] >>> 4 & 0x0001;
                break;
              case 5:
                newArray[index] = targetBuffer[i] >>> 5 & 0x0001;
                break;
              case 6:
                newArray[index] = targetBuffer[i] >>> 6 & 0x0001;
                break;
              case 7:
                newArray[index] = targetBuffer[i] >>> 7 & 0x0001;
                break;
              default:
                break;
            }

            bitStartOffset++;
            index++;
            // if return..
            if (index >= numPixels) {
              return newArray;
            }
          }
          bitStartOffset = 0;
        }
      }
    }
  }, {
    key: '_convertColorSpace',
    value: function _convertColorSpace(uncompressedData) {
      var rgbData = null;
      var photometricInterpretation = this.photometricInterpretation();
      var planarConfiguration = this.planarConfiguration();

      if (photometricInterpretation === 'RGB' && planarConfiguration === 0) {
        // ALL GOOD, ALREADY ORDERED
        // planar or non planar planarConfiguration
        rgbData = uncompressedData;
      } else if (photometricInterpretation === 'RGB' && planarConfiguration === 1) {
        if (uncompressedData instanceof Int8Array) {
          rgbData = new Int8Array(uncompressedData.length);
        } else if (uncompressedData instanceof Uint8Array) {
          rgbData = new Uint8Array(uncompressedData.length);
        } else if (uncompressedData instanceof Int16Array) {
          rgbData = new Int16Array(uncompressedData.length);
        } else if (uncompressedData instanceof Uint16Array) {
          rgbData = new Uint16Array(uncompressedData.length);
        } else {
          throw 'unsuported typed array: ${uncompressedData}';
        }

        var numPixels = uncompressedData.length / 3;
        var rgbaIndex = 0;
        var rIndex = 0;
        var gIndex = numPixels;
        var bIndex = numPixels * 2;
        for (var i = 0; i < numPixels; i++) {
          rgbData[rgbaIndex++] = uncompressedData[rIndex++]; // red
          rgbData[rgbaIndex++] = uncompressedData[gIndex++]; // green
          rgbData[rgbaIndex++] = uncompressedData[bIndex++]; // blue
        }
      } else if (photometricInterpretation === 'YBR_FULL') {
        if (uncompressedData instanceof Int8Array) {
          rgbData = new Int8Array(uncompressedData.length);
        } else if (uncompressedData instanceof Uint8Array) {
          rgbData = new Uint8Array(uncompressedData.length);
        } else if (uncompressedData instanceof Int16Array) {
          rgbData = new Int16Array(uncompressedData.length);
        } else if (uncompressedData instanceof Uint16Array) {
          rgbData = new Uint16Array(uncompressedData.length);
        } else {
          throw 'unsuported typed array: ${uncompressedData}';
        }

        // https://github.com/chafey/cornerstoneWADOImageLoader/blob/master/src/decodeYBRFull.js
        var nPixels = uncompressedData.length / 3;
        var ybrIndex = 0;
        var _rgbaIndex = 0;
        for (var _i = 0; _i < nPixels; _i++) {
          var y = uncompressedData[ybrIndex++];
          var cb = uncompressedData[ybrIndex++];
          var cr = uncompressedData[ybrIndex++];
          rgbData[_rgbaIndex++] = y + 1.40200 * (cr - 128); // red
          rgbData[_rgbaIndex++] = y - 0.34414 * (cb - 128) - 0.71414 * (cr - 128); // green
          rgbData[_rgbaIndex++] = y + 1.77200 * (cb - 128); // blue
          // rgbData[rgbaIndex++] = 255; //alpha
        }
      } else {
        throw 'photometric interpolation not supported: ${photometricInterpretation}';
      }

      return rgbData;
    }

    /**
     * Swap bytes in frame.
     */

  }, {
    key: '_swapFrame',
    value: function _swapFrame(frame) {
      // swap bytes ( if 8bits (1byte), nothing to swap)
      var bitsAllocated = this.bitsAllocated();

      if (bitsAllocated === 16) {
        for (var i = 0; i < frame.length; i++) {
          frame[i] = this._swap16(frame[i]);
        }
      } else if (bitsAllocated === 32) {
        for (var _i2 = 0; _i2 < frame.length; _i2++) {
          frame[_i2] = this._swap32(frame[_i2]);
        }
      }

      return frame;
    }
  }]);

  return ParsersDicom;
}(_parsers2.default);

// VJS.parsers.dicom.prototype.frameOfReferenceUID = function(imageJqueryDom) {
//   // try to access frame of reference UID through its DICOM tag
//   let seriesNumber = imageJqueryDom.find('[tag="00200052"] Value').text();

//   // if not available, assume we only have 1 frame
//   if (seriesNumber === '') {
//     seriesNumber = 1;
//   }
//   return seriesNumber;
// };

//
// ENDIAN NESS NOT TAKEN CARE OF
// http://stackoverflow.com/questions/5320439/how-do-i-swap-endian-ness-byte-order-of-a-letiable-in-javascript
// http://www.barre.nom.fr/medical/samples/
//
//


exports.default = ParsersDicom;

},{"../../external/scripts/jpeg":1,"../../external/scripts/jpx":2,"./parsers.volume":141,"dicom-parser":25,"jpeg-lossless-decoder-js":35}],137:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _parsers = require('./parsers.dicom');

var _parsers2 = _interopRequireDefault(_parsers);

var _parsers3 = require('./parsers.nifti');

var _parsers4 = _interopRequireDefault(_parsers3);

var _parsers5 = require('./parsers.nrrd');

var _parsers6 = _interopRequireDefault(_parsers5);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

/**
 * @module parsers
 */

exports.default = {
  Dicom: _parsers2.default,
  Nifti: _parsers4.default,
  Nrrd: _parsers6.default
};

},{"./parsers.dicom":136,"./parsers.nifti":139,"./parsers.nrrd":140}],138:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

var _parsers = require('./parsers.volume');

var _parsers2 = _interopRequireDefault(_parsers);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
} /** * Imports ***/

/**
 * @module parsers/mhd
 */
var ParsersMHD = function (_ParsersVolume) {
  _inherits(ParsersMHD, _ParsersVolume);

  function ParsersMHD(data, id) {
    _classCallCheck(this, ParsersMHD);

    /**
      * @member
      * @type {arraybuffer}
    */
    var _this = _possibleConstructorReturn(this, (ParsersMHD.__proto__ || Object.getPrototypeOf(ParsersMHD)).call(this));

    _this._id = id;
    _this._url = data.url;
    _this._header = {};
    _this._buffer = null;

    try {
      // parse header (mhd) data
      var lines = new TextDecoder().decode(data.mhdBuffer).split('\n');
      lines.forEach(function (line) {
        var keyvalue = line.split('=');
        if (keyvalue.length === 2) {
          _this._header[keyvalue[0].trim()] = keyvalue[1].trim();
        }
      });

      _this._header.DimSize = _this._header.DimSize.split(' ');
      _this._header.ElementSpacing = _this._header.ElementSpacing.split(' ');
      _this._header.TransformMatrix = _this._header.TransformMatrix.split(' ');
      _this._header.Offset = _this._header.Offset.split(' ');
      //
      _this._buffer = data.rawBuffer;
    } catch (error) {
      window.console.log('ooops... :(');
    }
    return _this;
  }

  _createClass(ParsersMHD, [{
    key: 'rightHanded',
    value: function rightHanded() {
      var anatomicalOrientation = this._header.AnatomicalOrientation;
      if (anatomicalOrientation === 'RAS' || anatomicalOrientation === 'RPI' || anatomicalOrientation === 'LPS' || anatomicalOrientation === 'LAI') {
        this._rightHanded = true;
      } else {
        this._rightHanded = false;
      }

      return this._rightHanded;
    }
  }, {
    key: 'seriesInstanceUID',
    value: function seriesInstanceUID() {
      // use filename + timestamp..?
      return this._url;
    }
  }, {
    key: 'numberOfFrames',
    value: function numberOfFrames() {
      return parseInt(this._header.DimSize[2], 10);
    }
  }, {
    key: 'sopInstanceUID',
    value: function sopInstanceUID() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      return frameIndex;
    }
  }, {
    key: 'rows',
    value: function rows() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      return parseInt(this._header.DimSize[1], 10);
    }
  }, {
    key: 'columns',
    value: function columns() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      return parseInt(this._header.DimSize[0], 10);
    }
  }, {
    key: 'pixelType',
    value: function pixelType() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      // 0 - int
      // 1 - float
      return 0;
    }
  }, {
    key: 'bitsAllocated',
    value: function bitsAllocated() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      var bitsAllocated = 1;

      if (this._header.ElementType === 'MET_UCHAR' || this._header.ElementType === 'MET_CHAR') {
        bitsAllocated = 8;
      } else if (this._header.ElementType === 'MET_USHORT' || this._header.ElementType === 'MET_SHORT') {
        bitsAllocated = 16;
      } else if (this._header.ElementType === 'MET_UFLOAT' || this._header.ElementType === 'MET_FLOAT') {
        bitsAllocated = 32;
      }

      return bitsAllocated;
    }
  }, {
    key: 'pixelSpacing',
    value: function pixelSpacing() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      var x = parseFloat(this._header.ElementSpacing[0], 10);
      var y = parseFloat(this._header.ElementSpacing[1], 10);
      var z = parseFloat(this._header.ElementSpacing[2], 10);
      return [x, y, z];
    }
  }, {
    key: 'imageOrientation',
    value: function imageOrientation() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      var invertX = this._header.AnatomicalOrientation.match(/L/) ? -1 : 1;
      var invertY = this._header.AnatomicalOrientation.match(/P/) ? -1 : 1;

      var x = new THREE.Vector3(parseFloat(this._header.TransformMatrix[0]) * invertX, parseFloat(this._header.TransformMatrix[1]) * invertY, parseFloat(this._header.TransformMatrix[2]));
      x.normalize();

      var y = new THREE.Vector3(parseFloat(this._header.TransformMatrix[3]) * invertX, parseFloat(this._header.TransformMatrix[4]) * invertY, parseFloat(this._header.TransformMatrix[5]));
      y.normalize();

      return [x.x, x.y, x.z, y.x, y.y, y.z];
    }
  }, {
    key: 'imagePosition',
    value: function imagePosition() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      return [parseFloat(this._header.Offset[0]), parseFloat(this._header.Offset[1]), parseFloat(this._header.Offset[2])];
    }
  }, {
    key: 'minMaxPixelData',
    value: function minMaxPixelData() {
      var pixelData = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

      var minMax = [65535, -32768];
      var numPixels = pixelData.length;
      for (var index = 0; index < numPixels; index++) {
        var spv = pixelData[index];
        minMax[0] = Math.min(minMax[0], spv);
        minMax[1] = Math.max(minMax[1], spv);
      }

      return minMax;
    }
  }, {
    key: 'extractPixelData',
    value: function extractPixelData() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      return this._decompressUncompressed(frameIndex);
    }
  }, {
    key: '_decompressUncompressed',
    value: function _decompressUncompressed() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      var buffer = this._buffer;
      var numberOfChannels = this.numberOfChannels();
      var numPixels = this.rows(frameIndex) * this.columns(frameIndex) * numberOfChannels;
      if (!this.rightHanded()) {
        frameIndex = this.numberOfFrames() - 1 - frameIndex;
      }
      var frameOffset = frameIndex * numPixels;

      if (this._header.ElementType === 'MET_CHAR') {
        frameOffset = frameOffset;
        return new Int8Array(buffer, frameOffset, numPixels);
      } else if (this._header.ElementType === 'MET_UCHAR') {
        frameOffset = frameOffset;
        return new Uint8Array(buffer, frameOffset, numPixels);
      } else if (this._header.ElementType === 'MET_SHORT') {
        frameOffset = frameOffset * 2;
        return new Int16Array(buffer, frameOffset, numPixels);
      } else if (this._header.ElementType === 'MET_USHORT') {
        frameOffset = frameOffset * 2;
        return new Uint16Array(buffer, frameOffset, numPixels);
      } else if (this._header.ElementType === 'MET_FLOAT') {
        frameOffset = frameOffset * 4;
        return new Float32Array(buffer, frameOffset, numPixels);
      }
    }
  }]);

  return ParsersMHD;
}(_parsers2.default);

exports.default = ParsersMHD;

},{"./parsers.volume":141}],139:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

var _parsers = require('./parsers.volume');

var _parsers2 = _interopRequireDefault(_parsers);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
} // use nifti-js and just parse header.???

// Slicer way to handle images
// should follow it...
// 897   if ( (this->IndexSeriesInstanceUIDs[k] != idxSeriesInstanceUID && this->IndexSeriesInstanceUIDs[k] >= 0 && idxSeriesInstanceUID >= 0) ||
// 898        (this->IndexContentTime[k] != idxContentTime && this->IndexContentTime[k] >= 0 && idxContentTime >= 0) ||
// 899        (this->IndexTriggerTime[k] != idxTriggerTime && this->IndexTriggerTime[k] >= 0 && idxTriggerTime >= 0) ||
// 900        (this->IndexEchoNumbers[k] != idxEchoNumbers && this->IndexEchoNumbers[k] >= 0 && idxEchoNumbers >= 0) ||
// 901        (this->IndexDiffusionGradientOrientation[k] != idxDiffusionGradientOrientation  && this->IndexDiffusionGradientOrientation[k] >= 0 && idxDiffusionGradientOrientation >= 0) ||
// 902        (this->IndexSliceLocation[k] != idxSliceLocation && this->IndexSliceLocation[k] >= 0 && idxSliceLocation >= 0) ||
// 903        (this->IndexImageOrientationPatient[k] != idxImageOrientationPatient && this->IndexImageOrientationPatient[k] >= 0 && idxImageOrientationPatient >= 0) )
// 904     {
// 905       continue;
// 906     }

// http://brainder.org/2012/09/23/the-nifti-file-format/

/** * Imports ***/

var NiftiReader = require('nifti-reader-js');
/**
 * @module parsers/nifti
 */

var ParsersNifti = function (_ParsersVolume) {
  _inherits(ParsersNifti, _ParsersVolume);

  function ParsersNifti(data, id) {
    _classCallCheck(this, ParsersNifti);

    /**
      * @member
      * @type {arraybuffer}
    */
    var _this = _possibleConstructorReturn(this, (ParsersNifti.__proto__ || Object.getPrototypeOf(ParsersNifti)).call(this));

    _this._id = id;
    _this._arrayBuffer = data.buffer;
    _this._url = data.url;
    _this._dataSet = null;
    _this._niftiHeader = null;
    _this._niftiImage = null;
    _this._ordered = true;
    _this._orderedData = null;

    //
    _this._qfac = 1.0;

    if (NiftiReader.isNIFTI(_this._arrayBuffer)) {
      _this._dataSet = NiftiReader.readHeader(_this._arrayBuffer);
      _this._niftiImage = NiftiReader.readImage(_this._dataSet, _this._arrayBuffer);
    } else {
      throw 'parsers.nifti could not parse the file';
    }
    return _this;
  }

  _createClass(ParsersNifti, [{
    key: 'seriesInstanceUID',
    value: function seriesInstanceUID() {
      // use filename + timestamp..?
      return this._url;
    }
  }, {
    key: 'numberOfFrames',
    value: function numberOfFrames() {
      return this._dataSet.dims[3];
    }
  }, {
    key: 'numberOfChannels',
    value: function numberOfChannels() {
      var numberOfChannels = 1;

      // can dims[0] >= 5 and not multi channels with RGB datatypecode?

      if (this._dataSet.dims[0] >= 5) {
        numberOfChannels = this._dataSet.dims[5];
        this._ordered = false;
      } else if (this._dataSet.datatypeCode === 128) {
        numberOfChannels = 3;
      } else if (this._dataSet.datatypeCode === 2304) {
        numberOfChannels = 4;
      }

      return numberOfChannels;
    }
  }, {
    key: 'sopInstanceUID',
    value: function sopInstanceUID() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      return frameIndex;
    }
  }, {
    key: 'rows',
    value: function rows() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      return this._dataSet.dims[2];
    }
  }, {
    key: 'columns',
    value: function columns() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      return this._dataSet.dims[1];
    }
  }, {
    key: 'pixelType',
    value: function pixelType() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      // papaya.volume.nifti.NIFTI_TYPE_UINT8           = 2;
      // papaya.volume.nifti.NIFTI_TYPE_INT16           = 4;
      // papaya.volume.nifti.NIFTI_TYPE_INT32           = 8;
      // papaya.volume.nifti.NIFTI_TYPE_FLOAT32        = 16;
      // papaya.volume.nifti.NIFTI_TYPE_COMPLEX64      = 32;
      // papaya.volume.nifti.NIFTI_TYPE_FLOAT64        = 64;
      // papaya.volume.nifti.NIFTI_TYPE_RGB24         = 128;
      // papaya.volume.nifti.NIFTI_TYPE_INT8          = 256;
      // papaya.volume.nifti.NIFTI_TYPE_UINT16        = 512;
      // papaya.volume.nifti.NIFTI_TYPE_UINT32        = 768;
      // papaya.volume.nifti.NIFTI_TYPE_INT64        = 1024;
      // papaya.volume.nifti.NIFTI_TYPE_UINT64       = 1280;
      // papaya.volume.nifti.NIFTI_TYPE_FLOAT128     = 1536;
      // papaya.volume.nifti.NIFTI_TYPE_COMPLEX128   = 1792;
      // papaya.volume.nifti.NIFTI_TYPE_COMPLEX256   = 2048;

      // 0 integer, 1 float

      var pixelType = 0;
      if (this._dataSet.datatypeCode === 16 || this._dataSet.datatypeCode === 64 || this._dataSet.datatypeCode === 1536) {
        pixelType = 1;
      }
      return pixelType;
    }
  }, {
    key: 'bitsAllocated',
    value: function bitsAllocated() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      return this._dataSet.numBitsPerVoxel;
    }
  }, {
    key: 'pixelSpacing',
    value: function pixelSpacing() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      return [this._dataSet.pixDims[1], this._dataSet.pixDims[2], this._dataSet.pixDims[3]];
    }
  }, {
    key: 'sliceThickness',
    value: function sliceThickness() {
      // should be a string...
      return null; // this._dataSet.pixDims[3].toString();
    }
  }, {
    key: 'imageOrientation',
    value: function imageOrientation() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      // window.console.log(this._dataSet);
      // http://nifti.nimh.nih.gov/pub/dist/src/niftilib/nifti1.h
      // http://nifti.nimh.nih.gov/pub/dist/src/niftilib/nifti1_io.c
      if (this._dataSet.qform_code > 0) {
        // https://github.com/Kitware/ITK/blob/master/Modules/IO/NIFTI/src/itkNiftiImageIO.cxx
        var a = 0.0;
        var b = this._dataSet.quatern_b;
        var c = this._dataSet.quatern_c;
        var d = this._dataSet.quatern_d;
        // compute a
        a = 1.0 - (b * b + c * c + d * d);
        if (a < 0.0000001) {
          /* special case */

          a = 1.0 / Math.sqrt(b * b + c * c + d * d);
          b *= a;c *= a;d *= a; /* normalize (b,c,d) vector */
          a = 0.0; /* a = 0 ==> 180 degree rotation */
        } else {
          a = Math.sqrt(a); /* angle = 2*arccos(a) */
        }

        if (this._dataSet.pixDims[0] < 0.0) {
          this._rightHanded = false;
        }

        return [-(a * a + b * b - c * c - d * d), -2 * (b * c + a * d), 2 * (b * d - a * c), -2 * (b * c - a * d), -(a * a + c * c - b * b - d * d), 2 * (c * d + a * b)];
      } else if (this._dataSet.sform_code > 0) {
        console.log('sform > 0');

        var sx = this._dataSet.srow_x;
        var sy = this._dataSet.srow_y;
        var sz = this._dataSet.srow_z;
        // fill IJKToRAS
        // goog.vec.Mat4.setRowValues(IJKToRAS, 0, sx[0], sx[1], sx[2], sx[3]);
        // goog.vec.Mat4.setRowValues(IJKToRAS, 1, sy[0], sy[1], sy[2], sy[3]);
        // goog.vec.Mat4.setRowValues(IJKToRAS, 2, sz[0], sz[1], sz[2], sz[3]);
      } else if (this._dataSet.qform_code === 0) {
        console.log('qform === 0');

        // fill IJKToRAS
        // goog.vec.Mat4.setRowValues(IJKToRAS, 0, MRI.pixdim[1], 0, 0, 0);
        // goog.vec.Mat4.setRowValues(IJKToRAS, 1, 0, MRI.pixdim[2], 0, 0);
        // goog.vec.Mat4.setRowValues(IJKToRAS, 2, 0, 0, MRI.pixdim[3], 0);
      }
      return [1, 0, 0, 0, 1, 0];
    }
  }, {
    key: 'imagePosition',
    value: function imagePosition() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      // qoffset is RAS
      return [-this._dataSet.qoffset_x, -this._dataSet.qoffset_y, this._dataSet.qoffset_z];
    }
  }, {
    key: 'dimensionIndexValues',
    value: function dimensionIndexValues() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      return null;
    }
  }, {
    key: 'instanceNumber',
    value: function instanceNumber() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      return frameIndex;
    }
  }, {
    key: 'windowCenter',
    value: function windowCenter() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      // calc min and calc max
      return null;
    }
  }, {
    key: 'windowWidth',
    value: function windowWidth() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      // calc min and calc max
      return null;
    }
  }, {
    key: 'rescaleSlope',
    value: function rescaleSlope() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      return this._dataSet.scl_slope;
    }
  }, {
    key: 'rescaleIntercept',
    value: function rescaleIntercept() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      return this._dataSet.scl_intercept;
    }
  }, {
    key: 'minMaxPixelData',
    value: function minMaxPixelData() {
      var pixelData = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

      var minMax = [65535, -32768];
      var numPixels = pixelData.length;
      for (var index = 0; index < numPixels; index++) {
        var spv = pixelData[index];
        minMax[0] = Math.min(minMax[0], spv);
        minMax[1] = Math.max(minMax[1], spv);
      }

      return minMax;
    }
  }, {
    key: 'extractPixelData',
    value: function extractPixelData() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      return this._decompressUncompressed(frameIndex);
      // let buffer = this._dataSet.imageData;
      // if (this._dataSet.compressed) {
      // let buffer = this._dataSet.rawData[0];
      // try {
      //   let data = pako.inflate(new Uint8Array(buffer));
      //   buffer = data.buffer;
      // } catch (err) {
      //   console.log(err);
      // }

      // window.console.log(buffer);
      // }

      // is it compressed?
      // yes/no

      //     try {
      //   var result = pako.inflate(compressed);
      // } catch (err) {
      //   console.log(err);
      // }

      // window.console.log(this);
    }
  }, {
    key: '_decompressUncompressed',
    value: function _decompressUncompressed() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      // papaya.volume.nifti.NIFTI_TYPE_UINT8           = 2;
      // papaya.volume.nifti.NIFTI_TYPE_INT16           = 4;
      // papaya.volume.nifti.NIFTI_TYPE_INT32           = 8;
      // papaya.volume.nifti.NIFTI_TYPE_FLOAT32        = 16;
      // papaya.volume.nifti.NIFTI_TYPE_COMPLEX64      = 32;
      // papaya.volume.nifti.NIFTI_TYPE_FLOAT64        = 64;
      // papaya.volume.nifti.NIFTI_TYPE_RGB24         = 128;
      // papaya.volume.nifti.NIFTI_TYPE_INT8          = 256;
      // papaya.volume.nifti.NIFTI_TYPE_UINT16        = 512;
      // papaya.volume.nifti.NIFTI_TYPE_UINT32        = 768;
      // papaya.volume.nifti.NIFTI_TYPE_INT64        = 1024;
      // papaya.volume.nifti.NIFTI_TYPE_UINT64       = 1280;
      // papaya.volume.nifti.NIFTI_TYPE_FLOAT128     = 1536;
      // papaya.volume.nifti.NIFTI_TYPE_COMPLEX128   = 1792;
      // papaya.volume.nifti.NIFTI_TYPE_COMPLEX256   = 2048;

      var numberOfChannels = this.numberOfChannels();
      var numPixels = this.rows(frameIndex) * this.columns(frameIndex) * numberOfChannels;
      // if( !this.rightHanded() ){
      //   frameIndex = this.numberOfFrames() - 1 - frameIndex;
      // }
      var frameOffset = frameIndex * numPixels;
      var buffer = this._niftiImage;

      // use bits allocated && pixel reprensentation too
      if (!this._ordered && this._orderedData === null) {
        // order then
        this._reorderData();
      }

      if (this._orderedData !== null) {
        // just a slice...
        return this._orderedData.slice(frameOffset, frameOffset + numPixels);
      } else if (this._dataSet.datatypeCode === 2) {
        // unsigned int 8 bit
        return new Uint8Array(buffer, frameOffset, numPixels);
      } else if (this._dataSet.datatypeCode === 256) {
        // signed int 8 bit
        return new Int8Array(buffer, frameOffset, numPixels);
      } else if (this._dataSet.datatypeCode === 512) {
        // unsigned int 16 bit
        frameOffset = frameOffset * 2;
        return new Uint16Array(buffer, frameOffset, numPixels);
      } else if (this._dataSet.datatypeCode === 4) {
        // signed int 16 bit
        frameOffset = frameOffset * 2;
        return new Int16Array(buffer, frameOffset, numPixels);
      } else if (this._dataSet.datatypeCode === 8) {
        // signed int 32 bit
        frameOffset = frameOffset * 4;
        return new Int32Array(buffer, frameOffset, numPixels);
      } else if (this._dataSet.datatypeCode === 16) {
        // signed float 32 bit
        frameOffset = frameOffset * 4;
        return new Float32Array(buffer, frameOffset, numPixels);
      } else {
        console.log('Unknown data type: datatypeCode : ' + this._dataSet.datatypeCode);
      }
    }
  }, {
    key: '_reorderData',
    value: function _reorderData() {
      window.console.log('re-order');
      var numberOfChannels = this.numberOfChannels();
      var numPixels = this.rows() * this.columns() * numberOfChannels;
      var buffer = this._niftiImage;

      var totalNumPixels = numPixels * this.numberOfFrames();
      var tmp = null;
      this._orderedData = null;

      if (this._dataSet.datatypeCode === 2) {
        // unsigned 8 bit
        tmp = new Uint8Array(buffer, 0, totalNumPixels);
        this._orderedData = new Uint8Array(tmp.length);
      } else if (this._dataSet.datatypeCode === 256) {
        // signed 8 bit
        tmp = new Int8Array(buffer, 0, totalNumPixels);
        this._orderedData = new Int8Array(tmp.length);
      } else if (this._dataSet.datatypeCode === 512) {
        tmp = new Uint16Array(buffer, 0, totalNumPixels);
        this._orderedData = new Uint16Array(tmp.length);
      } else if (this._dataSet.datatypeCode === 4) {
        tmp = new Int16Array(buffer, 0, totalNumPixels);
        this._orderedData = new Int16Array(tmp.length);
      } else if (this._dataSet.datatypeCode === 16) {
        tmp = new Float32Array(buffer, 0, totalNumPixels);
        this._orderedData = new Float32Array(tmp.length);
      }

      // re-order pixels...
      var numPixels2 = tmp.length / 3;
      var rgbaIndex = 0;
      var rIndex = 0;
      var gIndex = numPixels2;
      var bIndex = numPixels2 * 2;

      for (var i = 0; i < numPixels2; i++) {
        this._orderedData[rgbaIndex++] = tmp[rIndex++]; // red
        this._orderedData[rgbaIndex++] = tmp[gIndex++]; // green
        this._orderedData[rgbaIndex++] = tmp[bIndex++]; // blue
      }

      this._ordered = true;
    }
  }]);

  return ParsersNifti;
}(_parsers2.default);

exports.default = ParsersNifti;

},{"./parsers.volume":141,"nifti-reader-js":46}],140:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

var _parsers = require('./parsers.volume');

var _parsers2 = _interopRequireDefault(_parsers);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
} // use nifti-js and just parse header.???

// Slicer way to handle images
// should follow it...
// 897   if ( (this->IndexSeriesInstanceUIDs[k] != idxSeriesInstanceUID && this->IndexSeriesInstanceUIDs[k] >= 0 && idxSeriesInstanceUID >= 0) ||
// 898        (this->IndexContentTime[k] != idxContentTime && this->IndexContentTime[k] >= 0 && idxContentTime >= 0) ||
// 899        (this->IndexTriggerTime[k] != idxTriggerTime && this->IndexTriggerTime[k] >= 0 && idxTriggerTime >= 0) ||
// 900        (this->IndexEchoNumbers[k] != idxEchoNumbers && this->IndexEchoNumbers[k] >= 0 && idxEchoNumbers >= 0) ||
// 901        (this->IndexDiffusionGradientOrientation[k] != idxDiffusionGradientOrientation  && this->IndexDiffusionGradientOrientation[k] >= 0 && idxDiffusionGradientOrientation >= 0) ||
// 902        (this->IndexSliceLocation[k] != idxSliceLocation && this->IndexSliceLocation[k] >= 0 && idxSliceLocation >= 0) ||
// 903        (this->IndexImageOrientationPatient[k] != idxImageOrientationPatient && this->IndexImageOrientationPatient[k] >= 0 && idxImageOrientationPatient >= 0) )
// 904     {
// 905       continue;
// 906     }

// http://brainder.org/2012/09/23/the-nifti-file-format/

/** * Imports ***/

var pako = require('pako');
var NrrdReader = require('nrrd-js');
/**
 * @module parsers/nifti
 */

var ParsersNifti = function (_ParsersVolume) {
  _inherits(ParsersNifti, _ParsersVolume);

  function ParsersNifti(data, id) {
    _classCallCheck(this, ParsersNifti);

    /**
      * @member
      * @type {arraybuffer}
    */
    var _this = _possibleConstructorReturn(this, (ParsersNifti.__proto__ || Object.getPrototypeOf(ParsersNifti)).call(this));

    _this._id = id;
    _this._arrayBuffer = data.buffer;
    _this._url = data.url;
    _this._dataSet = null;
    _this._unpackedData = null;

    try {
      _this._dataSet = NrrdReader.parse(_this._arrayBuffer);
      console.log(_this._dataSet);
    } catch (error) {
      window.console.log('ooops... :(');
    }

    window.console.log(_this._dataSet);
    return _this;
  }

  _createClass(ParsersNifti, [{
    key: 'rightHanded',
    value: function rightHanded() {
      if (this._dataSet.space.match(/^right-anterior-superior/) || this._dataSet.space.match(/^left-posterior-superior/)) {
        this._rightHanded = true;
      } else {
        this._rightHanded = false;
      }

      return this._rightHanded;
    }
  }, {
    key: 'seriesInstanceUID',
    value: function seriesInstanceUID() {
      // use filename + timestamp..?
      return this._url;
    }
  }, {
    key: 'numberOfFrames',
    value: function numberOfFrames() {
      return this._dataSet.sizes[2];
    }
  }, {
    key: 'numberOfChannels',
    value: function numberOfChannels() {
      var numberOfChannels = 1;
      return numberOfChannels;
    }
  }, {
    key: 'sopInstanceUID',
    value: function sopInstanceUID() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      return frameIndex;
    }
  }, {
    key: 'rows',
    value: function rows() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      return this._dataSet.sizes[1];
    }
  }, {
    key: 'columns',
    value: function columns() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      return this._dataSet.sizes[0];
    }
  }, {
    key: 'pixelType',
    value: function pixelType() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      // 0 - int
      // 1 - float
      var pixelType = 0;
      if (this._dataSet.type === 'float') {
        pixelType = 1;
      }
      return pixelType;
    }
  }, {
    key: 'bitsAllocated',
    value: function bitsAllocated() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      var bitsAllocated = 1;

      if (this._dataSet.type === 'int8' || this._dataSet.type === 'uint8' || this._dataSet.type === 'char') {
        bitsAllocated = 8;
      } else if (this._dataSet.type === 'int16' || this._dataSet.type === 'uint16' || this._dataSet.type === 'short') {
        bitsAllocated = 16;
      } else if (this._dataSet.type === 'int32' || this._dataSet.type === 'uint32' || this._dataSet.type === 'float') {
        bitsAllocated = 32;
      }

      return bitsAllocated;
    }
  }, {
    key: 'pixelSpacing',
    value: function pixelSpacing() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      var x = new THREE.Vector3(this._dataSet.spaceDirections[0][0], this._dataSet.spaceDirections[0][1], this._dataSet.spaceDirections[0][2]);

      var y = new THREE.Vector3(this._dataSet.spaceDirections[1][0], this._dataSet.spaceDirections[1][1], this._dataSet.spaceDirections[1][2]);

      var z = new THREE.Vector3(this._dataSet.spaceDirections[2][0], this._dataSet.spaceDirections[2][1], this._dataSet.spaceDirections[2][2]);

      return [x.length(), y.length(), z.length()];
    }
  }, {
    key: 'sliceThickness',
    value: function sliceThickness() {
      // should be a string...
      return null; // this._dataSet.pixDims[3].toString();
    }
  }, {
    key: 'imageOrientation',
    value: function imageOrientation() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      var invertX = this._dataSet.space.match(/right/) ? -1 : 1;
      var invertY = this._dataSet.space.match(/anterior/) ? -1 : 1;

      var x = new THREE.Vector3(this._dataSet.spaceDirections[0][0] * invertX, this._dataSet.spaceDirections[0][1] * invertY, this._dataSet.spaceDirections[0][2]);
      x.normalize();

      var y = new THREE.Vector3(this._dataSet.spaceDirections[1][0] * invertX, this._dataSet.spaceDirections[1][1] * invertY, this._dataSet.spaceDirections[1][2]);
      y.normalize();

      return [x.x, x.y, x.z, y.x, y.y, y.z];
    }
  }, {
    key: 'imagePosition',
    value: function imagePosition() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      return [this._dataSet.spaceOrigin[0], this._dataSet.spaceOrigin[1], this._dataSet.spaceOrigin[2]];
    }
  }, {
    key: 'dimensionIndexValues',
    value: function dimensionIndexValues() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      return null;
    }
  }, {
    key: 'instanceNumber',
    value: function instanceNumber() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      return frameIndex;
    }
  }, {
    key: 'windowCenter',
    value: function windowCenter() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      // calc min and calc max
      return null;
    }
  }, {
    key: 'windowWidth',
    value: function windowWidth() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      // calc min and calc max
      return null;
    }
  }, {
    key: 'rescaleSlope',
    value: function rescaleSlope() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      return 1; // this._dataSet.scl_slope;
    }
  }, {
    key: 'rescaleIntercept',
    value: function rescaleIntercept() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      return 0; // this._dataSet.scl_intercept;
    }
  }, {
    key: 'minMaxPixelData',
    value: function minMaxPixelData() {
      var pixelData = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

      var minMax = [65535, -32768];
      var numPixels = pixelData.length;
      for (var index = 0; index < numPixels; index++) {
        var spv = pixelData[index];
        minMax[0] = Math.min(minMax[0], spv);
        minMax[1] = Math.max(minMax[1], spv);
      }

      return minMax;
    }
  }, {
    key: 'extractPixelData',
    value: function extractPixelData() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      return this._decompressUncompressed(frameIndex);
    }
  }, {
    key: '_decompressUncompressed',
    value: function _decompressUncompressed() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      var buffer = this._dataSet.buffer;
      var numberOfChannels = this.numberOfChannels();
      var numPixels = this.rows(frameIndex) * this.columns(frameIndex) * numberOfChannels;
      if (!this.rightHanded()) {
        frameIndex = this.numberOfFrames() - 1 - frameIndex;
      }
      var frameOffset = frameIndex * numPixels;

      // unpack data if needed
      if (this._unpackedData === null && this._dataSet.encoding === 'gzip') {
        var unpackedData = pako.inflate(this._dataSet.buffer);
        this._unpackedData = unpackedData.buffer;
        buffer = this._unpackedData;
      } else if (this._dataSet.encoding === 'gzip') {
        buffer = this._unpackedData;
      }

      if (this._dataSet.type === 'int8' || this._dataSet.type === 'char') {
        frameOffset = frameOffset;
        return new Int8Array(buffer, frameOffset, numPixels);
      } else if (this._dataSet.type === 'uint8') {
        frameOffset = frameOffset;
        return new Uint8Array(buffer, frameOffset, numPixels);
      } else if (this._dataSet.type === 'int16' || this._dataSet.type === 'short') {
        frameOffset = frameOffset * 2;
        return new Int16Array(buffer, frameOffset, numPixels);
      } else if (this._dataSet.type === 'uint16') {
        frameOffset = frameOffset * 2;
        return new Uint16Array(buffer, frameOffset, numPixels);
      } else if (this._dataSet.type === 'int32') {
        frameOffset = frameOffset * 4;
        return new Int32Array(buffer, frameOffset, numPixels);
      } else if (this._dataSet.type === 'uint32') {
        frameOffset = frameOffset * 4;
        return new Uint32Array(buffer, frameOffset, numPixels);
      } else if (this._dataSet.type === 'float') {
        frameOffset = frameOffset * 4;
        return new Float32Array(buffer, frameOffset, numPixels);
      }
    }
  }]);

  return ParsersNifti;
}(_parsers2.default);

exports.default = ParsersNifti;

},{"./parsers.volume":141,"nrrd-js":50,"pako":51}],141:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

/**
 * @module parsers/volume
 */
var ParsersVolume = function () {
  function ParsersVolume() {
    _classCallCheck(this, ParsersVolume);

    this._rightHanded = true;
  }

  _createClass(ParsersVolume, [{
    key: 'pixelRepresentation',
    value: function pixelRepresentation() {
      return 0;
    }
  }, {
    key: 'modality',
    value: function modality() {
      return 'unknown';
    }
  }, {
    key: 'segmentationType',
    value: function segmentationType() {
      return 'unknown';
    }
  }, {
    key: 'segmentationSegments',
    value: function segmentationSegments() {
      return [];
    }
  }, {
    key: 'referencedSegmentNumber',
    value: function referencedSegmentNumber(frameIndex) {
      return -1;
    }
  }, {
    key: 'rightHanded',
    value: function rightHanded() {
      return this._rightHanded;
    }
  }, {
    key: 'spacingBetweenSlices',
    value: function spacingBetweenSlices() {
      return null;
    }
  }, {
    key: 'numberOfChannels',
    value: function numberOfChannels() {
      return 1;
    }
  }, {
    key: 'sliceThickness',
    value: function sliceThickness() {
      return null;
    }
  }, {
    key: 'dimensionIndexValues',
    value: function dimensionIndexValues() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      return null;
    }
  }, {
    key: 'instanceNumber',
    value: function instanceNumber() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      return frameIndex;
    }
  }, {
    key: 'windowCenter',
    value: function windowCenter() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      return null;
    }
  }, {
    key: 'windowWidth',
    value: function windowWidth() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      return null;
    }
  }, {
    key: 'rescaleSlope',
    value: function rescaleSlope() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      return 1;
    }
  }, {
    key: 'rescaleIntercept',
    value: function rescaleIntercept() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      return 0;
    }
  }, {
    key: '_decompressUncompressed',
    value: function _decompressUncompressed() {}

    // http://stackoverflow.com/questions/5320439/how-do-i-swap-endian-ness-byte-order-of-a-variable-in-javascript

  }, {
    key: '_swap16',
    value: function _swap16(val) {
      return (val & 0xFF) << 8 | val >> 8 & 0xFF;
    }
  }, {
    key: '_swap32',
    value: function _swap32(val) {
      return (val & 0xFF) << 24 | (val & 0xFF00) << 8 | val >> 8 & 0xFF00 | val >> 24 & 0xFF;
    }
  }, {
    key: 'invert',
    value: function invert() {
      return false;
    }

    /**
     * Get the transfer syntax UID.
     * @return {*}
     */

  }, {
    key: 'transferSyntaxUID',
    value: function transferSyntaxUID() {
      return 'no value provided';
    }

    /**
     * Get the study desciption.
     * @return {*}
     */

  }, {
    key: 'studyDescription',
    value: function studyDescription() {
      return 'no value provided';
    }

    /**
     * Get the series desciption.
     * @return {*}
     */

  }, {
    key: 'seriesDescription',
    value: function seriesDescription() {
      return 'no value provided';
    }

    /**
     * Get the patient ID.
     * @return {*}
     */

  }, {
    key: 'patientID',
    value: function patientID() {
      return 'no value provided';
    }

    /**
     * Get the patient name.
     * @return {*}
     */

  }, {
    key: 'patientName',
    value: function patientName() {
      return 'no value provided';
    }

    /**
     * Get the patient age.
     * @return {*}
     */

  }, {
    key: 'patientAge',
    value: function patientAge() {
      return 'no value provided';
    }

    /**
     * Get the patient birthdate.
     * @return {*}
     */

  }, {
    key: 'patientBirthdate',
    value: function patientBirthdate() {
      return 'no value provided';
    }

    /**
     * Get the patient sex.
     * @return {*}
     */

  }, {
    key: 'patientSex',
    value: function patientSex() {
      return 'no value provided';
    }
  }]);

  return ParsersVolume;
}();

exports.default = ParsersVolume;

},{}],142:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

var _shaders = require('../shaders.base');

var _shaders2 = _interopRequireDefault(_shaders);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

var IntersectBox = function (_ShadersBase) {
  _inherits(IntersectBox, _ShadersBase);

  function IntersectBox() {
    _classCallCheck(this, IntersectBox);

    var _this = _possibleConstructorReturn(this, (IntersectBox.__proto__ || Object.getPrototypeOf(IntersectBox)).call(this));

    _this.name = 'intersectBox';

    // default properties names
    _this._rayOrigin = 'rayOrigin';
    _this._rayDirection = 'rayDirection';
    _this._aabbMin = 'aabbMin';
    _this._aabbMax = 'aabbMax';
    _this._tNear = 'tNear';
    _this._tFar = 'tFar';
    _this._intersect = 'intersect';
    return _this;
  }

  _createClass(IntersectBox, [{
    key: 'api',
    value: function api() {
      var baseFragment = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._base;
      var rayOrigin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this._rayOrigin;
      var rayDirection = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this._rayDirection;
      var aabbMin = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : this._aabbMin;
      var aabbMax = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : this._aabbMax;
      var tNear = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : this._tNear;
      var tFar = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : this._tFar;
      var intersect = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : this._intersect;

      this._base = baseFragment;
      return this.compute(rayOrigin, rayDirection, aabbMin, aabbMax, tNear, tFar, intersect);
    }
  }, {
    key: 'compute',
    value: function compute(rayOrigin, rayDirection, aabbMin, aabbMax, tNear, tFar, intersect) {
      this.computeDefinition();
      this._base._functions[this._name] = this._definition;
      return this._name + '(' + rayOrigin + ', ' + rayDirection + ', ' + aabbMin + ', ' + aabbMax + ', ' + tNear + ', ' + tFar + ', ' + intersect + ');';
    }
  }, {
    key: 'computeDefinition',
    value: function computeDefinition() {
      this._definition = '\nvoid ' + this._name + '(vec3 rayOrigin, vec3 rayDirection, vec3 boxMin, vec3 boxMax, out float tNear, out float tFar, out bool intersect){\n  // compute intersection of ray with all six bbox planes\n  vec3 invRay = vec3(1.) / rayDirection;\n  vec3 tBot = invRay * (boxMin - rayOrigin);\n  vec3 tTop = invRay * (boxMax - rayOrigin);\n  // re-order intersections to find smallest and largest on each axis\n  vec3 tMin = min(tTop, tBot);\n  vec3 tMax = max(tTop, tBot);\n  // find the largest tMin and the smallest tMax\n  float largest_tMin = max(max(tMin.x, tMin.y), max(tMin.x, tMin.z));\n  float smallest_tMax = min(min(tMax.x, tMax.y), min(tMax.x, tMax.z));\n  tNear = largest_tMin;\n  tFar = smallest_tMax;\n  intersect = smallest_tMax > largest_tMin;\n}\n\n    ';
    }
  }]);

  return IntersectBox;
}(_shaders2.default);

exports.default = new IntersectBox();

},{"../shaders.base":148}],143:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

var _shaders = require('../shaders.base');

var _shaders2 = _interopRequireDefault(_shaders);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

var Texture3d = function (_ShadersBase) {
  _inherits(Texture3d, _ShadersBase);

  function Texture3d() {
    _classCallCheck(this, Texture3d);

    var _this = _possibleConstructorReturn(this, (Texture3d.__proto__ || Object.getPrototypeOf(Texture3d)).call(this));

    _this.name = 'texture3d';

    // default properties names
    _this._dataCoordinates = 'dataCoordinates';
    _this._dataValue = 'dataValue';
    _this._offset = 'offset';
    return _this;
  }

  _createClass(Texture3d, [{
    key: 'api',
    value: function api() {
      var baseFragment = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._base;
      var dataCoordinates = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this._dataCoordinates;
      var dataValue = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this._dataValue;
      var offset = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : this._offset;

      this._base = baseFragment;
      return this.compute(dataCoordinates, dataValue, offset);
    }
  }, {
    key: 'compute',
    value: function compute(dataCoordinates, dataValue, offset) {
      this.computeDefinition();
      this._base._functions[this._name] = this._definition;
      return this._name + '(' + dataCoordinates + ', ' + dataValue + ', ' + offset + ');';
    }
  }, {
    key: 'computeDefinition',
    value: function computeDefinition() {
      this._definition = '\nvoid ' + this._name + '(in ivec3 dataCoordinates, out vec4 dataValue, out int offset){\n    \n  int index = dataCoordinates.x\n            + dataCoordinates.y * uDataDimensions.x\n            + dataCoordinates.z * uDataDimensions.y * uDataDimensions.x;\n  int indexP = int(index/uPackedPerPixel);\n  offset = index - 2*indexP;\n\n  // Map data index to right sampler2D texture\n  int voxelsPerTexture = uTextureSize*uTextureSize;\n  int textureIndex = int(floor(float(indexP) / float(voxelsPerTexture)));\n  // modulo seems incorrect sometimes...\n  // int inTextureIndex = int(mod(float(index), float(textureSize*textureSize)));\n  int inTextureIndex = indexP - voxelsPerTexture*textureIndex;\n\n  // Get row and column in the texture\n  int colIndex = int(mod(float(inTextureIndex), float(uTextureSize)));\n  int rowIndex = int(floor(float(inTextureIndex)/float(uTextureSize)));\n\n  // Map row and column to uv\n  vec2 uv = vec2(0,0);\n  uv.x = (0.5 + float(colIndex)) / float(uTextureSize);\n  uv.y = 1. - (0.5 + float(rowIndex)) / float(uTextureSize);\n\n  //\n  if(textureIndex == 0){ dataValue = texture2D(uTextureContainer[0], uv); }\n  else if(textureIndex == 1){dataValue = texture2D(uTextureContainer[1], uv);}\n  else if(textureIndex == 2){ dataValue = texture2D(uTextureContainer[2], uv); }\n  else if(textureIndex == 3){ dataValue = texture2D(uTextureContainer[3], uv); }\n  else if(textureIndex == 4){ dataValue = texture2D(uTextureContainer[4], uv); }\n  else if(textureIndex == 5){ dataValue = texture2D(uTextureContainer[5], uv); }\n  else if(textureIndex == 6){ dataValue = texture2D(uTextureContainer[6], uv); }\n\n}\n    ';
    }
  }]);

  return Texture3d;
}(_shaders2.default);

exports.default = new Texture3d();

},{"../shaders.base":148}],144:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

var _shaders = require('../shaders.base');

var _shaders2 = _interopRequireDefault(_shaders);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

var Unpack = function (_ShadersBase) {
  _inherits(Unpack, _ShadersBase);

  function Unpack() {
    _classCallCheck(this, Unpack);

    var _this = _possibleConstructorReturn(this, (Unpack.__proto__ || Object.getPrototypeOf(Unpack)).call(this));

    _this.name = 'unpack';

    // default properties names
    _this._packedData = 'packedData';
    _this._offset = 'offset';
    _this._unpackedData = 'unpackedData';

    _this._base._uniforms = {
      uNumberOfChannels: {
        value: 1
      },
      uBitsAllocated: {
        value: 16
      },
      uPixelType: {
        value: 0
      }
    };
    return _this;
  }

  _createClass(Unpack, [{
    key: 'api',
    value: function api() {
      var baseFragment = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._base;
      var packedData = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this._packedData;
      var offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this._offset;
      var unpackedData = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : this._unpackedData;

      this._base = baseFragment;
      return this.compute(packedData, offset, unpackedData);
    }
  }, {
    key: 'compute',
    value: function compute(packedData, offset, unpackedData) {
      this.computeDefinition();
      this._base._functions[this._name] = this._definition;
      return this._name + '(' + packedData + ', ' + offset + ', ' + unpackedData + ');';
    }
  }, {
    key: 'computeDefinition',
    value: function computeDefinition() {
      // fun stuff
      var content = '';
      if (this._base._uniforms.uNumberOfChannels.value === 1) {
        switch (this._base._uniforms.uBitsAllocated.value) {

          case 1:
          case 8:
            content = this.upack8();
            break;

          case 16:
            content = this.upack16();
            break;

          case 32:
            content = this.upack32();
            break;

          default:
            content = this.upackDefault();
            break;

        }
      } else {
        content = this.upackIdentity();
      }

      this._definition = '\nvoid ' + this._name + '(in vec4 packedData, in int offset, out vec4 unpackedData){\n\n' + content + '\n\n}  \n    ';
    }
  }, {
    key: 'upack8',
    value: function upack8() {
      this._base._functions['uInt8'] = this.uInt8();

      return '\nuInt8(\n  packedData.r,\n  unpackedData.x);\n    ';
    }
  }, {
    key: 'upack16',
    value: function upack16() {
      this._base._functions['uInt16'] = this.uInt16();

      return '\nuInt16(\n  packedData.r * float( 1 - offset) + packedData.b * float(offset),\n  packedData.g * float( 1 - offset) + packedData.a * float(offset),\n  unpackedData.x);\n    ';
    }
  }, {
    key: 'upack32',
    value: function upack32() {
      if (this._base._uniforms.uPixelType.value === 0) {
        this._base._functions['uInt32'] = this.uInt32();

        return '\nuInt32(\n  packedData.r,\n  packedData.g,\n  packedData.b,\n  packedData.a,\n  unpackedData.x);\n      ';
      } else {
        this._base._functions['uFloat32'] = this.uFloat32();

        return '\nuFloat32(\n  packedData.r,\n  packedData.g,\n  packedData.b,\n  packedData.a,\n  unpackedData.x);\n      ';
      }
    }
  }, {
    key: 'upackIdentity',
    value: function upackIdentity() {
      return '\n\nunpackedData = packedData;\n\n      ';
    }
  }, {
    key: 'uInt8',
    value: function uInt8() {
      return '\nvoid uInt8(in float r, out float value){\n  value = r * 256.;\n}\n    ';
    }
  }, {
    key: 'uInt16',
    value: function uInt16() {
      return '\nvoid uInt16(in float r, in float a, out float value){\n  value = r * 256. + a * 65536.;\n}\n    ';
    }
  }, {
    key: 'uInt32',
    value: function uInt32() {
      return '\nvoid uInt32(in float r, in float g, in float b, in float a, out float value){\n  value = r * 256. + g * 65536. + b * 16777216. + a * 4294967296.;\n}\n    ';
    }
  }, {
    key: 'uFloat32',
    value: function uFloat32() {
      return '\nvoid uFloat32(in float r, in float g, in float b, in float a, out float value){\n\n  // create arrays containing bits for rgba values\n  // value between 0 and 255\n  value = r * 255.;\n  int bytemeR[8];\n  bytemeR[0] = int(floor(value / 128.));\n  value -= float(bytemeR[0] * 128);\n  bytemeR[1] = int(floor(value / 64.));\n  value -= float(bytemeR[1] * 64);\n  bytemeR[2] = int(floor(value / 32.));\n  value -= float(bytemeR[2] * 32);\n  bytemeR[3] = int(floor(value / 16.));\n  value -= float(bytemeR[3] * 16);\n  bytemeR[4] = int(floor(value / 8.));\n  value -= float(bytemeR[4] * 8);\n  bytemeR[5] = int(floor(value / 4.));\n  value -= float(bytemeR[5] * 4);\n  bytemeR[6] = int(floor(value / 2.));\n  value -= float(bytemeR[6] * 2);\n  bytemeR[7] = int(floor(value));\n\n  value = g * 255.;\n  int bytemeG[8];\n  bytemeG[0] = int(floor(value / 128.));\n  value -= float(bytemeG[0] * 128);\n  bytemeG[1] = int(floor(value / 64.));\n  value -= float(bytemeG[1] * 64);\n  bytemeG[2] = int(floor(value / 32.));\n  value -= float(bytemeG[2] * 32);\n  bytemeG[3] = int(floor(value / 16.));\n  value -= float(bytemeG[3] * 16);\n  bytemeG[4] = int(floor(value / 8.));\n  value -= float(bytemeG[4] * 8);\n  bytemeG[5] = int(floor(value / 4.));\n  value -= float(bytemeG[5] * 4);\n  bytemeG[6] = int(floor(value / 2.));\n  value -= float(bytemeG[6] * 2);\n  bytemeG[7] = int(floor(value));\n\n  value = b * 255.;\n  int bytemeB[8];\n  bytemeB[0] = int(floor(value / 128.));\n  value -= float(bytemeB[0] * 128);\n  bytemeB[1] = int(floor(value / 64.));\n  value -= float(bytemeB[1] * 64);\n  bytemeB[2] = int(floor(value / 32.));\n  value -= float(bytemeB[2] * 32);\n  bytemeB[3] = int(floor(value / 16.));\n  value -= float(bytemeB[3] * 16);\n  bytemeB[4] = int(floor(value / 8.));\n  value -= float(bytemeB[4] * 8);\n  bytemeB[5] = int(floor(value / 4.));\n  value -= float(bytemeB[5] * 4);\n  bytemeB[6] = int(floor(value / 2.));\n  value -= float(bytemeB[6] * 2);\n  bytemeB[7] = int(floor(value));\n\n  value = a * 255.;\n  int bytemeA[8];\n  bytemeA[0] = int(floor(value / 128.));\n  value -= float(bytemeA[0] * 128);\n  bytemeA[1] = int(floor(value / 64.));\n  value -= float(bytemeA[1] * 64);\n  bytemeA[2] = int(floor(value / 32.));\n  value -= float(bytemeA[2] * 32);\n  bytemeA[3] = int(floor(value / 16.));\n  value -= float(bytemeA[3] * 16);\n  bytemeA[4] = int(floor(value / 8.));\n  value -= float(bytemeA[4] * 8);\n  bytemeA[5] = int(floor(value / 4.));\n  value -= float(bytemeA[5] * 4);\n  bytemeA[6] = int(floor(value / 2.));\n  value -= float(bytemeA[6] * 2);\n  bytemeA[7] = int(floor(value));\n\n  // compute float32 value from bit arrays\n\n  // sign\n  int issigned = 1 - 2 * bytemeR[0];\n  //   issigned = int(pow(-1., float(bytemeR[0])));\n\n  // exponent\n  int exponent = 0;\n\n  exponent += bytemeR[1] * int(pow(2., 7.));\n  exponent += bytemeR[2] * int(pow(2., 6.));\n  exponent += bytemeR[3] * int(pow(2., 5.));\n  exponent += bytemeR[4] * int(pow(2., 4.));\n  exponent += bytemeR[5] * int(pow(2., 3.));\n  exponent += bytemeR[6] * int(pow(2., 2.));\n  exponent += bytemeR[7] * int(pow(2., 1.));\n\n  exponent += bytemeG[0];\n\n\n  // fraction\n  float fraction = 0.;\n\n  fraction = float(bytemeG[1]) * pow(2., -1.);\n  fraction += float(bytemeG[2]) * pow(2., -2.);\n  fraction += float(bytemeG[3]) * pow(2., -3.);\n  fraction += float(bytemeG[4]) * pow(2., -4.);\n  fraction += float(bytemeG[5]) * pow(2., -5.);\n  fraction += float(bytemeG[6]) * pow(2., -6.);\n  fraction += float(bytemeG[7]) * pow(2., -7.);\n\n  fraction += float(bytemeB[0]) * pow(2., -8.);\n  fraction += float(bytemeB[1]) * pow(2., -9.);\n  fraction += float(bytemeB[2]) * pow(2., -10.);\n  fraction += float(bytemeB[3]) * pow(2., -11.);\n  fraction += float(bytemeB[4]) * pow(2., -12.);\n  fraction += float(bytemeB[5]) * pow(2., -13.);\n  fraction += float(bytemeB[6]) * pow(2., -14.);\n  fraction += float(bytemeB[7]) * pow(2., -15.);\n\n  fraction += float(bytemeA[0]) * pow(2., -16.);\n  fraction += float(bytemeA[1]) * pow(2., -17.);\n  fraction += float(bytemeA[2]) * pow(2., -18.);\n  fraction += float(bytemeA[3]) * pow(2., -19.);\n  fraction += float(bytemeA[4]) * pow(2., -20.);\n  fraction += float(bytemeA[5]) * pow(2., -21.);\n  fraction += float(bytemeA[6]) * pow(2., -22.);\n  fraction += float(bytemeA[7]) * pow(2., -23.);\n\n  value = float(issigned) * pow( 2., float(exponent - 127)) * (1. + fraction);\n}\n    ';
    }
  }]);

  return Unpack;
}(_shaders2.default);

exports.default = new Unpack();

},{"../shaders.base":148}],145:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

var _shaders = require('../shaders.base');

var _shaders2 = _interopRequireDefault(_shaders);

var _shadersHelpers = require('../helpers/shaders.helpers.unpack');

var _shadersHelpers2 = _interopRequireDefault(_shadersHelpers);

var _shadersHelpers3 = require('../helpers/shaders.helpers.texture3d');

var _shadersHelpers4 = _interopRequireDefault(_shadersHelpers3);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

var InterpolationIdentity = function (_ShadersBase) {
  _inherits(InterpolationIdentity, _ShadersBase);

  function InterpolationIdentity() {
    _classCallCheck(this, InterpolationIdentity);

    var _this = _possibleConstructorReturn(this, (InterpolationIdentity.__proto__ || Object.getPrototypeOf(InterpolationIdentity)).call(this));

    _this.name = 'interpolationIdentity';

    // default properties names
    _this._currentVoxel = 'currentVoxel';
    _this._dataValue = 'dataValue';
    return _this;
  }

  _createClass(InterpolationIdentity, [{
    key: 'api',
    value: function api() {
      var baseFragment = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._base;
      var currentVoxel = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this._currentVoxel;
      var dataValue = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this._dataValue;

      this._base = baseFragment;
      return this.compute(currentVoxel, dataValue);
    }
  }, {
    key: 'compute',
    value: function compute(currentVoxel, dataValue) {
      this.computeDefinition();
      this._base._functions[this._name] = this._definition;
      return this._name + '(' + currentVoxel + ', ' + dataValue + ');';
    }
  }, {
    key: 'computeDefinition',
    value: function computeDefinition() {
      this._definition = '\nvoid ' + this._name + '(in vec3 currentVoxel, out vec4 dataValue){\n  // lower bound\n  vec3 rcurrentVoxel = vec3(floor(currentVoxel.x + 0.5 ), floor(currentVoxel.y + 0.5 ), floor(currentVoxel.z + 0.5 ));\n  ivec3 voxel = ivec3(int(rcurrentVoxel.x), int(rcurrentVoxel.y), int(rcurrentVoxel.z));\n\n  vec4 tmp = vec4(0., 0., 0., 0.);\n  int offset = 0;\n\n  ' + _shadersHelpers4.default.api(this._base, 'voxel', 'tmp', 'offset') + '\n  ' + _shadersHelpers2.default.api(this._base, 'tmp', 'offset', 'dataValue') + '\n}\n    ';
    }
  }]);

  return InterpolationIdentity;
}(_shaders2.default);

exports.default = new InterpolationIdentity();

},{"../helpers/shaders.helpers.texture3d":143,"../helpers/shaders.helpers.unpack":144,"../shaders.base":148}],146:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _shadersInterpolation = require('./shaders.interpolation.identity');

var _shadersInterpolation2 = _interopRequireDefault(_shadersInterpolation);

var _shadersInterpolation3 = require('./shaders.interpolation.trilinear');

var _shadersInterpolation4 = _interopRequireDefault(_shadersInterpolation3);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function shadersInterpolation(baseFragment, currentVoxel, dataValue, gradient) {
  switch (baseFragment._uniforms.uInterpolation.value) {

    case 0:
      // no interpolation
      return _shadersInterpolation2.default.api(baseFragment, currentVoxel, dataValue);

    case 1:
      // trilinear interpolation
      return _shadersInterpolation4.default.api(baseFragment, currentVoxel, dataValue, gradient);

    default:
      return _shadersInterpolation2.default.api(baseFragment, currentVoxel, dataValue);

  }
}

exports.default = shadersInterpolation;

},{"./shaders.interpolation.identity":145,"./shaders.interpolation.trilinear":147}],147:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

var _shaders = require('../shaders.base');

var _shaders2 = _interopRequireDefault(_shaders);

var _shadersInterpolation = require('./shaders.interpolation.identity');

var _shadersInterpolation2 = _interopRequireDefault(_shadersInterpolation);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

var InterpolationTrilinear = function (_ShadersBase) {
  _inherits(InterpolationTrilinear, _ShadersBase);

  function InterpolationTrilinear() {
    _classCallCheck(this, InterpolationTrilinear);

    var _this = _possibleConstructorReturn(this, (InterpolationTrilinear.__proto__ || Object.getPrototypeOf(InterpolationTrilinear)).call(this));

    _this.name = 'interpolationTrilinear';

    // default properties names
    _this._currentVoxel = 'currentVoxel';
    _this._dataValue = 'dataValue';
    _this._gradient = 'gradient';
    return _this;
  }

  _createClass(InterpolationTrilinear, [{
    key: 'api',
    value: function api() {
      var baseFragment = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._base;
      var currentVoxel = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this._currentVoxel;
      var dataValue = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this._dataValue;
      var gradient = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : this._gradient;

      this._base = baseFragment;
      return this.compute(currentVoxel, dataValue, gradient);
    }
  }, {
    key: 'compute',
    value: function compute(currentVoxel, dataValue, gradient) {
      this.computeDefinition();
      this._base._functions[this._name] = this._definition;
      return this._name + '(' + currentVoxel + ', ' + dataValue + ', ' + gradient + ');';
    }
  }, {
    key: 'computeDefinition',
    value: function computeDefinition() {
      this._definition = '\nvoid ' + this._name + '(in vec3 currentVoxel, out vec4 dataValue, out vec3 gradient){\n\n  // https://en.wikipedia.org/wiki/Trilinear_interpolation\n  vec3 lower_bound = vec3(floor(currentVoxel.x), floor(currentVoxel.y), floor(currentVoxel.z));\n  if(lower_bound.x < 0.){\n    lower_bound.x = 0.;\n  }\n  if(lower_bound.y < 0.){\n    lower_bound.y = 0.;\n  }\n  if(lower_bound.z < 0.){\n    lower_bound.z = 0.;\n  }\n  \n  vec3 higher_bound = lower_bound + vec3(1);\n\n  float xd = ( currentVoxel.x - lower_bound.x ) / ( higher_bound.x - lower_bound.x );\n  float yd = ( currentVoxel.y - lower_bound.y ) / ( higher_bound.y - lower_bound.y );\n  float zd = ( currentVoxel.z - lower_bound.z ) / ( higher_bound.z - lower_bound.z );\n\n  //\n  // c00\n  //\n\n  //\n\n  vec4 v000 = vec4(0.0, 0.0, 0.0, 0.0);\n  vec3 c000 = vec3(lower_bound.x, lower_bound.y, lower_bound.z);\n  ' + _shadersInterpolation2.default.api(this._base, 'c000', 'v000') + '\n  vec3 g000 = v000.r * vec3(-1., -1., -1.);\n\n  //\n\n  vec4 v100 = vec4(0.0, 0.0, 0.0, 0.0);\n  vec3 c100 = vec3(higher_bound.x, lower_bound.y, lower_bound.z);\n  ' + _shadersInterpolation2.default.api(this._base, 'c100', 'v100') + '\n  vec3 g100 = v100.r * vec3(1., -1., -1.);\n\n  vec4 c00 = v000 * ( 1.0 - xd ) + v100 * xd;\n\n  //\n  // c01\n  //\n  vec4 v001 = vec4(0.0, 0.0, 0.0, 0.0);\n  vec3 c001 = vec3(lower_bound.x, lower_bound.y, higher_bound.z);\n  ' + _shadersInterpolation2.default.api(this._base, 'c001', 'v001') + '\n  vec3 g001 = v001.r * vec3(-1., -1., 1.);\n\n  vec4 v101 = vec4(0.0, 0.0, 0.0, 0.0);\n  vec3 c101 = vec3(higher_bound.x, lower_bound.y, higher_bound.z);\n  ' + _shadersInterpolation2.default.api(this._base, 'c101', 'v101') + '\n  vec3 g101 = v101.r * vec3(1., -1., 1.);\n\n  vec4 c01 = v001 * ( 1.0 - xd ) + v101 * xd;\n\n  //\n  // c10\n  //\n  vec4 v010 = vec4(0.0, 0.0, 0.0, 0.0);\n  vec3 c010 = vec3(lower_bound.x, higher_bound.y, lower_bound.z);\n  ' + _shadersInterpolation2.default.api(this._base, 'c010', 'v010') + '\n  vec3 g010 = v010.r * vec3(-1., 1., -1.);\n\n  vec4 v110 = vec4(0.0, 0.0, 0.0, 0.0);\n  vec3 c110 = vec3(higher_bound.x, higher_bound.y, lower_bound.z);\n  ' + _shadersInterpolation2.default.api(this._base, 'c110', 'v110') + '\n  vec3 g110 = v110.r * vec3(1., 1., -1.);\n\n  vec4 c10 = v010 * ( 1.0 - xd ) + v110 * xd;\n\n  //\n  // c11\n  //\n  vec4 v011 = vec4(0.0, 0.0, 0.0, 0.0);\n  vec3 c011 = vec3(lower_bound.x, higher_bound.y, higher_bound.z);\n  ' + _shadersInterpolation2.default.api(this._base, 'c011', 'v011') + '\n  vec3 g011 = v011.r * vec3(-1., 1., 1.);\n\n  vec4 v111 = vec4(0.0, 0.0, 0.0, 0.0);\n  vec3 c111 = vec3(higher_bound.x, higher_bound.y, higher_bound.z);\n  ' + _shadersInterpolation2.default.api(this._base, 'c111', 'v111') + '\n  vec3 g111 = v111.r * vec3(1., 1., 1.);\n\n  vec4 c11 = v011 * ( 1.0 - xd ) + v111 * xd;\n\n  // c0 and c1\n  vec4 c0 = c00 * ( 1.0 - yd) + c10 * yd;\n  vec4 c1 = c01 * ( 1.0 - yd) + c11 * yd;\n\n  // c\n  vec4 c = c0 * ( 1.0 - zd) + c1 * zd;\n  dataValue = c;\n\n  // compute gradient\n  gradient = g000 + g100 + g010 + g110 + g011 + g111 + g110 + g011;\n  // gradientMagnitude = length(gradient);\n  // // https://en.wikipedia.org/wiki/Normal_(geometry)#Transforming_normals\n  // vec3 localNormal = (-1. / gradientMagnitude) * gradient;\n  // normal = normalize(normalPixelToPatient' + this.id + ' * localNormal);\n  //normal = gradient;\n\n}\n    ';
    }
  }]);

  return InterpolationTrilinear;
}(_shaders2.default);

exports.default = new InterpolationTrilinear();

},{"../shaders.base":148,"./shaders.interpolation.identity":145}],148:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

var ShadersBase = function () {
  function ShadersBase() {
    _classCallCheck(this, ShadersBase);

    this._name = 'shadersBase';
    this._base = {
      _functions: {},
      _uniforms: {}
    };
    this._definition = '';
  }

  _createClass(ShadersBase, [{
    key: 'name',
    get: function get() {
      return this._name;
    },
    set: function set(name) {
      this._name = name;
    }
  }]);

  return ShadersBase;
}();

exports.default = ShadersBase;

},{}],149:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

var ShadersFragment = function () {

  // pass uniforms object
  function ShadersFragment(uniforms) {
    _classCallCheck(this, ShadersFragment);

    this._uniforms = uniforms;
    this._functions = {};
    this._main = '';
  }

  _createClass(ShadersFragment, [{
    key: 'functions',
    value: function functions() {
      if (this._main === '') {
        // if main is empty, functions can not have been computed
        this.main();
      }

      var content = '';
      for (var property in this._functions) {
        content += this._functions[property] + '\n';
      }

      return content;
    }
  }, {
    key: 'uniforms',
    value: function uniforms() {
      var content = '';
      for (var property in this._uniforms) {
        var uniform = this._uniforms[property];
        content += 'uniform ' + uniform.typeGLSL + ' ' + property;

        if (uniform && uniform.length) {
          content += '[' + uniform.length + ']';
        }

        content += ';\n';
      }

      return content;
    }
  }, {
    key: 'main',
    value: function main() {
      // need to pre-call main to fill up the functions list
      this._main = '\n\n    float luma (vec3 rgb) {\n\treturn (rgb.r + rgb.g + rgb.b)/3.0;\n}\n\nconst float T = 0.04;\nconst float M = 1.0;\nconst float L = 0.002;\n\nvoid main(void) {\n\n  vec2 texCoord = vec2(((vProjectedCoords.x / vProjectedCoords.w) + 1.0 ) / 2.0,\n                ((vProjectedCoords.y / vProjectedCoords.w) + 1.0 ) / 2.0 );\n\n  float borderWidth = uWidth; // in px\n  float step_u = borderWidth * 1.0 / uCanvasWidth;\n  float step_v = borderWidth * 1.0 / uCanvasHeight;\n  vec4 centerPixel = texture2D(uTextureFilled, texCoord);\n\n  vec4 rightPixel  = texture2D(uTextureFilled, texCoord + vec2(step_u, 0.0));\n  vec4 bottomPixel = texture2D(uTextureFilled, texCoord + vec2(0.0, step_v));\n\n  // now manually compute the derivatives\n  float _dFdX = length(rightPixel - centerPixel) / step_u;\n  float _dFdY = length(bottomPixel - centerPixel) / step_v;\n\n  // gl_FragColor.r = _dFdX;\n  // gl_FragColor.g = _dFdY;\n  gl_FragColor.r = max(max(centerPixel.r, rightPixel.r), bottomPixel.r);\n  gl_FragColor.g = max(max(centerPixel.g, rightPixel.g), bottomPixel.g);\n  gl_FragColor.b = max(max(centerPixel.b, rightPixel.b), bottomPixel.b);\n  gl_FragColor.a = max(_dFdX, _dFdY);\n\n  return;\n  float h = 1./uCanvasHeight;\n  float w = 1./uCanvasWidth;\n  vec4 n[9];\n  n[0] = texture2D(uTextureFilled, vProjectedTextCoords + vec2( -w, -h));\n  n[1] = texture2D(uTextureFilled, vProjectedTextCoords + vec2(0.0, -h));\n  n[2] = texture2D(uTextureFilled, vProjectedTextCoords + vec2(  w, -h));\n  n[3] = texture2D(uTextureFilled, vProjectedTextCoords + vec2( -w, 0.0));\n  n[4] = texture2D(uTextureFilled, vProjectedTextCoords);\n  n[5] = texture2D(uTextureFilled, texCoord + vec2(  w, 0.0));\n  n[6] = texture2D(uTextureFilled, texCoord + vec2( -w, h));\n  n[7] = texture2D(uTextureFilled, texCoord + vec2(0.0, h));\n  n[8] = texture2D(uTextureFilled, texCoord + vec2(  w, h));\n  vec4 sobel_horizEdge = n[2] + (2.0*n[5]) + n[8] - (n[0] + (2.0*n[3]) + n[6]);\n  vec4 sobel_vertEdge  = n[0] + (2.0*n[1]) + n[2] - (n[6] + (2.0*n[7]) + n[8]);\n  vec3 sobel = sqrt((sobel_horizEdge.rgb * sobel_horizEdge.rgb) + (sobel_vertEdge.rgb * sobel_vertEdge.rgb));\n  gl_FragColor = vec4( sobel, max(max(sobel.r, sobel.g), sobel.b) );\n\n\n  return;\n\n  gl_FragColor.r = (texCoord + vec2(0.0, step_v)).r;\n  gl_FragColor.g = (texCoord + vec2(step_u, 0.0)).g;\n  gl_FragColor = centerPixel;\n  gl_FragColor.r = texCoord.x;\n  // gl_FragColor.g = (texCoord + vec2(0.0, step_v)).x;\n  gl_FragColor.b = (texCoord + vec2(step_u, 0.0)).x;\n  gl_FragColor.rg = (texCoord + vec2(0.0, step_v));\n  gl_FragColor.b = 0.;\n  return;\n  vec2 texCoordSlope = fwidth(texCoord);\n  vec4 color2 = texture2D(uTextureFilled, vProjectedTextCoords);\n  // dfdx that vProjectedTextCoords\n  float l = luma (color2.rgb) ;\n    float luminance = dot(color2.rgb,vec3(0.2126, 0.7152, 0.0722));\n\n  \tfloat q0 = fwidth (luminance);\n    if(q0 > 0.01){\n      q0 = 1.0;\n    }\n\tfloat q1 = abs (dFdx (l)); \n\tfloat q2 = abs (dFdy (l));\n\n  \tvec4 ct = vec4 (1.0, 1.0, 1.0, 0.0);\n\tvec4 c0 = mix (ct, vec4 (1.0, 0.0, 0.0, 1.0), \n\t\tsmoothstep (T * (1.0 - M), T * (1.0 + M), q0));\n\ngl_FragColor.r = fwidth(color2.r);//abs(dFdx(color2.b));//texCoord;//color2.rgb;\ngl_FragColor.g = fwidth(color2.g);\ngl_FragColor.b = fwidth(color2.b);\ngl_FragColor.a = 1.;\n// gl_FragColor.a = q0;\n// gl_FragColor = color2;\n//return;\n\n\n  //The back position is the world space position stored in the texture.\n  vec4 color = texture2D(uTextureFilled, texCoord);\n  float lColor = length(color.rgb);\n  float maxColor = length(color.rgb);//max(max(color.r, color.g), color.b);\n  // if(maxColor > 0.1){\n  //   maxColor = 1.0;\n  // }\n\n\n\n  // gl_FragColor = color;//vec4(color.r, color.g, color.b, 1);\n  // return;\n  // float tmpxx  = abs(dFdx(lColor));\n  // float tmpxy  = abs(dFdy(lColor));\n  // float tmpx = max(tmpxx,tmpxy);\n\n  // float tmpyx  = abs(dFdx(color.y));\n  // float tmpyy  = abs(dFdy(color.y));\n  // float tmpy = max(tmpyx,tmpyy);\n\n  // float tmpzx  = abs(dFdx(color.z));\n  // float tmpzy  = abs(dFdy(color.z));\n  // float tmpz = max(tmpzx,tmpzy);\n\n  // float tmpmax = max(max(tmpx, tmpy), tmpz);\n  // if(tmpmax > 0.01){\n  //   tmpmax = 1.0;\n  // }\n  // gl_FragColor.r = tmpx;//smoothstep(tmpx-5., tmpx+5., lColor);\n  // gl_FragColor.g = tmpx;\n  // gl_FragColor.b = tmpx;\n\n  // vec4 color2 = texture2D(uTextureFilled, vec2(texcX, texcY));\n\n  // gl_FragColor.r = color.r - texcX;\n  // gl_FragColor.g = color.g - texcY;\n  // gl_FragColor.b = color.b - color2.b;\n  // gl_FragColor.a = 1.;\n\n  // float threshold = 0.7;\n  // float afwidth = length(vec2(dFdx(maxColor), dFdy(maxColor)));\n  // gl_FragColor.a = afwidth;\n  // float opacity =\n  //   smoothstep(afwidth - threshold, afwidth + threshold, maxColor);\n\n  // gl_FragColor.a = maxColor;\n\n// float aaf = fwidth(maxColor);\n// float alpha = smoothstep(.01, .8, aaf);\n// gl_FragColor = vec4(color.rgb, alpha);\n\n  // float h = 1./uCanvasHeight;\n  // float w = 1./uCanvasWidth;\n  // vec4 n[9];\n  // n[0] = texture2D(uTextureFilled, vProjectedTextCoords + vec2( -w, -h));\n  // n[1] = texture2D(uTextureFilled, vProjectedTextCoords + vec2(0.0, -h));\n  // n[2] = texture2D(uTextureFilled, vProjectedTextCoords + vec2(  w, -h));\n  // n[3] = texture2D(uTextureFilled, vProjectedTextCoords + vec2( -w, 0.0));\n  // n[4] = texture2D(uTextureFilled, vProjectedTextCoords);\n  // n[5] = texture2D(uTextureFilled, texCoord + vec2(  w, 0.0));\n  // n[6] = texture2D(uTextureFilled, texCoord + vec2( -w, h));\n  // n[7] = texture2D(uTextureFilled, texCoord + vec2(0.0, h));\n  // n[8] = texture2D(uTextureFilled, texCoord + vec2(  w, h));\n  // vec4 sobel_horizEdge = n[2] + (2.0*n[5]) + n[8] - (n[0] + (2.0*n[3]) + n[6]);\n  // vec4 sobel_vertEdge  = n[0] + (2.0*n[1]) + n[2] - (n[6] + (2.0*n[7]) + n[8]);\n  // vec3 sobel = sqrt((sobel_horizEdge.rgb * sobel_horizEdge.rgb) + (sobel_vertEdge.rgb * sobel_vertEdge.rgb));\n  // gl_FragColor = vec4( n[1].rgb, 1.0 );\n  // gl_FragColor.r = 1.0;\n\n  return;\n}\n   ';
    }
  }, {
    key: 'compute',
    value: function compute() {
      var shaderInterpolation = '';
      // shaderInterpolation.inline(args) //true/false
      // shaderInterpolation.functions(args)

      return '\n// uniforms\n' + this.uniforms() + '\n\n// varying (should fetch it from vertex directly)\nvarying vec4      vPos;\nvarying vec4      vProjectedCoords;\nvarying vec2      vProjectedTextCoords;\nvarying mat4      vProjectionViewMatrix;\n\n// tailored functions\n' + this.functions() + '\n\n// main loop\n' + this._main + '\n      ';
    }
  }]);

  return ShadersFragment;
}();

exports.default = ShadersFragment;

},{}],150:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

/**
 * @module shaders/data
 */
var ShadersUniform = function () {
  function ShadersUniform() {
    _classCallCheck(this, ShadersUniform);
  }

  _createClass(ShadersUniform, null, [{
    key: 'uniforms',
    value: function uniforms() {
      return {
        'uCanvasWidth': {
          type: 'f',
          value: 0.,
          typeGLSL: 'float'
        },
        'uCanvasHeight': {
          type: 'f',
          value: 0.,
          typeGLSL: 'float'
        },
        'uWidth': {
          type: 'f',
          value: 1.,
          typeGLSL: 'float'
        },
        'uTextureFilled': {
          type: 't',
          value: [],
          typeGLSL: 'sampler2D'
        }
      };
    }
  }]);

  return ShadersUniform;
}();

exports.default = ShadersUniform;

},{}],151:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () {
    function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
        }
    }return function (Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
}();

function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}

var ShadersVertex = function () {
    function ShadersVertex() {
        _classCallCheck(this, ShadersVertex);
    }

    _createClass(ShadersVertex, [{
        key: "compute",
        value: function compute() {
            return "\nvarying vec4 vPos;\nvarying vec4 vProjectedCoords;\nvarying mat4 vProjectionViewMatrix;\nvarying vec2 vProjectedTextCoords;\n\n//\n// main\n//\nvoid main() {\n\n  vPos = modelMatrix * vec4(position, 1.0 );\n  vProjectionViewMatrix = projectionMatrix * viewMatrix;\n  vProjectedCoords =  projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n  vProjectedTextCoords = vec2(((vProjectedCoords.x / vProjectedCoords.w) + 1.0 ) / 2.0,\n                ((vProjectedCoords.y / vProjectedCoords.w) + 1.0 ) / 2.0 );\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0 );\n\n}\n        ";
        }
    }]);

    return ShadersVertex;
}();

exports.default = ShadersVertex;

},{}],152:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

var _shaders = require('./interpolation/shaders.interpolation');

var _shaders2 = _interopRequireDefault(_shaders);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

var ShadersFragment = function () {

  // pass uniforms object
  function ShadersFragment(uniforms) {
    _classCallCheck(this, ShadersFragment);

    this._uniforms = uniforms;
    this._functions = {};
    this._main = '';
  }

  _createClass(ShadersFragment, [{
    key: 'functions',
    value: function functions() {
      if (this._main === '') {
        // if main is empty, functions can not have been computed
        this.main();
      }

      var content = '';
      for (var property in this._functions) {
        content += this._functions[property] + '\n';
      }

      return content;
    }
  }, {
    key: 'uniforms',
    value: function uniforms() {
      var content = '';
      for (var property in this._uniforms) {
        var uniform = this._uniforms[property];
        content += 'uniform ' + uniform.typeGLSL + ' ' + property;

        if (uniform && uniform.length) {
          content += '[' + uniform.length + ']';
        }

        content += ';\n';
      }

      return content;
    }
  }, {
    key: 'main',
    value: function main() {
      // need to pre-call main to fill up the functions list
      this._main = '\nvoid main(void) {\n\n  // draw border if slice is cropped\n  // float uBorderDashLength = 10.;\n\n  if( uCanvasWidth > 0. &&\n      ((gl_FragCoord.x > uBorderMargin && (gl_FragCoord.x - uBorderMargin) < uBorderWidth) ||\n       (gl_FragCoord.x < (uCanvasWidth - uBorderMargin) && (gl_FragCoord.x + uBorderMargin) > (uCanvasWidth - uBorderWidth) ))){\n    float valueY = mod(gl_FragCoord.y, 2. * uBorderDashLength);\n    if( valueY < uBorderDashLength && gl_FragCoord.y > uBorderMargin && gl_FragCoord.y < (uCanvasHeight - uBorderMargin) ){\n      gl_FragColor = vec4(uBorderColor, 1.);\n      return;\n    }\n  }\n\n  if( uCanvasHeight > 0. &&\n      ((gl_FragCoord.y > uBorderMargin && (gl_FragCoord.y - uBorderMargin) < uBorderWidth) ||\n       (gl_FragCoord.y < (uCanvasHeight - uBorderMargin) && (gl_FragCoord.y + uBorderMargin) > (uCanvasHeight - uBorderWidth) ))){\n    float valueX = mod(gl_FragCoord.x, 2. * uBorderDashLength);\n    if( valueX < uBorderDashLength && gl_FragCoord.x > uBorderMargin && gl_FragCoord.x < (uCanvasWidth - uBorderMargin) ){\n      gl_FragColor = vec4(uBorderColor, 1.);\n      return;\n    }\n  }\n\n  // get texture coordinates of current pixel\n  vec4 dataCoordinates = uWorldToData * vPos;\n  vec3 currentVoxel = vec3(dataCoordinates.x, dataCoordinates.y, dataCoordinates.z);\n  vec4 dataValue = vec4(0., 0., 0., 0.);\n  vec3 gradient = vec3(0., 0., 0.);\n  ' + (0, _shaders2.default)(this, 'currentVoxel', 'dataValue', 'gradient') + '\n\n  // how do we deal wil more than 1 channel?\n  if(uNumberOfChannels == 1){\n    float intensity = dataValue.r;\n\n    // rescale/slope\n    intensity = intensity*uRescaleSlopeIntercept[0] + uRescaleSlopeIntercept[1];\n\n    float windowMin = uWindowCenterWidth[0] - uWindowCenterWidth[1] * 0.5;\n    float windowMax = uWindowCenterWidth[0] + uWindowCenterWidth[1] * 0.5;\n    intensity = ( intensity - windowMin ) / uWindowCenterWidth[1];\n\n    dataValue.r = dataValue.g = dataValue.b = intensity;\n    dataValue.a = 1.0;\n  }\n\n  // Apply LUT table...\n  //\n  if(uLut == 1){\n    // should opacity be grabbed there?\n    dataValue = texture2D( uTextureLUT, vec2( dataValue.r , 1.0) );\n  }\n\n  if(uInvert == 1){\n    dataValue = vec4(1.) - dataValue;\n    // how do we deal with that and opacity?\n    dataValue.a = 1.;\n  }\n\n  gl_FragColor = dataValue;\n\n    // if on edge, draw line\n  // float xPos = gl_FragCoord.x/512.;\n  // float yPos = gl_FragCoord.y/512.;\n  // if( xPos < 0.05 || xPos > .95 || yPos < 0.05 || yPos > .95){\n  //   gl_FragColor = vec4(xPos, yPos, 0., 1.);//dataValue;\n  //   //return;\n  // }\n\n}\n   ';
    }
  }, {
    key: 'compute',
    value: function compute() {
      var shaderInterpolation = '';
      // shaderInterpolation.inline(args) //true/false
      // shaderInterpolation.functions(args)

      return '\n// uniforms\n' + this.uniforms() + '\n\n// varying (should fetch it from vertex directly)\nvarying vec4      vPos;\n\n// tailored functions\n' + this.functions() + '\n\n// main loop\n' + this._main + '\n      ';
    }
  }]);

  return ShadersFragment;
}();

exports.default = ShadersFragment;

},{"./interpolation/shaders.interpolation":146}],153:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

/**
 * @module shaders/data
 */
var ShadersUniform = function () {
  function ShadersUniform() {
    _classCallCheck(this, ShadersUniform);
  }

  _createClass(ShadersUniform, null, [{
    key: 'uniforms',

    /**
     * Shaders data uniforms
     */
    value: function uniforms() {
      return {
        'uTextureSize': {
          type: 'i',
          value: 0,
          typeGLSL: 'int'
        },
        'uTextureContainer': {
          type: 'tv',
          value: [],
          typeGLSL: 'sampler2D',
          length: 7
        },
        'uDataDimensions': {
          type: 'iv',
          value: [0, 0, 0],
          typeGLSL: 'ivec3'
        },
        'uWorldToData': {
          type: 'm4',
          value: new THREE.Matrix4(),
          typeGLSL: 'mat4'
        },
        'uWindowCenterWidth': {
          type: 'fv1',
          value: [0.0, 0.0],
          typeGLSL: 'float',
          length: 2
        },
        'uRescaleSlopeIntercept': {
          type: 'fv1',
          value: [0.0, 0.0],
          typeGLSL: 'float',
          length: 2
        },
        'uNumberOfChannels': {
          type: 'i',
          value: 1,
          typeGLSL: 'int'
        },
        'uBitsAllocated': {
          type: 'i',
          value: 8,
          typeGLSL: 'int'
        },
        'uInvert': {
          type: 'i',
          value: 0,
          typeGLSL: 'int'
        },
        'uLut': {
          type: 'i',
          value: 0,
          typeGLSL: 'int'
        },
        'uTextureLUT': {
          type: 't',
          value: [],
          typeGLSL: 'sampler2D'
        },
        'uPixelType': {
          type: 'i',
          value: 0,
          typeGLSL: 'int'
        },
        'uPackedPerPixel': {
          type: 'i',
          value: 1,
          typeGLSL: 'int'
        },
        'uInterpolation': {
          type: 'i',
          value: 1,
          typeGLSL: 'int'
        },
        'uCanvasWidth': {
          type: 'f',
          value: 0.,
          typeGLSL: 'float'
        },
        'uCanvasHeight': {
          type: 'f',
          value: 0.,
          typeGLSL: 'float'
        },
        'uBorderColor': {
          type: 'v3',
          value: [1.0, 0.0, 0.5],
          typeGLSL: 'vec3'
        },
        'uBorderWidth': {
          type: 'f',
          value: 2.,
          typeGLSL: 'float'
        },
        'uBorderMargin': {
          type: 'f',
          value: 2.,
          typeGLSL: 'float'
        },
        'uBorderDashLength': {
          type: 'f',
          value: 10.,
          typeGLSL: 'float'
        }
      };
    }
  }]);

  return ShadersUniform;
}();

exports.default = ShadersUniform;

},{}],154:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () {
    function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
        }
    }return function (Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
}();

function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}

var ShadersVertex = function () {
    function ShadersVertex() {
        _classCallCheck(this, ShadersVertex);
    }

    _createClass(ShadersVertex, [{
        key: "compute",
        value: function compute() {
            return "\nvarying vec4 vPos;\n\n//\n// main\n//\nvoid main() {\n\n  vPos = modelMatrix * vec4(position, 1.0 );\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0 );\n\n}\n        ";
        }
    }]);

    return ShadersVertex;
}();

exports.default = ShadersVertex;

},{}],155:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _shadersContour = require('./shaders.contour.uniform');

var _shadersContour2 = _interopRequireDefault(_shadersContour);

var _shadersContour3 = require('./shaders.contour.fragment');

var _shadersContour4 = _interopRequireDefault(_shadersContour3);

var _shadersContour5 = require('./shaders.contour.vertex');

var _shadersContour6 = _interopRequireDefault(_shadersContour5);

var _shadersData = require('./shaders.data.uniform');

var _shadersData2 = _interopRequireDefault(_shadersData);

var _shadersData3 = require('./shaders.data.fragment');

var _shadersData4 = _interopRequireDefault(_shadersData3);

var _shadersData5 = require('./shaders.data.vertex');

var _shadersData6 = _interopRequireDefault(_shadersData5);

var _shadersVr = require('./shaders.vr.uniform');

var _shadersVr2 = _interopRequireDefault(_shadersVr);

var _shadersVr3 = require('./shaders.vr.fragment');

var _shadersVr4 = _interopRequireDefault(_shadersVr3);

var _shadersVr5 = require('./shaders.vr.vertex');

var _shadersVr6 = _interopRequireDefault(_shadersVr5);

var _shadersLayer = require('./shaders.layer.uniform');

var _shadersLayer2 = _interopRequireDefault(_shadersLayer);

var _shadersLayer3 = require('./shaders.layer.fragment');

var _shadersLayer4 = _interopRequireDefault(_shadersLayer3);

var _shadersLayer5 = require('./shaders.layer.vertex');

var _shadersLayer6 = _interopRequireDefault(_shadersLayer5);

var _shadersLocalizer = require('./shaders.localizer.uniform');

var _shadersLocalizer2 = _interopRequireDefault(_shadersLocalizer);

var _shadersLocalizer3 = require('./shaders.localizer.fragment');

var _shadersLocalizer4 = _interopRequireDefault(_shadersLocalizer3);

var _shadersLocalizer5 = require('./shaders.localizer.vertex');

var _shadersLocalizer6 = _interopRequireDefault(_shadersLocalizer5);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

/**
 * @module shaders
 */

exports.default = {
  ContourUniform: _shadersContour2.default,
  ContourFragment: _shadersContour4.default,
  ContourVertex: _shadersContour6.default,

  DataUniform: _shadersData2.default,
  DataFragment: _shadersData4.default,
  DataVertex: _shadersData6.default,

  VRUniform: _shadersVr2.default,
  VRFragment: _shadersVr4.default,
  VRVertex: _shadersVr6.default,

  LayerUniform: _shadersLayer2.default,
  LayerFragment: _shadersLayer4.default,
  LayerVertex: _shadersLayer6.default,

  LocalizerUniform: _shadersLocalizer2.default,
  LocalizerFragment: _shadersLocalizer4.default,
  LocalizerVertex: _shadersLocalizer6.default
};

},{"./shaders.contour.fragment":149,"./shaders.contour.uniform":150,"./shaders.contour.vertex":151,"./shaders.data.fragment":152,"./shaders.data.uniform":153,"./shaders.data.vertex":154,"./shaders.layer.fragment":156,"./shaders.layer.uniform":157,"./shaders.layer.vertex":158,"./shaders.localizer.fragment":159,"./shaders.localizer.uniform":160,"./shaders.localizer.vertex":161,"./shaders.vr.fragment":162,"./shaders.vr.uniform":163,"./shaders.vr.vertex":164}],156:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

var ShadersFragment = function () {

  // pass uniforms object
  function ShadersFragment(uniforms) {
    _classCallCheck(this, ShadersFragment);

    this._uniforms = uniforms;
    this._functions = {};
    this._main = '';
  }

  _createClass(ShadersFragment, [{
    key: 'functions',
    value: function functions() {
      if (this._main === '') {
        // if main is empty, functions can not have been computed
        this.main();
      }

      var content = '';
      for (var property in this._functions) {
        content += this._functions[property] + '\n';
      }

      return content;
    }
  }, {
    key: 'uniforms',
    value: function uniforms() {
      var content = '';
      for (var property in this._uniforms) {
        var uniform = this._uniforms[property];
        content += 'uniform ' + uniform.typeGLSL + ' ' + property;

        if (uniform && uniform.length) {
          content += '[' + uniform.length + ']';
        }

        content += ';\n';
      }

      return content;
    }
  }, {
    key: 'main',
    value: function main() {
      // need to pre-call main to fill up the functions list
      this._main = '\nvoid main(void) {\n\n  vec2 texc = vec2(((vProjectedCoords.x / vProjectedCoords.w) + 1.0 ) / 2.0,\n                ((vProjectedCoords.y / vProjectedCoords.w) + 1.0 ) / 2.0 );\n\n  // just silence warning for\n  vec4 dummy = vPos;\n\n  //The back position is the world space position stored in the texture.\n  vec4 baseColor0 = texture2D(uTextureBackTest0, texc);\n  vec4 baseColor1 = texture2D(uTextureBackTest1, texc);\n\n  if( uTrackMouse == 1 ){\n\n      if( vProjectedCoords.x < uMouse.x ){\n\n        gl_FragColor = baseColor0;\n\n      }\n      else{\n\n        gl_FragColor = mix( baseColor0, baseColor1, uOpacity1 );\n\n      }\n\n  }\n  else{\n\n    if( uType1 == 0 ){\n\n      //merge an image into\n      gl_FragColor = mix( baseColor0, baseColor1, uOpacity1 );\n\n    }\n    else{\n\n      float opacity = baseColor1.a;\n      gl_FragColor = mix( baseColor0, baseColor1, opacity * uOpacity1 );\n\n    }\n\n  }\n\n  return;\n}\n   ';
    }
  }, {
    key: 'compute',
    value: function compute() {
      var shaderInterpolation = '';
      // shaderInterpolation.inline(args) //true/false
      // shaderInterpolation.functions(args)

      return '\n// uniforms\n' + this.uniforms() + '\n\n// varying (should fetch it from vertex directly)\nvarying vec4      vPos;\nvarying vec4      vProjectedCoords;\n\n// tailored functions\n' + this.functions() + '\n\n// main loop\n' + this._main + '\n      ';
    }
  }]);

  return ShadersFragment;
}();

exports.default = ShadersFragment;

},{}],157:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

/**
 * @module shaders/data
 */
var ShadersUniform = function () {
  function ShadersUniform() {
    _classCallCheck(this, ShadersUniform);
  }

  _createClass(ShadersUniform, null, [{
    key: 'uniforms',
    value: function uniforms() {
      return {
        'uTextureBackTest0': {
          type: 't',
          value: [],
          typeGLSL: 'sampler2D'
        },
        'uTextureBackTest1': {
          type: 't',
          value: [],
          typeGLSL: 'sampler2D'
        },
        'uOpacity0': {
          type: 'f',
          value: 1.0,
          typeGLSL: 'float'
        },
        'uOpacity1': {
          type: 'f',
          value: 1.0,
          typeGLSL: 'float'
        },
        'uType0': {
          type: 'i',
          value: 0,
          typeGLSL: 'int'
        },
        'uType1': {
          type: 'i',
          value: 1,
          typeGLSL: 'int'
        },
        'uTrackMouse': {
          type: 'i',
          value: 0,
          typeGLSL: 'int'
        },
        'uMouse': {
          type: 'v2',
          value: new THREE.Vector2(),
          typeGLSL: 'vec2'
        }
      };
    }
  }]);

  return ShadersUniform;
}();

exports.default = ShadersUniform;

},{}],158:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () {
    function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
        }
    }return function (Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
}();

function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}

var ShadersVertex = function () {
    function ShadersVertex() {
        _classCallCheck(this, ShadersVertex);
    }

    _createClass(ShadersVertex, [{
        key: "compute",
        value: function compute() {
            return "\nvarying vec4 vPos;\nvarying vec4 vProjectedCoords;\n\n//\n// main\n//\nvoid main() {\n\n  vPos = modelMatrix * vec4(position, 1.0 );\n  vProjectedCoords =  projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0 );\n\n}\n        ";
        }
    }]);

    return ShadersVertex;
}();

exports.default = ShadersVertex;

},{}],159:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

var _shaders = require('./interpolation/shaders.interpolation');

var _shaders2 = _interopRequireDefault(_shaders);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

/**
 * Localizer fragment shader
 */
var _class = function () {

  /**
   * 
   */
  function _class(uniforms) {
    _classCallCheck(this, _class);

    this._uniforms = uniforms;
    this._functions = {};
    this._main = '';
  }

  /**
   * 
   */

  _createClass(_class, [{
    key: 'functions',
    value: function functions() {
      if (this._main === '') {
        // if main is empty, functions can not have been computed
        this.main();
      }

      var content = '';
      for (var property in this._functions) {
        content += this._functions[property] + '\n';
      }

      return content;
    }

    /**
     * 
     */

  }, {
    key: 'uniforms',
    value: function uniforms() {
      var content = '';
      for (var property in this._uniforms) {
        var uniform = this._uniforms[property];
        content += 'uniform ' + uniform.typeGLSL + ' ' + property;

        if (uniform && uniform.length) {
          content += '[' + uniform.length + ']';
        }

        content += ';\n';
      }

      return content;
    }

    /**
     * 
     */

  }, {
    key: 'main',
    value: function main() {
      // need to pre-call main to fill up the functions list
      this._main = '\nvoid intersectionProjection(\n  in vec4 plane,\n  in vec4 slice,\n  out vec3 intersectionProjection){\n\n      vec3 intersectionDirection = normalize(cross(plane.xyz, slice.xyz));\n      vec3 intersectionPoint = \n        cross(intersectionDirection,slice.xyz) * plane.w +\n        cross(plane.xyz, intersectionDirection) * slice.w;\n\n      intersectionProjection =\n        intersectionPoint.xyz +\n        (dot(vPos.xyz - intersectionPoint, intersectionDirection)\n          * intersectionDirection);\n\n}\n\nvoid main(void) {\n      vec4 c1 = vec4(0., 0., 0., 0.);\n      vec4 c2 = vec4(0., 0., 0., 0.);\n      vec4 c3 = vec4(0., 0., 0., 0.);\n\n      // localizer #1\n      // must be normalized!\n      if(length(uPlane1.xyz) > 0.5) {\n        vec3 projection1 = vec3(1.);\n        intersectionProjection(\n          uPlane1,\n          uSlice,\n          projection1\n        );\n\n        vec4 projInter1 = (vProjectionViewMatrix * vec4(projection1, 1.));\n        vec3 ndc1 = projInter1.xyz / projInter1.w;\n        vec2 screenSpace1 = (ndc1.xy * .5 + .5) * vec2(uCanvasWidth, uCanvasHeight);\n\n        float d1 = distance(gl_FragCoord.xy, screenSpace1.xy);\n        c1 = vec4(uPlaneColor1, 1. - smoothstep(.5, .7, d1));\n      }\n\n      // localizer #2\n      if(length(uPlane2.xyz) > 0.5) {\n        vec3 projection2 = vec3(1.);\n        intersectionProjection(\n          uPlane2,\n          uSlice,\n          projection2\n        );\n\n        vec4 projInter2 = (vProjectionViewMatrix * vec4(projection2, 1.));\n        vec3 ndc2 = projInter2.xyz / projInter2.w;\n        vec2 screenSpace2 = (ndc2.xy * .5 + .5) * vec2(uCanvasWidth, uCanvasHeight);\n\n        float d2 = distance(gl_FragCoord.xy, screenSpace2.xy);\n        c2 = vec4(uPlaneColor2, 1. - smoothstep(.5, .7, d2));\n      }\n\n      // localizer #3\n      if(length(uPlane3.xyz) > 0.5) {\n        vec3 projection3 = vec3(1.);\n        intersectionProjection(\n          uPlane3,\n          uSlice,\n          projection3\n        );\n\n        vec4 projInter3 = (vProjectionViewMatrix * vec4(projection3, 1.));\n        vec3 ndc3 = projInter3.xyz / projInter3.w;\n        vec2 screenSpace3 = (ndc3.xy * .5 + .5) * vec2(uCanvasWidth, uCanvasHeight);\n\n        float d3 = distance(gl_FragCoord.xy, screenSpace3.xy);\n        c3 = vec4(uPlaneColor3, 1. - smoothstep(.5, .7, d3));\n      }\n\n      vec3 colorMix = c1.xyz*c1.w + c2.xyz*c2.w + c3.xyz*c3.w;\n      gl_FragColor = vec4(colorMix, max(max(c1.w, c2.w),c3.w));\n}\n   ';
    }

    /**
     * 
     */

  }, {
    key: 'compute',
    value: function compute() {
      var shaderInterpolation = '';
      // shaderInterpolation.inline(args) //true/false
      // shaderInterpolation.functions(args)

      return '\n// uniforms\n' + this.uniforms() + '\n\n// varying (should fetch it from vertex directly)\nvarying vec4 vPos;\nvarying mat4 vProjectionViewMatrix;\n\n// tailored functions\n' + this.functions() + '\n\n// main loop\n' + this._main + '\n      ';
    }
  }]);

  return _class;
}();

exports.default = _class;

},{"./interpolation/shaders.interpolation":146}],160:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

/**
 * @module shaders/localizer/uniforms
 */

var _class = function () {
  function _class() {
    _classCallCheck(this, _class);
  }

  _createClass(_class, null, [{
    key: 'uniforms',

    /**
     * Shaders data uniforms
     */
    value: function uniforms() {
      return {
        'uCanvasWidth': {
          type: 'f',
          value: 0.,
          typeGLSL: 'float'
        },
        'uCanvasHeight': {
          type: 'f',
          value: 0.,
          typeGLSL: 'float'
        },
        'uSlice': {
          type: 'v4',
          value: [0.0, 0.0, 0.0, 0.0],
          typeGLSL: 'vec4'
        },
        'uPlane1': {
          type: 'v4',
          value: [0.0, 0.0, 0.0, 0.0],
          typeGLSL: 'vec4'
        },
        'uPlaneColor1': {
          type: 'v3',
          value: [1.0, 1.0, 0.0],
          typeGLSL: 'vec3'
        },
        'uPlane2': {
          type: 'v4',
          value: [0.0, 0.0, 0.0, 0.0],
          typeGLSL: 'vec4'
        },
        'uPlaneColor2': {
          type: 'v3',
          value: [1.0, 1.0, 0.0],
          typeGLSL: 'vec3'
        },
        'uPlane3': {
          type: 'v4',
          value: [0.0, 0.0, 0.0, 0.0],
          typeGLSL: 'vec4'
        },
        'uPlaneColor3': {
          type: 'v3',
          value: [1.0, 1.0, 0.0],
          typeGLSL: 'vec3'
        }

      };
    }
  }]);

  return _class;
}();

exports.default = _class;

},{}],161:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

/**
 * 
 */
var _class = function () {
  /**
   * 
   */
  function _class() {
    _classCallCheck(this, _class);
  }

  /**
   * 
   */

  _createClass(_class, [{
    key: "compute",
    value: function compute() {
      return "\nvarying vec4 vPos;\nvarying mat4 vProjectionViewMatrix;\n\n//\n// main\n//\nvoid main() {\n\n  vPos = modelMatrix * vec4(position, 1.0 );\n  vProjectionViewMatrix = projectionMatrix * viewMatrix;\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0 );\n\n}\n        ";
    }
  }]);

  return _class;
}();

exports.default = _class;

},{}],162:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

var _shaders = require('./interpolation/shaders.interpolation');

var _shaders2 = _interopRequireDefault(_shaders);

var _shadersHelpers = require('./helpers/shaders.helpers.intersectBox');

var _shadersHelpers2 = _interopRequireDefault(_shadersHelpers);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

var ShadersFragment = function () {

  // pass uniforms object
  function ShadersFragment(uniforms) {
    _classCallCheck(this, ShadersFragment);

    this._uniforms = uniforms;
    this._functions = {};
    this._main = '';
  }

  _createClass(ShadersFragment, [{
    key: 'functions',
    value: function functions() {
      if (this._main === '') {
        // if main is empty, functions can not have been computed
        this.main();
      }

      var content = '';
      for (var property in this._functions) {
        content += this._functions[property] + '\n';
      }

      return content;
    }
  }, {
    key: 'uniforms',
    value: function uniforms() {
      var content = '';
      for (var property in this._uniforms) {
        var uniform = this._uniforms[property];
        content += 'uniform ' + uniform.typeGLSL + ' ' + property;

        if (uniform && uniform.length) {
          content += '[' + uniform.length + ']';
        }

        content += ';\n';
      }

      return content;
    }
  }, {
    key: 'main',
    value: function main() {
      // need to pre-call main to fill up the functions list
      this._main = '\nvoid getIntensity(in vec3 dataCoordinates, out float intensity, out vec3 gradient){\n\n  vec4 dataValue = vec4(0., 0., 0., 0.);\n  ' + (0, _shaders2.default)(this, 'dataCoordinates', 'dataValue', 'gradient') + '\n\n  intensity = dataValue.r;\n\n  // rescale/slope\n  intensity = intensity*uRescaleSlopeIntercept[0] + uRescaleSlopeIntercept[1];\n  // window level\n  float windowMin = uWindowCenterWidth[0] - uWindowCenterWidth[1] * 0.5;\n  intensity = ( intensity - windowMin ) / uWindowCenterWidth[1];\n}\n\nvoid main(void) {\n  const int maxSteps = 1024;\n\n  // the ray\n  vec3 rayOrigin = cameraPosition;\n  vec3 rayDirection = normalize(vPos.xyz - rayOrigin);\n\n  // the Axe-Aligned B-Box\n  vec3 AABBMin = vec3(uWorldBBox[0], uWorldBBox[2], uWorldBBox[4]);\n  vec3 AABBMax = vec3(uWorldBBox[1], uWorldBBox[3], uWorldBBox[5]);\n\n  // Intersection ray/bbox\n  float tNear, tFar;\n  bool intersect = false;\n  ' + _shadersHelpers2.default.api(this, 'rayOrigin', 'rayDirection', 'AABBMin', 'AABBMax', 'tNear', 'tFar', 'intersect') + '\n  if (tNear < 0.0) tNear = 0.0;\n\n  // init the ray marching\n  float tCurrent = tNear;\n  float tStep = (tFar - tNear) / float(uSteps);\n  vec4 accumulatedColor = vec4(0.0);\n  float accumulatedAlpha = 0.0;\n\n  for(int rayStep = 0; rayStep < maxSteps; rayStep++){\n    vec3 currentPosition = rayOrigin + rayDirection * tCurrent;\n    // some non-linear FUN\n    // some occlusion issue to be fixed\n    vec3 transformedPosition = currentPosition; //transformPoint(currentPosition, uAmplitude, uFrequence);\n    // world to data coordinates\n    // rounding trick\n    // first center of first voxel in data space is CENTERED on (0,0,0)\n    vec4 dataCoordinatesRaw = uWorldToData * vec4(transformedPosition, 1.0);\n    vec3 currentVoxel = vec3(dataCoordinatesRaw.x, dataCoordinatesRaw.y, dataCoordinatesRaw.z);\n    float intensity = 0.0;\n    vec3 gradient = vec3(0., 0., 0.);\n    getIntensity(currentVoxel, intensity, gradient);\n\n    vec4 colorSample;\n    float alphaSample;\n    if(uLut == 1){\n      vec4 colorFromLUT = texture2D( uTextureLUT, vec2( intensity, 1.0) );\n      // 256 colors\n      colorSample = colorFromLUT;\n      alphaSample = colorFromLUT.a;\n    }\n    else{\n      alphaSample = intensity;\n      colorSample.r = colorSample.g = colorSample.b = intensity * alphaSample;\n    }\n\n    alphaSample = alphaSample * uAlphaCorrection;\n    alphaSample *= (1.0 - accumulatedAlpha);\n\n    accumulatedColor += alphaSample * colorSample;\n    accumulatedAlpha += alphaSample;\n\n    tCurrent += tStep;\n\n    if(tCurrent > tFar || accumulatedAlpha >= 1.0 ) break;\n  }\n\n  gl_FragColor = vec4(accumulatedColor.xyz, accumulatedAlpha);\n}\n   ';
    }
  }, {
    key: 'compute',
    value: function compute() {
      var shaderInterpolation = '';
      // shaderInterpolation.inline(args) //true/false
      // shaderInterpolation.functions(args)

      return '\n// uniforms\n' + this.uniforms() + '\n\n// varying (should fetch it from vertex directly)\nvarying vec4      vPos;\n\n// tailored functions\n' + this.functions() + '\n\n// main loop\n' + this._main + '\n      ';
    }
  }]);

  return ShadersFragment;
}();

exports.default = ShadersFragment;

},{"./helpers/shaders.helpers.intersectBox":142,"./interpolation/shaders.interpolation":146}],163:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

/**
 * @module shaders/data
 */
var ShadersUniform = function () {
  function ShadersUniform() {
    _classCallCheck(this, ShadersUniform);
  }

  _createClass(ShadersUniform, null, [{
    key: 'uniforms',
    value: function uniforms() {
      return {
        'uTextureSize': {
          type: 'i',
          value: 0,
          typeGLSL: 'int'
        },
        'uTextureContainer': {
          type: 'tv',
          value: [],
          typeGLSL: 'sampler2D',
          length: 7
        },
        'uDataDimensions': {
          type: 'iv',
          value: [0, 0, 0],
          typeGLSL: 'ivec3'
        },
        'uWorldToData': {
          type: 'm4',
          value: new THREE.Matrix4(),
          typeGLSL: 'mat4'
        },
        'uWindowCenterWidth': {
          type: 'fv1',
          value: [0.0, 0.0],
          typeGLSL: 'float',
          length: 2
        },
        'uRescaleSlopeIntercept': {
          type: 'fv1',
          value: [0.0, 0.0],
          typeGLSL: 'float',
          length: 2
        },
        'uNumberOfChannels': {
          type: 'i',
          value: 1,
          typeGLSL: 'int'
        },
        'uBitsAllocated': {
          type: 'i',
          value: 8,
          typeGLSL: 'int'
        },
        'uInvert': {
          type: 'i',
          value: 0,
          typeGLSL: 'int'
        },
        'uLut': {
          type: 'i',
          value: 0,
          typeGLSL: 'int'
        },
        'uTextureLUT': {
          type: 't',
          value: [],
          typeGLSL: 'sampler2D'
        },
        'uPixelType': {
          type: 'i',
          value: 0,
          typeGLSL: 'int'
        },
        'uPackedPerPixel': {
          type: 'i',
          value: 1,
          typeGLSL: 'int'
        },
        'uInterpolation': {
          type: 'i',
          value: 1,
          typeGLSL: 'int'
        },
        'uWorldBBox': {
          type: 'fv1',
          value: [0.0, 0.0, 0.0, 0.0, 0.0, 0.0],
          typeGLSL: 'float',
          length: 6
        },
        'uSteps': {
          type: 'i',
          value: 256,
          typeGLSL: 'int'
        },
        'uAlphaCorrection': {
          type: 'f',
          value: 0.5,
          typeGLSL: 'float'
        },
        'uFrequence': {
          type: 'f',
          value: 0.0,
          typeGLSL: 'float'
        },
        'uAmplitude': {
          type: 'f',
          value: 0.0,
          typeGLSL: 'float'
        }
      };
    }
  }]);

  return ShadersUniform;
}();

exports.default = ShadersUniform;

},{}],164:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () {
    function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
        }
    }return function (Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
}();

function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}

var ShadersVertex = function () {
    function ShadersVertex() {
        _classCallCheck(this, ShadersVertex);
    }

    _createClass(ShadersVertex, [{
        key: "compute",
        value: function compute() {
            return "\nvarying vec4 vPos;\n\n//\n// main\n//\nvoid main() {\n\n  vPos = modelMatrix * vec4(position, 1.0 );\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0 );\n\n}\n        ";
        }
    }]);

    return ShadersVertex;
}();

exports.default = ShadersVertex;

},{}],165:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

var _widgets = require('../widgets/widgets.base');

var _widgets2 = _interopRequireDefault(_widgets);

var _widgets3 = require('../widgets/widgets.handle');

var _widgets4 = _interopRequireDefault(_widgets3);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

/**
 * @module widgets/handle
 *
 */

var WidgetsAnnotation = function (_WidgetsBase) {
  _inherits(WidgetsAnnotation, _WidgetsBase);

  function WidgetsAnnotation(targetMesh, controls, camera, container) {
    _classCallCheck(this, WidgetsAnnotation);

    var _this = _possibleConstructorReturn(this, (WidgetsAnnotation.__proto__ || Object.getPrototypeOf(WidgetsAnnotation)).call(this));

    _this._targetMesh = targetMesh;
    _this._controls = controls;
    _this._camera = camera;
    _this._container = container;

    _this._active = true;

    _this._worldPosition = new THREE.Vector3();
    if (_this._targetMesh !== null) {
      _this._worldPosition = _this._targetMesh.position;
    }

    // mesh stuff
    _this._material = null;
    _this._geometry = null;
    _this._mesh = null;

    // dom stuff
    _this._line = null;
    _this._label = null;
    _this._cone = null;
    _this._labeltext = null;

    //booleans
    _this._alreadycreated = null; //bool that turns true when the user enter the name of the label
    _this._movinglabel = null; //bool that turns true when the label is moving with the mouse
    _this._labelmoved = false; //bool that turns true once the label is moved by the user (at least once)

    _this._labelhovered = false;
    _this._domHovered = false;
    _this._hovered = true;

    //var
    _this._labelpositionx = null; //position of label (top left corner)
    _this._labelpositiony = null; //position of label (top left corner)
    _this._differencemousecenterlabelx = 0; //difference between mouse position in the label and position of label (top left corner)
    _this._differencemousecenterlabely = 0; //difference between mouse position in the label and position of label (top left corner)

    // add handles
    _this._handles = [];

    self = _this;

    // first handle
    var firstHandle = new _widgets4.default(_this._targetMesh, _this._controls, _this._camera, _this._container);
    firstHandle.worldPosition = _this._worldPosition;
    firstHandle.hovered = true;
    _this.add(firstHandle);

    _this._handles.push(firstHandle);

    var secondHandle = new _widgets4.default(_this._targetMesh, _this._controls, _this._camera, _this._container);
    secondHandle.worldPosition = _this._worldPosition;
    secondHandle.hovered = true;
    // active and tracking might be redundant
    secondHandle.active = true;
    secondHandle.tracking = true;
    _this.add(secondHandle);

    _this._handles.push(secondHandle);

    // Create annotation

    _this.create();

    _this.onMove = _this.onMove.bind(_this);
    _this.onHoverlabel = _this.onHoverlabel.bind(_this);
    _this.notonHoverlabel = _this.notonHoverlabel.bind(_this);
    _this.changelabeltext = _this.changelabeltext.bind(_this);
    _this.movelabel = _this.movelabel.bind(_this);
    _this.notmovelabel = _this.notmovelabel.bind(_this);

    _this.addEventListeners();

    return _this;
  }

  _createClass(WidgetsAnnotation, [{
    key: 'addEventListeners',
    value: function addEventListeners() {
      this._label.addEventListener('mouseenter', this.onHoverlabel);
      this._label.addEventListener('mouseleave', this.notonHoverlabel);
      this._label.addEventListener('dblclick', this.changelabeltext);
      this._label.addEventListener('mousedown', this.movelabel);
      this._container.addEventListener('mouseup', this.notmovelabel);

      this._container.addEventListener('mousewheel', this.onMove);
      this._container.addEventListener('DOMMouseScroll', this.onMove);
    }
  }, {
    key: 'movelabel',
    value: function movelabel() {
      //function called when mousedown
      if (this._labelhovered = true) {
        //if label hobered we will move the label
        this._movinglabel = true;
        this._labelmoved = true;
        var mousey = -(-event.clientY + this._container.offsetHeight);
        var mousex = event.clientX;
        //calculate differencemousecenterlabel (difference between ref position of the label (top-left corner) and mouse position in the label)
        this._differencemousecenterlabelx = Math.abs(Math.abs(mousex) - Math.abs(this._labelpositionx));
        this._differencemousecenterlabely = Math.abs(Math.abs(mousey) - Math.abs(this._labelpositiony));
      }
    }
  }, {
    key: 'notmovelabel',
    value: function notmovelabel() {
      //this function is called when mouseup
      this._movinglabel = false;
      this._handles[0]._controls.enabled = true; //move the camera when mousedown and mousedown again
      this._handles[1]._controls.enabled = true;
      this._differencemousecenterlabelx = 0; //restart the value of differencemousecenterlabel. Necessary?
      this._differencemousecenterlabely = 0;
    }
  }, {
    key: 'onHoverlabel',
    value: function onHoverlabel() {
      //this function is called when mouse enters the label with "mouseenter" event
      this._labelhovered = true;
    }
  }, {
    key: 'notonHoverlabel',
    value: function notonHoverlabel() {
      //this function is called when mouse leaves the label with "mouseleave" event
      this._labelhovered = false;
    }
  }, {
    key: 'onMove',
    value: function onMove(evt) {

      if (this._movinglabel == true) {
        this._handles[0]._controls.enabled = false;
        this._handles[1]._controls.enabled = false;
      }

      this._dragged = true;

      this._handles[0].onMove(evt);
      this._handles[1].onMove(evt);

      this._hovered = this._handles[0].hovered || this._handles[1].hovered || this._labelhovered;

      this.update();
    }
  }, {
    key: 'onStart',
    value: function onStart(evt) {

      this._dragged = false;

      this._handles[0].onStart(evt);
      this._handles[1].onStart(evt);

      this._active = this._handles[0].active || this._handles[1].active;

      this.update();
    }
  }, {
    key: 'setlabeltext',
    value: function setlabeltext() {
      this._labeltext = prompt("Please enter the name of the label", ""); //this function is called when the user creates a new arrow
      if (typeof this._labeltext == 'string') {
        //avoid error
        if (this._labeltext.length > 0) {
          this._label.innerHTML = this._labeltext;
          this._label.style.display = ''; //in css an empty string is used to revert display=none. Show the label once we know the content
          this._dashline.style.display = ''; //in css an empty string is used to revert display=none. Show the label once we know the content
        } else {
          this._label.innerHTML = this._labeltext;
          this._label.style.display = 'none'; //hide the label
          this._dashline.style.display = 'none'; //hide the label
        }
      }
    }
  }, {
    key: 'changelabeltext',
    value: function changelabeltext() {
      //this function is called when the user does double click in the label
      this._labeltext = prompt("Please enter new name of the label", this._label.innerHTML);
      if (typeof this._labeltext == 'string') {
        //avoid error
        if (this._labeltext.length > 0) {
          this._label.innerHTML = this._labeltext;
          this._label.style.display = ''; //in css an empty string is used to revert display=none. Show the label
          this._dashline.style.display = ''; //in css an empty string is used to revert display=none. Show the label
        } else {
          // if the length is 0 the user pressed Cancel
          this._label.innerHTML = this._labeltext;
          this._label.style.display = 'none'; //hide the label
          this._dashline.style.display = 'none'; //hide the label
        }
      }
    }
  }, {
    key: 'onEnd',
    value: function onEnd(evt) {
      // First Handle
      this._handles[0].onEnd(evt);

      // Second Handle
      if (this._dragged || !this._handles[1].tracking) {
        this._handles[1].tracking = false;
        this._handles[1].onEnd(evt);
      } else {
        this._handles[1].tracking = false;
      }

      if (self._alreadycreated != true) {
        this.setlabeltext();
        self._alreadycreated = true;
      }

      // State of annotation widget
      this._active = this._handles[0].active || this._handles[1].active;
      this.update();
    }
  }, {
    key: 'create',
    value: function create() {
      this.createMesh();
      this.createDOM();
    }
  }, {
    key: 'update',
    value: function update() {
      this.updateColor();

      // mesh stuff
      this.updateMeshColor();
      this.updateMeshPosition();

      // DOM stuff
      this.updateDOMPosition();
      this.updateDOMColor();
    }
  }, {
    key: 'createMesh',
    value: function createMesh() {
      // geometry
      this._geometry = new THREE.Geometry();
      this._geometry.vertices.push(this._handles[0].worldPosition);
      this._geometry.vertices.push(this._handles[1].worldPosition);

      // material
      this._material = new THREE.LineBasicMaterial();
      this.updateMeshColor();

      // mesh
      this._meshline = new THREE.Line(this._geometry, this._material);
      this._meshline.visible = true;

      // add it!
      this.add(this._meshline);

      //create cone and add it
      this._conegeometry = new THREE.CylinderGeometry(0, 2, 10);
      this._conegeometry.translate(0, -5, 0);
      this._conegeometry.rotateX(-Math.PI / 2);
      this._cone = new THREE.Mesh(this._conegeometry, this._material);
      this._cone.visible = true;
      this.add(this._cone);
    }
  }, {
    key: 'updateMeshColor',
    value: function updateMeshColor() {
      if (this._material) {
        this._material.color.set(this._color);
      }
    }
  }, {
    key: 'updateMeshPosition',
    value: function updateMeshPosition() {
      if (this._geometry) {
        this._geometry.verticesNeedUpdate = true;
      }
    }
  }, {
    key: 'createDOM',
    value: function createDOM() {
      // add line!
      this._line = document.createElement('div');
      this._line.setAttribute('class', 'widgets handle line');
      this._line.style.position = 'absolute';
      this._line.style.transformOrigin = '0 100%';
      this._line.style.marginTop = '-1px';
      this._line.style.height = '2px'; //2
      this._line.style.width = '3px'; //3
      this._container.appendChild(this._line);

      // add dash line
      this._dashline = document.createElement('div');
      this._dashline.setAttribute('class', 'widgets handle dashline');
      this._dashline.style.position = 'absolute';
      this._dashline.style.border = 'none';
      this._dashline.style.borderTop = '2.5px dashed #F9F9F9';
      this._dashline.style.transformOrigin = '0 100%';
      this._dashline.style.height = '1px';
      this._dashline.style.width = '50%';
      this._dashline.style.display = 'none';
      this._container.appendChild(this._dashline);

      // add label!
      this._label = document.createElement('div');
      this._label.setAttribute('id', this.uuid);
      this._label.setAttribute('class', 'widgets handle label');
      this._label.style.border = '2px solid #F9F9F9';
      this._label.style.backgroundColor = '#F9F9F9';
      // this._label.style.opacity = '0.5';
      this._label.style.color = '#353535';
      this._label.style.padding = '4px';
      this._label.style.position = 'absolute';
      this._label.style.transformOrigin = '0 100%';
      this._label.innerHTML = 'Hello, world!';
      this._label.style.display = 'none';
      this._container.appendChild(this._label);

      this.updateDOMColor();
    }
  }, {
    key: 'updateDOMPosition',
    value: function updateDOMPosition() {

      console.log('function updateDOMPosition');
      // update annotation lines and text!
      var x1 = this._handles[0].screenPosition.x;
      var y1 = this._handles[0].screenPosition.y;
      var x2 = this._handles[1].screenPosition.x;
      var y2 = this._handles[1].screenPosition.y;

      var x0 = x1 + (x2 - x1) / 2;
      var y0 = y1 + (y2 - y1) / 2;

      var length = Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));
      var angle = Math.atan2(y2 - y1, x2 - x1) * 180 / Math.PI; //result in deg

      var posY = y1 - this._container.offsetHeight;

      // update line
      var transform = 'translate3D(' + x1 + 'px,' + posY + 'px, 0)';
      transform += ' rotate(' + angle + 'deg)';

      this._line.style.transform = transform;
      this._line.style.width = length + 'px';

      // update label position
      var mousex = 0;
      var mousey = 0;

      var posY0 = void 0;

      posY0 = y0 - this._container.offsetHeight - this._label.offsetHeight / 2;
      x0 -= this._label.offsetWidth / 2;

      var x;
      var y;

      if (this._labelmoved == false) {
        //if the user hasnt moved the label, the position is defined by the position of the arrow
        var transform2 = 'translate3D(' + Math.round(x0) + 'px,' + Math.round(posY0) + 'px, 0)';
        this._label.style.transform = transform2;
        this._labelpositionx = Math.round(x0);
        this._labelpositiony = Math.round(posY0);
      }

      if (this._movinglabel) {
        //if the user has moved the label, the position is defined by the mouse
        mousex = event.clientX;
        mousey = -(-event.clientY + this._container.offsetHeight);
        this._label.style.transform = 'translate3D(' + (mousex - this._differencemousecenterlabelx) + 'px,' + (mousey - this._differencemousecenterlabely) + 'px, 0)';
        //we use differencemousecenterlabel to check the difference between the position of the mouse in the label and the reference position of the label (top-left corner)
        this._labelpositionx = mousex - this._differencemousecenterlabelx;
        this._labelpositiony = mousey - this._differencemousecenterlabely;
      }

      //update cone
      var w0 = this._handles[0].worldPosition;
      var w1 = this._handles[1].worldPosition;

      //position and rotation of cone
      this._cone.position.set(w1.x, w1.y, w1.z);
      this._cone.lookAt(w0);

      // update dash line

      //calculate the place in the label: center of the label
      x1 = this._handles[0].screenPosition.x;
      y1 = this._handles[0].screenPosition.y;
      x2 = this._labelpositionx;
      y2 = this._labelpositiony + this._container.offsetHeight; //revert the operation in 'mousey' to get the previous eventY

      //get the size of the label so we can place the dashed line in the center of it
      var labelheight = this._label.offsetHeight;
      var labelwidth = this._label.offsetWidth;

      var centerlabelx = 0;
      var centerlabely = 0;

      if (isFinite(labelwidth) && isFinite(labelheight)) {
        //if the extraction has been succesfull, we calculate the center of the label with total size
        centerlabelx = labelwidth / 2;
        centerlabely = labelheight / 2;
      }

      x2 += centerlabelx;
      y2 += centerlabely;

      //calculate the place in the arrow: closest part of the line to place the dashed line
      var x1_tail = this._handles[0].screenPosition.x; //first position: tail of arrow
      var y1_tail = this._handles[0].screenPosition.y;
      var x1_body = (this._handles[0].screenPosition.x + this._handles[1].screenPosition.x) / 2; //second position: center of arrow
      var y1_body = (this._handles[0].screenPosition.y + this._handles[1].screenPosition.y) / 2;
      var x1_nose = this._handles[1].screenPosition.x; //third position: peak of arrow
      var y1_nose = this._handles[1].screenPosition.y;

      //calculate all the lengths to the label, so we can choose the min
      var lengthtaillabel = Math.sqrt((x1_tail - x2) * (x1_tail - x2) + (y1_tail - y2) * (y1_tail - y2));
      var lengthbodylabel = Math.sqrt((x1_body - x2) * (x1_body - x2) + (y1_body - y2) * (y1_body - y2));
      var lengthnoselabel = Math.sqrt((x1_nose - x2) * (x1_nose - x2) + (y1_nose - y2) * (y1_nose - y2));

      var lengths = [lengthtaillabel, lengthbodylabel, lengthnoselabel];
      var minlength = Math.min(lengthtaillabel, lengthbodylabel, lengthnoselabel);
      var minlengthindex = lengths.indexOf(minlength);

      if (minlengthindex == 0) {
        x1 = x1_tail;
        y1 = y1_tail;
      }
      if (minlengthindex == 1) {
        x1 = x1_body;
        y1 = y1_body;
      }
      if (minlengthindex == 2) {
        x1 = x1_nose;
        y1 = y1_nose;
      }

      // Once we found the closest point to the label, we create the dashed line from that point
      var lengthdashline = Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));
      var angledashline = Math.atan2(y2 - y1, x2 - x1) * 180 / Math.PI; //result in deg

      var posYdashline = y1 - this._container.offsetHeight;

      // update dashed line
      var transformdashline = 'translate3D(' + x1 + 'px,' + posYdashline + 'px, 0)';
      transformdashline += ' rotate(' + angledashline + 'deg)';

      this._dashline.style.transform = transformdashline;
      this._dashline.style.width = lengthdashline + 'px';
    }
  }, {
    key: 'updateDOMColor',
    value: function updateDOMColor() {
      this._line.style.backgroundColor = '' + this._color;
      this._dashline.style.borderTop = '2.5px dashed ' + ('' + this._color);
      this._label.style.borderColor = '' + this._color;
    }
  }, {
    key: 'worldPosition',
    get: function get() {
      return this._worldPosition;
    },
    set: function set(worldPosition) {
      this._worldPosition = worldPosition;
      this._handles[0].worldPosition = this._worldPosition;
      this._handles[1].worldPosition = this._worldPosition;

      this.update();
    }
  }]);

  return WidgetsAnnotation;
}(_widgets2.default);

exports.default = WidgetsAnnotation;

},{"../widgets/widgets.base":166,"../widgets/widgets.handle":168}],166:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

/**
 *
 */
var WidgetsBase = function (_THREE$Object3D) {
  _inherits(WidgetsBase, _THREE$Object3D);

  function WidgetsBase(container) {
    _classCallCheck(this, WidgetsBase);

    // is widget enabled?
    var _this = _possibleConstructorReturn(this, (WidgetsBase.__proto__ || Object.getPrototypeOf(WidgetsBase)).call(this));
    // init THREE Object 3D


    _this._enabled = true;

    // STATE, ENUM might be better
    _this._selected = false;
    _this._hovered = false;
    _this._active = false;
    // thos._state = 'SELECTED';

    _this._colors = {
      default: '#00B0FF',
      active: '#FFEB3B',
      hover: '#F50057',
      select: '#76FF03'
    };
    _this._color = _this._colors.default;

    _this._dragged = false;
    // can not call it visible because it conflicts with THREE.Object3D
    _this._displayed = true;

    _this._container = container;
    return _this;
  }

  _createClass(WidgetsBase, [{
    key: 'initOffsets',
    value: function initOffsets() {
      var box = this._container.getBoundingClientRect();

      var body = document.body;
      var docEl = document.documentElement;

      var scrollTop = window.pageYOffset || docEl.scrollTop || body.scrollTop;
      var scrollLeft = window.pageXOffset || docEl.scrollLeft || body.scrollLeft;

      var clientTop = docEl.clientTop || body.clientTop || 0;
      var clientLeft = docEl.clientLeft || body.clientLeft || 0;

      var top = box.top + scrollTop - clientTop;
      var left = box.left + scrollLeft - clientLeft;

      this._offsets = {
        top: Math.round(top),
        left: Math.round(left)
      };
    }
  }, {
    key: 'offsetChanged',
    value: function offsetChanged() {
      this.initOffsets();
      this.update();
    }
  }, {
    key: 'getMouseOffsets',
    value: function getMouseOffsets(event, container) {
      return {
        x: (event.clientX - this._offsets.left) / container.offsetWidth * 2 - 1,
        y: -((event.clientY - this._offsets.top) / container.offsetHeight) * 2 + 1,
        screenX: event.clientX - this._offsets.left,
        screenY: event.clientY - this._offsets.top
      };
    }
  }, {
    key: 'update',
    value: function update() {
      // to be overloaded
      window.console.log('update() should be overloaded!');
    }
  }, {
    key: 'free',
    value: function free() {
      this._container = null;
    }
  }, {
    key: 'updateColor',
    value: function updateColor() {
      if (this._active) {
        this._color = this._colors.active;
      } else if (this._hovered) {
        this._color = this._colors.hover;
      } else if (this._selected) {
        this._color = this._colors.select;
      } else {
        this._color = this._colors.default;
      }
    }
  }, {
    key: 'enabled',
    get: function get() {
      return this._enabled;
    },
    set: function set(enabled) {
      this._enabled = enabled;
      this.update();
    }
  }, {
    key: 'selected',
    get: function get() {
      return this._selected;
    },
    set: function set(selected) {
      this._selected = selected;
      this.update();
    }
  }, {
    key: 'hovered',
    get: function get() {
      return this._hovered;
    },
    set: function set(hovered) {
      this._hovered = hovered;
      this.update();
    }
  }, {
    key: 'dragged',
    get: function get() {
      return this._dragged;
    },
    set: function set(dragged) {
      this._dragged = dragged;
      this.update();
    }
  }, {
    key: 'displayed',
    get: function get() {
      return this._displayed;
    },
    set: function set(displayed) {
      this._displayed = displayed;
      this.update();
    }
  }, {
    key: 'active',
    get: function get() {
      return this._active;
    },
    set: function set(active) {
      this._active = active;
      this.update();
    }
  }, {
    key: 'color',
    get: function get() {
      return this._color;
    },
    set: function set(color) {
      this._color = color;
      this.update();
    }
  }]);

  return WidgetsBase;
}(THREE.Object3D);

exports.default = WidgetsBase;

},{}],167:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () {
    function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
        }
    }return function (Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
}();

var _widgets = require('../widgets/widgets.base');

var _widgets2 = _interopRequireDefault(_widgets);

var _widgets3 = require('../widgets/widgets.handle');

var _widgets4 = _interopRequireDefault(_widgets3);

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
}

function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}

function _possibleConstructorReturn(self, call) {
    if (!self) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

/**
 * @module widgets/handle
 *
 */

var WidgetsBiRuler = function (_WidgetsBase) {
    _inherits(WidgetsBiRuler, _WidgetsBase);

    function WidgetsBiRuler(targetMesh, controls, camera, container) {
        _classCallCheck(this, WidgetsBiRuler);

        var _this = _possibleConstructorReturn(this, (WidgetsBiRuler.__proto__ || Object.getPrototypeOf(WidgetsBiRuler)).call(this));

        _this._targetMesh = targetMesh;
        _this._controls = controls;
        _this._camera = camera;
        _this._container = container;

        _this._active = true;
        _this._initOrtho = false;

        _this._worldPosition = new THREE.Vector3();
        if (_this._targetMesh !== null) {
            _this._worldPosition = _this._targetMesh.position;
        }

        // mesh stuff
        _this._material = null;
        _this._geometry = null;
        _this._mesh = null;

        // dom stuff
        _this._line = null;
        _this._distance = null;

        // add handles
        _this._handles = [];

        // first handle
        var firstHandle = new _widgets4.default(_this._targetMesh, _this._controls, _this._camera, _this._container);
        firstHandle.worldPosition = _this._worldPosition;
        firstHandle.hovered = true;
        _this.add(firstHandle);

        _this._handles.push(firstHandle);

        var secondHandle = new _widgets4.default(_this._targetMesh, _this._controls, _this._camera, _this._container);
        secondHandle.worldPosition = _this._worldPosition;
        secondHandle.hovered = true;
        // active and tracking might be redundant
        secondHandle.active = true;
        secondHandle.tracking = true;
        _this.add(secondHandle);

        _this._handles.push(secondHandle);

        // third handle
        var thirdHandle = new _widgets4.default(_this._targetMesh, _this._controls, _this._camera, _this._container);
        thirdHandle.worldPosition = _this._worldPosition;
        thirdHandle.hovered = true;
        _this.add(thirdHandle);

        _this._handles.push(thirdHandle);

        // fourth handle
        var fourthHandle = new _widgets4.default(_this._targetMesh, _this._controls, _this._camera, _this._container);
        fourthHandle.worldPosition = _this._worldPosition;
        fourthHandle.hovered = true;
        _this.add(fourthHandle);

        _this._handles.push(fourthHandle);

        // Create ruler
        _this.create();

        _this.onMove = _this.onMove.bind(_this);
        _this.addEventListeners();

        _this._orientation = null;
        _this._slice = null;
        return _this;
    }

    _createClass(WidgetsBiRuler, [{
        key: 'addEventListeners',
        value: function addEventListeners() {
            this._container.addEventListener('mousewheel', this.onMove);
            this._container.addEventListener('DOMMouseScroll', this.onMove);
        }
    }, {
        key: 'onMove',
        value: function onMove(evt) {
            this._dragged = true;

            this._handles[0].onMove(evt);
            this._handles[1].onMove(evt);
            this._handles[2].onMove(evt);
            this._handles[3].onMove(evt);

            this._hovered = this._handles[0].hovered || this._handles[1].hovered || this._handles[2].hovered || this._handles[3].hovered;

            this.update();
        }
    }, {
        key: 'onStart',
        value: function onStart(evt) {
            this._dragged = false;

            this._handles[0].onStart(evt);
            this._handles[1].onStart(evt);
            this._handles[2].onStart(evt);
            this._handles[3].onStart(evt);

            this._active = this._handles[0].active || this._handles[1].active || this._handles[2].active || this._handles[3].active;
            this.update();
        }
    }, {
        key: 'onEnd',
        value: function onEnd(evt) {
            // First Handle
            this._handles[0].onEnd(evt);
            this._handles[2].onEnd(evt);
            this._handles[3].onEnd(evt);

            window.console.log(this);

            // Second Handle
            if (this._dragged || !this._handles[1].tracking) {
                this._handles[1].tracking = false;
                this._handles[1].onEnd(evt);
            } else {
                this._handles[1].tracking = false;
            }

            // State of ruler widget
            this._active = this._handles[0].active || this._handles[1].active || this._handles[2].active || this._handles[3].active;
            this.update();
        }
    }, {
        key: 'create',
        value: function create() {
            this.createMesh();
            this.createDOM();
        }
    }, {
        key: 'hideDOM',
        value: function hideDOM() {
            this._line.style.display = 'none';
            this._distance.style.display = 'none';
            this._line2.style.display = 'none';
            this._distance2.style.display = 'none';

            for (var index in this._handles) {
                this._handles[index].hideDOM();
            }

            this._dashline.style.display = 'none';
        }
    }, {
        key: 'showDOM',
        value: function showDOM() {
            this._line.style.display = '';
            this._distance.style.display = '';
            this._line2.style.display = '';
            this._distance2.style.display = '';

            for (var index in this._handles) {
                this._handles[index].showDOM();
            }

            this._dashline.style.display = '';
        }
    }, {
        key: 'hideMesh',
        value: function hideMesh() {
            this._mesh.visible = false;
            this._mesh2.visible = false;
            this._handles[0].visible = false;
            this._handles[1].visible = false;
            this._handles[2].visible = false;
            this._handles[3].visible = false;
        }
    }, {
        key: 'showMesh',
        value: function showMesh() {
            this._mesh.visible = true;
            this._mesh2.visible = true;
            this._handles[0].visible = true;
            this._handles[1].visible = true;
            this._handles[2].visible = true;
            this._handles[3].visible = true;
        }
    }, {
        key: 'show',
        value: function show() {
            this.showDOM();
            this.showMesh();
        }
    }, {
        key: 'hide',
        value: function hide() {
            this.hideDOM();
            this.hideMesh();
        }
    }, {
        key: 'update',
        value: function update() {
            this.updateColor();

            // mesh stuff
            this.updateMeshColor();
            this.updateMeshPosition();

            // DOM stuff
            this.updateDOMPosition();
            this.updateDOMColor();
        }
    }, {
        key: 'createMesh',
        value: function createMesh() {
            // geometry
            this._geometry = new THREE.Geometry();
            this._geometry.vertices.push(this._handles[0].worldPosition);
            this._geometry.vertices.push(this._handles[1].worldPosition);

            // geometry
            this._geometry2 = new THREE.Geometry();
            this._geometry2.vertices.push(this._handles[2].worldPosition);
            this._geometry2.vertices.push(this._handles[3].worldPosition);

            // material
            this._material = new THREE.LineBasicMaterial();
            this._material2 = new THREE.LineBasicMaterial();
            this.updateMeshColor();

            // mesh
            this._mesh = new THREE.Line(this._geometry, this._material);
            this._mesh.visible = true;
            this._mesh2 = new THREE.Line(this._geometry2, this._material2);
            this._mesh2.visible = true;

            // add it!
            this.add(this._mesh);
            this.add(this._mesh2);
        }
    }, {
        key: 'updateMeshColor',
        value: function updateMeshColor() {
            if (this._material) {
                this._material.color.set(this._color);
            }
            if (this._material2) {
                this._material2.color.set(this._color);
            }
        }
    }, {
        key: 'updateMeshPosition',
        value: function updateMeshPosition() {
            if (this._geometry) {
                this._geometry.verticesNeedUpdate = true;
            }
            if (this._geometry2) {
                this._geometry2.verticesNeedUpdate = true;
            }
        }
    }, {
        key: 'createDOM',
        value: function createDOM() {
            // add line!
            this._line = document.createElement('div');
            this._line.setAttribute('class', 'widgets handle line');
            this._line.style.position = 'absolute';
            this._line.style.transformOrigin = '0 100%';
            this._line.style.marginTop = '-1px';
            this._line.style.height = '2px';
            this._line.style.width = '3px';
            this._container.appendChild(this._line);

            // add distance!
            this._distance = document.createElement('div');
            this._distance.setAttribute('class', 'widgets handle distance');
            this._distance.style.border = '2px solid';
            this._distance.style.backgroundColor = '#F9F9F9';
            // this._distance.style.opacity = '0.5';
            this._distance.style.color = '#353535';
            this._distance.style.padding = '4px';
            this._distance.style.position = 'absolute';
            this._distance.style.transformOrigin = '0 100%';
            this._distance.innerHTML = 'Hello, world!';
            this._container.appendChild(this._distance);

            // add line!
            this._line2 = document.createElement('div');
            this._line2.setAttribute('class', 'widgets handle line');
            this._line2.style.position = 'absolute';
            this._line2.style.transformOrigin = '0 100%';
            this._line2.style.marginTop = '-1px';
            this._line2.style.height = '2px';
            this._line2.style.width = '3px';
            this._container.appendChild(this._line2);

            // add distance!
            this._distance2 = document.createElement('div');
            this._distance2.setAttribute('class', 'widgets handle distance');
            this._distance.style.border = '2px solid';
            this._distance.style.backgroundColor = '#F9F9F9';
            // this._distance2.style.opacity = '0.5';
            this._distance2.style.color = '#353535';
            this._distance2.style.padding = '4px';
            this._distance2.style.position = 'absolute';
            this._distance2.style.transformOrigin = '0 100%';
            this._distance2.innerHTML = 'Hello, world!';
            this._container.appendChild(this._distance2);

            // add dash line
            this._dashline = document.createElement('div');
            this._dashline.setAttribute('class', 'widgets handle dashline');
            this._dashline.style.position = 'absolute';
            this._dashline.style.border = 'none';
            this._dashline.style.borderTop = '2.5px dashed #F9F9F9';
            this._dashline.style.transformOrigin = '0 100%';
            this._dashline.style.height = '1px';
            this._dashline.style.width = '50%';
            this._container.appendChild(this._dashline);

            this.updateDOMColor();
        }
    }, {
        key: 'updateDOMPosition',
        value: function updateDOMPosition() {
            // update rulers lines and text!
            var x1 = this._handles[0].screenPosition.x;
            var y1 = this._handles[0].screenPosition.y;
            var x2 = this._handles[1].screenPosition.x;
            var y2 = this._handles[1].screenPosition.y;

            //let x0 = x1 + (x2 - x1)/2;
            //let y0 = y1 + (y2 - y1)/2;
            var x0 = x2;
            var y0 = y2;

            if (y1 >= y2) {
                y0 = y2 - 30;
            } else {
                y0 = y2 + 30;
            }

            var length = Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));
            var angle = Math.atan2(y2 - y1, x2 - x1) * 180 / Math.PI;

            var posY = y1 - this._container.offsetHeight;

            // update line
            var transform = 'translate3D(' + x1 + 'px,' + posY + 'px, 0)';
            transform += ' rotate(' + angle + 'deg)';

            this._line.style.transform = transform;
            this._line.style.width = length;

            // update distance
            var w0 = this._handles[0].worldPosition;
            var w1 = this._handles[1].worldPosition;

            this._distance.innerHTML = Math.sqrt((w0.x - w1.x) * (w0.x - w1.x) + (w0.y - w1.y) * (w0.y - w1.y) + (w0.z - w1.z) * (w0.z - w1.z)).toFixed(2) + ' mm';
            this._distanceValue = Math.sqrt((w0.x - w1.x) * (w0.x - w1.x) + (w0.y - w1.y) * (w0.y - w1.y) + (w0.z - w1.z) * (w0.z - w1.z)).toFixed(2);
            var posY0 = y0 - this._container.offsetHeight - this._distance.offsetHeight / 2;
            x0 -= this._distance.offsetWidth / 2;

            var transform2 = 'translate3D(' + Math.round(x0) + 'px,' + Math.round(posY0) + 'px, 0)';
            this._distance.style.transform = transform2;

            // update rulers lines 2 and text!
            var x3 = this._handles[2].screenPosition.x;
            var y3 = this._handles[2].screenPosition.y;
            var x4 = this._handles[3].screenPosition.x;
            var y4 = this._handles[3].screenPosition.y;

            //let x0 = x1 + (x2 - x1)/2;
            //let y0 = y1 + (y2 - y1)/2;
            var x02 = x4;
            var y02 = y4;

            if (y3 >= y4) {
                y02 = y4 - 30;
            } else {
                y02 = y4 + 30;
            }

            length = Math.sqrt((x3 - x4) * (x3 - x4) + (y3 - y4) * (y3 - y4));
            angle = Math.atan2(y4 - y3, x4 - x3) * 180 / Math.PI;

            posY = y3 - this._container.offsetHeight;

            // update line
            transform = 'translate3D(' + x3 + 'px,' + posY + 'px, 0)';
            transform += ' rotate(' + angle + 'deg)';

            this._line2.style.transform = transform;
            this._line2.style.width = length;

            // update distance
            var w02 = this._handles[2].worldPosition;
            var w12 = this._handles[3].worldPosition;

            this._distance2.innerHTML = Math.sqrt((w02.x - w12.x) * (w02.x - w12.x) + (w02.y - w12.y) * (w02.y - w12.y) + (w02.z - w12.z) * (w02.z - w12.z)).toFixed(2) + ' mm';
            this._distance2Value = Math.sqrt((w02.x - w12.x) * (w02.x - w12.x) + (w02.y - w12.y) * (w02.y - w12.y) + (w02.z - w12.z) * (w02.z - w12.z)).toFixed(2);
            var posY02 = y02 - this._container.offsetHeight - this._distance2.offsetHeight / 2;
            x02 -= this._distance2.offsetWidth / 2;

            transform2 = 'translate3D(' + Math.round(x02) + 'px,' + Math.round(posY02) + 'px, 0)';
            this._distance2.style.transform = transform2;

            // update dash line

            var l1center = this.getPointInBetweenByPerc(this._handles[0].worldPosition, this._handles[1].worldPosition, 0.5);
            var l2center = this.getPointInBetweenByPerc(this._handles[2].worldPosition, this._handles[3].worldPosition, 0.5);

            var screen1 = this._handles[0].worldToScreen(l1center, this._camera, this._container);
            var screen2 = this._handles[0].worldToScreen(l2center, this._camera, this._container);

            x1 = screen1.x;
            y1 = screen1.y;
            x2 = screen2.x;
            y2 = screen2.y;

            length = Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));
            angle = Math.atan2(y2 - y1, x2 - x1) * 180 / Math.PI;

            posY = y1 - this._container.offsetHeight;

            // update line
            transform = 'translate3D(' + x1 + 'px,' + posY + 'px, 0)';
            transform += ' rotate(' + angle + 'deg)';

            this._dashline.style.transform = transform;
            this._dashline.style.width = length;
        }
    }, {
        key: 'updateDOMColor',
        value: function updateDOMColor() {
            this._line.style.backgroundColor = '' + this._color;
            this._distance.style.borderColor = '' + this._color;

            this._line2.style.backgroundColor = '' + this._color;
            this._distance2.style.borderColor = '' + this._color;
        }
    }, {
        key: 'getPointInBetweenByPerc',
        value: function getPointInBetweenByPerc(pointA, pointB, percentage) {

            var dir = pointB.clone().sub(pointA);
            var len = dir.length();
            dir = dir.normalize().multiplyScalar(len * percentage);
            return pointA.clone().add(dir);
        }
    }, {
        key: 'initOrtho',
        value: function initOrtho() {
            this._initOrtho = true;

            var pcenter = this.getPointInBetweenByPerc(this._handles[0].worldPosition, this._handles[1].worldPosition, 0.5);
            this._handles[2].worldPosition = this.getPointInBetweenByPerc(this._handles[0].worldPosition, this._handles[1].worldPosition, 0.25);
            this._handles[3].worldPosition = this.getPointInBetweenByPerc(this._handles[0].worldPosition, this._handles[1].worldPosition, 0.75);

            this._handles[2].worldPosition.x = pcenter.x - Math.sqrt((pcenter.y - this._handles[2].worldPosition.y) * (pcenter.y - this._handles[2].worldPosition.y));
            this._handles[2].worldPosition.y = pcenter.y + Math.sqrt((pcenter.x - this._handles[2].worldPosition.x) * (pcenter.x - this._handles[2].worldPosition.x));

            this._handles[3].worldPosition.x = pcenter.x + Math.sqrt((pcenter.y - this._handles[2].worldPosition.y) * (pcenter.y - this._handles[2].worldPosition.y));
            this._handles[3].worldPosition.y = pcenter.y - Math.sqrt((pcenter.x - this._handles[2].worldPosition.x) * (pcenter.x - this._handles[2].worldPosition.x));
        }
    }, {
        key: 'worldPosition',
        get: function get() {
            return this._worldPosition;
        },
        set: function set(worldPosition) {
            this._worldPosition = worldPosition;
            this._handles[0].worldPosition = this._worldPosition;
            this._handles[1].worldPosition = this._worldPosition;
            this._handles[2].worldPosition = this._worldPosition;
            this._handles[3].worldPosition = this._worldPosition;

            this.update();
        }
    }, {
        key: 'shotestDistance',
        get: function get() {
            return this._distanceValue < this._distance2Value ? this._distanceValue : this._distance2Value;
        }
    }, {
        key: 'longestDistance',
        get: function get() {
            return this._distanceValue > this._distance2Value ? this._distanceValue : this._distance2Value;
        }
    }]);

    return WidgetsBiRuler;
}(_widgets2.default);

exports.default = WidgetsBiRuler;

},{"../widgets/widgets.base":166,"../widgets/widgets.handle":168}],168:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

var _get = function get(object, property, receiver) {
  if (object === null) object = Function.prototype;var desc = Object.getOwnPropertyDescriptor(object, property);if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);if (parent === null) {
      return undefined;
    } else {
      return get(parent, property, receiver);
    }
  } else if ("value" in desc) {
    return desc.value;
  } else {
    var getter = desc.get;if (getter === undefined) {
      return undefined;
    }return getter.call(receiver);
  }
};

var _widgets = require('../widgets/widgets.base');

var _widgets2 = _interopRequireDefault(_widgets);

var _core = require('../core/core.intersections');

var _core2 = _interopRequireDefault(_core);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

/**
 * @module widgets/handle
 *
 */

var WidgetsHandle = function (_WidgetsBase) {
  _inherits(WidgetsHandle, _WidgetsBase);

  function WidgetsHandle(targetMesh, controls, camera, container) {
    _classCallCheck(this, WidgetsHandle);

    var _this = _possibleConstructorReturn(this, (WidgetsHandle.__proto__ || Object.getPrototypeOf(WidgetsHandle)).call(this, container));

    _this._targetMesh = targetMesh;
    _this._controls = controls;
    _this._camera = camera;

    // if no target mesh, use plane for FREE dragging.
    _this._plane = {
      position: new THREE.Vector3(),
      direction: new THREE.Vector3()
    };
    _this._offset = new THREE.Vector3();
    _this._raycaster = new THREE.Raycaster();

    _this._tracking = false;

    _this._mouse = new THREE.Vector2();
    _this._lastEvent = null;

    // world (LPS) position of this handle
    _this._worldPosition = new THREE.Vector3();

    // screen position of this handle
    _this._screenPosition = new THREE.Vector2();

    // mesh stuff
    _this._material = null;
    _this._geometry = null;
    _this._mesh = null;
    _this._meshDisplayed = true;
    _this._meshHovered = false;
    _this._meshStyle = 'sphere'; // cube, etc.

    // dom stuff
    _this._dom = null;
    _this._domDisplayed = true;
    _this._domHovered = false;
    _this._domStyle = 'circle'; // square, triangle

    if (_this._targetMesh !== null) {
      _this._worldPosition.copy(_this._targetMesh.position);
    }

    _this._screenPosition = _this.worldToScreen(_this._worldPosition, _this._camera, _this._container);

    // create handle
    _this.create();
    _this.initOffsets();

    // event listeners
    _this.onMove = _this.onMove.bind(_this);
    _this.onHover = _this.onHover.bind(_this);
    _this.onEndControl = _this.onEndControl.bind(_this);
    _this.addEventListeners();
    return _this;
  }

  _createClass(WidgetsHandle, [{
    key: 'addEventListeners',
    value: function addEventListeners() {
      this._dom.addEventListener('mouseenter', this.onHover);
      this._dom.addEventListener('mouseleave', this.onHover);

      this._container.addEventListener('mousewheel', this.onMove);
      this._container.addEventListener('DOMMouseScroll', this.onMove);

      this._controls.addEventListener('end', this.onEndControl);
    }
  }, {
    key: 'removeEventListeners',
    value: function removeEventListeners() {
      this._dom.removeEventListener('mouseenter', this.onHover);
      this._dom.removeEventListener('mouseleave', this.onHover);

      this._container.removeEventListener('mousewheel', this.onMove);
      this._container.removeEventListener('DOMMouseScroll', this.onMove);

      this._controls.removeEventListener('end', this.onEndControl);
    }
  }, {
    key: 'create',
    value: function create() {
      this.createMesh();
      this.createDOM();
    }
  }, {
    key: 'onStart',
    value: function onStart(evt) {
      console.log(evt);
      this._lastEvent = evt;
      evt.preventDefault();

      var offsets = this.getMouseOffsets(evt, this._container);
      this._mouse.set(offsets.x, offsets.y);
      console.log(this._mouse);

      // update raycaster
      this._raycaster.setFromCamera(this._mouse, this._camera);
      this._raycaster.ray.position = this._raycaster.ray.origin;

      if (this._hovered) {
        this._active = true;
        this._controls.enabled = false;

        if (this._targetMesh) {
          var intersectsTarget = this._raycaster.intersectObject(this._targetMesh);
          if (intersectsTarget.length > 0) {
            this._offset.copy(intersectsTarget[0].point).sub(this._worldPosition);
          }
        } else {
          this._plane.position.copy(this._worldPosition);
          this._plane.direction.copy(this._camera.getWorldDirection());
          var intersection = _core2.default.rayPlane(this._raycaster.ray, this._plane);
          if (intersection !== null) {
            this._offset.copy(intersection).sub(this._plane.position);
          }
        }

        this.update();
      }
    }
  }, {
    key: 'onEnd',
    value: function onEnd(evt) {
      this._lastEvent = evt;
      evt.preventDefault();

      // stay active and keep controls disabled
      if (this._tracking === true) {
        return;
      }

      // unselect if go up without moving
      if (!this._dragged && this._active) {
        // change state if was not dragging
        this._selected = !this._selected;
      }

      this._active = false;
      this._dragged = false;
      this._controls.enabled = true;

      this.update();
    }
  }, {
    key: 'onEndControl',
    value: function onEndControl() {
      var _this2 = this;

      if (!this._lastEvent) {
        return;
      }

      window.requestAnimationFrame(function () {
        _this2.onMove(_this2._lastEvent);
      });
    }

    /**
     *
     *
     */

  }, {
    key: 'onMove',
    value: function onMove(evt) {
      this._lastEvent = evt;
      evt.preventDefault();

      var offsets = this.getMouseOffsets(evt, this._container);
      this._mouse.set(offsets.x, offsets.y);

      // update raycaster
      // set ray.position to satisfy CoreIntersections::rayPlane API
      this._raycaster.setFromCamera(this._mouse, this._camera);
      this._raycaster.ray.position = this._raycaster.ray.origin;

      if (this._active) {
        this._dragged = true;

        if (this._targetMesh !== null) {
          var intersectsTarget = this._raycaster.intersectObject(this._targetMesh);
          if (intersectsTarget.length > 0) {
            this._worldPosition.copy(intersectsTarget[0].point.sub(this._offset));
          }
        } else {
          if (this._plane.direction.length() === 0) {
            // free mode!this._targetMesh
            this._plane.position.copy(this._worldPosition);
            this._plane.direction.copy(this._camera.getWorldDirection());
          }

          var intersection = _core2.default.rayPlane(this._raycaster.ray, this._plane);
          if (intersection !== null) {
            this._worldPosition.copy(intersection.sub(this._offset));
          }
        }
      } else {
        this.onHover(null);
      }

      this.update();
    }
  }, {
    key: 'onHover',
    value: function onHover(evt) {
      if (evt) {
        this._lastEvent = evt;
        evt.preventDefault();
        this.hoverDom(evt);
      }

      this.hoverMesh();

      this._hovered = this._meshHovered || this._domHovered;
      this._container.style.cursor = this._hovered ? 'pointer' : 'default';
    }
  }, {
    key: 'update',
    value: function update() {
      // general update
      this.updateColor();

      // update screen position of handle
      this._screenPosition = this.worldToScreen(this._worldPosition, this._camera, this._container);

      // mesh stuff
      this.updateMeshColor();
      this.updateMeshPosition();

      // DOM stuff
      this.updateDOMColor();
      this.updateDOMPosition();
    }

    //

  }, {
    key: 'updateMeshColor',
    value: function updateMeshColor() {
      if (this._material) {
        this._material.color.set(this._color);
      }
    }
  }, {
    key: 'updateMeshPosition',
    value: function updateMeshPosition() {
      if (this._mesh) {
        this._mesh.position.x = this._worldPosition.x;
        this._mesh.position.y = this._worldPosition.y;
        this._mesh.position.z = this._worldPosition.z;
      }
    }
  }, {
    key: 'hoverMesh',
    value: function hoverMesh() {
      // check raycast intersection, do we want to hover on mesh or just css?
      var intersectsHandle = this._raycaster.intersectObject(this._mesh);
      this._meshHovered = intersectsHandle.length > 0;
    }
  }, {
    key: 'hoverDom',
    value: function hoverDom(evt) {
      this._domHovered = evt.type === 'mouseenter';
    }
  }, {
    key: 'worldToScreen',
    value: function worldToScreen(worldCoordinate, camera, canvas) {
      var screenCoordinates = worldCoordinate.clone();
      screenCoordinates.project(camera);

      screenCoordinates.x = Math.round((screenCoordinates.x + 1) * canvas.offsetWidth / 2);
      screenCoordinates.y = Math.round((-screenCoordinates.y + 1) * canvas.offsetHeight / 2);
      screenCoordinates.z = 0;

      return screenCoordinates;
    }
  }, {
    key: 'createMesh',
    value: function createMesh() {
      // geometry
      this._geometry = new THREE.SphereGeometry(1, 16, 16);

      // material
      this._material = new THREE.MeshBasicMaterial({
        wireframe: true,
        wireframeLinewidth: 2
      });

      // mesh
      this._mesh = new THREE.Mesh(this._geometry, this._material);
      this._mesh.position.x = this._worldPosition.x;
      this._mesh.position.y = this._worldPosition.y;
      this._mesh.position.z = this._worldPosition.z;
      this._mesh.visible = true;

      this.updateMeshColor();

      // add it!
      this.add(this._mesh);
    }
  }, {
    key: 'createDOM',
    value: function createDOM() {
      // dom
      this._dom = document.createElement('div');
      this._dom.setAttribute('id', this.uuid);
      this._dom.setAttribute('class', 'AMI Widget Handle');
      this._dom.style.border = '2px solid';
      this._dom.style.backgroundColor = '#F9F9F9';
      this._dom.style.color = '#F9F9F9';
      this._dom.style.position = 'absolute';
      this._dom.style.width = '12px';
      this._dom.style.height = '12px';
      this._dom.style.margin = '-6px';
      this._dom.style.borderRadius = '50%';
      this._dom.style.transformOrigin = '0 100%';

      var posY = this._screenPosition.y - this._container.offsetHeight;
      this._dom.style.transform = 'translate3D(' + this._screenPosition.x + 'px, ' + posY + 'px, 0)';

      this.updateDOMColor();

      // add it!
      this._container.appendChild(this._dom);
    }
  }, {
    key: 'updateDOMPosition',
    value: function updateDOMPosition() {
      if (this._dom) {
        var posY = this._screenPosition.y - this._container.offsetHeight;
        this._dom.style.transform = 'translate3D(' + this._screenPosition.x + 'px, ' + posY + 'px, 0)';
      }
    }
  }, {
    key: 'updateDOMColor',
    value: function updateDOMColor() {
      this._dom.style.borderColor = '' + this._color;
    }
  }, {
    key: 'free',
    value: function free() {
      // threejs stuff

      // dom
      this._container.removeChild(this._dom);
      // event
      this.removeEventListeners();

      _get(WidgetsHandle.prototype.__proto__ || Object.getPrototypeOf(WidgetsHandle.prototype), 'free', this).call(this);
    }
  }, {
    key: 'hideDOM',
    value: function hideDOM() {
      this._dom.style.display = 'none';
    }
  }, {
    key: 'showDOM',
    value: function showDOM() {
      this._dom.style.display = '';
    }
  }, {
    key: 'hideMesh',
    value: function hideMesh() {
      this.visible = false;
    }
  }, {
    key: 'showMesh',
    value: function showMesh() {
      this.visible = true;
    }
  }, {
    key: 'show',
    value: function show() {
      this.showDOM();
      this.showMesh();
    }
  }, {
    key: 'hide',
    value: function hide() {
      this.hideDOM();
      this.hideMesh();
    }
  }, {
    key: 'worldPosition',
    set: function set(worldPosition) {
      this._worldPosition.copy(worldPosition);

      this.update();
    },
    get: function get() {
      return this._worldPosition;
    }
  }, {
    key: 'screenPosition',
    set: function set(screenPosition) {
      this._screenPosition = screenPosition;
    },
    get: function get() {
      return this._screenPosition;
    }
  }, {
    key: 'active',
    get: function get() {
      return this._active;
    },
    set: function set(active) {
      this._active = active;
      // this._tracking = this._active;
      this._controls.enabled = !this._active;

      this.update();
    }
  }, {
    key: 'tracking',
    get: function get() {
      return this._tracking;
    },
    set: function set(tracking) {
      this._tracking = tracking;
      this.update();
    }
  }]);

  return WidgetsHandle;
}(_widgets2.default);

exports.default = WidgetsHandle;

},{"../core/core.intersections":102,"../widgets/widgets.base":166}],169:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _widgets = require('./widgets.annotation');

var _widgets2 = _interopRequireDefault(_widgets);

var _widgets3 = require('./widgets.biruler');

var _widgets4 = _interopRequireDefault(_widgets3);

var _widgets5 = require('./widgets.handle');

var _widgets6 = _interopRequireDefault(_widgets5);

var _widgets7 = require('./widgets.roi');

var _widgets8 = _interopRequireDefault(_widgets7);

var _widgets9 = require('./widgets.ruler');

var _widgets10 = _interopRequireDefault(_widgets9);

var _widgets11 = require('./widgets.voxelProbe');

var _widgets12 = _interopRequireDefault(_widgets11);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

/**
 * @module widgets
 */

exports.default = {
  Annotation: _widgets2.default,
  BiRuler: _widgets4.default,
  Handle: _widgets6.default,
  Roi: _widgets8.default,
  Ruler: _widgets10.default,
  VoxelProbe: _widgets12.default
};

},{"./widgets.annotation":165,"./widgets.biruler":167,"./widgets.handle":168,"./widgets.roi":170,"./widgets.ruler":171,"./widgets.voxelProbe":172}],170:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () {
    function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
        }
    }return function (Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
}();

var _widgets = require('../widgets/widgets.base');

var _widgets2 = _interopRequireDefault(_widgets);

var _widgets3 = require('../widgets/widgets.handle');

var _widgets4 = _interopRequireDefault(_widgets3);

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
}

function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}

function _possibleConstructorReturn(self, call) {
    if (!self) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

/**
 * @module widgets/handle
 *
 */

var WidgetsRoi = function (_WidgetsBase) {
    _inherits(WidgetsRoi, _WidgetsBase);

    function WidgetsRoi(targetMesh, controls, camera, container) {
        _classCallCheck(this, WidgetsRoi);

        var _this = _possibleConstructorReturn(this, (WidgetsRoi.__proto__ || Object.getPrototypeOf(WidgetsRoi)).call(this));

        _this._targetMesh = targetMesh;
        _this._controls = controls;
        _this._camera = camera;
        _this._container = container;

        _this._active = true;
        _this._init = false;

        _this._worldPosition = new THREE.Vector3();
        if (_this._targetMesh !== null) {
            _this._worldPosition = _this._targetMesh.position;
        }

        // mesh stuff
        _this._material = null;
        _this._geometry = null;
        _this._mesh = null;

        // dom stuff
        _this._lines = [];
        _this._area = null;

        // add handles
        _this._handles = [];

        // first handle
        var firstHandle = new _widgets4.default(_this._targetMesh, _this._controls, _this._camera, _this._container);
        firstHandle.worldPosition = _this._worldPosition;
        firstHandle.hovered = true;
        _this.add(firstHandle);

        _this._handles.push(firstHandle);

        // Create ruler
        _this.create();

        _this.onMove = _this.onMove.bind(_this);
        _this.addEventListeners();

        _this._orientation = null;
        _this._slice = null;
        return _this;
    }

    _createClass(WidgetsRoi, [{
        key: 'addEventListeners',
        value: function addEventListeners() {
            this._container.addEventListener('mousewheel', this.onMove);
            this._container.addEventListener('DOMMouseScroll', this.onMove);
        }
    }, {
        key: 'onMove',
        value: function onMove(evt) {
            this._dragged = true;
            var numHandles = this._handles.length;

            if (this.active && !this._init) {
                var lastHandle = this._handles[numHandles - 1];
                lastHandle.hovered = false;
                lastHandle.active = false;
                lastHandle.tracking = false;

                var nextHandle = new _widgets4.default(this._targetMesh, this._controls, this._camera, this._container);
                nextHandle.worldPosition = this._worldPosition;
                nextHandle.hovered = true;
                nextHandle.active = true;
                nextHandle.tracking = true;
                this.add(nextHandle);

                this._handles.push(nextHandle);

                var newLine = document.createElement('div');
                newLine.setAttribute('class', 'widgets handle line');
                newLine.style.position = 'absolute';
                newLine.style.transformOrigin = '0 100%';
                newLine.style.marginTop = '-1px';
                newLine.style.height = '2px';
                newLine.style.width = '3px';
                newLine.style.backgroundColor = '#F9F9F9';

                this._lines.push(newLine);
                this._container.appendChild(newLine);
            }

            var hovered = false;

            for (var index in this._handles) {
                this._handles[index].onMove(evt);
                hovered = hovered || this._handles[index].hovered;
            }

            this._hovered = hovered;

            if (this.active && numHandles > 2) {
                this.pushPopHandle();
            }

            this.update();
        }
    }, {
        key: 'onStart',
        value: function onStart(evt) {
            this._dragged = false;

            var active = false;

            for (var index in this._handles) {
                this._handles[index].onStart(evt);
                active = active || this._handles[index].active;
            }

            this._active = active;
            this.update();
        }
    }, {
        key: 'onEnd',
        value: function onEnd(evt) {
            // First Handle
            var active = false;
            for (var index in this._handles.slice(0, this._handles.length - 2)) {
                this._handles[index].onEnd(evt);
                active = active || this._handles[index].active;
            }

            // Second Handle
            if (this._dragged || !this._handles[this._handles.length - 1].tracking) {
                this._handles[this._handles.length - 1].tracking = false;
                this._handles[this._handles.length - 1].onEnd(evt);
            } else {
                this._handles[this._handles.length - 1].tracking = false;
            }

            active = active || this._handles[this._handles.length - 1].active;
            // State of ruler widget
            this._active = active;

            var newLine = document.createElement('div');
            newLine.setAttribute('class', 'widgets handle line');
            newLine.style.position = 'absolute';
            newLine.style.transformOrigin = '0 100%';
            newLine.style.marginTop = '-1px';
            newLine.style.height = '2px';
            newLine.style.width = '3px';
            newLine.style.backgroundColor = '#F9F9F9';

            this._lines.push(newLine);
            this._container.appendChild(newLine);

            this._init = true;
            this.update();
        }
    }, {
        key: 'create',
        value: function create() {
            this.createMesh();
            this.createDOM();
        }
    }, {
        key: 'hideDOM',
        value: function hideDOM() {
            for (var index in this._handles) {
                this._handles[index].hideDOM();
            }

            for (var _index in this._lines) {
                this._lines[_index].style.display = 'none';
            }
        }
    }, {
        key: 'showDOM',
        value: function showDOM() {
            for (var index in this._handles) {
                this._handles[index].showDOM();
            }

            for (var _index2 in this._lines) {
                this._lines[_index2].style.display = '';
            }
        }
    }, {
        key: 'hideMesh',
        value: function hideMesh() {
            this.visible = false;
        }
    }, {
        key: 'showMesh',
        value: function showMesh() {
            this.visible = true;
        }
    }, {
        key: 'show',
        value: function show() {
            this.showDOM();
            this.showMesh();
        }
    }, {
        key: 'hide',
        value: function hide() {
            this.hideDOM();
            this.hideMesh();
        }
    }, {
        key: 'update',
        value: function update() {
            this.updateColor();

            for (var index in this._handles) {
                this._handles[index].update();
            }

            // mesh stuff
            this.updateMeshColor();
            this.updateMeshPosition();

            // DOM stuff
            this.updateDOMPosition();
            this.updateDOMColor();
        }
    }, {
        key: 'createMesh',
        value: function createMesh() {
            // geometry
            this._geometry = new THREE.Geometry();
            for (var index in this._handles) {
                this._geometry.vertices.push(this._handles[index].worldPosition);
            }

            // material
            this._material = new THREE.LineBasicMaterial();
            this.updateMeshColor();

            // mesh
            this._mesh = new THREE.Line(this._geometry, this._material);
            this._mesh.visible = true;

            // add it!
            this.add(this._mesh);
        }
    }, {
        key: 'updateMeshColor',
        value: function updateMeshColor() {
            if (this._material) {
                this._material.color.set(this._color);
            }
        }
    }, {
        key: 'updateMeshPosition',
        value: function updateMeshPosition() {
            if (this._geometry) {
                this._geometry.verticesNeedUpdate = true;
            }
        }
    }, {
        key: 'createDOM',
        value: function createDOM() {
            // add line!
            this._line = document.createElement('div');
            this._line.setAttribute('class', 'widgets handle line');
            this._line.style.position = 'absolute';
            this._line.style.transformOrigin = '0 100%';
            this._line.style.marginTop = '-1px';
            this._line.style.height = '2px';
            this._line.style.width = '3px';
            this._container.appendChild(this._line);

            // add distance!
            this._distance = document.createElement('div');
            this._distance.setAttribute('class', 'widgets handle distance');
            this._distance.style.border = '2px solid';
            this._distance.style.backgroundColor = '#F9F9F9';
            // this._distance.style.opacity = '0.5';
            this._distance.style.color = '#353535';
            this._distance.style.padding = '4px';
            this._distance.style.position = 'absolute';
            this._distance.style.transformOrigin = '0 100%';
            this._distance.innerHTML = 'Hello, world!';
            this._container.appendChild(this._distance);

            this.updateDOMColor();
        }
    }, {
        key: 'isPointOnLine',
        value: function isPointOnLine(pointA, pointB, pointToCheck) {
            var c = new THREE.Vector3();
            c.crossVectors(pointA.clone().sub(pointToCheck), pointB.clone().sub(pointToCheck));
            return !c.length();
        }
    }, {
        key: 'pushPopHandle',
        value: function pushPopHandle() {
            var handle0 = this._handles[this._handles.length - 3];
            var handle1 = this._handles[this._handles.length - 2];
            var newhandle = this._handles[this._handles.length - 1];

            var isOnLine = this.isPointOnLine(handle0.worldPosition, handle1.worldPosition, newhandle.worldPosition);

            if (isOnLine) {
                handle1._dom.style.display = 'none';
                this.remove(handle1);

                this._handles[this._handles.length - 2] = newhandle;
                this._handles.pop();

                var tempLine = this._lines.pop();
                tempLine.style.display = 'none';
                this._container.removeChild(tempLine);
            }

            return isOnLine;
        }
    }, {
        key: 'updateLineDOM',
        value: function updateLineDOM(lineIndex, handle0Index, handle1Index) {
            // update rulers lines and text!
            var x1 = this._handles[handle0Index].screenPosition.x;
            var y1 = this._handles[handle0Index].screenPosition.y;
            var x2 = this._handles[handle1Index].screenPosition.x;
            var y2 = this._handles[handle1Index].screenPosition.y;

            var x0 = x2;
            var y0 = y2;

            if (y1 >= y2) {
                y0 = y2 - 30;
            } else {
                y0 = y2 + 30;
            }

            var length = Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));
            var angle = Math.atan2(y2 - y1, x2 - x1) * 180 / Math.PI;

            var posY = y1 - this._container.offsetHeight;

            // update line
            var transform = 'translate3D(' + x1 + 'px, ' + posY + 'px, 0)';
            transform += ' rotate(' + angle + 'deg)';

            //this._lines[lineIndex].style.display = '';
            this._lines[lineIndex].style.transform = transform;
            this._lines[lineIndex].style.width = length;
        }
    }, {
        key: 'updateDOMPosition',
        value: function updateDOMPosition() {
            if (this._handles.length >= 2) {
                for (var index in this._lines) {
                    this.updateLineDOM(index, index, parseInt(index) + 1 == this._handles.length ? 0 : parseInt(index) + 1);
                }
            }
        }
    }, {
        key: 'updateDOMColor',
        value: function updateDOMColor() {
            this._line.style.backgroundColor = '' + this._color;
            this._distance.style.borderColor = '' + this._color;
        }
    }, {
        key: 'getPointInBetweenByPerc',
        value: function getPointInBetweenByPerc(pointA, pointB, percentage) {

            var dir = pointB.clone().sub(pointA);
            var len = dir.length();
            dir = dir.normalize().multiplyScalar(len * percentage);
            return pointA.clone().add(dir);
        }
    }, {
        key: 'worldPosition',
        get: function get() {
            return this._worldPosition;
        },
        set: function set(worldPosition) {
            this._worldPosition = worldPosition;

            for (var index in this._handles) {
                this._handles[index]._worldPosition = this._worldPosition;
            }

            this.update();
        }
    }]);

    return WidgetsRoi;
}(_widgets2.default);

exports.default = WidgetsRoi;

},{"../widgets/widgets.base":166,"../widgets/widgets.handle":168}],171:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

var _get = function get(object, property, receiver) {
  if (object === null) object = Function.prototype;var desc = Object.getOwnPropertyDescriptor(object, property);if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);if (parent === null) {
      return undefined;
    } else {
      return get(parent, property, receiver);
    }
  } else if ("value" in desc) {
    return desc.value;
  } else {
    var getter = desc.get;if (getter === undefined) {
      return undefined;
    }return getter.call(receiver);
  }
};

var _widgets = require('../widgets/widgets.base');

var _widgets2 = _interopRequireDefault(_widgets);

var _widgets3 = require('../widgets/widgets.handle');

var _widgets4 = _interopRequireDefault(_widgets3);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

/**
 * @module widgets/handle
 *
 */

var WidgetsRuler = function (_WidgetsBase) {
  _inherits(WidgetsRuler, _WidgetsBase);

  function WidgetsRuler(targetMesh, controls, camera, container) {
    _classCallCheck(this, WidgetsRuler);

    var _this = _possibleConstructorReturn(this, (WidgetsRuler.__proto__ || Object.getPrototypeOf(WidgetsRuler)).call(this, container));

    _this._targetMesh = targetMesh;
    _this._controls = controls;
    _this._camera = camera;

    _this._active = true;
    _this._lastEvent = null;

    _this._worldPosition = new THREE.Vector3();
    if (_this._targetMesh !== null) {
      _this._worldPosition = _this._targetMesh.position;
    }

    // mesh stuff
    _this._material = null;
    _this._geometry = null;
    _this._mesh = null;

    // dom stuff
    _this._line = null;
    _this._distance = null;

    // add handles
    _this._handles = [];

    // first handle
    var firstHandle = new _widgets4.default(_this._targetMesh, _this._controls, _this._camera, _this._container);
    firstHandle.worldPosition = _this._worldPosition;
    firstHandle.hovered = true;
    _this.add(firstHandle);

    _this._handles.push(firstHandle);

    var secondHandle = new _widgets4.default(_this._targetMesh, _this._controls, _this._camera, _this._container);
    secondHandle.worldPosition = _this._worldPosition;
    secondHandle.hovered = true;
    // active and tracking might be redundant
    secondHandle.active = true;
    secondHandle.tracking = true;
    _this.add(secondHandle);

    _this._handles.push(secondHandle);

    // Create ruler
    _this.create();
    _this.initOffsets();

    _this.onMove = _this.onMove.bind(_this);
    _this.onEndControl = _this.onEndControl.bind(_this);
    _this.addEventListeners();
    return _this;
  }

  _createClass(WidgetsRuler, [{
    key: 'addEventListeners',
    value: function addEventListeners() {
      this._container.addEventListener('mousewheel', this.onMove);
      this._container.addEventListener('DOMMouseScroll', this.onMove);

      this._controls.addEventListener('end', this.onEndControl);
    }
  }, {
    key: 'removeEventListeners',
    value: function removeEventListeners() {
      this._container.removeEventListener('mousewheel', this.onMove);
      this._container.removeEventListener('DOMMouseScroll', this.onMove);

      this._controls.removeEventListener('end', this.onEndControl);
    }
  }, {
    key: 'onMove',
    value: function onMove(evt) {
      this._lastEvent = evt;
      this._dragged = true;

      this._handles[0].onMove(evt);
      this._handles[1].onMove(evt);

      this._hovered = this._handles[0].hovered || this._handles[1].hovered;
      this.update();
    }
  }, {
    key: 'onStart',
    value: function onStart(evt) {
      this._lastEvent = evt;
      this._dragged = false;

      this._handles[0].onStart(evt);
      this._handles[1].onStart(evt);

      this._active = this._handles[0].active || this._handles[1].active;
      this.update();
    }
  }, {
    key: 'onEnd',
    value: function onEnd(evt) {
      this._lastEvent = evt;
      // First Handle
      this._handles[0].onEnd(evt);

      // window.console.log(this);

      // Second Handle
      if (this._dragged || !this._handles[1].tracking) {
        this._handles[1].tracking = false;
        this._handles[1].onEnd(evt);
      } else {
        this._handles[1].tracking = false;
      }

      // State of ruler widget
      this._active = this._handles[0].active || this._handles[1].active;
      this.update();
    }
  }, {
    key: 'onEndControl',
    value: function onEndControl() {
      var _this2 = this;

      if (!this._lastEvent) {
        return;
      }

      window.requestAnimationFrame(function () {
        _this2.onMove(_this2._lastEvent);
      });
    }
  }, {
    key: 'create',
    value: function create() {
      this.createMesh();
      this.createDOM();
    }
  }, {
    key: 'hideDOM',
    value: function hideDOM() {
      this._line.style.display = 'none';
      this._distance.style.display = 'none';
      for (var index in this._handles) {
        this._handles[index].hideDOM();
      }
    }
  }, {
    key: 'showDOM',
    value: function showDOM() {
      this._line.style.display = '';
      this._distance.style.display = '';
      for (var index in this._handles) {
        this._handles[index].showDOM();
      }
    }
  }, {
    key: 'hideMesh',
    value: function hideMesh() {
      this.visible = false;
    }
  }, {
    key: 'showMesh',
    value: function showMesh() {
      this.visible = true;
    }
  }, {
    key: 'show',
    value: function show() {
      this.showDOM();
      this.showMesh();
    }
  }, {
    key: 'hide',
    value: function hide() {
      this.hideDOM();
      this.hideMesh();
    }
  }, {
    key: 'update',
    value: function update() {
      this.updateColor();

      // update handles
      this._handles[0].update();
      this._handles[1].update();

      // mesh stuff
      this.updateMeshColor();
      this.updateMeshPosition();

      // DOM stuff
      this.updateDOMColor();
      this.updateDOMPosition();
    }
  }, {
    key: 'createMesh',
    value: function createMesh() {
      // geometry
      this._geometry = new THREE.Geometry();
      this._geometry.vertices.push(this._handles[0].worldPosition);
      this._geometry.vertices.push(this._handles[1].worldPosition);

      // material
      this._material = new THREE.LineBasicMaterial();
      this.updateMeshColor();

      // mesh
      this._mesh = new THREE.Line(this._geometry, this._material);
      this._mesh.visible = true;

      // add it!
      this.add(this._mesh);
    }
  }, {
    key: 'updateMeshColor',
    value: function updateMeshColor() {
      if (this._material) {
        this._material.color.set(this._color);
      }
    }
  }, {
    key: 'updateMeshPosition',
    value: function updateMeshPosition() {
      if (this._geometry) {
        this._geometry.verticesNeedUpdate = true;
      }
    }
  }, {
    key: 'createDOM',
    value: function createDOM() {
      // add line!
      this._line = document.createElement('div');
      this._line.setAttribute('id', this.uuid);
      this._line.setAttribute('class', 'AMI Widget Ruler');
      this._line.style.position = 'absolute';
      this._line.style.transformOrigin = '0 100%';
      this._line.style.marginTop = '-1px';
      this._line.style.height = '2px';
      this._line.style.width = '3px';
      this._container.appendChild(this._line);

      // add distance!
      this._distance = document.createElement('div');
      this._distance.setAttribute('class', 'widgets handle distance');
      this._distance.style.border = '2px solid';
      this._distance.style.backgroundColor = '#F9F9F9';
      // this._distance.style.opacity = '0.5';
      this._distance.style.color = '#353535';
      this._distance.style.padding = '4px';
      this._distance.style.position = 'absolute';
      this._distance.style.transformOrigin = '0 100%';
      this._distance.innerHTML = 'Hello, world!';
      this._container.appendChild(this._distance);

      this.updateDOMColor();
    }
  }, {
    key: 'updateDOMPosition',
    value: function updateDOMPosition() {
      // update rulers lines and text!
      var x1 = this._handles[0].screenPosition.x;
      var y1 = this._handles[0].screenPosition.y;
      var x2 = this._handles[1].screenPosition.x;
      var y2 = this._handles[1].screenPosition.y;

      //let x0 = x1 + (x2 - x1)/2;
      //let y0 = y1 + (y2 - y1)/2;
      var x0 = x2;
      var y0 = y2;

      if (y1 >= y2) {
        y0 = y2 - 30;
      } else {
        y0 = y2 + 30;
      }

      var length = Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));
      var angle = Math.atan2(y2 - y1, x2 - x1) * 180 / Math.PI;

      var posY = y1 - this._container.offsetHeight;

      // update line
      var transform = 'translate3D(' + x1 + 'px,' + posY + 'px, 0)';
      transform += ' rotate(' + angle + 'deg)';

      this._line.style.transform = transform;
      this._line.style.width = length;

      // update distance
      var w0 = this._handles[0].worldPosition;
      var w1 = this._handles[1].worldPosition;

      this._distance.innerHTML = Math.sqrt((w0.x - w1.x) * (w0.x - w1.x) + (w0.y - w1.y) * (w0.y - w1.y) + (w0.z - w1.z) * (w0.z - w1.z)).toFixed(2) + ' mm';
      var posY0 = y0 - this._container.offsetHeight - this._distance.offsetHeight / 2;
      x0 -= this._distance.offsetWidth / 2;

      var transform2 = 'translate3D(' + Math.round(x0) + 'px,' + Math.round(posY0) + 'px, 0)';
      this._distance.style.transform = transform2;
    }
  }, {
    key: 'updateDOMColor',
    value: function updateDOMColor() {
      this._line.style.backgroundColor = '' + this._color;
      this._distance.style.borderColor = '' + this._color;
    }
  }, {
    key: 'free',
    value: function free() {
      this._container.removeEventListener('mousewheel', this.onMove);
      this._container.removeEventListener('DOMMouseScroll', this.onMove);

      this._handles.forEach(function (h) {
        h.free();
      });

      this._handles = [];

      this._container.removeChild(this._line);
      this._container.removeChild(this._distance);

      this.remove(this._mesh);

      _get(WidgetsRuler.prototype.__proto__ || Object.getPrototypeOf(WidgetsRuler.prototype), 'free', this).call(this);
    }
  }, {
    key: 'worldPosition',
    get: function get() {
      return this._worldPosition;
    },
    set: function set(worldPosition) {
      this._worldPosition = worldPosition;
      this._handles[0].worldPosition = this._worldPosition;
      this._handles[1].worldPosition = this._worldPosition;

      this.update();
    }
  }]);

  return WidgetsRuler;
}(_widgets2.default);

exports.default = WidgetsRuler;

},{"../widgets/widgets.base":166,"../widgets/widgets.handle":168}],172:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

var _get = function get(object, property, receiver) {
  if (object === null) object = Function.prototype;var desc = Object.getOwnPropertyDescriptor(object, property);if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);if (parent === null) {
      return undefined;
    } else {
      return get(parent, property, receiver);
    }
  } else if ("value" in desc) {
    return desc.value;
  } else {
    var getter = desc.get;if (getter === undefined) {
      return undefined;
    }return getter.call(receiver);
  }
};

var _widgets = require('../widgets/widgets.base');

var _widgets2 = _interopRequireDefault(_widgets);

var _geometries = require('../geometries/geometries.voxel');

var _geometries2 = _interopRequireDefault(_geometries);

var _models = require('../models/models.stack');

var _models2 = _interopRequireDefault(_models);

var _models3 = require('../models/models.voxel');

var _models4 = _interopRequireDefault(_models3);

var _core = require('../core/core.intersections');

var _core2 = _interopRequireDefault(_core);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

/**
 * @module widgets/voxelProbe
 */

var WidgetsVoxelProbe = function (_WidgetsBase) {
  _inherits(WidgetsVoxelProbe, _WidgetsBase);

  function WidgetsVoxelProbe(stack, targetMesh, controls, camera, container) {
    _classCallCheck(this, WidgetsVoxelProbe);

    var _this = _possibleConstructorReturn(this, (WidgetsVoxelProbe.__proto__ || Object.getPrototypeOf(WidgetsVoxelProbe)).call(this, container));

    _this._stack = stack;

    _this._targetMesh = targetMesh;
    _this._controls = controls;
    _this._camera = camera;

    // if no target mesh, use plane for FREE dragging.
    _this._plane = {
      position: new THREE.Vector3(),
      direction: new THREE.Vector3()
    };

    _this._offset = new THREE.Vector3();
    _this._raycaster = new THREE.Raycaster();

    _this._tracking = false;

    _this._mouse = new THREE.Vector2();
    _this._lastEvent = null;

    // world (LPS) position of the center
    _this._worldPosition = new THREE.Vector3();

    // screen position of the center
    _this._screenPosition = new THREE.Vector2();

    // mesh stuff
    _this._material = null;
    _this._geometry = null;
    _this._mesh = null;
    _this._meshDisplayed = true;
    _this._meshHovered = false;
    _this._meshStyle = 'sphere'; // cube, etc.

    // dom stuff
    _this._dom = null;
    _this._domDisplayed = true;
    _this._domHovered = false;
    _this._domStyle = 'circle'; // square, triangle

    if (_this._targetMesh !== null) {
      _this._worldPosition.copy(_this._targetMesh.position);
    }

    _this._screenPosition = _this.worldToScreen(_this._worldPosition, _this._camera, _this._container);

    // create handle
    _this.create();
    _this.initOffsets();

    // event listeners
    _this.onMove = _this.onMove.bind(_this);
    _this.onHover = _this.onHover.bind(_this);
    _this.onEndControl = _this.onEndControl.bind(_this);
    _this.addEventListeners();
    return _this;
  }

  _createClass(WidgetsVoxelProbe, [{
    key: 'addEventListeners',
    value: function addEventListeners() {
      this._dom.addEventListener('mouseenter', this.onHover);
      this._dom.addEventListener('mouseleave', this.onHover);

      this._container.addEventListener('mousewheel', this.onMove);
      this._container.addEventListener('DOMMouseScroll', this.onMove);

      this._controls.addEventListener('end', this.onEndControl);
    }
  }, {
    key: 'removeEventListeners',
    value: function removeEventListeners() {
      this._dom.removeEventListener('mouseenter', this.onHover);
      this._dom.removeEventListener('mouseleave', this.onHover);

      this._container.removeEventListener('mousewheel', this.onMove);
      this._container.removeEventListener('DOMMouseScroll', this.onMove);

      this._controls.removeEventListener('end', this.onEndControl);
    }
  }, {
    key: 'onStart',
    value: function onStart(evt) {
      this._lastEvent = evt;
      evt.preventDefault();

      var offsets = this.getMouseOffsets(evt, this._container);
      this._mouse.set(offsets.x, offsets.y);

      // update raycaster
      this._raycaster.setFromCamera(this._mouse, this._camera);
      this._raycaster.ray.position = this._raycaster.ray.origin;

      if (this._hovered) {
        this._active = true;
        this._controls.enabled = false;

        if (this._targetMesh) {
          var intersectsTarget = this._raycaster.intersectObject(this._targetMesh);
          if (intersectsTarget.length > 0) {
            this._offset.copy(intersectsTarget[0].point).sub(this._worldPosition);
          }
        } else {
          this._plane.position.copy(this._worldPosition);
          this._plane.direction.copy(this._camera.getWorldDirection());
          var intersection = _core2.default.rayPlane(this._raycaster.ray, this._plane);
          if (intersection !== null) {
            this._offset.copy(intersection).sub(this._plane.position);
          }
        }

        this.update();
      }
    }
  }, {
    key: 'onEnd',
    value: function onEnd(evt) {
      this._lastEvent = evt;
      evt.preventDefault();

      // stay active and keep controls disabled
      if (this._tracking === true) {
        return;
      }

      // unselect if go up without moving
      if (!this._dragged && this._active) {
        // change state if was not dragging
        this._selected = !this._selected;
      }

      this._active = false;
      this._dragged = false;
      this._controls.enabled = true;

      this.update();
    }
  }, {
    key: 'onEndControl',
    value: function onEndControl() {
      var _this2 = this;

      if (!this._lastEvent) {
        return;
      }

      window.requestAnimationFrame(function () {
        _this2.onMove(_this2._lastEvent);
      });
    }
  }, {
    key: 'onMove',
    value: function onMove(evt) {
      this._lastEvent = evt;
      evt.preventDefault();

      var offsets = this.getMouseOffsets(evt, this._container);
      this._mouse.set(offsets.x, offsets.y);

      // update raycaster
      // set ray.position to satisfy CoreIntersections::rayPlane API
      this._raycaster.setFromCamera(this._mouse, this._camera);
      this._raycaster.ray.position = this._raycaster.ray.origin;

      if (this._active) {
        this._dragged = true;

        if (this._targetMesh !== null) {
          var intersectsTarget = this._raycaster.intersectObject(this._targetMesh);
          if (intersectsTarget.length > 0) {
            this._worldPosition.copy(intersectsTarget[0].point.sub(this._offset));
          }
        } else {
          if (this._plane.direction.length() === 0) {
            // free mode!this._targetMesh
            this._plane.position.copy(this._worldPosition);
            this._plane.direction.copy(this._camera.getWorldDirection());
          }

          var intersection = _core2.default.rayPlane(this._raycaster.ray, this._plane);
          if (intersection !== null) {
            this._worldPosition.copy(intersection.sub(this._offset));
          }
        }
      } else {
        this.onHover(null);
      }

      this.update();
    }
  }, {
    key: 'onHover',
    value: function onHover(evt) {
      if (evt) {
        this._lastEvent = evt;
        evt.preventDefault();
        this.hoverDom(evt);
      }

      this.hoverMesh();

      this._hovered = this._meshHovered || this._domHovered;
      this._container.style.cursor = this._hovered ? 'pointer' : 'default';
    }
  }, {
    key: 'hoverMesh',
    value: function hoverMesh() {
      // check raycast intersection, do we want to hover on mesh or just css?
      var intersectsHandle = this._raycaster.intersectObject(this._mesh);
      this._meshHovered = intersectsHandle.length > 0;
    }
  }, {
    key: 'hoverDom',
    value: function hoverDom(evt) {
      this._domHovered = evt.type === 'mouseenter';
    }
  }, {
    key: 'worldToScreen',
    value: function worldToScreen(worldCoordinate, camera, canvas) {
      var screenCoordinates = worldCoordinate.clone();
      screenCoordinates.project(camera);

      screenCoordinates.x = Math.round((screenCoordinates.x + 1) * canvas.offsetWidth / 2);
      screenCoordinates.y = Math.round((-screenCoordinates.y + 1) * canvas.offsetHeight / 2);
      screenCoordinates.z = 0;

      return screenCoordinates;
    }
  }, {
    key: 'create',
    value: function create() {
      this.createVoxel();
      this.createMesh();
      this.createDOM();
    }
  }, {
    key: 'createVoxel',
    value: function createVoxel() {
      this._voxel = new _models4.default();
      this._voxel.id = this.id;
      this._voxel.worldCoordinates = this._worldCoordinates;
    }
  }, {
    key: 'createMesh',
    value: function createMesh() {
      var dataCoordinates = _models2.default.worldToData(this._stack, this._worldPosition);

      this._geometry = new _geometries2.default(dataCoordinates);
      this._material = new THREE.MeshBasicMaterial({
        wireframe: true,
        wireframeLinewidth: 1
      });
      this._mesh = new THREE.Mesh(this._geometry, this._material);
      this._mesh.applyMatrix(this._stack.ijk2LPS);
      this._mesh.visible = true;

      this.updateMeshColor();

      this.add(this._mesh);
    }
  }, {
    key: 'updateMeshColor',
    value: function updateMeshColor() {
      if (this._material) {
        this._material.color.set(this._color);
      }
    }
  }, {
    key: 'createDOM',
    value: function createDOM() {
      // dom
      this._dom = document.createElement('div');
      this._dom.setAttribute('id', this.uuid);
      this._dom.setAttribute('class', 'AMI Widget VoxelProbe');
      this._dom.style.border = '2px solid #000';
      this._dom.style.backgroundColor = 'rgb(249, 249, 249)';
      this._dom.style.color = '#212121';
      this._dom.style.position = 'absolute';
      this._dom.style.transformOrigin = '0px 100% 0px';

      // measurenents
      var measurementsContainer = document.createElement('div');
      // LPS
      var lpsContainer = document.createElement('div');
      lpsContainer.setAttribute('id', 'lpsPosition');
      measurementsContainer.appendChild(lpsContainer);
      // IJK
      var ijkContainer = document.createElement('div');
      ijkContainer.setAttribute('id', 'ijkPosition');
      measurementsContainer.appendChild(ijkContainer);
      // Value
      var valueContainer = document.createElement('div');
      valueContainer.setAttribute('id', 'value');
      measurementsContainer.appendChild(valueContainer);

      this.updateDOMColor();
      this._dom.appendChild(measurementsContainer);

      // add it!
      this._container.appendChild(this._dom);
    }
  }, {
    key: 'updateDOMContent',
    value: function updateDOMContent() {
      var rasContainer = this._dom.querySelector('#lpsPosition');
      rasContainer.innerHTML = 'LPS: \n      ' + this._voxel.worldCoordinates.x.toFixed(2) + ' :\n      ' + this._voxel.worldCoordinates.y.toFixed(2) + ' :\n      ' + this._voxel.worldCoordinates.z.toFixed(2);

      var ijkContainer = this._dom.querySelector('#ijkPosition');
      ijkContainer.innerHTML = 'IJK: \n      ' + this._voxel.dataCoordinates.x + ' :\n      ' + this._voxel.dataCoordinates.y + ' :\n      ' + this._voxel.dataCoordinates.z;

      var valueContainer = this._dom.querySelector('#value');
      valueContainer.innerHTML = 'Value: ' + this._voxel.value;
    }
  }, {
    key: 'update',
    value: function update() {
      // general update
      this.updateColor();
      this._screenPosition = this.worldToScreen(this._worldPosition, this._camera, this._container);

      // set data coordinates && value
      this.updateVoxel(this._worldPosition);

      // update mesh position
      this.updateMeshColor();
      if (this._mesh && this._mesh.geometry) {
        this._mesh.geometry.location = this._voxel.dataCoordinates;
        this._mesh.updateMatrix();
      }

      // update dom
      this.updateDOMContent();
      this.updateDOMColor();
      this.updateDOMPosition();
    }
  }, {
    key: 'updateVoxel',
    value: function updateVoxel(worldCoordinates) {
      // update world coordinates
      this._voxel.worldCoordinates = worldCoordinates;

      // update data coordinates
      this._voxel.dataCoordinates = _models2.default.worldToData(this._stack, this._voxel.worldCoordinates);

      // update value
      var value = _models2.default.value(this._stack, this._voxel.dataCoordinates);

      this._voxel.value = _models2.default.valueRescaleSlopeIntercept(value, this._stack.rescaleSlope, this._stack.rescaleIntercept);
    }
  }, {
    key: 'updateDOMPosition',
    value: function updateDOMPosition() {
      if (this._dom) {
        var posY = this._screenPosition.y - this._container.offsetHeight;
        this._dom.style.transform = 'translate3D(' + this._screenPosition.x + 'px, ' + posY + 'px, 0)';
      }
    }
  }, {
    key: 'updateDOMColor',
    value: function updateDOMColor() {
      this._dom.style.borderColor = '' + this._color;
    }
  }, {
    key: 'free',
    value: function free() {
      this._container.removeEventListener('mouseup', this.onMouseUpHandler, false);
      this._container.removeEventListener('mousemove', this.onMouseMoveHandler, false);

      this._container.removeEventListener('mousewheel', this.onMouseMoveHandler, false);
      this._container.removeEventListener('DOMMouseScroll', this.onMouseMoveHandler, false);

      this._voxel.removeTest();
      this.remove(this._voxel);
      this._voxel = null;

      _get(WidgetsVoxelProbe.prototype.__proto__ || Object.getPrototypeOf(WidgetsVoxelProbe.prototype), 'free', this).call(this);
    }
  }, {
    key: 'hoverVoxel',
    value: function hoverVoxel(mouseScreenCoordinates, currentDataCoordinates) {
      // update distance mouse/this._voxel
      var dx = mouseScreenCoordinates.screenX - this._voxel.voxel.screenCoordinates.x;
      var dy = mouseScreenCoordinates.screenY - this._voxel.voxel.screenCoordinates.y;
      var distance = Math.sqrt(dx * dx + dy * dy);
      this._voxel.distance = distance;
      if (distance >= 0 && distance < 10) {
        this._hover = true;
      } else {
        this._hover = false;
      }
    }
  }, {
    key: 'worldPosition',
    set: function set(worldPosition) {
      this._worldPosition.copy(worldPosition);
      this.update();
    }
  }, {
    key: 'defaultColor',
    set: function set(defaultColor) {
      this._defaultColor = defaultColor;
      this.update();
    },
    get: function get() {
      return this._defaultColor;
    }
  }, {
    key: 'activeColor',
    set: function set(activeColor) {
      this._activeColor = activeColor;
      this.update();
    },
    get: function get() {
      return this._activeColor;
    }
  }, {
    key: 'hoverColor',
    set: function set(hoverColor) {
      this._hoverColor = hoverColor;
      this.update();
    },
    get: function get() {
      return this._hoverColor;
    }
  }, {
    key: 'selectedColor',
    set: function set(selectedColor) {
      this._selectedColor = selectedColor;
      this.update();
    },
    get: function get() {
      return this._selectedColor;
    }
  }, {
    key: 'showVoxel',
    set: function set(showVoxel) {
      this._showVoxel = showVoxel;
      this.update();
    },
    get: function get() {
      return this._showVoxel;
    }
  }, {
    key: 'showDomSVG',
    set: function set(showDomSVG) {
      this._showDomSVG = showDomSVG;
      this.update();
    },
    get: function get() {
      return this._showDomSVG;
    }
  }, {
    key: 'showDomMeasurements',
    set: function set(showDomMeasurements) {
      this._showDomMeasurements = showDomMeasurements;
      this.update();
    },
    get: function get() {
      return this._showDomMeasurements;
    }
  }]);

  return WidgetsVoxelProbe;
}(_widgets2.default);

exports.default = WidgetsVoxelProbe;

},{"../core/core.intersections":102,"../geometries/geometries.voxel":109,"../models/models.stack":134,"../models/models.voxel":135,"../widgets/widgets.base":166}]},{},[95])(95)
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJleHRlcm5hbC9zY3JpcHRzL2pwZWcuanMiLCJleHRlcm5hbC9zY3JpcHRzL2pweC5qcyIsIm5vZGVfbW9kdWxlcy9hc3NlcnQvYXNzZXJ0LmpzIiwibm9kZV9tb2R1bGVzL2Jhc2U2NC1qcy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyLXJlc29sdmUvZW1wdHkuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS16bGliL25vZGVfbW9kdWxlcy9wYWtvL2xpYi91dGlscy9jb21tb24uanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS16bGliL25vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2FkbGVyMzIuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS16bGliL25vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2NvbnN0YW50cy5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5LXpsaWIvbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvY3JjMzIuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS16bGliL25vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2RlZmxhdGUuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS16bGliL25vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2luZmZhc3QuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS16bGliL25vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2luZmxhdGUuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS16bGliL25vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2luZnRyZWVzLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktemxpYi9ub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9tZXNzYWdlcy5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5LXpsaWIvbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvdHJlZXMuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS16bGliL25vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL3pzdHJlYW0uanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS16bGliL3NyYy9iaW5kaW5nLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktemxpYi9zcmMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYnVmZmVyLXNoaW1zL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2J1ZmZlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9idWZmZXIvbm9kZV9tb2R1bGVzL2lzYXJyYXkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvY29uc3QtbmluZi1mbG9hdDMyL2xpYi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jb25zdC1waW5mLWZsb2F0MzIvbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtdXRpbC1pcy9saWIvdXRpbC5qcyIsIm5vZGVfbW9kdWxlcy9kaWNvbS1wYXJzZXIvZGlzdC9kaWNvbVBhcnNlci5qcyIsIm5vZGVfbW9kdWxlcy9ldmVudHMvZXZlbnRzLmpzIiwibm9kZV9tb2R1bGVzL2llZWU3NTQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaW5oZXJpdHMvaW5oZXJpdHNfYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9pcy1idWZmZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvanBlZy1sb3NzbGVzcy1kZWNvZGVyLWpzL3NyYy9jb21wb25lbnQtc3BlYy5qcyIsIm5vZGVfbW9kdWxlcy9qcGVnLWxvc3NsZXNzLWRlY29kZXItanMvc3JjL2RhdGEtc3RyZWFtLmpzIiwibm9kZV9tb2R1bGVzL2pwZWctbG9zc2xlc3MtZGVjb2Rlci1qcy9zcmMvZGVjb2Rlci5qcyIsIm5vZGVfbW9kdWxlcy9qcGVnLWxvc3NsZXNzLWRlY29kZXItanMvc3JjL2ZyYW1lLWhlYWRlci5qcyIsIm5vZGVfbW9kdWxlcy9qcGVnLWxvc3NsZXNzLWRlY29kZXItanMvc3JjL2h1ZmZtYW4tdGFibGUuanMiLCJub2RlX21vZHVsZXMvanBlZy1sb3NzbGVzcy1kZWNvZGVyLWpzL3NyYy9tYWluLmpzIiwibm9kZV9tb2R1bGVzL2pwZWctbG9zc2xlc3MtZGVjb2Rlci1qcy9zcmMvcXVhbnRpemF0aW9uLXRhYmxlLmpzIiwibm9kZV9tb2R1bGVzL2pwZWctbG9zc2xlc3MtZGVjb2Rlci1qcy9zcmMvc2Nhbi1jb21wb25lbnQuanMiLCJub2RlX21vZHVsZXMvanBlZy1sb3NzbGVzcy1kZWNvZGVyLWpzL3NyYy9zY2FuLWhlYWRlci5qcyIsIm5vZGVfbW9kdWxlcy9qcGVnLWxvc3NsZXNzLWRlY29kZXItanMvc3JjL3V0aWxzLmpzIiwibm9kZV9tb2R1bGVzL21hdGgtYWJzL2xpYi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9tYXRoLWNlaWwvbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL21hdGgtZmxvYXQzMi10by1iaW5hcnktc3RyaW5nL2xpYi9kaXYyLmpzIiwibm9kZV9tb2R1bGVzL21hdGgtZmxvYXQzMi10by1iaW5hcnktc3RyaW5nL2xpYi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9tYXRoLWZsb2F0MzItdG8tYmluYXJ5LXN0cmluZy9saWIvbXVsdDIuanMiLCJub2RlX21vZHVsZXMvbWF0aC1mbG9vci9saWIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbmlmdGktcmVhZGVyLWpzL3NyYy9uaWZ0aS5qcyIsIm5vZGVfbW9kdWxlcy9uaWZ0aS1yZWFkZXItanMvc3JjL25pZnRpMS5qcyIsIm5vZGVfbW9kdWxlcy9uaWZ0aS1yZWFkZXItanMvc3JjL25pZnRpMi5qcyIsIm5vZGVfbW9kdWxlcy9uaWZ0aS1yZWFkZXItanMvc3JjL3V0aWxpdGllcy5qcyIsIm5vZGVfbW9kdWxlcy9ucnJkLWpzL25ycmQuanMiLCJub2RlX21vZHVsZXMvcGFrby9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9wYWtvL2xpYi9kZWZsYXRlLmpzIiwibm9kZV9tb2R1bGVzL3Bha28vbGliL2luZmxhdGUuanMiLCJub2RlX21vZHVsZXMvcGFrby9saWIvdXRpbHMvc3RyaW5ncy5qcyIsIm5vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2RlZmxhdGUuanMiLCJub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9nemhlYWRlci5qcyIsIm5vZGVfbW9kdWxlcy9wcm9jZXNzLW5leHRpY2stYXJncy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvcHVueWNvZGUvcHVueWNvZGUuanMiLCJub2RlX21vZHVsZXMvcXVlcnlzdHJpbmctZXMzL2RlY29kZS5qcyIsIm5vZGVfbW9kdWxlcy9xdWVyeXN0cmluZy1lczMvZW5jb2RlLmpzIiwibm9kZV9tb2R1bGVzL3F1ZXJ5c3RyaW5nLWVzMy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fZHVwbGV4LmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9yZWFkYWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fdHJhbnNmb3JtLmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV93cml0YWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvQnVmZmVyTGlzdC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vdHJhbnNmb3JtLmpzIiwibm9kZV9tb2R1bGVzL3N0cmluZ19kZWNvZGVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3VybC91cmwuanMiLCJub2RlX21vZHVsZXMvdXJsL3V0aWwuanMiLCJub2RlX21vZHVsZXMvdXRpbC1kZXByZWNhdGUvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy91dGlsL3N1cHBvcnQvaXNCdWZmZXJCcm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3V0aWwvdXRpbC5qcyIsIm5vZGVfbW9kdWxlcy91dGlscy1sZWZ0LXBhZC1zdHJpbmcvbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3V0aWxzLXJlcGVhdC1zdHJpbmcvbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3V0aWxzLXJpZ2h0LXBhZC1zdHJpbmcvbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3ZhbGlkYXRlLmlvLWludGVnZXIvbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3ZhbGlkYXRlLmlvLW5vbm5lZ2F0aXZlLWludGVnZXIvbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3ZhbGlkYXRlLmlvLW51bWJlci9saWIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdmFsaWRhdGUuaW8tc3RyaW5nLXByaW1pdGl2ZS9saWIvaW5kZXguanMiLCJwYWNrYWdlLmpzb24iLCJzcmMvYW1pLmpzIiwic3JjL2NhbWVyYXMvY2FtZXJhcy5qcyIsInNyYy9jYW1lcmFzL2NhbWVyYXMub3J0aG9ncmFwaGljLmpzIiwic3JjL2NvbnRyb2xzL2NvbnRyb2xzLmpzIiwic3JjL2NvbnRyb2xzL2NvbnRyb2xzLnRyYWNrYmFsbC5qcyIsInNyYy9jb250cm9scy9jb250cm9scy50cmFja2JhbGxvcnRoby5qcyIsInNyYy9jb3JlL2NvcmUuY29sb3JzLmpzIiwic3JjL2NvcmUvY29yZS5pbnRlcnNlY3Rpb25zLmpzIiwic3JjL2NvcmUvY29yZS5qcyIsInNyYy9jb3JlL2NvcmUucGFjay5qcyIsInNyYy9jb3JlL2NvcmUudXRpbHMuanMiLCJzcmMvY29yZS9jb3JlLnZhbGlkYXRvcnMuanMiLCJzcmMvZ2VvbWV0cmllcy9nZW9tZXRyaWVzLmpzIiwic3JjL2dlb21ldHJpZXMvZ2VvbWV0cmllcy5zbGljZS5qcyIsInNyYy9nZW9tZXRyaWVzL2dlb21ldHJpZXMudm94ZWwuanMiLCJzcmMvaGVscGVycy9oZWxwZXJzLmJvcmRlci5qcyIsInNyYy9oZWxwZXJzL2hlbHBlcnMuYm91bmRpbmdib3guanMiLCJzcmMvaGVscGVycy9oZWxwZXJzLmpzIiwic3JjL2hlbHBlcnMvaGVscGVycy5sb2NhbGl6ZXIuanMiLCJzcmMvaGVscGVycy9oZWxwZXJzLmx1dC5qcyIsInNyYy9oZWxwZXJzL2hlbHBlcnMubWF0ZXJpYWwubWl4aW4uanMiLCJzcmMvaGVscGVycy9oZWxwZXJzLnByb2dyZXNzYmFyLmV2ZW50YmFzZWQuanMiLCJzcmMvaGVscGVycy9oZWxwZXJzLnByb2dyZXNzYmFyLmpzIiwic3JjL2hlbHBlcnMvaGVscGVycy5zbGljZS5qcyIsInNyYy9oZWxwZXJzL2hlbHBlcnMuc3RhY2suanMiLCJzcmMvaGVscGVycy9oZWxwZXJzLnZvbHVtZXJlbmRlcmluZy5qcyIsInNyYy9oZWxwZXJzL3gvaGVscGVycy54LmludGVyYWN0b3IuanMiLCJzcmMvaGVscGVycy94L2hlbHBlcnMueC5qcyIsInNyYy9oZWxwZXJzL3gvaGVscGVycy54Lm1lc2guanMiLCJzcmMvaGVscGVycy94L2hlbHBlcnMueC5yZW5kZXJlcjJkLmpzIiwic3JjL2hlbHBlcnMveC9oZWxwZXJzLngucmVuZGVyZXIzZC5qcyIsInNyYy9oZWxwZXJzL3gvaGVscGVycy54LnZvbHVtZS5qcyIsInNyYy9sb2FkZXJzL2xvYWRlcnMuYmFzZS5qcyIsInNyYy9sb2FkZXJzL2xvYWRlcnMuanMiLCJzcmMvbG9hZGVycy9sb2FkZXJzLnZvbHVtZS5qcyIsInNyYy9tb2RlbHMvbW9kZWxzLmJhc2UuanMiLCJzcmMvbW9kZWxzL21vZGVscy5mcmFtZS5qcyIsInNyYy9tb2RlbHMvbW9kZWxzLmpzIiwic3JjL21vZGVscy9tb2RlbHMuc2VyaWVzLmpzIiwic3JjL21vZGVscy9tb2RlbHMuc3RhY2suanMiLCJzcmMvbW9kZWxzL21vZGVscy52b3hlbC5qcyIsInNyYy9wYXJzZXJzL3BhcnNlcnMuZGljb20uanMiLCJzcmMvcGFyc2Vycy9wYXJzZXJzLmpzIiwic3JjL3BhcnNlcnMvcGFyc2Vycy5taGQuanMiLCJzcmMvcGFyc2Vycy9wYXJzZXJzLm5pZnRpLmpzIiwic3JjL3BhcnNlcnMvcGFyc2Vycy5ucnJkLmpzIiwic3JjL3BhcnNlcnMvcGFyc2Vycy52b2x1bWUuanMiLCJzcmMvc2hhZGVycy9oZWxwZXJzL3NoYWRlcnMuaGVscGVycy5pbnRlcnNlY3RCb3guanMiLCJzcmMvc2hhZGVycy9oZWxwZXJzL3NoYWRlcnMuaGVscGVycy50ZXh0dXJlM2QuanMiLCJzcmMvc2hhZGVycy9oZWxwZXJzL3NoYWRlcnMuaGVscGVycy51bnBhY2suanMiLCJzcmMvc2hhZGVycy9pbnRlcnBvbGF0aW9uL3NoYWRlcnMuaW50ZXJwb2xhdGlvbi5pZGVudGl0eS5qcyIsInNyYy9zaGFkZXJzL2ludGVycG9sYXRpb24vc2hhZGVycy5pbnRlcnBvbGF0aW9uLmpzIiwic3JjL3NoYWRlcnMvaW50ZXJwb2xhdGlvbi9zaGFkZXJzLmludGVycG9sYXRpb24udHJpbGluZWFyLmpzIiwic3JjL3NoYWRlcnMvc2hhZGVycy5iYXNlLmpzIiwic3JjL3NoYWRlcnMvc2hhZGVycy5jb250b3VyLmZyYWdtZW50LmpzIiwic3JjL3NoYWRlcnMvc2hhZGVycy5jb250b3VyLnVuaWZvcm0uanMiLCJzcmMvc2hhZGVycy9zaGFkZXJzLmNvbnRvdXIudmVydGV4LmpzIiwic3JjL3NoYWRlcnMvc2hhZGVycy5kYXRhLmZyYWdtZW50LmpzIiwic3JjL3NoYWRlcnMvc2hhZGVycy5kYXRhLnVuaWZvcm0uanMiLCJzcmMvc2hhZGVycy9zaGFkZXJzLmRhdGEudmVydGV4LmpzIiwic3JjL3NoYWRlcnMvc2hhZGVycy5qcyIsInNyYy9zaGFkZXJzL3NoYWRlcnMubGF5ZXIuZnJhZ21lbnQuanMiLCJzcmMvc2hhZGVycy9zaGFkZXJzLmxheWVyLnVuaWZvcm0uanMiLCJzcmMvc2hhZGVycy9zaGFkZXJzLmxheWVyLnZlcnRleC5qcyIsInNyYy9zaGFkZXJzL3NoYWRlcnMubG9jYWxpemVyLmZyYWdtZW50LmpzIiwic3JjL3NoYWRlcnMvc2hhZGVycy5sb2NhbGl6ZXIudW5pZm9ybS5qcyIsInNyYy9zaGFkZXJzL3NoYWRlcnMubG9jYWxpemVyLnZlcnRleC5qcyIsInNyYy9zaGFkZXJzL3NoYWRlcnMudnIuZnJhZ21lbnQuanMiLCJzcmMvc2hhZGVycy9zaGFkZXJzLnZyLnVuaWZvcm0uanMiLCJzcmMvc2hhZGVycy9zaGFkZXJzLnZyLnZlcnRleC5qcyIsInNyYy93aWRnZXRzL3dpZGdldHMuYW5ub3RhdGlvbi5qcyIsInNyYy93aWRnZXRzL3dpZGdldHMuYmFzZS5qcyIsInNyYy93aWRnZXRzL3dpZGdldHMuYmlydWxlci5qcyIsInNyYy93aWRnZXRzL3dpZGdldHMuaGFuZGxlLmpzIiwic3JjL3dpZGdldHMvd2lkZ2V0cy5qcyIsInNyYy93aWRnZXRzL3dpZGdldHMucm9pLmpzIiwic3JjL3dpZGdldHMvd2lkZ2V0cy5ydWxlci5qcyIsInNyYy93aWRnZXRzL3dpZGdldHMudm94ZWxQcm9iZS5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMS9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDcjlIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDMWVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xIQTs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvekRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0VUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xnREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdlVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzVPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ2xtQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDNUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM3dkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUMzR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzNuRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqMkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOXRDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2xhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDekxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3h6REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7O0FDeENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3BMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNyaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDMUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM1NkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3JMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDdGlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQy9EQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3TkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNXRCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDbkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzFrQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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ZUFBZSxBQUMvQjtXQUFBLEFBQUssaUJBQUwsQUFBc0IsQUFDdEI7V0FBQSxBQUFLLEFBQ047QTt3QkFFbUIsQUFDbEI7YUFBTyxLQUFQLEFBQVksQUFDYjs7OztzQixBQUVhLFdBQVcsQUFDdkI7V0FBQSxBQUFLLGFBQUwsQUFBa0IsQUFDbEI7V0FBQSxBQUFLLEFBQ047QTt3QkFFZSxBQUNkO2FBQU8sS0FBUCxBQUFZLEFBQ2I7Ozs7c0IsQUFFYyxZQUFZLEFBQ3pCO1dBQUEsQUFBSyxjQUFMLEFBQW1CLEFBQ25CO1dBQUEsQUFBSyxBQUNOO0E7d0JBRWdCLEFBQ2Y7YUFBTyxLQUFQLEFBQVksQUFDYjs7OztzQixBQUV1QixxQkFBcUIsQUFDM0M7V0FBQSxBQUFLLHVCQUFMLEFBQTRCLEFBQzVCO1dBQUEsQUFBSyxBQUNOO0E7d0JBRXlCLEFBQ3hCO2FBQU8sS0FBUCxBQUFZLEFBQ2I7Ozs7Ozs7a0IsQUFuZGtCIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsIi8vIGpzaGludCBpZ25vcmU6IHN0YXJ0XG5cbi8qIC0qLSBNb2RlOiBKYXZhOyB0YWItd2lkdGg6IDI7IGluZGVudC10YWJzLW1vZGU6IG5pbDsgYy1iYXNpYy1vZmZzZXQ6IDIgLSotIC9cbiAvKiB2aW06IHNldCBzaGlmdHdpZHRoPTIgdGFic3RvcD0yIGF1dG9pbmRlbnQgY2luZGVudCBleHBhbmR0YWI6ICovXG4vKlxuIENvcHlyaWdodCAyMDExIG5vdG1hc3RlcnlldFxuXG4gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8vIC0gVGhlIEpQRUcgc3BlY2lmaWNhdGlvbiBjYW4gYmUgZm91bmQgaW4gdGhlIElUVSBDQ0lUVCBSZWNvbW1lbmRhdGlvbiBULjgxXG4vLyAgICh3d3cudzMub3JnL0dyYXBoaWNzL0pQRUcvaXR1LXQ4MS5wZGYpXG4vLyAtIFRoZSBKRklGIHNwZWNpZmljYXRpb24gY2FuIGJlIGZvdW5kIGluIHRoZSBKUEVHIEZpbGUgSW50ZXJjaGFuZ2UgRm9ybWF0XG4vLyAgICh3d3cudzMub3JnL0dyYXBoaWNzL0pQRUcvamZpZjMucGRmKVxuLy8gLSBUaGUgQWRvYmUgQXBwbGljYXRpb24tU3BlY2lmaWMgSlBFRyBtYXJrZXJzIGluIHRoZSBTdXBwb3J0aW5nIHRoZSBEQ1QgRmlsdGVyc1xuLy8gICBpbiBQb3N0U2NyaXB0IExldmVsIDIsIFRlY2huaWNhbCBOb3RlICM1MTE2XG4vLyAgIChwYXJ0bmVycy5hZG9iZS5jb20vcHVibGljL2RldmVsb3Blci9lbi9wcy9zZGsvNTExNi5EQ1RfRmlsdGVyLnBkZilcblxudmFyIENvbG9yU3BhY2UgPSB7VW5rb3duOiAwLCBHcmF5c2NhbGU6IDEsIEFkb2JlUkdCOiAyLCBSR0I6IDMsIENZTUs6IDR9O1xudmFyIEpwZWdJbWFnZSA9IChmdW5jdGlvbiBqcGVnSW1hZ2UoKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuICB2YXIgZGN0WmlnWmFnID0gbmV3IEludDMyQXJyYXkoW1xuICAgIDAsXG4gICAgMSwgOCxcbiAgICAxNiwgOSwgMixcbiAgICAzLCAxMCwgMTcsIDI0LFxuICAgIDMyLCAyNSwgMTgsIDExLCA0LFxuICAgIDUsIDEyLCAxOSwgMjYsIDMzLCA0MCxcbiAgICA0OCwgNDEsIDM0LCAyNywgMjAsIDEzLCA2LFxuICAgIDcsIDE0LCAyMSwgMjgsIDM1LCA0MiwgNDksIDU2LFxuICAgIDU3LCA1MCwgNDMsIDM2LCAyOSwgMjIsIDE1LFxuICAgIDIzLCAzMCwgMzcsIDQ0LCA1MSwgNTgsXG4gICAgNTksIDUyLCA0NSwgMzgsIDMxLFxuICAgIDM5LCA0NiwgNTMsIDYwLFxuICAgIDYxLCA1NCwgNDcsXG4gICAgNTUsIDYyLFxuICAgIDYzXG4gIF0pO1xuXG4gIHZhciBkY3RDb3MxID0gNDAxNzsgICAvLyBjb3MocGkvMTYpXG4gIHZhciBkY3RTaW4xID0gNzk5OyAgIC8vIHNpbihwaS8xNilcbiAgdmFyIGRjdENvczMgPSAzNDA2OyAgIC8vIGNvcygzKnBpLzE2KVxuICB2YXIgZGN0U2luMyA9IDIyNzY7ICAgLy8gc2luKDMqcGkvMTYpXG4gIHZhciBkY3RDb3M2ID0gMTU2NzsgICAvLyBjb3MoNipwaS8xNilcbiAgdmFyIGRjdFNpbjYgPSAzNzg0OyAgIC8vIHNpbig2KnBpLzE2KVxuICB2YXIgZGN0U3FydDIgPSA1NzkzOyAgIC8vIHNxcnQoMilcbiAgdmFyIGRjdFNxcnQxZDIgPSAyODk2OyAgLy8gc3FydCgyKSAvIDJcblxuICBmdW5jdGlvbiBjb25zdHJ1Y3RvcigpIHtcbiAgfVxuXG4gIGZ1bmN0aW9uIGJ1aWxkSHVmZm1hblRhYmxlKGNvZGVMZW5ndGhzLCB2YWx1ZXMpIHtcbiAgICB2YXIgayA9IDAsIGNvZGUgPSBbXSwgaSwgaiwgbGVuZ3RoID0gMTY7XG4gICAgd2hpbGUgKGxlbmd0aCA+IDAgJiYgIWNvZGVMZW5ndGhzW2xlbmd0aCAtIDFdKVxuICAgICAgbGVuZ3RoLS07XG4gICAgY29kZS5wdXNoKHtjaGlsZHJlbjogW10sIGluZGV4OiAwfSk7XG4gICAgdmFyIHAgPSBjb2RlWzBdLCBxO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgZm9yIChqID0gMDsgaiA8IGNvZGVMZW5ndGhzW2ldOyBqKyspIHtcbiAgICAgICAgcCA9IGNvZGUucG9wKCk7XG4gICAgICAgIHAuY2hpbGRyZW5bcC5pbmRleF0gPSB2YWx1ZXNba107XG4gICAgICAgIHdoaWxlIChwLmluZGV4ID4gMCkge1xuICAgICAgICAgIHAgPSBjb2RlLnBvcCgpO1xuICAgICAgICB9XG4gICAgICAgIHAuaW5kZXgrKztcbiAgICAgICAgY29kZS5wdXNoKHApO1xuICAgICAgICB3aGlsZSAoY29kZS5sZW5ndGggPD0gaSkge1xuICAgICAgICAgIGNvZGUucHVzaChxID0ge2NoaWxkcmVuOiBbXSwgaW5kZXg6IDB9KTtcbiAgICAgICAgICBwLmNoaWxkcmVuW3AuaW5kZXhdID0gcS5jaGlsZHJlbjtcbiAgICAgICAgICBwID0gcTtcbiAgICAgICAgfVxuICAgICAgICBrKys7XG4gICAgICB9XG4gICAgICBpZiAoaSArIDEgPCBsZW5ndGgpIHtcbiAgICAgICAgLy8gcCBoZXJlIHBvaW50cyB0byBsYXN0IGNvZGVcbiAgICAgICAgY29kZS5wdXNoKHEgPSB7Y2hpbGRyZW46IFtdLCBpbmRleDogMH0pO1xuICAgICAgICBwLmNoaWxkcmVuW3AuaW5kZXhdID0gcS5jaGlsZHJlbjtcbiAgICAgICAgcCA9IHE7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjb2RlWzBdLmNoaWxkcmVuO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0QmxvY2tCdWZmZXJPZmZzZXQoY29tcG9uZW50LCByb3csIGNvbCkge1xuICAgIHJldHVybiA2NCAqICgoY29tcG9uZW50LmJsb2Nrc1BlckxpbmUgKyAxKSAqIHJvdyArIGNvbCk7XG4gIH1cblxuICBmdW5jdGlvbiBkZWNvZGVTY2FuKGRhdGEsIG9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgICBmcmFtZSwgY29tcG9uZW50cywgcmVzZXRJbnRlcnZhbCxcbiAgICAgICAgICAgICAgICAgICAgICBzcGVjdHJhbFN0YXJ0LCBzcGVjdHJhbEVuZCxcbiAgICAgICAgICAgICAgICAgICAgICBzdWNjZXNzaXZlUHJldiwgc3VjY2Vzc2l2ZSkge1xuICAgIHZhciBwcmVjaXNpb24gPSBmcmFtZS5wcmVjaXNpb247XG4gICAgdmFyIHNhbXBsZXNQZXJMaW5lID0gZnJhbWUuc2FtcGxlc1BlckxpbmU7XG4gICAgdmFyIHNjYW5MaW5lcyA9IGZyYW1lLnNjYW5MaW5lcztcbiAgICB2YXIgbWN1c1BlckxpbmUgPSBmcmFtZS5tY3VzUGVyTGluZTtcbiAgICB2YXIgcHJvZ3Jlc3NpdmUgPSBmcmFtZS5wcm9ncmVzc2l2ZTtcbiAgICB2YXIgbWF4SCA9IGZyYW1lLm1heEgsIG1heFYgPSBmcmFtZS5tYXhWO1xuXG4gICAgdmFyIHN0YXJ0T2Zmc2V0ID0gb2Zmc2V0LCBiaXRzRGF0YSA9IDAsIGJpdHNDb3VudCA9IDA7XG5cbiAgICBmdW5jdGlvbiByZWFkQml0KCkge1xuICAgICAgaWYgKGJpdHNDb3VudCA+IDApIHtcbiAgICAgICAgYml0c0NvdW50LS07XG4gICAgICAgIHJldHVybiAoYml0c0RhdGEgPj4gYml0c0NvdW50KSAmIDE7XG4gICAgICB9XG4gICAgICBiaXRzRGF0YSA9IGRhdGFbb2Zmc2V0KytdO1xuICAgICAgaWYgKGJpdHNEYXRhID09IDB4RkYpIHtcbiAgICAgICAgdmFyIG5leHRCeXRlID0gZGF0YVtvZmZzZXQrK107XG4gICAgICAgIGlmIChuZXh0Qnl0ZSkge1xuICAgICAgICAgIHRocm93IFwidW5leHBlY3RlZCBtYXJrZXI6IFwiICsgKChiaXRzRGF0YSA8PCA4KSB8IG5leHRCeXRlKS50b1N0cmluZygxNik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdW5zdHVmZiAwXG4gICAgICB9XG4gICAgICBiaXRzQ291bnQgPSA3O1xuICAgICAgcmV0dXJuIGJpdHNEYXRhID4+PiA3O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRlY29kZUh1ZmZtYW4odHJlZSkge1xuICAgICAgdmFyIG5vZGUgPSB0cmVlO1xuICAgICAgdmFyIGJpdDtcbiAgICAgIHdoaWxlICgoYml0ID0gcmVhZEJpdCgpKSAhPT0gbnVsbCkge1xuICAgICAgICBub2RlID0gbm9kZVtiaXRdO1xuICAgICAgICBpZiAodHlwZW9mIG5vZGUgPT09ICdudW1iZXInKVxuICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICBpZiAodHlwZW9mIG5vZGUgIT09ICdvYmplY3QnKVxuICAgICAgICAgIHRocm93IFwiaW52YWxpZCBodWZmbWFuIHNlcXVlbmNlXCI7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZWNlaXZlKGxlbmd0aCkge1xuICAgICAgdmFyIG4gPSAwO1xuICAgICAgd2hpbGUgKGxlbmd0aCA+IDApIHtcbiAgICAgICAgdmFyIGJpdCA9IHJlYWRCaXQoKTtcbiAgICAgICAgaWYgKGJpdCA9PT0gbnVsbClcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIG4gPSAobiA8PCAxKSB8IGJpdDtcbiAgICAgICAgbGVuZ3RoLS07XG4gICAgICB9XG4gICAgICByZXR1cm4gbjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZWNlaXZlQW5kRXh0ZW5kKGxlbmd0aCkge1xuICAgICAgdmFyIG4gPSByZWNlaXZlKGxlbmd0aCk7XG4gICAgICBpZiAobiA+PSAxIDw8IChsZW5ndGggLSAxKSlcbiAgICAgICAgcmV0dXJuIG47XG4gICAgICByZXR1cm4gbiArICgtMSA8PCBsZW5ndGgpICsgMTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkZWNvZGVCYXNlbGluZShjb21wb25lbnQsIG9mZnNldCkge1xuICAgICAgdmFyIHQgPSBkZWNvZGVIdWZmbWFuKGNvbXBvbmVudC5odWZmbWFuVGFibGVEQyk7XG4gICAgICB2YXIgZGlmZiA9IHQgPT09IDAgPyAwIDogcmVjZWl2ZUFuZEV4dGVuZCh0KTtcbiAgICAgIGNvbXBvbmVudC5ibG9ja0RhdGFbb2Zmc2V0XSA9IChjb21wb25lbnQucHJlZCArPSBkaWZmKTtcbiAgICAgIHZhciBrID0gMTtcbiAgICAgIHdoaWxlIChrIDwgNjQpIHtcbiAgICAgICAgdmFyIHJzID0gZGVjb2RlSHVmZm1hbihjb21wb25lbnQuaHVmZm1hblRhYmxlQUMpO1xuICAgICAgICB2YXIgcyA9IHJzICYgMTUsIHIgPSBycyA+PiA0O1xuICAgICAgICBpZiAocyA9PT0gMCkge1xuICAgICAgICAgIGlmIChyIDwgMTUpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBrICs9IDE2O1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGsgKz0gcjtcbiAgICAgICAgdmFyIHogPSBkY3RaaWdaYWdba107XG4gICAgICAgIGNvbXBvbmVudC5ibG9ja0RhdGFbb2Zmc2V0ICsgel0gPSByZWNlaXZlQW5kRXh0ZW5kKHMpO1xuICAgICAgICBrKys7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGVjb2RlRENGaXJzdChjb21wb25lbnQsIG9mZnNldCkge1xuICAgICAgdmFyIHQgPSBkZWNvZGVIdWZmbWFuKGNvbXBvbmVudC5odWZmbWFuVGFibGVEQyk7XG4gICAgICB2YXIgZGlmZiA9IHQgPT09IDAgPyAwIDogKHJlY2VpdmVBbmRFeHRlbmQodCkgPDwgc3VjY2Vzc2l2ZSk7XG4gICAgICBjb21wb25lbnQuYmxvY2tEYXRhW29mZnNldF0gPSAoY29tcG9uZW50LnByZWQgKz0gZGlmZik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGVjb2RlRENTdWNjZXNzaXZlKGNvbXBvbmVudCwgb2Zmc2V0KSB7XG4gICAgICBjb21wb25lbnQuYmxvY2tEYXRhW29mZnNldF0gfD0gcmVhZEJpdCgpIDw8IHN1Y2Nlc3NpdmU7XG4gICAgfVxuXG4gICAgdmFyIGVvYnJ1biA9IDA7XG4gICAgZnVuY3Rpb24gZGVjb2RlQUNGaXJzdChjb21wb25lbnQsIG9mZnNldCkge1xuICAgICAgaWYgKGVvYnJ1biA+IDApIHtcbiAgICAgICAgZW9icnVuLS07XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBrID0gc3BlY3RyYWxTdGFydCwgZSA9IHNwZWN0cmFsRW5kO1xuICAgICAgd2hpbGUgKGsgPD0gZSkge1xuICAgICAgICB2YXIgcnMgPSBkZWNvZGVIdWZmbWFuKGNvbXBvbmVudC5odWZmbWFuVGFibGVBQyk7XG4gICAgICAgIHZhciBzID0gcnMgJiAxNSwgciA9IHJzID4+IDQ7XG4gICAgICAgIGlmIChzID09PSAwKSB7XG4gICAgICAgICAgaWYgKHIgPCAxNSkge1xuICAgICAgICAgICAgZW9icnVuID0gcmVjZWl2ZShyKSArICgxIDw8IHIpIC0gMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBrICs9IDE2O1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGsgKz0gcjtcbiAgICAgICAgdmFyIHogPSBkY3RaaWdaYWdba107XG4gICAgICAgIGNvbXBvbmVudC5ibG9ja0RhdGFbb2Zmc2V0ICsgel0gPSByZWNlaXZlQW5kRXh0ZW5kKHMpICogKDEgPDwgc3VjY2Vzc2l2ZSk7XG4gICAgICAgIGsrKztcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgc3VjY2Vzc2l2ZUFDU3RhdGUgPSAwLCBzdWNjZXNzaXZlQUNOZXh0VmFsdWU7XG4gICAgZnVuY3Rpb24gZGVjb2RlQUNTdWNjZXNzaXZlKGNvbXBvbmVudCwgb2Zmc2V0KSB7XG4gICAgICB2YXIgayA9IHNwZWN0cmFsU3RhcnQsIGUgPSBzcGVjdHJhbEVuZCwgciA9IDA7XG4gICAgICB3aGlsZSAoayA8PSBlKSB7XG4gICAgICAgIHZhciB6ID0gZGN0WmlnWmFnW2tdO1xuICAgICAgICBzd2l0Y2ggKHN1Y2Nlc3NpdmVBQ1N0YXRlKSB7XG4gICAgICAgICAgY2FzZSAwOiAvLyBpbml0aWFsIHN0YXRlXG4gICAgICAgICAgICB2YXIgcnMgPSBkZWNvZGVIdWZmbWFuKGNvbXBvbmVudC5odWZmbWFuVGFibGVBQyk7XG4gICAgICAgICAgICB2YXIgcyA9IHJzICYgMTU7XG4gICAgICAgICAgICByID0gcnMgPj4gNDtcbiAgICAgICAgICAgIGlmIChzID09PSAwKSB7XG4gICAgICAgICAgICAgIGlmIChyIDwgMTUpIHtcbiAgICAgICAgICAgICAgICBlb2JydW4gPSByZWNlaXZlKHIpICsgKDEgPDwgcik7XG4gICAgICAgICAgICAgICAgc3VjY2Vzc2l2ZUFDU3RhdGUgPSA0O1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHIgPSAxNjtcbiAgICAgICAgICAgICAgICBzdWNjZXNzaXZlQUNTdGF0ZSA9IDE7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmIChzICE9PSAxKVxuICAgICAgICAgICAgICAgIHRocm93IFwiaW52YWxpZCBBQ24gZW5jb2RpbmdcIjtcbiAgICAgICAgICAgICAgc3VjY2Vzc2l2ZUFDTmV4dFZhbHVlID0gcmVjZWl2ZUFuZEV4dGVuZChzKTtcbiAgICAgICAgICAgICAgc3VjY2Vzc2l2ZUFDU3RhdGUgPSByID8gMiA6IDM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICBjYXNlIDE6IC8vIHNraXBwaW5nIHIgemVybyBpdGVtc1xuICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIGlmIChjb21wb25lbnQuYmxvY2tEYXRhW29mZnNldCArIHpdKSB7XG4gICAgICAgICAgICAgIGNvbXBvbmVudC5ibG9ja0RhdGFbb2Zmc2V0ICsgel0gKz0gKHJlYWRCaXQoKSA8PCBzdWNjZXNzaXZlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHItLTtcbiAgICAgICAgICAgICAgaWYgKHIgPT09IDApXG4gICAgICAgICAgICAgICAgc3VjY2Vzc2l2ZUFDU3RhdGUgPSBzdWNjZXNzaXZlQUNTdGF0ZSA9PSAyID8gMyA6IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDM6IC8vIHNldCB2YWx1ZSBmb3IgYSB6ZXJvIGl0ZW1cbiAgICAgICAgICAgIGlmIChjb21wb25lbnQuYmxvY2tEYXRhW29mZnNldCArIHpdKSB7XG4gICAgICAgICAgICAgIGNvbXBvbmVudC5ibG9ja0RhdGFbb2Zmc2V0ICsgel0gKz0gKHJlYWRCaXQoKSA8PCBzdWNjZXNzaXZlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNvbXBvbmVudC5ibG9ja0RhdGFbb2Zmc2V0ICsgel0gPSBzdWNjZXNzaXZlQUNOZXh0VmFsdWUgPDwgc3VjY2Vzc2l2ZTtcbiAgICAgICAgICAgICAgc3VjY2Vzc2l2ZUFDU3RhdGUgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSA0OiAvLyBlb2JcbiAgICAgICAgICAgIGlmIChjb21wb25lbnQuYmxvY2tEYXRhW29mZnNldCArIHpdKSB7XG4gICAgICAgICAgICAgIGNvbXBvbmVudC5ibG9ja0RhdGFbb2Zmc2V0ICsgel0gKz0gKHJlYWRCaXQoKSA8PCBzdWNjZXNzaXZlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGsrKztcbiAgICAgIH1cbiAgICAgIGlmIChzdWNjZXNzaXZlQUNTdGF0ZSA9PT0gNCkge1xuICAgICAgICBlb2JydW4tLTtcbiAgICAgICAgaWYgKGVvYnJ1biA9PT0gMClcbiAgICAgICAgICBzdWNjZXNzaXZlQUNTdGF0ZSA9IDA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGVjb2RlTWN1KGNvbXBvbmVudCwgZGVjb2RlLCBtY3UsIHJvdywgY29sKSB7XG4gICAgICB2YXIgbWN1Um93ID0gKG1jdSAvIG1jdXNQZXJMaW5lKSB8IDA7XG4gICAgICB2YXIgbWN1Q29sID0gbWN1ICUgbWN1c1BlckxpbmU7XG4gICAgICB2YXIgYmxvY2tSb3cgPSBtY3VSb3cgKiBjb21wb25lbnQudiArIHJvdztcbiAgICAgIHZhciBibG9ja0NvbCA9IG1jdUNvbCAqIGNvbXBvbmVudC5oICsgY29sO1xuICAgICAgdmFyIG9mZnNldCA9IGdldEJsb2NrQnVmZmVyT2Zmc2V0KGNvbXBvbmVudCwgYmxvY2tSb3csIGJsb2NrQ29sKTtcbiAgICAgIGRlY29kZShjb21wb25lbnQsIG9mZnNldCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGVjb2RlQmxvY2soY29tcG9uZW50LCBkZWNvZGUsIG1jdSkge1xuICAgICAgdmFyIGJsb2NrUm93ID0gKG1jdSAvIGNvbXBvbmVudC5ibG9ja3NQZXJMaW5lKSB8IDA7XG4gICAgICB2YXIgYmxvY2tDb2wgPSBtY3UgJSBjb21wb25lbnQuYmxvY2tzUGVyTGluZTtcbiAgICAgIHZhciBvZmZzZXQgPSBnZXRCbG9ja0J1ZmZlck9mZnNldChjb21wb25lbnQsIGJsb2NrUm93LCBibG9ja0NvbCk7XG4gICAgICBkZWNvZGUoY29tcG9uZW50LCBvZmZzZXQpO1xuICAgIH1cblxuICAgIHZhciBjb21wb25lbnRzTGVuZ3RoID0gY29tcG9uZW50cy5sZW5ndGg7XG4gICAgdmFyIGNvbXBvbmVudCwgaSwgaiwgaywgbjtcbiAgICB2YXIgZGVjb2RlRm47XG4gICAgaWYgKHByb2dyZXNzaXZlKSB7XG4gICAgICBpZiAoc3BlY3RyYWxTdGFydCA9PT0gMClcbiAgICAgICAgZGVjb2RlRm4gPSBzdWNjZXNzaXZlUHJldiA9PT0gMCA/IGRlY29kZURDRmlyc3QgOiBkZWNvZGVEQ1N1Y2Nlc3NpdmU7XG4gICAgICBlbHNlXG4gICAgICAgIGRlY29kZUZuID0gc3VjY2Vzc2l2ZVByZXYgPT09IDAgPyBkZWNvZGVBQ0ZpcnN0IDogZGVjb2RlQUNTdWNjZXNzaXZlO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWNvZGVGbiA9IGRlY29kZUJhc2VsaW5lO1xuICAgIH1cblxuICAgIHZhciBtY3UgPSAwLCBtYXJrZXI7XG4gICAgdmFyIG1jdUV4cGVjdGVkO1xuICAgIGlmIChjb21wb25lbnRzTGVuZ3RoID09IDEpIHtcbiAgICAgIG1jdUV4cGVjdGVkID0gY29tcG9uZW50c1swXS5ibG9ja3NQZXJMaW5lICogY29tcG9uZW50c1swXS5ibG9ja3NQZXJDb2x1bW47XG4gICAgfSBlbHNlIHtcbiAgICAgIG1jdUV4cGVjdGVkID0gbWN1c1BlckxpbmUgKiBmcmFtZS5tY3VzUGVyQ29sdW1uO1xuICAgIH1cbiAgICBpZiAoIXJlc2V0SW50ZXJ2YWwpIHtcbiAgICAgIHJlc2V0SW50ZXJ2YWwgPSBtY3VFeHBlY3RlZDtcbiAgICB9XG5cbiAgICB2YXIgaCwgdjtcbiAgICB3aGlsZSAobWN1IDwgbWN1RXhwZWN0ZWQpIHtcbiAgICAgIC8vIHJlc2V0IGludGVydmFsIHN0dWZmXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgY29tcG9uZW50c0xlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbXBvbmVudHNbaV0ucHJlZCA9IDA7XG4gICAgICB9XG4gICAgICBlb2JydW4gPSAwO1xuXG4gICAgICBpZiAoY29tcG9uZW50c0xlbmd0aCA9PSAxKSB7XG4gICAgICAgIGNvbXBvbmVudCA9IGNvbXBvbmVudHNbMF07XG4gICAgICAgIGZvciAobiA9IDA7IG4gPCByZXNldEludGVydmFsOyBuKyspIHtcbiAgICAgICAgICBkZWNvZGVCbG9jayhjb21wb25lbnQsIGRlY29kZUZuLCBtY3UpO1xuICAgICAgICAgIG1jdSsrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKG4gPSAwOyBuIDwgcmVzZXRJbnRlcnZhbDsgbisrKSB7XG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IGNvbXBvbmVudHNMZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29tcG9uZW50ID0gY29tcG9uZW50c1tpXTtcbiAgICAgICAgICAgIGggPSBjb21wb25lbnQuaDtcbiAgICAgICAgICAgIHYgPSBjb21wb25lbnQudjtcbiAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCB2OyBqKyspIHtcbiAgICAgICAgICAgICAgZm9yIChrID0gMDsgayA8IGg7IGsrKykge1xuICAgICAgICAgICAgICAgIGRlY29kZU1jdShjb21wb25lbnQsIGRlY29kZUZuLCBtY3UsIGosIGspO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIG1jdSsrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIGZpbmQgbWFya2VyXG4gICAgICBiaXRzQ291bnQgPSAwO1xuICAgICAgbWFya2VyID0gKGRhdGFbb2Zmc2V0XSA8PCA4KSB8IGRhdGFbb2Zmc2V0ICsgMV07XG4gICAgICBpZiAobWFya2VyIDw9IDB4RkYwMCkge1xuICAgICAgICB0aHJvdyBcIm1hcmtlciB3YXMgbm90IGZvdW5kXCI7XG4gICAgICB9XG5cbiAgICAgIGlmIChtYXJrZXIgPj0gMHhGRkQwICYmIG1hcmtlciA8PSAweEZGRDcpIHsgLy8gUlNUeFxuICAgICAgICBvZmZzZXQgKz0gMjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBvZmZzZXQgLSBzdGFydE9mZnNldDtcbiAgfVxuXG4gIC8vIEEgcG9ydCBvZiBwb3BwbGVyJ3MgSURDVCBtZXRob2Qgd2hpY2ggaW4gdHVybiBpcyB0YWtlbiBmcm9tOlxuICAvLyAgIENocmlzdG9waCBMb2VmZmxlciwgQWRyaWFhbiBMaWd0ZW5iZXJnLCBHZW9yZ2UgUy4gTW9zY2h5dHosXG4gIC8vICAgXCJQcmFjdGljYWwgRmFzdCAxLUQgRENUIEFsZ29yaXRobXMgd2l0aCAxMSBNdWx0aXBsaWNhdGlvbnNcIixcbiAgLy8gICBJRUVFIEludGwuIENvbmYuIG9uIEFjb3VzdGljcywgU3BlZWNoICYgU2lnbmFsIFByb2Nlc3NpbmcsIDE5ODksXG4gIC8vICAgOTg4LTk5MS5cbiAgZnVuY3Rpb24gcXVhbnRpemVBbmRJbnZlcnNlKGNvbXBvbmVudCwgYmxvY2tCdWZmZXJPZmZzZXQsIHApIHtcbiAgICB2YXIgcXQgPSBjb21wb25lbnQucXVhbnRpemF0aW9uVGFibGU7XG4gICAgdmFyIHYwLCB2MSwgdjIsIHYzLCB2NCwgdjUsIHY2LCB2NywgdDtcbiAgICB2YXIgaTtcblxuICAgIC8vIGRlcXVhbnRcbiAgICBmb3IgKGkgPSAwOyBpIDwgNjQ7IGkrKykge1xuICAgICAgcFtpXSA9IGNvbXBvbmVudC5ibG9ja0RhdGFbYmxvY2tCdWZmZXJPZmZzZXQgKyBpXSAqIHF0W2ldO1xuICAgIH1cblxuICAgIC8vIGludmVyc2UgRENUIG9uIHJvd3NcbiAgICBmb3IgKGkgPSAwOyBpIDwgODsgKytpKSB7XG4gICAgICB2YXIgcm93ID0gOCAqIGk7XG5cbiAgICAgIC8vIGNoZWNrIGZvciBhbGwtemVybyBBQyBjb2VmZmljaWVudHNcbiAgICAgIGlmIChwWzEgKyByb3ddID09PSAwICYmIHBbMiArIHJvd10gPT09IDAgJiYgcFszICsgcm93XSA9PT0gMCAmJlxuICAgICAgICBwWzQgKyByb3ddID09PSAwICYmIHBbNSArIHJvd10gPT09IDAgJiYgcFs2ICsgcm93XSA9PT0gMCAmJlxuICAgICAgICBwWzcgKyByb3ddID09PSAwKSB7XG4gICAgICAgIHQgPSAoZGN0U3FydDIgKiBwWzAgKyByb3ddICsgNTEyKSA+PiAxMDtcbiAgICAgICAgcFswICsgcm93XSA9IHQ7XG4gICAgICAgIHBbMSArIHJvd10gPSB0O1xuICAgICAgICBwWzIgKyByb3ddID0gdDtcbiAgICAgICAgcFszICsgcm93XSA9IHQ7XG4gICAgICAgIHBbNCArIHJvd10gPSB0O1xuICAgICAgICBwWzUgKyByb3ddID0gdDtcbiAgICAgICAgcFs2ICsgcm93XSA9IHQ7XG4gICAgICAgIHBbNyArIHJvd10gPSB0O1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gc3RhZ2UgNFxuICAgICAgdjAgPSAoZGN0U3FydDIgKiBwWzAgKyByb3ddICsgMTI4KSA+PiA4O1xuICAgICAgdjEgPSAoZGN0U3FydDIgKiBwWzQgKyByb3ddICsgMTI4KSA+PiA4O1xuICAgICAgdjIgPSBwWzIgKyByb3ddO1xuICAgICAgdjMgPSBwWzYgKyByb3ddO1xuICAgICAgdjQgPSAoZGN0U3FydDFkMiAqIChwWzEgKyByb3ddIC0gcFs3ICsgcm93XSkgKyAxMjgpID4+IDg7XG4gICAgICB2NyA9IChkY3RTcXJ0MWQyICogKHBbMSArIHJvd10gKyBwWzcgKyByb3ddKSArIDEyOCkgPj4gODtcbiAgICAgIHY1ID0gcFszICsgcm93XSA8PCA0O1xuICAgICAgdjYgPSBwWzUgKyByb3ddIDw8IDQ7XG5cbiAgICAgIC8vIHN0YWdlIDNcbiAgICAgIHQgPSAodjAgLSB2MSArIDEpID4+IDE7XG4gICAgICB2MCA9ICh2MCArIHYxICsgMSkgPj4gMTtcbiAgICAgIHYxID0gdDtcbiAgICAgIHQgPSAodjIgKiBkY3RTaW42ICsgdjMgKiBkY3RDb3M2ICsgMTI4KSA+PiA4O1xuICAgICAgdjIgPSAodjIgKiBkY3RDb3M2IC0gdjMgKiBkY3RTaW42ICsgMTI4KSA+PiA4O1xuICAgICAgdjMgPSB0O1xuICAgICAgdCA9ICh2NCAtIHY2ICsgMSkgPj4gMTtcbiAgICAgIHY0ID0gKHY0ICsgdjYgKyAxKSA+PiAxO1xuICAgICAgdjYgPSB0O1xuICAgICAgdCA9ICh2NyArIHY1ICsgMSkgPj4gMTtcbiAgICAgIHY1ID0gKHY3IC0gdjUgKyAxKSA+PiAxO1xuICAgICAgdjcgPSB0O1xuXG4gICAgICAvLyBzdGFnZSAyXG4gICAgICB0ID0gKHYwIC0gdjMgKyAxKSA+PiAxO1xuICAgICAgdjAgPSAodjAgKyB2MyArIDEpID4+IDE7XG4gICAgICB2MyA9IHQ7XG4gICAgICB0ID0gKHYxIC0gdjIgKyAxKSA+PiAxO1xuICAgICAgdjEgPSAodjEgKyB2MiArIDEpID4+IDE7XG4gICAgICB2MiA9IHQ7XG4gICAgICB0ID0gKHY0ICogZGN0U2luMyArIHY3ICogZGN0Q29zMyArIDIwNDgpID4+IDEyO1xuICAgICAgdjQgPSAodjQgKiBkY3RDb3MzIC0gdjcgKiBkY3RTaW4zICsgMjA0OCkgPj4gMTI7XG4gICAgICB2NyA9IHQ7XG4gICAgICB0ID0gKHY1ICogZGN0U2luMSArIHY2ICogZGN0Q29zMSArIDIwNDgpID4+IDEyO1xuICAgICAgdjUgPSAodjUgKiBkY3RDb3MxIC0gdjYgKiBkY3RTaW4xICsgMjA0OCkgPj4gMTI7XG4gICAgICB2NiA9IHQ7XG5cbiAgICAgIC8vIHN0YWdlIDFcbiAgICAgIHBbMCArIHJvd10gPSB2MCArIHY3O1xuICAgICAgcFs3ICsgcm93XSA9IHYwIC0gdjc7XG4gICAgICBwWzEgKyByb3ddID0gdjEgKyB2NjtcbiAgICAgIHBbNiArIHJvd10gPSB2MSAtIHY2O1xuICAgICAgcFsyICsgcm93XSA9IHYyICsgdjU7XG4gICAgICBwWzUgKyByb3ddID0gdjIgLSB2NTtcbiAgICAgIHBbMyArIHJvd10gPSB2MyArIHY0O1xuICAgICAgcFs0ICsgcm93XSA9IHYzIC0gdjQ7XG4gICAgfVxuXG4gICAgLy8gaW52ZXJzZSBEQ1Qgb24gY29sdW1uc1xuICAgIGZvciAoaSA9IDA7IGkgPCA4OyArK2kpIHtcbiAgICAgIHZhciBjb2wgPSBpO1xuXG4gICAgICAvLyBjaGVjayBmb3IgYWxsLXplcm8gQUMgY29lZmZpY2llbnRzXG4gICAgICBpZiAocFsxICogOCArIGNvbF0gPT09IDAgJiYgcFsyICogOCArIGNvbF0gPT09IDAgJiYgcFszICogOCArIGNvbF0gPT09IDAgJiZcbiAgICAgICAgcFs0ICogOCArIGNvbF0gPT09IDAgJiYgcFs1ICogOCArIGNvbF0gPT09IDAgJiYgcFs2ICogOCArIGNvbF0gPT09IDAgJiZcbiAgICAgICAgcFs3ICogOCArIGNvbF0gPT09IDApIHtcbiAgICAgICAgdCA9IChkY3RTcXJ0MiAqIHBbaSArIDBdICsgODE5MikgPj4gMTQ7XG4gICAgICAgIHBbMCAqIDggKyBjb2xdID0gdDtcbiAgICAgICAgcFsxICogOCArIGNvbF0gPSB0O1xuICAgICAgICBwWzIgKiA4ICsgY29sXSA9IHQ7XG4gICAgICAgIHBbMyAqIDggKyBjb2xdID0gdDtcbiAgICAgICAgcFs0ICogOCArIGNvbF0gPSB0O1xuICAgICAgICBwWzUgKiA4ICsgY29sXSA9IHQ7XG4gICAgICAgIHBbNiAqIDggKyBjb2xdID0gdDtcbiAgICAgICAgcFs3ICogOCArIGNvbF0gPSB0O1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gc3RhZ2UgNFxuICAgICAgdjAgPSAoZGN0U3FydDIgKiBwWzAgKiA4ICsgY29sXSArIDIwNDgpID4+IDEyO1xuICAgICAgdjEgPSAoZGN0U3FydDIgKiBwWzQgKiA4ICsgY29sXSArIDIwNDgpID4+IDEyO1xuICAgICAgdjIgPSBwWzIgKiA4ICsgY29sXTtcbiAgICAgIHYzID0gcFs2ICogOCArIGNvbF07XG4gICAgICB2NCA9IChkY3RTcXJ0MWQyICogKHBbMSAqIDggKyBjb2xdIC0gcFs3ICogOCArIGNvbF0pICsgMjA0OCkgPj4gMTI7XG4gICAgICB2NyA9IChkY3RTcXJ0MWQyICogKHBbMSAqIDggKyBjb2xdICsgcFs3ICogOCArIGNvbF0pICsgMjA0OCkgPj4gMTI7XG4gICAgICB2NSA9IHBbMyAqIDggKyBjb2xdO1xuICAgICAgdjYgPSBwWzUgKiA4ICsgY29sXTtcblxuICAgICAgLy8gc3RhZ2UgM1xuICAgICAgdCA9ICh2MCAtIHYxICsgMSkgPj4gMTtcbiAgICAgIHYwID0gKHYwICsgdjEgKyAxKSA+PiAxO1xuICAgICAgdjEgPSB0O1xuICAgICAgdCA9ICh2MiAqIGRjdFNpbjYgKyB2MyAqIGRjdENvczYgKyAyMDQ4KSA+PiAxMjtcbiAgICAgIHYyID0gKHYyICogZGN0Q29zNiAtIHYzICogZGN0U2luNiArIDIwNDgpID4+IDEyO1xuICAgICAgdjMgPSB0O1xuICAgICAgdCA9ICh2NCAtIHY2ICsgMSkgPj4gMTtcbiAgICAgIHY0ID0gKHY0ICsgdjYgKyAxKSA+PiAxO1xuICAgICAgdjYgPSB0O1xuICAgICAgdCA9ICh2NyArIHY1ICsgMSkgPj4gMTtcbiAgICAgIHY1ID0gKHY3IC0gdjUgKyAxKSA+PiAxO1xuICAgICAgdjcgPSB0O1xuXG4gICAgICAvLyBzdGFnZSAyXG4gICAgICB0ID0gKHYwIC0gdjMgKyAxKSA+PiAxO1xuICAgICAgdjAgPSAodjAgKyB2MyArIDEpID4+IDE7XG4gICAgICB2MyA9IHQ7XG4gICAgICB0ID0gKHYxIC0gdjIgKyAxKSA+PiAxO1xuICAgICAgdjEgPSAodjEgKyB2MiArIDEpID4+IDE7XG4gICAgICB2MiA9IHQ7XG4gICAgICB0ID0gKHY0ICogZGN0U2luMyArIHY3ICogZGN0Q29zMyArIDIwNDgpID4+IDEyO1xuICAgICAgdjQgPSAodjQgKiBkY3RDb3MzIC0gdjcgKiBkY3RTaW4zICsgMjA0OCkgPj4gMTI7XG4gICAgICB2NyA9IHQ7XG4gICAgICB0ID0gKHY1ICogZGN0U2luMSArIHY2ICogZGN0Q29zMSArIDIwNDgpID4+IDEyO1xuICAgICAgdjUgPSAodjUgKiBkY3RDb3MxIC0gdjYgKiBkY3RTaW4xICsgMjA0OCkgPj4gMTI7XG4gICAgICB2NiA9IHQ7XG5cbiAgICAgIC8vIHN0YWdlIDFcbiAgICAgIHBbMCAqIDggKyBjb2xdID0gdjAgKyB2NztcbiAgICAgIHBbNyAqIDggKyBjb2xdID0gdjAgLSB2NztcbiAgICAgIHBbMSAqIDggKyBjb2xdID0gdjEgKyB2NjtcbiAgICAgIHBbNiAqIDggKyBjb2xdID0gdjEgLSB2NjtcbiAgICAgIHBbMiAqIDggKyBjb2xdID0gdjIgKyB2NTtcbiAgICAgIHBbNSAqIDggKyBjb2xdID0gdjIgLSB2NTtcbiAgICAgIHBbMyAqIDggKyBjb2xdID0gdjMgKyB2NDtcbiAgICAgIHBbNCAqIDggKyBjb2xdID0gdjMgLSB2NDtcbiAgICB9XG5cbiAgICAvLyBjb252ZXJ0IHRvIDgtYml0IGludGVnZXJzXG4gICAgZm9yIChpID0gMDsgaSA8IDY0OyArK2kpIHtcbiAgICAgIHZhciBpbmRleCA9IGJsb2NrQnVmZmVyT2Zmc2V0ICsgaTtcbiAgICAgIHZhciBxID0gcFtpXTtcbiAgICAgIHEgPSAocSA8PSAtMjA1NiAvIGNvbXBvbmVudC5iaXRDb252ZXJzaW9uKSA/IDAgOlxuICAgICAgICAocSA+PSAyMDI0IC8gY29tcG9uZW50LmJpdENvbnZlcnNpb24pID8gMjU1IC8gY29tcG9uZW50LmJpdENvbnZlcnNpb24gOlxuICAgICAgICAocSArIDIwNTYgLyBjb21wb25lbnQuYml0Q29udmVyc2lvbikgPj4gNDtcbiAgICAgIGNvbXBvbmVudC5ibG9ja0RhdGFbaW5kZXhdID0gcTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBidWlsZENvbXBvbmVudERhdGEoZnJhbWUsIGNvbXBvbmVudCkge1xuICAgIHZhciBsaW5lcyA9IFtdO1xuICAgIHZhciBibG9ja3NQZXJMaW5lID0gY29tcG9uZW50LmJsb2Nrc1BlckxpbmU7XG4gICAgdmFyIGJsb2Nrc1BlckNvbHVtbiA9IGNvbXBvbmVudC5ibG9ja3NQZXJDb2x1bW47XG4gICAgdmFyIHNhbXBsZXNQZXJMaW5lID0gYmxvY2tzUGVyTGluZSA8PCAzO1xuICAgIHZhciBjb21wdXRhdGlvbkJ1ZmZlciA9IG5ldyBJbnQzMkFycmF5KDY0KTtcblxuICAgIHZhciBpLCBqLCBsbCA9IDA7XG4gICAgZm9yICh2YXIgYmxvY2tSb3cgPSAwOyBibG9ja1JvdyA8IGJsb2Nrc1BlckNvbHVtbjsgYmxvY2tSb3crKykge1xuICAgICAgZm9yICh2YXIgYmxvY2tDb2wgPSAwOyBibG9ja0NvbCA8IGJsb2Nrc1BlckxpbmU7IGJsb2NrQ29sKyspIHtcbiAgICAgICAgdmFyIG9mZnNldCA9IGdldEJsb2NrQnVmZmVyT2Zmc2V0KGNvbXBvbmVudCwgYmxvY2tSb3csIGJsb2NrQ29sKTtcbiAgICAgICAgcXVhbnRpemVBbmRJbnZlcnNlKGNvbXBvbmVudCwgb2Zmc2V0LCBjb21wdXRhdGlvbkJ1ZmZlcik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjb21wb25lbnQuYmxvY2tEYXRhO1xuICB9XG5cbiAgZnVuY3Rpb24gY2xhbXBUb1VpbnQ4KGEpIHtcbiAgICByZXR1cm4gYSA8PSAwID8gMCA6IGEgPj0gMjU1ID8gMjU1IDogYSB8IDA7XG4gIH1cblxuICBjb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSB7XG4gICAgbG9hZDogZnVuY3Rpb24gbG9hZChwYXRoKSB7XG4gICAgICB2YXIgaGFuZGxlRGF0YSA9IChmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB0aGlzLnBhcnNlKGRhdGEpO1xuICAgICAgICBpZiAodGhpcy5vbmxvYWQpXG4gICAgICAgICAgdGhpcy5vbmxvYWQoKTtcbiAgICAgIH0pLmJpbmQodGhpcyk7XG5cbiAgICAgIGlmIChwYXRoLmluZGV4T2YoXCJkYXRhOlwiKSA+IC0xKSB7XG4gICAgICAgIHZhciBvZmZzZXQgPSBwYXRoLmluZGV4T2YoXCJiYXNlNjQsXCIpICsgNztcbiAgICAgICAgdmFyIGRhdGEgPSBhdG9iKHBhdGguc3Vic3RyaW5nKG9mZnNldCkpO1xuICAgICAgICB2YXIgYXJyID0gbmV3IFVpbnQ4QXJyYXkoZGF0YS5sZW5ndGgpO1xuICAgICAgICBmb3IgKHZhciBpID0gZGF0YS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIGFycltpXSA9IGRhdGEuY2hhckNvZGVBdChpKTtcbiAgICAgICAgfVxuICAgICAgICBoYW5kbGVEYXRhKGRhdGEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgICB4aHIub3BlbihcIkdFVFwiLCBwYXRoLCB0cnVlKTtcbiAgICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9IFwiYXJyYXlidWZmZXJcIjtcbiAgICAgICAgeGhyLm9ubG9hZCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgLy8gVE9ETyBjYXRjaCBwYXJzZSBlcnJvclxuICAgICAgICAgIHZhciBkYXRhID0gbmV3IFVpbnQ4QXJyYXkoeGhyLnJlc3BvbnNlKTtcbiAgICAgICAgICBoYW5kbGVEYXRhKGRhdGEpO1xuICAgICAgICB9KS5iaW5kKHRoaXMpO1xuICAgICAgICB4aHIuc2VuZChudWxsKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHBhcnNlOiBmdW5jdGlvbiBwYXJzZShkYXRhKSB7XG5cbiAgICAgIGZ1bmN0aW9uIHJlYWRVaW50MTYoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IChkYXRhW29mZnNldF0gPDwgOCkgfCBkYXRhW29mZnNldCArIDFdO1xuICAgICAgICBvZmZzZXQgKz0gMjtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiByZWFkRGF0YUJsb2NrKCkge1xuICAgICAgICB2YXIgbGVuZ3RoID0gcmVhZFVpbnQxNigpO1xuICAgICAgICB2YXIgYXJyYXkgPSBkYXRhLnN1YmFycmF5KG9mZnNldCwgb2Zmc2V0ICsgbGVuZ3RoIC0gMik7XG4gICAgICAgIG9mZnNldCArPSBhcnJheS5sZW5ndGg7XG4gICAgICAgIHJldHVybiBhcnJheTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gcHJlcGFyZUNvbXBvbmVudHMoZnJhbWUpIHtcbiAgICAgICAgdmFyIG1jdXNQZXJMaW5lID0gTWF0aC5jZWlsKGZyYW1lLnNhbXBsZXNQZXJMaW5lIC8gOCAvIGZyYW1lLm1heEgpO1xuICAgICAgICB2YXIgbWN1c1BlckNvbHVtbiA9IE1hdGguY2VpbChmcmFtZS5zY2FuTGluZXMgLyA4IC8gZnJhbWUubWF4Vik7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZnJhbWUuY29tcG9uZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbXBvbmVudCA9IGZyYW1lLmNvbXBvbmVudHNbaV07XG4gICAgICAgICAgdmFyIGJsb2Nrc1BlckxpbmUgPSBNYXRoLmNlaWwoTWF0aC5jZWlsKGZyYW1lLnNhbXBsZXNQZXJMaW5lIC8gOCkgKiBjb21wb25lbnQuaCAvIGZyYW1lLm1heEgpO1xuICAgICAgICAgIHZhciBibG9ja3NQZXJDb2x1bW4gPSBNYXRoLmNlaWwoTWF0aC5jZWlsKGZyYW1lLnNjYW5MaW5lcyAvIDgpICogY29tcG9uZW50LnYgLyBmcmFtZS5tYXhWKTtcbiAgICAgICAgICB2YXIgYmxvY2tzUGVyTGluZUZvck1jdSA9IG1jdXNQZXJMaW5lICogY29tcG9uZW50Lmg7XG4gICAgICAgICAgdmFyIGJsb2Nrc1BlckNvbHVtbkZvck1jdSA9IG1jdXNQZXJDb2x1bW4gKiBjb21wb25lbnQudjtcblxuICAgICAgICAgIHZhciBibG9ja3NCdWZmZXJTaXplID0gNjQgKiBibG9ja3NQZXJDb2x1bW5Gb3JNY3UgKiAoYmxvY2tzUGVyTGluZUZvck1jdSArIDEpO1xuICAgICAgICAgIGNvbXBvbmVudC5ibG9ja0RhdGEgPSBuZXcgSW50MTZBcnJheShibG9ja3NCdWZmZXJTaXplKTtcbiAgICAgICAgICBjb21wb25lbnQuYmxvY2tzUGVyTGluZSA9IGJsb2Nrc1BlckxpbmU7XG4gICAgICAgICAgY29tcG9uZW50LmJsb2Nrc1BlckNvbHVtbiA9IGJsb2Nrc1BlckNvbHVtbjtcbiAgICAgICAgfVxuICAgICAgICBmcmFtZS5tY3VzUGVyTGluZSA9IG1jdXNQZXJMaW5lO1xuICAgICAgICBmcmFtZS5tY3VzUGVyQ29sdW1uID0gbWN1c1BlckNvbHVtbjtcbiAgICAgIH1cblxuICAgICAgdmFyIG9mZnNldCA9IDAsIGxlbmd0aCA9IGRhdGEubGVuZ3RoO1xuICAgICAgdmFyIGpmaWYgPSBudWxsO1xuICAgICAgdmFyIGFkb2JlID0gbnVsbDtcbiAgICAgIHZhciBwaXhlbHMgPSBudWxsO1xuICAgICAgdmFyIGZyYW1lLCByZXNldEludGVydmFsO1xuICAgICAgdmFyIHF1YW50aXphdGlvblRhYmxlcyA9IFtdO1xuICAgICAgdmFyIGh1ZmZtYW5UYWJsZXNBQyA9IFtdLCBodWZmbWFuVGFibGVzREMgPSBbXTtcbiAgICAgIHZhciBmaWxlTWFya2VyID0gcmVhZFVpbnQxNigpO1xuICAgICAgaWYgKGZpbGVNYXJrZXIgIT0gMHhGRkQ4KSB7IC8vIFNPSSAoU3RhcnQgb2YgSW1hZ2UpXG4gICAgICAgIHRocm93IFwiU09JIG5vdCBmb3VuZFwiO1xuICAgICAgfVxuXG4gICAgICBmaWxlTWFya2VyID0gcmVhZFVpbnQxNigpO1xuICAgICAgd2hpbGUgKGZpbGVNYXJrZXIgIT0gMHhGRkQ5KSB7IC8vIEVPSSAoRW5kIG9mIGltYWdlKVxuICAgICAgICB2YXIgaSwgaiwgbDtcbiAgICAgICAgc3dpdGNoIChmaWxlTWFya2VyKSB7XG4gICAgICAgICAgY2FzZSAweEZGRTA6IC8vIEFQUDAgKEFwcGxpY2F0aW9uIFNwZWNpZmljKVxuICAgICAgICAgIGNhc2UgMHhGRkUxOiAvLyBBUFAxXG4gICAgICAgICAgY2FzZSAweEZGRTI6IC8vIEFQUDJcbiAgICAgICAgICBjYXNlIDB4RkZFMzogLy8gQVBQM1xuICAgICAgICAgIGNhc2UgMHhGRkU0OiAvLyBBUFA0XG4gICAgICAgICAgY2FzZSAweEZGRTU6IC8vIEFQUDVcbiAgICAgICAgICBjYXNlIDB4RkZFNjogLy8gQVBQNlxuICAgICAgICAgIGNhc2UgMHhGRkU3OiAvLyBBUFA3XG4gICAgICAgICAgY2FzZSAweEZGRTg6IC8vIEFQUDhcbiAgICAgICAgICBjYXNlIDB4RkZFOTogLy8gQVBQOVxuICAgICAgICAgIGNhc2UgMHhGRkVBOiAvLyBBUFAxMFxuICAgICAgICAgIGNhc2UgMHhGRkVCOiAvLyBBUFAxMVxuICAgICAgICAgIGNhc2UgMHhGRkVDOiAvLyBBUFAxMlxuICAgICAgICAgIGNhc2UgMHhGRkVEOiAvLyBBUFAxM1xuICAgICAgICAgIGNhc2UgMHhGRkVFOiAvLyBBUFAxNFxuICAgICAgICAgIGNhc2UgMHhGRkVGOiAvLyBBUFAxNVxuICAgICAgICAgIGNhc2UgMHhGRkZFOiAvLyBDT00gKENvbW1lbnQpXG4gICAgICAgICAgICB2YXIgYXBwRGF0YSA9IHJlYWREYXRhQmxvY2soKTtcblxuICAgICAgICAgICAgaWYgKGZpbGVNYXJrZXIgPT09IDB4RkZFMCkge1xuICAgICAgICAgICAgICBpZiAoYXBwRGF0YVswXSA9PT0gMHg0QSAmJiBhcHBEYXRhWzFdID09PSAweDQ2ICYmIGFwcERhdGFbMl0gPT09IDB4NDkgJiZcbiAgICAgICAgICAgICAgICBhcHBEYXRhWzNdID09PSAweDQ2ICYmIGFwcERhdGFbNF0gPT09IDApIHsgLy8gJ0pGSUZcXHgwMCdcbiAgICAgICAgICAgICAgICBqZmlmID0ge1xuICAgICAgICAgICAgICAgICAgdmVyc2lvbjoge21ham9yOiBhcHBEYXRhWzVdLCBtaW5vcjogYXBwRGF0YVs2XX0sXG4gICAgICAgICAgICAgICAgICBkZW5zaXR5VW5pdHM6IGFwcERhdGFbN10sXG4gICAgICAgICAgICAgICAgICB4RGVuc2l0eTogKGFwcERhdGFbOF0gPDwgOCkgfCBhcHBEYXRhWzldLFxuICAgICAgICAgICAgICAgICAgeURlbnNpdHk6IChhcHBEYXRhWzEwXSA8PCA4KSB8IGFwcERhdGFbMTFdLFxuICAgICAgICAgICAgICAgICAgdGh1bWJXaWR0aDogYXBwRGF0YVsxMl0sXG4gICAgICAgICAgICAgICAgICB0aHVtYkhlaWdodDogYXBwRGF0YVsxM10sXG4gICAgICAgICAgICAgICAgICB0aHVtYkRhdGE6IGFwcERhdGEuc3ViYXJyYXkoMTQsIDE0ICsgMyAqIGFwcERhdGFbMTJdICogYXBwRGF0YVsxM10pXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVE9ETyBBUFAxIC0gRXhpZlxuICAgICAgICAgICAgaWYgKGZpbGVNYXJrZXIgPT09IDB4RkZFRSkge1xuICAgICAgICAgICAgICBpZiAoYXBwRGF0YVswXSA9PT0gMHg0MSAmJiBhcHBEYXRhWzFdID09PSAweDY0ICYmIGFwcERhdGFbMl0gPT09IDB4NkYgJiZcbiAgICAgICAgICAgICAgICBhcHBEYXRhWzNdID09PSAweDYyICYmIGFwcERhdGFbNF0gPT09IDB4NjUgJiYgYXBwRGF0YVs1XSA9PT0gMCkgeyAvLyAnQWRvYmVcXHgwMCdcbiAgICAgICAgICAgICAgICBhZG9iZSA9IHtcbiAgICAgICAgICAgICAgICAgIHZlcnNpb246IGFwcERhdGFbNl0sXG4gICAgICAgICAgICAgICAgICBmbGFnczA6IChhcHBEYXRhWzddIDw8IDgpIHwgYXBwRGF0YVs4XSxcbiAgICAgICAgICAgICAgICAgIGZsYWdzMTogKGFwcERhdGFbOV0gPDwgOCkgfCBhcHBEYXRhWzEwXSxcbiAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybUNvZGU6IGFwcERhdGFbMTFdXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDB4RkZEQjogLy8gRFFUIChEZWZpbmUgUXVhbnRpemF0aW9uIFRhYmxlcylcbiAgICAgICAgICAgIHZhciBxdWFudGl6YXRpb25UYWJsZXNMZW5ndGggPSByZWFkVWludDE2KCk7XG4gICAgICAgICAgICB2YXIgcXVhbnRpemF0aW9uVGFibGVzRW5kID0gcXVhbnRpemF0aW9uVGFibGVzTGVuZ3RoICsgb2Zmc2V0IC0gMjtcbiAgICAgICAgICAgIHdoaWxlIChvZmZzZXQgPCBxdWFudGl6YXRpb25UYWJsZXNFbmQpIHtcbiAgICAgICAgICAgICAgdmFyIHF1YW50aXphdGlvblRhYmxlU3BlYyA9IGRhdGFbb2Zmc2V0KytdO1xuICAgICAgICAgICAgICB2YXIgdGFibGVEYXRhID0gbmV3IEludDMyQXJyYXkoNjQpO1xuICAgICAgICAgICAgICBpZiAoKHF1YW50aXphdGlvblRhYmxlU3BlYyA+PiA0KSA9PT0gMCkgeyAvLyA4IGJpdCB2YWx1ZXNcbiAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgNjQ7IGorKykge1xuICAgICAgICAgICAgICAgICAgdmFyIHogPSBkY3RaaWdaYWdbal07XG4gICAgICAgICAgICAgICAgICB0YWJsZURhdGFbel0gPSBkYXRhW29mZnNldCsrXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoKHF1YW50aXphdGlvblRhYmxlU3BlYyA+PiA0KSA9PT0gMSkgeyAvLzE2IGJpdFxuICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCA2NDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgenogPSBkY3RaaWdaYWdbal07XG4gICAgICAgICAgICAgICAgICB0YWJsZURhdGFbenpdID0gcmVhZFVpbnQxNigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICAgdGhyb3cgXCJEUVQ6IGludmFsaWQgdGFibGUgc3BlY1wiO1xuICAgICAgICAgICAgICBxdWFudGl6YXRpb25UYWJsZXNbcXVhbnRpemF0aW9uVGFibGVTcGVjICYgMTVdID0gdGFibGVEYXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDB4RkZDMDogLy8gU09GMCAoU3RhcnQgb2YgRnJhbWUsIEJhc2VsaW5lIERDVClcbiAgICAgICAgICBjYXNlIDB4RkZDMTogLy8gU09GMSAoU3RhcnQgb2YgRnJhbWUsIEV4dGVuZGVkIERDVClcbiAgICAgICAgICBjYXNlIDB4RkZDMjogLy8gU09GMiAoU3RhcnQgb2YgRnJhbWUsIFByb2dyZXNzaXZlIERDVClcbiAgICAgICAgICAgIGlmIChmcmFtZSkge1xuICAgICAgICAgICAgICB0aHJvdyBcIk9ubHkgc2luZ2xlIGZyYW1lIEpQRUdzIHN1cHBvcnRlZFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVhZFVpbnQxNigpOyAvLyBza2lwIGRhdGEgbGVuZ3RoXG4gICAgICAgICAgICBmcmFtZSA9IHt9O1xuICAgICAgICAgICAgZnJhbWUuZXh0ZW5kZWQgPSAoZmlsZU1hcmtlciA9PT0gMHhGRkMxKTtcbiAgICAgICAgICAgIGZyYW1lLnByb2dyZXNzaXZlID0gKGZpbGVNYXJrZXIgPT09IDB4RkZDMik7XG4gICAgICAgICAgICBmcmFtZS5wcmVjaXNpb24gPSBkYXRhW29mZnNldCsrXTtcbiAgICAgICAgICAgIGZyYW1lLnNjYW5MaW5lcyA9IHJlYWRVaW50MTYoKTtcbiAgICAgICAgICAgIGZyYW1lLnNhbXBsZXNQZXJMaW5lID0gcmVhZFVpbnQxNigpO1xuICAgICAgICAgICAgZnJhbWUuY29tcG9uZW50cyA9IFtdO1xuICAgICAgICAgICAgZnJhbWUuY29tcG9uZW50SWRzID0ge307XG4gICAgICAgICAgICB2YXIgY29tcG9uZW50c0NvdW50ID0gZGF0YVtvZmZzZXQrK10sIGNvbXBvbmVudElkO1xuICAgICAgICAgICAgdmFyIG1heEggPSAwLCBtYXhWID0gMDtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb21wb25lbnRzQ291bnQ7IGkrKykge1xuICAgICAgICAgICAgICBjb21wb25lbnRJZCA9IGRhdGFbb2Zmc2V0XTtcbiAgICAgICAgICAgICAgdmFyIGggPSBkYXRhW29mZnNldCArIDFdID4+IDQ7XG4gICAgICAgICAgICAgIHZhciB2ID0gZGF0YVtvZmZzZXQgKyAxXSAmIDE1O1xuICAgICAgICAgICAgICBpZiAobWF4SCA8IGgpXG4gICAgICAgICAgICAgICAgbWF4SCA9IGg7XG4gICAgICAgICAgICAgIGlmIChtYXhWIDwgdilcbiAgICAgICAgICAgICAgICBtYXhWID0gdjtcbiAgICAgICAgICAgICAgdmFyIHFJZCA9IGRhdGFbb2Zmc2V0ICsgMl07XG4gICAgICAgICAgICAgIGwgPSBmcmFtZS5jb21wb25lbnRzLnB1c2goe1xuICAgICAgICAgICAgICAgIGg6IGgsXG4gICAgICAgICAgICAgICAgdjogdixcbiAgICAgICAgICAgICAgICBxdWFudGl6YXRpb25UYWJsZTogcXVhbnRpemF0aW9uVGFibGVzW3FJZF0sXG4gICAgICAgICAgICAgICAgcXVhbnRpemF0aW9uVGFibGVJZDogcUlkLFxuICAgICAgICAgICAgICAgIGJpdENvbnZlcnNpb246IDI1NSAvICgoMSA8PCBmcmFtZS5wcmVjaXNpb24pIC0gMSlcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGZyYW1lLmNvbXBvbmVudElkc1tjb21wb25lbnRJZF0gPSBsIC0gMTtcbiAgICAgICAgICAgICAgb2Zmc2V0ICs9IDM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmcmFtZS5tYXhIID0gbWF4SDtcbiAgICAgICAgICAgIGZyYW1lLm1heFYgPSBtYXhWO1xuICAgICAgICAgICAgcHJlcGFyZUNvbXBvbmVudHMoZnJhbWUpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDB4RkZDNDogLy8gREhUIChEZWZpbmUgSHVmZm1hbiBUYWJsZXMpXG4gICAgICAgICAgICB2YXIgaHVmZm1hbkxlbmd0aCA9IHJlYWRVaW50MTYoKTtcbiAgICAgICAgICAgIGZvciAoaSA9IDI7IGkgPCBodWZmbWFuTGVuZ3RoOyApIHtcbiAgICAgICAgICAgICAgdmFyIGh1ZmZtYW5UYWJsZVNwZWMgPSBkYXRhW29mZnNldCsrXTtcbiAgICAgICAgICAgICAgdmFyIGNvZGVMZW5ndGhzID0gbmV3IFVpbnQ4QXJyYXkoMTYpO1xuICAgICAgICAgICAgICB2YXIgY29kZUxlbmd0aFN1bSA9IDA7XG4gICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCAxNjsgaisrLCBvZmZzZXQrKylcbiAgICAgICAgICAgICAgICBjb2RlTGVuZ3RoU3VtICs9IChjb2RlTGVuZ3Roc1tqXSA9IGRhdGFbb2Zmc2V0XSk7XG4gICAgICAgICAgICAgIHZhciBodWZmbWFuVmFsdWVzID0gbmV3IFVpbnQ4QXJyYXkoY29kZUxlbmd0aFN1bSk7XG4gICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBjb2RlTGVuZ3RoU3VtOyBqKyssIG9mZnNldCsrKVxuICAgICAgICAgICAgICAgIGh1ZmZtYW5WYWx1ZXNbal0gPSBkYXRhW29mZnNldF07XG4gICAgICAgICAgICAgIGkgKz0gMTcgKyBjb2RlTGVuZ3RoU3VtO1xuXG4gICAgICAgICAgICAgICgoaHVmZm1hblRhYmxlU3BlYyA+PiA0KSA9PT0gMCA/XG4gICAgICAgICAgICAgICAgaHVmZm1hblRhYmxlc0RDIDogaHVmZm1hblRhYmxlc0FDKVtodWZmbWFuVGFibGVTcGVjICYgMTVdID1cbiAgICAgICAgICAgICAgICBidWlsZEh1ZmZtYW5UYWJsZShjb2RlTGVuZ3RocywgaHVmZm1hblZhbHVlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMHhGRkREOiAvLyBEUkkgKERlZmluZSBSZXN0YXJ0IEludGVydmFsKVxuICAgICAgICAgICAgcmVhZFVpbnQxNigpOyAvLyBza2lwIGRhdGEgbGVuZ3RoXG4gICAgICAgICAgICByZXNldEludGVydmFsID0gcmVhZFVpbnQxNigpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDB4RkZEQTogLy8gU09TIChTdGFydCBvZiBTY2FuKVxuICAgICAgICAgICAgdmFyIHNjYW5MZW5ndGggPSByZWFkVWludDE2KCk7XG4gICAgICAgICAgICB2YXIgc2VsZWN0b3JzQ291bnQgPSBkYXRhW29mZnNldCsrXTtcbiAgICAgICAgICAgIHZhciBjb21wb25lbnRzID0gW10sIGNvbXBvbmVudDtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBzZWxlY3RvcnNDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICAgIHZhciBjb21wb25lbnRJbmRleCA9IGZyYW1lLmNvbXBvbmVudElkc1tkYXRhW29mZnNldCsrXV07XG4gICAgICAgICAgICAgIGNvbXBvbmVudCA9IGZyYW1lLmNvbXBvbmVudHNbY29tcG9uZW50SW5kZXhdO1xuICAgICAgICAgICAgICB2YXIgdGFibGVTcGVjID0gZGF0YVtvZmZzZXQrK107XG4gICAgICAgICAgICAgIGNvbXBvbmVudC5odWZmbWFuVGFibGVEQyA9IGh1ZmZtYW5UYWJsZXNEQ1t0YWJsZVNwZWMgPj4gNF07XG4gICAgICAgICAgICAgIGNvbXBvbmVudC5odWZmbWFuVGFibGVBQyA9IGh1ZmZtYW5UYWJsZXNBQ1t0YWJsZVNwZWMgJiAxNV07XG4gICAgICAgICAgICAgIGNvbXBvbmVudHMucHVzaChjb21wb25lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHNwZWN0cmFsU3RhcnQgPSBkYXRhW29mZnNldCsrXTtcbiAgICAgICAgICAgIHZhciBzcGVjdHJhbEVuZCA9IGRhdGFbb2Zmc2V0KytdO1xuICAgICAgICAgICAgdmFyIHN1Y2Nlc3NpdmVBcHByb3hpbWF0aW9uID0gZGF0YVtvZmZzZXQrK107XG4gICAgICAgICAgICB2YXIgcHJvY2Vzc2VkID0gZGVjb2RlU2NhbihkYXRhLCBvZmZzZXQsXG4gICAgICAgICAgICAgIGZyYW1lLCBjb21wb25lbnRzLCByZXNldEludGVydmFsLFxuICAgICAgICAgICAgICBzcGVjdHJhbFN0YXJ0LCBzcGVjdHJhbEVuZCxcbiAgICAgICAgICAgICAgc3VjY2Vzc2l2ZUFwcHJveGltYXRpb24gPj4gNCwgc3VjY2Vzc2l2ZUFwcHJveGltYXRpb24gJiAxNSk7XG4gICAgICAgICAgICBvZmZzZXQgKz0gcHJvY2Vzc2VkO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGlmIChkYXRhW29mZnNldCAtIDNdID09IDB4RkYgJiZcbiAgICAgICAgICAgICAgZGF0YVtvZmZzZXQgLSAyXSA+PSAweEMwICYmIGRhdGFbb2Zmc2V0IC0gMl0gPD0gMHhGRSkge1xuICAgICAgICAgICAgICAvLyBjb3VsZCBiZSBpbmNvcnJlY3QgZW5jb2RpbmcgLS0gbGFzdCAweEZGIGJ5dGUgb2YgdGhlIHByZXZpb3VzXG4gICAgICAgICAgICAgIC8vIGJsb2NrIHdhcyBlYXRlbiBieSB0aGUgZW5jb2RlclxuICAgICAgICAgICAgICBvZmZzZXQgLT0gMztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBcInVua25vd24gSlBFRyBtYXJrZXIgXCIgKyBmaWxlTWFya2VyLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgfVxuICAgICAgICBmaWxlTWFya2VyID0gcmVhZFVpbnQxNigpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLndpZHRoID0gZnJhbWUuc2FtcGxlc1BlckxpbmU7XG4gICAgICB0aGlzLmhlaWdodCA9IGZyYW1lLnNjYW5MaW5lcztcbiAgICAgIHRoaXMuamZpZiA9IGpmaWY7XG4gICAgICB0aGlzLmFkb2JlID0gYWRvYmU7XG4gICAgICB0aGlzLmNvbXBvbmVudHMgPSBbXTtcbiAgICAgIHN3aXRjaCAoZnJhbWUuY29tcG9uZW50cy5sZW5ndGgpXG4gICAgICB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICB0aGlzLmNvbG9yc3BhY2UgPSBDb2xvclNwYWNlLkdyYXlzY2FsZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIGlmICh0aGlzLmFkb2JlKVxuICAgICAgICAgICAgdGhpcy5jb2xvcnNwYWNlID0gQ29sb3JTcGFjZS5BZG9iZVJHQjtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLmNvbG9yc3BhY2UgPSBDb2xvclNwYWNlLlJHQjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHRoaXMuY29sb3JzcGFjZSA9IENvbG9yU3BhY2UuQ1lNSztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aGlzLmNvbG9yc3BhY2UgPSBDb2xvclNwYWNlLlVua25vd247XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZyYW1lLmNvbXBvbmVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNvbXBvbmVudCA9IGZyYW1lLmNvbXBvbmVudHNbaV07XG4gICAgICAgIGlmICghY29tcG9uZW50LnF1YW50aXphdGlvblRhYmxlICYmIGNvbXBvbmVudC5xdWFudGl6YXRpb25UYWJsZUlkICE9PSBudWxsKVxuICAgICAgICAgIGNvbXBvbmVudC5xdWFudGl6YXRpb25UYWJsZSA9IHF1YW50aXphdGlvblRhYmxlc1tjb21wb25lbnQucXVhbnRpemF0aW9uVGFibGVJZF07XG4gICAgICAgIHRoaXMuY29tcG9uZW50cy5wdXNoKHtcbiAgICAgICAgICBvdXRwdXQ6IGJ1aWxkQ29tcG9uZW50RGF0YShmcmFtZSwgY29tcG9uZW50KSxcbiAgICAgICAgICBzY2FsZVg6IGNvbXBvbmVudC5oIC8gZnJhbWUubWF4SCxcbiAgICAgICAgICBzY2FsZVk6IGNvbXBvbmVudC52IC8gZnJhbWUubWF4VixcbiAgICAgICAgICBibG9ja3NQZXJMaW5lOiBjb21wb25lbnQuYmxvY2tzUGVyTGluZSxcbiAgICAgICAgICBibG9ja3NQZXJDb2x1bW46IGNvbXBvbmVudC5ibG9ja3NQZXJDb2x1bW4sXG4gICAgICAgICAgYml0Q29udmVyc2lvbjogY29tcG9uZW50LmJpdENvbnZlcnNpb25cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBnZXREYXRhMTY6IGZ1bmN0aW9uIGdldERhdGExNih3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICBpZiAodGhpcy5jb21wb25lbnRzLmxlbmd0aCAhPT0gMSlcbiAgICAgICAgdGhyb3cgJ1Vuc3VwcG9ydGVkIGNvbG9yIG1vZGUnO1xuICAgICAgdmFyIHNjYWxlWCA9IHRoaXMud2lkdGggLyB3aWR0aCwgc2NhbGVZID0gdGhpcy5oZWlnaHQgLyBoZWlnaHQ7XG5cbiAgICAgIHZhciBjb21wb25lbnQsIGNvbXBvbmVudFNjYWxlWCwgY29tcG9uZW50U2NhbGVZO1xuICAgICAgdmFyIHgsIHksIGk7XG4gICAgICB2YXIgb2Zmc2V0ID0gMDtcbiAgICAgIHZhciBudW1Db21wb25lbnRzID0gdGhpcy5jb21wb25lbnRzLmxlbmd0aDtcbiAgICAgIHZhciBkYXRhTGVuZ3RoID0gd2lkdGggKiBoZWlnaHQgKiBudW1Db21wb25lbnRzO1xuICAgICAgdmFyIGRhdGEgPSBuZXcgVWludDE2QXJyYXkoZGF0YUxlbmd0aCk7XG4gICAgICB2YXIgY29tcG9uZW50TGluZTtcblxuICAgICAgLy8gbGluZURhdGEgaXMgcmV1c2VkIGZvciBhbGwgY29tcG9uZW50cy4gQXNzdW1lIGZpcnN0IGNvbXBvbmVudCBpc1xuICAgICAgLy8gdGhlIGJpZ2dlc3RcbiAgICAgIHZhciBsaW5lRGF0YSA9IG5ldyBVaW50MTZBcnJheSgodGhpcy5jb21wb25lbnRzWzBdLmJsb2Nrc1BlckxpbmUgPDwgMykgKlxuICAgICAgdGhpcy5jb21wb25lbnRzWzBdLmJsb2Nrc1BlckNvbHVtbiAqIDgpO1xuXG4gICAgICAvLyBGaXJzdCBjb25zdHJ1Y3QgaW1hZ2UgZGF0YSAuLi5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBudW1Db21wb25lbnRzOyBpKyspIHtcbiAgICAgICAgY29tcG9uZW50ID0gdGhpcy5jb21wb25lbnRzW2ldO1xuICAgICAgICB2YXIgYmxvY2tzUGVyTGluZSA9IGNvbXBvbmVudC5ibG9ja3NQZXJMaW5lO1xuICAgICAgICB2YXIgYmxvY2tzUGVyQ29sdW1uID0gY29tcG9uZW50LmJsb2Nrc1BlckNvbHVtbjtcbiAgICAgICAgdmFyIHNhbXBsZXNQZXJMaW5lID0gYmxvY2tzUGVyTGluZSA8PCAzO1xuXG4gICAgICAgIHZhciBqLCBrLCBsbCA9IDA7XG4gICAgICAgIHZhciBsaW5lT2Zmc2V0ID0gMDtcbiAgICAgICAgZm9yICh2YXIgYmxvY2tSb3cgPSAwOyBibG9ja1JvdyA8IGJsb2Nrc1BlckNvbHVtbjsgYmxvY2tSb3crKykge1xuICAgICAgICAgIHZhciBzY2FuTGluZSA9IGJsb2NrUm93IDw8IDM7XG4gICAgICAgICAgZm9yICh2YXIgYmxvY2tDb2wgPSAwOyBibG9ja0NvbCA8IGJsb2Nrc1BlckxpbmU7IGJsb2NrQ29sKyspIHtcbiAgICAgICAgICAgIHZhciBidWZmZXJPZmZzZXQgPSBnZXRCbG9ja0J1ZmZlck9mZnNldChjb21wb25lbnQsIGJsb2NrUm93LCBibG9ja0NvbCk7XG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0gMCwgc2FtcGxlID0gYmxvY2tDb2wgPDwgMztcbiAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCA4OyBqKyspIHtcbiAgICAgICAgICAgICAgdmFyIGxpbmVPZmZzZXQgPSAoc2NhbkxpbmUgKyBqKSAqIHNhbXBsZXNQZXJMaW5lO1xuICAgICAgICAgICAgICBmb3IgKGsgPSAwOyBrIDwgODsgaysrKSB7XG4gICAgICAgICAgICAgICAgbGluZURhdGFbbGluZU9mZnNldCArIHNhbXBsZSArIGtdID1cbiAgICAgICAgICAgICAgICAgIGNvbXBvbmVudC5vdXRwdXRbYnVmZmVyT2Zmc2V0ICsgb2Zmc2V0KytdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29tcG9uZW50U2NhbGVYID0gY29tcG9uZW50LnNjYWxlWCAqIHNjYWxlWDtcbiAgICAgICAgY29tcG9uZW50U2NhbGVZID0gY29tcG9uZW50LnNjYWxlWSAqIHNjYWxlWTtcbiAgICAgICAgb2Zmc2V0ID0gaTtcblxuICAgICAgICB2YXIgY3gsIGN5O1xuICAgICAgICB2YXIgaW5kZXg7XG4gICAgICAgIGZvciAoeSA9IDA7IHkgPCBoZWlnaHQ7IHkrKykge1xuICAgICAgICAgIGZvciAoeCA9IDA7IHggPCB3aWR0aDsgeCsrKSB7XG4gICAgICAgICAgICBjeSA9IDAgfCAoeSAqIGNvbXBvbmVudFNjYWxlWSk7XG4gICAgICAgICAgICBjeCA9IDAgfCAoeCAqIGNvbXBvbmVudFNjYWxlWCk7XG4gICAgICAgICAgICBpbmRleCA9IGN5ICogc2FtcGxlc1BlckxpbmUgKyBjeDtcbiAgICAgICAgICAgIGRhdGFbb2Zmc2V0XSA9IGxpbmVEYXRhW2luZGV4XTtcbiAgICAgICAgICAgIG9mZnNldCArPSBudW1Db21wb25lbnRzO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfSxcbiAgICBnZXREYXRhOiBmdW5jdGlvbiBnZXREYXRhKHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgIHZhciBzY2FsZVggPSB0aGlzLndpZHRoIC8gd2lkdGgsIHNjYWxlWSA9IHRoaXMuaGVpZ2h0IC8gaGVpZ2h0O1xuXG4gICAgICB2YXIgY29tcG9uZW50LCBjb21wb25lbnRTY2FsZVgsIGNvbXBvbmVudFNjYWxlWTtcbiAgICAgIHZhciB4LCB5LCBpO1xuICAgICAgdmFyIG9mZnNldCA9IDA7XG4gICAgICB2YXIgWSwgQ2IsIENyLCBLLCBDLCBNLCBZZSwgUiwgRywgQjtcbiAgICAgIHZhciBjb2xvclRyYW5zZm9ybTtcbiAgICAgIHZhciBudW1Db21wb25lbnRzID0gdGhpcy5jb21wb25lbnRzLmxlbmd0aDtcbiAgICAgIHZhciBkYXRhTGVuZ3RoID0gd2lkdGggKiBoZWlnaHQgKiBudW1Db21wb25lbnRzO1xuICAgICAgdmFyIGRhdGEgPSBuZXcgVWludDhBcnJheShkYXRhTGVuZ3RoKTtcbiAgICAgIHZhciBjb21wb25lbnRMaW5lO1xuXG4gICAgICAvLyBsaW5lRGF0YSBpcyByZXVzZWQgZm9yIGFsbCBjb21wb25lbnRzLiBBc3N1bWUgZmlyc3QgY29tcG9uZW50IGlzXG4gICAgICAvLyB0aGUgYmlnZ2VzdFxuICAgICAgdmFyIGxpbmVEYXRhID0gbmV3IFVpbnQ4QXJyYXkoKHRoaXMuY29tcG9uZW50c1swXS5ibG9ja3NQZXJMaW5lIDw8IDMpICpcbiAgICAgIHRoaXMuY29tcG9uZW50c1swXS5ibG9ja3NQZXJDb2x1bW4gKiA4KTtcblxuICAgICAgLy8gRmlyc3QgY29uc3RydWN0IGltYWdlIGRhdGEgLi4uXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbnVtQ29tcG9uZW50czsgaSsrKSB7XG4gICAgICAgIGNvbXBvbmVudCA9IHRoaXMuY29tcG9uZW50c1tpXTtcbiAgICAgICAgdmFyIGJsb2Nrc1BlckxpbmUgPSBjb21wb25lbnQuYmxvY2tzUGVyTGluZTtcbiAgICAgICAgdmFyIGJsb2Nrc1BlckNvbHVtbiA9IGNvbXBvbmVudC5ibG9ja3NQZXJDb2x1bW47XG4gICAgICAgIHZhciBzYW1wbGVzUGVyTGluZSA9IGJsb2Nrc1BlckxpbmUgPDwgMztcblxuICAgICAgICB2YXIgaiwgaywgbGwgPSAwO1xuICAgICAgICB2YXIgbGluZU9mZnNldCA9IDA7XG4gICAgICAgIGZvciAodmFyIGJsb2NrUm93ID0gMDsgYmxvY2tSb3cgPCBibG9ja3NQZXJDb2x1bW47IGJsb2NrUm93KyspIHtcbiAgICAgICAgICB2YXIgc2NhbkxpbmUgPSBibG9ja1JvdyA8PCAzO1xuICAgICAgICAgIGZvciAodmFyIGJsb2NrQ29sID0gMDsgYmxvY2tDb2wgPCBibG9ja3NQZXJMaW5lOyBibG9ja0NvbCsrKSB7XG4gICAgICAgICAgICB2YXIgYnVmZmVyT2Zmc2V0ID0gZ2V0QmxvY2tCdWZmZXJPZmZzZXQoY29tcG9uZW50LCBibG9ja1JvdywgYmxvY2tDb2wpO1xuICAgICAgICAgICAgdmFyIG9mZnNldCA9IDAsIHNhbXBsZSA9IGJsb2NrQ29sIDw8IDM7XG4gICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgODsgaisrKSB7XG4gICAgICAgICAgICAgIHZhciBsaW5lT2Zmc2V0ID0gKHNjYW5MaW5lICsgaikgKiBzYW1wbGVzUGVyTGluZTtcbiAgICAgICAgICAgICAgZm9yIChrID0gMDsgayA8IDg7IGsrKykge1xuICAgICAgICAgICAgICAgIGxpbmVEYXRhW2xpbmVPZmZzZXQgKyBzYW1wbGUgKyBrXSA9XG4gICAgICAgICAgICAgICAgICBjb21wb25lbnQub3V0cHV0W2J1ZmZlck9mZnNldCArIG9mZnNldCsrXSAqIGNvbXBvbmVudC5iaXRDb252ZXJzaW9uO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29tcG9uZW50U2NhbGVYID0gY29tcG9uZW50LnNjYWxlWCAqIHNjYWxlWDtcbiAgICAgICAgY29tcG9uZW50U2NhbGVZID0gY29tcG9uZW50LnNjYWxlWSAqIHNjYWxlWTtcbiAgICAgICAgb2Zmc2V0ID0gaTtcblxuICAgICAgICB2YXIgY3gsIGN5O1xuICAgICAgICB2YXIgaW5kZXg7XG4gICAgICAgIGZvciAoeSA9IDA7IHkgPCBoZWlnaHQ7IHkrKykge1xuICAgICAgICAgIGZvciAoeCA9IDA7IHggPCB3aWR0aDsgeCsrKSB7XG4gICAgICAgICAgICBjeSA9IDAgfCAoeSAqIGNvbXBvbmVudFNjYWxlWSk7XG4gICAgICAgICAgICBjeCA9IDAgfCAoeCAqIGNvbXBvbmVudFNjYWxlWCk7XG4gICAgICAgICAgICBpbmRleCA9IGN5ICogc2FtcGxlc1BlckxpbmUgKyBjeDtcbiAgICAgICAgICAgIGRhdGFbb2Zmc2V0XSA9IGxpbmVEYXRhW2luZGV4XTtcbiAgICAgICAgICAgIG9mZnNldCArPSBudW1Db21wb25lbnRzO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyAuLi4gdGhlbiB0cmFuc2Zvcm0gY29sb3JzLCBpZiBuZWNlc3NhcnlcbiAgICAgIHN3aXRjaCAobnVtQ29tcG9uZW50cykge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgLy8gbm8gY29sb3IgY29udmVyc2lvbiBmb3Igb25lIG9yIHR3byBjb21wb2VuZW50c1xuXG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAvLyBUaGUgZGVmYXVsdCB0cmFuc2Zvcm0gZm9yIHRocmVlIGNvbXBvbmVudHMgaXMgdHJ1ZVxuICAgICAgICAgIGNvbG9yVHJhbnNmb3JtID0gdHJ1ZTtcbiAgICAgICAgICAvLyBUaGUgYWRvYmUgdHJhbnNmb3JtIG1hcmtlciBvdmVycmlkZXMgYW55IHByZXZpb3VzIHNldHRpbmdcbiAgICAgICAgICBpZiAodGhpcy5hZG9iZSAmJiB0aGlzLmFkb2JlLnRyYW5zZm9ybUNvZGUpXG4gICAgICAgICAgICBjb2xvclRyYW5zZm9ybSA9IHRydWU7XG4gICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHRoaXMuY29sb3JUcmFuc2Zvcm0gIT09ICd1bmRlZmluZWQnKVxuICAgICAgICAgICAgY29sb3JUcmFuc2Zvcm0gPSAhIXRoaXMuY29sb3JUcmFuc2Zvcm07XG5cbiAgICAgICAgICBpZiAoY29sb3JUcmFuc2Zvcm0pIHtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBkYXRhTGVuZ3RoOyBpICs9IG51bUNvbXBvbmVudHMpIHtcbiAgICAgICAgICAgICAgWSA9IGRhdGFbaSAgICBdO1xuICAgICAgICAgICAgICBDYiA9IGRhdGFbaSArIDFdO1xuICAgICAgICAgICAgICBDciA9IGRhdGFbaSArIDJdO1xuXG4gICAgICAgICAgICAgIFIgPSBjbGFtcFRvVWludDgoWSAtIDE3OS40NTYgKyAxLjQwMiAqIENyKTtcbiAgICAgICAgICAgICAgRyA9IGNsYW1wVG9VaW50OChZICsgMTM1LjQ1OSAtIDAuMzQ0ICogQ2IgLSAwLjcxNCAqIENyKTtcbiAgICAgICAgICAgICAgQiA9IGNsYW1wVG9VaW50OChZIC0gMjI2LjgxNiArIDEuNzcyICogQ2IpO1xuXG4gICAgICAgICAgICAgIGRhdGFbaSAgICBdID0gUjtcbiAgICAgICAgICAgICAgZGF0YVtpICsgMV0gPSBHO1xuICAgICAgICAgICAgICBkYXRhW2kgKyAyXSA9IEI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgaWYgKCF0aGlzLmFkb2JlKVxuICAgICAgICAgICAgdGhyb3cgJ1Vuc3VwcG9ydGVkIGNvbG9yIG1vZGUgKDQgY29tcG9uZW50cyknO1xuICAgICAgICAgIC8vIFRoZSBkZWZhdWx0IHRyYW5zZm9ybSBmb3IgZm91ciBjb21wb25lbnRzIGlzIGZhbHNlXG4gICAgICAgICAgY29sb3JUcmFuc2Zvcm0gPSBmYWxzZTtcbiAgICAgICAgICAvLyBUaGUgYWRvYmUgdHJhbnNmb3JtIG1hcmtlciBvdmVycmlkZXMgYW55IHByZXZpb3VzIHNldHRpbmdcbiAgICAgICAgICBpZiAodGhpcy5hZG9iZSAmJiB0aGlzLmFkb2JlLnRyYW5zZm9ybUNvZGUpXG4gICAgICAgICAgICBjb2xvclRyYW5zZm9ybSA9IHRydWU7XG4gICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHRoaXMuY29sb3JUcmFuc2Zvcm0gIT09ICd1bmRlZmluZWQnKVxuICAgICAgICAgICAgY29sb3JUcmFuc2Zvcm0gPSAhIXRoaXMuY29sb3JUcmFuc2Zvcm07XG5cbiAgICAgICAgICBpZiAoY29sb3JUcmFuc2Zvcm0pIHtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBkYXRhTGVuZ3RoOyBpICs9IG51bUNvbXBvbmVudHMpIHtcbiAgICAgICAgICAgICAgWSA9IGRhdGFbaV07XG4gICAgICAgICAgICAgIENiID0gZGF0YVtpICsgMV07XG4gICAgICAgICAgICAgIENyID0gZGF0YVtpICsgMl07XG5cbiAgICAgICAgICAgICAgQyA9IGNsYW1wVG9VaW50OCg0MzQuNDU2IC0gWSAtIDEuNDAyICogQ3IpO1xuICAgICAgICAgICAgICBNID0gY2xhbXBUb1VpbnQ4KDExOS41NDEgLSBZICsgMC4zNDQgKiBDYiArIDAuNzE0ICogQ3IpO1xuICAgICAgICAgICAgICBZID0gY2xhbXBUb1VpbnQ4KDQ4MS44MTYgLSBZIC0gMS43NzIgKiBDYik7XG5cbiAgICAgICAgICAgICAgZGF0YVtpICAgIF0gPSBDO1xuICAgICAgICAgICAgICBkYXRhW2kgKyAxXSA9IE07XG4gICAgICAgICAgICAgIGRhdGFbaSArIDJdID0gWTtcbiAgICAgICAgICAgICAgLy8gSyBpcyB1bmNoYW5nZWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgJ1Vuc3VwcG9ydGVkIGNvbG9yIG1vZGUnO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBjb25zdHJ1Y3Rvcjtcbn0pKCk7XG5cbnZhciBtb2R1bGVUeXBlID0gdHlwZW9mIG1vZHVsZTtcbmlmICgobW9kdWxlVHlwZSAhPT0gJ3VuZGVmaW5lZCcpICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBKcGVnSW1hZ2U7XG59IiwiLyohIGltYWdlLUpQRUcyMDAwIC0gdjAuMy4xIC0gMjAxNS0wOC0yNiB8IGh0dHBzOi8vZ2l0aHViLmNvbS9PSElGL2ltYWdlLUpQRUcyMDAwICovXG4vKiAtKi0gTW9kZTogSmF2YTsgdGFiLXdpZHRoOiAyOyBpbmRlbnQtdGFicy1tb2RlOiBuaWw7IGMtYmFzaWMtb2Zmc2V0OiAyIC0qLSAqL1xuLyogdmltOiBzZXQgc2hpZnR3aWR0aD0yIHRhYnN0b3A9MiBhdXRvaW5kZW50IGNpbmRlbnQgZXhwYW5kdGFiOiAqL1xuLyogQ29weXJpZ2h0IDIwMTIgTW96aWxsYSBGb3VuZGF0aW9uXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKiBnbG9iYWxzIEFyaXRobWV0aWNEZWNvZGVyLCBnbG9iYWxTY29wZSwgbG9nMiwgcmVhZFVpbnQxNiwgcmVhZFVpbnQzMixcbiAgICAgICAgICAgaW5mbywgd2FybiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBKcHhJbWFnZSA9IChmdW5jdGlvbiBKcHhJbWFnZUNsb3N1cmUoKSB7XG4gIC8vIFRhYmxlIEUuMVxuICB2YXIgU3ViYmFuZHNHYWluTG9nMiA9IHtcbiAgICAnTEwnOiAwLFxuICAgICdMSCc6IDEsXG4gICAgJ0hMJzogMSxcbiAgICAnSEgnOiAyXG4gIH07XG4gIGZ1bmN0aW9uIEpweEltYWdlKCkge1xuICAgIHRoaXMuZmFpbE9uQ29ycnVwdGVkSW1hZ2UgPSBmYWxzZTtcbiAgfVxuICBKcHhJbWFnZS5wcm90b3R5cGUgPSB7XG4gICAgcGFyc2U6IGZ1bmN0aW9uIEpweEltYWdlX3BhcnNlKGRhdGEpIHtcblxuICAgICAgdmFyIGhlYWQgPSByZWFkVWludDE2KGRhdGEsIDApO1xuICAgICAgLy8gTm8gYm94IGhlYWRlciwgaW1tZWRpYXRlIHN0YXJ0IG9mIGNvZGVzdHJlYW0gKFNPQylcbiAgICAgIGlmIChoZWFkID09PSAweEZGNEYpIHtcbiAgICAgICAgdGhpcy5wYXJzZUNvZGVzdHJlYW0oZGF0YSwgMCwgZGF0YS5sZW5ndGgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBwb3NpdGlvbiA9IDAsIGxlbmd0aCA9IGRhdGEubGVuZ3RoO1xuICAgICAgd2hpbGUgKHBvc2l0aW9uIDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBoZWFkZXJTaXplID0gODtcbiAgICAgICAgdmFyIGxib3ggPSByZWFkVWludDMyKGRhdGEsIHBvc2l0aW9uKTtcbiAgICAgICAgdmFyIHRib3ggPSByZWFkVWludDMyKGRhdGEsIHBvc2l0aW9uICsgNCk7XG4gICAgICAgIHBvc2l0aW9uICs9IGhlYWRlclNpemU7XG4gICAgICAgIGlmIChsYm94ID09PSAxKSB7XG4gICAgICAgICAgLy8gWExCb3g6IHJlYWQgVUludDY0IGFjY29yZGluZyB0byBzcGVjLlxuICAgICAgICAgIC8vIEphdmFTY3JpcHQncyBpbnQgcHJlY2lzaW9uIG9mIDUzIGJpdCBzaG91bGQgYmUgc3VmZmljaWVudCBoZXJlLlxuICAgICAgICAgIGxib3ggPSByZWFkVWludDMyKGRhdGEsIHBvc2l0aW9uKSAqIDQyOTQ5NjcyOTYgK1xuICAgICAgICAgICAgICAgICByZWFkVWludDMyKGRhdGEsIHBvc2l0aW9uICsgNCk7XG4gICAgICAgICAgcG9zaXRpb24gKz0gODtcbiAgICAgICAgICBoZWFkZXJTaXplICs9IDg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxib3ggPT09IDApIHtcbiAgICAgICAgICBsYm94ID0gbGVuZ3RoIC0gcG9zaXRpb24gKyBoZWFkZXJTaXplO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsYm94IDwgaGVhZGVyU2l6ZSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSlBYIEVycm9yOiBJbnZhbGlkIGJveCBmaWVsZCBzaXplJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRhdGFMZW5ndGggPSBsYm94IC0gaGVhZGVyU2l6ZTtcbiAgICAgICAgdmFyIGp1bXBEYXRhTGVuZ3RoID0gdHJ1ZTtcbiAgICAgICAgc3dpdGNoICh0Ym94KSB7XG4gICAgICAgICAgY2FzZSAweDZBNzAzMjY4OiAvLyAnanAyaCdcbiAgICAgICAgICAgIGp1bXBEYXRhTGVuZ3RoID0gZmFsc2U7IC8vIHBhcnNpbmcgY2hpbGQgYm94ZXNcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMHg2MzZGNkM3MjogLy8gJ2NvbHInXG4gICAgICAgICAgICAvLyBDb2xvcnNwYWNlcyBhcmUgbm90IHVzZWQsIHRoZSBDUyBmcm9tIHRoZSBQREYgaXMgdXNlZC5cbiAgICAgICAgICAgIHZhciBtZXRob2QgPSBkYXRhW3Bvc2l0aW9uXTtcbiAgICAgICAgICAgIHZhciBwcmVjZWRlbmNlID0gZGF0YVtwb3NpdGlvbiArIDFdO1xuICAgICAgICAgICAgdmFyIGFwcHJveGltYXRpb24gPSBkYXRhW3Bvc2l0aW9uICsgMl07XG4gICAgICAgICAgICBpZiAobWV0aG9kID09PSAxKSB7XG4gICAgICAgICAgICAgIC8vIGVudW1lcmF0ZWQgY29sb3JzcGFjZVxuICAgICAgICAgICAgICB2YXIgY29sb3JzcGFjZSA9IHJlYWRVaW50MzIoZGF0YSwgcG9zaXRpb24gKyAzKTtcbiAgICAgICAgICAgICAgc3dpdGNoIChjb2xvcnNwYWNlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxNjogLy8gdGhpcyBpbmRpY2F0ZXMgYSBzUkdCIGNvbG9yc3BhY2VcbiAgICAgICAgICAgICAgICBjYXNlIDE3OiAvLyB0aGlzIGluZGljYXRlcyBhIGdyYXlzY2FsZSBjb2xvcnNwYWNlXG4gICAgICAgICAgICAgICAgY2FzZSAxODogLy8gdGhpcyBpbmRpY2F0ZXMgYSBZVVYgY29sb3JzcGFjZVxuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgIHdhcm4oJ1Vua25vd24gY29sb3JzcGFjZSAnICsgY29sb3JzcGFjZSk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChtZXRob2QgPT09IDIpIHtcbiAgICAgICAgICAgICAgaW5mbygnSUNDIHByb2ZpbGUgbm90IHN1cHBvcnRlZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAweDZBNzAzMjYzOiAvLyAnanAyYydcbiAgICAgICAgICAgIHRoaXMucGFyc2VDb2Rlc3RyZWFtKGRhdGEsIHBvc2l0aW9uLCBwb3NpdGlvbiArIGRhdGFMZW5ndGgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAweDZBNTAyMDIwOiAvLyAnalBcXDAyNFxcMDI0J1xuICAgICAgICAgICAgaWYgKDB4MGQwYTg3MGEgIT09IHJlYWRVaW50MzIoZGF0YSwgcG9zaXRpb24pKSB7XG4gICAgICAgICAgICAgIHdhcm4oJ0ludmFsaWQgSlAyIHNpZ25hdHVyZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgLy8gVGhlIGZvbGxvd2luZyBoZWFkZXIgdHlwZXMgYXJlIHZhbGlkIGJ1dCBjdXJyZW50bHkgbm90IHVzZWQ6XG4gICAgICAgICAgY2FzZSAweDZBNTAxQTFBOiAvLyAnalBcXDAzMlxcMDMyJ1xuICAgICAgICAgIGNhc2UgMHg2Njc0Nzk3MDogLy8gJ2Z0eXAnXG4gICAgICAgICAgY2FzZSAweDcyNzI2NTcxOiAvLyAncnJlcSdcbiAgICAgICAgICBjYXNlIDB4NzI2NTczMjA6IC8vICdyZXMgJ1xuICAgICAgICAgIGNhc2UgMHg2OTY4NjQ3MjogLy8gJ2loZHInXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdmFyIGhlYWRlclR5cGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKCh0Ym94ID4+IDI0KSAmIDB4RkYsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHRib3ggPj4gMTYpICYgMHhGRixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAodGJveCA+PiA4KSAmIDB4RkYsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGJveCAmIDB4RkYpO1xuICAgICAgICAgICAgd2FybignVW5zdXBwb3J0ZWQgaGVhZGVyIHR5cGUgJyArIHRib3ggKyAnICgnICsgaGVhZGVyVHlwZSArICcpJyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoanVtcERhdGFMZW5ndGgpIHtcbiAgICAgICAgICBwb3NpdGlvbiArPSBkYXRhTGVuZ3RoO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBwYXJzZUltYWdlUHJvcGVydGllczogZnVuY3Rpb24gSnB4SW1hZ2VfcGFyc2VJbWFnZVByb3BlcnRpZXMoc3RyZWFtKSB7XG4gICAgICB2YXIgbmV3Qnl0ZSA9IHN0cmVhbS5nZXRCeXRlKCk7XG4gICAgICB3aGlsZSAobmV3Qnl0ZSA+PSAwKSB7XG4gICAgICAgIHZhciBvbGRCeXRlID0gbmV3Qnl0ZTtcbiAgICAgICAgbmV3Qnl0ZSA9IHN0cmVhbS5nZXRCeXRlKCk7XG4gICAgICAgIHZhciBjb2RlID0gKG9sZEJ5dGUgPDwgOCkgfCBuZXdCeXRlO1xuICAgICAgICAvLyBJbWFnZSBhbmQgdGlsZSBzaXplIChTSVopXG4gICAgICAgIGlmIChjb2RlID09PSAweEZGNTEpIHtcbiAgICAgICAgICBzdHJlYW0uc2tpcCg0KTtcbiAgICAgICAgICB2YXIgWHNpeiA9IHN0cmVhbS5nZXRJbnQzMigpID4+PiAwOyAvLyBCeXRlIDRcbiAgICAgICAgICB2YXIgWXNpeiA9IHN0cmVhbS5nZXRJbnQzMigpID4+PiAwOyAvLyBCeXRlIDhcbiAgICAgICAgICB2YXIgWE9zaXogPSBzdHJlYW0uZ2V0SW50MzIoKSA+Pj4gMDsgLy8gQnl0ZSAxMlxuICAgICAgICAgIHZhciBZT3NpeiA9IHN0cmVhbS5nZXRJbnQzMigpID4+PiAwOyAvLyBCeXRlIDE2XG4gICAgICAgICAgc3RyZWFtLnNraXAoMTYpO1xuICAgICAgICAgIHZhciBDc2l6ID0gc3RyZWFtLmdldFVpbnQxNigpOyAvLyBCeXRlIDM2XG4gICAgICAgICAgdGhpcy53aWR0aCA9IFhzaXogLSBYT3NpejtcbiAgICAgICAgICB0aGlzLmhlaWdodCA9IFlzaXogLSBZT3NpejtcbiAgICAgICAgICB0aGlzLmNvbXBvbmVudHNDb3VudCA9IENzaXo7XG4gICAgICAgICAgLy8gUmVzdWx0cyBhcmUgYWx3YXlzIHJldHVybmVkIGFzIFVpbnQ4QXJyYXlzXG4gICAgICAgICAgdGhpcy5iaXRzUGVyQ29tcG9uZW50ID0gODtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBFcnJvcignSlBYIEVycm9yOiBObyBzaXplIG1hcmtlciBmb3VuZCBpbiBKUFggc3RyZWFtJyk7XG4gICAgfSxcbiAgICBwYXJzZUNvZGVzdHJlYW06IGZ1bmN0aW9uIEpweEltYWdlX3BhcnNlQ29kZXN0cmVhbShkYXRhLCBzdGFydCwgZW5kKSB7XG4gICAgICB2YXIgY29udGV4dCA9IHt9O1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIGRvTm90UmVjb3ZlciA9IGZhbHNlO1xuICAgICAgICB2YXIgcG9zaXRpb24gPSBzdGFydDtcbiAgICAgICAgd2hpbGUgKHBvc2l0aW9uICsgMSA8IGVuZCkge1xuICAgICAgICAgIHZhciBjb2RlID0gcmVhZFVpbnQxNihkYXRhLCBwb3NpdGlvbik7XG4gICAgICAgICAgcG9zaXRpb24gKz0gMjtcblxuICAgICAgICAgIHZhciBsZW5ndGggPSAwLCBqLCBzcWNkLCBzcHFjZHMsIHNwcWNkU2l6ZSwgc2NhbGFyRXhwb3VuZGVkLCB0aWxlO1xuICAgICAgICAgIHN3aXRjaCAoY29kZSkge1xuICAgICAgICAgICAgY2FzZSAweEZGNEY6IC8vIFN0YXJ0IG9mIGNvZGVzdHJlYW0gKFNPQylcbiAgICAgICAgICAgICAgY29udGV4dC5tYWluSGVhZGVyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDB4RkZEOTogLy8gRW5kIG9mIGNvZGVzdHJlYW0gKEVPQylcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDB4RkY1MTogLy8gSW1hZ2UgYW5kIHRpbGUgc2l6ZSAoU0laKVxuICAgICAgICAgICAgICBsZW5ndGggPSByZWFkVWludDE2KGRhdGEsIHBvc2l0aW9uKTtcbiAgICAgICAgICAgICAgdmFyIHNpeiA9IHt9O1xuICAgICAgICAgICAgICBzaXouWHNpeiA9IHJlYWRVaW50MzIoZGF0YSwgcG9zaXRpb24gKyA0KTtcbiAgICAgICAgICAgICAgc2l6LllzaXogPSByZWFkVWludDMyKGRhdGEsIHBvc2l0aW9uICsgOCk7XG4gICAgICAgICAgICAgIHNpei5YT3NpeiA9IHJlYWRVaW50MzIoZGF0YSwgcG9zaXRpb24gKyAxMik7XG4gICAgICAgICAgICAgIHNpei5ZT3NpeiA9IHJlYWRVaW50MzIoZGF0YSwgcG9zaXRpb24gKyAxNik7XG4gICAgICAgICAgICAgIHNpei5YVHNpeiA9IHJlYWRVaW50MzIoZGF0YSwgcG9zaXRpb24gKyAyMCk7XG4gICAgICAgICAgICAgIHNpei5ZVHNpeiA9IHJlYWRVaW50MzIoZGF0YSwgcG9zaXRpb24gKyAyNCk7XG4gICAgICAgICAgICAgIHNpei5YVE9zaXogPSByZWFkVWludDMyKGRhdGEsIHBvc2l0aW9uICsgMjgpO1xuICAgICAgICAgICAgICBzaXouWVRPc2l6ID0gcmVhZFVpbnQzMihkYXRhLCBwb3NpdGlvbiArIDMyKTtcbiAgICAgICAgICAgICAgdmFyIGNvbXBvbmVudHNDb3VudCA9IHJlYWRVaW50MTYoZGF0YSwgcG9zaXRpb24gKyAzNik7XG4gICAgICAgICAgICAgIHNpei5Dc2l6ID0gY29tcG9uZW50c0NvdW50O1xuICAgICAgICAgICAgICB2YXIgY29tcG9uZW50cyA9IFtdO1xuICAgICAgICAgICAgICBqID0gcG9zaXRpb24gKyAzODtcbiAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb21wb25lbnRzQ291bnQ7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBjb21wb25lbnQgPSB7XG4gICAgICAgICAgICAgICAgICBwcmVjaXNpb246IChkYXRhW2pdICYgMHg3RikgKyAxLFxuICAgICAgICAgICAgICAgICAgaXNTaWduZWQ6ICEhKGRhdGFbal0gJiAweDgwKSxcbiAgICAgICAgICAgICAgICAgIFhSc2l6OiBkYXRhW2ogKyAxXSxcbiAgICAgICAgICAgICAgICAgIFlSc2l6OiBkYXRhW2ogKyAxXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgY2FsY3VsYXRlQ29tcG9uZW50RGltZW5zaW9ucyhjb21wb25lbnQsIHNpeik7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50cy5wdXNoKGNvbXBvbmVudCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29udGV4dC5TSVogPSBzaXo7XG4gICAgICAgICAgICAgIGNvbnRleHQuY29tcG9uZW50cyA9IGNvbXBvbmVudHM7XG4gICAgICAgICAgICAgIGNhbGN1bGF0ZVRpbGVHcmlkcyhjb250ZXh0LCBjb21wb25lbnRzKTtcbiAgICAgICAgICAgICAgY29udGV4dC5RQ0MgPSBbXTtcbiAgICAgICAgICAgICAgY29udGV4dC5DT0MgPSBbXTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDB4RkY1QzogLy8gUXVhbnRpemF0aW9uIGRlZmF1bHQgKFFDRClcbiAgICAgICAgICAgICAgbGVuZ3RoID0gcmVhZFVpbnQxNihkYXRhLCBwb3NpdGlvbik7XG4gICAgICAgICAgICAgIHZhciBxY2QgPSB7fTtcbiAgICAgICAgICAgICAgaiA9IHBvc2l0aW9uICsgMjtcbiAgICAgICAgICAgICAgc3FjZCA9IGRhdGFbaisrXTtcbiAgICAgICAgICAgICAgc3dpdGNoIChzcWNkICYgMHgxRikge1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgIHNwcWNkU2l6ZSA9IDg7XG4gICAgICAgICAgICAgICAgICBzY2FsYXJFeHBvdW5kZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgc3BxY2RTaXplID0gMTY7XG4gICAgICAgICAgICAgICAgICBzY2FsYXJFeHBvdW5kZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgIHNwcWNkU2l6ZSA9IDE2O1xuICAgICAgICAgICAgICAgICAgc2NhbGFyRXhwb3VuZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0pQWCBFcnJvcjogSW52YWxpZCBTUWNkIHZhbHVlICcgKyBzcWNkKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBxY2Qubm9RdWFudGl6YXRpb24gPSAoc3BxY2RTaXplID09PSA4KTtcbiAgICAgICAgICAgICAgcWNkLnNjYWxhckV4cG91bmRlZCA9IHNjYWxhckV4cG91bmRlZDtcbiAgICAgICAgICAgICAgcWNkLmd1YXJkQml0cyA9IHNxY2QgPj4gNTtcbiAgICAgICAgICAgICAgc3BxY2RzID0gW107XG4gICAgICAgICAgICAgIHdoaWxlIChqIDwgbGVuZ3RoICsgcG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICB2YXIgc3BxY2QgPSB7fTtcbiAgICAgICAgICAgICAgICBpZiAoc3BxY2RTaXplID09PSA4KSB7XG4gICAgICAgICAgICAgICAgICBzcHFjZC5lcHNpbG9uID0gZGF0YVtqKytdID4+IDM7XG4gICAgICAgICAgICAgICAgICBzcHFjZC5tdSA9IDA7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHNwcWNkLmVwc2lsb24gPSBkYXRhW2pdID4+IDM7XG4gICAgICAgICAgICAgICAgICBzcHFjZC5tdSA9ICgoZGF0YVtqXSAmIDB4NykgPDwgOCkgfCBkYXRhW2ogKyAxXTtcbiAgICAgICAgICAgICAgICAgIGogKz0gMjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3BxY2RzLnB1c2goc3BxY2QpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHFjZC5TUHFjZHMgPSBzcHFjZHM7XG4gICAgICAgICAgICAgIGlmIChjb250ZXh0Lm1haW5IZWFkZXIpIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0LlFDRCA9IHFjZDtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmN1cnJlbnRUaWxlLlFDRCA9IHFjZDtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmN1cnJlbnRUaWxlLlFDQyA9IFtdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAweEZGNUQ6IC8vIFF1YW50aXphdGlvbiBjb21wb25lbnQgKFFDQylcbiAgICAgICAgICAgICAgbGVuZ3RoID0gcmVhZFVpbnQxNihkYXRhLCBwb3NpdGlvbik7XG4gICAgICAgICAgICAgIHZhciBxY2MgPSB7fTtcbiAgICAgICAgICAgICAgaiA9IHBvc2l0aW9uICsgMjtcbiAgICAgICAgICAgICAgdmFyIGNxY2M7XG4gICAgICAgICAgICAgIGlmIChjb250ZXh0LlNJWi5Dc2l6IDwgMjU3KSB7XG4gICAgICAgICAgICAgICAgY3FjYyA9IGRhdGFbaisrXTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjcWNjID0gcmVhZFVpbnQxNihkYXRhLCBqKTtcbiAgICAgICAgICAgICAgICBqICs9IDI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgc3FjZCA9IGRhdGFbaisrXTtcbiAgICAgICAgICAgICAgc3dpdGNoIChzcWNkICYgMHgxRikge1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgIHNwcWNkU2l6ZSA9IDg7XG4gICAgICAgICAgICAgICAgICBzY2FsYXJFeHBvdW5kZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgc3BxY2RTaXplID0gMTY7XG4gICAgICAgICAgICAgICAgICBzY2FsYXJFeHBvdW5kZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgIHNwcWNkU2l6ZSA9IDE2O1xuICAgICAgICAgICAgICAgICAgc2NhbGFyRXhwb3VuZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0pQWCBFcnJvcjogSW52YWxpZCBTUWNkIHZhbHVlICcgKyBzcWNkKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBxY2Mubm9RdWFudGl6YXRpb24gPSAoc3BxY2RTaXplID09PSA4KTtcbiAgICAgICAgICAgICAgcWNjLnNjYWxhckV4cG91bmRlZCA9IHNjYWxhckV4cG91bmRlZDtcbiAgICAgICAgICAgICAgcWNjLmd1YXJkQml0cyA9IHNxY2QgPj4gNTtcbiAgICAgICAgICAgICAgc3BxY2RzID0gW107XG4gICAgICAgICAgICAgIHdoaWxlIChqIDwgKGxlbmd0aCArIHBvc2l0aW9uKSkge1xuICAgICAgICAgICAgICAgIHNwcWNkID0ge307XG4gICAgICAgICAgICAgICAgaWYgKHNwcWNkU2l6ZSA9PT0gOCkge1xuICAgICAgICAgICAgICAgICAgc3BxY2QuZXBzaWxvbiA9IGRhdGFbaisrXSA+PiAzO1xuICAgICAgICAgICAgICAgICAgc3BxY2QubXUgPSAwO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBzcHFjZC5lcHNpbG9uID0gZGF0YVtqXSA+PiAzO1xuICAgICAgICAgICAgICAgICAgc3BxY2QubXUgPSAoKGRhdGFbal0gJiAweDcpIDw8IDgpIHwgZGF0YVtqICsgMV07XG4gICAgICAgICAgICAgICAgICBqICs9IDI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNwcWNkcy5wdXNoKHNwcWNkKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBxY2MuU1BxY2RzID0gc3BxY2RzO1xuICAgICAgICAgICAgICBpZiAoY29udGV4dC5tYWluSGVhZGVyKSB7XG4gICAgICAgICAgICAgICAgY29udGV4dC5RQ0NbY3FjY10gPSBxY2M7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29udGV4dC5jdXJyZW50VGlsZS5RQ0NbY3FjY10gPSBxY2M7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDB4RkY1MjogLy8gQ29kaW5nIHN0eWxlIGRlZmF1bHQgKENPRClcbiAgICAgICAgICAgICAgbGVuZ3RoID0gcmVhZFVpbnQxNihkYXRhLCBwb3NpdGlvbik7XG4gICAgICAgICAgICAgIHZhciBjb2QgPSB7fTtcbiAgICAgICAgICAgICAgaiA9IHBvc2l0aW9uICsgMjtcbiAgICAgICAgICAgICAgdmFyIHNjb2QgPSBkYXRhW2orK107XG4gICAgICAgICAgICAgIGNvZC5lbnRyb3B5Q29kZXJXaXRoQ3VzdG9tUHJlY2luY3RzID0gISEoc2NvZCAmIDEpO1xuICAgICAgICAgICAgICBjb2Quc29wTWFya2VyVXNlZCA9ICEhKHNjb2QgJiAyKTtcbiAgICAgICAgICAgICAgY29kLmVwaE1hcmtlclVzZWQgPSAhIShzY29kICYgNCk7XG4gICAgICAgICAgICAgIGNvZC5wcm9ncmVzc2lvbk9yZGVyID0gZGF0YVtqKytdO1xuICAgICAgICAgICAgICBjb2QubGF5ZXJzQ291bnQgPSByZWFkVWludDE2KGRhdGEsIGopO1xuICAgICAgICAgICAgICBqICs9IDI7XG4gICAgICAgICAgICAgIGNvZC5tdWx0aXBsZUNvbXBvbmVudFRyYW5zZm9ybSA9IGRhdGFbaisrXTtcblxuICAgICAgICAgICAgICBjb2QuZGVjb21wb3NpdGlvbkxldmVsc0NvdW50ID0gZGF0YVtqKytdO1xuICAgICAgICAgICAgICBjb2QueGNiID0gKGRhdGFbaisrXSAmIDB4RikgKyAyO1xuICAgICAgICAgICAgICBjb2QueWNiID0gKGRhdGFbaisrXSAmIDB4RikgKyAyO1xuICAgICAgICAgICAgICB2YXIgYmxvY2tTdHlsZSA9IGRhdGFbaisrXTtcbiAgICAgICAgICAgICAgY29kLnNlbGVjdGl2ZUFyaXRobWV0aWNDb2RpbmdCeXBhc3MgPSAhIShibG9ja1N0eWxlICYgMSk7XG4gICAgICAgICAgICAgIGNvZC5yZXNldENvbnRleHRQcm9iYWJpbGl0aWVzID0gISEoYmxvY2tTdHlsZSAmIDIpO1xuICAgICAgICAgICAgICBjb2QudGVybWluYXRpb25PbkVhY2hDb2RpbmdQYXNzID0gISEoYmxvY2tTdHlsZSAmIDQpO1xuICAgICAgICAgICAgICBjb2QudmVydGljYWx5U3RyaXBlID0gISEoYmxvY2tTdHlsZSAmIDgpO1xuICAgICAgICAgICAgICBjb2QucHJlZGljdGFibGVUZXJtaW5hdGlvbiA9ICEhKGJsb2NrU3R5bGUgJiAxNik7XG4gICAgICAgICAgICAgIGNvZC5zZWdtZW50YXRpb25TeW1ib2xVc2VkID0gISEoYmxvY2tTdHlsZSAmIDMyKTtcbiAgICAgICAgICAgICAgY29kLnJldmVyc2libGVUcmFuc2Zvcm1hdGlvbiA9IGRhdGFbaisrXTtcbiAgICAgICAgICAgICAgaWYgKGNvZC5lbnRyb3B5Q29kZXJXaXRoQ3VzdG9tUHJlY2luY3RzKSB7XG4gICAgICAgICAgICAgICAgdmFyIHByZWNpbmN0c1NpemVzID0gW107XG4gICAgICAgICAgICAgICAgd2hpbGUgKGogPCBsZW5ndGggKyBwb3NpdGlvbikge1xuICAgICAgICAgICAgICAgICAgdmFyIHByZWNpbmN0c1NpemUgPSBkYXRhW2orK107XG4gICAgICAgICAgICAgICAgICBwcmVjaW5jdHNTaXplcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgUFB4OiBwcmVjaW5jdHNTaXplICYgMHhGLFxuICAgICAgICAgICAgICAgICAgICBQUHk6IHByZWNpbmN0c1NpemUgPj4gNFxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvZC5wcmVjaW5jdHNTaXplcyA9IHByZWNpbmN0c1NpemVzO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHZhciB1bnN1cHBvcnRlZCA9IFtdO1xuICAgICAgICAgICAgICBpZiAoY29kLnNlbGVjdGl2ZUFyaXRobWV0aWNDb2RpbmdCeXBhc3MpIHtcbiAgICAgICAgICAgICAgICB1bnN1cHBvcnRlZC5wdXNoKCdzZWxlY3RpdmVBcml0aG1ldGljQ29kaW5nQnlwYXNzJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGNvZC5yZXNldENvbnRleHRQcm9iYWJpbGl0aWVzKSB7XG4gICAgICAgICAgICAgICAgdW5zdXBwb3J0ZWQucHVzaCgncmVzZXRDb250ZXh0UHJvYmFiaWxpdGllcycpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChjb2QudGVybWluYXRpb25PbkVhY2hDb2RpbmdQYXNzKSB7XG4gICAgICAgICAgICAgICAgdW5zdXBwb3J0ZWQucHVzaCgndGVybWluYXRpb25PbkVhY2hDb2RpbmdQYXNzJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGNvZC52ZXJ0aWNhbHlTdHJpcGUpIHtcbiAgICAgICAgICAgICAgICB1bnN1cHBvcnRlZC5wdXNoKCd2ZXJ0aWNhbHlTdHJpcGUnKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoY29kLnByZWRpY3RhYmxlVGVybWluYXRpb24pIHtcbiAgICAgICAgICAgICAgICB1bnN1cHBvcnRlZC5wdXNoKCdwcmVkaWN0YWJsZVRlcm1pbmF0aW9uJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHVuc3VwcG9ydGVkLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBkb05vdFJlY292ZXIgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSlBYIEVycm9yOiBVbnN1cHBvcnRlZCBDT0Qgb3B0aW9ucyAoJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuc3VwcG9ydGVkLmpvaW4oJywgJykgKyAnKScpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChjb250ZXh0Lm1haW5IZWFkZXIpIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0LkNPRCA9IGNvZDtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmN1cnJlbnRUaWxlLkNPRCA9IGNvZDtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmN1cnJlbnRUaWxlLkNPQyA9IFtdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAweEZGOTA6IC8vIFN0YXJ0IG9mIHRpbGUtcGFydCAoU09UKVxuICAgICAgICAgICAgICBsZW5ndGggPSByZWFkVWludDE2KGRhdGEsIHBvc2l0aW9uKTtcbiAgICAgICAgICAgICAgdGlsZSA9IHt9O1xuICAgICAgICAgICAgICB0aWxlLmluZGV4ID0gcmVhZFVpbnQxNihkYXRhLCBwb3NpdGlvbiArIDIpO1xuICAgICAgICAgICAgICB0aWxlLmxlbmd0aCA9IHJlYWRVaW50MzIoZGF0YSwgcG9zaXRpb24gKyA0KTtcbiAgICAgICAgICAgICAgdGlsZS5kYXRhRW5kID0gdGlsZS5sZW5ndGggKyBwb3NpdGlvbiAtIDI7XG4gICAgICAgICAgICAgIHRpbGUucGFydEluZGV4ID0gZGF0YVtwb3NpdGlvbiArIDhdO1xuICAgICAgICAgICAgICB0aWxlLnBhcnRzQ291bnQgPSBkYXRhW3Bvc2l0aW9uICsgOV07XG5cbiAgICAgICAgICAgICAgY29udGV4dC5tYWluSGVhZGVyID0gZmFsc2U7XG4gICAgICAgICAgICAgIGlmICh0aWxlLnBhcnRJbmRleCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIC8vIHJlc2V0IGNvbXBvbmVudCBzcGVjaWZpYyBzZXR0aW5nc1xuICAgICAgICAgICAgICAgIHRpbGUuQ09EID0gY29udGV4dC5DT0Q7XG4gICAgICAgICAgICAgICAgdGlsZS5DT0MgPSBjb250ZXh0LkNPQy5zbGljZSgwKTsgLy8gY2xvbmUgb2YgdGhlIGdsb2JhbCBDT0NcbiAgICAgICAgICAgICAgICB0aWxlLlFDRCA9IGNvbnRleHQuUUNEO1xuICAgICAgICAgICAgICAgIHRpbGUuUUNDID0gY29udGV4dC5RQ0Muc2xpY2UoMCk7IC8vIGNsb25lIG9mIHRoZSBnbG9iYWwgQ09DXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29udGV4dC5jdXJyZW50VGlsZSA9IHRpbGU7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAweEZGOTM6IC8vIFN0YXJ0IG9mIGRhdGEgKFNPRClcbiAgICAgICAgICAgICAgdGlsZSA9IGNvbnRleHQuY3VycmVudFRpbGU7XG4gICAgICAgICAgICAgIGlmICh0aWxlLnBhcnRJbmRleCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGluaXRpYWxpemVUaWxlKGNvbnRleHQsIHRpbGUuaW5kZXgpO1xuICAgICAgICAgICAgICAgIGJ1aWxkUGFja2V0cyhjb250ZXh0KTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIC8vIG1vdmluZyB0byB0aGUgZW5kIG9mIHRoZSBkYXRhXG4gICAgICAgICAgICAgIGxlbmd0aCA9IHRpbGUuZGF0YUVuZCAtIHBvc2l0aW9uO1xuICAgICAgICAgICAgICBwYXJzZVRpbGVQYWNrZXRzKGNvbnRleHQsIGRhdGEsIHBvc2l0aW9uLCBsZW5ndGgpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMHhGRjU1OiAvLyBUaWxlLXBhcnQgbGVuZ3RocywgbWFpbiBoZWFkZXIgKFRMTSlcbiAgICAgICAgICAgIGNhc2UgMHhGRjU3OiAvLyBQYWNrZXQgbGVuZ3RoLCBtYWluIGhlYWRlciAoUExNKVxuICAgICAgICAgICAgY2FzZSAweEZGNTg6IC8vIFBhY2tldCBsZW5ndGgsIHRpbGUtcGFydCBoZWFkZXIgKFBMVClcbiAgICAgICAgICAgIGNhc2UgMHhGRjY0OiAvLyBDb21tZW50IChDT00pXG4gICAgICAgICAgICAgIGxlbmd0aCA9IHJlYWRVaW50MTYoZGF0YSwgcG9zaXRpb24pO1xuICAgICAgICAgICAgICAvLyBza2lwcGluZyBjb250ZW50XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAweEZGNTM6IC8vIENvZGluZyBzdHlsZSBjb21wb25lbnQgKENPQylcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdKUFggRXJyb3I6IENvZGVzdHJlYW0gY29kZSAweEZGNTMgKENPQykgaXMgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnbm90IGltcGxlbWVudGVkJyk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0pQWCBFcnJvcjogVW5rbm93biBjb2Rlc3RyZWFtIGNvZGU6ICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZS50b1N0cmluZygxNikpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwb3NpdGlvbiArPSBsZW5ndGg7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKGRvTm90UmVjb3ZlciB8fCB0aGlzLmZhaWxPbkNvcnJ1cHRlZEltYWdlKSB7XG4gICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3YXJuKCdUcnlpbmcgdG8gcmVjb3ZlciBmcm9tICcgKyBlLm1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLnRpbGVzID0gdHJhbnNmb3JtQ29tcG9uZW50cyhjb250ZXh0KTtcbiAgICAgIHRoaXMud2lkdGggPSBjb250ZXh0LlNJWi5Yc2l6IC0gY29udGV4dC5TSVouWE9zaXo7XG4gICAgICB0aGlzLmhlaWdodCA9IGNvbnRleHQuU0laLllzaXogLSBjb250ZXh0LlNJWi5ZT3NpejtcbiAgICAgIHRoaXMuY29tcG9uZW50c0NvdW50ID0gY29udGV4dC5TSVouQ3NpejtcbiAgICB9XG4gIH07XG4gIGZ1bmN0aW9uIGNhbGN1bGF0ZUNvbXBvbmVudERpbWVuc2lvbnMoY29tcG9uZW50LCBzaXopIHtcbiAgICAvLyBTZWN0aW9uIEIuMiBDb21wb25lbnQgbWFwcGluZ1xuICAgIGNvbXBvbmVudC54MCA9IE1hdGguY2VpbChzaXouWE9zaXogLyBjb21wb25lbnQuWFJzaXopO1xuICAgIGNvbXBvbmVudC54MSA9IE1hdGguY2VpbChzaXouWHNpeiAvIGNvbXBvbmVudC5YUnNpeik7XG4gICAgY29tcG9uZW50LnkwID0gTWF0aC5jZWlsKHNpei5ZT3NpeiAvIGNvbXBvbmVudC5ZUnNpeik7XG4gICAgY29tcG9uZW50LnkxID0gTWF0aC5jZWlsKHNpei5Zc2l6IC8gY29tcG9uZW50LllSc2l6KTtcbiAgICBjb21wb25lbnQud2lkdGggPSBjb21wb25lbnQueDEgLSBjb21wb25lbnQueDA7XG4gICAgY29tcG9uZW50LmhlaWdodCA9IGNvbXBvbmVudC55MSAtIGNvbXBvbmVudC55MDtcbiAgfVxuICBmdW5jdGlvbiBjYWxjdWxhdGVUaWxlR3JpZHMoY29udGV4dCwgY29tcG9uZW50cykge1xuICAgIHZhciBzaXogPSBjb250ZXh0LlNJWjtcbiAgICAvLyBTZWN0aW9uIEIuMyBEaXZpc2lvbiBpbnRvIHRpbGUgYW5kIHRpbGUtY29tcG9uZW50c1xuICAgIHZhciB0aWxlLCB0aWxlcyA9IFtdO1xuICAgIHZhciBudW1YdGlsZXMgPSBNYXRoLmNlaWwoKHNpei5Yc2l6IC0gc2l6LlhUT3NpeikgLyBzaXouWFRzaXopO1xuICAgIHZhciBudW1ZdGlsZXMgPSBNYXRoLmNlaWwoKHNpei5Zc2l6IC0gc2l6LllUT3NpeikgLyBzaXouWVRzaXopO1xuICAgIGZvciAodmFyIHEgPSAwOyBxIDwgbnVtWXRpbGVzOyBxKyspIHtcbiAgICAgIGZvciAodmFyIHAgPSAwOyBwIDwgbnVtWHRpbGVzOyBwKyspIHtcbiAgICAgICAgdGlsZSA9IHt9O1xuICAgICAgICB0aWxlLnR4MCA9IE1hdGgubWF4KHNpei5YVE9zaXogKyBwICogc2l6LlhUc2l6LCBzaXouWE9zaXopO1xuICAgICAgICB0aWxlLnR5MCA9IE1hdGgubWF4KHNpei5ZVE9zaXogKyBxICogc2l6LllUc2l6LCBzaXouWU9zaXopO1xuICAgICAgICB0aWxlLnR4MSA9IE1hdGgubWluKHNpei5YVE9zaXogKyAocCArIDEpICogc2l6LlhUc2l6LCBzaXouWHNpeik7XG4gICAgICAgIHRpbGUudHkxID0gTWF0aC5taW4oc2l6LllUT3NpeiArIChxICsgMSkgKiBzaXouWVRzaXosIHNpei5Zc2l6KTtcbiAgICAgICAgdGlsZS53aWR0aCA9IHRpbGUudHgxIC0gdGlsZS50eDA7XG4gICAgICAgIHRpbGUuaGVpZ2h0ID0gdGlsZS50eTEgLSB0aWxlLnR5MDtcbiAgICAgICAgdGlsZS5jb21wb25lbnRzID0gW107XG4gICAgICAgIHRpbGVzLnB1c2godGlsZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnRleHQudGlsZXMgPSB0aWxlcztcblxuICAgIHZhciBjb21wb25lbnRzQ291bnQgPSBzaXouQ3NpejtcbiAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBjb21wb25lbnRzQ291bnQ7IGkgPCBpaTsgaSsrKSB7XG4gICAgICB2YXIgY29tcG9uZW50ID0gY29tcG9uZW50c1tpXTtcbiAgICAgIGZvciAodmFyIGogPSAwLCBqaiA9IHRpbGVzLmxlbmd0aDsgaiA8IGpqOyBqKyspIHtcbiAgICAgICAgdmFyIHRpbGVDb21wb25lbnQgPSB7fTtcbiAgICAgICAgdGlsZSA9IHRpbGVzW2pdO1xuICAgICAgICB0aWxlQ29tcG9uZW50LnRjeDAgPSBNYXRoLmNlaWwodGlsZS50eDAgLyBjb21wb25lbnQuWFJzaXopO1xuICAgICAgICB0aWxlQ29tcG9uZW50LnRjeTAgPSBNYXRoLmNlaWwodGlsZS50eTAgLyBjb21wb25lbnQuWVJzaXopO1xuICAgICAgICB0aWxlQ29tcG9uZW50LnRjeDEgPSBNYXRoLmNlaWwodGlsZS50eDEgLyBjb21wb25lbnQuWFJzaXopO1xuICAgICAgICB0aWxlQ29tcG9uZW50LnRjeTEgPSBNYXRoLmNlaWwodGlsZS50eTEgLyBjb21wb25lbnQuWVJzaXopO1xuICAgICAgICB0aWxlQ29tcG9uZW50LndpZHRoID0gdGlsZUNvbXBvbmVudC50Y3gxIC0gdGlsZUNvbXBvbmVudC50Y3gwO1xuICAgICAgICB0aWxlQ29tcG9uZW50LmhlaWdodCA9IHRpbGVDb21wb25lbnQudGN5MSAtIHRpbGVDb21wb25lbnQudGN5MDtcbiAgICAgICAgdGlsZS5jb21wb25lbnRzW2ldID0gdGlsZUNvbXBvbmVudDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZ2V0QmxvY2tzRGltZW5zaW9ucyhjb250ZXh0LCBjb21wb25lbnQsIHIpIHtcbiAgICB2YXIgY29kT3JDb2MgPSBjb21wb25lbnQuY29kaW5nU3R5bGVQYXJhbWV0ZXJzO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAoIWNvZE9yQ29jLmVudHJvcHlDb2RlcldpdGhDdXN0b21QcmVjaW5jdHMpIHtcbiAgICAgIHJlc3VsdC5QUHggPSAxNTtcbiAgICAgIHJlc3VsdC5QUHkgPSAxNTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0LlBQeCA9IGNvZE9yQ29jLnByZWNpbmN0c1NpemVzW3JdLlBQeDtcbiAgICAgIHJlc3VsdC5QUHkgPSBjb2RPckNvYy5wcmVjaW5jdHNTaXplc1tyXS5QUHk7XG4gICAgfVxuICAgIC8vIGNhbGN1bGF0ZSBjb2RlYmxvY2sgc2l6ZSBhcyBkZXNjcmliZWQgaW4gc2VjdGlvbiBCLjdcbiAgICByZXN1bHQueGNiXyA9IChyID4gMCA/IE1hdGgubWluKGNvZE9yQ29jLnhjYiwgcmVzdWx0LlBQeCAtIDEpIDpcbiAgICAgICAgICAgICAgICAgICBNYXRoLm1pbihjb2RPckNvYy54Y2IsIHJlc3VsdC5QUHgpKTtcbiAgICByZXN1bHQueWNiXyA9IChyID4gMCA/IE1hdGgubWluKGNvZE9yQ29jLnljYiwgcmVzdWx0LlBQeSAtIDEpIDpcbiAgICAgICAgICAgICAgICAgICBNYXRoLm1pbihjb2RPckNvYy55Y2IsIHJlc3VsdC5QUHkpKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGZ1bmN0aW9uIGJ1aWxkUHJlY2luY3RzKGNvbnRleHQsIHJlc29sdXRpb24sIGRpbWVuc2lvbnMpIHtcbiAgICAvLyBTZWN0aW9uIEIuNiBEaXZpc2lvbiByZXNvbHV0aW9uIHRvIHByZWNpbmN0c1xuICAgIHZhciBwcmVjaW5jdFdpZHRoID0gMSA8PCBkaW1lbnNpb25zLlBQeDtcbiAgICB2YXIgcHJlY2luY3RIZWlnaHQgPSAxIDw8IGRpbWVuc2lvbnMuUFB5O1xuICAgIC8vIEphc3BlciBpbnRyb2R1Y2VzIGNvZGVibG9jayBncm91cHMgZm9yIG1hcHBpbmcgZWFjaCBzdWJiYW5kIGNvZGVibG9ja3NcbiAgICAvLyB0byBwcmVjaW5jdHMuIFByZWNpbmN0IHBhcnRpdGlvbiBkaXZpZGVzIGEgcmVzb2x1dGlvbiBhY2NvcmRpbmcgdG8gd2lkdGhcbiAgICAvLyBhbmQgaGVpZ2h0IHBhcmFtZXRlcnMuIFRoZSBzdWJiYW5kIHRoYXQgYmVsb25ncyB0byB0aGUgcmVzb2x1dGlvbiBsZXZlbFxuICAgIC8vIGhhcyBhIGRpZmZlcmVudCBzaXplIHRoYW4gdGhlIGxldmVsLCB1bmxlc3MgaXQgaXMgdGhlIHplcm8gcmVzb2x1dGlvbi5cblxuICAgIC8vIEZyb20gSmFzcGVyIGRvY3VtZW50YXRpb246IGpwZWcyMDAwLnBkZiwgc2VjdGlvbiBLOiBUaWVyLTIgY29kaW5nOlxuICAgIC8vIFRoZSBwcmVjaW5jdCBwYXJ0aXRpb25pbmcgZm9yIGEgcGFydGljdWxhciBzdWJiYW5kIGlzIGRlcml2ZWQgZnJvbSBhXG4gICAgLy8gcGFydGl0aW9uaW5nIG9mIGl0cyBwYXJlbnQgTEwgYmFuZCAoaS5lLiwgdGhlIExMIGJhbmQgYXQgdGhlIG5leHQgaGlnaGVyXG4gICAgLy8gcmVzb2x1dGlvbiBsZXZlbCkuLi4gVGhlIExMIGJhbmQgYXNzb2NpYXRlZCB3aXRoIGVhY2ggcmVzb2x1dGlvbiBsZXZlbCBpc1xuICAgIC8vIGRpdmlkZWQgaW50byBwcmVjaW5jdHMuLi4gRWFjaCBvZiB0aGUgcmVzdWx0aW5nIHByZWNpbmN0IHJlZ2lvbnMgaXMgdGhlblxuICAgIC8vIG1hcHBlZCBpbnRvIGl0cyBjaGlsZCBzdWJiYW5kcyAoaWYgYW55KSBhdCB0aGUgbmV4dCBsb3dlciByZXNvbHV0aW9uXG4gICAgLy8gbGV2ZWwuIFRoaXMgaXMgYWNjb21wbGlzaGVkIGJ5IHVzaW5nIHRoZSBjb29yZGluYXRlIHRyYW5zZm9ybWF0aW9uXG4gICAgLy8gKHUsIHYpID0gKGNlaWwoeC8yKSwgY2VpbCh5LzIpKSB3aGVyZSAoeCwgeSkgYW5kICh1LCB2KSBhcmUgdGhlXG4gICAgLy8gY29vcmRpbmF0ZXMgb2YgYSBwb2ludCBpbiB0aGUgTEwgYmFuZCBhbmQgY2hpbGQgc3ViYmFuZCwgcmVzcGVjdGl2ZWx5LlxuICAgIHZhciBpc1plcm9SZXMgPSByZXNvbHV0aW9uLnJlc0xldmVsID09PSAwO1xuICAgIHZhciBwcmVjaW5jdFdpZHRoSW5TdWJiYW5kID0gMSA8PCAoZGltZW5zaW9ucy5QUHggKyAoaXNaZXJvUmVzID8gMCA6IC0xKSk7XG4gICAgdmFyIHByZWNpbmN0SGVpZ2h0SW5TdWJiYW5kID0gMSA8PCAoZGltZW5zaW9ucy5QUHkgKyAoaXNaZXJvUmVzID8gMCA6IC0xKSk7XG4gICAgdmFyIG51bXByZWNpbmN0c3dpZGUgPSAocmVzb2x1dGlvbi50cngxID4gcmVzb2x1dGlvbi50cngwID9cbiAgICAgIE1hdGguY2VpbChyZXNvbHV0aW9uLnRyeDEgLyBwcmVjaW5jdFdpZHRoKSAtXG4gICAgICBNYXRoLmZsb29yKHJlc29sdXRpb24udHJ4MCAvIHByZWNpbmN0V2lkdGgpIDogMCk7XG4gICAgdmFyIG51bXByZWNpbmN0c2hpZ2ggPSAocmVzb2x1dGlvbi50cnkxID4gcmVzb2x1dGlvbi50cnkwID9cbiAgICAgIE1hdGguY2VpbChyZXNvbHV0aW9uLnRyeTEgLyBwcmVjaW5jdEhlaWdodCkgLVxuICAgICAgTWF0aC5mbG9vcihyZXNvbHV0aW9uLnRyeTAgLyBwcmVjaW5jdEhlaWdodCkgOiAwKTtcbiAgICB2YXIgbnVtcHJlY2luY3RzID0gbnVtcHJlY2luY3Rzd2lkZSAqIG51bXByZWNpbmN0c2hpZ2g7XG5cbiAgICByZXNvbHV0aW9uLnByZWNpbmN0UGFyYW1ldGVycyA9IHtcbiAgICAgIHByZWNpbmN0V2lkdGg6IHByZWNpbmN0V2lkdGgsXG4gICAgICBwcmVjaW5jdEhlaWdodDogcHJlY2luY3RIZWlnaHQsXG4gICAgICBudW1wcmVjaW5jdHN3aWRlOiBudW1wcmVjaW5jdHN3aWRlLFxuICAgICAgbnVtcHJlY2luY3RzaGlnaDogbnVtcHJlY2luY3RzaGlnaCxcbiAgICAgIG51bXByZWNpbmN0czogbnVtcHJlY2luY3RzLFxuICAgICAgcHJlY2luY3RXaWR0aEluU3ViYmFuZDogcHJlY2luY3RXaWR0aEluU3ViYmFuZCxcbiAgICAgIHByZWNpbmN0SGVpZ2h0SW5TdWJiYW5kOiBwcmVjaW5jdEhlaWdodEluU3ViYmFuZFxuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gYnVpbGRDb2RlYmxvY2tzKGNvbnRleHQsIHN1YmJhbmQsIGRpbWVuc2lvbnMpIHtcbiAgICAvLyBTZWN0aW9uIEIuNyBEaXZpc2lvbiBzdWItYmFuZCBpbnRvIGNvZGUtYmxvY2tzXG4gICAgdmFyIHhjYl8gPSBkaW1lbnNpb25zLnhjYl87XG4gICAgdmFyIHljYl8gPSBkaW1lbnNpb25zLnljYl87XG4gICAgdmFyIGNvZGVibG9ja1dpZHRoID0gMSA8PCB4Y2JfO1xuICAgIHZhciBjb2RlYmxvY2tIZWlnaHQgPSAxIDw8IHljYl87XG4gICAgdmFyIGNieDAgPSBzdWJiYW5kLnRieDAgPj4geGNiXztcbiAgICB2YXIgY2J5MCA9IHN1YmJhbmQudGJ5MCA+PiB5Y2JfO1xuICAgIHZhciBjYngxID0gKHN1YmJhbmQudGJ4MSArIGNvZGVibG9ja1dpZHRoIC0gMSkgPj4geGNiXztcbiAgICB2YXIgY2J5MSA9IChzdWJiYW5kLnRieTEgKyBjb2RlYmxvY2tIZWlnaHQgLSAxKSA+PiB5Y2JfO1xuICAgIHZhciBwcmVjaW5jdFBhcmFtZXRlcnMgPSBzdWJiYW5kLnJlc29sdXRpb24ucHJlY2luY3RQYXJhbWV0ZXJzO1xuICAgIHZhciBjb2RlYmxvY2tzID0gW107XG4gICAgdmFyIHByZWNpbmN0cyA9IFtdO1xuICAgIHZhciBpLCBqLCBjb2RlYmxvY2ssIHByZWNpbmN0TnVtYmVyO1xuICAgIGZvciAoaiA9IGNieTA7IGogPCBjYnkxOyBqKyspIHtcbiAgICAgIGZvciAoaSA9IGNieDA7IGkgPCBjYngxOyBpKyspIHtcbiAgICAgICAgY29kZWJsb2NrID0ge1xuICAgICAgICAgIGNieDogaSxcbiAgICAgICAgICBjYnk6IGosXG4gICAgICAgICAgdGJ4MDogY29kZWJsb2NrV2lkdGggKiBpLFxuICAgICAgICAgIHRieTA6IGNvZGVibG9ja0hlaWdodCAqIGosXG4gICAgICAgICAgdGJ4MTogY29kZWJsb2NrV2lkdGggKiAoaSArIDEpLFxuICAgICAgICAgIHRieTE6IGNvZGVibG9ja0hlaWdodCAqIChqICsgMSlcbiAgICAgICAgfTtcblxuICAgICAgICBjb2RlYmxvY2sudGJ4MF8gPSBNYXRoLm1heChzdWJiYW5kLnRieDAsIGNvZGVibG9jay50YngwKTtcbiAgICAgICAgY29kZWJsb2NrLnRieTBfID0gTWF0aC5tYXgoc3ViYmFuZC50YnkwLCBjb2RlYmxvY2sudGJ5MCk7XG4gICAgICAgIGNvZGVibG9jay50YngxXyA9IE1hdGgubWluKHN1YmJhbmQudGJ4MSwgY29kZWJsb2NrLnRieDEpO1xuICAgICAgICBjb2RlYmxvY2sudGJ5MV8gPSBNYXRoLm1pbihzdWJiYW5kLnRieTEsIGNvZGVibG9jay50YnkxKTtcblxuICAgICAgICAvLyBDYWxjdWxhdGUgcHJlY2luY3QgbnVtYmVyIGZvciB0aGlzIGNvZGVibG9jaywgY29kZWJsb2NrIHBvc2l0aW9uXG4gICAgICAgIC8vIHNob3VsZCBiZSByZWxhdGl2ZSB0byBpdHMgc3ViYmFuZCwgdXNlIGFjdHVhbCBkaW1lbnNpb24gYW5kIHBvc2l0aW9uXG4gICAgICAgIC8vIFNlZSBjb21tZW50IGFib3V0IGNvZGVibG9jayBncm91cCB3aWR0aCBhbmQgaGVpZ2h0XG4gICAgICAgIHZhciBwaSA9IE1hdGguZmxvb3IoKGNvZGVibG9jay50YngwXyAtIHN1YmJhbmQudGJ4MCkgL1xuICAgICAgICAgIHByZWNpbmN0UGFyYW1ldGVycy5wcmVjaW5jdFdpZHRoSW5TdWJiYW5kKTtcbiAgICAgICAgdmFyIHBqID0gTWF0aC5mbG9vcigoY29kZWJsb2NrLnRieTBfIC0gc3ViYmFuZC50YnkwKSAvXG4gICAgICAgICAgcHJlY2luY3RQYXJhbWV0ZXJzLnByZWNpbmN0SGVpZ2h0SW5TdWJiYW5kKTtcbiAgICAgICAgcHJlY2luY3ROdW1iZXIgPSBwaSArIChwaiAqIHByZWNpbmN0UGFyYW1ldGVycy5udW1wcmVjaW5jdHN3aWRlKTtcblxuICAgICAgICBjb2RlYmxvY2sucHJlY2luY3ROdW1iZXIgPSBwcmVjaW5jdE51bWJlcjtcbiAgICAgICAgY29kZWJsb2NrLnN1YmJhbmRUeXBlID0gc3ViYmFuZC50eXBlO1xuICAgICAgICBjb2RlYmxvY2suTGJsb2NrID0gMztcblxuICAgICAgICBpZiAoY29kZWJsb2NrLnRieDFfIDw9IGNvZGVibG9jay50YngwXyB8fFxuICAgICAgICAgICAgY29kZWJsb2NrLnRieTFfIDw9IGNvZGVibG9jay50YnkwXykge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvZGVibG9ja3MucHVzaChjb2RlYmxvY2spO1xuICAgICAgICAvLyBidWlsZGluZyBwcmVjaW5jdCBmb3IgdGhlIHN1Yi1iYW5kXG4gICAgICAgIHZhciBwcmVjaW5jdCA9IHByZWNpbmN0c1twcmVjaW5jdE51bWJlcl07XG4gICAgICAgIGlmIChwcmVjaW5jdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKGkgPCBwcmVjaW5jdC5jYnhNaW4pIHtcbiAgICAgICAgICAgIHByZWNpbmN0LmNieE1pbiA9IGk7XG4gICAgICAgICAgfSBlbHNlIGlmIChpID4gcHJlY2luY3QuY2J4TWF4KSB7XG4gICAgICAgICAgICBwcmVjaW5jdC5jYnhNYXggPSBpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaiA8IHByZWNpbmN0LmNieU1pbikge1xuICAgICAgICAgICAgcHJlY2luY3QuY2J4TWluID0gajtcbiAgICAgICAgICB9IGVsc2UgaWYgKGogPiBwcmVjaW5jdC5jYnlNYXgpIHtcbiAgICAgICAgICAgIHByZWNpbmN0LmNieU1heCA9IGo7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByZWNpbmN0c1twcmVjaW5jdE51bWJlcl0gPSBwcmVjaW5jdCA9IHtcbiAgICAgICAgICAgIGNieE1pbjogaSxcbiAgICAgICAgICAgIGNieU1pbjogaixcbiAgICAgICAgICAgIGNieE1heDogaSxcbiAgICAgICAgICAgIGNieU1heDogalxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29kZWJsb2NrLnByZWNpbmN0ID0gcHJlY2luY3Q7XG4gICAgICB9XG4gICAgfVxuICAgIHN1YmJhbmQuY29kZWJsb2NrUGFyYW1ldGVycyA9IHtcbiAgICAgIGNvZGVibG9ja1dpZHRoOiB4Y2JfLFxuICAgICAgY29kZWJsb2NrSGVpZ2h0OiB5Y2JfLFxuICAgICAgbnVtY29kZWJsb2Nrd2lkZTogY2J4MSAtIGNieDAgKyAxLFxuICAgICAgbnVtY29kZWJsb2NraGlnaDogY2J5MSAtIGNieTAgKyAxXG4gICAgfTtcbiAgICBzdWJiYW5kLmNvZGVibG9ja3MgPSBjb2RlYmxvY2tzO1xuICAgIHN1YmJhbmQucHJlY2luY3RzID0gcHJlY2luY3RzO1xuICB9XG4gIGZ1bmN0aW9uIGNyZWF0ZVBhY2tldChyZXNvbHV0aW9uLCBwcmVjaW5jdE51bWJlciwgbGF5ZXJOdW1iZXIpIHtcbiAgICB2YXIgcHJlY2luY3RDb2RlYmxvY2tzID0gW107XG4gICAgLy8gU2VjdGlvbiBCLjEwLjggT3JkZXIgb2YgaW5mbyBpbiBwYWNrZXRcbiAgICB2YXIgc3ViYmFuZHMgPSByZXNvbHV0aW9uLnN1YmJhbmRzO1xuICAgIC8vIHN1Yi1iYW5kcyBhbHJlYWR5IG9yZGVyZWQgaW4gJ0xMJywgJ0hMJywgJ0xIJywgYW5kICdISCcgc2VxdWVuY2VcbiAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBzdWJiYW5kcy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICB2YXIgc3ViYmFuZCA9IHN1YmJhbmRzW2ldO1xuICAgICAgdmFyIGNvZGVibG9ja3MgPSBzdWJiYW5kLmNvZGVibG9ja3M7XG4gICAgICBmb3IgKHZhciBqID0gMCwgamogPSBjb2RlYmxvY2tzLmxlbmd0aDsgaiA8IGpqOyBqKyspIHtcbiAgICAgICAgdmFyIGNvZGVibG9jayA9IGNvZGVibG9ja3Nbal07XG4gICAgICAgIGlmIChjb2RlYmxvY2sucHJlY2luY3ROdW1iZXIgIT09IHByZWNpbmN0TnVtYmVyKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgcHJlY2luY3RDb2RlYmxvY2tzLnB1c2goY29kZWJsb2NrKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGxheWVyTnVtYmVyOiBsYXllck51bWJlcixcbiAgICAgIGNvZGVibG9ja3M6IHByZWNpbmN0Q29kZWJsb2Nrc1xuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gTGF5ZXJSZXNvbHV0aW9uQ29tcG9uZW50UG9zaXRpb25JdGVyYXRvcihjb250ZXh0KSB7XG4gICAgdmFyIHNpeiA9IGNvbnRleHQuU0laO1xuICAgIHZhciB0aWxlSW5kZXggPSBjb250ZXh0LmN1cnJlbnRUaWxlLmluZGV4O1xuICAgIHZhciB0aWxlID0gY29udGV4dC50aWxlc1t0aWxlSW5kZXhdO1xuICAgIHZhciBsYXllcnNDb3VudCA9IHRpbGUuY29kaW5nU3R5bGVEZWZhdWx0UGFyYW1ldGVycy5sYXllcnNDb3VudDtcbiAgICB2YXIgY29tcG9uZW50c0NvdW50ID0gc2l6LkNzaXo7XG4gICAgdmFyIG1heERlY29tcG9zaXRpb25MZXZlbHNDb3VudCA9IDA7XG4gICAgZm9yICh2YXIgcSA9IDA7IHEgPCBjb21wb25lbnRzQ291bnQ7IHErKykge1xuICAgICAgbWF4RGVjb21wb3NpdGlvbkxldmVsc0NvdW50ID0gTWF0aC5tYXgobWF4RGVjb21wb3NpdGlvbkxldmVsc0NvdW50LFxuICAgICAgICB0aWxlLmNvbXBvbmVudHNbcV0uY29kaW5nU3R5bGVQYXJhbWV0ZXJzLmRlY29tcG9zaXRpb25MZXZlbHNDb3VudCk7XG4gICAgfVxuXG4gICAgdmFyIGwgPSAwLCByID0gMCwgaSA9IDAsIGsgPSAwO1xuXG4gICAgdGhpcy5uZXh0UGFja2V0ID0gZnVuY3Rpb24gSnB4SW1hZ2VfbmV4dFBhY2tldCgpIHtcbiAgICAgIC8vIFNlY3Rpb24gQi4xMi4xLjEgTGF5ZXItcmVzb2x1dGlvbi1jb21wb25lbnQtcG9zaXRpb25cbiAgICAgIGZvciAoOyBsIDwgbGF5ZXJzQ291bnQ7IGwrKykge1xuICAgICAgICBmb3IgKDsgciA8PSBtYXhEZWNvbXBvc2l0aW9uTGV2ZWxzQ291bnQ7IHIrKykge1xuICAgICAgICAgIGZvciAoOyBpIDwgY29tcG9uZW50c0NvdW50OyBpKyspIHtcbiAgICAgICAgICAgIHZhciBjb21wb25lbnQgPSB0aWxlLmNvbXBvbmVudHNbaV07XG4gICAgICAgICAgICBpZiAociA+IGNvbXBvbmVudC5jb2RpbmdTdHlsZVBhcmFtZXRlcnMuZGVjb21wb3NpdGlvbkxldmVsc0NvdW50KSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcmVzb2x1dGlvbiA9IGNvbXBvbmVudC5yZXNvbHV0aW9uc1tyXTtcbiAgICAgICAgICAgIHZhciBudW1wcmVjaW5jdHMgPSByZXNvbHV0aW9uLnByZWNpbmN0UGFyYW1ldGVycy5udW1wcmVjaW5jdHM7XG4gICAgICAgICAgICBmb3IgKDsgayA8IG51bXByZWNpbmN0czspIHtcbiAgICAgICAgICAgICAgdmFyIHBhY2tldCA9IGNyZWF0ZVBhY2tldChyZXNvbHV0aW9uLCBrLCBsKTtcbiAgICAgICAgICAgICAgaysrO1xuICAgICAgICAgICAgICByZXR1cm4gcGFja2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgayA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICAgIGkgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHIgPSAwO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gUmVzb2x1dGlvbkxheWVyQ29tcG9uZW50UG9zaXRpb25JdGVyYXRvcihjb250ZXh0KSB7XG4gICAgdmFyIHNpeiA9IGNvbnRleHQuU0laO1xuICAgIHZhciB0aWxlSW5kZXggPSBjb250ZXh0LmN1cnJlbnRUaWxlLmluZGV4O1xuICAgIHZhciB0aWxlID0gY29udGV4dC50aWxlc1t0aWxlSW5kZXhdO1xuICAgIHZhciBsYXllcnNDb3VudCA9IHRpbGUuY29kaW5nU3R5bGVEZWZhdWx0UGFyYW1ldGVycy5sYXllcnNDb3VudDtcbiAgICB2YXIgY29tcG9uZW50c0NvdW50ID0gc2l6LkNzaXo7XG4gICAgdmFyIG1heERlY29tcG9zaXRpb25MZXZlbHNDb3VudCA9IDA7XG4gICAgZm9yICh2YXIgcSA9IDA7IHEgPCBjb21wb25lbnRzQ291bnQ7IHErKykge1xuICAgICAgbWF4RGVjb21wb3NpdGlvbkxldmVsc0NvdW50ID0gTWF0aC5tYXgobWF4RGVjb21wb3NpdGlvbkxldmVsc0NvdW50LFxuICAgICAgICB0aWxlLmNvbXBvbmVudHNbcV0uY29kaW5nU3R5bGVQYXJhbWV0ZXJzLmRlY29tcG9zaXRpb25MZXZlbHNDb3VudCk7XG4gICAgfVxuXG4gICAgdmFyIHIgPSAwLCBsID0gMCwgaSA9IDAsIGsgPSAwO1xuXG4gICAgdGhpcy5uZXh0UGFja2V0ID0gZnVuY3Rpb24gSnB4SW1hZ2VfbmV4dFBhY2tldCgpIHtcbiAgICAgIC8vIFNlY3Rpb24gQi4xMi4xLjIgUmVzb2x1dGlvbi1sYXllci1jb21wb25lbnQtcG9zaXRpb25cbiAgICAgIGZvciAoOyByIDw9IG1heERlY29tcG9zaXRpb25MZXZlbHNDb3VudDsgcisrKSB7XG4gICAgICAgIGZvciAoOyBsIDwgbGF5ZXJzQ291bnQ7IGwrKykge1xuICAgICAgICAgIGZvciAoOyBpIDwgY29tcG9uZW50c0NvdW50OyBpKyspIHtcbiAgICAgICAgICAgIHZhciBjb21wb25lbnQgPSB0aWxlLmNvbXBvbmVudHNbaV07XG4gICAgICAgICAgICBpZiAociA+IGNvbXBvbmVudC5jb2RpbmdTdHlsZVBhcmFtZXRlcnMuZGVjb21wb3NpdGlvbkxldmVsc0NvdW50KSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcmVzb2x1dGlvbiA9IGNvbXBvbmVudC5yZXNvbHV0aW9uc1tyXTtcbiAgICAgICAgICAgIHZhciBudW1wcmVjaW5jdHMgPSByZXNvbHV0aW9uLnByZWNpbmN0UGFyYW1ldGVycy5udW1wcmVjaW5jdHM7XG4gICAgICAgICAgICBmb3IgKDsgayA8IG51bXByZWNpbmN0czspIHtcbiAgICAgICAgICAgICAgdmFyIHBhY2tldCA9IGNyZWF0ZVBhY2tldChyZXNvbHV0aW9uLCBrLCBsKTtcbiAgICAgICAgICAgICAgaysrO1xuICAgICAgICAgICAgICByZXR1cm4gcGFja2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgayA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICAgIGkgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGwgPSAwO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gUmVzb2x1dGlvblBvc2l0aW9uQ29tcG9uZW50TGF5ZXJJdGVyYXRvcihjb250ZXh0KSB7XG4gICAgdmFyIHNpeiA9IGNvbnRleHQuU0laO1xuICAgIHZhciB0aWxlSW5kZXggPSBjb250ZXh0LmN1cnJlbnRUaWxlLmluZGV4O1xuICAgIHZhciB0aWxlID0gY29udGV4dC50aWxlc1t0aWxlSW5kZXhdO1xuICAgIHZhciBsYXllcnNDb3VudCA9IHRpbGUuY29kaW5nU3R5bGVEZWZhdWx0UGFyYW1ldGVycy5sYXllcnNDb3VudDtcbiAgICB2YXIgY29tcG9uZW50c0NvdW50ID0gc2l6LkNzaXo7XG4gICAgdmFyIGwsIHIsIGMsIHA7XG4gICAgdmFyIG1heERlY29tcG9zaXRpb25MZXZlbHNDb3VudCA9IDA7XG4gICAgZm9yIChjID0gMDsgYyA8IGNvbXBvbmVudHNDb3VudDsgYysrKSB7XG4gICAgICB2YXIgY29tcG9uZW50ID0gdGlsZS5jb21wb25lbnRzW2NdO1xuICAgICAgbWF4RGVjb21wb3NpdGlvbkxldmVsc0NvdW50ID0gTWF0aC5tYXgobWF4RGVjb21wb3NpdGlvbkxldmVsc0NvdW50LFxuICAgICAgICBjb21wb25lbnQuY29kaW5nU3R5bGVQYXJhbWV0ZXJzLmRlY29tcG9zaXRpb25MZXZlbHNDb3VudCk7XG4gICAgfVxuICAgIHZhciBtYXhOdW1QcmVjaW5jdHNJbkxldmVsID0gbmV3IEludDMyQXJyYXkoXG4gICAgICBtYXhEZWNvbXBvc2l0aW9uTGV2ZWxzQ291bnQgKyAxKTtcbiAgICBmb3IgKHIgPSAwOyByIDw9IG1heERlY29tcG9zaXRpb25MZXZlbHNDb3VudDsgKytyKSB7XG4gICAgICB2YXIgbWF4TnVtUHJlY2luY3RzID0gMDtcbiAgICAgIGZvciAoYyA9IDA7IGMgPCBjb21wb25lbnRzQ291bnQ7ICsrYykge1xuICAgICAgICB2YXIgcmVzb2x1dGlvbnMgPSB0aWxlLmNvbXBvbmVudHNbY10ucmVzb2x1dGlvbnM7XG4gICAgICAgIGlmIChyIDwgcmVzb2x1dGlvbnMubGVuZ3RoKSB7XG4gICAgICAgICAgbWF4TnVtUHJlY2luY3RzID0gTWF0aC5tYXgobWF4TnVtUHJlY2luY3RzLFxuICAgICAgICAgICAgcmVzb2x1dGlvbnNbcl0ucHJlY2luY3RQYXJhbWV0ZXJzLm51bXByZWNpbmN0cyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG1heE51bVByZWNpbmN0c0luTGV2ZWxbcl0gPSBtYXhOdW1QcmVjaW5jdHM7XG4gICAgfVxuICAgIGwgPSAwO1xuICAgIHIgPSAwO1xuICAgIGMgPSAwO1xuICAgIHAgPSAwO1xuXG4gICAgdGhpcy5uZXh0UGFja2V0ID0gZnVuY3Rpb24gSnB4SW1hZ2VfbmV4dFBhY2tldCgpIHtcbiAgICAgIC8vIFNlY3Rpb24gQi4xMi4xLjMgUmVzb2x1dGlvbi1wb3NpdGlvbi1jb21wb25lbnQtbGF5ZXJcbiAgICAgIGZvciAoOyByIDw9IG1heERlY29tcG9zaXRpb25MZXZlbHNDb3VudDsgcisrKSB7XG4gICAgICAgIGZvciAoOyBwIDwgbWF4TnVtUHJlY2luY3RzSW5MZXZlbFtyXTsgcCsrKSB7XG4gICAgICAgICAgZm9yICg7IGMgPCBjb21wb25lbnRzQ291bnQ7IGMrKykge1xuICAgICAgICAgICAgdmFyIGNvbXBvbmVudCA9IHRpbGUuY29tcG9uZW50c1tjXTtcbiAgICAgICAgICAgIGlmIChyID4gY29tcG9uZW50LmNvZGluZ1N0eWxlUGFyYW1ldGVycy5kZWNvbXBvc2l0aW9uTGV2ZWxzQ291bnQpIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcmVzb2x1dGlvbiA9IGNvbXBvbmVudC5yZXNvbHV0aW9uc1tyXTtcbiAgICAgICAgICAgIHZhciBudW1wcmVjaW5jdHMgPSByZXNvbHV0aW9uLnByZWNpbmN0UGFyYW1ldGVycy5udW1wcmVjaW5jdHM7XG4gICAgICAgICAgICBpZiAocCA+PSBudW1wcmVjaW5jdHMpIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKDsgbCA8IGxheWVyc0NvdW50Oykge1xuICAgICAgICAgICAgICB2YXIgcGFja2V0ID0gY3JlYXRlUGFja2V0KHJlc29sdXRpb24sIHAsIGwpO1xuICAgICAgICAgICAgICBsKys7XG4gICAgICAgICAgICAgIHJldHVybiBwYWNrZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgICAgYyA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcCA9IDA7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBQb3NpdGlvbkNvbXBvbmVudFJlc29sdXRpb25MYXllckl0ZXJhdG9yKGNvbnRleHQpIHtcbiAgICB2YXIgc2l6ID0gY29udGV4dC5TSVo7XG4gICAgdmFyIHRpbGVJbmRleCA9IGNvbnRleHQuY3VycmVudFRpbGUuaW5kZXg7XG4gICAgdmFyIHRpbGUgPSBjb250ZXh0LnRpbGVzW3RpbGVJbmRleF07XG4gICAgdmFyIGxheWVyc0NvdW50ID0gdGlsZS5jb2RpbmdTdHlsZURlZmF1bHRQYXJhbWV0ZXJzLmxheWVyc0NvdW50O1xuICAgIHZhciBjb21wb25lbnRzQ291bnQgPSBzaXouQ3NpejtcbiAgICB2YXIgcHJlY2luY3RzU2l6ZXMgPSBnZXRQcmVjaW5jdFNpemVzSW5JbWFnZVNjYWxlKHRpbGUpO1xuICAgIHZhciBwcmVjaW5jdHNJdGVyYXRpb25TaXplcyA9IHByZWNpbmN0c1NpemVzO1xuICAgIHZhciBsID0gMCwgciA9IDAsIGMgPSAwLCBweCA9IDAsIHB5ID0gMDtcblxuICAgIHRoaXMubmV4dFBhY2tldCA9IGZ1bmN0aW9uIEpweEltYWdlX25leHRQYWNrZXQoKSB7XG4gICAgICAvLyBTZWN0aW9uIEIuMTIuMS40IFBvc2l0aW9uLWNvbXBvbmVudC1yZXNvbHV0aW9uLWxheWVyXG4gICAgICBmb3IgKDsgcHkgPCBwcmVjaW5jdHNJdGVyYXRpb25TaXplcy5tYXhOdW1IaWdoOyBweSsrKSB7XG4gICAgICAgIGZvciAoOyBweCA8IHByZWNpbmN0c0l0ZXJhdGlvblNpemVzLm1heE51bVdpZGU7IHB4KyspIHtcbiAgICAgICAgICBmb3IgKDsgYyA8IGNvbXBvbmVudHNDb3VudDsgYysrKSB7XG4gICAgICAgICAgICB2YXIgY29tcG9uZW50ID0gdGlsZS5jb21wb25lbnRzW2NdO1xuICAgICAgICAgICAgdmFyIGRlY29tcG9zaXRpb25MZXZlbHNDb3VudCA9XG4gICAgICAgICAgICAgIGNvbXBvbmVudC5jb2RpbmdTdHlsZVBhcmFtZXRlcnMuZGVjb21wb3NpdGlvbkxldmVsc0NvdW50O1xuICAgICAgICAgICAgZm9yICg7IHIgPD0gZGVjb21wb3NpdGlvbkxldmVsc0NvdW50OyByKyspIHtcbiAgICAgICAgICAgICAgdmFyIHJlc29sdXRpb24gPSBjb21wb25lbnQucmVzb2x1dGlvbnNbcl07XG4gICAgICAgICAgICAgIHZhciBzaXplSW5JbWFnZVNjYWxlID1cbiAgICAgICAgICAgICAgICBwcmVjaW5jdHNTaXplcy5jb21wb25lbnRzW2NdLnJlc29sdXRpb25zW3JdO1xuICAgICAgICAgICAgICB2YXIgayA9IGdldFByZWNpbmN0SW5kZXhJZkV4aXN0KFxuICAgICAgICAgICAgICAgIHB4LFxuICAgICAgICAgICAgICAgIHB5LFxuICAgICAgICAgICAgICAgIHNpemVJbkltYWdlU2NhbGUsXG4gICAgICAgICAgICAgICAgcHJlY2luY3RzSXRlcmF0aW9uU2l6ZXMsXG4gICAgICAgICAgICAgICAgcmVzb2x1dGlvbik7XG4gICAgICAgICAgICAgIGlmIChrID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZm9yICg7IGwgPCBsYXllcnNDb3VudDspIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFja2V0ID0gY3JlYXRlUGFja2V0KHJlc29sdXRpb24sIGssIGwpO1xuICAgICAgICAgICAgICAgIGwrKztcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFja2V0O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGwgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgciA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICAgIGMgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHB4ID0gMDtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIENvbXBvbmVudFBvc2l0aW9uUmVzb2x1dGlvbkxheWVySXRlcmF0b3IoY29udGV4dCkge1xuICAgIHZhciBzaXogPSBjb250ZXh0LlNJWjtcbiAgICB2YXIgdGlsZUluZGV4ID0gY29udGV4dC5jdXJyZW50VGlsZS5pbmRleDtcbiAgICB2YXIgdGlsZSA9IGNvbnRleHQudGlsZXNbdGlsZUluZGV4XTtcbiAgICB2YXIgbGF5ZXJzQ291bnQgPSB0aWxlLmNvZGluZ1N0eWxlRGVmYXVsdFBhcmFtZXRlcnMubGF5ZXJzQ291bnQ7XG4gICAgdmFyIGNvbXBvbmVudHNDb3VudCA9IHNpei5Dc2l6O1xuICAgIHZhciBwcmVjaW5jdHNTaXplcyA9IGdldFByZWNpbmN0U2l6ZXNJbkltYWdlU2NhbGUodGlsZSk7XG4gICAgdmFyIGwgPSAwLCByID0gMCwgYyA9IDAsIHB4ID0gMCwgcHkgPSAwO1xuXG4gICAgdGhpcy5uZXh0UGFja2V0ID0gZnVuY3Rpb24gSnB4SW1hZ2VfbmV4dFBhY2tldCgpIHtcbiAgICAgIC8vIFNlY3Rpb24gQi4xMi4xLjUgQ29tcG9uZW50LXBvc2l0aW9uLXJlc29sdXRpb24tbGF5ZXJcbiAgICAgIGZvciAoOyBjIDwgY29tcG9uZW50c0NvdW50OyArK2MpIHtcbiAgICAgICAgdmFyIGNvbXBvbmVudCA9IHRpbGUuY29tcG9uZW50c1tjXTtcbiAgICAgICAgdmFyIHByZWNpbmN0c0l0ZXJhdGlvblNpemVzID0gcHJlY2luY3RzU2l6ZXMuY29tcG9uZW50c1tjXTtcbiAgICAgICAgdmFyIGRlY29tcG9zaXRpb25MZXZlbHNDb3VudCA9XG4gICAgICAgICAgY29tcG9uZW50LmNvZGluZ1N0eWxlUGFyYW1ldGVycy5kZWNvbXBvc2l0aW9uTGV2ZWxzQ291bnQ7XG4gICAgICAgIGZvciAoOyBweSA8IHByZWNpbmN0c0l0ZXJhdGlvblNpemVzLm1heE51bUhpZ2g7IHB5KyspIHtcbiAgICAgICAgICBmb3IgKDsgcHggPCBwcmVjaW5jdHNJdGVyYXRpb25TaXplcy5tYXhOdW1XaWRlOyBweCsrKSB7XG4gICAgICAgICAgICBmb3IgKDsgciA8PSBkZWNvbXBvc2l0aW9uTGV2ZWxzQ291bnQ7IHIrKykge1xuICAgICAgICAgICAgICB2YXIgcmVzb2x1dGlvbiA9IGNvbXBvbmVudC5yZXNvbHV0aW9uc1tyXTtcbiAgICAgICAgICAgICAgdmFyIHNpemVJbkltYWdlU2NhbGUgPSBwcmVjaW5jdHNJdGVyYXRpb25TaXplcy5yZXNvbHV0aW9uc1tyXTtcbiAgICAgICAgICAgICAgdmFyIGsgPSBnZXRQcmVjaW5jdEluZGV4SWZFeGlzdChcbiAgICAgICAgICAgICAgICBweCxcbiAgICAgICAgICAgICAgICBweSxcbiAgICAgICAgICAgICAgICBzaXplSW5JbWFnZVNjYWxlLFxuICAgICAgICAgICAgICAgIHByZWNpbmN0c0l0ZXJhdGlvblNpemVzLFxuICAgICAgICAgICAgICAgIHJlc29sdXRpb24pO1xuICAgICAgICAgICAgICBpZiAoayA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGZvciAoOyBsIDwgbGF5ZXJzQ291bnQ7KSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhY2tldCA9IGNyZWF0ZVBhY2tldChyZXNvbHV0aW9uLCBrLCBsKTtcbiAgICAgICAgICAgICAgICBsKys7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhY2tldDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBsID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHIgPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgICBweCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcHkgPSAwO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gZ2V0UHJlY2luY3RJbmRleElmRXhpc3QoXG4gICAgcHhJbmRleCwgcHlJbmRleCwgc2l6ZUluSW1hZ2VTY2FsZSwgcHJlY2luY3RJdGVyYXRpb25TaXplcywgcmVzb2x1dGlvbikge1xuICAgIHZhciBwb3NYID0gcHhJbmRleCAqIHByZWNpbmN0SXRlcmF0aW9uU2l6ZXMubWluV2lkdGg7XG4gICAgdmFyIHBvc1kgPSBweUluZGV4ICogcHJlY2luY3RJdGVyYXRpb25TaXplcy5taW5IZWlnaHQ7XG4gICAgaWYgKHBvc1ggJSBzaXplSW5JbWFnZVNjYWxlLndpZHRoICE9PSAwIHx8XG4gICAgICAgIHBvc1kgJSBzaXplSW5JbWFnZVNjYWxlLmhlaWdodCAhPT0gMCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciBzdGFydFByZWNpbmN0Um93SW5kZXggPVxuICAgICAgKHBvc1kgLyBzaXplSW5JbWFnZVNjYWxlLndpZHRoKSAqXG4gICAgICByZXNvbHV0aW9uLnByZWNpbmN0UGFyYW1ldGVycy5udW1wcmVjaW5jdHN3aWRlO1xuICAgIHJldHVybiAocG9zWCAvIHNpemVJbkltYWdlU2NhbGUuaGVpZ2h0KSArIHN0YXJ0UHJlY2luY3RSb3dJbmRleDtcbiAgfVxuICBmdW5jdGlvbiBnZXRQcmVjaW5jdFNpemVzSW5JbWFnZVNjYWxlKHRpbGUpIHtcbiAgICB2YXIgY29tcG9uZW50c0NvdW50ID0gdGlsZS5jb21wb25lbnRzLmxlbmd0aDtcbiAgICB2YXIgbWluV2lkdGggPSBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgIHZhciBtaW5IZWlnaHQgPSBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgIHZhciBtYXhOdW1XaWRlID0gMDtcbiAgICB2YXIgbWF4TnVtSGlnaCA9IDA7XG4gICAgdmFyIHNpemVQZXJDb21wb25lbnQgPSBuZXcgQXJyYXkoY29tcG9uZW50c0NvdW50KTtcbiAgICBmb3IgKHZhciBjID0gMDsgYyA8IGNvbXBvbmVudHNDb3VudDsgYysrKSB7XG4gICAgICB2YXIgY29tcG9uZW50ID0gdGlsZS5jb21wb25lbnRzW2NdO1xuICAgICAgdmFyIGRlY29tcG9zaXRpb25MZXZlbHNDb3VudCA9XG4gICAgICAgIGNvbXBvbmVudC5jb2RpbmdTdHlsZVBhcmFtZXRlcnMuZGVjb21wb3NpdGlvbkxldmVsc0NvdW50O1xuICAgICAgdmFyIHNpemVQZXJSZXNvbHV0aW9uID0gbmV3IEFycmF5KGRlY29tcG9zaXRpb25MZXZlbHNDb3VudCArIDEpO1xuICAgICAgdmFyIG1pbldpZHRoQ3VycmVudENvbXBvbmVudCA9IE51bWJlci5NQVhfVkFMVUU7XG4gICAgICB2YXIgbWluSGVpZ2h0Q3VycmVudENvbXBvbmVudCA9IE51bWJlci5NQVhfVkFMVUU7XG4gICAgICB2YXIgbWF4TnVtV2lkZUN1cnJlbnRDb21wb25lbnQgPSAwO1xuICAgICAgdmFyIG1heE51bUhpZ2hDdXJyZW50Q29tcG9uZW50ID0gMDtcbiAgICAgIHZhciBzY2FsZSA9IDE7XG4gICAgICBmb3IgKHZhciByID0gZGVjb21wb3NpdGlvbkxldmVsc0NvdW50OyByID49IDA7IC0tcikge1xuICAgICAgICB2YXIgcmVzb2x1dGlvbiA9IGNvbXBvbmVudC5yZXNvbHV0aW9uc1tyXTtcbiAgICAgICAgdmFyIHdpZHRoQ3VycmVudFJlc29sdXRpb24gPVxuICAgICAgICAgIHNjYWxlICogcmVzb2x1dGlvbi5wcmVjaW5jdFBhcmFtZXRlcnMucHJlY2luY3RXaWR0aDtcbiAgICAgICAgdmFyIGhlaWdodEN1cnJlbnRSZXNvbHV0aW9uID1cbiAgICAgICAgICBzY2FsZSAqIHJlc29sdXRpb24ucHJlY2luY3RQYXJhbWV0ZXJzLnByZWNpbmN0SGVpZ2h0O1xuICAgICAgICBtaW5XaWR0aEN1cnJlbnRDb21wb25lbnQgPSBNYXRoLm1pbihcbiAgICAgICAgICBtaW5XaWR0aEN1cnJlbnRDb21wb25lbnQsXG4gICAgICAgICAgd2lkdGhDdXJyZW50UmVzb2x1dGlvbik7XG4gICAgICAgIG1pbkhlaWdodEN1cnJlbnRDb21wb25lbnQgPSBNYXRoLm1pbihcbiAgICAgICAgICBtaW5IZWlnaHRDdXJyZW50Q29tcG9uZW50LFxuICAgICAgICAgIGhlaWdodEN1cnJlbnRSZXNvbHV0aW9uKTtcbiAgICAgICAgbWF4TnVtV2lkZUN1cnJlbnRDb21wb25lbnQgPSBNYXRoLm1heChtYXhOdW1XaWRlQ3VycmVudENvbXBvbmVudCxcbiAgICAgICAgICByZXNvbHV0aW9uLnByZWNpbmN0UGFyYW1ldGVycy5udW1wcmVjaW5jdHN3aWRlKTtcbiAgICAgICAgbWF4TnVtSGlnaEN1cnJlbnRDb21wb25lbnQgPSBNYXRoLm1heChtYXhOdW1IaWdoQ3VycmVudENvbXBvbmVudCxcbiAgICAgICAgICByZXNvbHV0aW9uLnByZWNpbmN0UGFyYW1ldGVycy5udW1wcmVjaW5jdHNoaWdoKTtcbiAgICAgICAgc2l6ZVBlclJlc29sdXRpb25bcl0gPSB7XG4gICAgICAgICAgd2lkdGg6IHdpZHRoQ3VycmVudFJlc29sdXRpb24sXG4gICAgICAgICAgaGVpZ2h0OiBoZWlnaHRDdXJyZW50UmVzb2x1dGlvblxuICAgICAgICB9O1xuICAgICAgICBzY2FsZSA8PD0gMTtcbiAgICAgIH1cbiAgICAgIG1pbldpZHRoID0gTWF0aC5taW4obWluV2lkdGgsIG1pbldpZHRoQ3VycmVudENvbXBvbmVudCk7XG4gICAgICBtaW5IZWlnaHQgPSBNYXRoLm1pbihtaW5IZWlnaHQsIG1pbkhlaWdodEN1cnJlbnRDb21wb25lbnQpO1xuICAgICAgbWF4TnVtV2lkZSA9IE1hdGgubWF4KG1heE51bVdpZGUsIG1heE51bVdpZGVDdXJyZW50Q29tcG9uZW50KTtcbiAgICAgIG1heE51bUhpZ2ggPSBNYXRoLm1heChtYXhOdW1IaWdoLCBtYXhOdW1IaWdoQ3VycmVudENvbXBvbmVudCk7XG4gICAgICBzaXplUGVyQ29tcG9uZW50W2NdID0ge1xuICAgICAgICByZXNvbHV0aW9uczogc2l6ZVBlclJlc29sdXRpb24sXG4gICAgICAgIG1pbldpZHRoOiBtaW5XaWR0aEN1cnJlbnRDb21wb25lbnQsXG4gICAgICAgIG1pbkhlaWdodDogbWluSGVpZ2h0Q3VycmVudENvbXBvbmVudCxcbiAgICAgICAgbWF4TnVtV2lkZTogbWF4TnVtV2lkZUN1cnJlbnRDb21wb25lbnQsXG4gICAgICAgIG1heE51bUhpZ2g6IG1heE51bUhpZ2hDdXJyZW50Q29tcG9uZW50XG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgY29tcG9uZW50czogc2l6ZVBlckNvbXBvbmVudCxcbiAgICAgIG1pbldpZHRoOiBtaW5XaWR0aCxcbiAgICAgIG1pbkhlaWdodDogbWluSGVpZ2h0LFxuICAgICAgbWF4TnVtV2lkZTogbWF4TnVtV2lkZSxcbiAgICAgIG1heE51bUhpZ2g6IG1heE51bUhpZ2hcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGJ1aWxkUGFja2V0cyhjb250ZXh0KSB7XG4gICAgdmFyIHNpeiA9IGNvbnRleHQuU0laO1xuICAgIHZhciB0aWxlSW5kZXggPSBjb250ZXh0LmN1cnJlbnRUaWxlLmluZGV4O1xuICAgIHZhciB0aWxlID0gY29udGV4dC50aWxlc1t0aWxlSW5kZXhdO1xuICAgIHZhciBjb21wb25lbnRzQ291bnQgPSBzaXouQ3NpejtcbiAgICAvLyBDcmVhdGluZyByZXNvbHV0aW9ucyBhbmQgc3ViLWJhbmRzIGZvciBlYWNoIGNvbXBvbmVudFxuICAgIGZvciAodmFyIGMgPSAwOyBjIDwgY29tcG9uZW50c0NvdW50OyBjKyspIHtcbiAgICAgIHZhciBjb21wb25lbnQgPSB0aWxlLmNvbXBvbmVudHNbY107XG4gICAgICB2YXIgZGVjb21wb3NpdGlvbkxldmVsc0NvdW50ID1cbiAgICAgICAgY29tcG9uZW50LmNvZGluZ1N0eWxlUGFyYW1ldGVycy5kZWNvbXBvc2l0aW9uTGV2ZWxzQ291bnQ7XG4gICAgICAvLyBTZWN0aW9uIEIuNSBSZXNvbHV0aW9uIGxldmVscyBhbmQgc3ViLWJhbmRzXG4gICAgICB2YXIgcmVzb2x1dGlvbnMgPSBbXTtcbiAgICAgIHZhciBzdWJiYW5kcyA9IFtdO1xuICAgICAgZm9yICh2YXIgciA9IDA7IHIgPD0gZGVjb21wb3NpdGlvbkxldmVsc0NvdW50OyByKyspIHtcbiAgICAgICAgdmFyIGJsb2Nrc0RpbWVuc2lvbnMgPSBnZXRCbG9ja3NEaW1lbnNpb25zKGNvbnRleHQsIGNvbXBvbmVudCwgcik7XG4gICAgICAgIHZhciByZXNvbHV0aW9uID0ge307XG4gICAgICAgIHZhciBzY2FsZSA9IDEgPDwgKGRlY29tcG9zaXRpb25MZXZlbHNDb3VudCAtIHIpO1xuICAgICAgICByZXNvbHV0aW9uLnRyeDAgPSBNYXRoLmNlaWwoY29tcG9uZW50LnRjeDAgLyBzY2FsZSk7XG4gICAgICAgIHJlc29sdXRpb24udHJ5MCA9IE1hdGguY2VpbChjb21wb25lbnQudGN5MCAvIHNjYWxlKTtcbiAgICAgICAgcmVzb2x1dGlvbi50cngxID0gTWF0aC5jZWlsKGNvbXBvbmVudC50Y3gxIC8gc2NhbGUpO1xuICAgICAgICByZXNvbHV0aW9uLnRyeTEgPSBNYXRoLmNlaWwoY29tcG9uZW50LnRjeTEgLyBzY2FsZSk7XG4gICAgICAgIHJlc29sdXRpb24ucmVzTGV2ZWwgPSByO1xuICAgICAgICBidWlsZFByZWNpbmN0cyhjb250ZXh0LCByZXNvbHV0aW9uLCBibG9ja3NEaW1lbnNpb25zKTtcbiAgICAgICAgcmVzb2x1dGlvbnMucHVzaChyZXNvbHV0aW9uKTtcblxuICAgICAgICB2YXIgc3ViYmFuZDtcbiAgICAgICAgaWYgKHIgPT09IDApIHtcbiAgICAgICAgICAvLyBvbmUgc3ViLWJhbmQgKExMKSB3aXRoIGxhc3QgZGVjb21wb3NpdGlvblxuICAgICAgICAgIHN1YmJhbmQgPSB7fTtcbiAgICAgICAgICBzdWJiYW5kLnR5cGUgPSAnTEwnO1xuICAgICAgICAgIHN1YmJhbmQudGJ4MCA9IE1hdGguY2VpbChjb21wb25lbnQudGN4MCAvIHNjYWxlKTtcbiAgICAgICAgICBzdWJiYW5kLnRieTAgPSBNYXRoLmNlaWwoY29tcG9uZW50LnRjeTAgLyBzY2FsZSk7XG4gICAgICAgICAgc3ViYmFuZC50YngxID0gTWF0aC5jZWlsKGNvbXBvbmVudC50Y3gxIC8gc2NhbGUpO1xuICAgICAgICAgIHN1YmJhbmQudGJ5MSA9IE1hdGguY2VpbChjb21wb25lbnQudGN5MSAvIHNjYWxlKTtcbiAgICAgICAgICBzdWJiYW5kLnJlc29sdXRpb24gPSByZXNvbHV0aW9uO1xuICAgICAgICAgIGJ1aWxkQ29kZWJsb2Nrcyhjb250ZXh0LCBzdWJiYW5kLCBibG9ja3NEaW1lbnNpb25zKTtcbiAgICAgICAgICBzdWJiYW5kcy5wdXNoKHN1YmJhbmQpO1xuICAgICAgICAgIHJlc29sdXRpb24uc3ViYmFuZHMgPSBbc3ViYmFuZF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGJzY2FsZSA9IDEgPDwgKGRlY29tcG9zaXRpb25MZXZlbHNDb3VudCAtIHIgKyAxKTtcbiAgICAgICAgICB2YXIgcmVzb2x1dGlvblN1YmJhbmRzID0gW107XG4gICAgICAgICAgLy8gdGhyZWUgc3ViLWJhbmRzIChITCwgTEggYW5kIEhIKSB3aXRoIHJlc3Qgb2YgZGVjb21wb3NpdGlvbnNcbiAgICAgICAgICBzdWJiYW5kID0ge307XG4gICAgICAgICAgc3ViYmFuZC50eXBlID0gJ0hMJztcbiAgICAgICAgICBzdWJiYW5kLnRieDAgPSBNYXRoLmNlaWwoY29tcG9uZW50LnRjeDAgLyBic2NhbGUgLSAwLjUpO1xuICAgICAgICAgIHN1YmJhbmQudGJ5MCA9IE1hdGguY2VpbChjb21wb25lbnQudGN5MCAvIGJzY2FsZSk7XG4gICAgICAgICAgc3ViYmFuZC50YngxID0gTWF0aC5jZWlsKGNvbXBvbmVudC50Y3gxIC8gYnNjYWxlIC0gMC41KTtcbiAgICAgICAgICBzdWJiYW5kLnRieTEgPSBNYXRoLmNlaWwoY29tcG9uZW50LnRjeTEgLyBic2NhbGUpO1xuICAgICAgICAgIHN1YmJhbmQucmVzb2x1dGlvbiA9IHJlc29sdXRpb247XG4gICAgICAgICAgYnVpbGRDb2RlYmxvY2tzKGNvbnRleHQsIHN1YmJhbmQsIGJsb2Nrc0RpbWVuc2lvbnMpO1xuICAgICAgICAgIHN1YmJhbmRzLnB1c2goc3ViYmFuZCk7XG4gICAgICAgICAgcmVzb2x1dGlvblN1YmJhbmRzLnB1c2goc3ViYmFuZCk7XG5cbiAgICAgICAgICBzdWJiYW5kID0ge307XG4gICAgICAgICAgc3ViYmFuZC50eXBlID0gJ0xIJztcbiAgICAgICAgICBzdWJiYW5kLnRieDAgPSBNYXRoLmNlaWwoY29tcG9uZW50LnRjeDAgLyBic2NhbGUpO1xuICAgICAgICAgIHN1YmJhbmQudGJ5MCA9IE1hdGguY2VpbChjb21wb25lbnQudGN5MCAvIGJzY2FsZSAtIDAuNSk7XG4gICAgICAgICAgc3ViYmFuZC50YngxID0gTWF0aC5jZWlsKGNvbXBvbmVudC50Y3gxIC8gYnNjYWxlKTtcbiAgICAgICAgICBzdWJiYW5kLnRieTEgPSBNYXRoLmNlaWwoY29tcG9uZW50LnRjeTEgLyBic2NhbGUgLSAwLjUpO1xuICAgICAgICAgIHN1YmJhbmQucmVzb2x1dGlvbiA9IHJlc29sdXRpb247XG4gICAgICAgICAgYnVpbGRDb2RlYmxvY2tzKGNvbnRleHQsIHN1YmJhbmQsIGJsb2Nrc0RpbWVuc2lvbnMpO1xuICAgICAgICAgIHN1YmJhbmRzLnB1c2goc3ViYmFuZCk7XG4gICAgICAgICAgcmVzb2x1dGlvblN1YmJhbmRzLnB1c2goc3ViYmFuZCk7XG5cbiAgICAgICAgICBzdWJiYW5kID0ge307XG4gICAgICAgICAgc3ViYmFuZC50eXBlID0gJ0hIJztcbiAgICAgICAgICBzdWJiYW5kLnRieDAgPSBNYXRoLmNlaWwoY29tcG9uZW50LnRjeDAgLyBic2NhbGUgLSAwLjUpO1xuICAgICAgICAgIHN1YmJhbmQudGJ5MCA9IE1hdGguY2VpbChjb21wb25lbnQudGN5MCAvIGJzY2FsZSAtIDAuNSk7XG4gICAgICAgICAgc3ViYmFuZC50YngxID0gTWF0aC5jZWlsKGNvbXBvbmVudC50Y3gxIC8gYnNjYWxlIC0gMC41KTtcbiAgICAgICAgICBzdWJiYW5kLnRieTEgPSBNYXRoLmNlaWwoY29tcG9uZW50LnRjeTEgLyBic2NhbGUgLSAwLjUpO1xuICAgICAgICAgIHN1YmJhbmQucmVzb2x1dGlvbiA9IHJlc29sdXRpb247XG4gICAgICAgICAgYnVpbGRDb2RlYmxvY2tzKGNvbnRleHQsIHN1YmJhbmQsIGJsb2Nrc0RpbWVuc2lvbnMpO1xuICAgICAgICAgIHN1YmJhbmRzLnB1c2goc3ViYmFuZCk7XG4gICAgICAgICAgcmVzb2x1dGlvblN1YmJhbmRzLnB1c2goc3ViYmFuZCk7XG5cbiAgICAgICAgICByZXNvbHV0aW9uLnN1YmJhbmRzID0gcmVzb2x1dGlvblN1YmJhbmRzO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb21wb25lbnQucmVzb2x1dGlvbnMgPSByZXNvbHV0aW9ucztcbiAgICAgIGNvbXBvbmVudC5zdWJiYW5kcyA9IHN1YmJhbmRzO1xuICAgIH1cbiAgICAvLyBHZW5lcmF0ZSB0aGUgcGFja2V0cyBzZXF1ZW5jZVxuICAgIHZhciBwcm9ncmVzc2lvbk9yZGVyID0gdGlsZS5jb2RpbmdTdHlsZURlZmF1bHRQYXJhbWV0ZXJzLnByb2dyZXNzaW9uT3JkZXI7XG4gICAgc3dpdGNoIChwcm9ncmVzc2lvbk9yZGVyKSB7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIHRpbGUucGFja2V0c0l0ZXJhdG9yID1cbiAgICAgICAgICBuZXcgTGF5ZXJSZXNvbHV0aW9uQ29tcG9uZW50UG9zaXRpb25JdGVyYXRvcihjb250ZXh0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIHRpbGUucGFja2V0c0l0ZXJhdG9yID1cbiAgICAgICAgICBuZXcgUmVzb2x1dGlvbkxheWVyQ29tcG9uZW50UG9zaXRpb25JdGVyYXRvcihjb250ZXh0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIHRpbGUucGFja2V0c0l0ZXJhdG9yID1cbiAgICAgICAgICBuZXcgUmVzb2x1dGlvblBvc2l0aW9uQ29tcG9uZW50TGF5ZXJJdGVyYXRvcihjb250ZXh0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDM6XG4gICAgICAgIHRpbGUucGFja2V0c0l0ZXJhdG9yID1cbiAgICAgICAgICBuZXcgUG9zaXRpb25Db21wb25lbnRSZXNvbHV0aW9uTGF5ZXJJdGVyYXRvcihjb250ZXh0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDQ6XG4gICAgICAgIHRpbGUucGFja2V0c0l0ZXJhdG9yID1cbiAgICAgICAgICBuZXcgQ29tcG9uZW50UG9zaXRpb25SZXNvbHV0aW9uTGF5ZXJJdGVyYXRvcihjb250ZXh0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0pQWCBFcnJvcjogVW5zdXBwb3J0ZWQgcHJvZ3Jlc3Npb24gb3JkZXIgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9ncmVzc2lvbk9yZGVyKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gcGFyc2VUaWxlUGFja2V0cyhjb250ZXh0LCBkYXRhLCBvZmZzZXQsIGRhdGFMZW5ndGgpIHtcbiAgICB2YXIgcG9zaXRpb24gPSAwO1xuICAgIHZhciBidWZmZXIsIGJ1ZmZlclNpemUgPSAwLCBza2lwTmV4dEJpdCA9IGZhbHNlO1xuICAgIGZ1bmN0aW9uIHJlYWRCaXRzKGNvdW50KSB7XG4gICAgICB3aGlsZSAoYnVmZmVyU2l6ZSA8IGNvdW50KSB7XG4gICAgICAgIGlmKG9mZnNldCArIHBvc2l0aW9uICA+PSBkYXRhLmxlbmd0aCl7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBFT0ZcIik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGIgPSBkYXRhW29mZnNldCArIHBvc2l0aW9uXTtcbiAgICAgICAgcG9zaXRpb24rKztcbiAgICAgICAgaWYgKHNraXBOZXh0Qml0KSB7XG4gICAgICAgICAgYnVmZmVyID0gKGJ1ZmZlciA8PCA3KSB8IGI7XG4gICAgICAgICAgYnVmZmVyU2l6ZSArPSA3O1xuICAgICAgICAgIHNraXBOZXh0Qml0ID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYnVmZmVyID0gKGJ1ZmZlciA8PCA4KSB8IGI7XG4gICAgICAgICAgYnVmZmVyU2l6ZSArPSA4O1xuICAgICAgICB9XG4gICAgICAgIGlmIChiID09PSAweEZGKSB7XG4gICAgICAgICAgc2tpcE5leHRCaXQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBidWZmZXJTaXplIC09IGNvdW50O1xuICAgICAgcmV0dXJuIChidWZmZXIgPj4+IGJ1ZmZlclNpemUpICYgKCgxIDw8IGNvdW50KSAtIDEpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBza2lwTWFya2VySWZFcXVhbCh2YWx1ZSkge1xuICAgICAgaWYgKGRhdGFbb2Zmc2V0ICsgcG9zaXRpb24gLSAxXSA9PT0gMHhGRiAmJlxuICAgICAgICAgIGRhdGFbb2Zmc2V0ICsgcG9zaXRpb25dID09PSB2YWx1ZSkge1xuICAgICAgICBza2lwQnl0ZXMoMSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChkYXRhW29mZnNldCArIHBvc2l0aW9uXSA9PT0gMHhGRiAmJlxuICAgICAgICAgICAgICAgICBkYXRhW29mZnNldCArIHBvc2l0aW9uICsgMV0gPT09IHZhbHVlKSB7XG4gICAgICAgIHNraXBCeXRlcygyKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNraXBCeXRlcyhjb3VudCkge1xuICAgICAgcG9zaXRpb24gKz0gY291bnQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFsaWduVG9CeXRlKCkge1xuICAgICAgYnVmZmVyU2l6ZSA9IDA7XG4gICAgICBpZiAoc2tpcE5leHRCaXQpIHtcbiAgICAgICAgcG9zaXRpb24rKztcbiAgICAgICAgc2tpcE5leHRCaXQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcmVhZENvZGluZ3Bhc3NlcygpIHtcbiAgICAgIGlmIChyZWFkQml0cygxKSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH1cbiAgICAgIGlmIChyZWFkQml0cygxKSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gMjtcbiAgICAgIH1cbiAgICAgIHZhciB2YWx1ZSA9IHJlYWRCaXRzKDIpO1xuICAgICAgaWYgKHZhbHVlIDwgMykge1xuICAgICAgICByZXR1cm4gdmFsdWUgKyAzO1xuICAgICAgfVxuICAgICAgdmFsdWUgPSByZWFkQml0cyg1KTtcbiAgICAgIGlmICh2YWx1ZSA8IDMxKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSArIDY7XG4gICAgICB9XG4gICAgICB2YWx1ZSA9IHJlYWRCaXRzKDcpO1xuICAgICAgcmV0dXJuIHZhbHVlICsgMzc7XG4gICAgfVxuICAgIHZhciB0aWxlSW5kZXggPSBjb250ZXh0LmN1cnJlbnRUaWxlLmluZGV4O1xuICAgIHZhciB0aWxlID0gY29udGV4dC50aWxlc1t0aWxlSW5kZXhdO1xuICAgIHZhciBzb3BNYXJrZXJVc2VkID0gY29udGV4dC5DT0Quc29wTWFya2VyVXNlZDtcbiAgICB2YXIgZXBoTWFya2VyVXNlZCA9IGNvbnRleHQuQ09ELmVwaE1hcmtlclVzZWQ7XG4gICAgdmFyIHBhY2tldHNJdGVyYXRvciA9IHRpbGUucGFja2V0c0l0ZXJhdG9yO1xuICAgIHdoaWxlIChwb3NpdGlvbiA8IGRhdGFMZW5ndGgpIHtcbiAgICAgIHRyeXtcbiAgICAgICAgYWxpZ25Ub0J5dGUoKTtcbiAgICAgICAgaWYgKHNvcE1hcmtlclVzZWQgJiYgc2tpcE1hcmtlcklmRXF1YWwoMHg5MSkpIHtcbiAgICAgICAgICAvLyBTa2lwIGFsc28gbWFya2VyIHNlZ21lbnQgbGVuZ3RoIGFuZCBwYWNrZXQgc2VxdWVuY2UgSURcbiAgICAgICAgICBza2lwQnl0ZXMoNCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBhY2tldCA9IHBhY2tldHNJdGVyYXRvci5uZXh0UGFja2V0KCk7XG4gICAgICAgIGlmIChwYWNrZXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIC8vTm8gbW9yZSBwYWNrZXRzLiBTdHJlYW0gaXMgcHJvYmFibHkgdHJ1bmNhdGVkLlxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJlYWRCaXRzKDEpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxheWVyTnVtYmVyID0gcGFja2V0LmxheWVyTnVtYmVyO1xuICAgICAgICB2YXIgcXVldWUgPSBbXSwgY29kZWJsb2NrO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBwYWNrZXQuY29kZWJsb2Nrcy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgICAgY29kZWJsb2NrID0gcGFja2V0LmNvZGVibG9ja3NbaV07XG4gICAgICAgICAgdmFyIHByZWNpbmN0ID0gY29kZWJsb2NrLnByZWNpbmN0O1xuICAgICAgICAgIHZhciBjb2RlYmxvY2tDb2x1bW4gPSBjb2RlYmxvY2suY2J4IC0gcHJlY2luY3QuY2J4TWluO1xuICAgICAgICAgIHZhciBjb2RlYmxvY2tSb3cgPSBjb2RlYmxvY2suY2J5IC0gcHJlY2luY3QuY2J5TWluO1xuICAgICAgICAgIHZhciBjb2RlYmxvY2tJbmNsdWRlZCA9IGZhbHNlO1xuICAgICAgICAgIHZhciBmaXJzdFRpbWVJbmNsdXNpb24gPSBmYWxzZTtcbiAgICAgICAgICB2YXIgdmFsdWVSZWFkeTtcbiAgICAgICAgICBpZiAoY29kZWJsb2NrWydpbmNsdWRlZCddICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvZGVibG9ja0luY2x1ZGVkID0gISFyZWFkQml0cygxKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gcmVhZGluZyBpbmNsdXNpb24gdHJlZVxuICAgICAgICAgICAgcHJlY2luY3QgPSBjb2RlYmxvY2sucHJlY2luY3Q7XG4gICAgICAgICAgICB2YXIgaW5jbHVzaW9uVHJlZSwgemVyb0JpdFBsYW5lc1RyZWU7XG4gICAgICAgICAgICBpZiAocHJlY2luY3RbJ2luY2x1c2lvblRyZWUnXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIGluY2x1c2lvblRyZWUgPSBwcmVjaW5jdC5pbmNsdXNpb25UcmVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gYnVpbGRpbmcgaW5jbHVzaW9uIGFuZCB6ZXJvIGJpdC1wbGFuZXMgdHJlZXNcbiAgICAgICAgICAgICAgdmFyIHdpZHRoID0gcHJlY2luY3QuY2J4TWF4IC0gcHJlY2luY3QuY2J4TWluICsgMTtcbiAgICAgICAgICAgICAgdmFyIGhlaWdodCA9IHByZWNpbmN0LmNieU1heCAtIHByZWNpbmN0LmNieU1pbiArIDE7XG4gICAgICAgICAgICAgIGluY2x1c2lvblRyZWUgPSBuZXcgSW5jbHVzaW9uVHJlZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICAgICAgemVyb0JpdFBsYW5lc1RyZWUgPSBuZXcgVGFnVHJlZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICAgICAgcHJlY2luY3QuaW5jbHVzaW9uVHJlZSA9IGluY2x1c2lvblRyZWU7XG4gICAgICAgICAgICAgIHByZWNpbmN0Lnplcm9CaXRQbGFuZXNUcmVlID0gemVyb0JpdFBsYW5lc1RyZWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGluY2x1c2lvblRyZWUucmVzZXQoY29kZWJsb2NrQ29sdW1uLCBjb2RlYmxvY2tSb3csIGxheWVyTnVtYmVyKTtcbiAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICAgIGlmIChwb3NpdGlvbiA+PSBkYXRhLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoaW5jbHVzaW9uVHJlZS5pc0Fib3ZlVGhyZXNob2xkKCkpe1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChpbmNsdXNpb25UcmVlLmlzS25vd24oKSkge1xuICAgICAgICAgICAgICAgIGluY2x1c2lvblRyZWUubmV4dExldmVsKCk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHJlYWRCaXRzKDEpKSB7XG4gICAgICAgICAgICAgICAgaW5jbHVzaW9uVHJlZS5zZXRLbm93bigpO1xuICAgICAgICAgICAgICAgIGlmIChpbmNsdXNpb25UcmVlLmlzTGVhZigpKSB7XG4gICAgICAgICAgICAgICAgICBjb2RlYmxvY2suaW5jbHVkZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgY29kZWJsb2NrSW5jbHVkZWQgPSBmaXJzdFRpbWVJbmNsdXNpb24gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGluY2x1c2lvblRyZWUubmV4dExldmVsKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGluY2x1c2lvblRyZWUuaW5jcmVtZW50VmFsdWUoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWNvZGVibG9ja0luY2x1ZGVkKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGZpcnN0VGltZUluY2x1c2lvbikge1xuICAgICAgICAgICAgemVyb0JpdFBsYW5lc1RyZWUgPSBwcmVjaW5jdC56ZXJvQml0UGxhbmVzVHJlZTtcbiAgICAgICAgICAgIHplcm9CaXRQbGFuZXNUcmVlLnJlc2V0KGNvZGVibG9ja0NvbHVtbiwgY29kZWJsb2NrUm93KTtcbiAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICAgIGlmIChwb3NpdGlvbiA+PSBkYXRhLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAocmVhZEJpdHMoMSkpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZVJlYWR5ID0gIXplcm9CaXRQbGFuZXNUcmVlLm5leHRMZXZlbCgpO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZVJlYWR5KSB7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgemVyb0JpdFBsYW5lc1RyZWUuaW5jcmVtZW50VmFsdWUoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29kZWJsb2NrLnplcm9CaXRQbGFuZXMgPSB6ZXJvQml0UGxhbmVzVHJlZS52YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGNvZGluZ3Bhc3NlcyA9IHJlYWRDb2RpbmdwYXNzZXMoKTtcbiAgICAgICAgICB3aGlsZSAocmVhZEJpdHMoMSkpIHtcbiAgICAgICAgICAgIGNvZGVibG9jay5MYmxvY2srKztcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGNvZGluZ3Bhc3Nlc0xvZzIgPSBsb2cyKGNvZGluZ3Bhc3Nlcyk7XG4gICAgICAgICAgLy8gcm91bmRpbmcgZG93biBsb2cyXG4gICAgICAgICAgdmFyIGJpdHMgPSAoKGNvZGluZ3Bhc3NlcyA8ICgxIDw8IGNvZGluZ3Bhc3Nlc0xvZzIpKSA/XG4gICAgICAgICAgICAgICAgICAgICAgY29kaW5ncGFzc2VzTG9nMiAtIDEgOiBjb2RpbmdwYXNzZXNMb2cyKSArIGNvZGVibG9jay5MYmxvY2s7XG4gICAgICAgICAgdmFyIGNvZGVkRGF0YUxlbmd0aCA9IHJlYWRCaXRzKGJpdHMpO1xuICAgICAgICAgIHF1ZXVlLnB1c2goe1xuICAgICAgICAgICAgY29kZWJsb2NrOiBjb2RlYmxvY2ssXG4gICAgICAgICAgICBjb2RpbmdwYXNzZXM6IGNvZGluZ3Bhc3NlcyxcbiAgICAgICAgICAgIGRhdGFMZW5ndGg6IGNvZGVkRGF0YUxlbmd0aFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGFsaWduVG9CeXRlKCk7XG4gICAgICAgIGlmIChlcGhNYXJrZXJVc2VkKSB7XG4gICAgICAgICAgc2tpcE1hcmtlcklmRXF1YWwoMHg5Mik7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKHF1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICB2YXIgcGFja2V0SXRlbSA9IHF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgICAgY29kZWJsb2NrID0gcGFja2V0SXRlbS5jb2RlYmxvY2s7XG4gICAgICAgICAgaWYgKGNvZGVibG9ja1snZGF0YSddID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvZGVibG9jay5kYXRhID0gW107XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvZGVibG9jay5kYXRhLnB1c2goe1xuICAgICAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgICAgIHN0YXJ0OiBvZmZzZXQgKyBwb3NpdGlvbixcbiAgICAgICAgICAgIGVuZDogb2Zmc2V0ICsgcG9zaXRpb24gKyBwYWNrZXRJdGVtLmRhdGFMZW5ndGgsXG4gICAgICAgICAgICBjb2RpbmdwYXNzZXM6IHBhY2tldEl0ZW0uY29kaW5ncGFzc2VzXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcG9zaXRpb24gKz0gcGFja2V0SXRlbS5kYXRhTGVuZ3RoO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHBvc2l0aW9uO1xuICB9XG4gIGZ1bmN0aW9uIGNvcHlDb2VmZmljaWVudHMoY29lZmZpY2llbnRzLCBsZXZlbFdpZHRoLCBsZXZlbEhlaWdodCwgc3ViYmFuZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWx0YSwgbWIsIHJldmVyc2libGUsIHNlZ21lbnRhdGlvblN5bWJvbFVzZWQpIHtcbiAgICB2YXIgeDAgPSBzdWJiYW5kLnRieDA7XG4gICAgdmFyIHkwID0gc3ViYmFuZC50YnkwO1xuICAgIHZhciB3aWR0aCA9IHN1YmJhbmQudGJ4MSAtIHN1YmJhbmQudGJ4MDtcbiAgICB2YXIgY29kZWJsb2NrcyA9IHN1YmJhbmQuY29kZWJsb2NrcztcbiAgICB2YXIgcmlnaHQgPSBzdWJiYW5kLnR5cGUuY2hhckF0KDApID09PSAnSCcgPyAxIDogMDtcbiAgICB2YXIgYm90dG9tID0gc3ViYmFuZC50eXBlLmNoYXJBdCgxKSA9PT0gJ0gnID8gbGV2ZWxXaWR0aCA6IDA7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBjb2RlYmxvY2tzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgIHZhciBjb2RlYmxvY2sgPSBjb2RlYmxvY2tzW2ldO1xuICAgICAgdmFyIGJsb2NrV2lkdGggPSBjb2RlYmxvY2sudGJ4MV8gLSBjb2RlYmxvY2sudGJ4MF87XG4gICAgICB2YXIgYmxvY2tIZWlnaHQgPSBjb2RlYmxvY2sudGJ5MV8gLSBjb2RlYmxvY2sudGJ5MF87XG4gICAgICBpZiAoYmxvY2tXaWR0aCA9PT0gMCB8fCBibG9ja0hlaWdodCA9PT0gMCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChjb2RlYmxvY2tbJ2RhdGEnXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgYml0TW9kZWwsIGN1cnJlbnRDb2RpbmdwYXNzVHlwZTtcbiAgICAgIGJpdE1vZGVsID0gbmV3IEJpdE1vZGVsKGJsb2NrV2lkdGgsIGJsb2NrSGVpZ2h0LCBjb2RlYmxvY2suc3ViYmFuZFR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlYmxvY2suemVyb0JpdFBsYW5lcywgbWIpO1xuICAgICAgY3VycmVudENvZGluZ3Bhc3NUeXBlID0gMjsgLy8gZmlyc3QgYml0IHBsYW5lIHN0YXJ0cyBmcm9tIGNsZWFudXBcblxuICAgICAgLy8gY29sbGVjdCBkYXRhXG4gICAgICB2YXIgZGF0YSA9IGNvZGVibG9jay5kYXRhLCB0b3RhbExlbmd0aCA9IDAsIGNvZGluZ3Bhc3NlcyA9IDA7XG4gICAgICB2YXIgaiwgamosIGRhdGFJdGVtO1xuICAgICAgZm9yIChqID0gMCwgamogPSBkYXRhLmxlbmd0aDsgaiA8IGpqOyBqKyspIHtcbiAgICAgICAgZGF0YUl0ZW0gPSBkYXRhW2pdO1xuICAgICAgICB0b3RhbExlbmd0aCArPSBkYXRhSXRlbS5lbmQgLSBkYXRhSXRlbS5zdGFydDtcbiAgICAgICAgY29kaW5ncGFzc2VzICs9IGRhdGFJdGVtLmNvZGluZ3Bhc3NlcztcbiAgICAgIH1cbiAgICAgIHZhciBlbmNvZGVkRGF0YSA9IG5ldyBJbnQxNkFycmF5KHRvdGFsTGVuZ3RoKTtcbiAgICAgIHZhciBwb3NpdGlvbiA9IDA7XG4gICAgICBmb3IgKGogPSAwLCBqaiA9IGRhdGEubGVuZ3RoOyBqIDwgamo7IGorKykge1xuICAgICAgICBkYXRhSXRlbSA9IGRhdGFbal07XG4gICAgICAgIHZhciBjaHVuayA9IGRhdGFJdGVtLmRhdGEuc3ViYXJyYXkoZGF0YUl0ZW0uc3RhcnQsIGRhdGFJdGVtLmVuZCk7XG4gICAgICAgIGVuY29kZWREYXRhLnNldChjaHVuaywgcG9zaXRpb24pO1xuICAgICAgICBwb3NpdGlvbiArPSBjaHVuay5sZW5ndGg7XG4gICAgICB9XG4gICAgICAvLyBkZWNvZGluZyB0aGUgaXRlbVxuICAgICAgdmFyIGRlY29kZXIgPSBuZXcgQXJpdGhtZXRpY0RlY29kZXIoZW5jb2RlZERhdGEsIDAsIHRvdGFsTGVuZ3RoKTtcbiAgICAgIGJpdE1vZGVsLnNldERlY29kZXIoZGVjb2Rlcik7XG5cbiAgICAgIGZvciAoaiA9IDA7IGogPCBjb2RpbmdwYXNzZXM7IGorKykge1xuICAgICAgICBzd2l0Y2ggKGN1cnJlbnRDb2RpbmdwYXNzVHlwZSkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGJpdE1vZGVsLnJ1blNpZ25pZmljYW5jZVByb3BvZ2F0aW9uUGFzcygpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgYml0TW9kZWwucnVuTWFnbml0dWRlUmVmaW5lbWVudFBhc3MoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIGJpdE1vZGVsLnJ1bkNsZWFudXBQYXNzKCk7XG4gICAgICAgICAgICBpZiAoc2VnbWVudGF0aW9uU3ltYm9sVXNlZCkge1xuICAgICAgICAgICAgICBiaXRNb2RlbC5jaGVja1NlZ21lbnRhdGlvblN5bWJvbCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudENvZGluZ3Bhc3NUeXBlID0gKGN1cnJlbnRDb2RpbmdwYXNzVHlwZSArIDEpICUgMztcbiAgICAgIH1cblxuICAgICAgdmFyIG9mZnNldCA9IChjb2RlYmxvY2sudGJ4MF8gLSB4MCkgKyAoY29kZWJsb2NrLnRieTBfIC0geTApICogd2lkdGg7XG4gICAgICB2YXIgc2lnbiA9IGJpdE1vZGVsLmNvZWZmaWNlbnRzU2lnbjtcbiAgICAgIHZhciBtYWduaXR1ZGUgPSBiaXRNb2RlbC5jb2VmZmljZW50c01hZ25pdHVkZTtcbiAgICAgIHZhciBiaXRzRGVjb2RlZCA9IGJpdE1vZGVsLmJpdHNEZWNvZGVkO1xuICAgICAgdmFyIG1hZ25pdHVkZUNvcnJlY3Rpb24gPSByZXZlcnNpYmxlID8gMCA6IDAuNTtcbiAgICAgIHZhciBrLCBuLCBuYjtcbiAgICAgIHBvc2l0aW9uID0gMDtcbiAgICAgIC8vIERvIHRoZSBpbnRlcmxlYXZpbmcgb2YgU2VjdGlvbiBGLjMuMyBoZXJlLCBzbyB3ZSBkbyBub3QgbmVlZFxuICAgICAgLy8gdG8gY29weSBsYXRlci4gTEwgbGV2ZWwgaXMgbm90IGludGVybGVhdmVkLCBqdXN0IGNvcGllZC5cbiAgICAgIHZhciBpbnRlcmxlYXZlID0gKHN1YmJhbmQudHlwZSAhPT0gJ0xMJyk7XG4gICAgICBmb3IgKGogPSAwOyBqIDwgYmxvY2tIZWlnaHQ7IGorKykge1xuICAgICAgICB2YXIgcm93ID0gKG9mZnNldCAvIHdpZHRoKSB8IDA7IC8vIHJvdyBpbiB0aGUgbm9uLWludGVybGVhdmVkIHN1YmJhbmRcbiAgICAgICAgdmFyIGxldmVsT2Zmc2V0ID0gMiAqIHJvdyAqIChsZXZlbFdpZHRoIC0gd2lkdGgpICsgcmlnaHQgKyBib3R0b207XG4gICAgICAgIGZvciAoayA9IDA7IGsgPCBibG9ja1dpZHRoOyBrKyspIHtcbiAgICAgICAgICBuID0gbWFnbml0dWRlW3Bvc2l0aW9uXTtcbiAgICAgICAgICBpZiAobiAhPT0gMCkge1xuICAgICAgICAgICAgbiA9IChuICsgbWFnbml0dWRlQ29ycmVjdGlvbikgKiBkZWx0YTtcbiAgICAgICAgICAgIGlmIChzaWduW3Bvc2l0aW9uXSAhPT0gMCkge1xuICAgICAgICAgICAgICBuID0gLW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuYiA9IGJpdHNEZWNvZGVkW3Bvc2l0aW9uXTtcbiAgICAgICAgICAgIHZhciBwb3MgPSBpbnRlcmxlYXZlID8gKGxldmVsT2Zmc2V0ICsgKG9mZnNldCA8PCAxKSkgOiBvZmZzZXQ7XG4gICAgICAgICAgICBpZiAocmV2ZXJzaWJsZSAmJiAobmIgPj0gbWIpKSB7XG4gICAgICAgICAgICAgIGNvZWZmaWNpZW50c1twb3NdID0gbjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNvZWZmaWNpZW50c1twb3NdID0gbiAqICgxIDw8IChtYiAtIG5iKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIG9mZnNldCsrO1xuICAgICAgICAgIHBvc2l0aW9uKys7XG4gICAgICAgIH1cbiAgICAgICAgb2Zmc2V0ICs9IHdpZHRoIC0gYmxvY2tXaWR0aDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gdHJhbnNmb3JtVGlsZShjb250ZXh0LCB0aWxlLCBjKSB7XG4gICAgdmFyIGNvbXBvbmVudCA9IHRpbGUuY29tcG9uZW50c1tjXTtcbiAgICB2YXIgY29kaW5nU3R5bGVQYXJhbWV0ZXJzID0gY29tcG9uZW50LmNvZGluZ1N0eWxlUGFyYW1ldGVycztcbiAgICB2YXIgcXVhbnRpemF0aW9uUGFyYW1ldGVycyA9IGNvbXBvbmVudC5xdWFudGl6YXRpb25QYXJhbWV0ZXJzO1xuICAgIHZhciBkZWNvbXBvc2l0aW9uTGV2ZWxzQ291bnQgPVxuICAgICAgY29kaW5nU3R5bGVQYXJhbWV0ZXJzLmRlY29tcG9zaXRpb25MZXZlbHNDb3VudDtcbiAgICB2YXIgc3BxY2RzID0gcXVhbnRpemF0aW9uUGFyYW1ldGVycy5TUHFjZHM7XG4gICAgdmFyIHNjYWxhckV4cG91bmRlZCA9IHF1YW50aXphdGlvblBhcmFtZXRlcnMuc2NhbGFyRXhwb3VuZGVkO1xuICAgIHZhciBndWFyZEJpdHMgPSBxdWFudGl6YXRpb25QYXJhbWV0ZXJzLmd1YXJkQml0cztcbiAgICB2YXIgc2VnbWVudGF0aW9uU3ltYm9sVXNlZCA9IGNvZGluZ1N0eWxlUGFyYW1ldGVycy5zZWdtZW50YXRpb25TeW1ib2xVc2VkO1xuICAgIHZhciBwcmVjaXNpb24gPSBjb250ZXh0LmNvbXBvbmVudHNbY10ucHJlY2lzaW9uO1xuXG4gICAgdmFyIHJldmVyc2libGUgPSBjb2RpbmdTdHlsZVBhcmFtZXRlcnMucmV2ZXJzaWJsZVRyYW5zZm9ybWF0aW9uO1xuICAgIHZhciB0cmFuc2Zvcm0gPSAocmV2ZXJzaWJsZSA/IG5ldyBSZXZlcnNpYmxlVHJhbnNmb3JtKCkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBJcnJldmVyc2libGVUcmFuc2Zvcm0oKSk7XG5cbiAgICB2YXIgc3ViYmFuZENvZWZmaWNpZW50cyA9IFtdO1xuICAgIHZhciBiID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8PSBkZWNvbXBvc2l0aW9uTGV2ZWxzQ291bnQ7IGkrKykge1xuICAgICAgdmFyIHJlc29sdXRpb24gPSBjb21wb25lbnQucmVzb2x1dGlvbnNbaV07XG5cbiAgICAgIHZhciB3aWR0aCA9IHJlc29sdXRpb24udHJ4MSAtIHJlc29sdXRpb24udHJ4MDtcbiAgICAgIHZhciBoZWlnaHQgPSByZXNvbHV0aW9uLnRyeTEgLSByZXNvbHV0aW9uLnRyeTA7XG4gICAgICAvLyBBbGxvY2F0ZSBzcGFjZSBmb3IgdGhlIHdob2xlIHN1YmxldmVsLlxuICAgICAgdmFyIGNvZWZmaWNpZW50cyA9IG5ldyBGbG9hdDMyQXJyYXkod2lkdGggKiBoZWlnaHQpO1xuXG4gICAgICBmb3IgKHZhciBqID0gMCwgamogPSByZXNvbHV0aW9uLnN1YmJhbmRzLmxlbmd0aDsgaiA8IGpqOyBqKyspIHtcbiAgICAgICAgdmFyIG11LCBlcHNpbG9uO1xuICAgICAgICBpZiAoIXNjYWxhckV4cG91bmRlZCkge1xuICAgICAgICAgIC8vIGZvcm11bGEgRS01XG4gICAgICAgICAgbXUgPSBzcHFjZHNbMF0ubXU7XG4gICAgICAgICAgZXBzaWxvbiA9IHNwcWNkc1swXS5lcHNpbG9uICsgKGkgPiAwID8gMSAtIGkgOiAwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtdSA9IHNwcWNkc1tiXS5tdTtcbiAgICAgICAgICBlcHNpbG9uID0gc3BxY2RzW2JdLmVwc2lsb247XG4gICAgICAgICAgYisrO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHN1YmJhbmQgPSByZXNvbHV0aW9uLnN1YmJhbmRzW2pdO1xuICAgICAgICB2YXIgZ2FpbkxvZzIgPSBTdWJiYW5kc0dhaW5Mb2cyW3N1YmJhbmQudHlwZV07XG5cbiAgICAgICAgLy8gY2FsdWxhdGUgcXVhbnRpemF0aW9uIGNvZWZmaWNpZW50IChTZWN0aW9uIEUuMS4xLjEpXG4gICAgICAgIHZhciBkZWx0YSA9IChyZXZlcnNpYmxlID8gMSA6XG4gICAgICAgICAgTWF0aC5wb3coMiwgcHJlY2lzaW9uICsgZ2FpbkxvZzIgLSBlcHNpbG9uKSAqICgxICsgbXUgLyAyMDQ4KSk7XG4gICAgICAgIHZhciBtYiA9IChndWFyZEJpdHMgKyBlcHNpbG9uIC0gMSk7XG5cbiAgICAgICAgLy8gSW4gdGhlIGZpcnN0IHJlc29sdXRpb24gbGV2ZWwsIGNvcHlDb2VmZmljaWVudHMgd2lsbCBmaWxsIHRoZVxuICAgICAgICAvLyB3aG9sZSBhcnJheSB3aXRoIGNvZWZmaWNpZW50cy4gSW4gdGhlIHN1Y2NlZGluZyBwYXNzZXMsXG4gICAgICAgIC8vIGNvcHlDb2VmZmljaWVudHMgd2lsbCBjb25zZWN1dGl2ZWx5IGZpbGwgaW4gdGhlIHZhbHVlcyB0aGF0IGJlbG9uZ1xuICAgICAgICAvLyB0byB0aGUgaW50ZXJsZWF2ZWQgcG9zaXRpb25zIG9mIHRoZSBITCwgTEgsIGFuZCBISCBjb2VmZmljaWVudHMuXG4gICAgICAgIC8vIFRoZSBMTCBjb2VmZmljaWVudHMgd2lsbCB0aGVuIGJlIGludGVybGVhdmVkIGluIFRyYW5zZm9ybS5pdGVyYXRlKCkuXG4gICAgICAgIGNvcHlDb2VmZmljaWVudHMoY29lZmZpY2llbnRzLCB3aWR0aCwgaGVpZ2h0LCBzdWJiYW5kLCBkZWx0YSwgbWIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgcmV2ZXJzaWJsZSwgc2VnbWVudGF0aW9uU3ltYm9sVXNlZCk7XG4gICAgICB9XG4gICAgICBzdWJiYW5kQ29lZmZpY2llbnRzLnB1c2goe1xuICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgICBpdGVtczogY29lZmZpY2llbnRzXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB2YXIgcmVzdWx0ID0gdHJhbnNmb3JtLmNhbGN1bGF0ZShzdWJiYW5kQ29lZmZpY2llbnRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudC50Y3gwLCBjb21wb25lbnQudGN5MCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxlZnQ6IGNvbXBvbmVudC50Y3gwLFxuICAgICAgdG9wOiBjb21wb25lbnQudGN5MCxcbiAgICAgIHdpZHRoOiByZXN1bHQud2lkdGgsXG4gICAgICBoZWlnaHQ6IHJlc3VsdC5oZWlnaHQsXG4gICAgICBpdGVtczogcmVzdWx0Lml0ZW1zXG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiB0cmFuc2Zvcm1Db21wb25lbnRzKGNvbnRleHQpIHtcbiAgICB2YXIgc2l6ID0gY29udGV4dC5TSVo7XG4gICAgdmFyIGNvbXBvbmVudHMgPSBjb250ZXh0LmNvbXBvbmVudHM7XG4gICAgdmFyIGNvbXBvbmVudHNDb3VudCA9IHNpei5Dc2l6O1xuICAgIHZhciByZXN1bHRJbWFnZXMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBjb250ZXh0LnRpbGVzLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgIHZhciB0aWxlID0gY29udGV4dC50aWxlc1tpXTtcbiAgICAgIHZhciB0cmFuc2Zvcm1lZFRpbGVzID0gW107XG4gICAgICB2YXIgYztcbiAgICAgIGZvciAoYyA9IDA7IGMgPCBjb21wb25lbnRzQ291bnQ7IGMrKykge1xuICAgICAgICB0cmFuc2Zvcm1lZFRpbGVzW2NdID0gdHJhbnNmb3JtVGlsZShjb250ZXh0LCB0aWxlLCBjKTtcbiAgICAgIH1cbiAgICAgIHZhciB0aWxlMCA9IHRyYW5zZm9ybWVkVGlsZXNbMF07XG4gICAgICB2YXIgaXNTaWduZWQgPSBjb21wb25lbnRzWzBdLmlzU2lnbmVkO1xuICAgICAgaWYgKGlzU2lnbmVkKSB7XG4gICAgICAgIHZhciBvdXQgPSBuZXcgSW50MTZBcnJheSh0aWxlMC5pdGVtcy5sZW5ndGggKiBjb21wb25lbnRzQ291bnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIG91dCA9IG5ldyBVaW50MTZBcnJheSh0aWxlMC5pdGVtcy5sZW5ndGggKiBjb21wb25lbnRzQ291bnQpO1xuICAgICAgfVxuICAgICAgdmFyIHJlc3VsdCA9IHtcbiAgICAgICAgbGVmdDogdGlsZTAubGVmdCxcbiAgICAgICAgdG9wOiB0aWxlMC50b3AsXG4gICAgICAgIHdpZHRoOiB0aWxlMC53aWR0aCxcbiAgICAgICAgaGVpZ2h0OiB0aWxlMC5oZWlnaHQsXG4gICAgICAgIGl0ZW1zOiBvdXRcbiAgICAgIH07XG5cbiAgICAgIC8vIFNlY3Rpb24gRy4yLjIgSW52ZXJzZSBtdWx0aSBjb21wb25lbnQgdHJhbnNmb3JtXG4gICAgICB2YXIgc2hpZnQsIG9mZnNldCwgbWF4LCBtaW4sIG1heEs7XG4gICAgICB2YXIgcG9zID0gMCwgaiwgamosIHkwLCB5MSwgeTIsIHIsIGcsIGIsIGssIHZhbDtcbiAgICAgIGlmICh0aWxlLmNvZGluZ1N0eWxlRGVmYXVsdFBhcmFtZXRlcnMubXVsdGlwbGVDb21wb25lbnRUcmFuc2Zvcm0pIHtcbiAgICAgICAgdmFyIGZvdXJDb21wb25lbnRzID0gY29tcG9uZW50c0NvdW50ID09PSA0O1xuICAgICAgICB2YXIgeTBpdGVtcyA9IHRyYW5zZm9ybWVkVGlsZXNbMF0uaXRlbXM7XG4gICAgICAgIHZhciB5MWl0ZW1zID0gdHJhbnNmb3JtZWRUaWxlc1sxXS5pdGVtcztcbiAgICAgICAgdmFyIHkyaXRlbXMgPSB0cmFuc2Zvcm1lZFRpbGVzWzJdLml0ZW1zO1xuICAgICAgICB2YXIgeTNpdGVtcyA9IGZvdXJDb21wb25lbnRzID8gdHJhbnNmb3JtZWRUaWxlc1szXS5pdGVtcyA6IG51bGw7XG5cbiAgICAgICAgLy8gSEFDSzogVGhlIG11bHRpcGxlIGNvbXBvbmVudCB0cmFuc2Zvcm0gZm9ybXVsYXMgYmVsb3cgYXNzdW1lIHRoYXRcbiAgICAgICAgLy8gYWxsIGNvbXBvbmVudHMgaGF2ZSB0aGUgc2FtZSBwcmVjaXNpb24uIFdpdGggdGhpcyBpbiBtaW5kLCB3ZVxuICAgICAgICAvLyBjb21wdXRlIHNoaWZ0IGFuZCBvZmZzZXQgb25seSBvbmNlLlxuICAgICAgICBzaGlmdCA9IGNvbXBvbmVudHNbMF0ucHJlY2lzaW9uIC0gODtcbiAgICAgICAgb2Zmc2V0ID0gKDEyOCA8PCBzaGlmdCkgKyAwLjU7XG4gICAgICAgIG1heCA9IDI1NSAqICgxIDw8IHNoaWZ0KTtcbiAgICAgICAgbWF4SyA9IG1heCAqIDAuNTtcbiAgICAgICAgbWluID0gLW1heEs7XG5cbiAgICAgICAgdmFyIGNvbXBvbmVudDAgPSB0aWxlLmNvbXBvbmVudHNbMF07XG4gICAgICAgIHZhciBhbHBoYTAxID0gY29tcG9uZW50c0NvdW50IC0gMztcbiAgICAgICAgamogPSB5MGl0ZW1zLmxlbmd0aDtcbiAgICAgICAgaWYgKCFjb21wb25lbnQwLmNvZGluZ1N0eWxlUGFyYW1ldGVycy5yZXZlcnNpYmxlVHJhbnNmb3JtYXRpb24pIHtcbiAgICAgICAgICAvLyBpbnZlcnNlIGlycmV2ZXJzaWJsZSBtdWx0aXBsZSBjb21wb25lbnQgdHJhbnNmb3JtXG4gICAgICAgICAgZm9yIChqID0gMDsgaiA8IGpqOyBqKyssIHBvcyArPSBhbHBoYTAxKSB7XG4gICAgICAgICAgICB5MCA9IHkwaXRlbXNbal0gKyBvZmZzZXQ7XG4gICAgICAgICAgICB5MSA9IHkxaXRlbXNbal07XG4gICAgICAgICAgICB5MiA9IHkyaXRlbXNbal07XG4gICAgICAgICAgICByID0geTAgKyAxLjQwMiAqIHkyO1xuICAgICAgICAgICAgZyA9IHkwIC0gMC4zNDQxMyAqIHkxIC0gMC43MTQxNCAqIHkyO1xuICAgICAgICAgICAgYiA9IHkwICsgMS43NzIgKiB5MTtcbiAgICAgICAgICAgIG91dFtwb3MrK10gPSByIDw9IDAgPyAwIDogciA+PSBtYXggPyAyNTUgOiByID4+IHNoaWZ0O1xuICAgICAgICAgICAgb3V0W3BvcysrXSA9IGcgPD0gMCA/IDAgOiBnID49IG1heCA/IDI1NSA6IGcgPj4gc2hpZnQ7XG4gICAgICAgICAgICBvdXRbcG9zKytdID0gYiA8PSAwID8gMCA6IGIgPj0gbWF4ID8gMjU1IDogYiA+PiBzaGlmdDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gaW52ZXJzZSByZXZlcnNpYmxlIG11bHRpcGxlIGNvbXBvbmVudCB0cmFuc2Zvcm1cbiAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgamo7IGorKywgcG9zICs9IGFscGhhMDEpIHtcbiAgICAgICAgICAgIHkwID0geTBpdGVtc1tqXSArIG9mZnNldDtcbiAgICAgICAgICAgIHkxID0geTFpdGVtc1tqXTtcbiAgICAgICAgICAgIHkyID0geTJpdGVtc1tqXTtcbiAgICAgICAgICAgIGcgPSB5MCAtICgoeTIgKyB5MSkgPj4gMik7XG4gICAgICAgICAgICByID0gZyArIHkyO1xuICAgICAgICAgICAgYiA9IGcgKyB5MTtcbiAgICAgICAgICAgIG91dFtwb3MrK10gPSByIDw9IDAgPyAwIDogciA+PSBtYXggPyAyNTUgOiByID4+IHNoaWZ0O1xuICAgICAgICAgICAgb3V0W3BvcysrXSA9IGcgPD0gMCA/IDAgOiBnID49IG1heCA/IDI1NSA6IGcgPj4gc2hpZnQ7XG4gICAgICAgICAgICBvdXRbcG9zKytdID0gYiA8PSAwID8gMCA6IGIgPj0gbWF4ID8gMjU1IDogYiA+PiBzaGlmdDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZvdXJDb21wb25lbnRzKSB7XG4gICAgICAgICAgZm9yIChqID0gMCwgcG9zID0gMzsgaiA8IGpqOyBqKyssIHBvcyArPSA0KSB7XG4gICAgICAgICAgICBrID0geTNpdGVtc1tqXTtcbiAgICAgICAgICAgIG91dFtwb3NdID0gayA8PSBtaW4gPyAwIDogayA+PSBtYXhLID8gMjU1IDogKGsgKyBvZmZzZXQpID4+IHNoaWZ0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHsgLy8gbm8gbXVsdGktY29tcG9uZW50IHRyYW5zZm9ybVxuICAgICAgICBmb3IgKGMgPSAwOyBjIDwgY29tcG9uZW50c0NvdW50OyBjKyspIHtcbiAgICAgICAgICBpZiAoY29tcG9uZW50c1tjXS5wcmVjaXNpb24gPT09IDgpe1xuICAgICAgICAgICAgdmFyIGl0ZW1zID0gdHJhbnNmb3JtZWRUaWxlc1tjXS5pdGVtcztcbiAgICAgICAgICAgIHNoaWZ0ID0gY29tcG9uZW50c1tjXS5wcmVjaXNpb24gLSA4O1xuICAgICAgICAgICAgb2Zmc2V0ID0gKDEyOCA8PCBzaGlmdCkgKyAwLjU7XG4gICAgICAgICAgICBtYXggPSAoMTI3LjUgKiAoMSA8PCBzaGlmdCkpO1xuICAgICAgICAgICAgbWluID0gLW1heDtcbiAgICAgICAgICAgIGZvciAocG9zID0gYywgaiA9IDAsIGpqID0gaXRlbXMubGVuZ3RoOyBqIDwgamo7IGorKykge1xuICAgICAgICAgICAgICB2YWwgPSBpdGVtc1tqXTtcbiAgICAgICAgICAgICAgb3V0W3Bvc10gPSB2YWwgPD0gbWluID8gMCA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgdmFsID49IG1heCA/IDI1NSA6ICh2YWwgKyBvZmZzZXQpID4+IHNoaWZ0O1xuICAgICAgICAgICAgICBwb3MgKz0gY29tcG9uZW50c0NvdW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgdmFyIGlzU2lnbmVkID0gY29tcG9uZW50c1tjXS5pc1NpZ25lZDtcbiAgICAgICAgICAgIHZhciBpdGVtcyA9IHRyYW5zZm9ybWVkVGlsZXNbY10uaXRlbXM7XG5cbiAgICAgICAgICAgIGlmKGlzU2lnbmVkKXtcbiAgICAgICAgICAgICAgZm9yIChwb3MgPSBjLCBqID0gMCwgamogPSBpdGVtcy5sZW5ndGg7IGogPCBqajsgaisrKSB7XG4gICAgICAgICAgICAgICAgb3V0W3Bvc10gPSBpdGVtc1tqXTtcbiAgICAgICAgICAgICAgICBwb3MgKz0gY29tcG9uZW50c0NvdW50O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgICAgc2hpZnQgPSBjb21wb25lbnRzW2NdLnByZWNpc2lvbiAtIDg7XG4gICAgICAgICAgICAgIG9mZnNldCA9ICgxMjggPDwgc2hpZnQpICsgMC41O1xuICAgICAgICAgICAgICB2YXIgcHJlY2lzaW9uTWF4ID0gTWF0aC5wb3coMixjb21wb25lbnRzW2NdLnByZWNpc2lvbiktMTtcbiAgICAgICAgICAgICAgZm9yIChwb3MgPSBjLCBqID0gMCwgamogPSBpdGVtcy5sZW5ndGg7IGogPCBqajsgaisrKSB7XG4gICAgICAgICAgICAgICAgdmFsID0gaXRlbXNbal07XG4gICAgICAgICAgICAgICAgb3V0W3Bvc10gPSBNYXRoLm1heChNYXRoLm1pbigodmFsICsgb2Zmc2V0KSxwcmVjaXNpb25NYXgpLDApO1xuICAgICAgICAgICAgICAgIHBvcyArPSBjb21wb25lbnRzQ291bnQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJlc3VsdEltYWdlcy5wdXNoKHJlc3VsdCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRJbWFnZXM7XG4gIH1cbiAgZnVuY3Rpb24gaW5pdGlhbGl6ZVRpbGUoY29udGV4dCwgdGlsZUluZGV4KSB7XG4gICAgdmFyIHNpeiA9IGNvbnRleHQuU0laO1xuICAgIHZhciBjb21wb25lbnRzQ291bnQgPSBzaXouQ3NpejtcbiAgICB2YXIgdGlsZSA9IGNvbnRleHQudGlsZXNbdGlsZUluZGV4XTtcbiAgICBmb3IgKHZhciBjID0gMDsgYyA8IGNvbXBvbmVudHNDb3VudDsgYysrKSB7XG4gICAgICB2YXIgY29tcG9uZW50ID0gdGlsZS5jb21wb25lbnRzW2NdO1xuICAgICAgdmFyIHFjZE9yUWNjID0gKGNvbnRleHQuY3VycmVudFRpbGUuUUNDW2NdICE9PSB1bmRlZmluZWQgP1xuICAgICAgICBjb250ZXh0LmN1cnJlbnRUaWxlLlFDQ1tjXSA6IGNvbnRleHQuY3VycmVudFRpbGUuUUNEKTtcbiAgICAgIGNvbXBvbmVudC5xdWFudGl6YXRpb25QYXJhbWV0ZXJzID0gcWNkT3JRY2M7XG4gICAgICB2YXIgY29kT3JDb2MgPSAoY29udGV4dC5jdXJyZW50VGlsZS5DT0NbY10gIT09IHVuZGVmaW5lZCAgP1xuICAgICAgICBjb250ZXh0LmN1cnJlbnRUaWxlLkNPQ1tjXSA6IGNvbnRleHQuY3VycmVudFRpbGUuQ09EKTtcbiAgICAgIGNvbXBvbmVudC5jb2RpbmdTdHlsZVBhcmFtZXRlcnMgPSBjb2RPckNvYztcbiAgICB9XG4gICAgdGlsZS5jb2RpbmdTdHlsZURlZmF1bHRQYXJhbWV0ZXJzID0gY29udGV4dC5jdXJyZW50VGlsZS5DT0Q7XG4gIH1cblxuICAvLyBTZWN0aW9uIEIuMTAuMiBUYWcgdHJlZXNcbiAgdmFyIFRhZ1RyZWUgPSAoZnVuY3Rpb24gVGFnVHJlZUNsb3N1cmUoKSB7XG4gICAgZnVuY3Rpb24gVGFnVHJlZSh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICB2YXIgbGV2ZWxzTGVuZ3RoID0gbG9nMihNYXRoLm1heCh3aWR0aCwgaGVpZ2h0KSkgKyAxO1xuICAgICAgdGhpcy5sZXZlbHMgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGV2ZWxzTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGxldmVsID0ge1xuICAgICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICAgICAgICBpdGVtczogW11cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5sZXZlbHMucHVzaChsZXZlbCk7XG4gICAgICAgIHdpZHRoID0gTWF0aC5jZWlsKHdpZHRoIC8gMik7XG4gICAgICAgIGhlaWdodCA9IE1hdGguY2VpbChoZWlnaHQgLyAyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgVGFnVHJlZS5wcm90b3R5cGUgPSB7XG4gICAgICByZXNldDogZnVuY3Rpb24gVGFnVHJlZV9yZXNldChpLCBqKSB7XG4gICAgICAgIHZhciBjdXJyZW50TGV2ZWwgPSAwLCB2YWx1ZSA9IDAsIGxldmVsO1xuICAgICAgICB3aGlsZSAoY3VycmVudExldmVsIDwgdGhpcy5sZXZlbHMubGVuZ3RoKSB7XG4gICAgICAgICAgbGV2ZWwgPSB0aGlzLmxldmVsc1tjdXJyZW50TGV2ZWxdO1xuICAgICAgICAgIHZhciBpbmRleCA9IGkgKyBqICogbGV2ZWwud2lkdGg7XG4gICAgICAgICAgaWYgKGxldmVsLml0ZW1zW2luZGV4XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGxldmVsLml0ZW1zW2luZGV4XTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsZXZlbC5pbmRleCA9IGluZGV4O1xuICAgICAgICAgIGkgPj49IDE7XG4gICAgICAgICAgaiA+Pj0gMTtcbiAgICAgICAgICBjdXJyZW50TGV2ZWwrKztcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50TGV2ZWwtLTtcbiAgICAgICAgbGV2ZWwgPSB0aGlzLmxldmVsc1tjdXJyZW50TGV2ZWxdO1xuICAgICAgICBsZXZlbC5pdGVtc1tsZXZlbC5pbmRleF0gPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5jdXJyZW50TGV2ZWwgPSBjdXJyZW50TGV2ZWw7XG4gICAgICAgIGRlbGV0ZSB0aGlzLnZhbHVlO1xuICAgICAgfSxcbiAgICAgIGluY3JlbWVudFZhbHVlOiBmdW5jdGlvbiBUYWdUcmVlX2luY3JlbWVudFZhbHVlKCkge1xuICAgICAgICB2YXIgbGV2ZWwgPSB0aGlzLmxldmVsc1t0aGlzLmN1cnJlbnRMZXZlbF07XG4gICAgICAgIGxldmVsLml0ZW1zW2xldmVsLmluZGV4XSsrO1xuICAgICAgfSxcbiAgICAgIG5leHRMZXZlbDogZnVuY3Rpb24gVGFnVHJlZV9uZXh0TGV2ZWwoKSB7XG4gICAgICAgIHZhciBjdXJyZW50TGV2ZWwgPSB0aGlzLmN1cnJlbnRMZXZlbDtcbiAgICAgICAgdmFyIGxldmVsID0gdGhpcy5sZXZlbHNbY3VycmVudExldmVsXTtcbiAgICAgICAgdmFyIHZhbHVlID0gbGV2ZWwuaXRlbXNbbGV2ZWwuaW5kZXhdO1xuICAgICAgICBjdXJyZW50TGV2ZWwtLTtcbiAgICAgICAgaWYgKGN1cnJlbnRMZXZlbCA8IDApIHtcbiAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jdXJyZW50TGV2ZWwgPSBjdXJyZW50TGV2ZWw7XG4gICAgICAgIGxldmVsID0gdGhpcy5sZXZlbHNbY3VycmVudExldmVsXTtcbiAgICAgICAgbGV2ZWwuaXRlbXNbbGV2ZWwuaW5kZXhdID0gdmFsdWU7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFRhZ1RyZWU7XG4gIH0pKCk7XG5cbiAgdmFyIEluY2x1c2lvblRyZWUgPSAoZnVuY3Rpb24gSW5jbHVzaW9uVHJlZUNsb3N1cmUoKSB7XG4gICAgZnVuY3Rpb24gSW5jbHVzaW9uVHJlZSh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICB2YXIgbGV2ZWxzTGVuZ3RoID0gbG9nMihNYXRoLm1heCh3aWR0aCwgaGVpZ2h0KSkgKyAxO1xuICAgICAgdGhpcy5sZXZlbHMgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGV2ZWxzTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGl0ZW1zID0gbmV3IFVpbnQ4QXJyYXkod2lkdGggKiBoZWlnaHQpO1xuICAgICAgICB2YXIgc3RhdHVzID0gbmV3IFVpbnQ4QXJyYXkod2lkdGggKiBoZWlnaHQpO1xuICAgICAgICBmb3IgKHZhciBqID0gMCwgamogPSBpdGVtcy5sZW5ndGg7IGogPCBqajsgaisrKSB7XG4gICAgICAgICAgaXRlbXNbal0gPSAwO1xuICAgICAgICAgIHN0YXR1c1tqXSA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbGV2ZWwgPSB7XG4gICAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgICAgIGl0ZW1zOiBpdGVtcyxcbiAgICAgICAgICBzdGF0dXM6IHN0YXR1c1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmxldmVscy5wdXNoKGxldmVsKTtcblxuICAgICAgICB3aWR0aCA9IE1hdGguY2VpbCh3aWR0aCAvIDIpO1xuICAgICAgICBoZWlnaHQgPSBNYXRoLmNlaWwoaGVpZ2h0IC8gMik7XG4gICAgICB9XG4gICAgfVxuICAgIEluY2x1c2lvblRyZWUucHJvdG90eXBlID0ge1xuICAgICAgcmVzZXQ6IGZ1bmN0aW9uIEluY2x1c2lvblRyZWVfcmVzZXQoaSwgaiwgc3RvcFZhbHVlKSB7XG4gICAgICAgIHRoaXMuY3VycmVudFN0b3BWYWx1ZSA9IHN0b3BWYWx1ZTtcbiAgICAgICAgdmFyIGN1cnJlbnRMZXZlbCA9IDA7XG4gICAgICAgIHdoaWxlIChjdXJyZW50TGV2ZWwgPCB0aGlzLmxldmVscy5sZW5ndGgpIHtcbiAgICAgICAgICB2YXIgbGV2ZWwgPSB0aGlzLmxldmVsc1tjdXJyZW50TGV2ZWxdO1xuICAgICAgICAgIHZhciBpbmRleCA9IGkgKyBqICogbGV2ZWwud2lkdGg7XG4gICAgICAgICAgbGV2ZWwuaW5kZXggPSBpbmRleDtcblxuICAgICAgICAgIGkgPj49IDE7XG4gICAgICAgICAgaiA+Pj0gMTtcbiAgICAgICAgICBjdXJyZW50TGV2ZWwrKztcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY3VycmVudExldmVsID0gdGhpcy5sZXZlbHMubGVuZ3RoIC0gMTtcbiAgICAgICAgdGhpcy5taW5WYWx1ZSA9dGhpcy5sZXZlbHNbdGhpcy5jdXJyZW50TGV2ZWxdLml0ZW1zWzBdO1xuICAgICAgICByZXR1cm47XG4gICAgICB9LFxuICAgICAgaW5jcmVtZW50VmFsdWU6IGZ1bmN0aW9uIEluY2x1c2lvblRyZWVfaW5jcmVtZW50VmFsdWUoKSB7XG4gICAgICAgIHZhciBsZXZlbCA9IHRoaXMubGV2ZWxzW3RoaXMuY3VycmVudExldmVsXTtcbiAgICAgICAgbGV2ZWwuaXRlbXNbbGV2ZWwuaW5kZXhdID0gbGV2ZWwuaXRlbXNbbGV2ZWwuaW5kZXhdICsgMTtcbiAgICAgICAgaWYobGV2ZWwuaXRlbXNbbGV2ZWwuaW5kZXhdID4gdGhpcy5taW5WYWx1ZSkge1xuICAgICAgICAgIHRoaXMubWluVmFsdWUgPSBsZXZlbC5pdGVtc1tsZXZlbC5pbmRleF07XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBuZXh0TGV2ZWw6IGZ1bmN0aW9uIEluY2x1c2lvblRyZWVfbmV4dExldmVsKCkge1xuICAgICAgICB2YXIgY3VycmVudExldmVsID0gdGhpcy5jdXJyZW50TGV2ZWw7XG4gICAgICAgIGN1cnJlbnRMZXZlbC0tO1xuICAgICAgICBpZiAoY3VycmVudExldmVsIDwgMCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmN1cnJlbnRMZXZlbCA9IGN1cnJlbnRMZXZlbDtcbiAgICAgICAgICB2YXIgbGV2ZWwgPSB0aGlzLmxldmVsc1tjdXJyZW50TGV2ZWxdO1xuICAgICAgICAgIGlmKGxldmVsLml0ZW1zW2xldmVsLmluZGV4XSA8IHRoaXMubWluVmFsdWUpIHtcbiAgICAgICAgICAgIGxldmVsLml0ZW1zW2xldmVsLmluZGV4XSA9IHRoaXMubWluVmFsdWU7XG4gICAgICAgICAgfWVsc2UgaWYgKGxldmVsLml0ZW1zW2xldmVsLmluZGV4XSA+IHRoaXMubWluVmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMubWluVmFsdWUgPSBsZXZlbC5pdGVtc1tsZXZlbC5pbmRleF07XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgIGlzTGVhZjogZnVuY3Rpb24gSW5jbHVzaW9uVHJlZV9pc0xlYWYoKXtcbiAgICAgIHJldHVybiAodGhpcy5jdXJyZW50TGV2ZWwgPT09IDApO1xuICAgIH0sXG4gICAgaXNBYm92ZVRocmVzaG9sZDogZnVuY3Rpb24gSW5jbHVzaW9uVHJlZV9pc0Fib3ZlVGhyZXNob2xkKCl7XG4gICAgICB2YXIgbGV2ZWxpbmRleCA9IHRoaXMuY3VycmVudExldmVsO1xuICAgICAgdmFyIGxldmVsID0gdGhpcy5sZXZlbHNbbGV2ZWxpbmRleF07XG4gICAgICByZXR1cm4gKGxldmVsLml0ZW1zW2xldmVsLmluZGV4XSA+IHRoaXMuY3VycmVudFN0b3BWYWx1ZSk7XG4gICAgfSxcbiAgICBpc0tub3duOiBmdW5jdGlvbiBJbmNsdXNpb25UcmVlX2lzS25vd24oKXtcbiAgICAgIHZhciBsZXZlbGluZGV4ID0gdGhpcy5jdXJyZW50TGV2ZWw7XG4gICAgICB2YXIgbGV2ZWwgPSB0aGlzLmxldmVsc1tsZXZlbGluZGV4XTtcbiAgICAgIHJldHVybiAobGV2ZWwuc3RhdHVzW2xldmVsLmluZGV4XSA+IDApO1xuICAgIH0sXG4gICAgc2V0S25vd246IGZ1bmN0aW9uIEluY2x1c2lvblRyZWVfc2V0S25vd24oKXtcbiAgICAgIHZhciBsZXZlbGluZGV4ID0gdGhpcy5jdXJyZW50TGV2ZWw7XG4gICAgICB2YXIgbGV2ZWwgPSB0aGlzLmxldmVsc1tsZXZlbGluZGV4XTtcbiAgICAgIGxldmVsLnN0YXR1c1tsZXZlbC5pbmRleF0gPSAxO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIH07XG4gICAgcmV0dXJuIEluY2x1c2lvblRyZWU7XG4gIH0pKCk7XG5cbiAgLy8gU2VjdGlvbiBELiBDb2VmZmljaWVudCBiaXQgbW9kZWxpbmdcbiAgdmFyIEJpdE1vZGVsID0gKGZ1bmN0aW9uIEJpdE1vZGVsQ2xvc3VyZSgpIHtcbiAgICB2YXIgVU5JRk9STV9DT05URVhUID0gMTc7XG4gICAgdmFyIFJVTkxFTkdUSF9DT05URVhUID0gMTg7XG4gICAgLy8gVGFibGUgRC0xXG4gICAgLy8gVGhlIGluZGV4IGlzIGJpbmFyeSBwcmVzZW50YXRpb246IDBkZGR2dmhoLCBkZGQgLSBzdW0gb2YgRGkgKDAuLjQpLFxuICAgIC8vIHZ2IC0gc3VtIG9mIFZpICgwLi4yKSwgYW5kIGhoIC0gc3VtIG9mIEhpICgwLi4yKVxuICAgIHZhciBMTEFuZExIQ29udGV4dHNMYWJlbCA9IG5ldyBVaW50OEFycmF5KFtcbiAgICAgIDAsIDUsIDgsIDAsIDMsIDcsIDgsIDAsIDQsIDcsIDgsIDAsIDAsIDAsIDAsIDAsIDEsIDYsIDgsIDAsIDMsIDcsIDgsIDAsIDQsXG4gICAgICA3LCA4LCAwLCAwLCAwLCAwLCAwLCAyLCA2LCA4LCAwLCAzLCA3LCA4LCAwLCA0LCA3LCA4LCAwLCAwLCAwLCAwLCAwLCAyLCA2LFxuICAgICAgOCwgMCwgMywgNywgOCwgMCwgNCwgNywgOCwgMCwgMCwgMCwgMCwgMCwgMiwgNiwgOCwgMCwgMywgNywgOCwgMCwgNCwgNywgOFxuICAgIF0pO1xuICAgIHZhciBITENvbnRleHRMYWJlbCA9IG5ldyBVaW50OEFycmF5KFtcbiAgICAgIDAsIDMsIDQsIDAsIDUsIDcsIDcsIDAsIDgsIDgsIDgsIDAsIDAsIDAsIDAsIDAsIDEsIDMsIDQsIDAsIDYsIDcsIDcsIDAsIDgsXG4gICAgICA4LCA4LCAwLCAwLCAwLCAwLCAwLCAyLCAzLCA0LCAwLCA2LCA3LCA3LCAwLCA4LCA4LCA4LCAwLCAwLCAwLCAwLCAwLCAyLCAzLFxuICAgICAgNCwgMCwgNiwgNywgNywgMCwgOCwgOCwgOCwgMCwgMCwgMCwgMCwgMCwgMiwgMywgNCwgMCwgNiwgNywgNywgMCwgOCwgOCwgOFxuICAgIF0pO1xuICAgIHZhciBISENvbnRleHRMYWJlbCA9IG5ldyBVaW50OEFycmF5KFtcbiAgICAgIDAsIDEsIDIsIDAsIDEsIDIsIDIsIDAsIDIsIDIsIDIsIDAsIDAsIDAsIDAsIDAsIDMsIDQsIDUsIDAsIDQsIDUsIDUsIDAsIDUsXG4gICAgICA1LCA1LCAwLCAwLCAwLCAwLCAwLCA2LCA3LCA3LCAwLCA3LCA3LCA3LCAwLCA3LCA3LCA3LCAwLCAwLCAwLCAwLCAwLCA4LCA4LFxuICAgICAgOCwgMCwgOCwgOCwgOCwgMCwgOCwgOCwgOCwgMCwgMCwgMCwgMCwgMCwgOCwgOCwgOCwgMCwgOCwgOCwgOCwgMCwgOCwgOCwgOFxuICAgIF0pO1xuXG4gICAgZnVuY3Rpb24gQml0TW9kZWwod2lkdGgsIGhlaWdodCwgc3ViYmFuZCwgemVyb0JpdFBsYW5lcywgbWIpIHtcbiAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuXG4gICAgICB0aGlzLmNvbnRleHRMYWJlbFRhYmxlID0gKHN1YmJhbmQgPT09ICdISCcgPyBISENvbnRleHRMYWJlbCA6XG4gICAgICAgIChzdWJiYW5kID09PSAnSEwnID8gSExDb250ZXh0TGFiZWwgOiBMTEFuZExIQ29udGV4dHNMYWJlbCkpO1xuXG4gICAgICB2YXIgY29lZmZpY2llbnRDb3VudCA9IHdpZHRoICogaGVpZ2h0O1xuXG4gICAgICAvLyBjb2VmZmljaWVudHMgb3V0c2lkZSB0aGUgZW5jb2RpbmcgcmVnaW9uIHRyZWF0ZWQgYXMgaW5zaWduaWZpY2FudFxuICAgICAgLy8gYWRkIGJvcmRlciBzdGF0ZSBjZWxscyBmb3Igc2lnbmlmaWNhbmNlU3RhdGVcbiAgICAgIHRoaXMubmVpZ2hib3JzU2lnbmlmaWNhbmNlID0gbmV3IFVpbnQ4QXJyYXkoY29lZmZpY2llbnRDb3VudCk7XG4gICAgICB0aGlzLmNvZWZmaWNlbnRzU2lnbiA9IG5ldyBVaW50OEFycmF5KGNvZWZmaWNpZW50Q291bnQpO1xuICAgICAgdGhpcy5jb2VmZmljZW50c01hZ25pdHVkZSA9IG1iID4gMTQgPyBuZXcgVWludDMyQXJyYXkoY29lZmZpY2llbnRDb3VudCkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1iID4gNiA/IG5ldyBVaW50MTZBcnJheShjb2VmZmljaWVudENvdW50KSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3IFVpbnQ4QXJyYXkoY29lZmZpY2llbnRDb3VudCk7XG4gICAgICB0aGlzLnByb2Nlc3NpbmdGbGFncyA9IG5ldyBVaW50OEFycmF5KGNvZWZmaWNpZW50Q291bnQpO1xuXG4gICAgICB2YXIgYml0c0RlY29kZWQgPSBuZXcgVWludDhBcnJheShjb2VmZmljaWVudENvdW50KTtcbiAgICAgIGlmICh6ZXJvQml0UGxhbmVzICE9PSAwKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29lZmZpY2llbnRDb3VudDsgaSsrKSB7XG4gICAgICAgICAgYml0c0RlY29kZWRbaV0gPSB6ZXJvQml0UGxhbmVzO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLmJpdHNEZWNvZGVkID0gYml0c0RlY29kZWQ7XG5cbiAgICAgIHRoaXMucmVzZXQoKTtcbiAgICB9XG5cbiAgICBCaXRNb2RlbC5wcm90b3R5cGUgPSB7XG4gICAgICBzZXREZWNvZGVyOiBmdW5jdGlvbiBCaXRNb2RlbF9zZXREZWNvZGVyKGRlY29kZXIpIHtcbiAgICAgICAgdGhpcy5kZWNvZGVyID0gZGVjb2RlcjtcbiAgICAgIH0sXG4gICAgICByZXNldDogZnVuY3Rpb24gQml0TW9kZWxfcmVzZXQoKSB7XG4gICAgICAgIC8vIFdlIGhhdmUgMTcgY29udGV4dHMgdGhhdCBhcmUgYWNjZXNzZWQgdmlhIGNvbnRleHQgbGFiZWxzLFxuICAgICAgICAvLyBwbHVzIHRoZSB1bmlmb3JtIGFuZCBydW5sZW5ndGggY29udGV4dC5cbiAgICAgICAgdGhpcy5jb250ZXh0cyA9IG5ldyBJbnQ4QXJyYXkoMTkpO1xuXG4gICAgICAgIC8vIENvbnRleHRzIGFyZSBwYWNrZWQgaW50byAxIGJ5dGU6XG4gICAgICAgIC8vIGhpZ2hlc3QgNyBiaXRzIGNhcnJ5IHRoZSBpbmRleCwgbG93ZXN0IGJpdCBjYXJyaWVzIG1wc1xuICAgICAgICB0aGlzLmNvbnRleHRzWzBdID0gKDQgPDwgMSkgfCAwO1xuICAgICAgICB0aGlzLmNvbnRleHRzW1VOSUZPUk1fQ09OVEVYVF0gPSAoNDYgPDwgMSkgfCAwO1xuICAgICAgICB0aGlzLmNvbnRleHRzW1JVTkxFTkdUSF9DT05URVhUXSA9ICgzIDw8IDEpIHwgMDtcbiAgICAgIH0sXG4gICAgICBzZXROZWlnaGJvcnNTaWduaWZpY2FuY2U6XG4gICAgICAgIGZ1bmN0aW9uIEJpdE1vZGVsX3NldE5laWdoYm9yc1NpZ25pZmljYW5jZShyb3csIGNvbHVtbiwgaW5kZXgpIHtcbiAgICAgICAgdmFyIG5laWdoYm9yc1NpZ25pZmljYW5jZSA9IHRoaXMubmVpZ2hib3JzU2lnbmlmaWNhbmNlO1xuICAgICAgICB2YXIgd2lkdGggPSB0aGlzLndpZHRoLCBoZWlnaHQgPSB0aGlzLmhlaWdodDtcbiAgICAgICAgdmFyIGxlZnQgPSAoY29sdW1uID4gMCk7XG4gICAgICAgIHZhciByaWdodCA9IChjb2x1bW4gKyAxIDwgd2lkdGgpO1xuICAgICAgICB2YXIgaTtcblxuICAgICAgICBpZiAocm93ID4gMCkge1xuICAgICAgICAgIGkgPSBpbmRleCAtIHdpZHRoO1xuICAgICAgICAgIGlmIChsZWZ0KSB7XG4gICAgICAgICAgICBuZWlnaGJvcnNTaWduaWZpY2FuY2VbaSAtIDFdICs9IDB4MTA7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyaWdodCkge1xuICAgICAgICAgICAgbmVpZ2hib3JzU2lnbmlmaWNhbmNlW2kgKyAxXSArPSAweDEwO1xuICAgICAgICAgIH1cbiAgICAgICAgICBuZWlnaGJvcnNTaWduaWZpY2FuY2VbaV0gKz0gMHgwNDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyb3cgKyAxIDwgaGVpZ2h0KSB7XG4gICAgICAgICAgaSA9IGluZGV4ICsgd2lkdGg7XG4gICAgICAgICAgaWYgKGxlZnQpIHtcbiAgICAgICAgICAgIG5laWdoYm9yc1NpZ25pZmljYW5jZVtpIC0gMV0gKz0gMHgxMDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJpZ2h0KSB7XG4gICAgICAgICAgICBuZWlnaGJvcnNTaWduaWZpY2FuY2VbaSArIDFdICs9IDB4MTA7XG4gICAgICAgICAgfVxuICAgICAgICAgIG5laWdoYm9yc1NpZ25pZmljYW5jZVtpXSArPSAweDA0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxlZnQpIHtcbiAgICAgICAgICBuZWlnaGJvcnNTaWduaWZpY2FuY2VbaW5kZXggLSAxXSArPSAweDAxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyaWdodCkge1xuICAgICAgICAgIG5laWdoYm9yc1NpZ25pZmljYW5jZVtpbmRleCArIDFdICs9IDB4MDE7XG4gICAgICAgIH1cbiAgICAgICAgbmVpZ2hib3JzU2lnbmlmaWNhbmNlW2luZGV4XSB8PSAweDgwO1xuICAgICAgfSxcbiAgICAgIHJ1blNpZ25pZmljYW5jZVByb3BvZ2F0aW9uUGFzczpcbiAgICAgICAgZnVuY3Rpb24gQml0TW9kZWxfcnVuU2lnbmlmaWNhbmNlUHJvcG9nYXRpb25QYXNzKCkge1xuICAgICAgICB2YXIgZGVjb2RlciA9IHRoaXMuZGVjb2RlcjtcbiAgICAgICAgdmFyIHdpZHRoID0gdGhpcy53aWR0aCwgaGVpZ2h0ID0gdGhpcy5oZWlnaHQ7XG4gICAgICAgIHZhciBjb2VmZmljZW50c01hZ25pdHVkZSA9IHRoaXMuY29lZmZpY2VudHNNYWduaXR1ZGU7XG4gICAgICAgIHZhciBjb2VmZmljZW50c1NpZ24gPSB0aGlzLmNvZWZmaWNlbnRzU2lnbjtcbiAgICAgICAgdmFyIG5laWdoYm9yc1NpZ25pZmljYW5jZSA9IHRoaXMubmVpZ2hib3JzU2lnbmlmaWNhbmNlO1xuICAgICAgICB2YXIgcHJvY2Vzc2luZ0ZsYWdzID0gdGhpcy5wcm9jZXNzaW5nRmxhZ3M7XG4gICAgICAgIHZhciBjb250ZXh0cyA9IHRoaXMuY29udGV4dHM7XG4gICAgICAgIHZhciBsYWJlbHMgPSB0aGlzLmNvbnRleHRMYWJlbFRhYmxlO1xuICAgICAgICB2YXIgYml0c0RlY29kZWQgPSB0aGlzLmJpdHNEZWNvZGVkO1xuICAgICAgICB2YXIgcHJvY2Vzc2VkSW52ZXJzZU1hc2sgPSB+MTtcbiAgICAgICAgdmFyIHByb2Nlc3NlZE1hc2sgPSAxO1xuICAgICAgICB2YXIgZmlyc3RNYWduaXR1ZGVCaXRNYXNrID0gMjtcblxuICAgICAgICBmb3IgKHZhciBpMCA9IDA7IGkwIDwgaGVpZ2h0OyBpMCArPSA0KSB7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB3aWR0aDsgaisrKSB7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSBpMCAqIHdpZHRoICsgajtcbiAgICAgICAgICAgIGZvciAodmFyIGkxID0gMDsgaTEgPCA0OyBpMSsrLCBpbmRleCArPSB3aWR0aCkge1xuICAgICAgICAgICAgICB2YXIgaSA9IGkwICsgaTE7XG4gICAgICAgICAgICAgIGlmIChpID49IGhlaWdodCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vIGNsZWFyIHByb2Nlc3NlZCBmbGFnIGZpcnN0XG4gICAgICAgICAgICAgIHByb2Nlc3NpbmdGbGFnc1tpbmRleF0gJj0gcHJvY2Vzc2VkSW52ZXJzZU1hc2s7XG5cbiAgICAgICAgICAgICAgaWYgKGNvZWZmaWNlbnRzTWFnbml0dWRlW2luZGV4XSB8fFxuICAgICAgICAgICAgICAgICAgIW5laWdoYm9yc1NpZ25pZmljYW5jZVtpbmRleF0pIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHZhciBjb250ZXh0TGFiZWwgPSBsYWJlbHNbbmVpZ2hib3JzU2lnbmlmaWNhbmNlW2luZGV4XV07XG4gICAgICAgICAgICAgIHZhciBkZWNpc2lvbiA9IGRlY29kZXIucmVhZEJpdChjb250ZXh0cywgY29udGV4dExhYmVsKTtcbiAgICAgICAgICAgICAgaWYgKGRlY2lzaW9uKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNpZ24gPSB0aGlzLmRlY29kZVNpZ25CaXQoaSwgaiwgaW5kZXgpO1xuICAgICAgICAgICAgICAgIGNvZWZmaWNlbnRzU2lnbltpbmRleF0gPSBzaWduO1xuICAgICAgICAgICAgICAgIGNvZWZmaWNlbnRzTWFnbml0dWRlW2luZGV4XSA9IDE7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXROZWlnaGJvcnNTaWduaWZpY2FuY2UoaSwgaiwgaW5kZXgpO1xuICAgICAgICAgICAgICAgIHByb2Nlc3NpbmdGbGFnc1tpbmRleF0gfD0gZmlyc3RNYWduaXR1ZGVCaXRNYXNrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJpdHNEZWNvZGVkW2luZGV4XSsrO1xuICAgICAgICAgICAgICBwcm9jZXNzaW5nRmxhZ3NbaW5kZXhdIHw9IHByb2Nlc3NlZE1hc2s7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZGVjb2RlU2lnbkJpdDogZnVuY3Rpb24gQml0TW9kZWxfZGVjb2RlU2lnbkJpdChyb3csIGNvbHVtbiwgaW5kZXgpIHtcbiAgICAgICAgdmFyIHdpZHRoID0gdGhpcy53aWR0aCwgaGVpZ2h0ID0gdGhpcy5oZWlnaHQ7XG4gICAgICAgIHZhciBjb2VmZmljZW50c01hZ25pdHVkZSA9IHRoaXMuY29lZmZpY2VudHNNYWduaXR1ZGU7XG4gICAgICAgIHZhciBjb2VmZmljZW50c1NpZ24gPSB0aGlzLmNvZWZmaWNlbnRzU2lnbjtcbiAgICAgICAgdmFyIGNvbnRyaWJ1dGlvbiwgc2lnbjAsIHNpZ24xLCBzaWduaWZpY2FuY2UxO1xuICAgICAgICB2YXIgY29udGV4dExhYmVsLCBkZWNvZGVkO1xuXG4gICAgICAgIC8vIGNhbGN1bGF0ZSBob3Jpem9udGFsIGNvbnRyaWJ1dGlvblxuICAgICAgICBzaWduaWZpY2FuY2UxID0gKGNvbHVtbiA+IDAgJiYgY29lZmZpY2VudHNNYWduaXR1ZGVbaW5kZXggLSAxXSAhPT0gMCk7XG4gICAgICAgIGlmIChjb2x1bW4gKyAxIDwgd2lkdGggJiYgY29lZmZpY2VudHNNYWduaXR1ZGVbaW5kZXggKyAxXSAhPT0gMCkge1xuICAgICAgICAgIHNpZ24xID0gY29lZmZpY2VudHNTaWduW2luZGV4ICsgMV07XG4gICAgICAgICAgaWYgKHNpZ25pZmljYW5jZTEpIHtcbiAgICAgICAgICAgIHNpZ24wID0gY29lZmZpY2VudHNTaWduW2luZGV4IC0gMV07XG4gICAgICAgICAgICBjb250cmlidXRpb24gPSAxIC0gc2lnbjEgLSBzaWduMDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29udHJpYnV0aW9uID0gMSAtIHNpZ24xIC0gc2lnbjE7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHNpZ25pZmljYW5jZTEpIHtcbiAgICAgICAgICBzaWduMCA9IGNvZWZmaWNlbnRzU2lnbltpbmRleCAtIDFdO1xuICAgICAgICAgIGNvbnRyaWJ1dGlvbiA9IDEgLSBzaWduMCAtIHNpZ24wO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnRyaWJ1dGlvbiA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGhvcml6b250YWxDb250cmlidXRpb24gPSAzICogY29udHJpYnV0aW9uO1xuXG4gICAgICAgIC8vIGNhbGN1bGF0ZSB2ZXJ0aWNhbCBjb250cmlidXRpb24gYW5kIGNvbWJpbmUgd2l0aCB0aGUgaG9yaXpvbnRhbFxuICAgICAgICBzaWduaWZpY2FuY2UxID0gKHJvdyA+IDAgJiYgY29lZmZpY2VudHNNYWduaXR1ZGVbaW5kZXggLSB3aWR0aF0gIT09IDApO1xuICAgICAgICBpZiAocm93ICsgMSA8IGhlaWdodCAmJiBjb2VmZmljZW50c01hZ25pdHVkZVtpbmRleCArIHdpZHRoXSAhPT0gMCkge1xuICAgICAgICAgIHNpZ24xID0gY29lZmZpY2VudHNTaWduW2luZGV4ICsgd2lkdGhdO1xuICAgICAgICAgIGlmIChzaWduaWZpY2FuY2UxKSB7XG4gICAgICAgICAgICBzaWduMCA9IGNvZWZmaWNlbnRzU2lnbltpbmRleCAtIHdpZHRoXTtcbiAgICAgICAgICAgIGNvbnRyaWJ1dGlvbiA9IDEgLSBzaWduMSAtIHNpZ24wICsgaG9yaXpvbnRhbENvbnRyaWJ1dGlvbjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29udHJpYnV0aW9uID0gMSAtIHNpZ24xIC0gc2lnbjEgKyBob3Jpem9udGFsQ29udHJpYnV0aW9uO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChzaWduaWZpY2FuY2UxKSB7XG4gICAgICAgICAgc2lnbjAgPSBjb2VmZmljZW50c1NpZ25baW5kZXggLSB3aWR0aF07XG4gICAgICAgICAgY29udHJpYnV0aW9uID0gMSAtIHNpZ24wIC0gc2lnbjAgKyBob3Jpem9udGFsQ29udHJpYnV0aW9uO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnRyaWJ1dGlvbiA9IGhvcml6b250YWxDb250cmlidXRpb247XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29udHJpYnV0aW9uID49IDApIHtcbiAgICAgICAgICBjb250ZXh0TGFiZWwgPSA5ICsgY29udHJpYnV0aW9uO1xuICAgICAgICAgIGRlY29kZWQgPSB0aGlzLmRlY29kZXIucmVhZEJpdCh0aGlzLmNvbnRleHRzLCBjb250ZXh0TGFiZWwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnRleHRMYWJlbCA9IDkgLSBjb250cmlidXRpb247XG4gICAgICAgICAgZGVjb2RlZCA9IHRoaXMuZGVjb2Rlci5yZWFkQml0KHRoaXMuY29udGV4dHMsIGNvbnRleHRMYWJlbCkgXiAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZWNvZGVkO1xuICAgICAgfSxcbiAgICAgIHJ1bk1hZ25pdHVkZVJlZmluZW1lbnRQYXNzOlxuICAgICAgICBmdW5jdGlvbiBCaXRNb2RlbF9ydW5NYWduaXR1ZGVSZWZpbmVtZW50UGFzcygpIHtcbiAgICAgICAgdmFyIGRlY29kZXIgPSB0aGlzLmRlY29kZXI7XG4gICAgICAgIHZhciB3aWR0aCA9IHRoaXMud2lkdGgsIGhlaWdodCA9IHRoaXMuaGVpZ2h0O1xuICAgICAgICB2YXIgY29lZmZpY2VudHNNYWduaXR1ZGUgPSB0aGlzLmNvZWZmaWNlbnRzTWFnbml0dWRlO1xuICAgICAgICB2YXIgbmVpZ2hib3JzU2lnbmlmaWNhbmNlID0gdGhpcy5uZWlnaGJvcnNTaWduaWZpY2FuY2U7XG4gICAgICAgIHZhciBjb250ZXh0cyA9IHRoaXMuY29udGV4dHM7XG4gICAgICAgIHZhciBiaXRzRGVjb2RlZCA9IHRoaXMuYml0c0RlY29kZWQ7XG4gICAgICAgIHZhciBwcm9jZXNzaW5nRmxhZ3MgPSB0aGlzLnByb2Nlc3NpbmdGbGFncztcbiAgICAgICAgdmFyIHByb2Nlc3NlZE1hc2sgPSAxO1xuICAgICAgICB2YXIgZmlyc3RNYWduaXR1ZGVCaXRNYXNrID0gMjtcbiAgICAgICAgdmFyIGxlbmd0aCA9IHdpZHRoICogaGVpZ2h0O1xuICAgICAgICB2YXIgd2lkdGg0ID0gd2lkdGggKiA0O1xuXG4gICAgICAgIGZvciAodmFyIGluZGV4MCA9IDAsIGluZGV4TmV4dDsgaW5kZXgwIDwgbGVuZ3RoOyBpbmRleDAgPSBpbmRleE5leHQpIHtcbiAgICAgICAgICBpbmRleE5leHQgPSBNYXRoLm1pbihsZW5ndGgsIGluZGV4MCArIHdpZHRoNCk7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB3aWR0aDsgaisrKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpbmRleCA9IGluZGV4MCArIGo7IGluZGV4IDwgaW5kZXhOZXh0OyBpbmRleCArPSB3aWR0aCkge1xuXG4gICAgICAgICAgICAgIC8vIHNpZ25pZmljYW50IGJ1dCBub3QgdGhvc2UgdGhhdCBoYXZlIGp1c3QgYmVjb21lXG4gICAgICAgICAgICAgIGlmICghY29lZmZpY2VudHNNYWduaXR1ZGVbaW5kZXhdIHx8XG4gICAgICAgICAgICAgICAgKHByb2Nlc3NpbmdGbGFnc1tpbmRleF0gJiBwcm9jZXNzZWRNYXNrKSAhPT0gMCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdmFyIGNvbnRleHRMYWJlbCA9IDE2O1xuICAgICAgICAgICAgICBpZiAoKHByb2Nlc3NpbmdGbGFnc1tpbmRleF0gJiBmaXJzdE1hZ25pdHVkZUJpdE1hc2spICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgcHJvY2Vzc2luZ0ZsYWdzW2luZGV4XSBePSBmaXJzdE1hZ25pdHVkZUJpdE1hc2s7XG4gICAgICAgICAgICAgICAgLy8gZmlyc3QgcmVmaW5lbWVudFxuICAgICAgICAgICAgICAgdmFyIHNpZ25pZmljYW5jZSA9IG5laWdoYm9yc1NpZ25pZmljYW5jZVtpbmRleF0gJiAxMjc7XG4gICAgICAgICAgICAgICBjb250ZXh0TGFiZWwgPSBzaWduaWZpY2FuY2UgPT09IDAgPyAxNSA6IDE0O1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdmFyIGJpdCA9IGRlY29kZXIucmVhZEJpdChjb250ZXh0cywgY29udGV4dExhYmVsKTtcbiAgICAgICAgICAgICAgY29lZmZpY2VudHNNYWduaXR1ZGVbaW5kZXhdID1cbiAgICAgICAgICAgICAgICAoY29lZmZpY2VudHNNYWduaXR1ZGVbaW5kZXhdIDw8IDEpIHwgYml0O1xuICAgICAgICAgICAgICBiaXRzRGVjb2RlZFtpbmRleF0rKztcbiAgICAgICAgICAgICAgcHJvY2Vzc2luZ0ZsYWdzW2luZGV4XSB8PSBwcm9jZXNzZWRNYXNrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHJ1bkNsZWFudXBQYXNzOiBmdW5jdGlvbiBCaXRNb2RlbF9ydW5DbGVhbnVwUGFzcygpIHtcbiAgICAgICAgdmFyIGRlY29kZXIgPSB0aGlzLmRlY29kZXI7XG4gICAgICAgIHZhciB3aWR0aCA9IHRoaXMud2lkdGgsIGhlaWdodCA9IHRoaXMuaGVpZ2h0O1xuICAgICAgICB2YXIgbmVpZ2hib3JzU2lnbmlmaWNhbmNlID0gdGhpcy5uZWlnaGJvcnNTaWduaWZpY2FuY2U7XG4gICAgICAgIHZhciBjb2VmZmljZW50c01hZ25pdHVkZSA9IHRoaXMuY29lZmZpY2VudHNNYWduaXR1ZGU7XG4gICAgICAgIHZhciBjb2VmZmljZW50c1NpZ24gPSB0aGlzLmNvZWZmaWNlbnRzU2lnbjtcbiAgICAgICAgdmFyIGNvbnRleHRzID0gdGhpcy5jb250ZXh0cztcbiAgICAgICAgdmFyIGxhYmVscyA9IHRoaXMuY29udGV4dExhYmVsVGFibGU7XG4gICAgICAgIHZhciBiaXRzRGVjb2RlZCA9IHRoaXMuYml0c0RlY29kZWQ7XG4gICAgICAgIHZhciBwcm9jZXNzaW5nRmxhZ3MgPSB0aGlzLnByb2Nlc3NpbmdGbGFncztcbiAgICAgICAgdmFyIHByb2Nlc3NlZE1hc2sgPSAxO1xuICAgICAgICB2YXIgZmlyc3RNYWduaXR1ZGVCaXRNYXNrID0gMjtcbiAgICAgICAgdmFyIG9uZVJvd0Rvd24gPSB3aWR0aDtcbiAgICAgICAgdmFyIHR3b1Jvd3NEb3duID0gd2lkdGggKiAyO1xuICAgICAgICB2YXIgdGhyZWVSb3dzRG93biA9IHdpZHRoICogMztcbiAgICAgICAgdmFyIGlOZXh0O1xuICAgICAgICBmb3IgKHZhciBpMCA9IDA7IGkwIDwgaGVpZ2h0OyBpMCA9IGlOZXh0KSB7XG4gICAgICAgICAgaU5leHQgPSBNYXRoLm1pbihpMCArIDQsIGhlaWdodCk7XG4gICAgICAgICAgdmFyIGluZGV4QmFzZSA9IGkwICogd2lkdGg7XG4gICAgICAgICAgdmFyIGNoZWNrQWxsRW1wdHkgPSBpMCArIDMgPCBoZWlnaHQ7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB3aWR0aDsgaisrKSB7XG4gICAgICAgICAgICB2YXIgaW5kZXgwID0gaW5kZXhCYXNlICsgajtcbiAgICAgICAgICAgIC8vIHVzaW5nIHRoZSBwcm9wZXJ0eTogbGFiZWxzW25laWdoYm9yc1NpZ25pZmljYW5jZVtpbmRleF1dID09PSAwXG4gICAgICAgICAgICAvLyB3aGVuIG5laWdoYm9yc1NpZ25pZmljYW5jZVtpbmRleF0gPT09IDBcbiAgICAgICAgICAgIHZhciBhbGxFbXB0eSA9IChjaGVja0FsbEVtcHR5ICYmXG4gICAgICAgICAgICAgIHByb2Nlc3NpbmdGbGFnc1tpbmRleDBdID09PSAwICYmXG4gICAgICAgICAgICAgIHByb2Nlc3NpbmdGbGFnc1tpbmRleDAgKyBvbmVSb3dEb3duXSA9PT0gMCAmJlxuICAgICAgICAgICAgICBwcm9jZXNzaW5nRmxhZ3NbaW5kZXgwICsgdHdvUm93c0Rvd25dID09PSAwICYmXG4gICAgICAgICAgICAgIHByb2Nlc3NpbmdGbGFnc1tpbmRleDAgKyB0aHJlZVJvd3NEb3duXSA9PT0gMCAmJlxuICAgICAgICAgICAgICBuZWlnaGJvcnNTaWduaWZpY2FuY2VbaW5kZXgwXSA9PT0gMCAmJlxuICAgICAgICAgICAgICBuZWlnaGJvcnNTaWduaWZpY2FuY2VbaW5kZXgwICsgb25lUm93RG93bl0gPT09IDAgJiZcbiAgICAgICAgICAgICAgbmVpZ2hib3JzU2lnbmlmaWNhbmNlW2luZGV4MCArIHR3b1Jvd3NEb3duXSA9PT0gMCAmJlxuICAgICAgICAgICAgICBuZWlnaGJvcnNTaWduaWZpY2FuY2VbaW5kZXgwICsgdGhyZWVSb3dzRG93bl0gPT09IDApO1xuICAgICAgICAgICAgdmFyIGkxID0gMCwgaW5kZXggPSBpbmRleDA7XG4gICAgICAgICAgICB2YXIgaSA9IGkwLCBzaWduO1xuICAgICAgICAgICAgaWYgKGFsbEVtcHR5KSB7XG4gICAgICAgICAgICAgIHZhciBoYXNTaWduaWZpY2FudENvZWZmaWNlbnQgPVxuICAgICAgICAgICAgICAgIGRlY29kZXIucmVhZEJpdChjb250ZXh0cywgUlVOTEVOR1RIX0NPTlRFWFQpO1xuICAgICAgICAgICAgICBpZiAoIWhhc1NpZ25pZmljYW50Q29lZmZpY2VudCkge1xuICAgICAgICAgICAgICAgIGJpdHNEZWNvZGVkW2luZGV4MF0rKztcbiAgICAgICAgICAgICAgICBiaXRzRGVjb2RlZFtpbmRleDAgKyBvbmVSb3dEb3duXSsrO1xuICAgICAgICAgICAgICAgIGJpdHNEZWNvZGVkW2luZGV4MCArIHR3b1Jvd3NEb3duXSsrO1xuICAgICAgICAgICAgICAgIGJpdHNEZWNvZGVkW2luZGV4MCArIHRocmVlUm93c0Rvd25dKys7XG4gICAgICAgICAgICAgICAgY29udGludWU7IC8vIG5leHQgY29sdW1uXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaTEgPSAoZGVjb2Rlci5yZWFkQml0KGNvbnRleHRzLCBVTklGT1JNX0NPTlRFWFQpIDw8IDEpIHxcbiAgICAgICAgICAgICAgICAgICAgZGVjb2Rlci5yZWFkQml0KGNvbnRleHRzLCBVTklGT1JNX0NPTlRFWFQpO1xuICAgICAgICAgICAgICBpZiAoaTEgIT09IDApIHtcbiAgICAgICAgICAgICAgICBpID0gaTAgKyBpMTtcbiAgICAgICAgICAgICAgICBpbmRleCArPSBpMSAqIHdpZHRoO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgc2lnbiA9IHRoaXMuZGVjb2RlU2lnbkJpdChpLCBqLCBpbmRleCk7XG4gICAgICAgICAgICAgIGNvZWZmaWNlbnRzU2lnbltpbmRleF0gPSBzaWduO1xuICAgICAgICAgICAgICBjb2VmZmljZW50c01hZ25pdHVkZVtpbmRleF0gPSAxO1xuICAgICAgICAgICAgICB0aGlzLnNldE5laWdoYm9yc1NpZ25pZmljYW5jZShpLCBqLCBpbmRleCk7XG4gICAgICAgICAgICAgIHByb2Nlc3NpbmdGbGFnc1tpbmRleF0gfD0gZmlyc3RNYWduaXR1ZGVCaXRNYXNrO1xuXG4gICAgICAgICAgICAgIGluZGV4ID0gaW5kZXgwO1xuICAgICAgICAgICAgICBmb3IgKHZhciBpMiA9IGkwOyBpMiA8PSBpOyBpMisrLCBpbmRleCArPSB3aWR0aCkge1xuICAgICAgICAgICAgICAgIGJpdHNEZWNvZGVkW2luZGV4XSsrO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaTErKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoaSA9IGkwICsgaTE7IGkgPCBpTmV4dDsgaSsrLCBpbmRleCArPSB3aWR0aCkge1xuICAgICAgICAgICAgICBpZiAoY29lZmZpY2VudHNNYWduaXR1ZGVbaW5kZXhdIHx8XG4gICAgICAgICAgICAgICAgKHByb2Nlc3NpbmdGbGFnc1tpbmRleF0gJiBwcm9jZXNzZWRNYXNrKSAhPT0gMCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdmFyIGNvbnRleHRMYWJlbCA9IGxhYmVsc1tuZWlnaGJvcnNTaWduaWZpY2FuY2VbaW5kZXhdXTtcbiAgICAgICAgICAgICAgdmFyIGRlY2lzaW9uID0gZGVjb2Rlci5yZWFkQml0KGNvbnRleHRzLCBjb250ZXh0TGFiZWwpO1xuICAgICAgICAgICAgICBpZiAoZGVjaXNpb24gPT09IDEpIHtcbiAgICAgICAgICAgICAgICBzaWduID0gdGhpcy5kZWNvZGVTaWduQml0KGksIGosIGluZGV4KTtcbiAgICAgICAgICAgICAgICBjb2VmZmljZW50c1NpZ25baW5kZXhdID0gc2lnbjtcbiAgICAgICAgICAgICAgICBjb2VmZmljZW50c01hZ25pdHVkZVtpbmRleF0gPSAxO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0TmVpZ2hib3JzU2lnbmlmaWNhbmNlKGksIGosIGluZGV4KTtcbiAgICAgICAgICAgICAgICBwcm9jZXNzaW5nRmxhZ3NbaW5kZXhdIHw9IGZpcnN0TWFnbml0dWRlQml0TWFzaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBiaXRzRGVjb2RlZFtpbmRleF0rKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBjaGVja1NlZ21lbnRhdGlvblN5bWJvbDogZnVuY3Rpb24gQml0TW9kZWxfY2hlY2tTZWdtZW50YXRpb25TeW1ib2woKSB7XG4gICAgICAgIHZhciBkZWNvZGVyID0gdGhpcy5kZWNvZGVyO1xuICAgICAgICB2YXIgY29udGV4dHMgPSB0aGlzLmNvbnRleHRzO1xuICAgICAgICB2YXIgc3ltYm9sID0gKGRlY29kZXIucmVhZEJpdChjb250ZXh0cywgVU5JRk9STV9DT05URVhUKSA8PCAzKSB8XG4gICAgICAgICAgICAgICAgICAgICAoZGVjb2Rlci5yZWFkQml0KGNvbnRleHRzLCBVTklGT1JNX0NPTlRFWFQpIDw8IDIpIHxcbiAgICAgICAgICAgICAgICAgICAgIChkZWNvZGVyLnJlYWRCaXQoY29udGV4dHMsIFVOSUZPUk1fQ09OVEVYVCkgPDwgMSkgfFxuICAgICAgICAgICAgICAgICAgICAgIGRlY29kZXIucmVhZEJpdChjb250ZXh0cywgVU5JRk9STV9DT05URVhUKTtcbiAgICAgICAgaWYgKHN5bWJvbCAhPT0gMHhBKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdKUFggRXJyb3I6IEludmFsaWQgc2VnbWVudGF0aW9uIHN5bWJvbCcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBCaXRNb2RlbDtcbiAgfSkoKTtcblxuICAvLyBTZWN0aW9uIEYsIERpc2NyZXRlIHdhdmVsZXQgdHJhbnNmb3JtYXRpb25cbiAgdmFyIFRyYW5zZm9ybSA9IChmdW5jdGlvbiBUcmFuc2Zvcm1DbG9zdXJlKCkge1xuICAgIGZ1bmN0aW9uIFRyYW5zZm9ybSgpIHt9XG5cbiAgICBUcmFuc2Zvcm0ucHJvdG90eXBlLmNhbGN1bGF0ZSA9XG4gICAgICBmdW5jdGlvbiB0cmFuc2Zvcm1DYWxjdWxhdGUoc3ViYmFuZHMsIHUwLCB2MCkge1xuICAgICAgdmFyIGxsID0gc3ViYmFuZHNbMF07XG4gICAgICBmb3IgKHZhciBpID0gMSwgaWkgPSBzdWJiYW5kcy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgIGxsID0gdGhpcy5pdGVyYXRlKGxsLCBzdWJiYW5kc1tpXSwgdTAsIHYwKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBsbDtcbiAgICB9O1xuICAgIFRyYW5zZm9ybS5wcm90b3R5cGUuZXh0ZW5kID0gZnVuY3Rpb24gZXh0ZW5kKGJ1ZmZlciwgb2Zmc2V0LCBzaXplKSB7XG4gICAgICAvLyBTZWN0aW9uIEYuMy43IGV4dGVuZGluZy4uLiB1c2luZyBtYXggZXh0ZW5zaW9uIG9mIDRcbiAgICAgIHZhciBpMSA9IG9mZnNldCAtIDEsIGoxID0gb2Zmc2V0ICsgMTtcbiAgICAgIHZhciBpMiA9IG9mZnNldCArIHNpemUgLSAyLCBqMiA9IG9mZnNldCArIHNpemU7XG4gICAgICBidWZmZXJbaTEtLV0gPSBidWZmZXJbajErK107XG4gICAgICBidWZmZXJbajIrK10gPSBidWZmZXJbaTItLV07XG4gICAgICBidWZmZXJbaTEtLV0gPSBidWZmZXJbajErK107XG4gICAgICBidWZmZXJbajIrK10gPSBidWZmZXJbaTItLV07XG4gICAgICBidWZmZXJbaTEtLV0gPSBidWZmZXJbajErK107XG4gICAgICBidWZmZXJbajIrK10gPSBidWZmZXJbaTItLV07XG4gICAgICBidWZmZXJbaTFdID0gYnVmZmVyW2oxXTtcbiAgICAgIGJ1ZmZlcltqMl0gPSBidWZmZXJbaTJdO1xuICAgIH07XG4gICAgVHJhbnNmb3JtLnByb3RvdHlwZS5pdGVyYXRlID0gZnVuY3Rpb24gVHJhbnNmb3JtX2l0ZXJhdGUobGwsIGhsX2xoX2hoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHUwLCB2MCkge1xuICAgICAgdmFyIGxsV2lkdGggPSBsbC53aWR0aCwgbGxIZWlnaHQgPSBsbC5oZWlnaHQsIGxsSXRlbXMgPSBsbC5pdGVtcztcbiAgICAgIHZhciB3aWR0aCA9IGhsX2xoX2hoLndpZHRoO1xuICAgICAgdmFyIGhlaWdodCA9IGhsX2xoX2hoLmhlaWdodDtcbiAgICAgIHZhciBpdGVtcyA9IGhsX2xoX2hoLml0ZW1zO1xuICAgICAgdmFyIGksIGosIGssIGwsIHUsIHY7XG5cbiAgICAgIC8vIEludGVybGVhdmUgTEwgYWNjb3JkaW5nIHRvIFNlY3Rpb24gRi4zLjNcbiAgICAgIGZvciAoayA9IDAsIGkgPSAwOyBpIDwgbGxIZWlnaHQ7IGkrKykge1xuICAgICAgICBsID0gaSAqIDIgKiB3aWR0aDtcbiAgICAgICAgZm9yIChqID0gMDsgaiA8IGxsV2lkdGg7IGorKywgaysrLCBsICs9IDIpIHtcbiAgICAgICAgICBpdGVtc1tsXSA9IGxsSXRlbXNba107XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIFRoZSBMTCBiYW5kIGlzIG5vdCBuZWVkZWQgYW55bW9yZS5cbiAgICAgIGxsSXRlbXMgPSBsbC5pdGVtcyA9IG51bGw7XG5cbiAgICAgIHZhciBidWZmZXJQYWRkaW5nID0gNDtcbiAgICAgIHZhciByb3dCdWZmZXIgPSBuZXcgRmxvYXQzMkFycmF5KHdpZHRoICsgMiAqIGJ1ZmZlclBhZGRpbmcpO1xuXG4gICAgICAvLyBTZWN0aW9uIEYuMy40IEhPUl9TUlxuICAgICAgaWYgKHdpZHRoID09PSAxKSB7XG4gICAgICAgIC8vIGlmIHdpZHRoID0gMSwgd2hlbiB1MCBldmVuIGtlZXAgaXRlbXMgYXMgaXMsIHdoZW4gb2RkIGRpdmlkZSBieSAyXG4gICAgICAgIGlmICgodTAgJiAxKSAhPT0gMCkge1xuICAgICAgICAgIGZvciAodiA9IDAsIGsgPSAwOyB2IDwgaGVpZ2h0OyB2KyssIGsgKz0gd2lkdGgpIHtcbiAgICAgICAgICAgIGl0ZW1zW2tdICo9IDAuNTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAodiA9IDAsIGsgPSAwOyB2IDwgaGVpZ2h0OyB2KyssIGsgKz0gd2lkdGgpIHtcbiAgICAgICAgICByb3dCdWZmZXIuc2V0KGl0ZW1zLnN1YmFycmF5KGssIGsgKyB3aWR0aCksIGJ1ZmZlclBhZGRpbmcpO1xuXG4gICAgICAgICAgdGhpcy5leHRlbmQocm93QnVmZmVyLCBidWZmZXJQYWRkaW5nLCB3aWR0aCk7XG4gICAgICAgICAgdGhpcy5maWx0ZXIocm93QnVmZmVyLCBidWZmZXJQYWRkaW5nLCB3aWR0aCk7XG5cbiAgICAgICAgICBpdGVtcy5zZXQoXG4gICAgICAgICAgICByb3dCdWZmZXIuc3ViYXJyYXkoYnVmZmVyUGFkZGluZywgYnVmZmVyUGFkZGluZyArIHdpZHRoKSxcbiAgICAgICAgICAgIGspO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIEFjY2Vzc2VzIHRvIHRoZSBpdGVtcyBhcnJheSBjYW4gdGFrZSBsb25nLCBiZWNhdXNlIGl0IG1heSBub3QgZml0IGludG9cbiAgICAgIC8vIENQVSBjYWNoZSBhbmQgaGFzIHRvIGJlIGZldGNoZWQgZnJvbSBtYWluIG1lbW9yeS4gU2luY2Ugc3Vic2VxdWVudFxuICAgICAgLy8gYWNjZXNzZXMgdG8gdGhlIGl0ZW1zIGFycmF5IGFyZSBub3QgbG9jYWwgd2hlbiByZWFkaW5nIGNvbHVtbnMsIHdlXG4gICAgICAvLyBoYXZlIGEgY2FjaGUgbWlzcyBldmVyeSB0aW1lLiBUbyByZWR1Y2UgY2FjaGUgbWlzc2VzLCBnZXQgdXAgdG9cbiAgICAgIC8vICdudW1CdWZmZXJzJyBpdGVtcyBhdCBhIHRpbWUgYW5kIHN0b3JlIHRoZW0gaW50byB0aGUgaW5kaXZpZHVhbFxuICAgICAgLy8gYnVmZmVycy4gVGhlIGNvbEJ1ZmZlcnMgc2hvdWxkIGJlIHNtYWxsIGVub3VnaCB0byBmaXQgaW50byBDUFUgY2FjaGUuXG4gICAgICB2YXIgbnVtQnVmZmVycyA9IDE2O1xuICAgICAgdmFyIGNvbEJ1ZmZlcnMgPSBbXTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBudW1CdWZmZXJzOyBpKyspIHtcbiAgICAgICAgY29sQnVmZmVycy5wdXNoKG5ldyBGbG9hdDMyQXJyYXkoaGVpZ2h0ICsgMiAqIGJ1ZmZlclBhZGRpbmcpKTtcbiAgICAgIH1cbiAgICAgIHZhciBiLCBjdXJyZW50QnVmZmVyID0gMDtcbiAgICAgIGxsID0gYnVmZmVyUGFkZGluZyArIGhlaWdodDtcblxuICAgICAgLy8gU2VjdGlvbiBGLjMuNSBWRVJfU1JcbiAgICAgIGlmIChoZWlnaHQgPT09IDEpIHtcbiAgICAgICAgICAvLyBpZiBoZWlnaHQgPSAxLCB3aGVuIHYwIGV2ZW4ga2VlcCBpdGVtcyBhcyBpcywgd2hlbiBvZGQgZGl2aWRlIGJ5IDJcbiAgICAgICAgaWYgKCh2MCAmIDEpICE9PSAwKSB7XG4gICAgICAgICAgZm9yICh1ID0gMDsgdSA8IHdpZHRoOyB1KyspIHtcbiAgICAgICAgICAgIGl0ZW1zW3VdICo9IDAuNTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAodSA9IDA7IHUgPCB3aWR0aDsgdSsrKSB7XG4gICAgICAgICAgLy8gaWYgd2UgcmFuIG91dCBvZiBidWZmZXJzLCBjb3B5IHNldmVyYWwgaW1hZ2UgY29sdW1ucyBhdCBvbmNlXG4gICAgICAgICAgaWYgKGN1cnJlbnRCdWZmZXIgPT09IDApIHtcbiAgICAgICAgICAgIG51bUJ1ZmZlcnMgPSBNYXRoLm1pbih3aWR0aCAtIHUsIG51bUJ1ZmZlcnMpO1xuICAgICAgICAgICAgZm9yIChrID0gdSwgbCA9IGJ1ZmZlclBhZGRpbmc7IGwgPCBsbDsgayArPSB3aWR0aCwgbCsrKSB7XG4gICAgICAgICAgICAgIGZvciAoYiA9IDA7IGIgPCBudW1CdWZmZXJzOyBiKyspIHtcbiAgICAgICAgICAgICAgICBjb2xCdWZmZXJzW2JdW2xdID0gaXRlbXNbayArIGJdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyZW50QnVmZmVyID0gbnVtQnVmZmVycztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjdXJyZW50QnVmZmVyLS07XG4gICAgICAgICAgdmFyIGJ1ZmZlciA9IGNvbEJ1ZmZlcnNbY3VycmVudEJ1ZmZlcl07XG4gICAgICAgICAgdGhpcy5leHRlbmQoYnVmZmVyLCBidWZmZXJQYWRkaW5nLCBoZWlnaHQpO1xuICAgICAgICAgIHRoaXMuZmlsdGVyKGJ1ZmZlciwgYnVmZmVyUGFkZGluZywgaGVpZ2h0KTtcblxuICAgICAgICAgIC8vIElmIHRoaXMgaXMgbGFzdCBidWZmZXIgaW4gdGhpcyBncm91cCBvZiBidWZmZXJzLCBmbHVzaCBhbGwgYnVmZmVycy5cbiAgICAgICAgICBpZiAoY3VycmVudEJ1ZmZlciA9PT0gMCkge1xuICAgICAgICAgICAgayA9IHUgLSBudW1CdWZmZXJzICsgMTtcbiAgICAgICAgICAgIGZvciAobCA9IGJ1ZmZlclBhZGRpbmc7IGwgPCBsbDsgayArPSB3aWR0aCwgbCsrKSB7XG4gICAgICAgICAgICAgIGZvciAoYiA9IDA7IGIgPCBudW1CdWZmZXJzOyBiKyspIHtcbiAgICAgICAgICAgICAgICBpdGVtc1trICsgYl0gPSBjb2xCdWZmZXJzW2JdW2xdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgICAgIGl0ZW1zOiBpdGVtc1xuICAgICAgfTtcbiAgICB9O1xuICAgIHJldHVybiBUcmFuc2Zvcm07XG4gIH0pKCk7XG5cbiAgLy8gU2VjdGlvbiAzLjguMiBJcnJldmVyc2libGUgOS03IGZpbHRlclxuICB2YXIgSXJyZXZlcnNpYmxlVHJhbnNmb3JtID0gKGZ1bmN0aW9uIElycmV2ZXJzaWJsZVRyYW5zZm9ybUNsb3N1cmUoKSB7XG4gICAgZnVuY3Rpb24gSXJyZXZlcnNpYmxlVHJhbnNmb3JtKCkge1xuICAgICAgVHJhbnNmb3JtLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgSXJyZXZlcnNpYmxlVHJhbnNmb3JtLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoVHJhbnNmb3JtLnByb3RvdHlwZSk7XG4gICAgSXJyZXZlcnNpYmxlVHJhbnNmb3JtLnByb3RvdHlwZS5maWx0ZXIgPVxuICAgICAgZnVuY3Rpb24gaXJyZXZlcnNpYmxlVHJhbnNmb3JtRmlsdGVyKHgsIG9mZnNldCwgbGVuZ3RoKSB7XG4gICAgICB2YXIgbGVuID0gbGVuZ3RoID4+IDE7XG4gICAgICBvZmZzZXQgPSBvZmZzZXQgfCAwO1xuICAgICAgdmFyIGosIG4sIGN1cnJlbnQsIG5leHQ7XG5cbiAgICAgIHZhciBhbHBoYSA9IC0xLjU4NjEzNDM0MjA1OTkyNDtcbiAgICAgIHZhciBiZXRhID0gLTAuMDUyOTgwMTE4NTcyOTYxO1xuICAgICAgdmFyIGdhbW1hID0gMC44ODI5MTEwNzU1MzA5MzQ7XG4gICAgICB2YXIgZGVsdGEgPSAwLjQ0MzUwNjg1MjA0Mzk3MTtcbiAgICAgIHZhciBLID0gMS4yMzAxNzQxMDQ5MTQwMDE7XG4gICAgICB2YXIgS18gPSAxIC8gSztcblxuICAgICAgLy8gc3RlcCAxIGlzIGNvbWJpbmVkIHdpdGggc3RlcCAzXG5cbiAgICAgIC8vIHN0ZXAgMlxuICAgICAgaiA9IG9mZnNldCAtIDM7XG4gICAgICBmb3IgKG4gPSBsZW4gKyA0OyBuLS07IGogKz0gMikge1xuICAgICAgICB4W2pdICo9IEtfO1xuICAgICAgfVxuXG4gICAgICAvLyBzdGVwIDEgJiAzXG4gICAgICBqID0gb2Zmc2V0IC0gMjtcbiAgICAgIGN1cnJlbnQgPSBkZWx0YSAqIHhbaiAtMV07XG4gICAgICBmb3IgKG4gPSBsZW4gKyAzOyBuLS07IGogKz0gMikge1xuICAgICAgICBuZXh0ID0gZGVsdGEgKiB4W2ogKyAxXTtcbiAgICAgICAgeFtqXSA9IEsgKiB4W2pdIC0gY3VycmVudCAtIG5leHQ7XG4gICAgICAgIGlmIChuLS0pIHtcbiAgICAgICAgICBqICs9IDI7XG4gICAgICAgICAgY3VycmVudCA9IGRlbHRhICogeFtqICsgMV07XG4gICAgICAgICAgeFtqXSA9IEsgKiB4W2pdIC0gY3VycmVudCAtIG5leHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gc3RlcCA0XG4gICAgICBqID0gb2Zmc2V0IC0gMTtcbiAgICAgIGN1cnJlbnQgPSBnYW1tYSAqIHhbaiAtIDFdO1xuICAgICAgZm9yIChuID0gbGVuICsgMjsgbi0tOyBqICs9IDIpIHtcbiAgICAgICAgbmV4dCA9IGdhbW1hICogeFtqICsgMV07XG4gICAgICAgIHhbal0gLT0gY3VycmVudCArIG5leHQ7XG4gICAgICAgIGlmIChuLS0pIHtcbiAgICAgICAgICBqICs9IDI7XG4gICAgICAgICAgY3VycmVudCA9IGdhbW1hICogeFtqICsgMV07XG4gICAgICAgICAgeFtqXSAtPSBjdXJyZW50ICsgbmV4dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBzdGVwIDVcbiAgICAgIGogPSBvZmZzZXQ7XG4gICAgICBjdXJyZW50ID0gYmV0YSAqIHhbaiAtIDFdO1xuICAgICAgZm9yIChuID0gbGVuICsgMTsgbi0tOyBqICs9IDIpIHtcbiAgICAgICAgbmV4dCA9IGJldGEgKiB4W2ogKyAxXTtcbiAgICAgICAgeFtqXSAtPSBjdXJyZW50ICsgbmV4dDtcbiAgICAgICAgaWYgKG4tLSkge1xuICAgICAgICAgIGogKz0gMjtcbiAgICAgICAgICBjdXJyZW50ID0gYmV0YSAqIHhbaiArIDFdO1xuICAgICAgICAgIHhbal0gLT0gY3VycmVudCArIG5leHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gc3RlcCA2XG4gICAgICBpZiAobGVuICE9PSAwKSB7XG4gICAgICAgIGogPSBvZmZzZXQgKyAxO1xuICAgICAgICBjdXJyZW50ID0gYWxwaGEgKiB4W2ogLSAxXTtcbiAgICAgICAgZm9yIChuID0gbGVuOyBuLS07IGogKz0gMikge1xuICAgICAgICAgIG5leHQgPSBhbHBoYSAqIHhbaiArIDFdO1xuICAgICAgICAgIHhbal0gLT0gY3VycmVudCArIG5leHQ7XG4gICAgICAgICAgaWYgKG4tLSkge1xuICAgICAgICAgICAgaiArPSAyO1xuICAgICAgICAgICAgY3VycmVudCA9IGFscGhhICogeFtqICsgMV07XG4gICAgICAgICAgICB4W2pdIC09IGN1cnJlbnQgKyBuZXh0O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIElycmV2ZXJzaWJsZVRyYW5zZm9ybTtcbiAgfSkoKTtcblxuICAvLyBTZWN0aW9uIDMuOC4xIFJldmVyc2libGUgNS0zIGZpbHRlclxuICB2YXIgUmV2ZXJzaWJsZVRyYW5zZm9ybSA9IChmdW5jdGlvbiBSZXZlcnNpYmxlVHJhbnNmb3JtQ2xvc3VyZSgpIHtcbiAgICBmdW5jdGlvbiBSZXZlcnNpYmxlVHJhbnNmb3JtKCkge1xuICAgICAgVHJhbnNmb3JtLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgUmV2ZXJzaWJsZVRyYW5zZm9ybS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFRyYW5zZm9ybS5wcm90b3R5cGUpO1xuICAgIFJldmVyc2libGVUcmFuc2Zvcm0ucHJvdG90eXBlLmZpbHRlciA9XG4gICAgICBmdW5jdGlvbiByZXZlcnNpYmxlVHJhbnNmb3JtRmlsdGVyKHgsIG9mZnNldCwgbGVuZ3RoKSB7XG4gICAgICB2YXIgbGVuID0gbGVuZ3RoID4+IDE7XG4gICAgICBvZmZzZXQgPSBvZmZzZXQgfCAwO1xuICAgICAgdmFyIGosIG47XG5cbiAgICAgIGZvciAoaiA9IG9mZnNldCwgbiA9IGxlbiArIDE7IG4tLTsgaiArPSAyKSB7XG4gICAgICAgIHhbal0gLT0gKHhbaiAtIDFdICsgeFtqICsgMV0gKyAyKSA+PiAyO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGogPSBvZmZzZXQgKyAxLCBuID0gbGVuOyBuLS07IGogKz0gMikge1xuICAgICAgICB4W2pdICs9ICh4W2ogLSAxXSArIHhbaiArIDFdKSA+PiAxO1xuICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gUmV2ZXJzaWJsZVRyYW5zZm9ybTtcbiAgfSkoKTtcblxuICByZXR1cm4gSnB4SW1hZ2U7XG59KSgpO1xuXG5cbi8qIC0qLSBNb2RlOiBKYXZhOyB0YWItd2lkdGg6IDI7IGluZGVudC10YWJzLW1vZGU6IG5pbDsgYy1iYXNpYy1vZmZzZXQ6IDIgLSotICovXG4vKiB2aW06IHNldCBzaGlmdHdpZHRoPTIgdGFic3RvcD0yIGF1dG9pbmRlbnQgY2luZGVudCBleHBhbmR0YWI6ICovXG4vKiBDb3B5cmlnaHQgMjAxMiBNb3ppbGxhIEZvdW5kYXRpb25cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKiBUaGlzIGNsYXNzIGltcGxlbWVudHMgdGhlIFFNIENvZGVyIGRlY29kaW5nIGFzIGRlZmluZWQgaW5cbiAqICAgSlBFRyAyMDAwIFBhcnQgSSBGaW5hbCBDb21taXR0ZWUgRHJhZnQgVmVyc2lvbiAxLjBcbiAqICAgQW5uZXggQy4zIEFyaXRobWV0aWMgZGVjb2RpbmcgcHJvY2VkdXJlIFxuICogYXZhaWxhYmxlIGF0IGh0dHA6Ly93d3cuanBlZy5vcmcvcHVibGljL2ZjZDE1NDQ0LTEucGRmXG4gKiBcbiAqIFRoZSBhcml0aG1ldGljIGRlY29kZXIgaXMgdXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoIGNvbnRleHQgbW9kZWxzIHRvIGRlY29kZVxuICogSlBFRzIwMDAgYW5kIEpCSUcyIHN0cmVhbXMuXG4gKi9cbnZhciBBcml0aG1ldGljRGVjb2RlciA9IChmdW5jdGlvbiBBcml0aG1ldGljRGVjb2RlckNsb3N1cmUoKSB7XG4gIC8vIFRhYmxlIEMtMlxuICB2YXIgUWVUYWJsZSA9IFtcbiAgICB7cWU6IDB4NTYwMSwgbm1wczogMSwgbmxwczogMSwgc3dpdGNoRmxhZzogMX0sXG4gICAge3FlOiAweDM0MDEsIG5tcHM6IDIsIG5scHM6IDYsIHN3aXRjaEZsYWc6IDB9LFxuICAgIHtxZTogMHgxODAxLCBubXBzOiAzLCBubHBzOiA5LCBzd2l0Y2hGbGFnOiAwfSxcbiAgICB7cWU6IDB4MEFDMSwgbm1wczogNCwgbmxwczogMTIsIHN3aXRjaEZsYWc6IDB9LFxuICAgIHtxZTogMHgwNTIxLCBubXBzOiA1LCBubHBzOiAyOSwgc3dpdGNoRmxhZzogMH0sXG4gICAge3FlOiAweDAyMjEsIG5tcHM6IDM4LCBubHBzOiAzMywgc3dpdGNoRmxhZzogMH0sXG4gICAge3FlOiAweDU2MDEsIG5tcHM6IDcsIG5scHM6IDYsIHN3aXRjaEZsYWc6IDF9LFxuICAgIHtxZTogMHg1NDAxLCBubXBzOiA4LCBubHBzOiAxNCwgc3dpdGNoRmxhZzogMH0sXG4gICAge3FlOiAweDQ4MDEsIG5tcHM6IDksIG5scHM6IDE0LCBzd2l0Y2hGbGFnOiAwfSxcbiAgICB7cWU6IDB4MzgwMSwgbm1wczogMTAsIG5scHM6IDE0LCBzd2l0Y2hGbGFnOiAwfSxcbiAgICB7cWU6IDB4MzAwMSwgbm1wczogMTEsIG5scHM6IDE3LCBzd2l0Y2hGbGFnOiAwfSxcbiAgICB7cWU6IDB4MjQwMSwgbm1wczogMTIsIG5scHM6IDE4LCBzd2l0Y2hGbGFnOiAwfSxcbiAgICB7cWU6IDB4MUMwMSwgbm1wczogMTMsIG5scHM6IDIwLCBzd2l0Y2hGbGFnOiAwfSxcbiAgICB7cWU6IDB4MTYwMSwgbm1wczogMjksIG5scHM6IDIxLCBzd2l0Y2hGbGFnOiAwfSxcbiAgICB7cWU6IDB4NTYwMSwgbm1wczogMTUsIG5scHM6IDE0LCBzd2l0Y2hGbGFnOiAxfSxcbiAgICB7cWU6IDB4NTQwMSwgbm1wczogMTYsIG5scHM6IDE0LCBzd2l0Y2hGbGFnOiAwfSxcbiAgICB7cWU6IDB4NTEwMSwgbm1wczogMTcsIG5scHM6IDE1LCBzd2l0Y2hGbGFnOiAwfSxcbiAgICB7cWU6IDB4NDgwMSwgbm1wczogMTgsIG5scHM6IDE2LCBzd2l0Y2hGbGFnOiAwfSxcbiAgICB7cWU6IDB4MzgwMSwgbm1wczogMTksIG5scHM6IDE3LCBzd2l0Y2hGbGFnOiAwfSxcbiAgICB7cWU6IDB4MzQwMSwgbm1wczogMjAsIG5scHM6IDE4LCBzd2l0Y2hGbGFnOiAwfSxcbiAgICB7cWU6IDB4MzAwMSwgbm1wczogMjEsIG5scHM6IDE5LCBzd2l0Y2hGbGFnOiAwfSxcbiAgICB7cWU6IDB4MjgwMSwgbm1wczogMjIsIG5scHM6IDE5LCBzd2l0Y2hGbGFnOiAwfSxcbiAgICB7cWU6IDB4MjQwMSwgbm1wczogMjMsIG5scHM6IDIwLCBzd2l0Y2hGbGFnOiAwfSxcbiAgICB7cWU6IDB4MjIwMSwgbm1wczogMjQsIG5scHM6IDIxLCBzd2l0Y2hGbGFnOiAwfSxcbiAgICB7cWU6IDB4MUMwMSwgbm1wczogMjUsIG5scHM6IDIyLCBzd2l0Y2hGbGFnOiAwfSxcbiAgICB7cWU6IDB4MTgwMSwgbm1wczogMjYsIG5scHM6IDIzLCBzd2l0Y2hGbGFnOiAwfSxcbiAgICB7cWU6IDB4MTYwMSwgbm1wczogMjcsIG5scHM6IDI0LCBzd2l0Y2hGbGFnOiAwfSxcbiAgICB7cWU6IDB4MTQwMSwgbm1wczogMjgsIG5scHM6IDI1LCBzd2l0Y2hGbGFnOiAwfSxcbiAgICB7cWU6IDB4MTIwMSwgbm1wczogMjksIG5scHM6IDI2LCBzd2l0Y2hGbGFnOiAwfSxcbiAgICB7cWU6IDB4MTEwMSwgbm1wczogMzAsIG5scHM6IDI3LCBzd2l0Y2hGbGFnOiAwfSxcbiAgICB7cWU6IDB4MEFDMSwgbm1wczogMzEsIG5scHM6IDI4LCBzd2l0Y2hGbGFnOiAwfSxcbiAgICB7cWU6IDB4MDlDMSwgbm1wczogMzIsIG5scHM6IDI5LCBzd2l0Y2hGbGFnOiAwfSxcbiAgICB7cWU6IDB4MDhBMSwgbm1wczogMzMsIG5scHM6IDMwLCBzd2l0Y2hGbGFnOiAwfSxcbiAgICB7cWU6IDB4MDUyMSwgbm1wczogMzQsIG5scHM6IDMxLCBzd2l0Y2hGbGFnOiAwfSxcbiAgICB7cWU6IDB4MDQ0MSwgbm1wczogMzUsIG5scHM6IDMyLCBzd2l0Y2hGbGFnOiAwfSxcbiAgICB7cWU6IDB4MDJBMSwgbm1wczogMzYsIG5scHM6IDMzLCBzd2l0Y2hGbGFnOiAwfSxcbiAgICB7cWU6IDB4MDIyMSwgbm1wczogMzcsIG5scHM6IDM0LCBzd2l0Y2hGbGFnOiAwfSxcbiAgICB7cWU6IDB4MDE0MSwgbm1wczogMzgsIG5scHM6IDM1LCBzd2l0Y2hGbGFnOiAwfSxcbiAgICB7cWU6IDB4MDExMSwgbm1wczogMzksIG5scHM6IDM2LCBzd2l0Y2hGbGFnOiAwfSxcbiAgICB7cWU6IDB4MDA4NSwgbm1wczogNDAsIG5scHM6IDM3LCBzd2l0Y2hGbGFnOiAwfSxcbiAgICB7cWU6IDB4MDA0OSwgbm1wczogNDEsIG5scHM6IDM4LCBzd2l0Y2hGbGFnOiAwfSxcbiAgICB7cWU6IDB4MDAyNSwgbm1wczogNDIsIG5scHM6IDM5LCBzd2l0Y2hGbGFnOiAwfSxcbiAgICB7cWU6IDB4MDAxNSwgbm1wczogNDMsIG5scHM6IDQwLCBzd2l0Y2hGbGFnOiAwfSxcbiAgICB7cWU6IDB4MDAwOSwgbm1wczogNDQsIG5scHM6IDQxLCBzd2l0Y2hGbGFnOiAwfSxcbiAgICB7cWU6IDB4MDAwNSwgbm1wczogNDUsIG5scHM6IDQyLCBzd2l0Y2hGbGFnOiAwfSxcbiAgICB7cWU6IDB4MDAwMSwgbm1wczogNDUsIG5scHM6IDQzLCBzd2l0Y2hGbGFnOiAwfSxcbiAgICB7cWU6IDB4NTYwMSwgbm1wczogNDYsIG5scHM6IDQ2LCBzd2l0Y2hGbGFnOiAwfVxuICBdO1xuXG4gIC8vIEMuMy41IEluaXRpYWxpc2F0aW9uIG9mIHRoZSBkZWNvZGVyIChJTklUREVDKVxuICBmdW5jdGlvbiBBcml0aG1ldGljRGVjb2RlcihkYXRhLCBzdGFydCwgZW5kKSB7XG4gICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICB0aGlzLmJwID0gc3RhcnQ7XG4gICAgdGhpcy5kYXRhRW5kID0gZW5kO1xuXG4gICAgdGhpcy5jaGlnaCA9IGRhdGFbc3RhcnRdO1xuICAgIHRoaXMuY2xvdyA9IDA7XG5cbiAgICB0aGlzLmJ5dGVJbigpO1xuXG4gICAgdGhpcy5jaGlnaCA9ICgodGhpcy5jaGlnaCA8PCA3KSAmIDB4RkZGRikgfCAoKHRoaXMuY2xvdyA+PiA5KSAmIDB4N0YpO1xuICAgIHRoaXMuY2xvdyA9ICh0aGlzLmNsb3cgPDwgNykgJiAweEZGRkY7XG4gICAgdGhpcy5jdCAtPSA3O1xuICAgIHRoaXMuYSA9IDB4ODAwMDtcbiAgfVxuXG4gIEFyaXRobWV0aWNEZWNvZGVyLnByb3RvdHlwZSA9IHtcbiAgICAvLyBDLjMuNCBDb21wcmVzc2VkIGRhdGEgaW5wdXQgKEJZVEVJTilcbiAgICBieXRlSW46IGZ1bmN0aW9uIEFyaXRobWV0aWNEZWNvZGVyX2J5dGVJbigpIHtcbiAgICAgIHZhciBkYXRhID0gdGhpcy5kYXRhO1xuICAgICAgdmFyIGJwID0gdGhpcy5icDtcbiAgICAgIGlmIChkYXRhW2JwXSA9PT0gMHhGRikge1xuICAgICAgICB2YXIgYjEgPSBkYXRhW2JwICsgMV07XG4gICAgICAgIGlmIChiMSA+IDB4OEYpIHtcbiAgICAgICAgICB0aGlzLmNsb3cgKz0gMHhGRjAwO1xuICAgICAgICAgIHRoaXMuY3QgPSA4O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJwKys7XG4gICAgICAgICAgdGhpcy5jbG93ICs9IChkYXRhW2JwXSA8PCA5KTtcbiAgICAgICAgICB0aGlzLmN0ID0gNztcbiAgICAgICAgICB0aGlzLmJwID0gYnA7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJwKys7XG4gICAgICAgIHRoaXMuY2xvdyArPSBicCA8IHRoaXMuZGF0YUVuZCA/IChkYXRhW2JwXSA8PCA4KSA6IDB4RkYwMDtcbiAgICAgICAgdGhpcy5jdCA9IDg7XG4gICAgICAgIHRoaXMuYnAgPSBicDtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmNsb3cgPiAweEZGRkYpIHtcbiAgICAgICAgdGhpcy5jaGlnaCArPSAodGhpcy5jbG93ID4+IDE2KTtcbiAgICAgICAgdGhpcy5jbG93ICY9IDB4RkZGRjtcbiAgICAgIH1cbiAgICB9LFxuICAgIC8vIEMuMy4yIERlY29kaW5nIGEgZGVjaXNpb24gKERFQ09ERSlcbiAgICByZWFkQml0OiBmdW5jdGlvbiBBcml0aG1ldGljRGVjb2Rlcl9yZWFkQml0KGNvbnRleHRzLCBwb3MpIHtcbiAgICAgIC8vIGNvbnRleHRzIGFyZSBwYWNrZWQgaW50byAxIGJ5dGU6XG4gICAgICAvLyBoaWdoZXN0IDcgYml0cyBjYXJyeSBjeC5pbmRleCwgbG93ZXN0IGJpdCBjYXJyaWVzIGN4Lm1wc1xuICAgICAgdmFyIGN4X2luZGV4ID0gY29udGV4dHNbcG9zXSA+PiAxLCBjeF9tcHMgPSBjb250ZXh0c1twb3NdICYgMTtcbiAgICAgIHZhciBxZVRhYmxlSWN4ID0gUWVUYWJsZVtjeF9pbmRleF07XG4gICAgICB2YXIgcWVJY3ggPSBxZVRhYmxlSWN4LnFlO1xuICAgICAgdmFyIGQ7XG4gICAgICB2YXIgYSA9IHRoaXMuYSAtIHFlSWN4O1xuXG4gICAgICBpZiAodGhpcy5jaGlnaCA8IHFlSWN4KSB7XG4gICAgICAgIC8vIGV4Y2hhbmdlTHBzXG4gICAgICAgIGlmIChhIDwgcWVJY3gpIHtcbiAgICAgICAgICBhID0gcWVJY3g7XG4gICAgICAgICAgZCA9IGN4X21wcztcbiAgICAgICAgICBjeF9pbmRleCA9IHFlVGFibGVJY3gubm1wcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhID0gcWVJY3g7XG4gICAgICAgICAgZCA9IDEgXiBjeF9tcHM7XG4gICAgICAgICAgaWYgKHFlVGFibGVJY3guc3dpdGNoRmxhZyA9PT0gMSkge1xuICAgICAgICAgICAgY3hfbXBzID0gZDtcbiAgICAgICAgICB9XG4gICAgICAgICAgY3hfaW5kZXggPSBxZVRhYmxlSWN4Lm5scHM7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY2hpZ2ggLT0gcWVJY3g7XG4gICAgICAgIGlmICgoYSAmIDB4ODAwMCkgIT09IDApIHtcbiAgICAgICAgICB0aGlzLmEgPSBhO1xuICAgICAgICAgIHJldHVybiBjeF9tcHM7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZXhjaGFuZ2VNcHNcbiAgICAgICAgaWYgKGEgPCBxZUljeCkge1xuICAgICAgICAgIGQgPSAxIF4gY3hfbXBzO1xuICAgICAgICAgIGlmIChxZVRhYmxlSWN4LnN3aXRjaEZsYWcgPT09IDEpIHtcbiAgICAgICAgICAgIGN4X21wcyA9IGQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGN4X2luZGV4ID0gcWVUYWJsZUljeC5ubHBzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGQgPSBjeF9tcHM7XG4gICAgICAgICAgY3hfaW5kZXggPSBxZVRhYmxlSWN4Lm5tcHM7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIEMuMy4zIHJlbm9ybUQ7XG4gICAgICBkbyB7XG4gICAgICAgIGlmICh0aGlzLmN0ID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5ieXRlSW4oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGEgPDw9IDE7XG4gICAgICAgIHRoaXMuY2hpZ2ggPSAoKHRoaXMuY2hpZ2ggPDwgMSkgJiAweEZGRkYpIHwgKCh0aGlzLmNsb3cgPj4gMTUpICYgMSk7XG4gICAgICAgIHRoaXMuY2xvdyA9ICh0aGlzLmNsb3cgPDwgMSkgJiAweEZGRkY7XG4gICAgICAgIHRoaXMuY3QtLTtcbiAgICAgIH0gd2hpbGUgKChhICYgMHg4MDAwKSA9PT0gMCk7XG4gICAgICB0aGlzLmEgPSBhO1xuXG4gICAgICBjb250ZXh0c1twb3NdID0gY3hfaW5kZXggPDwgMSB8IGN4X21wcztcbiAgICAgIHJldHVybiBkO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gQXJpdGhtZXRpY0RlY29kZXI7XG59KSgpO1xuXG4vKiAtKi0gTW9kZTogSmF2YTsgdGFiLXdpZHRoOiAyOyBpbmRlbnQtdGFicy1tb2RlOiBuaWw7IGMtYmFzaWMtb2Zmc2V0OiAyIC0qLSAqL1xuLyogdmltOiBzZXQgc2hpZnR3aWR0aD0yIHRhYnN0b3A9MiBhdXRvaW5kZW50IGNpbmRlbnQgZXhwYW5kdGFiOiAqL1xuLyogQ29weXJpZ2h0IDIwMTIgTW96aWxsYSBGb3VuZGF0aW9uXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKiBnbG9iYWxzIENtZCwgQ29sb3JTcGFjZSwgRGljdCwgTW96QmxvYkJ1aWxkZXIsIE5hbWUsIFBERkpTLCBSZWYsIFVSTCxcbiAgICAgICAgICAgUHJvbWlzZSAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBnbG9iYWxTY29wZSA9ICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgPyB0aGlzIDogd2luZG93O1xuXG52YXIgaXNXb3JrZXIgPSAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpO1xuXG52YXIgRk9OVF9JREVOVElUWV9NQVRSSVggPSBbMC4wMDEsIDAsIDAsIDAuMDAxLCAwLCAwXTtcblxudmFyIFRleHRSZW5kZXJpbmdNb2RlID0ge1xuICBGSUxMOiAwLFxuICBTVFJPS0U6IDEsXG4gIEZJTExfU1RST0tFOiAyLFxuICBJTlZJU0lCTEU6IDMsXG4gIEZJTExfQUREX1RPX1BBVEg6IDQsXG4gIFNUUk9LRV9BRERfVE9fUEFUSDogNSxcbiAgRklMTF9TVFJPS0VfQUREX1RPX1BBVEg6IDYsXG4gIEFERF9UT19QQVRIOiA3LFxuICBGSUxMX1NUUk9LRV9NQVNLOiAzLFxuICBBRERfVE9fUEFUSF9GTEFHOiA0XG59O1xuXG52YXIgSW1hZ2VLaW5kID0ge1xuICBHUkFZU0NBTEVfMUJQUDogMSxcbiAgUkdCXzI0QlBQOiAyLFxuICBSR0JBXzMyQlBQOiAzXG59O1xuXG52YXIgQW5ub3RhdGlvblR5cGUgPSB7XG4gIFdJREdFVDogMSxcbiAgVEVYVDogMixcbiAgTElOSzogM1xufTtcblxudmFyIFN0cmVhbVR5cGUgPSB7XG4gIFVOS05PV046IDAsXG4gIEZMQVRFOiAxLFxuICBMWlc6IDIsXG4gIERDVDogMyxcbiAgSlBYOiA0LFxuICBKQklHOiA1LFxuICBBODU6IDYsXG4gIEFIWDogNyxcbiAgQ0NGOiA4LFxuICBSTDogOVxufTtcblxudmFyIEZvbnRUeXBlID0ge1xuICBVTktOT1dOOiAwLFxuICBUWVBFMTogMSxcbiAgVFlQRTFDOiAyLFxuICBDSURGT05UVFlQRTA6IDMsXG4gIENJREZPTlRUWVBFMEM6IDQsXG4gIFRSVUVUWVBFOiA1LFxuICBDSURGT05UVFlQRTI6IDYsXG4gIFRZUEUzOiA3LFxuICBPUEVOVFlQRTogOCxcbiAgVFlQRTA6IDksXG4gIE1NVFlQRTE6IDEwXG59O1xuXG4vLyBUaGUgZ2xvYmFsIFBERkpTIG9iamVjdCBleHBvc2VzIHRoZSBBUElcbi8vIEluIHByb2R1Y3Rpb24sIGl0IHdpbGwgYmUgZGVjbGFyZWQgb3V0c2lkZSBhIGdsb2JhbCB3cmFwcGVyXG4vLyBJbiBkZXZlbG9wbWVudCwgaXQgd2lsbCBiZSBkZWNsYXJlZCBoZXJlXG5pZiAoIWdsb2JhbFNjb3BlLlBERkpTKSB7XG4gIGdsb2JhbFNjb3BlLlBERkpTID0ge307XG59XG5cbmdsb2JhbFNjb3BlLlBERkpTLnBkZkJ1ZyA9IGZhbHNlO1xuXG5QREZKUy5WRVJCT1NJVFlfTEVWRUxTID0ge1xuICBlcnJvcnM6IDAsXG4gIHdhcm5pbmdzOiAxLFxuICBpbmZvczogNVxufTtcblxuLy8gQWxsIHRoZSBwb3NzaWJsZSBvcGVyYXRpb25zIGZvciBhbiBvcGVyYXRvciBsaXN0LlxudmFyIE9QUyA9IFBERkpTLk9QUyA9IHtcbiAgLy8gSW50ZW50aW9uYWxseSBzdGFydCBmcm9tIDEgc28gaXQgaXMgZWFzeSB0byBzcG90IGJhZCBvcGVyYXRvcnMgdGhhdCB3aWxsIGJlXG4gIC8vIDAncy5cbiAgZGVwZW5kZW5jeTogMSxcbiAgc2V0TGluZVdpZHRoOiAyLFxuICBzZXRMaW5lQ2FwOiAzLFxuICBzZXRMaW5lSm9pbjogNCxcbiAgc2V0TWl0ZXJMaW1pdDogNSxcbiAgc2V0RGFzaDogNixcbiAgc2V0UmVuZGVyaW5nSW50ZW50OiA3LFxuICBzZXRGbGF0bmVzczogOCxcbiAgc2V0R1N0YXRlOiA5LFxuICBzYXZlOiAxMCxcbiAgcmVzdG9yZTogMTEsXG4gIHRyYW5zZm9ybTogMTIsXG4gIG1vdmVUbzogMTMsXG4gIGxpbmVUbzogMTQsXG4gIGN1cnZlVG86IDE1LFxuICBjdXJ2ZVRvMjogMTYsXG4gIGN1cnZlVG8zOiAxNyxcbiAgY2xvc2VQYXRoOiAxOCxcbiAgcmVjdGFuZ2xlOiAxOSxcbiAgc3Ryb2tlOiAyMCxcbiAgY2xvc2VTdHJva2U6IDIxLFxuICBmaWxsOiAyMixcbiAgZW9GaWxsOiAyMyxcbiAgZmlsbFN0cm9rZTogMjQsXG4gIGVvRmlsbFN0cm9rZTogMjUsXG4gIGNsb3NlRmlsbFN0cm9rZTogMjYsXG4gIGNsb3NlRU9GaWxsU3Ryb2tlOiAyNyxcbiAgZW5kUGF0aDogMjgsXG4gIGNsaXA6IDI5LFxuICBlb0NsaXA6IDMwLFxuICBiZWdpblRleHQ6IDMxLFxuICBlbmRUZXh0OiAzMixcbiAgc2V0Q2hhclNwYWNpbmc6IDMzLFxuICBzZXRXb3JkU3BhY2luZzogMzQsXG4gIHNldEhTY2FsZTogMzUsXG4gIHNldExlYWRpbmc6IDM2LFxuICBzZXRGb250OiAzNyxcbiAgc2V0VGV4dFJlbmRlcmluZ01vZGU6IDM4LFxuICBzZXRUZXh0UmlzZTogMzksXG4gIG1vdmVUZXh0OiA0MCxcbiAgc2V0TGVhZGluZ01vdmVUZXh0OiA0MSxcbiAgc2V0VGV4dE1hdHJpeDogNDIsXG4gIG5leHRMaW5lOiA0MyxcbiAgc2hvd1RleHQ6IDQ0LFxuICBzaG93U3BhY2VkVGV4dDogNDUsXG4gIG5leHRMaW5lU2hvd1RleHQ6IDQ2LFxuICBuZXh0TGluZVNldFNwYWNpbmdTaG93VGV4dDogNDcsXG4gIHNldENoYXJXaWR0aDogNDgsXG4gIHNldENoYXJXaWR0aEFuZEJvdW5kczogNDksXG4gIHNldFN0cm9rZUNvbG9yU3BhY2U6IDUwLFxuICBzZXRGaWxsQ29sb3JTcGFjZTogNTEsXG4gIHNldFN0cm9rZUNvbG9yOiA1MixcbiAgc2V0U3Ryb2tlQ29sb3JOOiA1MyxcbiAgc2V0RmlsbENvbG9yOiA1NCxcbiAgc2V0RmlsbENvbG9yTjogNTUsXG4gIHNldFN0cm9rZUdyYXk6IDU2LFxuICBzZXRGaWxsR3JheTogNTcsXG4gIHNldFN0cm9rZVJHQkNvbG9yOiA1OCxcbiAgc2V0RmlsbFJHQkNvbG9yOiA1OSxcbiAgc2V0U3Ryb2tlQ01ZS0NvbG9yOiA2MCxcbiAgc2V0RmlsbENNWUtDb2xvcjogNjEsXG4gIHNoYWRpbmdGaWxsOiA2MixcbiAgYmVnaW5JbmxpbmVJbWFnZTogNjMsXG4gIGJlZ2luSW1hZ2VEYXRhOiA2NCxcbiAgZW5kSW5saW5lSW1hZ2U6IDY1LFxuICBwYWludFhPYmplY3Q6IDY2LFxuICBtYXJrUG9pbnQ6IDY3LFxuICBtYXJrUG9pbnRQcm9wczogNjgsXG4gIGJlZ2luTWFya2VkQ29udGVudDogNjksXG4gIGJlZ2luTWFya2VkQ29udGVudFByb3BzOiA3MCxcbiAgZW5kTWFya2VkQ29udGVudDogNzEsXG4gIGJlZ2luQ29tcGF0OiA3MixcbiAgZW5kQ29tcGF0OiA3MyxcbiAgcGFpbnRGb3JtWE9iamVjdEJlZ2luOiA3NCxcbiAgcGFpbnRGb3JtWE9iamVjdEVuZDogNzUsXG4gIGJlZ2luR3JvdXA6IDc2LFxuICBlbmRHcm91cDogNzcsXG4gIGJlZ2luQW5ub3RhdGlvbnM6IDc4LFxuICBlbmRBbm5vdGF0aW9uczogNzksXG4gIGJlZ2luQW5ub3RhdGlvbjogODAsXG4gIGVuZEFubm90YXRpb246IDgxLFxuICBwYWludEpwZWdYT2JqZWN0OiA4MixcbiAgcGFpbnRJbWFnZU1hc2tYT2JqZWN0OiA4MyxcbiAgcGFpbnRJbWFnZU1hc2tYT2JqZWN0R3JvdXA6IDg0LFxuICBwYWludEltYWdlWE9iamVjdDogODUsXG4gIHBhaW50SW5saW5lSW1hZ2VYT2JqZWN0OiA4NixcbiAgcGFpbnRJbmxpbmVJbWFnZVhPYmplY3RHcm91cDogODcsXG4gIHBhaW50SW1hZ2VYT2JqZWN0UmVwZWF0OiA4OCxcbiAgcGFpbnRJbWFnZU1hc2tYT2JqZWN0UmVwZWF0OiA4OSxcbiAgcGFpbnRTb2xpZENvbG9ySW1hZ2VNYXNrOiA5MCxcbiAgY29uc3RydWN0UGF0aDogOTFcbn07XG5cbi8vIEEgbm90aWNlIGZvciBkZXZzLiBUaGVzZSBhcmUgZ29vZCBmb3IgdGhpbmdzIHRoYXQgYXJlIGhlbHBmdWwgdG8gZGV2cywgc3VjaFxuLy8gYXMgd2FybmluZyB0aGF0IFdvcmtlcnMgd2VyZSBkaXNhYmxlZCwgd2hpY2ggaXMgaW1wb3J0YW50IHRvIGRldnMgYnV0IG5vdFxuLy8gZW5kIHVzZXJzLlxuZnVuY3Rpb24gaW5mbyhtc2cpIHtcbiAgaWYgKFBERkpTLnZlcmJvc2l0eSA+PSBQREZKUy5WRVJCT1NJVFlfTEVWRUxTLmluZm9zKSB7XG4gICAgY29uc29sZS5sb2coJ0luZm86ICcgKyBtc2cpO1xuICB9XG59XG5cbi8vIE5vbi1mYXRhbCB3YXJuaW5ncy5cbmZ1bmN0aW9uIHdhcm4obXNnKSB7XG4gIGlmIChQREZKUy52ZXJib3NpdHkgPj0gUERGSlMuVkVSQk9TSVRZX0xFVkVMUy53YXJuaW5ncykge1xuICAgIGNvbnNvbGUubG9nKCdXYXJuaW5nOiAnICsgbXNnKTtcbiAgfVxufVxuXG4vLyBGYXRhbCBlcnJvcnMgdGhhdCBzaG91bGQgdHJpZ2dlciB0aGUgZmFsbGJhY2sgVUkgYW5kIGhhbHQgZXhlY3V0aW9uIGJ5XG4vLyB0aHJvd2luZyBhbiBleGNlcHRpb24uXG5mdW5jdGlvbiBlcnJvcihtc2cpIHtcbiAgLy8gSWYgbXVsdGlwbGUgYXJndW1lbnRzIHdlcmUgcGFzc2VkLCBwYXNzIHRoZW0gYWxsIHRvIHRoZSBsb2cgZnVuY3Rpb24uXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgIHZhciBsb2dBcmd1bWVudHMgPSBbJ0Vycm9yOiddO1xuICAgIGxvZ0FyZ3VtZW50cy5wdXNoLmFwcGx5KGxvZ0FyZ3VtZW50cywgYXJndW1lbnRzKTtcbiAgICBjb25zb2xlLmxvZy5hcHBseShjb25zb2xlLCBsb2dBcmd1bWVudHMpO1xuICAgIC8vIEpvaW4gdGhlIGFyZ3VtZW50cyBpbnRvIGEgc2luZ2xlIHN0cmluZyBmb3IgdGhlIGxpbmVzIGJlbG93LlxuICAgIG1zZyA9IFtdLmpvaW4uY2FsbChhcmd1bWVudHMsICcgJyk7XG4gIH0gZWxzZSB7XG4gICAgY29uc29sZS5sb2coJ0Vycm9yOiAnICsgbXNnKTtcbiAgfVxuICBjb25zb2xlLmxvZyhiYWNrdHJhY2UoKSk7XG4gIFVuc3VwcG9ydGVkTWFuYWdlci5ub3RpZnkoVU5TVVBQT1JURURfRkVBVFVSRVMudW5rbm93bik7XG4gIHRocm93IG5ldyBFcnJvcihtc2cpO1xufVxuXG5mdW5jdGlvbiBiYWNrdHJhY2UoKSB7XG4gIHRyeSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZS5zdGFjayA/IGUuc3RhY2suc3BsaXQoJ1xcbicpLnNsaWNlKDIpLmpvaW4oJ1xcbicpIDogJyc7XG4gIH1cbn1cblxuZnVuY3Rpb24gYXNzZXJ0KGNvbmQsIG1zZykge1xuICBpZiAoIWNvbmQpIHtcbiAgICBlcnJvcihtc2cpO1xuICB9XG59XG5cbnZhciBVTlNVUFBPUlRFRF9GRUFUVVJFUyA9IFBERkpTLlVOU1VQUE9SVEVEX0ZFQVRVUkVTID0ge1xuICB1bmtub3duOiAndW5rbm93bicsXG4gIGZvcm1zOiAnZm9ybXMnLFxuICBqYXZhU2NyaXB0OiAnamF2YVNjcmlwdCcsXG4gIHNtYXNrOiAnc21hc2snLFxuICBzaGFkaW5nUGF0dGVybjogJ3NoYWRpbmdQYXR0ZXJuJyxcbiAgZm9udDogJ2ZvbnQnXG59O1xuXG52YXIgVW5zdXBwb3J0ZWRNYW5hZ2VyID0gUERGSlMuVW5zdXBwb3J0ZWRNYW5hZ2VyID1cbiAgKGZ1bmN0aW9uIFVuc3VwcG9ydGVkTWFuYWdlckNsb3N1cmUoKSB7XG4gIHZhciBsaXN0ZW5lcnMgPSBbXTtcbiAgcmV0dXJuIHtcbiAgICBsaXN0ZW46IGZ1bmN0aW9uIChjYikge1xuICAgICAgbGlzdGVuZXJzLnB1c2goY2IpO1xuICAgIH0sXG4gICAgbm90aWZ5OiBmdW5jdGlvbiAoZmVhdHVyZUlkKSB7XG4gICAgICB3YXJuKCdVbnN1cHBvcnRlZCBmZWF0dXJlIFwiJyArIGZlYXR1cmVJZCArICdcIicpO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gbGlzdGVuZXJzLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgbGlzdGVuZXJzW2ldKGZlYXR1cmVJZCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xufSkoKTtcblxuLy8gQ29tYmluZXMgdHdvIFVSTHMuIFRoZSBiYXNlVXJsIHNoYWxsIGJlIGFic29sdXRlIFVSTC4gSWYgdGhlIHVybCBpcyBhblxuLy8gYWJzb2x1dGUgVVJMLCBpdCB3aWxsIGJlIHJldHVybmVkIGFzIGlzLlxuZnVuY3Rpb24gY29tYmluZVVybChiYXNlVXJsLCB1cmwpIHtcbiAgaWYgKCF1cmwpIHtcbiAgICByZXR1cm4gYmFzZVVybDtcbiAgfVxuICBpZiAoL15bYS16XVthLXowLTkrXFwtLl0qOi9pLnRlc3QodXJsKSkge1xuICAgIHJldHVybiB1cmw7XG4gIH1cbiAgdmFyIGk7XG4gIGlmICh1cmwuY2hhckF0KDApID09PSAnLycpIHtcbiAgICAvLyBhYnNvbHV0ZSBwYXRoXG4gICAgaSA9IGJhc2VVcmwuaW5kZXhPZignOi8vJyk7XG4gICAgaWYgKHVybC5jaGFyQXQoMSkgPT09ICcvJykge1xuICAgICAgKytpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpID0gYmFzZVVybC5pbmRleE9mKCcvJywgaSArIDMpO1xuICAgIH1cbiAgICByZXR1cm4gYmFzZVVybC5zdWJzdHJpbmcoMCwgaSkgKyB1cmw7XG4gIH0gZWxzZSB7XG4gICAgLy8gcmVsYXRpdmUgcGF0aFxuICAgIHZhciBwYXRoTGVuZ3RoID0gYmFzZVVybC5sZW5ndGg7XG4gICAgaSA9IGJhc2VVcmwubGFzdEluZGV4T2YoJyMnKTtcbiAgICBwYXRoTGVuZ3RoID0gaSA+PSAwID8gaSA6IHBhdGhMZW5ndGg7XG4gICAgaSA9IGJhc2VVcmwubGFzdEluZGV4T2YoJz8nLCBwYXRoTGVuZ3RoKTtcbiAgICBwYXRoTGVuZ3RoID0gaSA+PSAwID8gaSA6IHBhdGhMZW5ndGg7XG4gICAgdmFyIHByZWZpeExlbmd0aCA9IGJhc2VVcmwubGFzdEluZGV4T2YoJy8nLCBwYXRoTGVuZ3RoKTtcbiAgICByZXR1cm4gYmFzZVVybC5zdWJzdHJpbmcoMCwgcHJlZml4TGVuZ3RoICsgMSkgKyB1cmw7XG4gIH1cbn1cblxuLy8gVmFsaWRhdGVzIGlmIFVSTCBpcyBzYWZlIGFuZCBhbGxvd2VkLCBlLmcuIHRvIGF2b2lkIFhTUy5cbmZ1bmN0aW9uIGlzVmFsaWRVcmwodXJsLCBhbGxvd1JlbGF0aXZlKSB7XG4gIGlmICghdXJsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIFJGQyAzOTg2IChodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzOTg2I3NlY3Rpb24tMy4xKVxuICAvLyBzY2hlbWUgPSBBTFBIQSAqKCBBTFBIQSAvIERJR0lUIC8gXCIrXCIgLyBcIi1cIiAvIFwiLlwiIClcbiAgdmFyIHByb3RvY29sID0gL15bYS16XVthLXowLTkrXFwtLl0qKD89OikvaS5leGVjKHVybCk7XG4gIGlmICghcHJvdG9jb2wpIHtcbiAgICByZXR1cm4gYWxsb3dSZWxhdGl2ZTtcbiAgfVxuICBwcm90b2NvbCA9IHByb3RvY29sWzBdLnRvTG93ZXJDYXNlKCk7XG4gIHN3aXRjaCAocHJvdG9jb2wpIHtcbiAgICBjYXNlICdodHRwJzpcbiAgICBjYXNlICdodHRwcyc6XG4gICAgY2FzZSAnZnRwJzpcbiAgICBjYXNlICdtYWlsdG8nOlxuICAgIGNhc2UgJ3RlbCc6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5QREZKUy5pc1ZhbGlkVXJsID0gaXNWYWxpZFVybDtcblxuZnVuY3Rpb24gc2hhZG93KG9iaiwgcHJvcCwgdmFsdWUpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwgcHJvcCwgeyB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd3JpdGFibGU6IGZhbHNlIH0pO1xuICByZXR1cm4gdmFsdWU7XG59XG5QREZKUy5zaGFkb3cgPSBzaGFkb3c7XG5cbnZhciBQYXNzd29yZFJlc3BvbnNlcyA9IFBERkpTLlBhc3N3b3JkUmVzcG9uc2VzID0ge1xuICBORUVEX1BBU1NXT1JEOiAxLFxuICBJTkNPUlJFQ1RfUEFTU1dPUkQ6IDJcbn07XG5cbnZhciBQYXNzd29yZEV4Y2VwdGlvbiA9IChmdW5jdGlvbiBQYXNzd29yZEV4Y2VwdGlvbkNsb3N1cmUoKSB7XG4gIGZ1bmN0aW9uIFBhc3N3b3JkRXhjZXB0aW9uKG1zZywgY29kZSkge1xuICAgIHRoaXMubmFtZSA9ICdQYXNzd29yZEV4Y2VwdGlvbic7XG4gICAgdGhpcy5tZXNzYWdlID0gbXNnO1xuICAgIHRoaXMuY29kZSA9IGNvZGU7XG4gIH1cblxuICBQYXNzd29yZEV4Y2VwdGlvbi5wcm90b3R5cGUgPSBuZXcgRXJyb3IoKTtcbiAgUGFzc3dvcmRFeGNlcHRpb24uY29uc3RydWN0b3IgPSBQYXNzd29yZEV4Y2VwdGlvbjtcblxuICByZXR1cm4gUGFzc3dvcmRFeGNlcHRpb247XG59KSgpO1xuUERGSlMuUGFzc3dvcmRFeGNlcHRpb24gPSBQYXNzd29yZEV4Y2VwdGlvbjtcblxudmFyIFVua25vd25FcnJvckV4Y2VwdGlvbiA9IChmdW5jdGlvbiBVbmtub3duRXJyb3JFeGNlcHRpb25DbG9zdXJlKCkge1xuICBmdW5jdGlvbiBVbmtub3duRXJyb3JFeGNlcHRpb24obXNnLCBkZXRhaWxzKSB7XG4gICAgdGhpcy5uYW1lID0gJ1Vua25vd25FcnJvckV4Y2VwdGlvbic7XG4gICAgdGhpcy5tZXNzYWdlID0gbXNnO1xuICAgIHRoaXMuZGV0YWlscyA9IGRldGFpbHM7XG4gIH1cblxuICBVbmtub3duRXJyb3JFeGNlcHRpb24ucHJvdG90eXBlID0gbmV3IEVycm9yKCk7XG4gIFVua25vd25FcnJvckV4Y2VwdGlvbi5jb25zdHJ1Y3RvciA9IFVua25vd25FcnJvckV4Y2VwdGlvbjtcblxuICByZXR1cm4gVW5rbm93bkVycm9yRXhjZXB0aW9uO1xufSkoKTtcblBERkpTLlVua25vd25FcnJvckV4Y2VwdGlvbiA9IFVua25vd25FcnJvckV4Y2VwdGlvbjtcblxudmFyIEludmFsaWRQREZFeGNlcHRpb24gPSAoZnVuY3Rpb24gSW52YWxpZFBERkV4Y2VwdGlvbkNsb3N1cmUoKSB7XG4gIGZ1bmN0aW9uIEludmFsaWRQREZFeGNlcHRpb24obXNnKSB7XG4gICAgdGhpcy5uYW1lID0gJ0ludmFsaWRQREZFeGNlcHRpb24nO1xuICAgIHRoaXMubWVzc2FnZSA9IG1zZztcbiAgfVxuXG4gIEludmFsaWRQREZFeGNlcHRpb24ucHJvdG90eXBlID0gbmV3IEVycm9yKCk7XG4gIEludmFsaWRQREZFeGNlcHRpb24uY29uc3RydWN0b3IgPSBJbnZhbGlkUERGRXhjZXB0aW9uO1xuXG4gIHJldHVybiBJbnZhbGlkUERGRXhjZXB0aW9uO1xufSkoKTtcblBERkpTLkludmFsaWRQREZFeGNlcHRpb24gPSBJbnZhbGlkUERGRXhjZXB0aW9uO1xuXG52YXIgTWlzc2luZ1BERkV4Y2VwdGlvbiA9IChmdW5jdGlvbiBNaXNzaW5nUERGRXhjZXB0aW9uQ2xvc3VyZSgpIHtcbiAgZnVuY3Rpb24gTWlzc2luZ1BERkV4Y2VwdGlvbihtc2cpIHtcbiAgICB0aGlzLm5hbWUgPSAnTWlzc2luZ1BERkV4Y2VwdGlvbic7XG4gICAgdGhpcy5tZXNzYWdlID0gbXNnO1xuICB9XG5cbiAgTWlzc2luZ1BERkV4Y2VwdGlvbi5wcm90b3R5cGUgPSBuZXcgRXJyb3IoKTtcbiAgTWlzc2luZ1BERkV4Y2VwdGlvbi5jb25zdHJ1Y3RvciA9IE1pc3NpbmdQREZFeGNlcHRpb247XG5cbiAgcmV0dXJuIE1pc3NpbmdQREZFeGNlcHRpb247XG59KSgpO1xuUERGSlMuTWlzc2luZ1BERkV4Y2VwdGlvbiA9IE1pc3NpbmdQREZFeGNlcHRpb247XG5cbnZhciBVbmV4cGVjdGVkUmVzcG9uc2VFeGNlcHRpb24gPVxuICAgIChmdW5jdGlvbiBVbmV4cGVjdGVkUmVzcG9uc2VFeGNlcHRpb25DbG9zdXJlKCkge1xuICBmdW5jdGlvbiBVbmV4cGVjdGVkUmVzcG9uc2VFeGNlcHRpb24obXNnLCBzdGF0dXMpIHtcbiAgICB0aGlzLm5hbWUgPSAnVW5leHBlY3RlZFJlc3BvbnNlRXhjZXB0aW9uJztcbiAgICB0aGlzLm1lc3NhZ2UgPSBtc2c7XG4gICAgdGhpcy5zdGF0dXMgPSBzdGF0dXM7XG4gIH1cblxuICBVbmV4cGVjdGVkUmVzcG9uc2VFeGNlcHRpb24ucHJvdG90eXBlID0gbmV3IEVycm9yKCk7XG4gIFVuZXhwZWN0ZWRSZXNwb25zZUV4Y2VwdGlvbi5jb25zdHJ1Y3RvciA9IFVuZXhwZWN0ZWRSZXNwb25zZUV4Y2VwdGlvbjtcblxuICByZXR1cm4gVW5leHBlY3RlZFJlc3BvbnNlRXhjZXB0aW9uO1xufSkoKTtcblBERkpTLlVuZXhwZWN0ZWRSZXNwb25zZUV4Y2VwdGlvbiA9IFVuZXhwZWN0ZWRSZXNwb25zZUV4Y2VwdGlvbjtcblxudmFyIE5vdEltcGxlbWVudGVkRXhjZXB0aW9uID0gKGZ1bmN0aW9uIE5vdEltcGxlbWVudGVkRXhjZXB0aW9uQ2xvc3VyZSgpIHtcbiAgZnVuY3Rpb24gTm90SW1wbGVtZW50ZWRFeGNlcHRpb24obXNnKSB7XG4gICAgdGhpcy5tZXNzYWdlID0gbXNnO1xuICB9XG5cbiAgTm90SW1wbGVtZW50ZWRFeGNlcHRpb24ucHJvdG90eXBlID0gbmV3IEVycm9yKCk7XG4gIE5vdEltcGxlbWVudGVkRXhjZXB0aW9uLnByb3RvdHlwZS5uYW1lID0gJ05vdEltcGxlbWVudGVkRXhjZXB0aW9uJztcbiAgTm90SW1wbGVtZW50ZWRFeGNlcHRpb24uY29uc3RydWN0b3IgPSBOb3RJbXBsZW1lbnRlZEV4Y2VwdGlvbjtcblxuICByZXR1cm4gTm90SW1wbGVtZW50ZWRFeGNlcHRpb247XG59KSgpO1xuXG52YXIgTWlzc2luZ0RhdGFFeGNlcHRpb24gPSAoZnVuY3Rpb24gTWlzc2luZ0RhdGFFeGNlcHRpb25DbG9zdXJlKCkge1xuICBmdW5jdGlvbiBNaXNzaW5nRGF0YUV4Y2VwdGlvbihiZWdpbiwgZW5kKSB7XG4gICAgdGhpcy5iZWdpbiA9IGJlZ2luO1xuICAgIHRoaXMuZW5kID0gZW5kO1xuICAgIHRoaXMubWVzc2FnZSA9ICdNaXNzaW5nIGRhdGEgWycgKyBiZWdpbiArICcsICcgKyBlbmQgKyAnKSc7XG4gIH1cblxuICBNaXNzaW5nRGF0YUV4Y2VwdGlvbi5wcm90b3R5cGUgPSBuZXcgRXJyb3IoKTtcbiAgTWlzc2luZ0RhdGFFeGNlcHRpb24ucHJvdG90eXBlLm5hbWUgPSAnTWlzc2luZ0RhdGFFeGNlcHRpb24nO1xuICBNaXNzaW5nRGF0YUV4Y2VwdGlvbi5jb25zdHJ1Y3RvciA9IE1pc3NpbmdEYXRhRXhjZXB0aW9uO1xuXG4gIHJldHVybiBNaXNzaW5nRGF0YUV4Y2VwdGlvbjtcbn0pKCk7XG5cbnZhciBYUmVmUGFyc2VFeGNlcHRpb24gPSAoZnVuY3Rpb24gWFJlZlBhcnNlRXhjZXB0aW9uQ2xvc3VyZSgpIHtcbiAgZnVuY3Rpb24gWFJlZlBhcnNlRXhjZXB0aW9uKG1zZykge1xuICAgIHRoaXMubWVzc2FnZSA9IG1zZztcbiAgfVxuXG4gIFhSZWZQYXJzZUV4Y2VwdGlvbi5wcm90b3R5cGUgPSBuZXcgRXJyb3IoKTtcbiAgWFJlZlBhcnNlRXhjZXB0aW9uLnByb3RvdHlwZS5uYW1lID0gJ1hSZWZQYXJzZUV4Y2VwdGlvbic7XG4gIFhSZWZQYXJzZUV4Y2VwdGlvbi5jb25zdHJ1Y3RvciA9IFhSZWZQYXJzZUV4Y2VwdGlvbjtcblxuICByZXR1cm4gWFJlZlBhcnNlRXhjZXB0aW9uO1xufSkoKTtcblxuXG5mdW5jdGlvbiBieXRlc1RvU3RyaW5nKGJ5dGVzKSB7XG4gIGFzc2VydChieXRlcyAhPT0gbnVsbCAmJiB0eXBlb2YgYnl0ZXMgPT09ICdvYmplY3QnICYmXG4gICAgICAgICBieXRlcy5sZW5ndGggIT09IHVuZGVmaW5lZCwgJ0ludmFsaWQgYXJndW1lbnQgZm9yIGJ5dGVzVG9TdHJpbmcnKTtcbiAgdmFyIGxlbmd0aCA9IGJ5dGVzLmxlbmd0aDtcbiAgdmFyIE1BWF9BUkdVTUVOVF9DT1VOVCA9IDgxOTI7XG4gIGlmIChsZW5ndGggPCBNQVhfQVJHVU1FTlRfQ09VTlQpIHtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBieXRlcyk7XG4gIH1cbiAgdmFyIHN0ckJ1ZiA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSBNQVhfQVJHVU1FTlRfQ09VTlQpIHtcbiAgICB2YXIgY2h1bmtFbmQgPSBNYXRoLm1pbihpICsgTUFYX0FSR1VNRU5UX0NPVU5ULCBsZW5ndGgpO1xuICAgIHZhciBjaHVuayA9IGJ5dGVzLnN1YmFycmF5KGksIGNodW5rRW5kKTtcbiAgICBzdHJCdWYucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGNodW5rKSk7XG4gIH1cbiAgcmV0dXJuIHN0ckJ1Zi5qb2luKCcnKTtcbn1cblxuZnVuY3Rpb24gc3RyaW5nVG9CeXRlcyhzdHIpIHtcbiAgYXNzZXJ0KHR5cGVvZiBzdHIgPT09ICdzdHJpbmcnLCAnSW52YWxpZCBhcmd1bWVudCBmb3Igc3RyaW5nVG9CeXRlcycpO1xuICB2YXIgbGVuZ3RoID0gc3RyLmxlbmd0aDtcbiAgdmFyIGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGJ5dGVzW2ldID0gc3RyLmNoYXJDb2RlQXQoaSkgJiAweEZGO1xuICB9XG4gIHJldHVybiBieXRlcztcbn1cblxuZnVuY3Rpb24gc3RyaW5nMzIodmFsdWUpIHtcbiAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoKHZhbHVlID4+IDI0KSAmIDB4ZmYsICh2YWx1ZSA+PiAxNikgJiAweGZmLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAodmFsdWUgPj4gOCkgJiAweGZmLCB2YWx1ZSAmIDB4ZmYpO1xufVxuXG5mdW5jdGlvbiBsb2cyKHgpIHtcbiAgdmFyIG4gPSAxLCBpID0gMDtcbiAgd2hpbGUgKHggPiBuKSB7XG4gICAgbiA8PD0gMTtcbiAgICBpKys7XG4gIH1cbiAgcmV0dXJuIGk7XG59XG5cbmZ1bmN0aW9uIHJlYWRJbnQ4KGRhdGEsIHN0YXJ0KSB7XG4gIHJldHVybiAoZGF0YVtzdGFydF0gPDwgMjQpID4+IDI0O1xufVxuXG5mdW5jdGlvbiByZWFkVWludDE2KGRhdGEsIG9mZnNldCkge1xuICByZXR1cm4gKGRhdGFbb2Zmc2V0XSA8PCA4KSB8IGRhdGFbb2Zmc2V0ICsgMV07XG59XG5cbmZ1bmN0aW9uIHJlYWRVaW50MzIoZGF0YSwgb2Zmc2V0KSB7XG4gIHJldHVybiAoKGRhdGFbb2Zmc2V0XSA8PCAyNCkgfCAoZGF0YVtvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICAgICAgKGRhdGFbb2Zmc2V0ICsgMl0gPDwgOCkgfCBkYXRhW29mZnNldCArIDNdKSA+Pj4gMDtcbn1cblxuLy8gTGF6eSB0ZXN0IHRoZSBlbmRpYW5uZXNzIG9mIHRoZSBwbGF0Zm9ybVxuLy8gTk9URTogVGhpcyB3aWxsIGJlICd0cnVlJyBmb3Igc2ltdWxhdGVkIFR5cGVkQXJyYXlzXG5mdW5jdGlvbiBpc0xpdHRsZUVuZGlhbigpIHtcbiAgdmFyIGJ1ZmZlcjggPSBuZXcgVWludDhBcnJheSgyKTtcbiAgYnVmZmVyOFswXSA9IDE7XG4gIHZhciBidWZmZXIxNiA9IG5ldyBVaW50MTZBcnJheShidWZmZXI4LmJ1ZmZlcik7XG4gIHJldHVybiAoYnVmZmVyMTZbMF0gPT09IDEpO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUERGSlMsICdpc0xpdHRsZUVuZGlhbicsIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIFBERkpTX2lzTGl0dGxlRW5kaWFuKCkge1xuICAgIHJldHVybiBzaGFkb3coUERGSlMsICdpc0xpdHRsZUVuZGlhbicsIGlzTGl0dGxlRW5kaWFuKCkpO1xuICB9XG59KTtcblxuLy8jaWYgIShGSVJFRk9YIHx8IE1PWkNFTlRSQUwgfHwgQjJHIHx8IENIUk9NRSlcbi8vLy8gTGF6eSB0ZXN0IGlmIHRoZSB1c2VyQWdhbnQgc3VwcG9ydCBDYW52YXNUeXBlZEFycmF5c1xuZnVuY3Rpb24gaGFzQ2FudmFzVHlwZWRBcnJheXMoKSB7XG4gIHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgY2FudmFzLndpZHRoID0gY2FudmFzLmhlaWdodCA9IDE7XG4gIHZhciBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgdmFyIGltYWdlRGF0YSA9IGN0eC5jcmVhdGVJbWFnZURhdGEoMSwgMSk7XG4gIHJldHVybiAodHlwZW9mIGltYWdlRGF0YS5kYXRhLmJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcpO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUERGSlMsICdoYXNDYW52YXNUeXBlZEFycmF5cycsIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIFBERkpTX2hhc0NhbnZhc1R5cGVkQXJyYXlzKCkge1xuICAgIHJldHVybiBzaGFkb3coUERGSlMsICdoYXNDYW52YXNUeXBlZEFycmF5cycsIGhhc0NhbnZhc1R5cGVkQXJyYXlzKCkpO1xuICB9XG59KTtcblxudmFyIFVpbnQzMkFycmF5VmlldyA9IChmdW5jdGlvbiBVaW50MzJBcnJheVZpZXdDbG9zdXJlKCkge1xuXG4gIGZ1bmN0aW9uIFVpbnQzMkFycmF5VmlldyhidWZmZXIsIGxlbmd0aCkge1xuICAgIHRoaXMuYnVmZmVyID0gYnVmZmVyO1xuICAgIHRoaXMuYnl0ZUxlbmd0aCA9IGJ1ZmZlci5sZW5ndGg7XG4gICAgdGhpcy5sZW5ndGggPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/ICh0aGlzLmJ5dGVMZW5ndGggPj4gMikgOiBsZW5ndGg7XG4gICAgZW5zdXJlVWludDMyQXJyYXlWaWV3UHJvcHModGhpcy5sZW5ndGgpO1xuICB9XG4gIFVpbnQzMkFycmF5Vmlldy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gIHZhciB1aW50MzJBcnJheVZpZXdTZXR0ZXJzID0gMDtcbiAgZnVuY3Rpb24gY3JlYXRlVWludDMyQXJyYXlQcm9wKGluZGV4KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYnVmZmVyID0gdGhpcy5idWZmZXIsIG9mZnNldCA9IGluZGV4IDw8IDI7XG4gICAgICAgIHJldHVybiAoYnVmZmVyW29mZnNldF0gfCAoYnVmZmVyW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAgICAgICAoYnVmZmVyW29mZnNldCArIDJdIDw8IDE2KSB8IChidWZmZXJbb2Zmc2V0ICsgM10gPDwgMjQpKSA+Pj4gMDtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgYnVmZmVyID0gdGhpcy5idWZmZXIsIG9mZnNldCA9IGluZGV4IDw8IDI7XG4gICAgICAgIGJ1ZmZlcltvZmZzZXRdID0gdmFsdWUgJiAyNTU7XG4gICAgICAgIGJ1ZmZlcltvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+PiA4KSAmIDI1NTtcbiAgICAgICAgYnVmZmVyW29mZnNldCArIDJdID0gKHZhbHVlID4+IDE2KSAmIDI1NTtcbiAgICAgICAgYnVmZmVyW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNCkgJiAyNTU7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGVuc3VyZVVpbnQzMkFycmF5Vmlld1Byb3BzKGxlbmd0aCkge1xuICAgIHdoaWxlICh1aW50MzJBcnJheVZpZXdTZXR0ZXJzIDwgbGVuZ3RoKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVWludDMyQXJyYXlWaWV3LnByb3RvdHlwZSxcbiAgICAgICAgdWludDMyQXJyYXlWaWV3U2V0dGVycyxcbiAgICAgICAgY3JlYXRlVWludDMyQXJyYXlQcm9wKHVpbnQzMkFycmF5Vmlld1NldHRlcnMpKTtcbiAgICAgIHVpbnQzMkFycmF5Vmlld1NldHRlcnMrKztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gVWludDMyQXJyYXlWaWV3O1xufSkoKTtcbi8vI2Vsc2Vcbi8vUERGSlMuaGFzQ2FudmFzVHlwZWRBcnJheXMgPSB0cnVlO1xuLy8jZW5kaWZcblxudmFyIElERU5USVRZX01BVFJJWCA9IFsxLCAwLCAwLCAxLCAwLCAwXTtcblxudmFyIFV0aWwgPSBQREZKUy5VdGlsID0gKGZ1bmN0aW9uIFV0aWxDbG9zdXJlKCkge1xuICBmdW5jdGlvbiBVdGlsKCkge31cblxuICB2YXIgcmdiQnVmID0gWydyZ2IoJywgMCwgJywnLCAwLCAnLCcsIDAsICcpJ107XG5cbiAgLy8gbWFrZUNzc1JnYigpIGNhbiBiZSBjYWxsZWQgdGhvdXNhbmRzIG9mIHRpbWVzLiBVc2luZyB8cmdiQnVmfCBhdm9pZHNcbiAgLy8gY3JlYXRpbmcgbWFueSBpbnRlcm1lZGlhdGUgc3RyaW5ncy5cbiAgVXRpbC5tYWtlQ3NzUmdiID0gZnVuY3Rpb24gVXRpbF9tYWtlQ3NzUmdiKHIsIGcsIGIpIHtcbiAgICByZ2JCdWZbMV0gPSByO1xuICAgIHJnYkJ1ZlszXSA9IGc7XG4gICAgcmdiQnVmWzVdID0gYjtcbiAgICByZXR1cm4gcmdiQnVmLmpvaW4oJycpO1xuICB9O1xuXG4gIC8vIENvbmNhdGVuYXRlcyB0d28gdHJhbnNmb3JtYXRpb24gbWF0cmljZXMgdG9nZXRoZXIgYW5kIHJldHVybnMgdGhlIHJlc3VsdC5cbiAgVXRpbC50cmFuc2Zvcm0gPSBmdW5jdGlvbiBVdGlsX3RyYW5zZm9ybShtMSwgbTIpIHtcbiAgICByZXR1cm4gW1xuICAgICAgbTFbMF0gKiBtMlswXSArIG0xWzJdICogbTJbMV0sXG4gICAgICBtMVsxXSAqIG0yWzBdICsgbTFbM10gKiBtMlsxXSxcbiAgICAgIG0xWzBdICogbTJbMl0gKyBtMVsyXSAqIG0yWzNdLFxuICAgICAgbTFbMV0gKiBtMlsyXSArIG0xWzNdICogbTJbM10sXG4gICAgICBtMVswXSAqIG0yWzRdICsgbTFbMl0gKiBtMls1XSArIG0xWzRdLFxuICAgICAgbTFbMV0gKiBtMls0XSArIG0xWzNdICogbTJbNV0gKyBtMVs1XVxuICAgIF07XG4gIH07XG5cbiAgLy8gRm9yIDJkIGFmZmluZSB0cmFuc2Zvcm1zXG4gIFV0aWwuYXBwbHlUcmFuc2Zvcm0gPSBmdW5jdGlvbiBVdGlsX2FwcGx5VHJhbnNmb3JtKHAsIG0pIHtcbiAgICB2YXIgeHQgPSBwWzBdICogbVswXSArIHBbMV0gKiBtWzJdICsgbVs0XTtcbiAgICB2YXIgeXQgPSBwWzBdICogbVsxXSArIHBbMV0gKiBtWzNdICsgbVs1XTtcbiAgICByZXR1cm4gW3h0LCB5dF07XG4gIH07XG5cbiAgVXRpbC5hcHBseUludmVyc2VUcmFuc2Zvcm0gPSBmdW5jdGlvbiBVdGlsX2FwcGx5SW52ZXJzZVRyYW5zZm9ybShwLCBtKSB7XG4gICAgdmFyIGQgPSBtWzBdICogbVszXSAtIG1bMV0gKiBtWzJdO1xuICAgIHZhciB4dCA9IChwWzBdICogbVszXSAtIHBbMV0gKiBtWzJdICsgbVsyXSAqIG1bNV0gLSBtWzRdICogbVszXSkgLyBkO1xuICAgIHZhciB5dCA9ICgtcFswXSAqIG1bMV0gKyBwWzFdICogbVswXSArIG1bNF0gKiBtWzFdIC0gbVs1XSAqIG1bMF0pIC8gZDtcbiAgICByZXR1cm4gW3h0LCB5dF07XG4gIH07XG5cbiAgLy8gQXBwbGllcyB0aGUgdHJhbnNmb3JtIHRvIHRoZSByZWN0YW5nbGUgYW5kIGZpbmRzIHRoZSBtaW5pbXVtIGF4aWFsbHlcbiAgLy8gYWxpZ25lZCBib3VuZGluZyBib3guXG4gIFV0aWwuZ2V0QXhpYWxBbGlnbmVkQm91bmRpbmdCb3ggPVxuICAgIGZ1bmN0aW9uIFV0aWxfZ2V0QXhpYWxBbGlnbmVkQm91bmRpbmdCb3gociwgbSkge1xuXG4gICAgdmFyIHAxID0gVXRpbC5hcHBseVRyYW5zZm9ybShyLCBtKTtcbiAgICB2YXIgcDIgPSBVdGlsLmFwcGx5VHJhbnNmb3JtKHIuc2xpY2UoMiwgNCksIG0pO1xuICAgIHZhciBwMyA9IFV0aWwuYXBwbHlUcmFuc2Zvcm0oW3JbMF0sIHJbM11dLCBtKTtcbiAgICB2YXIgcDQgPSBVdGlsLmFwcGx5VHJhbnNmb3JtKFtyWzJdLCByWzFdXSwgbSk7XG4gICAgcmV0dXJuIFtcbiAgICAgIE1hdGgubWluKHAxWzBdLCBwMlswXSwgcDNbMF0sIHA0WzBdKSxcbiAgICAgIE1hdGgubWluKHAxWzFdLCBwMlsxXSwgcDNbMV0sIHA0WzFdKSxcbiAgICAgIE1hdGgubWF4KHAxWzBdLCBwMlswXSwgcDNbMF0sIHA0WzBdKSxcbiAgICAgIE1hdGgubWF4KHAxWzFdLCBwMlsxXSwgcDNbMV0sIHA0WzFdKVxuICAgIF07XG4gIH07XG5cbiAgVXRpbC5pbnZlcnNlVHJhbnNmb3JtID0gZnVuY3Rpb24gVXRpbF9pbnZlcnNlVHJhbnNmb3JtKG0pIHtcbiAgICB2YXIgZCA9IG1bMF0gKiBtWzNdIC0gbVsxXSAqIG1bMl07XG4gICAgcmV0dXJuIFttWzNdIC8gZCwgLW1bMV0gLyBkLCAtbVsyXSAvIGQsIG1bMF0gLyBkLFxuICAgICAgKG1bMl0gKiBtWzVdIC0gbVs0XSAqIG1bM10pIC8gZCwgKG1bNF0gKiBtWzFdIC0gbVs1XSAqIG1bMF0pIC8gZF07XG4gIH07XG5cbiAgLy8gQXBwbHkgYSBnZW5lcmljIDNkIG1hdHJpeCBNIG9uIGEgMy12ZWN0b3IgdjpcbiAgLy8gICB8IGEgYiBjIHwgICB8IFggfFxuICAvLyAgIHwgZCBlIGYgfCB4IHwgWSB8XG4gIC8vICAgfCBnIGggaSB8ICAgfCBaIHxcbiAgLy8gTSBpcyBhc3N1bWVkIHRvIGJlIHNlcmlhbGl6ZWQgYXMgW2EsYixjLGQsZSxmLGcsaCxpXSxcbiAgLy8gd2l0aCB2IGFzIFtYLFksWl1cbiAgVXRpbC5hcHBseTNkVHJhbnNmb3JtID0gZnVuY3Rpb24gVXRpbF9hcHBseTNkVHJhbnNmb3JtKG0sIHYpIHtcbiAgICByZXR1cm4gW1xuICAgICAgbVswXSAqIHZbMF0gKyBtWzFdICogdlsxXSArIG1bMl0gKiB2WzJdLFxuICAgICAgbVszXSAqIHZbMF0gKyBtWzRdICogdlsxXSArIG1bNV0gKiB2WzJdLFxuICAgICAgbVs2XSAqIHZbMF0gKyBtWzddICogdlsxXSArIG1bOF0gKiB2WzJdXG4gICAgXTtcbiAgfTtcblxuICAvLyBUaGlzIGNhbGN1bGF0aW9uIHVzZXMgU2luZ3VsYXIgVmFsdWUgRGVjb21wb3NpdGlvbi5cbiAgLy8gVGhlIFNWRCBjYW4gYmUgcmVwcmVzZW50ZWQgd2l0aCBmb3JtdWxhIEEgPSBVU1YuIFdlIGFyZSBpbnRlcmVzdGVkIGluIHRoZVxuICAvLyBtYXRyaXggUyBoZXJlIGJlY2F1c2UgaXQgcmVwcmVzZW50cyB0aGUgc2NhbGUgdmFsdWVzLlxuICBVdGlsLnNpbmd1bGFyVmFsdWVEZWNvbXBvc2UyZFNjYWxlID1cbiAgICBmdW5jdGlvbiBVdGlsX3Npbmd1bGFyVmFsdWVEZWNvbXBvc2UyZFNjYWxlKG0pIHtcblxuICAgIHZhciB0cmFuc3Bvc2UgPSBbbVswXSwgbVsyXSwgbVsxXSwgbVszXV07XG5cbiAgICAvLyBNdWx0aXBseSBtYXRyaXggbSB3aXRoIGl0cyB0cmFuc3Bvc2UuXG4gICAgdmFyIGEgPSBtWzBdICogdHJhbnNwb3NlWzBdICsgbVsxXSAqIHRyYW5zcG9zZVsyXTtcbiAgICB2YXIgYiA9IG1bMF0gKiB0cmFuc3Bvc2VbMV0gKyBtWzFdICogdHJhbnNwb3NlWzNdO1xuICAgIHZhciBjID0gbVsyXSAqIHRyYW5zcG9zZVswXSArIG1bM10gKiB0cmFuc3Bvc2VbMl07XG4gICAgdmFyIGQgPSBtWzJdICogdHJhbnNwb3NlWzFdICsgbVszXSAqIHRyYW5zcG9zZVszXTtcblxuICAgIC8vIFNvbHZlIHRoZSBzZWNvbmQgZGVncmVlIHBvbHlub21pYWwgdG8gZ2V0IHJvb3RzLlxuICAgIHZhciBmaXJzdCA9IChhICsgZCkgLyAyO1xuICAgIHZhciBzZWNvbmQgPSBNYXRoLnNxcnQoKGEgKyBkKSAqIChhICsgZCkgLSA0ICogKGEgKiBkIC0gYyAqIGIpKSAvIDI7XG4gICAgdmFyIHN4ID0gZmlyc3QgKyBzZWNvbmQgfHwgMTtcbiAgICB2YXIgc3kgPSBmaXJzdCAtIHNlY29uZCB8fCAxO1xuXG4gICAgLy8gU2NhbGUgdmFsdWVzIGFyZSB0aGUgc3F1YXJlIHJvb3RzIG9mIHRoZSBlaWdlbnZhbHVlcy5cbiAgICByZXR1cm4gW01hdGguc3FydChzeCksIE1hdGguc3FydChzeSldO1xuICB9O1xuXG4gIC8vIE5vcm1hbGl6ZSByZWN0YW5nbGUgcmVjdD1beDEsIHkxLCB4MiwgeTJdIHNvIHRoYXQgKHgxLHkxKSA8ICh4Mix5MilcbiAgLy8gRm9yIGNvb3JkaW5hdGUgc3lzdGVtcyB3aG9zZSBvcmlnaW4gbGllcyBpbiB0aGUgYm90dG9tLWxlZnQsIHRoaXNcbiAgLy8gbWVhbnMgbm9ybWFsaXphdGlvbiB0byAoQkwsVFIpIG9yZGVyaW5nLiBGb3Igc3lzdGVtcyB3aXRoIG9yaWdpbiBpbiB0aGVcbiAgLy8gdG9wLWxlZnQsIHRoaXMgbWVhbnMgKFRMLEJSKSBvcmRlcmluZy5cbiAgVXRpbC5ub3JtYWxpemVSZWN0ID0gZnVuY3Rpb24gVXRpbF9ub3JtYWxpemVSZWN0KHJlY3QpIHtcbiAgICB2YXIgciA9IHJlY3Quc2xpY2UoMCk7IC8vIGNsb25lIHJlY3RcbiAgICBpZiAocmVjdFswXSA+IHJlY3RbMl0pIHtcbiAgICAgIHJbMF0gPSByZWN0WzJdO1xuICAgICAgclsyXSA9IHJlY3RbMF07XG4gICAgfVxuICAgIGlmIChyZWN0WzFdID4gcmVjdFszXSkge1xuICAgICAgclsxXSA9IHJlY3RbM107XG4gICAgICByWzNdID0gcmVjdFsxXTtcbiAgICB9XG4gICAgcmV0dXJuIHI7XG4gIH07XG5cbiAgLy8gUmV0dXJucyBhIHJlY3RhbmdsZSBbeDEsIHkxLCB4MiwgeTJdIGNvcnJlc3BvbmRpbmcgdG8gdGhlXG4gIC8vIGludGVyc2VjdGlvbiBvZiByZWN0MSBhbmQgcmVjdDIuIElmIG5vIGludGVyc2VjdGlvbiwgcmV0dXJucyAnZmFsc2UnXG4gIC8vIFRoZSByZWN0YW5nbGUgY29vcmRpbmF0ZXMgb2YgcmVjdDEsIHJlY3QyIHNob3VsZCBiZSBbeDEsIHkxLCB4MiwgeTJdXG4gIFV0aWwuaW50ZXJzZWN0ID0gZnVuY3Rpb24gVXRpbF9pbnRlcnNlY3QocmVjdDEsIHJlY3QyKSB7XG4gICAgZnVuY3Rpb24gY29tcGFyZShhLCBiKSB7XG4gICAgICByZXR1cm4gYSAtIGI7XG4gICAgfVxuXG4gICAgLy8gT3JkZXIgcG9pbnRzIGFsb25nIHRoZSBheGVzXG4gICAgdmFyIG9yZGVyZWRYID0gW3JlY3QxWzBdLCByZWN0MVsyXSwgcmVjdDJbMF0sIHJlY3QyWzJdXS5zb3J0KGNvbXBhcmUpLFxuICAgICAgICBvcmRlcmVkWSA9IFtyZWN0MVsxXSwgcmVjdDFbM10sIHJlY3QyWzFdLCByZWN0MlszXV0uc29ydChjb21wYXJlKSxcbiAgICAgICAgcmVzdWx0ID0gW107XG5cbiAgICByZWN0MSA9IFV0aWwubm9ybWFsaXplUmVjdChyZWN0MSk7XG4gICAgcmVjdDIgPSBVdGlsLm5vcm1hbGl6ZVJlY3QocmVjdDIpO1xuXG4gICAgLy8gWDogZmlyc3QgYW5kIHNlY29uZCBwb2ludHMgYmVsb25nIHRvIGRpZmZlcmVudCByZWN0YW5nbGVzP1xuICAgIGlmICgob3JkZXJlZFhbMF0gPT09IHJlY3QxWzBdICYmIG9yZGVyZWRYWzFdID09PSByZWN0MlswXSkgfHxcbiAgICAgICAgKG9yZGVyZWRYWzBdID09PSByZWN0MlswXSAmJiBvcmRlcmVkWFsxXSA9PT0gcmVjdDFbMF0pKSB7XG4gICAgICAvLyBJbnRlcnNlY3Rpb24gbXVzdCBiZSBiZXR3ZWVuIHNlY29uZCBhbmQgdGhpcmQgcG9pbnRzXG4gICAgICByZXN1bHRbMF0gPSBvcmRlcmVkWFsxXTtcbiAgICAgIHJlc3VsdFsyXSA9IG9yZGVyZWRYWzJdO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gWTogZmlyc3QgYW5kIHNlY29uZCBwb2ludHMgYmVsb25nIHRvIGRpZmZlcmVudCByZWN0YW5nbGVzP1xuICAgIGlmICgob3JkZXJlZFlbMF0gPT09IHJlY3QxWzFdICYmIG9yZGVyZWRZWzFdID09PSByZWN0MlsxXSkgfHxcbiAgICAgICAgKG9yZGVyZWRZWzBdID09PSByZWN0MlsxXSAmJiBvcmRlcmVkWVsxXSA9PT0gcmVjdDFbMV0pKSB7XG4gICAgICAvLyBJbnRlcnNlY3Rpb24gbXVzdCBiZSBiZXR3ZWVuIHNlY29uZCBhbmQgdGhpcmQgcG9pbnRzXG4gICAgICByZXN1bHRbMV0gPSBvcmRlcmVkWVsxXTtcbiAgICAgIHJlc3VsdFszXSA9IG9yZGVyZWRZWzJdO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICBVdGlsLnNpZ24gPSBmdW5jdGlvbiBVdGlsX3NpZ24obnVtKSB7XG4gICAgcmV0dXJuIG51bSA8IDAgPyAtMSA6IDE7XG4gIH07XG5cbiAgVXRpbC5hcHBlbmRUb0FycmF5ID0gZnVuY3Rpb24gVXRpbF9hcHBlbmRUb0FycmF5KGFycjEsIGFycjIpIHtcbiAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShhcnIxLCBhcnIyKTtcbiAgfTtcblxuICBVdGlsLnByZXBlbmRUb0FycmF5ID0gZnVuY3Rpb24gVXRpbF9wcmVwZW5kVG9BcnJheShhcnIxLCBhcnIyKSB7XG4gICAgQXJyYXkucHJvdG90eXBlLnVuc2hpZnQuYXBwbHkoYXJyMSwgYXJyMik7XG4gIH07XG5cbiAgVXRpbC5leHRlbmRPYmogPSBmdW5jdGlvbiBleHRlbmRPYmoob2JqMSwgb2JqMikge1xuICAgIGZvciAodmFyIGtleSBpbiBvYmoyKSB7XG4gICAgICBvYmoxW2tleV0gPSBvYmoyW2tleV07XG4gICAgfVxuICB9O1xuXG4gIFV0aWwuZ2V0SW5oZXJpdGFibGVQcm9wZXJ0eSA9IGZ1bmN0aW9uIFV0aWxfZ2V0SW5oZXJpdGFibGVQcm9wZXJ0eShkaWN0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZSkge1xuICAgIHdoaWxlIChkaWN0ICYmICFkaWN0LmhhcyhuYW1lKSkge1xuICAgICAgZGljdCA9IGRpY3QuZ2V0KCdQYXJlbnQnKTtcbiAgICB9XG4gICAgaWYgKCFkaWN0KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGRpY3QuZ2V0KG5hbWUpO1xuICB9O1xuXG4gIFV0aWwuaW5oZXJpdCA9IGZ1bmN0aW9uIFV0aWxfaW5oZXJpdChzdWIsIGJhc2UsIHByb3RvdHlwZSkge1xuICAgIHN1Yi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGJhc2UucHJvdG90eXBlKTtcbiAgICBzdWIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViO1xuICAgIGZvciAodmFyIHByb3AgaW4gcHJvdG90eXBlKSB7XG4gICAgICBzdWIucHJvdG90eXBlW3Byb3BdID0gcHJvdG90eXBlW3Byb3BdO1xuICAgIH1cbiAgfTtcblxuICBVdGlsLmxvYWRTY3JpcHQgPSBmdW5jdGlvbiBVdGlsX2xvYWRTY3JpcHQoc3JjLCBjYWxsYmFjaykge1xuICAgIHZhciBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcbiAgICB2YXIgbG9hZGVkID0gZmFsc2U7XG4gICAgc2NyaXB0LnNldEF0dHJpYnV0ZSgnc3JjJywgc3JjKTtcbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgIHNjcmlwdC5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCFsb2FkZWQpIHtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICB9XG4gICAgICAgIGxvYWRlZCA9IHRydWU7XG4gICAgICB9O1xuICAgIH1cbiAgICBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdLmFwcGVuZENoaWxkKHNjcmlwdCk7XG4gIH07XG5cbiAgcmV0dXJuIFV0aWw7XG59KSgpO1xuXG4vKipcbiAqIFBERiBwYWdlIHZpZXdwb3J0IGNyZWF0ZWQgYmFzZWQgb24gc2NhbGUsIHJvdGF0aW9uIGFuZCBvZmZzZXQuXG4gKiBAY2xhc3NcbiAqIEBhbGlhcyBQREZKUy5QYWdlVmlld3BvcnRcbiAqL1xudmFyIFBhZ2VWaWV3cG9ydCA9IFBERkpTLlBhZ2VWaWV3cG9ydCA9IChmdW5jdGlvbiBQYWdlVmlld3BvcnRDbG9zdXJlKCkge1xuICAvKipcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB2aWV3Qm94IHtBcnJheX0geE1pbiwgeU1pbiwgeE1heCBhbmQgeU1heCBjb29yZGluYXRlcy5cbiAgICogQHBhcmFtIHNjYWxlIHtudW1iZXJ9IHNjYWxlIG9mIHRoZSB2aWV3cG9ydC5cbiAgICogQHBhcmFtIHJvdGF0aW9uIHtudW1iZXJ9IHJvdGF0aW9ucyBvZiB0aGUgdmlld3BvcnQgaW4gZGVncmVlcy5cbiAgICogQHBhcmFtIG9mZnNldFgge251bWJlcn0gb2Zmc2V0IFhcbiAgICogQHBhcmFtIG9mZnNldFkge251bWJlcn0gb2Zmc2V0IFlcbiAgICogQHBhcmFtIGRvbnRGbGlwIHtib29sZWFufSBpZiB0cnVlLCBheGlzIFkgd2lsbCBub3QgYmUgZmxpcHBlZC5cbiAgICovXG4gIGZ1bmN0aW9uIFBhZ2VWaWV3cG9ydCh2aWV3Qm94LCBzY2FsZSwgcm90YXRpb24sIG9mZnNldFgsIG9mZnNldFksIGRvbnRGbGlwKSB7XG4gICAgdGhpcy52aWV3Qm94ID0gdmlld0JveDtcbiAgICB0aGlzLnNjYWxlID0gc2NhbGU7XG4gICAgdGhpcy5yb3RhdGlvbiA9IHJvdGF0aW9uO1xuICAgIHRoaXMub2Zmc2V0WCA9IG9mZnNldFg7XG4gICAgdGhpcy5vZmZzZXRZID0gb2Zmc2V0WTtcblxuICAgIC8vIGNyZWF0aW5nIHRyYW5zZm9ybSB0byBjb252ZXJ0IHBkZiBjb29yZGluYXRlIHN5c3RlbSB0byB0aGUgbm9ybWFsXG4gICAgLy8gY2FudmFzIGxpa2UgY29vcmRpbmF0ZXMgdGFraW5nIGluIGFjY291bnQgc2NhbGUgYW5kIHJvdGF0aW9uXG4gICAgdmFyIGNlbnRlclggPSAodmlld0JveFsyXSArIHZpZXdCb3hbMF0pIC8gMjtcbiAgICB2YXIgY2VudGVyWSA9ICh2aWV3Qm94WzNdICsgdmlld0JveFsxXSkgLyAyO1xuICAgIHZhciByb3RhdGVBLCByb3RhdGVCLCByb3RhdGVDLCByb3RhdGVEO1xuICAgIHJvdGF0aW9uID0gcm90YXRpb24gJSAzNjA7XG4gICAgcm90YXRpb24gPSByb3RhdGlvbiA8IDAgPyByb3RhdGlvbiArIDM2MCA6IHJvdGF0aW9uO1xuICAgIHN3aXRjaCAocm90YXRpb24pIHtcbiAgICAgIGNhc2UgMTgwOlxuICAgICAgICByb3RhdGVBID0gLTE7IHJvdGF0ZUIgPSAwOyByb3RhdGVDID0gMDsgcm90YXRlRCA9IDE7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSA5MDpcbiAgICAgICAgcm90YXRlQSA9IDA7IHJvdGF0ZUIgPSAxOyByb3RhdGVDID0gMTsgcm90YXRlRCA9IDA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyNzA6XG4gICAgICAgIHJvdGF0ZUEgPSAwOyByb3RhdGVCID0gLTE7IHJvdGF0ZUMgPSAtMTsgcm90YXRlRCA9IDA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgLy9jYXNlIDA6XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByb3RhdGVBID0gMTsgcm90YXRlQiA9IDA7IHJvdGF0ZUMgPSAwOyByb3RhdGVEID0gLTE7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGlmIChkb250RmxpcCkge1xuICAgICAgcm90YXRlQyA9IC1yb3RhdGVDOyByb3RhdGVEID0gLXJvdGF0ZUQ7XG4gICAgfVxuXG4gICAgdmFyIG9mZnNldENhbnZhc1gsIG9mZnNldENhbnZhc1k7XG4gICAgdmFyIHdpZHRoLCBoZWlnaHQ7XG4gICAgaWYgKHJvdGF0ZUEgPT09IDApIHtcbiAgICAgIG9mZnNldENhbnZhc1ggPSBNYXRoLmFicyhjZW50ZXJZIC0gdmlld0JveFsxXSkgKiBzY2FsZSArIG9mZnNldFg7XG4gICAgICBvZmZzZXRDYW52YXNZID0gTWF0aC5hYnMoY2VudGVyWCAtIHZpZXdCb3hbMF0pICogc2NhbGUgKyBvZmZzZXRZO1xuICAgICAgd2lkdGggPSBNYXRoLmFicyh2aWV3Qm94WzNdIC0gdmlld0JveFsxXSkgKiBzY2FsZTtcbiAgICAgIGhlaWdodCA9IE1hdGguYWJzKHZpZXdCb3hbMl0gLSB2aWV3Qm94WzBdKSAqIHNjYWxlO1xuICAgIH0gZWxzZSB7XG4gICAgICBvZmZzZXRDYW52YXNYID0gTWF0aC5hYnMoY2VudGVyWCAtIHZpZXdCb3hbMF0pICogc2NhbGUgKyBvZmZzZXRYO1xuICAgICAgb2Zmc2V0Q2FudmFzWSA9IE1hdGguYWJzKGNlbnRlclkgLSB2aWV3Qm94WzFdKSAqIHNjYWxlICsgb2Zmc2V0WTtcbiAgICAgIHdpZHRoID0gTWF0aC5hYnModmlld0JveFsyXSAtIHZpZXdCb3hbMF0pICogc2NhbGU7XG4gICAgICBoZWlnaHQgPSBNYXRoLmFicyh2aWV3Qm94WzNdIC0gdmlld0JveFsxXSkgKiBzY2FsZTtcbiAgICB9XG4gICAgLy8gY3JlYXRpbmcgdHJhbnNmb3JtIGZvciB0aGUgZm9sbG93aW5nIG9wZXJhdGlvbnM6XG4gICAgLy8gdHJhbnNsYXRlKC1jZW50ZXJYLCAtY2VudGVyWSksIHJvdGF0ZSBhbmQgZmxpcCB2ZXJ0aWNhbGx5LFxuICAgIC8vIHNjYWxlLCBhbmQgdHJhbnNsYXRlKG9mZnNldENhbnZhc1gsIG9mZnNldENhbnZhc1kpXG4gICAgdGhpcy50cmFuc2Zvcm0gPSBbXG4gICAgICByb3RhdGVBICogc2NhbGUsXG4gICAgICByb3RhdGVCICogc2NhbGUsXG4gICAgICByb3RhdGVDICogc2NhbGUsXG4gICAgICByb3RhdGVEICogc2NhbGUsXG4gICAgICBvZmZzZXRDYW52YXNYIC0gcm90YXRlQSAqIHNjYWxlICogY2VudGVyWCAtIHJvdGF0ZUMgKiBzY2FsZSAqIGNlbnRlclksXG4gICAgICBvZmZzZXRDYW52YXNZIC0gcm90YXRlQiAqIHNjYWxlICogY2VudGVyWCAtIHJvdGF0ZUQgKiBzY2FsZSAqIGNlbnRlcllcbiAgICBdO1xuXG4gICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIHRoaXMuZm9udFNjYWxlID0gc2NhbGU7XG4gIH1cbiAgUGFnZVZpZXdwb3J0LnByb3RvdHlwZSA9IC8qKiBAbGVuZHMgUERGSlMuUGFnZVZpZXdwb3J0LnByb3RvdHlwZSAqLyB7XG4gICAgLyoqXG4gICAgICogQ2xvbmVzIHZpZXdwb3J0IHdpdGggYWRkaXRpb25hbCBwcm9wZXJ0aWVzLlxuICAgICAqIEBwYXJhbSBhcmdzIHtPYmplY3R9IChvcHRpb25hbCkgSWYgc3BlY2lmaWVkLCBtYXkgY29udGFpbiB0aGUgJ3NjYWxlJyBvclxuICAgICAqICdyb3RhdGlvbicgcHJvcGVydGllcyB0byBvdmVycmlkZSB0aGUgY29ycmVzcG9uZGluZyBwcm9wZXJ0aWVzIGluXG4gICAgICogdGhlIGNsb25lZCB2aWV3cG9ydC5cbiAgICAgKiBAcmV0dXJucyB7UERGSlMuUGFnZVZpZXdwb3J0fSBDbG9uZWQgdmlld3BvcnQuXG4gICAgICovXG4gICAgY2xvbmU6IGZ1bmN0aW9uIFBhZ2VWaWV3UG9ydF9jbG9uZShhcmdzKSB7XG4gICAgICBhcmdzID0gYXJncyB8fCB7fTtcbiAgICAgIHZhciBzY2FsZSA9ICdzY2FsZScgaW4gYXJncyA/IGFyZ3Muc2NhbGUgOiB0aGlzLnNjYWxlO1xuICAgICAgdmFyIHJvdGF0aW9uID0gJ3JvdGF0aW9uJyBpbiBhcmdzID8gYXJncy5yb3RhdGlvbiA6IHRoaXMucm90YXRpb247XG4gICAgICByZXR1cm4gbmV3IFBhZ2VWaWV3cG9ydCh0aGlzLnZpZXdCb3guc2xpY2UoKSwgc2NhbGUsIHJvdGF0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vZmZzZXRYLCB0aGlzLm9mZnNldFksIGFyZ3MuZG9udEZsaXApO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgUERGIHBvaW50IHRvIHRoZSB2aWV3cG9ydCBjb29yZGluYXRlcy4gRm9yIGV4YW1wbGVzLCB1c2VmdWwgZm9yXG4gICAgICogY29udmVydGluZyBQREYgbG9jYXRpb24gaW50byBjYW52YXMgcGl4ZWwgY29vcmRpbmF0ZXMuXG4gICAgICogQHBhcmFtIHgge251bWJlcn0gWCBjb29yZGluYXRlLlxuICAgICAqIEBwYXJhbSB5IHtudW1iZXJ9IFkgY29vcmRpbmF0ZS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBPYmplY3QgdGhhdCBjb250YWlucyAneCcgYW5kICd5JyBwcm9wZXJ0aWVzIG9mIHRoZVxuICAgICAqIHBvaW50IGluIHRoZSB2aWV3cG9ydCBjb29yZGluYXRlIHNwYWNlLlxuICAgICAqIEBzZWUge0BsaW5rIGNvbnZlcnRUb1BkZlBvaW50fVxuICAgICAqIEBzZWUge0BsaW5rIGNvbnZlcnRUb1ZpZXdwb3J0UmVjdGFuZ2xlfVxuICAgICAqL1xuICAgIGNvbnZlcnRUb1ZpZXdwb3J0UG9pbnQ6IGZ1bmN0aW9uIFBhZ2VWaWV3cG9ydF9jb252ZXJ0VG9WaWV3cG9ydFBvaW50KHgsIHkpIHtcbiAgICAgIHJldHVybiBVdGlsLmFwcGx5VHJhbnNmb3JtKFt4LCB5XSwgdGhpcy50cmFuc2Zvcm0pO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgUERGIHJlY3RhbmdsZSB0byB0aGUgdmlld3BvcnQgY29vcmRpbmF0ZXMuXG4gICAgICogQHBhcmFtIHJlY3Qge0FycmF5fSB4TWluLCB5TWluLCB4TWF4IGFuZCB5TWF4IGNvb3JkaW5hdGVzLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gQ29udGFpbnMgY29ycmVzcG9uZGluZyBjb29yZGluYXRlcyBvZiB0aGUgcmVjdGFuZ2xlXG4gICAgICogaW4gdGhlIHZpZXdwb3J0IGNvb3JkaW5hdGUgc3BhY2UuXG4gICAgICogQHNlZSB7QGxpbmsgY29udmVydFRvVmlld3BvcnRQb2ludH1cbiAgICAgKi9cbiAgICBjb252ZXJ0VG9WaWV3cG9ydFJlY3RhbmdsZTpcbiAgICAgIGZ1bmN0aW9uIFBhZ2VWaWV3cG9ydF9jb252ZXJ0VG9WaWV3cG9ydFJlY3RhbmdsZShyZWN0KSB7XG4gICAgICB2YXIgdGwgPSBVdGlsLmFwcGx5VHJhbnNmb3JtKFtyZWN0WzBdLCByZWN0WzFdXSwgdGhpcy50cmFuc2Zvcm0pO1xuICAgICAgdmFyIGJyID0gVXRpbC5hcHBseVRyYW5zZm9ybShbcmVjdFsyXSwgcmVjdFszXV0sIHRoaXMudHJhbnNmb3JtKTtcbiAgICAgIHJldHVybiBbdGxbMF0sIHRsWzFdLCBiclswXSwgYnJbMV1dO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgdmlld3BvcnQgY29vcmRpbmF0ZXMgdG8gdGhlIFBERiBsb2NhdGlvbi4gRm9yIGV4YW1wbGVzLCB1c2VmdWxcbiAgICAgKiBmb3IgY29udmVydGluZyBjYW52YXMgcGl4ZWwgbG9jYXRpb24gaW50byBQREYgb25lLlxuICAgICAqIEBwYXJhbSB4IHtudW1iZXJ9IFggY29vcmRpbmF0ZS5cbiAgICAgKiBAcGFyYW0geSB7bnVtYmVyfSBZIGNvb3JkaW5hdGUuXG4gICAgICogQHJldHVybnMge09iamVjdH0gT2JqZWN0IHRoYXQgY29udGFpbnMgJ3gnIGFuZCAneScgcHJvcGVydGllcyBvZiB0aGVcbiAgICAgKiBwb2ludCBpbiB0aGUgUERGIGNvb3JkaW5hdGUgc3BhY2UuXG4gICAgICogQHNlZSB7QGxpbmsgY29udmVydFRvVmlld3BvcnRQb2ludH1cbiAgICAgKi9cbiAgICBjb252ZXJ0VG9QZGZQb2ludDogZnVuY3Rpb24gUGFnZVZpZXdwb3J0X2NvbnZlcnRUb1BkZlBvaW50KHgsIHkpIHtcbiAgICAgIHJldHVybiBVdGlsLmFwcGx5SW52ZXJzZVRyYW5zZm9ybShbeCwgeV0sIHRoaXMudHJhbnNmb3JtKTtcbiAgICB9XG4gIH07XG4gIHJldHVybiBQYWdlVmlld3BvcnQ7XG59KSgpO1xuXG52YXIgUERGU3RyaW5nVHJhbnNsYXRlVGFibGUgPSBbXG4gIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsXG4gIDB4MkQ4LCAweDJDNywgMHgyQzYsIDB4MkQ5LCAweDJERCwgMHgyREIsIDB4MkRBLCAweDJEQywgMCwgMCwgMCwgMCwgMCwgMCwgMCxcbiAgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCxcbiAgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCxcbiAgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCxcbiAgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMHgyMDIyLCAweDIwMjAsIDB4MjAyMSwgMHgyMDI2LCAweDIwMTQsXG4gIDB4MjAxMywgMHgxOTIsIDB4MjA0NCwgMHgyMDM5LCAweDIwM0EsIDB4MjIxMiwgMHgyMDMwLCAweDIwMUUsIDB4MjAxQyxcbiAgMHgyMDFELCAweDIwMTgsIDB4MjAxOSwgMHgyMDFBLCAweDIxMjIsIDB4RkIwMSwgMHhGQjAyLCAweDE0MSwgMHgxNTIsIDB4MTYwLFxuICAweDE3OCwgMHgxN0QsIDB4MTMxLCAweDE0MiwgMHgxNTMsIDB4MTYxLCAweDE3RSwgMCwgMHgyMEFDXG5dO1xuXG5mdW5jdGlvbiBzdHJpbmdUb1BERlN0cmluZyhzdHIpIHtcbiAgdmFyIGksIG4gPSBzdHIubGVuZ3RoLCBzdHJCdWYgPSBbXTtcbiAgaWYgKHN0clswXSA9PT0gJ1xceEZFJyAmJiBzdHJbMV0gPT09ICdcXHhGRicpIHtcbiAgICAvLyBVVEYxNkJFIEJPTVxuICAgIGZvciAoaSA9IDI7IGkgPCBuOyBpICs9IDIpIHtcbiAgICAgIHN0ckJ1Zi5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoXG4gICAgICAgIChzdHIuY2hhckNvZGVBdChpKSA8PCA4KSB8IHN0ci5jaGFyQ29kZUF0KGkgKyAxKSkpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICB2YXIgY29kZSA9IFBERlN0cmluZ1RyYW5zbGF0ZVRhYmxlW3N0ci5jaGFyQ29kZUF0KGkpXTtcbiAgICAgIHN0ckJ1Zi5wdXNoKGNvZGUgPyBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpIDogc3RyLmNoYXJBdChpKSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBzdHJCdWYuam9pbignJyk7XG59XG5cbmZ1bmN0aW9uIHN0cmluZ1RvVVRGOFN0cmluZyhzdHIpIHtcbiAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChlc2NhcGUoc3RyKSk7XG59XG5cbmZ1bmN0aW9uIGlzRW1wdHlPYmoob2JqKSB7XG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGlzQm9vbCh2KSB7XG4gIHJldHVybiB0eXBlb2YgdiA9PT0gJ2Jvb2xlYW4nO1xufVxuXG5mdW5jdGlvbiBpc0ludCh2KSB7XG4gIHJldHVybiB0eXBlb2YgdiA9PT0gJ251bWJlcicgJiYgKCh2IHwgMCkgPT09IHYpO1xufVxuXG5mdW5jdGlvbiBpc051bSh2KSB7XG4gIHJldHVybiB0eXBlb2YgdiA9PT0gJ251bWJlcic7XG59XG5cbmZ1bmN0aW9uIGlzU3RyaW5nKHYpIHtcbiAgcmV0dXJuIHR5cGVvZiB2ID09PSAnc3RyaW5nJztcbn1cblxuZnVuY3Rpb24gaXNOdWxsKHYpIHtcbiAgcmV0dXJuIHYgPT09IG51bGw7XG59XG5cbmZ1bmN0aW9uIGlzTmFtZSh2KSB7XG4gIHJldHVybiB2IGluc3RhbmNlb2YgTmFtZTtcbn1cblxuZnVuY3Rpb24gaXNDbWQodiwgY21kKSB7XG4gIHJldHVybiB2IGluc3RhbmNlb2YgQ21kICYmIChjbWQgPT09IHVuZGVmaW5lZCB8fCB2LmNtZCA9PT0gY21kKTtcbn1cblxuZnVuY3Rpb24gaXNEaWN0KHYsIHR5cGUpIHtcbiAgaWYgKCEodiBpbnN0YW5jZW9mIERpY3QpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICghdHlwZSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHZhciBkaWN0VHlwZSA9IHYuZ2V0KCdUeXBlJyk7XG4gIHJldHVybiBpc05hbWUoZGljdFR5cGUpICYmIGRpY3RUeXBlLm5hbWUgPT09IHR5cGU7XG59XG5cbmZ1bmN0aW9uIGlzQXJyYXkodikge1xuICByZXR1cm4gdiBpbnN0YW5jZW9mIEFycmF5O1xufVxuXG5mdW5jdGlvbiBpc1N0cmVhbSh2KSB7XG4gIHJldHVybiB0eXBlb2YgdiA9PT0gJ29iamVjdCcgJiYgdiAhPT0gbnVsbCAmJiB2LmdldEJ5dGVzICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGlzQXJyYXlCdWZmZXIodikge1xuICByZXR1cm4gdHlwZW9mIHYgPT09ICdvYmplY3QnICYmIHYgIT09IG51bGwgJiYgdi5ieXRlTGVuZ3RoICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGlzUmVmKHYpIHtcbiAgcmV0dXJuIHYgaW5zdGFuY2VvZiBSZWY7XG59XG5cbi8qKlxuICogUHJvbWlzZSBDYXBhYmlsaXR5IG9iamVjdC5cbiAqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBQcm9taXNlQ2FwYWJpbGl0eVxuICogQHByb3BlcnR5IHtQcm9taXNlfSBwcm9taXNlIC0gQSBwcm9taXNlIG9iamVjdC5cbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IHJlc29sdmUgLSBGdWxsZmlsbHMgdGhlIHByb21pc2UuXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9ufSByZWplY3QgLSBSZWplY3RzIHRoZSBwcm9taXNlLlxuICovXG5cbi8qKlxuICogQ3JlYXRlcyBhIHByb21pc2UgY2FwYWJpbGl0eSBvYmplY3QuXG4gKiBAYWxpYXMgUERGSlMuY3JlYXRlUHJvbWlzZUNhcGFiaWxpdHlcbiAqXG4gKiBAcmV0dXJuIHtQcm9taXNlQ2FwYWJpbGl0eX0gQSBjYXBhYmlsaXR5IG9iamVjdCBjb250YWluczpcbiAqIC0gYSBQcm9taXNlLCByZXNvbHZlIGFuZCByZWplY3QgbWV0aG9kcy5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlUHJvbWlzZUNhcGFiaWxpdHkoKSB7XG4gIHZhciBjYXBhYmlsaXR5ID0ge307XG4gIGNhcGFiaWxpdHkucHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICBjYXBhYmlsaXR5LnJlc29sdmUgPSByZXNvbHZlO1xuICAgIGNhcGFiaWxpdHkucmVqZWN0ID0gcmVqZWN0O1xuICB9KTtcbiAgcmV0dXJuIGNhcGFiaWxpdHk7XG59XG5cblBERkpTLmNyZWF0ZVByb21pc2VDYXBhYmlsaXR5ID0gY3JlYXRlUHJvbWlzZUNhcGFiaWxpdHk7XG5cbi8qKlxuICogUG9seWZpbGwgZm9yIFByb21pc2VzOlxuICogVGhlIGZvbGxvd2luZyBwcm9taXNlIGltcGxlbWVudGF0aW9uIHRyaWVzIHRvIGdlbmVyYWxseSBpbXBsZW1lbnQgdGhlXG4gKiBQcm9taXNlL0ErIHNwZWMuIFNvbWUgbm90YWJsZSBkaWZmZXJlbmNlcyBmcm9tIG90aGVyIHByb21pc2UgbGliYXJpZXMgYXJlOlxuICogLSBUaGVyZSBjdXJyZW50bHkgaXNuJ3QgYSBzZXBlcmF0ZSBkZWZlcnJlZCBhbmQgcHJvbWlzZSBvYmplY3QuXG4gKiAtIFVuaGFuZGxlZCByZWplY3Rpb25zIGV2ZW50dWFsbHkgc2hvdyBhbiBlcnJvciBpZiB0aGV5IGFyZW4ndCBoYW5kbGVkLlxuICpcbiAqIEJhc2VkIG9mZiBvZiB0aGUgd29yayBpbjpcbiAqIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTgxMDQ5MFxuICovXG4oZnVuY3Rpb24gUHJvbWlzZUNsb3N1cmUoKSB7XG4gIGlmIChnbG9iYWxTY29wZS5Qcm9taXNlKSB7XG4gICAgLy8gUHJvbWlzZXMgZXhpc3RpbmcgaW4gdGhlIERPTS9Xb3JrZXIsIGNoZWNraW5nIHByZXNlbmNlIG9mIGFsbC9yZXNvbHZlXG4gICAgaWYgKHR5cGVvZiBnbG9iYWxTY29wZS5Qcm9taXNlLmFsbCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZ2xvYmFsU2NvcGUuUHJvbWlzZS5hbGwgPSBmdW5jdGlvbiAoaXRlcmFibGUpIHtcbiAgICAgICAgdmFyIGNvdW50ID0gMCwgcmVzdWx0cyA9IFtdLCByZXNvbHZlLCByZWplY3Q7XG4gICAgICAgIHZhciBwcm9taXNlID0gbmV3IGdsb2JhbFNjb3BlLlByb21pc2UoZnVuY3Rpb24gKHJlc29sdmVfLCByZWplY3RfKSB7XG4gICAgICAgICAgcmVzb2x2ZSA9IHJlc29sdmVfO1xuICAgICAgICAgIHJlamVjdCA9IHJlamVjdF87XG4gICAgICAgIH0pO1xuICAgICAgICBpdGVyYWJsZS5mb3JFYWNoKGZ1bmN0aW9uIChwLCBpKSB7XG4gICAgICAgICAgY291bnQrKztcbiAgICAgICAgICBwLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgICAgcmVzdWx0c1tpXSA9IHJlc3VsdDtcbiAgICAgICAgICAgIGNvdW50LS07XG4gICAgICAgICAgICBpZiAoY291bnQgPT09IDApIHtcbiAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGNvdW50ID09PSAwKSB7XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHRzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICAgIH07XG4gICAgfVxuICAgIGlmICh0eXBlb2YgZ2xvYmFsU2NvcGUuUHJvbWlzZS5yZXNvbHZlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBnbG9iYWxTY29wZS5Qcm9taXNlLnJlc29sdmUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBnbG9iYWxTY29wZS5Qcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTtcbiAgICAgIH07XG4gICAgfVxuICAgIGlmICh0eXBlb2YgZ2xvYmFsU2NvcGUuUHJvbWlzZS5yZWplY3QgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGdsb2JhbFNjb3BlLlByb21pc2UucmVqZWN0ID0gZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICByZXR1cm4gbmV3IGdsb2JhbFNjb3BlLlByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgIHJlamVjdChyZWFzb24pO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgfVxuICAgIGlmICh0eXBlb2YgZ2xvYmFsU2NvcGUuUHJvbWlzZS5wcm90b3R5cGUuY2F0Y2ggIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGdsb2JhbFNjb3BlLlByb21pc2UucHJvdG90eXBlLmNhdGNoID0gZnVuY3Rpb24gKG9uUmVqZWN0KSB7XG4gICAgICAgIHJldHVybiBnbG9iYWxTY29wZS5Qcm9taXNlLnByb3RvdHlwZS50aGVuKHVuZGVmaW5lZCwgb25SZWplY3QpO1xuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG4vLyNpZiAhTU9aQ0VOVFJBTFxuICB2YXIgU1RBVFVTX1BFTkRJTkcgPSAwO1xuICB2YXIgU1RBVFVTX1JFU09MVkVEID0gMTtcbiAgdmFyIFNUQVRVU19SRUpFQ1RFRCA9IDI7XG5cbiAgLy8gSW4gYW4gYXR0ZW1wdCB0byBhdm9pZCBzaWxlbnQgZXhjZXB0aW9ucywgdW5oYW5kbGVkIHJlamVjdGlvbnMgYXJlXG4gIC8vIHRyYWNrZWQgYW5kIGlmIHRoZXkgYXJlbid0IGhhbmRsZWQgaW4gYSBjZXJ0YWluIGFtb3VudCBvZiB0aW1lIGFuXG4gIC8vIGVycm9yIGlzIGxvZ2dlZC5cbiAgdmFyIFJFSkVDVElPTl9USU1FT1VUID0gNTAwO1xuXG4gIHZhciBIYW5kbGVyTWFuYWdlciA9IHtcbiAgICBoYW5kbGVyczogW10sXG4gICAgcnVubmluZzogZmFsc2UsXG4gICAgdW5oYW5kbGVkUmVqZWN0aW9uczogW10sXG4gICAgcGVuZGluZ1JlamVjdGlvbkNoZWNrOiBmYWxzZSxcblxuICAgIHNjaGVkdWxlSGFuZGxlcnM6IGZ1bmN0aW9uIHNjaGVkdWxlSGFuZGxlcnMocHJvbWlzZSkge1xuICAgICAgaWYgKHByb21pc2UuX3N0YXR1cyA9PT0gU1RBVFVTX1BFTkRJTkcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmhhbmRsZXJzID0gdGhpcy5oYW5kbGVycy5jb25jYXQocHJvbWlzZS5faGFuZGxlcnMpO1xuICAgICAgcHJvbWlzZS5faGFuZGxlcnMgPSBbXTtcblxuICAgICAgaWYgKHRoaXMucnVubmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLnJ1bm5pbmcgPSB0cnVlO1xuXG4gICAgICBzZXRUaW1lb3V0KHRoaXMucnVuSGFuZGxlcnMuYmluZCh0aGlzKSwgMCk7XG4gICAgfSxcblxuICAgIHJ1bkhhbmRsZXJzOiBmdW5jdGlvbiBydW5IYW5kbGVycygpIHtcbiAgICAgIHZhciBSVU5fVElNRU9VVCA9IDE7IC8vIG1zXG4gICAgICB2YXIgdGltZW91dEF0ID0gRGF0ZS5ub3coKSArIFJVTl9USU1FT1VUO1xuICAgICAgd2hpbGUgKHRoaXMuaGFuZGxlcnMubGVuZ3RoID4gMCkge1xuICAgICAgICB2YXIgaGFuZGxlciA9IHRoaXMuaGFuZGxlcnMuc2hpZnQoKTtcblxuICAgICAgICB2YXIgbmV4dFN0YXR1cyA9IGhhbmRsZXIudGhpc1Byb21pc2UuX3N0YXR1cztcbiAgICAgICAgdmFyIG5leHRWYWx1ZSA9IGhhbmRsZXIudGhpc1Byb21pc2UuX3ZhbHVlO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKG5leHRTdGF0dXMgPT09IFNUQVRVU19SRVNPTFZFRCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBoYW5kbGVyLm9uUmVzb2x2ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICBuZXh0VmFsdWUgPSBoYW5kbGVyLm9uUmVzb2x2ZShuZXh0VmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGhhbmRsZXIub25SZWplY3QgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgbmV4dFZhbHVlID0gaGFuZGxlci5vblJlamVjdChuZXh0VmFsdWUpO1xuICAgICAgICAgICAgICBuZXh0U3RhdHVzID0gU1RBVFVTX1JFU09MVkVEO1xuXG4gICAgICAgICAgICAgIGlmIChoYW5kbGVyLnRoaXNQcm9taXNlLl91bmhhbmRsZWRSZWplY3Rpb24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZVVuaGFuZGVsZWRSZWplY3Rpb24oaGFuZGxlci50aGlzUHJvbWlzZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgbmV4dFN0YXR1cyA9IFNUQVRVU19SRUpFQ1RFRDtcbiAgICAgICAgICBuZXh0VmFsdWUgPSBleDtcbiAgICAgICAgfVxuXG4gICAgICAgIGhhbmRsZXIubmV4dFByb21pc2UuX3VwZGF0ZVN0YXR1cyhuZXh0U3RhdHVzLCBuZXh0VmFsdWUpO1xuICAgICAgICBpZiAoRGF0ZS5ub3coKSA+PSB0aW1lb3V0QXQpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5oYW5kbGVycy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHNldFRpbWVvdXQodGhpcy5ydW5IYW5kbGVycy5iaW5kKHRoaXMpLCAwKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnJ1bm5pbmcgPSBmYWxzZTtcbiAgICB9LFxuXG4gICAgYWRkVW5oYW5kbGVkUmVqZWN0aW9uOiBmdW5jdGlvbiBhZGRVbmhhbmRsZWRSZWplY3Rpb24ocHJvbWlzZSkge1xuICAgICAgdGhpcy51bmhhbmRsZWRSZWplY3Rpb25zLnB1c2goe1xuICAgICAgICBwcm9taXNlOiBwcm9taXNlLFxuICAgICAgICB0aW1lOiBEYXRlLm5vdygpXG4gICAgICB9KTtcbiAgICAgIHRoaXMuc2NoZWR1bGVSZWplY3Rpb25DaGVjaygpO1xuICAgIH0sXG5cbiAgICByZW1vdmVVbmhhbmRlbGVkUmVqZWN0aW9uOiBmdW5jdGlvbiByZW1vdmVVbmhhbmRlbGVkUmVqZWN0aW9uKHByb21pc2UpIHtcbiAgICAgIHByb21pc2UuX3VuaGFuZGxlZFJlamVjdGlvbiA9IGZhbHNlO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnVuaGFuZGxlZFJlamVjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHRoaXMudW5oYW5kbGVkUmVqZWN0aW9uc1tpXS5wcm9taXNlID09PSBwcm9taXNlKSB7XG4gICAgICAgICAgdGhpcy51bmhhbmRsZWRSZWplY3Rpb25zLnNwbGljZShpKTtcbiAgICAgICAgICBpLS07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgc2NoZWR1bGVSZWplY3Rpb25DaGVjazogZnVuY3Rpb24gc2NoZWR1bGVSZWplY3Rpb25DaGVjaygpIHtcbiAgICAgIGlmICh0aGlzLnBlbmRpbmdSZWplY3Rpb25DaGVjaykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLnBlbmRpbmdSZWplY3Rpb25DaGVjayA9IHRydWU7XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uIHJlamVjdGlvbkNoZWNrKCkge1xuICAgICAgICB0aGlzLnBlbmRpbmdSZWplY3Rpb25DaGVjayA9IGZhbHNlO1xuICAgICAgICB2YXIgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnVuaGFuZGxlZFJlamVjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAobm93IC0gdGhpcy51bmhhbmRsZWRSZWplY3Rpb25zW2ldLnRpbWUgPiBSRUpFQ1RJT05fVElNRU9VVCkge1xuICAgICAgICAgICAgdmFyIHVuaGFuZGxlZCA9IHRoaXMudW5oYW5kbGVkUmVqZWN0aW9uc1tpXS5wcm9taXNlLl92YWx1ZTtcbiAgICAgICAgICAgIHZhciBtc2cgPSAnVW5oYW5kbGVkIHJlamVjdGlvbjogJyArIHVuaGFuZGxlZDtcbiAgICAgICAgICAgIGlmICh1bmhhbmRsZWQuc3RhY2spIHtcbiAgICAgICAgICAgICAgbXNnICs9ICdcXG4nICsgdW5oYW5kbGVkLnN0YWNrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2Fybihtc2cpO1xuICAgICAgICAgICAgdGhpcy51bmhhbmRsZWRSZWplY3Rpb25zLnNwbGljZShpKTtcbiAgICAgICAgICAgIGktLTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudW5oYW5kbGVkUmVqZWN0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICB0aGlzLnNjaGVkdWxlUmVqZWN0aW9uQ2hlY2soKTtcbiAgICAgICAgfVxuICAgICAgfS5iaW5kKHRoaXMpLCBSRUpFQ1RJT05fVElNRU9VVCk7XG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIFByb21pc2UocmVzb2x2ZXIpIHtcbiAgICB0aGlzLl9zdGF0dXMgPSBTVEFUVVNfUEVORElORztcbiAgICB0aGlzLl9oYW5kbGVycyA9IFtdO1xuICAgIHRyeSB7XG4gICAgICByZXNvbHZlci5jYWxsKHRoaXMsIHRoaXMuX3Jlc29sdmUuYmluZCh0aGlzKSwgdGhpcy5fcmVqZWN0LmJpbmQodGhpcykpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRoaXMuX3JlamVjdChlKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEJ1aWxkcyBhIHByb21pc2UgdGhhdCBpcyByZXNvbHZlZCB3aGVuIGFsbCB0aGUgcGFzc2VkIGluIHByb21pc2VzIGFyZVxuICAgKiByZXNvbHZlZC5cbiAgICogQHBhcmFtIHthcnJheX0gYXJyYXkgb2YgZGF0YSBhbmQvb3IgcHJvbWlzZXMgdG8gd2FpdCBmb3IuXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IE5ldyBkZXBlbmRhbnQgcHJvbWlzZS5cbiAgICovXG4gIFByb21pc2UuYWxsID0gZnVuY3Rpb24gUHJvbWlzZV9hbGwocHJvbWlzZXMpIHtcbiAgICB2YXIgcmVzb2x2ZUFsbCwgcmVqZWN0QWxsO1xuICAgIHZhciBkZWZlcnJlZCA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHJlc29sdmVBbGwgPSByZXNvbHZlO1xuICAgICAgcmVqZWN0QWxsID0gcmVqZWN0O1xuICAgIH0pO1xuICAgIHZhciB1bnJlc29sdmVkID0gcHJvbWlzZXMubGVuZ3RoO1xuICAgIHZhciByZXN1bHRzID0gW107XG4gICAgaWYgKHVucmVzb2x2ZWQgPT09IDApIHtcbiAgICAgIHJlc29sdmVBbGwocmVzdWx0cyk7XG4gICAgICByZXR1cm4gZGVmZXJyZWQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlamVjdChyZWFzb24pIHtcbiAgICAgIGlmIChkZWZlcnJlZC5fc3RhdHVzID09PSBTVEFUVVNfUkVKRUNURUQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgcmVqZWN0QWxsKHJlYXNvbik7XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IHByb21pc2VzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgIHZhciBwcm9taXNlID0gcHJvbWlzZXNbaV07XG4gICAgICB2YXIgcmVzb2x2ZSA9IChmdW5jdGlvbihpKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgIGlmIChkZWZlcnJlZC5fc3RhdHVzID09PSBTVEFUVVNfUkVKRUNURUQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzdWx0c1tpXSA9IHZhbHVlO1xuICAgICAgICAgIHVucmVzb2x2ZWQtLTtcbiAgICAgICAgICBpZiAodW5yZXNvbHZlZCA9PT0gMCkge1xuICAgICAgICAgICAgcmVzb2x2ZUFsbChyZXN1bHRzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9KShpKTtcbiAgICAgIGlmIChQcm9taXNlLmlzUHJvbWlzZShwcm9taXNlKSkge1xuICAgICAgICBwcm9taXNlLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc29sdmUocHJvbWlzZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkZWZlcnJlZDtcbiAgfTtcblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZSB2YWx1ZSBpcyBsaWtlbHkgYSBwcm9taXNlIChoYXMgYSAndGhlbicgZnVuY3Rpb24pLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmIHZhbHVlIGlzIHRoZW5hYmxlXG4gICAqL1xuICBQcm9taXNlLmlzUHJvbWlzZSA9IGZ1bmN0aW9uIFByb21pc2VfaXNQcm9taXNlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlICYmIHR5cGVvZiB2YWx1ZS50aGVuID09PSAnZnVuY3Rpb24nO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIHJlc29sdmVkIHByb21pc2VcbiAgICogQHBhcmFtIHZhbHVlIHJlc29sdmUgdmFsdWVcbiAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAqL1xuICBQcm9taXNlLnJlc29sdmUgPSBmdW5jdGlvbiBQcm9taXNlX3Jlc29sdmUodmFsdWUpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIHJlamVjdGVkIHByb21pc2VcbiAgICogQHBhcmFtIHJlYXNvbiByZWplY3Rpb24gdmFsdWVcbiAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAqL1xuICBQcm9taXNlLnJlamVjdCA9IGZ1bmN0aW9uIFByb21pc2VfcmVqZWN0KHJlYXNvbikge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7IHJlamVjdChyZWFzb24pOyB9KTtcbiAgfTtcblxuICBQcm9taXNlLnByb3RvdHlwZSA9IHtcbiAgICBfc3RhdHVzOiBudWxsLFxuICAgIF92YWx1ZTogbnVsbCxcbiAgICBfaGFuZGxlcnM6IG51bGwsXG4gICAgX3VuaGFuZGxlZFJlamVjdGlvbjogbnVsbCxcblxuICAgIF91cGRhdGVTdGF0dXM6IGZ1bmN0aW9uIFByb21pc2VfX3VwZGF0ZVN0YXR1cyhzdGF0dXMsIHZhbHVlKSB7XG4gICAgICBpZiAodGhpcy5fc3RhdHVzID09PSBTVEFUVVNfUkVTT0xWRUQgfHxcbiAgICAgICAgICB0aGlzLl9zdGF0dXMgPT09IFNUQVRVU19SRUpFQ1RFRCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGF0dXMgPT09IFNUQVRVU19SRVNPTFZFRCAmJlxuICAgICAgICAgIFByb21pc2UuaXNQcm9taXNlKHZhbHVlKSkge1xuICAgICAgICB2YWx1ZS50aGVuKHRoaXMuX3VwZGF0ZVN0YXR1cy5iaW5kKHRoaXMsIFNUQVRVU19SRVNPTFZFRCksXG4gICAgICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlU3RhdHVzLmJpbmQodGhpcywgU1RBVFVTX1JFSkVDVEVEKSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fc3RhdHVzID0gc3RhdHVzO1xuICAgICAgdGhpcy5fdmFsdWUgPSB2YWx1ZTtcblxuICAgICAgaWYgKHN0YXR1cyA9PT0gU1RBVFVTX1JFSkVDVEVEICYmIHRoaXMuX2hhbmRsZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aGlzLl91bmhhbmRsZWRSZWplY3Rpb24gPSB0cnVlO1xuICAgICAgICBIYW5kbGVyTWFuYWdlci5hZGRVbmhhbmRsZWRSZWplY3Rpb24odGhpcyk7XG4gICAgICB9XG5cbiAgICAgIEhhbmRsZXJNYW5hZ2VyLnNjaGVkdWxlSGFuZGxlcnModGhpcyk7XG4gICAgfSxcblxuICAgIF9yZXNvbHZlOiBmdW5jdGlvbiBQcm9taXNlX3Jlc29sdmUodmFsdWUpIHtcbiAgICAgIHRoaXMuX3VwZGF0ZVN0YXR1cyhTVEFUVVNfUkVTT0xWRUQsIHZhbHVlKTtcbiAgICB9LFxuXG4gICAgX3JlamVjdDogZnVuY3Rpb24gUHJvbWlzZV9yZWplY3QocmVhc29uKSB7XG4gICAgICB0aGlzLl91cGRhdGVTdGF0dXMoU1RBVFVTX1JFSkVDVEVELCByZWFzb24pO1xuICAgIH0sXG5cbiAgICB0aGVuOiBmdW5jdGlvbiBQcm9taXNlX3RoZW4ob25SZXNvbHZlLCBvblJlamVjdCkge1xuICAgICAgdmFyIG5leHRQcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICB0aGlzLnJlc29sdmUgPSByZXNvbHZlO1xuICAgICAgICB0aGlzLnJlamVjdCA9IHJlamVjdDtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5faGFuZGxlcnMucHVzaCh7XG4gICAgICAgIHRoaXNQcm9taXNlOiB0aGlzLFxuICAgICAgICBvblJlc29sdmU6IG9uUmVzb2x2ZSxcbiAgICAgICAgb25SZWplY3Q6IG9uUmVqZWN0LFxuICAgICAgICBuZXh0UHJvbWlzZTogbmV4dFByb21pc2VcbiAgICAgIH0pO1xuICAgICAgSGFuZGxlck1hbmFnZXIuc2NoZWR1bGVIYW5kbGVycyh0aGlzKTtcbiAgICAgIHJldHVybiBuZXh0UHJvbWlzZTtcbiAgICB9LFxuXG4gICAgY2F0Y2g6IGZ1bmN0aW9uIFByb21pc2VfY2F0Y2gob25SZWplY3QpIHtcbiAgICAgIHJldHVybiB0aGlzLnRoZW4odW5kZWZpbmVkLCBvblJlamVjdCk7XG4gICAgfVxuICB9O1xuXG4gIGdsb2JhbFNjb3BlLlByb21pc2UgPSBQcm9taXNlO1xuLy8jZWxzZVxuLy90aHJvdyBuZXcgRXJyb3IoJ0RPTSBQcm9taXNlIGlzIG5vdCBwcmVzZW50Jyk7XG4vLyNlbmRpZlxufSkoKTtcblxudmFyIFN0YXRUaW1lciA9IChmdW5jdGlvbiBTdGF0VGltZXJDbG9zdXJlKCkge1xuICBmdW5jdGlvbiBycGFkKHN0ciwgcGFkLCBsZW5ndGgpIHtcbiAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IGxlbmd0aCkge1xuICAgICAgc3RyICs9IHBhZDtcbiAgICB9XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxuICBmdW5jdGlvbiBTdGF0VGltZXIoKSB7XG4gICAgdGhpcy5zdGFydGVkID0ge307XG4gICAgdGhpcy50aW1lcyA9IFtdO1xuICAgIHRoaXMuZW5hYmxlZCA9IHRydWU7XG4gIH1cbiAgU3RhdFRpbWVyLnByb3RvdHlwZSA9IHtcbiAgICB0aW1lOiBmdW5jdGlvbiBTdGF0VGltZXJfdGltZShuYW1lKSB7XG4gICAgICBpZiAoIXRoaXMuZW5hYmxlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAobmFtZSBpbiB0aGlzLnN0YXJ0ZWQpIHtcbiAgICAgICAgd2FybignVGltZXIgaXMgYWxyZWFkeSBydW5uaW5nIGZvciAnICsgbmFtZSk7XG4gICAgICB9XG4gICAgICB0aGlzLnN0YXJ0ZWRbbmFtZV0gPSBEYXRlLm5vdygpO1xuICAgIH0sXG4gICAgdGltZUVuZDogZnVuY3Rpb24gU3RhdFRpbWVyX3RpbWVFbmQobmFtZSkge1xuICAgICAgaWYgKCF0aGlzLmVuYWJsZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCEobmFtZSBpbiB0aGlzLnN0YXJ0ZWQpKSB7XG4gICAgICAgIHdhcm4oJ1RpbWVyIGhhcyBub3QgYmVlbiBzdGFydGVkIGZvciAnICsgbmFtZSk7XG4gICAgICB9XG4gICAgICB0aGlzLnRpbWVzLnB1c2goe1xuICAgICAgICAnbmFtZSc6IG5hbWUsXG4gICAgICAgICdzdGFydCc6IHRoaXMuc3RhcnRlZFtuYW1lXSxcbiAgICAgICAgJ2VuZCc6IERhdGUubm93KClcbiAgICAgIH0pO1xuICAgICAgLy8gUmVtb3ZlIHRpbWVyIGZyb20gc3RhcnRlZCBzbyBpdCBjYW4gYmUgY2FsbGVkIGFnYWluLlxuICAgICAgZGVsZXRlIHRoaXMuc3RhcnRlZFtuYW1lXTtcbiAgICB9LFxuICAgIHRvU3RyaW5nOiBmdW5jdGlvbiBTdGF0VGltZXJfdG9TdHJpbmcoKSB7XG4gICAgICB2YXIgaSwgaWk7XG4gICAgICB2YXIgdGltZXMgPSB0aGlzLnRpbWVzO1xuICAgICAgdmFyIG91dCA9ICcnO1xuICAgICAgLy8gRmluZCB0aGUgbG9uZ2VzdCBuYW1lIGZvciBwYWRkaW5nIHB1cnBvc2VzLlxuICAgICAgdmFyIGxvbmdlc3QgPSAwO1xuICAgICAgZm9yIChpID0gMCwgaWkgPSB0aW1lcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICAgIHZhciBuYW1lID0gdGltZXNbaV1bJ25hbWUnXTtcbiAgICAgICAgaWYgKG5hbWUubGVuZ3RoID4gbG9uZ2VzdCkge1xuICAgICAgICAgIGxvbmdlc3QgPSBuYW1lLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZm9yIChpID0gMCwgaWkgPSB0aW1lcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICAgIHZhciBzcGFuID0gdGltZXNbaV07XG4gICAgICAgIHZhciBkdXJhdGlvbiA9IHNwYW4uZW5kIC0gc3Bhbi5zdGFydDtcbiAgICAgICAgb3V0ICs9IHJwYWQoc3BhblsnbmFtZSddLCAnICcsIGxvbmdlc3QpICsgJyAnICsgZHVyYXRpb24gKyAnbXNcXG4nO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG4gIH07XG4gIHJldHVybiBTdGF0VGltZXI7XG59KSgpO1xuXG5QREZKUy5jcmVhdGVCbG9iID0gZnVuY3Rpb24gY3JlYXRlQmxvYihkYXRhLCBjb250ZW50VHlwZSkge1xuICBpZiAodHlwZW9mIEJsb2IgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIG5ldyBCbG9iKFtkYXRhXSwgeyB0eXBlOiBjb250ZW50VHlwZSB9KTtcbiAgfVxuICAvLyBCbG9iIGJ1aWxkZXIgaXMgZGVwcmVjYXRlZCBpbiBGRjE0IGFuZCByZW1vdmVkIGluIEZGMTguXG4gIHZhciBiYiA9IG5ldyBNb3pCbG9iQnVpbGRlcigpO1xuICBiYi5hcHBlbmQoZGF0YSk7XG4gIHJldHVybiBiYi5nZXRCbG9iKGNvbnRlbnRUeXBlKTtcbn07XG5cblBERkpTLmNyZWF0ZU9iamVjdFVSTCA9IChmdW5jdGlvbiBjcmVhdGVPYmplY3RVUkxDbG9zdXJlKCkge1xuICAvLyBCbG9iL2NyZWF0ZU9iamVjdFVSTCBpcyBub3QgYXZhaWxhYmxlLCBmYWxsaW5nIGJhY2sgdG8gZGF0YSBzY2hlbWEuXG4gIHZhciBkaWdpdHMgPVxuICAgICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvPSc7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIGNyZWF0ZU9iamVjdFVSTChkYXRhLCBjb250ZW50VHlwZSkge1xuICAgIGlmICghUERGSlMuZGlzYWJsZUNyZWF0ZU9iamVjdFVSTCAmJlxuICAgICAgICB0eXBlb2YgVVJMICE9PSAndW5kZWZpbmVkJyAmJiBVUkwuY3JlYXRlT2JqZWN0VVJMKSB7XG4gICAgICB2YXIgYmxvYiA9IFBERkpTLmNyZWF0ZUJsb2IoZGF0YSwgY29udGVudFR5cGUpO1xuICAgICAgcmV0dXJuIFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XG4gICAgfVxuXG4gICAgdmFyIGJ1ZmZlciA9ICdkYXRhOicgKyBjb250ZW50VHlwZSArICc7YmFzZTY0LCc7XG4gICAgZm9yICh2YXIgaSA9IDAsIGlpID0gZGF0YS5sZW5ndGg7IGkgPCBpaTsgaSArPSAzKSB7XG4gICAgICB2YXIgYjEgPSBkYXRhW2ldICYgMHhGRjtcbiAgICAgIHZhciBiMiA9IGRhdGFbaSArIDFdICYgMHhGRjtcbiAgICAgIHZhciBiMyA9IGRhdGFbaSArIDJdICYgMHhGRjtcbiAgICAgIHZhciBkMSA9IGIxID4+IDIsIGQyID0gKChiMSAmIDMpIDw8IDQpIHwgKGIyID4+IDQpO1xuICAgICAgdmFyIGQzID0gaSArIDEgPCBpaSA/ICgoYjIgJiAweEYpIDw8IDIpIHwgKGIzID4+IDYpIDogNjQ7XG4gICAgICB2YXIgZDQgPSBpICsgMiA8IGlpID8gKGIzICYgMHgzRikgOiA2NDtcbiAgICAgIGJ1ZmZlciArPSBkaWdpdHNbZDFdICsgZGlnaXRzW2QyXSArIGRpZ2l0c1tkM10gKyBkaWdpdHNbZDRdO1xuICAgIH1cbiAgICByZXR1cm4gYnVmZmVyO1xuICB9O1xufSkoKTtcblxuZnVuY3Rpb24gTWVzc2FnZUhhbmRsZXIobmFtZSwgY29tT2JqKSB7XG4gIHRoaXMubmFtZSA9IG5hbWU7XG4gIHRoaXMuY29tT2JqID0gY29tT2JqO1xuICB0aGlzLmNhbGxiYWNrSW5kZXggPSAxO1xuICB0aGlzLnBvc3RNZXNzYWdlVHJhbnNmZXJzID0gdHJ1ZTtcbiAgdmFyIGNhbGxiYWNrc0NhcGFiaWxpdGllcyA9IHRoaXMuY2FsbGJhY2tzQ2FwYWJpbGl0aWVzID0ge307XG4gIHZhciBhaCA9IHRoaXMuYWN0aW9uSGFuZGxlciA9IHt9O1xuXG4gIGFoWydjb25zb2xlX2xvZyddID0gW2Z1bmN0aW9uIGFoQ29uc29sZUxvZyhkYXRhKSB7XG4gICAgY29uc29sZS5sb2cuYXBwbHkoY29uc29sZSwgZGF0YSk7XG4gIH1dO1xuICBhaFsnY29uc29sZV9lcnJvciddID0gW2Z1bmN0aW9uIGFoQ29uc29sZUVycm9yKGRhdGEpIHtcbiAgICBjb25zb2xlLmVycm9yLmFwcGx5KGNvbnNvbGUsIGRhdGEpO1xuICB9XTtcbiAgYWhbJ191bnN1cHBvcnRlZF9mZWF0dXJlJ10gPSBbZnVuY3Rpb24gYWhfdW5zdXBwb3J0ZWRGZWF0dXJlKGRhdGEpIHtcbiAgICBVbnN1cHBvcnRlZE1hbmFnZXIubm90aWZ5KGRhdGEpO1xuICB9XTtcblxuICBjb21PYmoub25tZXNzYWdlID0gZnVuY3Rpb24gbWVzc2FnZUhhbmRsZXJDb21PYmpPbk1lc3NhZ2UoZXZlbnQpIHtcbiAgICB2YXIgZGF0YSA9IGV2ZW50LmRhdGE7XG4gICAgaWYgKGRhdGEuaXNSZXBseSkge1xuICAgICAgdmFyIGNhbGxiYWNrSWQgPSBkYXRhLmNhbGxiYWNrSWQ7XG4gICAgICBpZiAoZGF0YS5jYWxsYmFja0lkIGluIGNhbGxiYWNrc0NhcGFiaWxpdGllcykge1xuICAgICAgICB2YXIgY2FsbGJhY2sgPSBjYWxsYmFja3NDYXBhYmlsaXRpZXNbY2FsbGJhY2tJZF07XG4gICAgICAgIGRlbGV0ZSBjYWxsYmFja3NDYXBhYmlsaXRpZXNbY2FsbGJhY2tJZF07XG4gICAgICAgIGlmICgnZXJyb3InIGluIGRhdGEpIHtcbiAgICAgICAgICBjYWxsYmFjay5yZWplY3QoZGF0YS5lcnJvcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2FsbGJhY2sucmVzb2x2ZShkYXRhLmRhdGEpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlcnJvcignQ2Fubm90IHJlc29sdmUgY2FsbGJhY2sgJyArIGNhbGxiYWNrSWQpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZGF0YS5hY3Rpb24gaW4gYWgpIHtcbiAgICAgIHZhciBhY3Rpb24gPSBhaFtkYXRhLmFjdGlvbl07XG4gICAgICBpZiAoZGF0YS5jYWxsYmFja0lkKSB7XG4gICAgICAgIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBhY3Rpb25bMF0uY2FsbChhY3Rpb25bMV0sIGRhdGEuZGF0YSk7XG4gICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgIGNvbU9iai5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICBpc1JlcGx5OiB0cnVlLFxuICAgICAgICAgICAgY2FsbGJhY2tJZDogZGF0YS5jYWxsYmFja0lkLFxuICAgICAgICAgICAgZGF0YTogcmVzdWx0XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgICBjb21PYmoucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgaXNSZXBseTogdHJ1ZSxcbiAgICAgICAgICAgIGNhbGxiYWNrSWQ6IGRhdGEuY2FsbGJhY2tJZCxcbiAgICAgICAgICAgIGVycm9yOiByZWFzb25cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhY3Rpb25bMF0uY2FsbChhY3Rpb25bMV0sIGRhdGEuZGF0YSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVycm9yKCdVbmtub3duIGFjdGlvbiBmcm9tIHdvcmtlcjogJyArIGRhdGEuYWN0aW9uKTtcbiAgICB9XG4gIH07XG59XG5cbk1lc3NhZ2VIYW5kbGVyLnByb3RvdHlwZSA9IHtcbiAgb246IGZ1bmN0aW9uIG1lc3NhZ2VIYW5kbGVyT24oYWN0aW9uTmFtZSwgaGFuZGxlciwgc2NvcGUpIHtcbiAgICB2YXIgYWggPSB0aGlzLmFjdGlvbkhhbmRsZXI7XG4gICAgaWYgKGFoW2FjdGlvbk5hbWVdKSB7XG4gICAgICBlcnJvcignVGhlcmUgaXMgYWxyZWFkeSBhbiBhY3Rpb25OYW1lIGNhbGxlZCBcIicgKyBhY3Rpb25OYW1lICsgJ1wiJyk7XG4gICAgfVxuICAgIGFoW2FjdGlvbk5hbWVdID0gW2hhbmRsZXIsIHNjb3BlXTtcbiAgfSxcbiAgLyoqXG4gICAqIFNlbmRzIGEgbWVzc2FnZSB0byB0aGUgY29tT2JqIHRvIGludm9rZSB0aGUgYWN0aW9uIHdpdGggdGhlIHN1cHBsaWVkIGRhdGEuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhY3Rpb25OYW1lIEFjdGlvbiB0byBjYWxsLlxuICAgKiBAcGFyYW0ge0pTT059IGRhdGEgSlNPTiBkYXRhIHRvIHNlbmQuXG4gICAqIEBwYXJhbSB7QXJyYXl9IFt0cmFuc2ZlcnNdIE9wdGlvbmFsIGxpc3Qgb2YgdHJhbnNmZXJzL0FycmF5QnVmZmVyc1xuICAgKi9cbiAgc2VuZDogZnVuY3Rpb24gbWVzc2FnZUhhbmRsZXJTZW5kKGFjdGlvbk5hbWUsIGRhdGEsIHRyYW5zZmVycykge1xuICAgIHZhciBtZXNzYWdlID0ge1xuICAgICAgYWN0aW9uOiBhY3Rpb25OYW1lLFxuICAgICAgZGF0YTogZGF0YVxuICAgIH07XG4gICAgdGhpcy5wb3N0TWVzc2FnZShtZXNzYWdlLCB0cmFuc2ZlcnMpO1xuICB9LFxuICAvKipcbiAgICogU2VuZHMgYSBtZXNzYWdlIHRvIHRoZSBjb21PYmogdG8gaW52b2tlIHRoZSBhY3Rpb24gd2l0aCB0aGUgc3VwcGxpZWQgZGF0YS5cbiAgICogRXhwZWN0cyB0aGF0IG90aGVyIHNpZGUgd2lsbCBjYWxsYmFjayB3aXRoIHRoZSByZXNwb25zZS5cbiAgICogQHBhcmFtIHtTdHJpbmd9IGFjdGlvbk5hbWUgQWN0aW9uIHRvIGNhbGwuXG4gICAqIEBwYXJhbSB7SlNPTn0gZGF0YSBKU09OIGRhdGEgdG8gc2VuZC5cbiAgICogQHBhcmFtIHtBcnJheX0gW3RyYW5zZmVyc10gT3B0aW9uYWwgbGlzdCBvZiB0cmFuc2ZlcnMvQXJyYXlCdWZmZXJzLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gUHJvbWlzZSB0byBiZSByZXNvbHZlZCB3aXRoIHJlc3BvbnNlIGRhdGEuXG4gICAqL1xuICBzZW5kV2l0aFByb21pc2U6XG4gICAgZnVuY3Rpb24gbWVzc2FnZUhhbmRsZXJTZW5kV2l0aFByb21pc2UoYWN0aW9uTmFtZSwgZGF0YSwgdHJhbnNmZXJzKSB7XG4gICAgdmFyIGNhbGxiYWNrSWQgPSB0aGlzLmNhbGxiYWNrSW5kZXgrKztcbiAgICB2YXIgbWVzc2FnZSA9IHtcbiAgICAgIGFjdGlvbjogYWN0aW9uTmFtZSxcbiAgICAgIGRhdGE6IGRhdGEsXG4gICAgICBjYWxsYmFja0lkOiBjYWxsYmFja0lkXG4gICAgfTtcbiAgICB2YXIgY2FwYWJpbGl0eSA9IGNyZWF0ZVByb21pc2VDYXBhYmlsaXR5KCk7XG4gICAgdGhpcy5jYWxsYmFja3NDYXBhYmlsaXRpZXNbY2FsbGJhY2tJZF0gPSBjYXBhYmlsaXR5O1xuICAgIHRyeSB7XG4gICAgICB0aGlzLnBvc3RNZXNzYWdlKG1lc3NhZ2UsIHRyYW5zZmVycyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY2FwYWJpbGl0eS5yZWplY3QoZSk7XG4gICAgfVxuICAgIHJldHVybiBjYXBhYmlsaXR5LnByb21pc2U7XG4gIH0sXG4gIC8qKlxuICAgKiBTZW5kcyByYXcgbWVzc2FnZSB0byB0aGUgY29tT2JqLlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0gbWVzc2FnZSB7T2JqZWN0fSBSYXcgbWVzc2FnZS5cbiAgICogQHBhcmFtIHRyYW5zZmVycyBMaXN0IG9mIHRyYW5zZmVycy9BcnJheUJ1ZmZlcnMsIG9yIHVuZGVmaW5lZC5cbiAgICovXG4gIHBvc3RNZXNzYWdlOiBmdW5jdGlvbiAobWVzc2FnZSwgdHJhbnNmZXJzKSB7XG4gICAgaWYgKHRyYW5zZmVycyAmJiB0aGlzLnBvc3RNZXNzYWdlVHJhbnNmZXJzKSB7XG4gICAgICB0aGlzLmNvbU9iai5wb3N0TWVzc2FnZShtZXNzYWdlLCB0cmFuc2ZlcnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNvbU9iai5wb3N0TWVzc2FnZShtZXNzYWdlKTtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBtb2R1bGVUeXBlID0gdHlwZW9mIG1vZHVsZTtcbmlmICgobW9kdWxlVHlwZSAhPT0gJ3VuZGVmaW5lZCcpICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBKcHhJbWFnZTtcbn1cblxuZnVuY3Rpb24gbG9hZEpwZWdTdHJlYW0oaWQsIGltYWdlVXJsLCBvYmpzKSB7XG4gIHZhciBpbWcgPSBuZXcgSW1hZ2UoKTtcbiAgaW1nLm9ubG9hZCA9IChmdW5jdGlvbiBsb2FkSnBlZ1N0cmVhbV9vbmxvYWRDbG9zdXJlKCkge1xuICAgIG9ianMucmVzb2x2ZShpZCwgaW1nKTtcbiAgfSk7XG4gIGltZy5vbmVycm9yID0gKGZ1bmN0aW9uIGxvYWRKcGVnU3RyZWFtX29uZXJyb3JDbG9zdXJlKCkge1xuICAgIG9ianMucmVzb2x2ZShpZCwgbnVsbCk7XG4gICAgd2FybignRXJyb3IgZHVyaW5nIEpQRUcgaW1hZ2UgbG9hZGluZycpO1xuICB9KTtcbiAgaW1nLnNyYyA9IGltYWdlVXJsO1xufSIsIid1c2Ugc3RyaWN0JztcblxuLy8gY29tcGFyZSBhbmQgaXNCdWZmZXIgdGFrZW4gZnJvbSBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9ibG9iLzY4MGU5ZTVlNDg4ZjIyYWFjMjc1OTlhNTdkYzg0NGE2MzE1OTI4ZGQvaW5kZXguanNcbi8vIG9yaWdpbmFsIG5vdGljZTpcblxuLyohXG4gKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci5cbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8ZmVyb3NzQGZlcm9zcy5vcmc+IDxodHRwOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuZnVuY3Rpb24gY29tcGFyZShhLCBiKSB7XG4gIGlmIChhID09PSBiKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICB2YXIgeCA9IGEubGVuZ3RoO1xuICB2YXIgeSA9IGIubGVuZ3RoO1xuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBNYXRoLm1pbih4LCB5KTsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgICAgIHggPSBhW2ldO1xuICAgICAgeSA9IGJbaV07XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHtcbiAgICByZXR1cm4gLTE7XG4gIH1cbiAgaWYgKHkgPCB4KSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5mdW5jdGlvbiBpc0J1ZmZlcihiKSB7XG4gIGlmIChnbG9iYWwuQnVmZmVyICYmIHR5cGVvZiBnbG9iYWwuQnVmZmVyLmlzQnVmZmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGdsb2JhbC5CdWZmZXIuaXNCdWZmZXIoYik7XG4gIH1cbiAgcmV0dXJuICEhKGIgIT0gbnVsbCAmJiBiLl9pc0J1ZmZlcik7XG59XG5cbi8vIGJhc2VkIG9uIG5vZGUgYXNzZXJ0LCBvcmlnaW5hbCBub3RpY2U6XG5cbi8vIGh0dHA6Ly93aWtpLmNvbW1vbmpzLm9yZy93aWtpL1VuaXRfVGVzdGluZy8xLjBcbi8vXG4vLyBUSElTIElTIE5PVCBURVNURUQgTk9SIExJS0VMWSBUTyBXT1JLIE9VVFNJREUgVjghXG4vL1xuLy8gT3JpZ2luYWxseSBmcm9tIG5hcndoYWwuanMgKGh0dHA6Ly9uYXJ3aGFsanMub3JnKVxuLy8gQ29weXJpZ2h0IChjKSAyMDA5IFRob21hcyBSb2JpbnNvbiA8Mjgwbm9ydGguY29tPlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlICdTb2Z0d2FyZScpLCB0b1xuLy8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGVcbi8vIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vclxuLy8gc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCAnQVMgSVMnLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU5cbi8vIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT05cbi8vIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwvJyk7XG52YXIgaGFzT3duID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBwU2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG52YXIgZnVuY3Rpb25zSGF2ZU5hbWVzID0gKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGZvbygpIHt9Lm5hbWUgPT09ICdmb28nO1xufSgpKTtcbmZ1bmN0aW9uIHBUb1N0cmluZyAob2JqKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKTtcbn1cbmZ1bmN0aW9uIGlzVmlldyhhcnJidWYpIHtcbiAgaWYgKGlzQnVmZmVyKGFycmJ1ZikpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHR5cGVvZiBnbG9iYWwuQXJyYXlCdWZmZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlci5pc1ZpZXcgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gQXJyYXlCdWZmZXIuaXNWaWV3KGFycmJ1Zik7XG4gIH1cbiAgaWYgKCFhcnJidWYpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGFycmJ1ZiBpbnN0YW5jZW9mIERhdGFWaWV3KSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKGFycmJ1Zi5idWZmZXIgJiYgYXJyYnVmLmJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuLy8gMS4gVGhlIGFzc2VydCBtb2R1bGUgcHJvdmlkZXMgZnVuY3Rpb25zIHRoYXQgdGhyb3dcbi8vIEFzc2VydGlvbkVycm9yJ3Mgd2hlbiBwYXJ0aWN1bGFyIGNvbmRpdGlvbnMgYXJlIG5vdCBtZXQuIFRoZVxuLy8gYXNzZXJ0IG1vZHVsZSBtdXN0IGNvbmZvcm0gdG8gdGhlIGZvbGxvd2luZyBpbnRlcmZhY2UuXG5cbnZhciBhc3NlcnQgPSBtb2R1bGUuZXhwb3J0cyA9IG9rO1xuXG4vLyAyLiBUaGUgQXNzZXJ0aW9uRXJyb3IgaXMgZGVmaW5lZCBpbiBhc3NlcnQuXG4vLyBuZXcgYXNzZXJ0LkFzc2VydGlvbkVycm9yKHsgbWVzc2FnZTogbWVzc2FnZSxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3R1YWw6IGFjdHVhbCxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHBlY3RlZDogZXhwZWN0ZWQgfSlcblxudmFyIHJlZ2V4ID0gL1xccypmdW5jdGlvblxccysoW15cXChcXHNdKilcXHMqLztcbi8vIGJhc2VkIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS9samhhcmIvZnVuY3Rpb24ucHJvdG90eXBlLm5hbWUvYmxvYi9hZGVlZWVjOGJmY2M2MDY4YjE4N2Q3ZDlmYjNkNWJiMWQzYTMwODk5L2ltcGxlbWVudGF0aW9uLmpzXG5mdW5jdGlvbiBnZXROYW1lKGZ1bmMpIHtcbiAgaWYgKCF1dGlsLmlzRnVuY3Rpb24oZnVuYykpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGZ1bmN0aW9uc0hhdmVOYW1lcykge1xuICAgIHJldHVybiBmdW5jLm5hbWU7XG4gIH1cbiAgdmFyIHN0ciA9IGZ1bmMudG9TdHJpbmcoKTtcbiAgdmFyIG1hdGNoID0gc3RyLm1hdGNoKHJlZ2V4KTtcbiAgcmV0dXJuIG1hdGNoICYmIG1hdGNoWzFdO1xufVxuYXNzZXJ0LkFzc2VydGlvbkVycm9yID0gZnVuY3Rpb24gQXNzZXJ0aW9uRXJyb3Iob3B0aW9ucykge1xuICB0aGlzLm5hbWUgPSAnQXNzZXJ0aW9uRXJyb3InO1xuICB0aGlzLmFjdHVhbCA9IG9wdGlvbnMuYWN0dWFsO1xuICB0aGlzLmV4cGVjdGVkID0gb3B0aW9ucy5leHBlY3RlZDtcbiAgdGhpcy5vcGVyYXRvciA9IG9wdGlvbnMub3BlcmF0b3I7XG4gIGlmIChvcHRpb25zLm1lc3NhZ2UpIHtcbiAgICB0aGlzLm1lc3NhZ2UgPSBvcHRpb25zLm1lc3NhZ2U7XG4gICAgdGhpcy5nZW5lcmF0ZWRNZXNzYWdlID0gZmFsc2U7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5tZXNzYWdlID0gZ2V0TWVzc2FnZSh0aGlzKTtcbiAgICB0aGlzLmdlbmVyYXRlZE1lc3NhZ2UgPSB0cnVlO1xuICB9XG4gIHZhciBzdGFja1N0YXJ0RnVuY3Rpb24gPSBvcHRpb25zLnN0YWNrU3RhcnRGdW5jdGlvbiB8fCBmYWlsO1xuICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIHtcbiAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBzdGFja1N0YXJ0RnVuY3Rpb24pO1xuICB9IGVsc2Uge1xuICAgIC8vIG5vbiB2OCBicm93c2VycyBzbyB3ZSBjYW4gaGF2ZSBhIHN0YWNrdHJhY2VcbiAgICB2YXIgZXJyID0gbmV3IEVycm9yKCk7XG4gICAgaWYgKGVyci5zdGFjaykge1xuICAgICAgdmFyIG91dCA9IGVyci5zdGFjaztcblxuICAgICAgLy8gdHJ5IHRvIHN0cmlwIHVzZWxlc3MgZnJhbWVzXG4gICAgICB2YXIgZm5fbmFtZSA9IGdldE5hbWUoc3RhY2tTdGFydEZ1bmN0aW9uKTtcbiAgICAgIHZhciBpZHggPSBvdXQuaW5kZXhPZignXFxuJyArIGZuX25hbWUpO1xuICAgICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICAgIC8vIG9uY2Ugd2UgaGF2ZSBsb2NhdGVkIHRoZSBmdW5jdGlvbiBmcmFtZVxuICAgICAgICAvLyB3ZSBuZWVkIHRvIHN0cmlwIG91dCBldmVyeXRoaW5nIGJlZm9yZSBpdCAoYW5kIGl0cyBsaW5lKVxuICAgICAgICB2YXIgbmV4dF9saW5lID0gb3V0LmluZGV4T2YoJ1xcbicsIGlkeCArIDEpO1xuICAgICAgICBvdXQgPSBvdXQuc3Vic3RyaW5nKG5leHRfbGluZSArIDEpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnN0YWNrID0gb3V0O1xuICAgIH1cbiAgfVxufTtcblxuLy8gYXNzZXJ0LkFzc2VydGlvbkVycm9yIGluc3RhbmNlb2YgRXJyb3JcbnV0aWwuaW5oZXJpdHMoYXNzZXJ0LkFzc2VydGlvbkVycm9yLCBFcnJvcik7XG5cbmZ1bmN0aW9uIHRydW5jYXRlKHMsIG4pIHtcbiAgaWYgKHR5cGVvZiBzID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBzLmxlbmd0aCA8IG4gPyBzIDogcy5zbGljZSgwLCBuKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcztcbiAgfVxufVxuZnVuY3Rpb24gaW5zcGVjdChzb21ldGhpbmcpIHtcbiAgaWYgKGZ1bmN0aW9uc0hhdmVOYW1lcyB8fCAhdXRpbC5pc0Z1bmN0aW9uKHNvbWV0aGluZykpIHtcbiAgICByZXR1cm4gdXRpbC5pbnNwZWN0KHNvbWV0aGluZyk7XG4gIH1cbiAgdmFyIHJhd25hbWUgPSBnZXROYW1lKHNvbWV0aGluZyk7XG4gIHZhciBuYW1lID0gcmF3bmFtZSA/ICc6ICcgKyByYXduYW1lIDogJyc7XG4gIHJldHVybiAnW0Z1bmN0aW9uJyArICBuYW1lICsgJ10nO1xufVxuZnVuY3Rpb24gZ2V0TWVzc2FnZShzZWxmKSB7XG4gIHJldHVybiB0cnVuY2F0ZShpbnNwZWN0KHNlbGYuYWN0dWFsKSwgMTI4KSArICcgJyArXG4gICAgICAgICBzZWxmLm9wZXJhdG9yICsgJyAnICtcbiAgICAgICAgIHRydW5jYXRlKGluc3BlY3Qoc2VsZi5leHBlY3RlZCksIDEyOCk7XG59XG5cbi8vIEF0IHByZXNlbnQgb25seSB0aGUgdGhyZWUga2V5cyBtZW50aW9uZWQgYWJvdmUgYXJlIHVzZWQgYW5kXG4vLyB1bmRlcnN0b29kIGJ5IHRoZSBzcGVjLiBJbXBsZW1lbnRhdGlvbnMgb3Igc3ViIG1vZHVsZXMgY2FuIHBhc3Ncbi8vIG90aGVyIGtleXMgdG8gdGhlIEFzc2VydGlvbkVycm9yJ3MgY29uc3RydWN0b3IgLSB0aGV5IHdpbGwgYmVcbi8vIGlnbm9yZWQuXG5cbi8vIDMuIEFsbCBvZiB0aGUgZm9sbG93aW5nIGZ1bmN0aW9ucyBtdXN0IHRocm93IGFuIEFzc2VydGlvbkVycm9yXG4vLyB3aGVuIGEgY29ycmVzcG9uZGluZyBjb25kaXRpb24gaXMgbm90IG1ldCwgd2l0aCBhIG1lc3NhZ2UgdGhhdFxuLy8gbWF5IGJlIHVuZGVmaW5lZCBpZiBub3QgcHJvdmlkZWQuICBBbGwgYXNzZXJ0aW9uIG1ldGhvZHMgcHJvdmlkZVxuLy8gYm90aCB0aGUgYWN0dWFsIGFuZCBleHBlY3RlZCB2YWx1ZXMgdG8gdGhlIGFzc2VydGlvbiBlcnJvciBmb3Jcbi8vIGRpc3BsYXkgcHVycG9zZXMuXG5cbmZ1bmN0aW9uIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgb3BlcmF0b3IsIHN0YWNrU3RhcnRGdW5jdGlvbikge1xuICB0aHJvdyBuZXcgYXNzZXJ0LkFzc2VydGlvbkVycm9yKHtcbiAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgIGFjdHVhbDogYWN0dWFsLFxuICAgIGV4cGVjdGVkOiBleHBlY3RlZCxcbiAgICBvcGVyYXRvcjogb3BlcmF0b3IsXG4gICAgc3RhY2tTdGFydEZ1bmN0aW9uOiBzdGFja1N0YXJ0RnVuY3Rpb25cbiAgfSk7XG59XG5cbi8vIEVYVEVOU0lPTiEgYWxsb3dzIGZvciB3ZWxsIGJlaGF2ZWQgZXJyb3JzIGRlZmluZWQgZWxzZXdoZXJlLlxuYXNzZXJ0LmZhaWwgPSBmYWlsO1xuXG4vLyA0LiBQdXJlIGFzc2VydGlvbiB0ZXN0cyB3aGV0aGVyIGEgdmFsdWUgaXMgdHJ1dGh5LCBhcyBkZXRlcm1pbmVkXG4vLyBieSAhIWd1YXJkLlxuLy8gYXNzZXJ0Lm9rKGd1YXJkLCBtZXNzYWdlX29wdCk7XG4vLyBUaGlzIHN0YXRlbWVudCBpcyBlcXVpdmFsZW50IHRvIGFzc2VydC5lcXVhbCh0cnVlLCAhIWd1YXJkLFxuLy8gbWVzc2FnZV9vcHQpOy4gVG8gdGVzdCBzdHJpY3RseSBmb3IgdGhlIHZhbHVlIHRydWUsIHVzZVxuLy8gYXNzZXJ0LnN0cmljdEVxdWFsKHRydWUsIGd1YXJkLCBtZXNzYWdlX29wdCk7LlxuXG5mdW5jdGlvbiBvayh2YWx1ZSwgbWVzc2FnZSkge1xuICBpZiAoIXZhbHVlKSBmYWlsKHZhbHVlLCB0cnVlLCBtZXNzYWdlLCAnPT0nLCBhc3NlcnQub2spO1xufVxuYXNzZXJ0Lm9rID0gb2s7XG5cbi8vIDUuIFRoZSBlcXVhbGl0eSBhc3NlcnRpb24gdGVzdHMgc2hhbGxvdywgY29lcmNpdmUgZXF1YWxpdHkgd2l0aFxuLy8gPT0uXG4vLyBhc3NlcnQuZXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZV9vcHQpO1xuXG5hc3NlcnQuZXF1YWwgPSBmdW5jdGlvbiBlcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChhY3R1YWwgIT0gZXhwZWN0ZWQpIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJz09JywgYXNzZXJ0LmVxdWFsKTtcbn07XG5cbi8vIDYuIFRoZSBub24tZXF1YWxpdHkgYXNzZXJ0aW9uIHRlc3RzIGZvciB3aGV0aGVyIHR3byBvYmplY3RzIGFyZSBub3QgZXF1YWxcbi8vIHdpdGggIT0gYXNzZXJ0Lm5vdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0Lm5vdEVxdWFsID0gZnVuY3Rpb24gbm90RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoYWN0dWFsID09IGV4cGVjdGVkKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnIT0nLCBhc3NlcnQubm90RXF1YWwpO1xuICB9XG59O1xuXG4vLyA3LiBUaGUgZXF1aXZhbGVuY2UgYXNzZXJ0aW9uIHRlc3RzIGEgZGVlcCBlcXVhbGl0eSByZWxhdGlvbi5cbi8vIGFzc2VydC5kZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZV9vcHQpO1xuXG5hc3NlcnQuZGVlcEVxdWFsID0gZnVuY3Rpb24gZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKCFfZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIGZhbHNlKSkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJ2RlZXBFcXVhbCcsIGFzc2VydC5kZWVwRXF1YWwpO1xuICB9XG59O1xuXG5hc3NlcnQuZGVlcFN0cmljdEVxdWFsID0gZnVuY3Rpb24gZGVlcFN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKCFfZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIHRydWUpKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnZGVlcFN0cmljdEVxdWFsJywgYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbCk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIF9kZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgc3RyaWN0LCBtZW1vcykge1xuICAvLyA3LjEuIEFsbCBpZGVudGljYWwgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBhcyBkZXRlcm1pbmVkIGJ5ID09PS5cbiAgaWYgKGFjdHVhbCA9PT0gZXhwZWN0ZWQpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIGlmIChpc0J1ZmZlcihhY3R1YWwpICYmIGlzQnVmZmVyKGV4cGVjdGVkKSkge1xuICAgIHJldHVybiBjb21wYXJlKGFjdHVhbCwgZXhwZWN0ZWQpID09PSAwO1xuXG4gIC8vIDcuMi4gSWYgdGhlIGV4cGVjdGVkIHZhbHVlIGlzIGEgRGF0ZSBvYmplY3QsIHRoZSBhY3R1YWwgdmFsdWUgaXNcbiAgLy8gZXF1aXZhbGVudCBpZiBpdCBpcyBhbHNvIGEgRGF0ZSBvYmplY3QgdGhhdCByZWZlcnMgdG8gdGhlIHNhbWUgdGltZS5cbiAgfSBlbHNlIGlmICh1dGlsLmlzRGF0ZShhY3R1YWwpICYmIHV0aWwuaXNEYXRlKGV4cGVjdGVkKSkge1xuICAgIHJldHVybiBhY3R1YWwuZ2V0VGltZSgpID09PSBleHBlY3RlZC5nZXRUaW1lKCk7XG5cbiAgLy8gNy4zIElmIHRoZSBleHBlY3RlZCB2YWx1ZSBpcyBhIFJlZ0V4cCBvYmplY3QsIHRoZSBhY3R1YWwgdmFsdWUgaXNcbiAgLy8gZXF1aXZhbGVudCBpZiBpdCBpcyBhbHNvIGEgUmVnRXhwIG9iamVjdCB3aXRoIHRoZSBzYW1lIHNvdXJjZSBhbmRcbiAgLy8gcHJvcGVydGllcyAoYGdsb2JhbGAsIGBtdWx0aWxpbmVgLCBgbGFzdEluZGV4YCwgYGlnbm9yZUNhc2VgKS5cbiAgfSBlbHNlIGlmICh1dGlsLmlzUmVnRXhwKGFjdHVhbCkgJiYgdXRpbC5pc1JlZ0V4cChleHBlY3RlZCkpIHtcbiAgICByZXR1cm4gYWN0dWFsLnNvdXJjZSA9PT0gZXhwZWN0ZWQuc291cmNlICYmXG4gICAgICAgICAgIGFjdHVhbC5nbG9iYWwgPT09IGV4cGVjdGVkLmdsb2JhbCAmJlxuICAgICAgICAgICBhY3R1YWwubXVsdGlsaW5lID09PSBleHBlY3RlZC5tdWx0aWxpbmUgJiZcbiAgICAgICAgICAgYWN0dWFsLmxhc3RJbmRleCA9PT0gZXhwZWN0ZWQubGFzdEluZGV4ICYmXG4gICAgICAgICAgIGFjdHVhbC5pZ25vcmVDYXNlID09PSBleHBlY3RlZC5pZ25vcmVDYXNlO1xuXG4gIC8vIDcuNC4gT3RoZXIgcGFpcnMgdGhhdCBkbyBub3QgYm90aCBwYXNzIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0JyxcbiAgLy8gZXF1aXZhbGVuY2UgaXMgZGV0ZXJtaW5lZCBieSA9PS5cbiAgfSBlbHNlIGlmICgoYWN0dWFsID09PSBudWxsIHx8IHR5cGVvZiBhY3R1YWwgIT09ICdvYmplY3QnKSAmJlxuICAgICAgICAgICAgIChleHBlY3RlZCA9PT0gbnVsbCB8fCB0eXBlb2YgZXhwZWN0ZWQgIT09ICdvYmplY3QnKSkge1xuICAgIHJldHVybiBzdHJpY3QgPyBhY3R1YWwgPT09IGV4cGVjdGVkIDogYWN0dWFsID09IGV4cGVjdGVkO1xuXG4gIC8vIElmIGJvdGggdmFsdWVzIGFyZSBpbnN0YW5jZXMgb2YgdHlwZWQgYXJyYXlzLCB3cmFwIHRoZWlyIHVuZGVybHlpbmdcbiAgLy8gQXJyYXlCdWZmZXJzIGluIGEgQnVmZmVyIGVhY2ggdG8gaW5jcmVhc2UgcGVyZm9ybWFuY2VcbiAgLy8gVGhpcyBvcHRpbWl6YXRpb24gcmVxdWlyZXMgdGhlIGFycmF5cyB0byBoYXZlIHRoZSBzYW1lIHR5cGUgYXMgY2hlY2tlZCBieVxuICAvLyBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nIChha2EgcFRvU3RyaW5nKS4gTmV2ZXIgcGVyZm9ybSBiaW5hcnlcbiAgLy8gY29tcGFyaXNvbnMgZm9yIEZsb2F0KkFycmF5cywgdGhvdWdoLCBzaW5jZSBlLmcuICswID09PSAtMCBidXQgdGhlaXJcbiAgLy8gYml0IHBhdHRlcm5zIGFyZSBub3QgaWRlbnRpY2FsLlxuICB9IGVsc2UgaWYgKGlzVmlldyhhY3R1YWwpICYmIGlzVmlldyhleHBlY3RlZCkgJiZcbiAgICAgICAgICAgICBwVG9TdHJpbmcoYWN0dWFsKSA9PT0gcFRvU3RyaW5nKGV4cGVjdGVkKSAmJlxuICAgICAgICAgICAgICEoYWN0dWFsIGluc3RhbmNlb2YgRmxvYXQzMkFycmF5IHx8XG4gICAgICAgICAgICAgICBhY3R1YWwgaW5zdGFuY2VvZiBGbG9hdDY0QXJyYXkpKSB7XG4gICAgcmV0dXJuIGNvbXBhcmUobmV3IFVpbnQ4QXJyYXkoYWN0dWFsLmJ1ZmZlciksXG4gICAgICAgICAgICAgICAgICAgbmV3IFVpbnQ4QXJyYXkoZXhwZWN0ZWQuYnVmZmVyKSkgPT09IDA7XG5cbiAgLy8gNy41IEZvciBhbGwgb3RoZXIgT2JqZWN0IHBhaXJzLCBpbmNsdWRpbmcgQXJyYXkgb2JqZWN0cywgZXF1aXZhbGVuY2UgaXNcbiAgLy8gZGV0ZXJtaW5lZCBieSBoYXZpbmcgdGhlIHNhbWUgbnVtYmVyIG9mIG93bmVkIHByb3BlcnRpZXMgKGFzIHZlcmlmaWVkXG4gIC8vIHdpdGggT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKSwgdGhlIHNhbWUgc2V0IG9mIGtleXNcbiAgLy8gKGFsdGhvdWdoIG5vdCBuZWNlc3NhcmlseSB0aGUgc2FtZSBvcmRlciksIGVxdWl2YWxlbnQgdmFsdWVzIGZvciBldmVyeVxuICAvLyBjb3JyZXNwb25kaW5nIGtleSwgYW5kIGFuIGlkZW50aWNhbCAncHJvdG90eXBlJyBwcm9wZXJ0eS4gTm90ZTogdGhpc1xuICAvLyBhY2NvdW50cyBmb3IgYm90aCBuYW1lZCBhbmQgaW5kZXhlZCBwcm9wZXJ0aWVzIG9uIEFycmF5cy5cbiAgfSBlbHNlIGlmIChpc0J1ZmZlcihhY3R1YWwpICE9PSBpc0J1ZmZlcihleHBlY3RlZCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gZWxzZSB7XG4gICAgbWVtb3MgPSBtZW1vcyB8fCB7YWN0dWFsOiBbXSwgZXhwZWN0ZWQ6IFtdfTtcblxuICAgIHZhciBhY3R1YWxJbmRleCA9IG1lbW9zLmFjdHVhbC5pbmRleE9mKGFjdHVhbCk7XG4gICAgaWYgKGFjdHVhbEluZGV4ICE9PSAtMSkge1xuICAgICAgaWYgKGFjdHVhbEluZGV4ID09PSBtZW1vcy5leHBlY3RlZC5pbmRleE9mKGV4cGVjdGVkKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBtZW1vcy5hY3R1YWwucHVzaChhY3R1YWwpO1xuICAgIG1lbW9zLmV4cGVjdGVkLnB1c2goZXhwZWN0ZWQpO1xuXG4gICAgcmV0dXJuIG9iakVxdWl2KGFjdHVhbCwgZXhwZWN0ZWQsIHN0cmljdCwgbWVtb3MpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzQXJndW1lbnRzKG9iamVjdCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iamVjdCkgPT0gJ1tvYmplY3QgQXJndW1lbnRzXSc7XG59XG5cbmZ1bmN0aW9uIG9iakVxdWl2KGEsIGIsIHN0cmljdCwgYWN0dWFsVmlzaXRlZE9iamVjdHMpIHtcbiAgaWYgKGEgPT09IG51bGwgfHwgYSA9PT0gdW5kZWZpbmVkIHx8IGIgPT09IG51bGwgfHwgYiA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBmYWxzZTtcbiAgLy8gaWYgb25lIGlzIGEgcHJpbWl0aXZlLCB0aGUgb3RoZXIgbXVzdCBiZSBzYW1lXG4gIGlmICh1dGlsLmlzUHJpbWl0aXZlKGEpIHx8IHV0aWwuaXNQcmltaXRpdmUoYikpXG4gICAgcmV0dXJuIGEgPT09IGI7XG4gIGlmIChzdHJpY3QgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKGEpICE9PSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoYikpXG4gICAgcmV0dXJuIGZhbHNlO1xuICB2YXIgYUlzQXJncyA9IGlzQXJndW1lbnRzKGEpO1xuICB2YXIgYklzQXJncyA9IGlzQXJndW1lbnRzKGIpO1xuICBpZiAoKGFJc0FyZ3MgJiYgIWJJc0FyZ3MpIHx8ICghYUlzQXJncyAmJiBiSXNBcmdzKSlcbiAgICByZXR1cm4gZmFsc2U7XG4gIGlmIChhSXNBcmdzKSB7XG4gICAgYSA9IHBTbGljZS5jYWxsKGEpO1xuICAgIGIgPSBwU2xpY2UuY2FsbChiKTtcbiAgICByZXR1cm4gX2RlZXBFcXVhbChhLCBiLCBzdHJpY3QpO1xuICB9XG4gIHZhciBrYSA9IG9iamVjdEtleXMoYSk7XG4gIHZhciBrYiA9IG9iamVjdEtleXMoYik7XG4gIHZhciBrZXksIGk7XG4gIC8vIGhhdmluZyB0aGUgc2FtZSBudW1iZXIgb2Ygb3duZWQgcHJvcGVydGllcyAoa2V5cyBpbmNvcnBvcmF0ZXNcbiAgLy8gaGFzT3duUHJvcGVydHkpXG4gIGlmIChrYS5sZW5ndGggIT09IGtiLmxlbmd0aClcbiAgICByZXR1cm4gZmFsc2U7XG4gIC8vdGhlIHNhbWUgc2V0IG9mIGtleXMgKGFsdGhvdWdoIG5vdCBuZWNlc3NhcmlseSB0aGUgc2FtZSBvcmRlciksXG4gIGthLnNvcnQoKTtcbiAga2Iuc29ydCgpO1xuICAvL35+fmNoZWFwIGtleSB0ZXN0XG4gIGZvciAoaSA9IGthLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgaWYgKGthW2ldICE9PSBrYltpXSlcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvL2VxdWl2YWxlbnQgdmFsdWVzIGZvciBldmVyeSBjb3JyZXNwb25kaW5nIGtleSwgYW5kXG4gIC8vfn5+cG9zc2libHkgZXhwZW5zaXZlIGRlZXAgdGVzdFxuICBmb3IgKGkgPSBrYS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGtleSA9IGthW2ldO1xuICAgIGlmICghX2RlZXBFcXVhbChhW2tleV0sIGJba2V5XSwgc3RyaWN0LCBhY3R1YWxWaXNpdGVkT2JqZWN0cykpXG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8vIDguIFRoZSBub24tZXF1aXZhbGVuY2UgYXNzZXJ0aW9uIHRlc3RzIGZvciBhbnkgZGVlcCBpbmVxdWFsaXR5LlxuLy8gYXNzZXJ0Lm5vdERlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlX29wdCk7XG5cbmFzc2VydC5ub3REZWVwRXF1YWwgPSBmdW5jdGlvbiBub3REZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoX2RlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBmYWxzZSkpIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsICdub3REZWVwRXF1YWwnLCBhc3NlcnQubm90RGVlcEVxdWFsKTtcbiAgfVxufTtcblxuYXNzZXJ0Lm5vdERlZXBTdHJpY3RFcXVhbCA9IG5vdERlZXBTdHJpY3RFcXVhbDtcbmZ1bmN0aW9uIG5vdERlZXBTdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChfZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIHRydWUpKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnbm90RGVlcFN0cmljdEVxdWFsJywgbm90RGVlcFN0cmljdEVxdWFsKTtcbiAgfVxufVxuXG5cbi8vIDkuIFRoZSBzdHJpY3QgZXF1YWxpdHkgYXNzZXJ0aW9uIHRlc3RzIHN0cmljdCBlcXVhbGl0eSwgYXMgZGV0ZXJtaW5lZCBieSA9PT0uXG4vLyBhc3NlcnQuc3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZV9vcHQpO1xuXG5hc3NlcnQuc3RyaWN0RXF1YWwgPSBmdW5jdGlvbiBzdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChhY3R1YWwgIT09IGV4cGVjdGVkKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnPT09JywgYXNzZXJ0LnN0cmljdEVxdWFsKTtcbiAgfVxufTtcblxuLy8gMTAuIFRoZSBzdHJpY3Qgbm9uLWVxdWFsaXR5IGFzc2VydGlvbiB0ZXN0cyBmb3Igc3RyaWN0IGluZXF1YWxpdHksIGFzXG4vLyBkZXRlcm1pbmVkIGJ5ICE9PS4gIGFzc2VydC5ub3RTdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlX29wdCk7XG5cbmFzc2VydC5ub3RTdHJpY3RFcXVhbCA9IGZ1bmN0aW9uIG5vdFN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKGFjdHVhbCA9PT0gZXhwZWN0ZWQpIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsICchPT0nLCBhc3NlcnQubm90U3RyaWN0RXF1YWwpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBleHBlY3RlZEV4Y2VwdGlvbihhY3R1YWwsIGV4cGVjdGVkKSB7XG4gIGlmICghYWN0dWFsIHx8ICFleHBlY3RlZCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZXhwZWN0ZWQpID09ICdbb2JqZWN0IFJlZ0V4cF0nKSB7XG4gICAgcmV0dXJuIGV4cGVjdGVkLnRlc3QoYWN0dWFsKTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgaWYgKGFjdHVhbCBpbnN0YW5jZW9mIGV4cGVjdGVkKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBJZ25vcmUuICBUaGUgaW5zdGFuY2VvZiBjaGVjayBkb2Vzbid0IHdvcmsgZm9yIGFycm93IGZ1bmN0aW9ucy5cbiAgfVxuXG4gIGlmIChFcnJvci5pc1Byb3RvdHlwZU9mKGV4cGVjdGVkKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBleHBlY3RlZC5jYWxsKHt9LCBhY3R1YWwpID09PSB0cnVlO1xufVxuXG5mdW5jdGlvbiBfdHJ5QmxvY2soYmxvY2spIHtcbiAgdmFyIGVycm9yO1xuICB0cnkge1xuICAgIGJsb2NrKCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBlcnJvciA9IGU7XG4gIH1cbiAgcmV0dXJuIGVycm9yO1xufVxuXG5mdW5jdGlvbiBfdGhyb3dzKHNob3VsZFRocm93LCBibG9jaywgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgdmFyIGFjdHVhbDtcblxuICBpZiAodHlwZW9mIGJsb2NrICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJibG9ja1wiIGFyZ3VtZW50IG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBleHBlY3RlZCA9PT0gJ3N0cmluZycpIHtcbiAgICBtZXNzYWdlID0gZXhwZWN0ZWQ7XG4gICAgZXhwZWN0ZWQgPSBudWxsO1xuICB9XG5cbiAgYWN0dWFsID0gX3RyeUJsb2NrKGJsb2NrKTtcblxuICBtZXNzYWdlID0gKGV4cGVjdGVkICYmIGV4cGVjdGVkLm5hbWUgPyAnICgnICsgZXhwZWN0ZWQubmFtZSArICcpLicgOiAnLicpICtcbiAgICAgICAgICAgIChtZXNzYWdlID8gJyAnICsgbWVzc2FnZSA6ICcuJyk7XG5cbiAgaWYgKHNob3VsZFRocm93ICYmICFhY3R1YWwpIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsICdNaXNzaW5nIGV4cGVjdGVkIGV4Y2VwdGlvbicgKyBtZXNzYWdlKTtcbiAgfVxuXG4gIHZhciB1c2VyUHJvdmlkZWRNZXNzYWdlID0gdHlwZW9mIG1lc3NhZ2UgPT09ICdzdHJpbmcnO1xuICB2YXIgaXNVbndhbnRlZEV4Y2VwdGlvbiA9ICFzaG91bGRUaHJvdyAmJiB1dGlsLmlzRXJyb3IoYWN0dWFsKTtcbiAgdmFyIGlzVW5leHBlY3RlZEV4Y2VwdGlvbiA9ICFzaG91bGRUaHJvdyAmJiBhY3R1YWwgJiYgIWV4cGVjdGVkO1xuXG4gIGlmICgoaXNVbndhbnRlZEV4Y2VwdGlvbiAmJlxuICAgICAgdXNlclByb3ZpZGVkTWVzc2FnZSAmJlxuICAgICAgZXhwZWN0ZWRFeGNlcHRpb24oYWN0dWFsLCBleHBlY3RlZCkpIHx8XG4gICAgICBpc1VuZXhwZWN0ZWRFeGNlcHRpb24pIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsICdHb3QgdW53YW50ZWQgZXhjZXB0aW9uJyArIG1lc3NhZ2UpO1xuICB9XG5cbiAgaWYgKChzaG91bGRUaHJvdyAmJiBhY3R1YWwgJiYgZXhwZWN0ZWQgJiZcbiAgICAgICFleHBlY3RlZEV4Y2VwdGlvbihhY3R1YWwsIGV4cGVjdGVkKSkgfHwgKCFzaG91bGRUaHJvdyAmJiBhY3R1YWwpKSB7XG4gICAgdGhyb3cgYWN0dWFsO1xuICB9XG59XG5cbi8vIDExLiBFeHBlY3RlZCB0byB0aHJvdyBhbiBlcnJvcjpcbi8vIGFzc2VydC50aHJvd3MoYmxvY2ssIEVycm9yX29wdCwgbWVzc2FnZV9vcHQpO1xuXG5hc3NlcnQudGhyb3dzID0gZnVuY3Rpb24oYmxvY2ssIC8qb3B0aW9uYWwqL2Vycm9yLCAvKm9wdGlvbmFsKi9tZXNzYWdlKSB7XG4gIF90aHJvd3ModHJ1ZSwgYmxvY2ssIGVycm9yLCBtZXNzYWdlKTtcbn07XG5cbi8vIEVYVEVOU0lPTiEgVGhpcyBpcyBhbm5veWluZyB0byB3cml0ZSBvdXRzaWRlIHRoaXMgbW9kdWxlLlxuYXNzZXJ0LmRvZXNOb3RUaHJvdyA9IGZ1bmN0aW9uKGJsb2NrLCAvKm9wdGlvbmFsKi9lcnJvciwgLypvcHRpb25hbCovbWVzc2FnZSkge1xuICBfdGhyb3dzKGZhbHNlLCBibG9jaywgZXJyb3IsIG1lc3NhZ2UpO1xufTtcblxuYXNzZXJ0LmlmRXJyb3IgPSBmdW5jdGlvbihlcnIpIHsgaWYgKGVycikgdGhyb3cgZXJyOyB9O1xuXG52YXIgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIChvYmopIHtcbiAgdmFyIGtleXMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIGlmIChoYXNPd24uY2FsbChvYmosIGtleSkpIGtleXMucHVzaChrZXkpO1xuICB9XG4gIHJldHVybiBrZXlzO1xufTtcbiIsIid1c2Ugc3RyaWN0J1xuXG5leHBvcnRzLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXG5leHBvcnRzLnRvQnl0ZUFycmF5ID0gdG9CeXRlQXJyYXlcbmV4cG9ydHMuZnJvbUJ5dGVBcnJheSA9IGZyb21CeXRlQXJyYXlcblxudmFyIGxvb2t1cCA9IFtdXG52YXIgcmV2TG9va3VwID0gW11cbnZhciBBcnIgPSB0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcgPyBVaW50OEFycmF5IDogQXJyYXlcblxudmFyIGNvZGUgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLydcbmZvciAodmFyIGkgPSAwLCBsZW4gPSBjb2RlLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gIGxvb2t1cFtpXSA9IGNvZGVbaV1cbiAgcmV2TG9va3VwW2NvZGUuY2hhckNvZGVBdChpKV0gPSBpXG59XG5cbnJldkxvb2t1cFsnLScuY2hhckNvZGVBdCgwKV0gPSA2MlxucmV2TG9va3VwWydfJy5jaGFyQ29kZUF0KDApXSA9IDYzXG5cbmZ1bmN0aW9uIHBsYWNlSG9sZGVyc0NvdW50IChiNjQpIHtcbiAgdmFyIGxlbiA9IGI2NC5sZW5ndGhcbiAgaWYgKGxlbiAlIDQgPiAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0cmluZy4gTGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA0JylcbiAgfVxuXG4gIC8vIHRoZSBudW1iZXIgb2YgZXF1YWwgc2lnbnMgKHBsYWNlIGhvbGRlcnMpXG4gIC8vIGlmIHRoZXJlIGFyZSB0d28gcGxhY2Vob2xkZXJzLCB0aGFuIHRoZSB0d28gY2hhcmFjdGVycyBiZWZvcmUgaXRcbiAgLy8gcmVwcmVzZW50IG9uZSBieXRlXG4gIC8vIGlmIHRoZXJlIGlzIG9ubHkgb25lLCB0aGVuIHRoZSB0aHJlZSBjaGFyYWN0ZXJzIGJlZm9yZSBpdCByZXByZXNlbnQgMiBieXRlc1xuICAvLyB0aGlzIGlzIGp1c3QgYSBjaGVhcCBoYWNrIHRvIG5vdCBkbyBpbmRleE9mIHR3aWNlXG4gIHJldHVybiBiNjRbbGVuIC0gMl0gPT09ICc9JyA/IDIgOiBiNjRbbGVuIC0gMV0gPT09ICc9JyA/IDEgOiAwXG59XG5cbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKGI2NCkge1xuICAvLyBiYXNlNjQgaXMgNC8zICsgdXAgdG8gdHdvIGNoYXJhY3RlcnMgb2YgdGhlIG9yaWdpbmFsIGRhdGFcbiAgcmV0dXJuIGI2NC5sZW5ndGggKiAzIC8gNCAtIHBsYWNlSG9sZGVyc0NvdW50KGI2NClcbn1cblxuZnVuY3Rpb24gdG9CeXRlQXJyYXkgKGI2NCkge1xuICB2YXIgaSwgaiwgbCwgdG1wLCBwbGFjZUhvbGRlcnMsIGFyclxuICB2YXIgbGVuID0gYjY0Lmxlbmd0aFxuICBwbGFjZUhvbGRlcnMgPSBwbGFjZUhvbGRlcnNDb3VudChiNjQpXG5cbiAgYXJyID0gbmV3IEFycihsZW4gKiAzIC8gNCAtIHBsYWNlSG9sZGVycylcblxuICAvLyBpZiB0aGVyZSBhcmUgcGxhY2Vob2xkZXJzLCBvbmx5IGdldCB1cCB0byB0aGUgbGFzdCBjb21wbGV0ZSA0IGNoYXJzXG4gIGwgPSBwbGFjZUhvbGRlcnMgPiAwID8gbGVuIC0gNCA6IGxlblxuXG4gIHZhciBMID0gMFxuXG4gIGZvciAoaSA9IDAsIGogPSAwOyBpIDwgbDsgaSArPSA0LCBqICs9IDMpIHtcbiAgICB0bXAgPSAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxOCkgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgMTIpIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildIDw8IDYpIHwgcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAzKV1cbiAgICBhcnJbTCsrXSA9ICh0bXAgPj4gMTYpICYgMHhGRlxuICAgIGFycltMKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcbiAgICBhcnJbTCsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIGlmIChwbGFjZUhvbGRlcnMgPT09IDIpIHtcbiAgICB0bXAgPSAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAyKSB8IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA+PiA0KVxuICAgIGFycltMKytdID0gdG1wICYgMHhGRlxuICB9IGVsc2UgaWYgKHBsYWNlSG9sZGVycyA9PT0gMSkge1xuICAgIHRtcCA9IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDEwKSB8IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCA0KSB8IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA+PiAyKVxuICAgIGFycltMKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcbiAgICBhcnJbTCsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBhcnJcbn1cblxuZnVuY3Rpb24gdHJpcGxldFRvQmFzZTY0IChudW0pIHtcbiAgcmV0dXJuIGxvb2t1cFtudW0gPj4gMTggJiAweDNGXSArIGxvb2t1cFtudW0gPj4gMTIgJiAweDNGXSArIGxvb2t1cFtudW0gPj4gNiAmIDB4M0ZdICsgbG9va3VwW251bSAmIDB4M0ZdXG59XG5cbmZ1bmN0aW9uIGVuY29kZUNodW5rICh1aW50OCwgc3RhcnQsIGVuZCkge1xuICB2YXIgdG1wXG4gIHZhciBvdXRwdXQgPSBbXVxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkgKz0gMykge1xuICAgIHRtcCA9ICh1aW50OFtpXSA8PCAxNikgKyAodWludDhbaSArIDFdIDw8IDgpICsgKHVpbnQ4W2kgKyAyXSlcbiAgICBvdXRwdXQucHVzaCh0cmlwbGV0VG9CYXNlNjQodG1wKSlcbiAgfVxuICByZXR1cm4gb3V0cHV0LmpvaW4oJycpXG59XG5cbmZ1bmN0aW9uIGZyb21CeXRlQXJyYXkgKHVpbnQ4KSB7XG4gIHZhciB0bXBcbiAgdmFyIGxlbiA9IHVpbnQ4Lmxlbmd0aFxuICB2YXIgZXh0cmFCeXRlcyA9IGxlbiAlIDMgLy8gaWYgd2UgaGF2ZSAxIGJ5dGUgbGVmdCwgcGFkIDIgYnl0ZXNcbiAgdmFyIG91dHB1dCA9ICcnXG4gIHZhciBwYXJ0cyA9IFtdXG4gIHZhciBtYXhDaHVua0xlbmd0aCA9IDE2MzgzIC8vIG11c3QgYmUgbXVsdGlwbGUgb2YgM1xuXG4gIC8vIGdvIHRocm91Z2ggdGhlIGFycmF5IGV2ZXJ5IHRocmVlIGJ5dGVzLCB3ZSdsbCBkZWFsIHdpdGggdHJhaWxpbmcgc3R1ZmYgbGF0ZXJcbiAgZm9yICh2YXIgaSA9IDAsIGxlbjIgPSBsZW4gLSBleHRyYUJ5dGVzOyBpIDwgbGVuMjsgaSArPSBtYXhDaHVua0xlbmd0aCkge1xuICAgIHBhcnRzLnB1c2goZW5jb2RlQ2h1bmsodWludDgsIGksIChpICsgbWF4Q2h1bmtMZW5ndGgpID4gbGVuMiA/IGxlbjIgOiAoaSArIG1heENodW5rTGVuZ3RoKSkpXG4gIH1cblxuICAvLyBwYWQgdGhlIGVuZCB3aXRoIHplcm9zLCBidXQgbWFrZSBzdXJlIHRvIG5vdCBmb3JnZXQgdGhlIGV4dHJhIGJ5dGVzXG4gIGlmIChleHRyYUJ5dGVzID09PSAxKSB7XG4gICAgdG1wID0gdWludDhbbGVuIC0gMV1cbiAgICBvdXRwdXQgKz0gbG9va3VwW3RtcCA+PiAyXVxuICAgIG91dHB1dCArPSBsb29rdXBbKHRtcCA8PCA0KSAmIDB4M0ZdXG4gICAgb3V0cHV0ICs9ICc9PSdcbiAgfSBlbHNlIGlmIChleHRyYUJ5dGVzID09PSAyKSB7XG4gICAgdG1wID0gKHVpbnQ4W2xlbiAtIDJdIDw8IDgpICsgKHVpbnQ4W2xlbiAtIDFdKVxuICAgIG91dHB1dCArPSBsb29rdXBbdG1wID4+IDEwXVxuICAgIG91dHB1dCArPSBsb29rdXBbKHRtcCA+PiA0KSAmIDB4M0ZdXG4gICAgb3V0cHV0ICs9IGxvb2t1cFsodG1wIDw8IDIpICYgMHgzRl1cbiAgICBvdXRwdXQgKz0gJz0nXG4gIH1cblxuICBwYXJ0cy5wdXNoKG91dHB1dClcblxuICByZXR1cm4gcGFydHMuam9pbignJylcbn1cbiIsIiIsIid1c2Ugc3RyaWN0JztcblxuXG52YXIgVFlQRURfT0sgPSAgKHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJykgJiZcbiAgICAgICAgICAgICAgICAodHlwZW9mIFVpbnQxNkFycmF5ICE9PSAndW5kZWZpbmVkJykgJiZcbiAgICAgICAgICAgICAgICAodHlwZW9mIEludDMyQXJyYXkgIT09ICd1bmRlZmluZWQnKTtcblxuXG5leHBvcnRzLmFzc2lnbiA9IGZ1bmN0aW9uIChvYmogLypmcm9tMSwgZnJvbTIsIGZyb20zLCAuLi4qLykge1xuICB2YXIgc291cmNlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gIHdoaWxlIChzb3VyY2VzLmxlbmd0aCkge1xuICAgIHZhciBzb3VyY2UgPSBzb3VyY2VzLnNoaWZ0KCk7XG4gICAgaWYgKCFzb3VyY2UpIHsgY29udGludWU7IH1cblxuICAgIGlmICh0eXBlb2Ygc291cmNlICE9PSAnb2JqZWN0Jykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihzb3VyY2UgKyAnbXVzdCBiZSBub24tb2JqZWN0Jyk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgcCBpbiBzb3VyY2UpIHtcbiAgICAgIGlmIChzb3VyY2UuaGFzT3duUHJvcGVydHkocCkpIHtcbiAgICAgICAgb2JqW3BdID0gc291cmNlW3BdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvYmo7XG59O1xuXG5cbi8vIHJlZHVjZSBidWZmZXIgc2l6ZSwgYXZvaWRpbmcgbWVtIGNvcHlcbmV4cG9ydHMuc2hyaW5rQnVmID0gZnVuY3Rpb24gKGJ1Ziwgc2l6ZSkge1xuICBpZiAoYnVmLmxlbmd0aCA9PT0gc2l6ZSkgeyByZXR1cm4gYnVmOyB9XG4gIGlmIChidWYuc3ViYXJyYXkpIHsgcmV0dXJuIGJ1Zi5zdWJhcnJheSgwLCBzaXplKTsgfVxuICBidWYubGVuZ3RoID0gc2l6ZTtcbiAgcmV0dXJuIGJ1Zjtcbn07XG5cblxudmFyIGZuVHlwZWQgPSB7XG4gIGFycmF5U2V0OiBmdW5jdGlvbiAoZGVzdCwgc3JjLCBzcmNfb2ZmcywgbGVuLCBkZXN0X29mZnMpIHtcbiAgICBpZiAoc3JjLnN1YmFycmF5ICYmIGRlc3Quc3ViYXJyYXkpIHtcbiAgICAgIGRlc3Quc2V0KHNyYy5zdWJhcnJheShzcmNfb2Zmcywgc3JjX29mZnMgKyBsZW4pLCBkZXN0X29mZnMpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBGYWxsYmFjayB0byBvcmRpbmFyeSBhcnJheVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGRlc3RbZGVzdF9vZmZzICsgaV0gPSBzcmNbc3JjX29mZnMgKyBpXTtcbiAgICB9XG4gIH0sXG4gIC8vIEpvaW4gYXJyYXkgb2YgY2h1bmtzIHRvIHNpbmdsZSBhcnJheS5cbiAgZmxhdHRlbkNodW5rczogZnVuY3Rpb24gKGNodW5rcykge1xuICAgIHZhciBpLCBsLCBsZW4sIHBvcywgY2h1bmssIHJlc3VsdDtcblxuICAgIC8vIGNhbGN1bGF0ZSBkYXRhIGxlbmd0aFxuICAgIGxlbiA9IDA7XG4gICAgZm9yIChpID0gMCwgbCA9IGNodW5rcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGxlbiArPSBjaHVua3NbaV0ubGVuZ3RoO1xuICAgIH1cblxuICAgIC8vIGpvaW4gY2h1bmtzXG4gICAgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkobGVuKTtcbiAgICBwb3MgPSAwO1xuICAgIGZvciAoaSA9IDAsIGwgPSBjaHVua3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBjaHVuayA9IGNodW5rc1tpXTtcbiAgICAgIHJlc3VsdC5zZXQoY2h1bmssIHBvcyk7XG4gICAgICBwb3MgKz0gY2h1bmsubGVuZ3RoO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn07XG5cbnZhciBmblVudHlwZWQgPSB7XG4gIGFycmF5U2V0OiBmdW5jdGlvbiAoZGVzdCwgc3JjLCBzcmNfb2ZmcywgbGVuLCBkZXN0X29mZnMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBkZXN0W2Rlc3Rfb2ZmcyArIGldID0gc3JjW3NyY19vZmZzICsgaV07XG4gICAgfVxuICB9LFxuICAvLyBKb2luIGFycmF5IG9mIGNodW5rcyB0byBzaW5nbGUgYXJyYXkuXG4gIGZsYXR0ZW5DaHVua3M6IGZ1bmN0aW9uIChjaHVua3MpIHtcbiAgICByZXR1cm4gW10uY29uY2F0LmFwcGx5KFtdLCBjaHVua3MpO1xuICB9XG59O1xuXG5cbi8vIEVuYWJsZS9EaXNhYmxlIHR5cGVkIGFycmF5cyB1c2UsIGZvciB0ZXN0aW5nXG4vL1xuZXhwb3J0cy5zZXRUeXBlZCA9IGZ1bmN0aW9uIChvbikge1xuICBpZiAob24pIHtcbiAgICBleHBvcnRzLkJ1ZjggID0gVWludDhBcnJheTtcbiAgICBleHBvcnRzLkJ1ZjE2ID0gVWludDE2QXJyYXk7XG4gICAgZXhwb3J0cy5CdWYzMiA9IEludDMyQXJyYXk7XG4gICAgZXhwb3J0cy5hc3NpZ24oZXhwb3J0cywgZm5UeXBlZCk7XG4gIH0gZWxzZSB7XG4gICAgZXhwb3J0cy5CdWY4ICA9IEFycmF5O1xuICAgIGV4cG9ydHMuQnVmMTYgPSBBcnJheTtcbiAgICBleHBvcnRzLkJ1ZjMyID0gQXJyYXk7XG4gICAgZXhwb3J0cy5hc3NpZ24oZXhwb3J0cywgZm5VbnR5cGVkKTtcbiAgfVxufTtcblxuZXhwb3J0cy5zZXRUeXBlZChUWVBFRF9PSyk7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIE5vdGU6IGFkbGVyMzIgdGFrZXMgMTIlIGZvciBsZXZlbCAwIGFuZCAyJSBmb3IgbGV2ZWwgNi5cbi8vIEl0IGRvZXNuJ3Qgd29ydGggdG8gbWFrZSBhZGRpdGlvbmFsIG9wdGltaXphdGlvbmEgYXMgaW4gb3JpZ2luYWwuXG4vLyBTbWFsbCBzaXplIGlzIHByZWZlcmFibGUuXG5cbmZ1bmN0aW9uIGFkbGVyMzIoYWRsZXIsIGJ1ZiwgbGVuLCBwb3MpIHtcbiAgdmFyIHMxID0gKGFkbGVyICYgMHhmZmZmKSB8MCxcbiAgICAgIHMyID0gKChhZGxlciA+Pj4gMTYpICYgMHhmZmZmKSB8MCxcbiAgICAgIG4gPSAwO1xuXG4gIHdoaWxlIChsZW4gIT09IDApIHtcbiAgICAvLyBTZXQgbGltaXQgfiB0d2ljZSBsZXNzIHRoYW4gNTU1MiwgdG8ga2VlcFxuICAgIC8vIHMyIGluIDMxLWJpdHMsIGJlY2F1c2Ugd2UgZm9yY2Ugc2lnbmVkIGludHMuXG4gICAgLy8gaW4gb3RoZXIgY2FzZSAlPSB3aWxsIGZhaWwuXG4gICAgbiA9IGxlbiA+IDIwMDAgPyAyMDAwIDogbGVuO1xuICAgIGxlbiAtPSBuO1xuXG4gICAgZG8ge1xuICAgICAgczEgPSAoczEgKyBidWZbcG9zKytdKSB8MDtcbiAgICAgIHMyID0gKHMyICsgczEpIHwwO1xuICAgIH0gd2hpbGUgKC0tbik7XG5cbiAgICBzMSAlPSA2NTUyMTtcbiAgICBzMiAlPSA2NTUyMTtcbiAgfVxuXG4gIHJldHVybiAoczEgfCAoczIgPDwgMTYpKSB8MDtcbn1cblxuXG5tb2R1bGUuZXhwb3J0cyA9IGFkbGVyMzI7XG4iLCIndXNlIHN0cmljdCc7XG5cblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgLyogQWxsb3dlZCBmbHVzaCB2YWx1ZXM7IHNlZSBkZWZsYXRlKCkgYW5kIGluZmxhdGUoKSBiZWxvdyBmb3IgZGV0YWlscyAqL1xuICBaX05PX0ZMVVNIOiAgICAgICAgIDAsXG4gIFpfUEFSVElBTF9GTFVTSDogICAgMSxcbiAgWl9TWU5DX0ZMVVNIOiAgICAgICAyLFxuICBaX0ZVTExfRkxVU0g6ICAgICAgIDMsXG4gIFpfRklOSVNIOiAgICAgICAgICAgNCxcbiAgWl9CTE9DSzogICAgICAgICAgICA1LFxuICBaX1RSRUVTOiAgICAgICAgICAgIDYsXG5cbiAgLyogUmV0dXJuIGNvZGVzIGZvciB0aGUgY29tcHJlc3Npb24vZGVjb21wcmVzc2lvbiBmdW5jdGlvbnMuIE5lZ2F0aXZlIHZhbHVlc1xuICAqIGFyZSBlcnJvcnMsIHBvc2l0aXZlIHZhbHVlcyBhcmUgdXNlZCBmb3Igc3BlY2lhbCBidXQgbm9ybWFsIGV2ZW50cy5cbiAgKi9cbiAgWl9PSzogICAgICAgICAgICAgICAwLFxuICBaX1NUUkVBTV9FTkQ6ICAgICAgIDEsXG4gIFpfTkVFRF9ESUNUOiAgICAgICAgMixcbiAgWl9FUlJOTzogICAgICAgICAgIC0xLFxuICBaX1NUUkVBTV9FUlJPUjogICAgLTIsXG4gIFpfREFUQV9FUlJPUjogICAgICAtMyxcbiAgLy9aX01FTV9FUlJPUjogICAgIC00LFxuICBaX0JVRl9FUlJPUjogICAgICAgLTUsXG4gIC8vWl9WRVJTSU9OX0VSUk9SOiAtNixcblxuICAvKiBjb21wcmVzc2lvbiBsZXZlbHMgKi9cbiAgWl9OT19DT01QUkVTU0lPTjogICAgICAgICAwLFxuICBaX0JFU1RfU1BFRUQ6ICAgICAgICAgICAgIDEsXG4gIFpfQkVTVF9DT01QUkVTU0lPTjogICAgICAgOSxcbiAgWl9ERUZBVUxUX0NPTVBSRVNTSU9OOiAgIC0xLFxuXG5cbiAgWl9GSUxURVJFRDogICAgICAgICAgICAgICAxLFxuICBaX0hVRkZNQU5fT05MWTogICAgICAgICAgIDIsXG4gIFpfUkxFOiAgICAgICAgICAgICAgICAgICAgMyxcbiAgWl9GSVhFRDogICAgICAgICAgICAgICAgICA0LFxuICBaX0RFRkFVTFRfU1RSQVRFR1k6ICAgICAgIDAsXG5cbiAgLyogUG9zc2libGUgdmFsdWVzIG9mIHRoZSBkYXRhX3R5cGUgZmllbGQgKHRob3VnaCBzZWUgaW5mbGF0ZSgpKSAqL1xuICBaX0JJTkFSWTogICAgICAgICAgICAgICAgIDAsXG4gIFpfVEVYVDogICAgICAgICAgICAgICAgICAgMSxcbiAgLy9aX0FTQ0lJOiAgICAgICAgICAgICAgICAxLCAvLyA9IFpfVEVYVCAoZGVwcmVjYXRlZClcbiAgWl9VTktOT1dOOiAgICAgICAgICAgICAgICAyLFxuXG4gIC8qIFRoZSBkZWZsYXRlIGNvbXByZXNzaW9uIG1ldGhvZCAqL1xuICBaX0RFRkxBVEVEOiAgICAgICAgICAgICAgIDhcbiAgLy9aX05VTEw6ICAgICAgICAgICAgICAgICBudWxsIC8vIFVzZSAtMSBvciBudWxsIGlubGluZSwgZGVwZW5kaW5nIG9uIHZhciB0eXBlXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyBOb3RlOiB3ZSBjYW4ndCBnZXQgc2lnbmlmaWNhbnQgc3BlZWQgYm9vc3QgaGVyZS5cbi8vIFNvIHdyaXRlIGNvZGUgdG8gbWluaW1pemUgc2l6ZSAtIG5vIHByZWdlbmVyYXRlZCB0YWJsZXNcbi8vIGFuZCBhcnJheSB0b29scyBkZXBlbmRlbmNpZXMuXG5cblxuLy8gVXNlIG9yZGluYXJ5IGFycmF5LCBzaW5jZSB1bnR5cGVkIG1ha2VzIG5vIGJvb3N0IGhlcmVcbmZ1bmN0aW9uIG1ha2VUYWJsZSgpIHtcbiAgdmFyIGMsIHRhYmxlID0gW107XG5cbiAgZm9yICh2YXIgbiA9IDA7IG4gPCAyNTY7IG4rKykge1xuICAgIGMgPSBuO1xuICAgIGZvciAodmFyIGsgPSAwOyBrIDwgODsgaysrKSB7XG4gICAgICBjID0gKChjICYgMSkgPyAoMHhFREI4ODMyMCBeIChjID4+PiAxKSkgOiAoYyA+Pj4gMSkpO1xuICAgIH1cbiAgICB0YWJsZVtuXSA9IGM7XG4gIH1cblxuICByZXR1cm4gdGFibGU7XG59XG5cbi8vIENyZWF0ZSB0YWJsZSBvbiBsb2FkLiBKdXN0IDI1NSBzaWduZWQgbG9uZ3MuIE5vdCBhIHByb2JsZW0uXG52YXIgY3JjVGFibGUgPSBtYWtlVGFibGUoKTtcblxuXG5mdW5jdGlvbiBjcmMzMihjcmMsIGJ1ZiwgbGVuLCBwb3MpIHtcbiAgdmFyIHQgPSBjcmNUYWJsZSxcbiAgICAgIGVuZCA9IHBvcyArIGxlbjtcblxuICBjcmMgXj0gLTE7XG5cbiAgZm9yICh2YXIgaSA9IHBvczsgaSA8IGVuZDsgaSsrKSB7XG4gICAgY3JjID0gKGNyYyA+Pj4gOCkgXiB0WyhjcmMgXiBidWZbaV0pICYgMHhGRl07XG4gIH1cblxuICByZXR1cm4gKGNyYyBeICgtMSkpOyAvLyA+Pj4gMDtcbn1cblxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyYzMyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgICA9IHJlcXVpcmUoJy4uL3V0aWxzL2NvbW1vbicpO1xudmFyIHRyZWVzICAgPSByZXF1aXJlKCcuL3RyZWVzJyk7XG52YXIgYWRsZXIzMiA9IHJlcXVpcmUoJy4vYWRsZXIzMicpO1xudmFyIGNyYzMyICAgPSByZXF1aXJlKCcuL2NyYzMyJyk7XG52YXIgbXNnICAgICA9IHJlcXVpcmUoJy4vbWVzc2FnZXMnKTtcblxuLyogUHVibGljIGNvbnN0YW50cyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cblxuLyogQWxsb3dlZCBmbHVzaCB2YWx1ZXM7IHNlZSBkZWZsYXRlKCkgYW5kIGluZmxhdGUoKSBiZWxvdyBmb3IgZGV0YWlscyAqL1xudmFyIFpfTk9fRkxVU0ggICAgICA9IDA7XG52YXIgWl9QQVJUSUFMX0ZMVVNIID0gMTtcbi8vdmFyIFpfU1lOQ19GTFVTSCAgICA9IDI7XG52YXIgWl9GVUxMX0ZMVVNIICAgID0gMztcbnZhciBaX0ZJTklTSCAgICAgICAgPSA0O1xudmFyIFpfQkxPQ0sgICAgICAgICA9IDU7XG4vL3ZhciBaX1RSRUVTICAgICAgICAgPSA2O1xuXG5cbi8qIFJldHVybiBjb2RlcyBmb3IgdGhlIGNvbXByZXNzaW9uL2RlY29tcHJlc3Npb24gZnVuY3Rpb25zLiBOZWdhdGl2ZSB2YWx1ZXNcbiAqIGFyZSBlcnJvcnMsIHBvc2l0aXZlIHZhbHVlcyBhcmUgdXNlZCBmb3Igc3BlY2lhbCBidXQgbm9ybWFsIGV2ZW50cy5cbiAqL1xudmFyIFpfT0sgICAgICAgICAgICA9IDA7XG52YXIgWl9TVFJFQU1fRU5EICAgID0gMTtcbi8vdmFyIFpfTkVFRF9ESUNUICAgICA9IDI7XG4vL3ZhciBaX0VSUk5PICAgICAgICAgPSAtMTtcbnZhciBaX1NUUkVBTV9FUlJPUiAgPSAtMjtcbnZhciBaX0RBVEFfRVJST1IgICAgPSAtMztcbi8vdmFyIFpfTUVNX0VSUk9SICAgICA9IC00O1xudmFyIFpfQlVGX0VSUk9SICAgICA9IC01O1xuLy92YXIgWl9WRVJTSU9OX0VSUk9SID0gLTY7XG5cblxuLyogY29tcHJlc3Npb24gbGV2ZWxzICovXG4vL3ZhciBaX05PX0NPTVBSRVNTSU9OICAgICAgPSAwO1xuLy92YXIgWl9CRVNUX1NQRUVEICAgICAgICAgID0gMTtcbi8vdmFyIFpfQkVTVF9DT01QUkVTU0lPTiAgICA9IDk7XG52YXIgWl9ERUZBVUxUX0NPTVBSRVNTSU9OID0gLTE7XG5cblxudmFyIFpfRklMVEVSRUQgICAgICAgICAgICA9IDE7XG52YXIgWl9IVUZGTUFOX09OTFkgICAgICAgID0gMjtcbnZhciBaX1JMRSAgICAgICAgICAgICAgICAgPSAzO1xudmFyIFpfRklYRUQgICAgICAgICAgICAgICA9IDQ7XG52YXIgWl9ERUZBVUxUX1NUUkFURUdZICAgID0gMDtcblxuLyogUG9zc2libGUgdmFsdWVzIG9mIHRoZSBkYXRhX3R5cGUgZmllbGQgKHRob3VnaCBzZWUgaW5mbGF0ZSgpKSAqL1xuLy92YXIgWl9CSU5BUlkgICAgICAgICAgICAgID0gMDtcbi8vdmFyIFpfVEVYVCAgICAgICAgICAgICAgICA9IDE7XG4vL3ZhciBaX0FTQ0lJICAgICAgICAgICAgICAgPSAxOyAvLyA9IFpfVEVYVFxudmFyIFpfVU5LTk9XTiAgICAgICAgICAgICA9IDI7XG5cblxuLyogVGhlIGRlZmxhdGUgY29tcHJlc3Npb24gbWV0aG9kICovXG52YXIgWl9ERUZMQVRFRCAgPSA4O1xuXG4vKj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5cbnZhciBNQVhfTUVNX0xFVkVMID0gOTtcbi8qIE1heGltdW0gdmFsdWUgZm9yIG1lbUxldmVsIGluIGRlZmxhdGVJbml0MiAqL1xudmFyIE1BWF9XQklUUyA9IDE1O1xuLyogMzJLIExaNzcgd2luZG93ICovXG52YXIgREVGX01FTV9MRVZFTCA9IDg7XG5cblxudmFyIExFTkdUSF9DT0RFUyAgPSAyOTtcbi8qIG51bWJlciBvZiBsZW5ndGggY29kZXMsIG5vdCBjb3VudGluZyB0aGUgc3BlY2lhbCBFTkRfQkxPQ0sgY29kZSAqL1xudmFyIExJVEVSQUxTICAgICAgPSAyNTY7XG4vKiBudW1iZXIgb2YgbGl0ZXJhbCBieXRlcyAwLi4yNTUgKi9cbnZhciBMX0NPREVTICAgICAgID0gTElURVJBTFMgKyAxICsgTEVOR1RIX0NPREVTO1xuLyogbnVtYmVyIG9mIExpdGVyYWwgb3IgTGVuZ3RoIGNvZGVzLCBpbmNsdWRpbmcgdGhlIEVORF9CTE9DSyBjb2RlICovXG52YXIgRF9DT0RFUyAgICAgICA9IDMwO1xuLyogbnVtYmVyIG9mIGRpc3RhbmNlIGNvZGVzICovXG52YXIgQkxfQ09ERVMgICAgICA9IDE5O1xuLyogbnVtYmVyIG9mIGNvZGVzIHVzZWQgdG8gdHJhbnNmZXIgdGhlIGJpdCBsZW5ndGhzICovXG52YXIgSEVBUF9TSVpFICAgICA9IDIgKiBMX0NPREVTICsgMTtcbi8qIG1heGltdW0gaGVhcCBzaXplICovXG52YXIgTUFYX0JJVFMgID0gMTU7XG4vKiBBbGwgY29kZXMgbXVzdCBub3QgZXhjZWVkIE1BWF9CSVRTIGJpdHMgKi9cblxudmFyIE1JTl9NQVRDSCA9IDM7XG52YXIgTUFYX01BVENIID0gMjU4O1xudmFyIE1JTl9MT09LQUhFQUQgPSAoTUFYX01BVENIICsgTUlOX01BVENIICsgMSk7XG5cbnZhciBQUkVTRVRfRElDVCA9IDB4MjA7XG5cbnZhciBJTklUX1NUQVRFID0gNDI7XG52YXIgRVhUUkFfU1RBVEUgPSA2OTtcbnZhciBOQU1FX1NUQVRFID0gNzM7XG52YXIgQ09NTUVOVF9TVEFURSA9IDkxO1xudmFyIEhDUkNfU1RBVEUgPSAxMDM7XG52YXIgQlVTWV9TVEFURSA9IDExMztcbnZhciBGSU5JU0hfU1RBVEUgPSA2NjY7XG5cbnZhciBCU19ORUVEX01PUkUgICAgICA9IDE7IC8qIGJsb2NrIG5vdCBjb21wbGV0ZWQsIG5lZWQgbW9yZSBpbnB1dCBvciBtb3JlIG91dHB1dCAqL1xudmFyIEJTX0JMT0NLX0RPTkUgICAgID0gMjsgLyogYmxvY2sgZmx1c2ggcGVyZm9ybWVkICovXG52YXIgQlNfRklOSVNIX1NUQVJURUQgPSAzOyAvKiBmaW5pc2ggc3RhcnRlZCwgbmVlZCBvbmx5IG1vcmUgb3V0cHV0IGF0IG5leHQgZGVmbGF0ZSAqL1xudmFyIEJTX0ZJTklTSF9ET05FICAgID0gNDsgLyogZmluaXNoIGRvbmUsIGFjY2VwdCBubyBtb3JlIGlucHV0IG9yIG91dHB1dCAqL1xuXG52YXIgT1NfQ09ERSA9IDB4MDM7IC8vIFVuaXggOikgLiBEb24ndCBkZXRlY3QsIHVzZSB0aGlzIGRlZmF1bHQuXG5cbmZ1bmN0aW9uIGVycihzdHJtLCBlcnJvckNvZGUpIHtcbiAgc3RybS5tc2cgPSBtc2dbZXJyb3JDb2RlXTtcbiAgcmV0dXJuIGVycm9yQ29kZTtcbn1cblxuZnVuY3Rpb24gcmFuayhmKSB7XG4gIHJldHVybiAoKGYpIDw8IDEpIC0gKChmKSA+IDQgPyA5IDogMCk7XG59XG5cbmZ1bmN0aW9uIHplcm8oYnVmKSB7IHZhciBsZW4gPSBidWYubGVuZ3RoOyB3aGlsZSAoLS1sZW4gPj0gMCkgeyBidWZbbGVuXSA9IDA7IH0gfVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEZsdXNoIGFzIG11Y2ggcGVuZGluZyBvdXRwdXQgYXMgcG9zc2libGUuIEFsbCBkZWZsYXRlKCkgb3V0cHV0IGdvZXNcbiAqIHRocm91Z2ggdGhpcyBmdW5jdGlvbiBzbyBzb21lIGFwcGxpY2F0aW9ucyBtYXkgd2lzaCB0byBtb2RpZnkgaXRcbiAqIHRvIGF2b2lkIGFsbG9jYXRpbmcgYSBsYXJnZSBzdHJtLT5vdXRwdXQgYnVmZmVyIGFuZCBjb3B5aW5nIGludG8gaXQuXG4gKiAoU2VlIGFsc28gcmVhZF9idWYoKSkuXG4gKi9cbmZ1bmN0aW9uIGZsdXNoX3BlbmRpbmcoc3RybSkge1xuICB2YXIgcyA9IHN0cm0uc3RhdGU7XG5cbiAgLy9fdHJfZmx1c2hfYml0cyhzKTtcbiAgdmFyIGxlbiA9IHMucGVuZGluZztcbiAgaWYgKGxlbiA+IHN0cm0uYXZhaWxfb3V0KSB7XG4gICAgbGVuID0gc3RybS5hdmFpbF9vdXQ7XG4gIH1cbiAgaWYgKGxlbiA9PT0gMCkgeyByZXR1cm47IH1cblxuICB1dGlscy5hcnJheVNldChzdHJtLm91dHB1dCwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nX291dCwgbGVuLCBzdHJtLm5leHRfb3V0KTtcbiAgc3RybS5uZXh0X291dCArPSBsZW47XG4gIHMucGVuZGluZ19vdXQgKz0gbGVuO1xuICBzdHJtLnRvdGFsX291dCArPSBsZW47XG4gIHN0cm0uYXZhaWxfb3V0IC09IGxlbjtcbiAgcy5wZW5kaW5nIC09IGxlbjtcbiAgaWYgKHMucGVuZGluZyA9PT0gMCkge1xuICAgIHMucGVuZGluZ19vdXQgPSAwO1xuICB9XG59XG5cblxuZnVuY3Rpb24gZmx1c2hfYmxvY2tfb25seShzLCBsYXN0KSB7XG4gIHRyZWVzLl90cl9mbHVzaF9ibG9jayhzLCAocy5ibG9ja19zdGFydCA+PSAwID8gcy5ibG9ja19zdGFydCA6IC0xKSwgcy5zdHJzdGFydCAtIHMuYmxvY2tfc3RhcnQsIGxhc3QpO1xuICBzLmJsb2NrX3N0YXJ0ID0gcy5zdHJzdGFydDtcbiAgZmx1c2hfcGVuZGluZyhzLnN0cm0pO1xufVxuXG5cbmZ1bmN0aW9uIHB1dF9ieXRlKHMsIGIpIHtcbiAgcy5wZW5kaW5nX2J1ZltzLnBlbmRpbmcrK10gPSBiO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFB1dCBhIHNob3J0IGluIHRoZSBwZW5kaW5nIGJ1ZmZlci4gVGhlIDE2LWJpdCB2YWx1ZSBpcyBwdXQgaW4gTVNCIG9yZGVyLlxuICogSU4gYXNzZXJ0aW9uOiB0aGUgc3RyZWFtIHN0YXRlIGlzIGNvcnJlY3QgYW5kIHRoZXJlIGlzIGVub3VnaCByb29tIGluXG4gKiBwZW5kaW5nX2J1Zi5cbiAqL1xuZnVuY3Rpb24gcHV0U2hvcnRNU0IocywgYikge1xuLy8gIHB1dF9ieXRlKHMsIChCeXRlKShiID4+IDgpKTtcbi8vICBwdXRfYnl0ZShzLCAoQnl0ZSkoYiAmIDB4ZmYpKTtcbiAgcy5wZW5kaW5nX2J1ZltzLnBlbmRpbmcrK10gPSAoYiA+Pj4gOCkgJiAweGZmO1xuICBzLnBlbmRpbmdfYnVmW3MucGVuZGluZysrXSA9IGIgJiAweGZmO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogUmVhZCBhIG5ldyBidWZmZXIgZnJvbSB0aGUgY3VycmVudCBpbnB1dCBzdHJlYW0sIHVwZGF0ZSB0aGUgYWRsZXIzMlxuICogYW5kIHRvdGFsIG51bWJlciBvZiBieXRlcyByZWFkLiAgQWxsIGRlZmxhdGUoKSBpbnB1dCBnb2VzIHRocm91Z2hcbiAqIHRoaXMgZnVuY3Rpb24gc28gc29tZSBhcHBsaWNhdGlvbnMgbWF5IHdpc2ggdG8gbW9kaWZ5IGl0IHRvIGF2b2lkXG4gKiBhbGxvY2F0aW5nIGEgbGFyZ2Ugc3RybS0+aW5wdXQgYnVmZmVyIGFuZCBjb3B5aW5nIGZyb20gaXQuXG4gKiAoU2VlIGFsc28gZmx1c2hfcGVuZGluZygpKS5cbiAqL1xuZnVuY3Rpb24gcmVhZF9idWYoc3RybSwgYnVmLCBzdGFydCwgc2l6ZSkge1xuICB2YXIgbGVuID0gc3RybS5hdmFpbF9pbjtcblxuICBpZiAobGVuID4gc2l6ZSkgeyBsZW4gPSBzaXplOyB9XG4gIGlmIChsZW4gPT09IDApIHsgcmV0dXJuIDA7IH1cblxuICBzdHJtLmF2YWlsX2luIC09IGxlbjtcblxuICAvLyB6bWVtY3B5KGJ1Ziwgc3RybS0+bmV4dF9pbiwgbGVuKTtcbiAgdXRpbHMuYXJyYXlTZXQoYnVmLCBzdHJtLmlucHV0LCBzdHJtLm5leHRfaW4sIGxlbiwgc3RhcnQpO1xuICBpZiAoc3RybS5zdGF0ZS53cmFwID09PSAxKSB7XG4gICAgc3RybS5hZGxlciA9IGFkbGVyMzIoc3RybS5hZGxlciwgYnVmLCBsZW4sIHN0YXJ0KTtcbiAgfVxuXG4gIGVsc2UgaWYgKHN0cm0uc3RhdGUud3JhcCA9PT0gMikge1xuICAgIHN0cm0uYWRsZXIgPSBjcmMzMihzdHJtLmFkbGVyLCBidWYsIGxlbiwgc3RhcnQpO1xuICB9XG5cbiAgc3RybS5uZXh0X2luICs9IGxlbjtcbiAgc3RybS50b3RhbF9pbiArPSBsZW47XG5cbiAgcmV0dXJuIGxlbjtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNldCBtYXRjaF9zdGFydCB0byB0aGUgbG9uZ2VzdCBtYXRjaCBzdGFydGluZyBhdCB0aGUgZ2l2ZW4gc3RyaW5nIGFuZFxuICogcmV0dXJuIGl0cyBsZW5ndGguIE1hdGNoZXMgc2hvcnRlciBvciBlcXVhbCB0byBwcmV2X2xlbmd0aCBhcmUgZGlzY2FyZGVkLFxuICogaW4gd2hpY2ggY2FzZSB0aGUgcmVzdWx0IGlzIGVxdWFsIHRvIHByZXZfbGVuZ3RoIGFuZCBtYXRjaF9zdGFydCBpc1xuICogZ2FyYmFnZS5cbiAqIElOIGFzc2VydGlvbnM6IGN1cl9tYXRjaCBpcyB0aGUgaGVhZCBvZiB0aGUgaGFzaCBjaGFpbiBmb3IgdGhlIGN1cnJlbnRcbiAqICAgc3RyaW5nIChzdHJzdGFydCkgYW5kIGl0cyBkaXN0YW5jZSBpcyA8PSBNQVhfRElTVCwgYW5kIHByZXZfbGVuZ3RoID49IDFcbiAqIE9VVCBhc3NlcnRpb246IHRoZSBtYXRjaCBsZW5ndGggaXMgbm90IGdyZWF0ZXIgdGhhbiBzLT5sb29rYWhlYWQuXG4gKi9cbmZ1bmN0aW9uIGxvbmdlc3RfbWF0Y2gocywgY3VyX21hdGNoKSB7XG4gIHZhciBjaGFpbl9sZW5ndGggPSBzLm1heF9jaGFpbl9sZW5ndGg7ICAgICAgLyogbWF4IGhhc2ggY2hhaW4gbGVuZ3RoICovXG4gIHZhciBzY2FuID0gcy5zdHJzdGFydDsgLyogY3VycmVudCBzdHJpbmcgKi9cbiAgdmFyIG1hdGNoOyAgICAgICAgICAgICAgICAgICAgICAgLyogbWF0Y2hlZCBzdHJpbmcgKi9cbiAgdmFyIGxlbjsgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBsZW5ndGggb2YgY3VycmVudCBtYXRjaCAqL1xuICB2YXIgYmVzdF9sZW4gPSBzLnByZXZfbGVuZ3RoOyAgICAgICAgICAgICAgLyogYmVzdCBtYXRjaCBsZW5ndGggc28gZmFyICovXG4gIHZhciBuaWNlX21hdGNoID0gcy5uaWNlX21hdGNoOyAgICAgICAgICAgICAvKiBzdG9wIGlmIG1hdGNoIGxvbmcgZW5vdWdoICovXG4gIHZhciBsaW1pdCA9IChzLnN0cnN0YXJ0ID4gKHMud19zaXplIC0gTUlOX0xPT0tBSEVBRCkpID9cbiAgICAgIHMuc3Ryc3RhcnQgLSAocy53X3NpemUgLSBNSU5fTE9PS0FIRUFEKSA6IDAvKk5JTCovO1xuXG4gIHZhciBfd2luID0gcy53aW5kb3c7IC8vIHNob3J0Y3V0XG5cbiAgdmFyIHdtYXNrID0gcy53X21hc2s7XG4gIHZhciBwcmV2ICA9IHMucHJldjtcblxuICAvKiBTdG9wIHdoZW4gY3VyX21hdGNoIGJlY29tZXMgPD0gbGltaXQuIFRvIHNpbXBsaWZ5IHRoZSBjb2RlLFxuICAgKiB3ZSBwcmV2ZW50IG1hdGNoZXMgd2l0aCB0aGUgc3RyaW5nIG9mIHdpbmRvdyBpbmRleCAwLlxuICAgKi9cblxuICB2YXIgc3RyZW5kID0gcy5zdHJzdGFydCArIE1BWF9NQVRDSDtcbiAgdmFyIHNjYW5fZW5kMSAgPSBfd2luW3NjYW4gKyBiZXN0X2xlbiAtIDFdO1xuICB2YXIgc2Nhbl9lbmQgICA9IF93aW5bc2NhbiArIGJlc3RfbGVuXTtcblxuICAvKiBUaGUgY29kZSBpcyBvcHRpbWl6ZWQgZm9yIEhBU0hfQklUUyA+PSA4IGFuZCBNQVhfTUFUQ0gtMiBtdWx0aXBsZSBvZiAxNi5cbiAgICogSXQgaXMgZWFzeSB0byBnZXQgcmlkIG9mIHRoaXMgb3B0aW1pemF0aW9uIGlmIG5lY2Vzc2FyeS5cbiAgICovXG4gIC8vIEFzc2VydChzLT5oYXNoX2JpdHMgPj0gOCAmJiBNQVhfTUFUQ0ggPT0gMjU4LCBcIkNvZGUgdG9vIGNsZXZlclwiKTtcblxuICAvKiBEbyBub3Qgd2FzdGUgdG9vIG11Y2ggdGltZSBpZiB3ZSBhbHJlYWR5IGhhdmUgYSBnb29kIG1hdGNoOiAqL1xuICBpZiAocy5wcmV2X2xlbmd0aCA+PSBzLmdvb2RfbWF0Y2gpIHtcbiAgICBjaGFpbl9sZW5ndGggPj49IDI7XG4gIH1cbiAgLyogRG8gbm90IGxvb2sgZm9yIG1hdGNoZXMgYmV5b25kIHRoZSBlbmQgb2YgdGhlIGlucHV0LiBUaGlzIGlzIG5lY2Vzc2FyeVxuICAgKiB0byBtYWtlIGRlZmxhdGUgZGV0ZXJtaW5pc3RpYy5cbiAgICovXG4gIGlmIChuaWNlX21hdGNoID4gcy5sb29rYWhlYWQpIHsgbmljZV9tYXRjaCA9IHMubG9va2FoZWFkOyB9XG5cbiAgLy8gQXNzZXJ0KCh1bGcpcy0+c3Ryc3RhcnQgPD0gcy0+d2luZG93X3NpemUtTUlOX0xPT0tBSEVBRCwgXCJuZWVkIGxvb2thaGVhZFwiKTtcblxuICBkbyB7XG4gICAgLy8gQXNzZXJ0KGN1cl9tYXRjaCA8IHMtPnN0cnN0YXJ0LCBcIm5vIGZ1dHVyZVwiKTtcbiAgICBtYXRjaCA9IGN1cl9tYXRjaDtcblxuICAgIC8qIFNraXAgdG8gbmV4dCBtYXRjaCBpZiB0aGUgbWF0Y2ggbGVuZ3RoIGNhbm5vdCBpbmNyZWFzZVxuICAgICAqIG9yIGlmIHRoZSBtYXRjaCBsZW5ndGggaXMgbGVzcyB0aGFuIDIuICBOb3RlIHRoYXQgdGhlIGNoZWNrcyBiZWxvd1xuICAgICAqIGZvciBpbnN1ZmZpY2llbnQgbG9va2FoZWFkIG9ubHkgb2NjdXIgb2NjYXNpb25hbGx5IGZvciBwZXJmb3JtYW5jZVxuICAgICAqIHJlYXNvbnMuICBUaGVyZWZvcmUgdW5pbml0aWFsaXplZCBtZW1vcnkgd2lsbCBiZSBhY2Nlc3NlZCwgYW5kXG4gICAgICogY29uZGl0aW9uYWwganVtcHMgd2lsbCBiZSBtYWRlIHRoYXQgZGVwZW5kIG9uIHRob3NlIHZhbHVlcy5cbiAgICAgKiBIb3dldmVyIHRoZSBsZW5ndGggb2YgdGhlIG1hdGNoIGlzIGxpbWl0ZWQgdG8gdGhlIGxvb2thaGVhZCwgc29cbiAgICAgKiB0aGUgb3V0cHV0IG9mIGRlZmxhdGUgaXMgbm90IGFmZmVjdGVkIGJ5IHRoZSB1bmluaXRpYWxpemVkIHZhbHVlcy5cbiAgICAgKi9cblxuICAgIGlmIChfd2luW21hdGNoICsgYmVzdF9sZW5dICAgICAhPT0gc2Nhbl9lbmQgIHx8XG4gICAgICAgIF93aW5bbWF0Y2ggKyBiZXN0X2xlbiAtIDFdICE9PSBzY2FuX2VuZDEgfHxcbiAgICAgICAgX3dpblttYXRjaF0gICAgICAgICAgICAgICAgIT09IF93aW5bc2Nhbl0gfHxcbiAgICAgICAgX3dpblsrK21hdGNoXSAgICAgICAgICAgICAgIT09IF93aW5bc2NhbiArIDFdKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvKiBUaGUgY2hlY2sgYXQgYmVzdF9sZW4tMSBjYW4gYmUgcmVtb3ZlZCBiZWNhdXNlIGl0IHdpbGwgYmUgbWFkZVxuICAgICAqIGFnYWluIGxhdGVyLiAoVGhpcyBoZXVyaXN0aWMgaXMgbm90IGFsd2F5cyBhIHdpbi4pXG4gICAgICogSXQgaXMgbm90IG5lY2Vzc2FyeSB0byBjb21wYXJlIHNjYW5bMl0gYW5kIG1hdGNoWzJdIHNpbmNlIHRoZXlcbiAgICAgKiBhcmUgYWx3YXlzIGVxdWFsIHdoZW4gdGhlIG90aGVyIGJ5dGVzIG1hdGNoLCBnaXZlbiB0aGF0XG4gICAgICogdGhlIGhhc2gga2V5cyBhcmUgZXF1YWwgYW5kIHRoYXQgSEFTSF9CSVRTID49IDguXG4gICAgICovXG4gICAgc2NhbiArPSAyO1xuICAgIG1hdGNoKys7XG4gICAgLy8gQXNzZXJ0KCpzY2FuID09ICptYXRjaCwgXCJtYXRjaFsyXT9cIik7XG5cbiAgICAvKiBXZSBjaGVjayBmb3IgaW5zdWZmaWNpZW50IGxvb2thaGVhZCBvbmx5IGV2ZXJ5IDh0aCBjb21wYXJpc29uO1xuICAgICAqIHRoZSAyNTZ0aCBjaGVjayB3aWxsIGJlIG1hZGUgYXQgc3Ryc3RhcnQrMjU4LlxuICAgICAqL1xuICAgIGRvIHtcbiAgICAgIC8qanNoaW50IG5vZW1wdHk6ZmFsc2UqL1xuICAgIH0gd2hpbGUgKF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJiBfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiZcbiAgICAgICAgICAgICBfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiYgX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmXG4gICAgICAgICAgICAgX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmIF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJlxuICAgICAgICAgICAgIF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJiBfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiZcbiAgICAgICAgICAgICBzY2FuIDwgc3RyZW5kKTtcblxuICAgIC8vIEFzc2VydChzY2FuIDw9IHMtPndpbmRvdysodW5zaWduZWQpKHMtPndpbmRvd19zaXplLTEpLCBcIndpbGQgc2NhblwiKTtcblxuICAgIGxlbiA9IE1BWF9NQVRDSCAtIChzdHJlbmQgLSBzY2FuKTtcbiAgICBzY2FuID0gc3RyZW5kIC0gTUFYX01BVENIO1xuXG4gICAgaWYgKGxlbiA+IGJlc3RfbGVuKSB7XG4gICAgICBzLm1hdGNoX3N0YXJ0ID0gY3VyX21hdGNoO1xuICAgICAgYmVzdF9sZW4gPSBsZW47XG4gICAgICBpZiAobGVuID49IG5pY2VfbWF0Y2gpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBzY2FuX2VuZDEgID0gX3dpbltzY2FuICsgYmVzdF9sZW4gLSAxXTtcbiAgICAgIHNjYW5fZW5kICAgPSBfd2luW3NjYW4gKyBiZXN0X2xlbl07XG4gICAgfVxuICB9IHdoaWxlICgoY3VyX21hdGNoID0gcHJldltjdXJfbWF0Y2ggJiB3bWFza10pID4gbGltaXQgJiYgLS1jaGFpbl9sZW5ndGggIT09IDApO1xuXG4gIGlmIChiZXN0X2xlbiA8PSBzLmxvb2thaGVhZCkge1xuICAgIHJldHVybiBiZXN0X2xlbjtcbiAgfVxuICByZXR1cm4gcy5sb29rYWhlYWQ7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBGaWxsIHRoZSB3aW5kb3cgd2hlbiB0aGUgbG9va2FoZWFkIGJlY29tZXMgaW5zdWZmaWNpZW50LlxuICogVXBkYXRlcyBzdHJzdGFydCBhbmQgbG9va2FoZWFkLlxuICpcbiAqIElOIGFzc2VydGlvbjogbG9va2FoZWFkIDwgTUlOX0xPT0tBSEVBRFxuICogT1VUIGFzc2VydGlvbnM6IHN0cnN0YXJ0IDw9IHdpbmRvd19zaXplLU1JTl9MT09LQUhFQURcbiAqICAgIEF0IGxlYXN0IG9uZSBieXRlIGhhcyBiZWVuIHJlYWQsIG9yIGF2YWlsX2luID09IDA7IHJlYWRzIGFyZVxuICogICAgcGVyZm9ybWVkIGZvciBhdCBsZWFzdCB0d28gYnl0ZXMgKHJlcXVpcmVkIGZvciB0aGUgemlwIHRyYW5zbGF0ZV9lb2xcbiAqICAgIG9wdGlvbiAtLSBub3Qgc3VwcG9ydGVkIGhlcmUpLlxuICovXG5mdW5jdGlvbiBmaWxsX3dpbmRvdyhzKSB7XG4gIHZhciBfd19zaXplID0gcy53X3NpemU7XG4gIHZhciBwLCBuLCBtLCBtb3JlLCBzdHI7XG5cbiAgLy9Bc3NlcnQocy0+bG9va2FoZWFkIDwgTUlOX0xPT0tBSEVBRCwgXCJhbHJlYWR5IGVub3VnaCBsb29rYWhlYWRcIik7XG5cbiAgZG8ge1xuICAgIG1vcmUgPSBzLndpbmRvd19zaXplIC0gcy5sb29rYWhlYWQgLSBzLnN0cnN0YXJ0O1xuXG4gICAgLy8gSlMgaW50cyBoYXZlIDMyIGJpdCwgYmxvY2sgYmVsb3cgbm90IG5lZWRlZFxuICAgIC8qIERlYWwgd2l0aCAhQCMkJSA2NEsgbGltaXQ6ICovXG4gICAgLy9pZiAoc2l6ZW9mKGludCkgPD0gMikge1xuICAgIC8vICAgIGlmIChtb3JlID09IDAgJiYgcy0+c3Ryc3RhcnQgPT0gMCAmJiBzLT5sb29rYWhlYWQgPT0gMCkge1xuICAgIC8vICAgICAgICBtb3JlID0gd3NpemU7XG4gICAgLy9cbiAgICAvLyAgfSBlbHNlIGlmIChtb3JlID09ICh1bnNpZ25lZCkoLTEpKSB7XG4gICAgLy8gICAgICAgIC8qIFZlcnkgdW5saWtlbHksIGJ1dCBwb3NzaWJsZSBvbiAxNiBiaXQgbWFjaGluZSBpZlxuICAgIC8vICAgICAgICAgKiBzdHJzdGFydCA9PSAwICYmIGxvb2thaGVhZCA9PSAxIChpbnB1dCBkb25lIGEgYnl0ZSBhdCB0aW1lKVxuICAgIC8vICAgICAgICAgKi9cbiAgICAvLyAgICAgICAgbW9yZS0tO1xuICAgIC8vICAgIH1cbiAgICAvL31cblxuXG4gICAgLyogSWYgdGhlIHdpbmRvdyBpcyBhbG1vc3QgZnVsbCBhbmQgdGhlcmUgaXMgaW5zdWZmaWNpZW50IGxvb2thaGVhZCxcbiAgICAgKiBtb3ZlIHRoZSB1cHBlciBoYWxmIHRvIHRoZSBsb3dlciBvbmUgdG8gbWFrZSByb29tIGluIHRoZSB1cHBlciBoYWxmLlxuICAgICAqL1xuICAgIGlmIChzLnN0cnN0YXJ0ID49IF93X3NpemUgKyAoX3dfc2l6ZSAtIE1JTl9MT09LQUhFQUQpKSB7XG5cbiAgICAgIHV0aWxzLmFycmF5U2V0KHMud2luZG93LCBzLndpbmRvdywgX3dfc2l6ZSwgX3dfc2l6ZSwgMCk7XG4gICAgICBzLm1hdGNoX3N0YXJ0IC09IF93X3NpemU7XG4gICAgICBzLnN0cnN0YXJ0IC09IF93X3NpemU7XG4gICAgICAvKiB3ZSBub3cgaGF2ZSBzdHJzdGFydCA+PSBNQVhfRElTVCAqL1xuICAgICAgcy5ibG9ja19zdGFydCAtPSBfd19zaXplO1xuXG4gICAgICAvKiBTbGlkZSB0aGUgaGFzaCB0YWJsZSAoY291bGQgYmUgYXZvaWRlZCB3aXRoIDMyIGJpdCB2YWx1ZXNcbiAgICAgICBhdCB0aGUgZXhwZW5zZSBvZiBtZW1vcnkgdXNhZ2UpLiBXZSBzbGlkZSBldmVuIHdoZW4gbGV2ZWwgPT0gMFxuICAgICAgIHRvIGtlZXAgdGhlIGhhc2ggdGFibGUgY29uc2lzdGVudCBpZiB3ZSBzd2l0Y2ggYmFjayB0byBsZXZlbCA+IDBcbiAgICAgICBsYXRlci4gKFVzaW5nIGxldmVsIDAgcGVybWFuZW50bHkgaXMgbm90IGFuIG9wdGltYWwgdXNhZ2Ugb2ZcbiAgICAgICB6bGliLCBzbyB3ZSBkb24ndCBjYXJlIGFib3V0IHRoaXMgcGF0aG9sb2dpY2FsIGNhc2UuKVxuICAgICAgICovXG5cbiAgICAgIG4gPSBzLmhhc2hfc2l6ZTtcbiAgICAgIHAgPSBuO1xuICAgICAgZG8ge1xuICAgICAgICBtID0gcy5oZWFkWy0tcF07XG4gICAgICAgIHMuaGVhZFtwXSA9IChtID49IF93X3NpemUgPyBtIC0gX3dfc2l6ZSA6IDApO1xuICAgICAgfSB3aGlsZSAoLS1uKTtcblxuICAgICAgbiA9IF93X3NpemU7XG4gICAgICBwID0gbjtcbiAgICAgIGRvIHtcbiAgICAgICAgbSA9IHMucHJldlstLXBdO1xuICAgICAgICBzLnByZXZbcF0gPSAobSA+PSBfd19zaXplID8gbSAtIF93X3NpemUgOiAwKTtcbiAgICAgICAgLyogSWYgbiBpcyBub3Qgb24gYW55IGhhc2ggY2hhaW4sIHByZXZbbl0gaXMgZ2FyYmFnZSBidXRcbiAgICAgICAgICogaXRzIHZhbHVlIHdpbGwgbmV2ZXIgYmUgdXNlZC5cbiAgICAgICAgICovXG4gICAgICB9IHdoaWxlICgtLW4pO1xuXG4gICAgICBtb3JlICs9IF93X3NpemU7XG4gICAgfVxuICAgIGlmIChzLnN0cm0uYXZhaWxfaW4gPT09IDApIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8qIElmIHRoZXJlIHdhcyBubyBzbGlkaW5nOlxuICAgICAqICAgIHN0cnN0YXJ0IDw9IFdTSVpFK01BWF9ESVNULTEgJiYgbG9va2FoZWFkIDw9IE1JTl9MT09LQUhFQUQgLSAxICYmXG4gICAgICogICAgbW9yZSA9PSB3aW5kb3dfc2l6ZSAtIGxvb2thaGVhZCAtIHN0cnN0YXJ0XG4gICAgICogPT4gbW9yZSA+PSB3aW5kb3dfc2l6ZSAtIChNSU5fTE9PS0FIRUFELTEgKyBXU0laRSArIE1BWF9ESVNULTEpXG4gICAgICogPT4gbW9yZSA+PSB3aW5kb3dfc2l6ZSAtIDIqV1NJWkUgKyAyXG4gICAgICogSW4gdGhlIEJJR19NRU0gb3IgTU1BUCBjYXNlIChub3QgeWV0IHN1cHBvcnRlZCksXG4gICAgICogICB3aW5kb3dfc2l6ZSA9PSBpbnB1dF9zaXplICsgTUlOX0xPT0tBSEVBRCAgJiZcbiAgICAgKiAgIHN0cnN0YXJ0ICsgcy0+bG9va2FoZWFkIDw9IGlucHV0X3NpemUgPT4gbW9yZSA+PSBNSU5fTE9PS0FIRUFELlxuICAgICAqIE90aGVyd2lzZSwgd2luZG93X3NpemUgPT0gMipXU0laRSBzbyBtb3JlID49IDIuXG4gICAgICogSWYgdGhlcmUgd2FzIHNsaWRpbmcsIG1vcmUgPj0gV1NJWkUuIFNvIGluIGFsbCBjYXNlcywgbW9yZSA+PSAyLlxuICAgICAqL1xuICAgIC8vQXNzZXJ0KG1vcmUgPj0gMiwgXCJtb3JlIDwgMlwiKTtcbiAgICBuID0gcmVhZF9idWYocy5zdHJtLCBzLndpbmRvdywgcy5zdHJzdGFydCArIHMubG9va2FoZWFkLCBtb3JlKTtcbiAgICBzLmxvb2thaGVhZCArPSBuO1xuXG4gICAgLyogSW5pdGlhbGl6ZSB0aGUgaGFzaCB2YWx1ZSBub3cgdGhhdCB3ZSBoYXZlIHNvbWUgaW5wdXQ6ICovXG4gICAgaWYgKHMubG9va2FoZWFkICsgcy5pbnNlcnQgPj0gTUlOX01BVENIKSB7XG4gICAgICBzdHIgPSBzLnN0cnN0YXJ0IC0gcy5pbnNlcnQ7XG4gICAgICBzLmluc19oID0gcy53aW5kb3dbc3RyXTtcblxuICAgICAgLyogVVBEQVRFX0hBU0gocywgcy0+aW5zX2gsIHMtPndpbmRvd1tzdHIgKyAxXSk7ICovXG4gICAgICBzLmluc19oID0gKChzLmluc19oIDw8IHMuaGFzaF9zaGlmdCkgXiBzLndpbmRvd1tzdHIgKyAxXSkgJiBzLmhhc2hfbWFzaztcbi8vI2lmIE1JTl9NQVRDSCAhPSAzXG4vLyAgICAgICAgQ2FsbCB1cGRhdGVfaGFzaCgpIE1JTl9NQVRDSC0zIG1vcmUgdGltZXNcbi8vI2VuZGlmXG4gICAgICB3aGlsZSAocy5pbnNlcnQpIHtcbiAgICAgICAgLyogVVBEQVRFX0hBU0gocywgcy0+aW5zX2gsIHMtPndpbmRvd1tzdHIgKyBNSU5fTUFUQ0gtMV0pOyAqL1xuICAgICAgICBzLmluc19oID0gKChzLmluc19oIDw8IHMuaGFzaF9zaGlmdCkgXiBzLndpbmRvd1tzdHIgKyBNSU5fTUFUQ0ggLSAxXSkgJiBzLmhhc2hfbWFzaztcblxuICAgICAgICBzLnByZXZbc3RyICYgcy53X21hc2tdID0gcy5oZWFkW3MuaW5zX2hdO1xuICAgICAgICBzLmhlYWRbcy5pbnNfaF0gPSBzdHI7XG4gICAgICAgIHN0cisrO1xuICAgICAgICBzLmluc2VydC0tO1xuICAgICAgICBpZiAocy5sb29rYWhlYWQgKyBzLmluc2VydCA8IE1JTl9NQVRDSCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8qIElmIHRoZSB3aG9sZSBpbnB1dCBoYXMgbGVzcyB0aGFuIE1JTl9NQVRDSCBieXRlcywgaW5zX2ggaXMgZ2FyYmFnZSxcbiAgICAgKiBidXQgdGhpcyBpcyBub3QgaW1wb3J0YW50IHNpbmNlIG9ubHkgbGl0ZXJhbCBieXRlcyB3aWxsIGJlIGVtaXR0ZWQuXG4gICAgICovXG5cbiAgfSB3aGlsZSAocy5sb29rYWhlYWQgPCBNSU5fTE9PS0FIRUFEICYmIHMuc3RybS5hdmFpbF9pbiAhPT0gMCk7XG5cbiAgLyogSWYgdGhlIFdJTl9JTklUIGJ5dGVzIGFmdGVyIHRoZSBlbmQgb2YgdGhlIGN1cnJlbnQgZGF0YSBoYXZlIG5ldmVyIGJlZW5cbiAgICogd3JpdHRlbiwgdGhlbiB6ZXJvIHRob3NlIGJ5dGVzIGluIG9yZGVyIHRvIGF2b2lkIG1lbW9yeSBjaGVjayByZXBvcnRzIG9mXG4gICAqIHRoZSB1c2Ugb2YgdW5pbml0aWFsaXplZCAob3IgdW5pbml0aWFsaXNlZCBhcyBKdWxpYW4gd3JpdGVzKSBieXRlcyBieVxuICAgKiB0aGUgbG9uZ2VzdCBtYXRjaCByb3V0aW5lcy4gIFVwZGF0ZSB0aGUgaGlnaCB3YXRlciBtYXJrIGZvciB0aGUgbmV4dFxuICAgKiB0aW1lIHRocm91Z2ggaGVyZS4gIFdJTl9JTklUIGlzIHNldCB0byBNQVhfTUFUQ0ggc2luY2UgdGhlIGxvbmdlc3QgbWF0Y2hcbiAgICogcm91dGluZXMgYWxsb3cgc2Nhbm5pbmcgdG8gc3Ryc3RhcnQgKyBNQVhfTUFUQ0gsIGlnbm9yaW5nIGxvb2thaGVhZC5cbiAgICovXG4vLyAgaWYgKHMuaGlnaF93YXRlciA8IHMud2luZG93X3NpemUpIHtcbi8vICAgIHZhciBjdXJyID0gcy5zdHJzdGFydCArIHMubG9va2FoZWFkO1xuLy8gICAgdmFyIGluaXQgPSAwO1xuLy9cbi8vICAgIGlmIChzLmhpZ2hfd2F0ZXIgPCBjdXJyKSB7XG4vLyAgICAgIC8qIFByZXZpb3VzIGhpZ2ggd2F0ZXIgbWFyayBiZWxvdyBjdXJyZW50IGRhdGEgLS0gemVybyBXSU5fSU5JVFxuLy8gICAgICAgKiBieXRlcyBvciB1cCB0byBlbmQgb2Ygd2luZG93LCB3aGljaGV2ZXIgaXMgbGVzcy5cbi8vICAgICAgICovXG4vLyAgICAgIGluaXQgPSBzLndpbmRvd19zaXplIC0gY3Vycjtcbi8vICAgICAgaWYgKGluaXQgPiBXSU5fSU5JVClcbi8vICAgICAgICBpbml0ID0gV0lOX0lOSVQ7XG4vLyAgICAgIHptZW16ZXJvKHMtPndpbmRvdyArIGN1cnIsICh1bnNpZ25lZClpbml0KTtcbi8vICAgICAgcy0+aGlnaF93YXRlciA9IGN1cnIgKyBpbml0O1xuLy8gICAgfVxuLy8gICAgZWxzZSBpZiAocy0+aGlnaF93YXRlciA8ICh1bGcpY3VyciArIFdJTl9JTklUKSB7XG4vLyAgICAgIC8qIEhpZ2ggd2F0ZXIgbWFyayBhdCBvciBhYm92ZSBjdXJyZW50IGRhdGEsIGJ1dCBiZWxvdyBjdXJyZW50IGRhdGFcbi8vICAgICAgICogcGx1cyBXSU5fSU5JVCAtLSB6ZXJvIG91dCB0byBjdXJyZW50IGRhdGEgcGx1cyBXSU5fSU5JVCwgb3IgdXBcbi8vICAgICAgICogdG8gZW5kIG9mIHdpbmRvdywgd2hpY2hldmVyIGlzIGxlc3MuXG4vLyAgICAgICAqL1xuLy8gICAgICBpbml0ID0gKHVsZyljdXJyICsgV0lOX0lOSVQgLSBzLT5oaWdoX3dhdGVyO1xuLy8gICAgICBpZiAoaW5pdCA+IHMtPndpbmRvd19zaXplIC0gcy0+aGlnaF93YXRlcilcbi8vICAgICAgICBpbml0ID0gcy0+d2luZG93X3NpemUgLSBzLT5oaWdoX3dhdGVyO1xuLy8gICAgICB6bWVtemVybyhzLT53aW5kb3cgKyBzLT5oaWdoX3dhdGVyLCAodW5zaWduZWQpaW5pdCk7XG4vLyAgICAgIHMtPmhpZ2hfd2F0ZXIgKz0gaW5pdDtcbi8vICAgIH1cbi8vICB9XG4vL1xuLy8gIEFzc2VydCgodWxnKXMtPnN0cnN0YXJ0IDw9IHMtPndpbmRvd19zaXplIC0gTUlOX0xPT0tBSEVBRCxcbi8vICAgIFwibm90IGVub3VnaCByb29tIGZvciBzZWFyY2hcIik7XG59XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29weSB3aXRob3V0IGNvbXByZXNzaW9uIGFzIG11Y2ggYXMgcG9zc2libGUgZnJvbSB0aGUgaW5wdXQgc3RyZWFtLCByZXR1cm5cbiAqIHRoZSBjdXJyZW50IGJsb2NrIHN0YXRlLlxuICogVGhpcyBmdW5jdGlvbiBkb2VzIG5vdCBpbnNlcnQgbmV3IHN0cmluZ3MgaW4gdGhlIGRpY3Rpb25hcnkgc2luY2VcbiAqIHVuY29tcHJlc3NpYmxlIGRhdGEgaXMgcHJvYmFibHkgbm90IHVzZWZ1bC4gVGhpcyBmdW5jdGlvbiBpcyB1c2VkXG4gKiBvbmx5IGZvciB0aGUgbGV2ZWw9MCBjb21wcmVzc2lvbiBvcHRpb24uXG4gKiBOT1RFOiB0aGlzIGZ1bmN0aW9uIHNob3VsZCBiZSBvcHRpbWl6ZWQgdG8gYXZvaWQgZXh0cmEgY29weWluZyBmcm9tXG4gKiB3aW5kb3cgdG8gcGVuZGluZ19idWYuXG4gKi9cbmZ1bmN0aW9uIGRlZmxhdGVfc3RvcmVkKHMsIGZsdXNoKSB7XG4gIC8qIFN0b3JlZCBibG9ja3MgYXJlIGxpbWl0ZWQgdG8gMHhmZmZmIGJ5dGVzLCBwZW5kaW5nX2J1ZiBpcyBsaW1pdGVkXG4gICAqIHRvIHBlbmRpbmdfYnVmX3NpemUsIGFuZCBlYWNoIHN0b3JlZCBibG9jayBoYXMgYSA1IGJ5dGUgaGVhZGVyOlxuICAgKi9cbiAgdmFyIG1heF9ibG9ja19zaXplID0gMHhmZmZmO1xuXG4gIGlmIChtYXhfYmxvY2tfc2l6ZSA+IHMucGVuZGluZ19idWZfc2l6ZSAtIDUpIHtcbiAgICBtYXhfYmxvY2tfc2l6ZSA9IHMucGVuZGluZ19idWZfc2l6ZSAtIDU7XG4gIH1cblxuICAvKiBDb3B5IGFzIG11Y2ggYXMgcG9zc2libGUgZnJvbSBpbnB1dCB0byBvdXRwdXQ6ICovXG4gIGZvciAoOzspIHtcbiAgICAvKiBGaWxsIHRoZSB3aW5kb3cgYXMgbXVjaCBhcyBwb3NzaWJsZTogKi9cbiAgICBpZiAocy5sb29rYWhlYWQgPD0gMSkge1xuXG4gICAgICAvL0Fzc2VydChzLT5zdHJzdGFydCA8IHMtPndfc2l6ZStNQVhfRElTVChzKSB8fFxuICAgICAgLy8gIHMtPmJsb2NrX3N0YXJ0ID49IChsb25nKXMtPndfc2l6ZSwgXCJzbGlkZSB0b28gbGF0ZVwiKTtcbi8vICAgICAgaWYgKCEocy5zdHJzdGFydCA8IHMud19zaXplICsgKHMud19zaXplIC0gTUlOX0xPT0tBSEVBRCkgfHxcbi8vICAgICAgICBzLmJsb2NrX3N0YXJ0ID49IHMud19zaXplKSkge1xuLy8gICAgICAgIHRocm93ICBuZXcgRXJyb3IoXCJzbGlkZSB0b28gbGF0ZVwiKTtcbi8vICAgICAgfVxuXG4gICAgICBmaWxsX3dpbmRvdyhzKTtcbiAgICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCAmJiBmbHVzaCA9PT0gWl9OT19GTFVTSCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuXG4gICAgICBpZiAocy5sb29rYWhlYWQgPT09IDApIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICAvKiBmbHVzaCB0aGUgY3VycmVudCBibG9jayAqL1xuICAgIH1cbiAgICAvL0Fzc2VydChzLT5ibG9ja19zdGFydCA+PSAwTCwgXCJibG9jayBnb25lXCIpO1xuLy8gICAgaWYgKHMuYmxvY2tfc3RhcnQgPCAwKSB0aHJvdyBuZXcgRXJyb3IoXCJibG9jayBnb25lXCIpO1xuXG4gICAgcy5zdHJzdGFydCArPSBzLmxvb2thaGVhZDtcbiAgICBzLmxvb2thaGVhZCA9IDA7XG5cbiAgICAvKiBFbWl0IGEgc3RvcmVkIGJsb2NrIGlmIHBlbmRpbmdfYnVmIHdpbGwgYmUgZnVsbDogKi9cbiAgICB2YXIgbWF4X3N0YXJ0ID0gcy5ibG9ja19zdGFydCArIG1heF9ibG9ja19zaXplO1xuXG4gICAgaWYgKHMuc3Ryc3RhcnQgPT09IDAgfHwgcy5zdHJzdGFydCA+PSBtYXhfc3RhcnQpIHtcbiAgICAgIC8qIHN0cnN0YXJ0ID09IDAgaXMgcG9zc2libGUgd2hlbiB3cmFwYXJvdW5kIG9uIDE2LWJpdCBtYWNoaW5lICovXG4gICAgICBzLmxvb2thaGVhZCA9IHMuc3Ryc3RhcnQgLSBtYXhfc3RhcnQ7XG4gICAgICBzLnN0cnN0YXJ0ID0gbWF4X3N0YXJ0O1xuICAgICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgICAgLyoqKi9cblxuXG4gICAgfVxuICAgIC8qIEZsdXNoIGlmIHdlIG1heSBoYXZlIHRvIHNsaWRlLCBvdGhlcndpc2UgYmxvY2tfc3RhcnQgbWF5IGJlY29tZVxuICAgICAqIG5lZ2F0aXZlIGFuZCB0aGUgZGF0YSB3aWxsIGJlIGdvbmU6XG4gICAgICovXG4gICAgaWYgKHMuc3Ryc3RhcnQgLSBzLmJsb2NrX3N0YXJ0ID49IChzLndfc2l6ZSAtIE1JTl9MT09LQUhFQUQpKSB7XG4gICAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG4gICAgICAvKioqL1xuICAgIH1cbiAgfVxuXG4gIHMuaW5zZXJ0ID0gMDtcblxuICBpZiAoZmx1c2ggPT09IFpfRklOSVNIKSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAxKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgdHJ1ZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19GSU5JU0hfU1RBUlRFRDtcbiAgICB9XG4gICAgLyoqKi9cbiAgICByZXR1cm4gQlNfRklOSVNIX0RPTkU7XG4gIH1cblxuICBpZiAocy5zdHJzdGFydCA+IHMuYmxvY2tfc3RhcnQpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgfVxuICAgIC8qKiovXG4gIH1cblxuICByZXR1cm4gQlNfTkVFRF9NT1JFO1xufVxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvbXByZXNzIGFzIG11Y2ggYXMgcG9zc2libGUgZnJvbSB0aGUgaW5wdXQgc3RyZWFtLCByZXR1cm4gdGhlIGN1cnJlbnRcbiAqIGJsb2NrIHN0YXRlLlxuICogVGhpcyBmdW5jdGlvbiBkb2VzIG5vdCBwZXJmb3JtIGxhenkgZXZhbHVhdGlvbiBvZiBtYXRjaGVzIGFuZCBpbnNlcnRzXG4gKiBuZXcgc3RyaW5ncyBpbiB0aGUgZGljdGlvbmFyeSBvbmx5IGZvciB1bm1hdGNoZWQgc3RyaW5ncyBvciBmb3Igc2hvcnRcbiAqIG1hdGNoZXMuIEl0IGlzIHVzZWQgb25seSBmb3IgdGhlIGZhc3QgY29tcHJlc3Npb24gb3B0aW9ucy5cbiAqL1xuZnVuY3Rpb24gZGVmbGF0ZV9mYXN0KHMsIGZsdXNoKSB7XG4gIHZhciBoYXNoX2hlYWQ7ICAgICAgICAvKiBoZWFkIG9mIHRoZSBoYXNoIGNoYWluICovXG4gIHZhciBiZmx1c2g7ICAgICAgICAgICAvKiBzZXQgaWYgY3VycmVudCBibG9jayBtdXN0IGJlIGZsdXNoZWQgKi9cblxuICBmb3IgKDs7KSB7XG4gICAgLyogTWFrZSBzdXJlIHRoYXQgd2UgYWx3YXlzIGhhdmUgZW5vdWdoIGxvb2thaGVhZCwgZXhjZXB0XG4gICAgICogYXQgdGhlIGVuZCBvZiB0aGUgaW5wdXQgZmlsZS4gV2UgbmVlZCBNQVhfTUFUQ0ggYnl0ZXNcbiAgICAgKiBmb3IgdGhlIG5leHQgbWF0Y2gsIHBsdXMgTUlOX01BVENIIGJ5dGVzIHRvIGluc2VydCB0aGVcbiAgICAgKiBzdHJpbmcgZm9sbG93aW5nIHRoZSBuZXh0IG1hdGNoLlxuICAgICAqL1xuICAgIGlmIChzLmxvb2thaGVhZCA8IE1JTl9MT09LQUhFQUQpIHtcbiAgICAgIGZpbGxfd2luZG93KHMpO1xuICAgICAgaWYgKHMubG9va2FoZWFkIDwgTUlOX0xPT0tBSEVBRCAmJiBmbHVzaCA9PT0gWl9OT19GTFVTSCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgICAgaWYgKHMubG9va2FoZWFkID09PSAwKSB7XG4gICAgICAgIGJyZWFrOyAvKiBmbHVzaCB0aGUgY3VycmVudCBibG9jayAqL1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qIEluc2VydCB0aGUgc3RyaW5nIHdpbmRvd1tzdHJzdGFydCAuLiBzdHJzdGFydCsyXSBpbiB0aGVcbiAgICAgKiBkaWN0aW9uYXJ5LCBhbmQgc2V0IGhhc2hfaGVhZCB0byB0aGUgaGVhZCBvZiB0aGUgaGFzaCBjaGFpbjpcbiAgICAgKi9cbiAgICBoYXNoX2hlYWQgPSAwLypOSUwqLztcbiAgICBpZiAocy5sb29rYWhlYWQgPj0gTUlOX01BVENIKSB7XG4gICAgICAvKioqIElOU0VSVF9TVFJJTkcocywgcy5zdHJzdGFydCwgaGFzaF9oZWFkKTsgKioqL1xuICAgICAgcy5pbnNfaCA9ICgocy5pbnNfaCA8PCBzLmhhc2hfc2hpZnQpIF4gcy53aW5kb3dbcy5zdHJzdGFydCArIE1JTl9NQVRDSCAtIDFdKSAmIHMuaGFzaF9tYXNrO1xuICAgICAgaGFzaF9oZWFkID0gcy5wcmV2W3Muc3Ryc3RhcnQgJiBzLndfbWFza10gPSBzLmhlYWRbcy5pbnNfaF07XG4gICAgICBzLmhlYWRbcy5pbnNfaF0gPSBzLnN0cnN0YXJ0O1xuICAgICAgLyoqKi9cbiAgICB9XG5cbiAgICAvKiBGaW5kIHRoZSBsb25nZXN0IG1hdGNoLCBkaXNjYXJkaW5nIHRob3NlIDw9IHByZXZfbGVuZ3RoLlxuICAgICAqIEF0IHRoaXMgcG9pbnQgd2UgaGF2ZSBhbHdheXMgbWF0Y2hfbGVuZ3RoIDwgTUlOX01BVENIXG4gICAgICovXG4gICAgaWYgKGhhc2hfaGVhZCAhPT0gMC8qTklMKi8gJiYgKChzLnN0cnN0YXJ0IC0gaGFzaF9oZWFkKSA8PSAocy53X3NpemUgLSBNSU5fTE9PS0FIRUFEKSkpIHtcbiAgICAgIC8qIFRvIHNpbXBsaWZ5IHRoZSBjb2RlLCB3ZSBwcmV2ZW50IG1hdGNoZXMgd2l0aCB0aGUgc3RyaW5nXG4gICAgICAgKiBvZiB3aW5kb3cgaW5kZXggMCAoaW4gcGFydGljdWxhciB3ZSBoYXZlIHRvIGF2b2lkIGEgbWF0Y2hcbiAgICAgICAqIG9mIHRoZSBzdHJpbmcgd2l0aCBpdHNlbGYgYXQgdGhlIHN0YXJ0IG9mIHRoZSBpbnB1dCBmaWxlKS5cbiAgICAgICAqL1xuICAgICAgcy5tYXRjaF9sZW5ndGggPSBsb25nZXN0X21hdGNoKHMsIGhhc2hfaGVhZCk7XG4gICAgICAvKiBsb25nZXN0X21hdGNoKCkgc2V0cyBtYXRjaF9zdGFydCAqL1xuICAgIH1cbiAgICBpZiAocy5tYXRjaF9sZW5ndGggPj0gTUlOX01BVENIKSB7XG4gICAgICAvLyBjaGVja19tYXRjaChzLCBzLnN0cnN0YXJ0LCBzLm1hdGNoX3N0YXJ0LCBzLm1hdGNoX2xlbmd0aCk7IC8vIGZvciBkZWJ1ZyBvbmx5XG5cbiAgICAgIC8qKiogX3RyX3RhbGx5X2Rpc3Qocywgcy5zdHJzdGFydCAtIHMubWF0Y2hfc3RhcnQsXG4gICAgICAgICAgICAgICAgICAgICBzLm1hdGNoX2xlbmd0aCAtIE1JTl9NQVRDSCwgYmZsdXNoKTsgKioqL1xuICAgICAgYmZsdXNoID0gdHJlZXMuX3RyX3RhbGx5KHMsIHMuc3Ryc3RhcnQgLSBzLm1hdGNoX3N0YXJ0LCBzLm1hdGNoX2xlbmd0aCAtIE1JTl9NQVRDSCk7XG5cbiAgICAgIHMubG9va2FoZWFkIC09IHMubWF0Y2hfbGVuZ3RoO1xuXG4gICAgICAvKiBJbnNlcnQgbmV3IHN0cmluZ3MgaW4gdGhlIGhhc2ggdGFibGUgb25seSBpZiB0aGUgbWF0Y2ggbGVuZ3RoXG4gICAgICAgKiBpcyBub3QgdG9vIGxhcmdlLiBUaGlzIHNhdmVzIHRpbWUgYnV0IGRlZ3JhZGVzIGNvbXByZXNzaW9uLlxuICAgICAgICovXG4gICAgICBpZiAocy5tYXRjaF9sZW5ndGggPD0gcy5tYXhfbGF6eV9tYXRjaC8qbWF4X2luc2VydF9sZW5ndGgqLyAmJiBzLmxvb2thaGVhZCA+PSBNSU5fTUFUQ0gpIHtcbiAgICAgICAgcy5tYXRjaF9sZW5ndGgtLTsgLyogc3RyaW5nIGF0IHN0cnN0YXJ0IGFscmVhZHkgaW4gdGFibGUgKi9cbiAgICAgICAgZG8ge1xuICAgICAgICAgIHMuc3Ryc3RhcnQrKztcbiAgICAgICAgICAvKioqIElOU0VSVF9TVFJJTkcocywgcy5zdHJzdGFydCwgaGFzaF9oZWFkKTsgKioqL1xuICAgICAgICAgIHMuaW5zX2ggPSAoKHMuaW5zX2ggPDwgcy5oYXNoX3NoaWZ0KSBeIHMud2luZG93W3Muc3Ryc3RhcnQgKyBNSU5fTUFUQ0ggLSAxXSkgJiBzLmhhc2hfbWFzaztcbiAgICAgICAgICBoYXNoX2hlYWQgPSBzLnByZXZbcy5zdHJzdGFydCAmIHMud19tYXNrXSA9IHMuaGVhZFtzLmluc19oXTtcbiAgICAgICAgICBzLmhlYWRbcy5pbnNfaF0gPSBzLnN0cnN0YXJ0O1xuICAgICAgICAgIC8qKiovXG4gICAgICAgICAgLyogc3Ryc3RhcnQgbmV2ZXIgZXhjZWVkcyBXU0laRS1NQVhfTUFUQ0gsIHNvIHRoZXJlIGFyZVxuICAgICAgICAgICAqIGFsd2F5cyBNSU5fTUFUQ0ggYnl0ZXMgYWhlYWQuXG4gICAgICAgICAgICovXG4gICAgICAgIH0gd2hpbGUgKC0tcy5tYXRjaF9sZW5ndGggIT09IDApO1xuICAgICAgICBzLnN0cnN0YXJ0Kys7XG4gICAgICB9IGVsc2VcbiAgICAgIHtcbiAgICAgICAgcy5zdHJzdGFydCArPSBzLm1hdGNoX2xlbmd0aDtcbiAgICAgICAgcy5tYXRjaF9sZW5ndGggPSAwO1xuICAgICAgICBzLmluc19oID0gcy53aW5kb3dbcy5zdHJzdGFydF07XG4gICAgICAgIC8qIFVQREFURV9IQVNIKHMsIHMuaW5zX2gsIHMud2luZG93W3Muc3Ryc3RhcnQrMV0pOyAqL1xuICAgICAgICBzLmluc19oID0gKChzLmluc19oIDw8IHMuaGFzaF9zaGlmdCkgXiBzLndpbmRvd1tzLnN0cnN0YXJ0ICsgMV0pICYgcy5oYXNoX21hc2s7XG5cbi8vI2lmIE1JTl9NQVRDSCAhPSAzXG4vLyAgICAgICAgICAgICAgICBDYWxsIFVQREFURV9IQVNIKCkgTUlOX01BVENILTMgbW9yZSB0aW1lc1xuLy8jZW5kaWZcbiAgICAgICAgLyogSWYgbG9va2FoZWFkIDwgTUlOX01BVENILCBpbnNfaCBpcyBnYXJiYWdlLCBidXQgaXQgZG9lcyBub3RcbiAgICAgICAgICogbWF0dGVyIHNpbmNlIGl0IHdpbGwgYmUgcmVjb21wdXRlZCBhdCBuZXh0IGRlZmxhdGUgY2FsbC5cbiAgICAgICAgICovXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8qIE5vIG1hdGNoLCBvdXRwdXQgYSBsaXRlcmFsIGJ5dGUgKi9cbiAgICAgIC8vVHJhY2V2digoc3RkZXJyLFwiJWNcIiwgcy53aW5kb3dbcy5zdHJzdGFydF0pKTtcbiAgICAgIC8qKiogX3RyX3RhbGx5X2xpdChzLCBzLndpbmRvd1tzLnN0cnN0YXJ0XSwgYmZsdXNoKTsgKioqL1xuICAgICAgYmZsdXNoID0gdHJlZXMuX3RyX3RhbGx5KHMsIDAsIHMud2luZG93W3Muc3Ryc3RhcnRdKTtcblxuICAgICAgcy5sb29rYWhlYWQtLTtcbiAgICAgIHMuc3Ryc3RhcnQrKztcbiAgICB9XG4gICAgaWYgKGJmbHVzaCkge1xuICAgICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgICAgLyoqKi9cbiAgICB9XG4gIH1cbiAgcy5pbnNlcnQgPSAoKHMuc3Ryc3RhcnQgPCAoTUlOX01BVENIIC0gMSkpID8gcy5zdHJzdGFydCA6IE1JTl9NQVRDSCAtIDEpO1xuICBpZiAoZmx1c2ggPT09IFpfRklOSVNIKSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAxKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgdHJ1ZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19GSU5JU0hfU1RBUlRFRDtcbiAgICB9XG4gICAgLyoqKi9cbiAgICByZXR1cm4gQlNfRklOSVNIX0RPTkU7XG4gIH1cbiAgaWYgKHMubGFzdF9saXQpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgfVxuICAgIC8qKiovXG4gIH1cbiAgcmV0dXJuIEJTX0JMT0NLX0RPTkU7XG59XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2FtZSBhcyBhYm92ZSwgYnV0IGFjaGlldmVzIGJldHRlciBjb21wcmVzc2lvbi4gV2UgdXNlIGEgbGF6eVxuICogZXZhbHVhdGlvbiBmb3IgbWF0Y2hlczogYSBtYXRjaCBpcyBmaW5hbGx5IGFkb3B0ZWQgb25seSBpZiB0aGVyZSBpc1xuICogbm8gYmV0dGVyIG1hdGNoIGF0IHRoZSBuZXh0IHdpbmRvdyBwb3NpdGlvbi5cbiAqL1xuZnVuY3Rpb24gZGVmbGF0ZV9zbG93KHMsIGZsdXNoKSB7XG4gIHZhciBoYXNoX2hlYWQ7ICAgICAgICAgIC8qIGhlYWQgb2YgaGFzaCBjaGFpbiAqL1xuICB2YXIgYmZsdXNoOyAgICAgICAgICAgICAgLyogc2V0IGlmIGN1cnJlbnQgYmxvY2sgbXVzdCBiZSBmbHVzaGVkICovXG5cbiAgdmFyIG1heF9pbnNlcnQ7XG5cbiAgLyogUHJvY2VzcyB0aGUgaW5wdXQgYmxvY2suICovXG4gIGZvciAoOzspIHtcbiAgICAvKiBNYWtlIHN1cmUgdGhhdCB3ZSBhbHdheXMgaGF2ZSBlbm91Z2ggbG9va2FoZWFkLCBleGNlcHRcbiAgICAgKiBhdCB0aGUgZW5kIG9mIHRoZSBpbnB1dCBmaWxlLiBXZSBuZWVkIE1BWF9NQVRDSCBieXRlc1xuICAgICAqIGZvciB0aGUgbmV4dCBtYXRjaCwgcGx1cyBNSU5fTUFUQ0ggYnl0ZXMgdG8gaW5zZXJ0IHRoZVxuICAgICAqIHN0cmluZyBmb2xsb3dpbmcgdGhlIG5leHQgbWF0Y2guXG4gICAgICovXG4gICAgaWYgKHMubG9va2FoZWFkIDwgTUlOX0xPT0tBSEVBRCkge1xuICAgICAgZmlsbF93aW5kb3cocyk7XG4gICAgICBpZiAocy5sb29rYWhlYWQgPCBNSU5fTE9PS0FIRUFEICYmIGZsdXNoID09PSBaX05PX0ZMVVNIKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG4gICAgICBpZiAocy5sb29rYWhlYWQgPT09IDApIHsgYnJlYWs7IH0gLyogZmx1c2ggdGhlIGN1cnJlbnQgYmxvY2sgKi9cbiAgICB9XG5cbiAgICAvKiBJbnNlcnQgdGhlIHN0cmluZyB3aW5kb3dbc3Ryc3RhcnQgLi4gc3Ryc3RhcnQrMl0gaW4gdGhlXG4gICAgICogZGljdGlvbmFyeSwgYW5kIHNldCBoYXNoX2hlYWQgdG8gdGhlIGhlYWQgb2YgdGhlIGhhc2ggY2hhaW46XG4gICAgICovXG4gICAgaGFzaF9oZWFkID0gMC8qTklMKi87XG4gICAgaWYgKHMubG9va2FoZWFkID49IE1JTl9NQVRDSCkge1xuICAgICAgLyoqKiBJTlNFUlRfU1RSSU5HKHMsIHMuc3Ryc3RhcnQsIGhhc2hfaGVhZCk7ICoqKi9cbiAgICAgIHMuaW5zX2ggPSAoKHMuaW5zX2ggPDwgcy5oYXNoX3NoaWZ0KSBeIHMud2luZG93W3Muc3Ryc3RhcnQgKyBNSU5fTUFUQ0ggLSAxXSkgJiBzLmhhc2hfbWFzaztcbiAgICAgIGhhc2hfaGVhZCA9IHMucHJldltzLnN0cnN0YXJ0ICYgcy53X21hc2tdID0gcy5oZWFkW3MuaW5zX2hdO1xuICAgICAgcy5oZWFkW3MuaW5zX2hdID0gcy5zdHJzdGFydDtcbiAgICAgIC8qKiovXG4gICAgfVxuXG4gICAgLyogRmluZCB0aGUgbG9uZ2VzdCBtYXRjaCwgZGlzY2FyZGluZyB0aG9zZSA8PSBwcmV2X2xlbmd0aC5cbiAgICAgKi9cbiAgICBzLnByZXZfbGVuZ3RoID0gcy5tYXRjaF9sZW5ndGg7XG4gICAgcy5wcmV2X21hdGNoID0gcy5tYXRjaF9zdGFydDtcbiAgICBzLm1hdGNoX2xlbmd0aCA9IE1JTl9NQVRDSCAtIDE7XG5cbiAgICBpZiAoaGFzaF9oZWFkICE9PSAwLypOSUwqLyAmJiBzLnByZXZfbGVuZ3RoIDwgcy5tYXhfbGF6eV9tYXRjaCAmJlxuICAgICAgICBzLnN0cnN0YXJ0IC0gaGFzaF9oZWFkIDw9IChzLndfc2l6ZSAtIE1JTl9MT09LQUhFQUQpLypNQVhfRElTVChzKSovKSB7XG4gICAgICAvKiBUbyBzaW1wbGlmeSB0aGUgY29kZSwgd2UgcHJldmVudCBtYXRjaGVzIHdpdGggdGhlIHN0cmluZ1xuICAgICAgICogb2Ygd2luZG93IGluZGV4IDAgKGluIHBhcnRpY3VsYXIgd2UgaGF2ZSB0byBhdm9pZCBhIG1hdGNoXG4gICAgICAgKiBvZiB0aGUgc3RyaW5nIHdpdGggaXRzZWxmIGF0IHRoZSBzdGFydCBvZiB0aGUgaW5wdXQgZmlsZSkuXG4gICAgICAgKi9cbiAgICAgIHMubWF0Y2hfbGVuZ3RoID0gbG9uZ2VzdF9tYXRjaChzLCBoYXNoX2hlYWQpO1xuICAgICAgLyogbG9uZ2VzdF9tYXRjaCgpIHNldHMgbWF0Y2hfc3RhcnQgKi9cblxuICAgICAgaWYgKHMubWF0Y2hfbGVuZ3RoIDw9IDUgJiZcbiAgICAgICAgIChzLnN0cmF0ZWd5ID09PSBaX0ZJTFRFUkVEIHx8IChzLm1hdGNoX2xlbmd0aCA9PT0gTUlOX01BVENIICYmIHMuc3Ryc3RhcnQgLSBzLm1hdGNoX3N0YXJ0ID4gNDA5Ni8qVE9PX0ZBUiovKSkpIHtcblxuICAgICAgICAvKiBJZiBwcmV2X21hdGNoIGlzIGFsc28gTUlOX01BVENILCBtYXRjaF9zdGFydCBpcyBnYXJiYWdlXG4gICAgICAgICAqIGJ1dCB3ZSB3aWxsIGlnbm9yZSB0aGUgY3VycmVudCBtYXRjaCBhbnl3YXkuXG4gICAgICAgICAqL1xuICAgICAgICBzLm1hdGNoX2xlbmd0aCA9IE1JTl9NQVRDSCAtIDE7XG4gICAgICB9XG4gICAgfVxuICAgIC8qIElmIHRoZXJlIHdhcyBhIG1hdGNoIGF0IHRoZSBwcmV2aW91cyBzdGVwIGFuZCB0aGUgY3VycmVudFxuICAgICAqIG1hdGNoIGlzIG5vdCBiZXR0ZXIsIG91dHB1dCB0aGUgcHJldmlvdXMgbWF0Y2g6XG4gICAgICovXG4gICAgaWYgKHMucHJldl9sZW5ndGggPj0gTUlOX01BVENIICYmIHMubWF0Y2hfbGVuZ3RoIDw9IHMucHJldl9sZW5ndGgpIHtcbiAgICAgIG1heF9pbnNlcnQgPSBzLnN0cnN0YXJ0ICsgcy5sb29rYWhlYWQgLSBNSU5fTUFUQ0g7XG4gICAgICAvKiBEbyBub3QgaW5zZXJ0IHN0cmluZ3MgaW4gaGFzaCB0YWJsZSBiZXlvbmQgdGhpcy4gKi9cblxuICAgICAgLy9jaGVja19tYXRjaChzLCBzLnN0cnN0YXJ0LTEsIHMucHJldl9tYXRjaCwgcy5wcmV2X2xlbmd0aCk7XG5cbiAgICAgIC8qKipfdHJfdGFsbHlfZGlzdChzLCBzLnN0cnN0YXJ0IC0gMSAtIHMucHJldl9tYXRjaCxcbiAgICAgICAgICAgICAgICAgICAgIHMucHJldl9sZW5ndGggLSBNSU5fTUFUQ0gsIGJmbHVzaCk7KioqL1xuICAgICAgYmZsdXNoID0gdHJlZXMuX3RyX3RhbGx5KHMsIHMuc3Ryc3RhcnQgLSAxIC0gcy5wcmV2X21hdGNoLCBzLnByZXZfbGVuZ3RoIC0gTUlOX01BVENIKTtcbiAgICAgIC8qIEluc2VydCBpbiBoYXNoIHRhYmxlIGFsbCBzdHJpbmdzIHVwIHRvIHRoZSBlbmQgb2YgdGhlIG1hdGNoLlxuICAgICAgICogc3Ryc3RhcnQtMSBhbmQgc3Ryc3RhcnQgYXJlIGFscmVhZHkgaW5zZXJ0ZWQuIElmIHRoZXJlIGlzIG5vdFxuICAgICAgICogZW5vdWdoIGxvb2thaGVhZCwgdGhlIGxhc3QgdHdvIHN0cmluZ3MgYXJlIG5vdCBpbnNlcnRlZCBpblxuICAgICAgICogdGhlIGhhc2ggdGFibGUuXG4gICAgICAgKi9cbiAgICAgIHMubG9va2FoZWFkIC09IHMucHJldl9sZW5ndGggLSAxO1xuICAgICAgcy5wcmV2X2xlbmd0aCAtPSAyO1xuICAgICAgZG8ge1xuICAgICAgICBpZiAoKytzLnN0cnN0YXJ0IDw9IG1heF9pbnNlcnQpIHtcbiAgICAgICAgICAvKioqIElOU0VSVF9TVFJJTkcocywgcy5zdHJzdGFydCwgaGFzaF9oZWFkKTsgKioqL1xuICAgICAgICAgIHMuaW5zX2ggPSAoKHMuaW5zX2ggPDwgcy5oYXNoX3NoaWZ0KSBeIHMud2luZG93W3Muc3Ryc3RhcnQgKyBNSU5fTUFUQ0ggLSAxXSkgJiBzLmhhc2hfbWFzaztcbiAgICAgICAgICBoYXNoX2hlYWQgPSBzLnByZXZbcy5zdHJzdGFydCAmIHMud19tYXNrXSA9IHMuaGVhZFtzLmluc19oXTtcbiAgICAgICAgICBzLmhlYWRbcy5pbnNfaF0gPSBzLnN0cnN0YXJ0O1xuICAgICAgICAgIC8qKiovXG4gICAgICAgIH1cbiAgICAgIH0gd2hpbGUgKC0tcy5wcmV2X2xlbmd0aCAhPT0gMCk7XG4gICAgICBzLm1hdGNoX2F2YWlsYWJsZSA9IDA7XG4gICAgICBzLm1hdGNoX2xlbmd0aCA9IE1JTl9NQVRDSCAtIDE7XG4gICAgICBzLnN0cnN0YXJ0Kys7XG5cbiAgICAgIGlmIChiZmx1c2gpIHtcbiAgICAgICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgICB9XG4gICAgICAgIC8qKiovXG4gICAgICB9XG5cbiAgICB9IGVsc2UgaWYgKHMubWF0Y2hfYXZhaWxhYmxlKSB7XG4gICAgICAvKiBJZiB0aGVyZSB3YXMgbm8gbWF0Y2ggYXQgdGhlIHByZXZpb3VzIHBvc2l0aW9uLCBvdXRwdXQgYVxuICAgICAgICogc2luZ2xlIGxpdGVyYWwuIElmIHRoZXJlIHdhcyBhIG1hdGNoIGJ1dCB0aGUgY3VycmVudCBtYXRjaFxuICAgICAgICogaXMgbG9uZ2VyLCB0cnVuY2F0ZSB0aGUgcHJldmlvdXMgbWF0Y2ggdG8gYSBzaW5nbGUgbGl0ZXJhbC5cbiAgICAgICAqL1xuICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsXCIlY1wiLCBzLT53aW5kb3dbcy0+c3Ryc3RhcnQtMV0pKTtcbiAgICAgIC8qKiogX3RyX3RhbGx5X2xpdChzLCBzLndpbmRvd1tzLnN0cnN0YXJ0LTFdLCBiZmx1c2gpOyAqKiovXG4gICAgICBiZmx1c2ggPSB0cmVlcy5fdHJfdGFsbHkocywgMCwgcy53aW5kb3dbcy5zdHJzdGFydCAtIDFdKTtcblxuICAgICAgaWYgKGJmbHVzaCkge1xuICAgICAgICAvKioqIEZMVVNIX0JMT0NLX09OTFkocywgMCkgKioqL1xuICAgICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICAgICAgLyoqKi9cbiAgICAgIH1cbiAgICAgIHMuc3Ryc3RhcnQrKztcbiAgICAgIHMubG9va2FoZWFkLS07XG4gICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvKiBUaGVyZSBpcyBubyBwcmV2aW91cyBtYXRjaCB0byBjb21wYXJlIHdpdGgsIHdhaXQgZm9yXG4gICAgICAgKiB0aGUgbmV4dCBzdGVwIHRvIGRlY2lkZS5cbiAgICAgICAqL1xuICAgICAgcy5tYXRjaF9hdmFpbGFibGUgPSAxO1xuICAgICAgcy5zdHJzdGFydCsrO1xuICAgICAgcy5sb29rYWhlYWQtLTtcbiAgICB9XG4gIH1cbiAgLy9Bc3NlcnQgKGZsdXNoICE9IFpfTk9fRkxVU0gsIFwibm8gZmx1c2g/XCIpO1xuICBpZiAocy5tYXRjaF9hdmFpbGFibGUpIHtcbiAgICAvL1RyYWNldnYoKHN0ZGVycixcIiVjXCIsIHMtPndpbmRvd1tzLT5zdHJzdGFydC0xXSkpO1xuICAgIC8qKiogX3RyX3RhbGx5X2xpdChzLCBzLndpbmRvd1tzLnN0cnN0YXJ0LTFdLCBiZmx1c2gpOyAqKiovXG4gICAgYmZsdXNoID0gdHJlZXMuX3RyX3RhbGx5KHMsIDAsIHMud2luZG93W3Muc3Ryc3RhcnQgLSAxXSk7XG5cbiAgICBzLm1hdGNoX2F2YWlsYWJsZSA9IDA7XG4gIH1cbiAgcy5pbnNlcnQgPSBzLnN0cnN0YXJ0IDwgTUlOX01BVENIIC0gMSA/IHMuc3Ryc3RhcnQgOiBNSU5fTUFUQ0ggLSAxO1xuICBpZiAoZmx1c2ggPT09IFpfRklOSVNIKSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAxKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgdHJ1ZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19GSU5JU0hfU1RBUlRFRDtcbiAgICB9XG4gICAgLyoqKi9cbiAgICByZXR1cm4gQlNfRklOSVNIX0RPTkU7XG4gIH1cbiAgaWYgKHMubGFzdF9saXQpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgfVxuICAgIC8qKiovXG4gIH1cblxuICByZXR1cm4gQlNfQkxPQ0tfRE9ORTtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEZvciBaX1JMRSwgc2ltcGx5IGxvb2sgZm9yIHJ1bnMgb2YgYnl0ZXMsIGdlbmVyYXRlIG1hdGNoZXMgb25seSBvZiBkaXN0YW5jZVxuICogb25lLiAgRG8gbm90IG1haW50YWluIGEgaGFzaCB0YWJsZS4gIChJdCB3aWxsIGJlIHJlZ2VuZXJhdGVkIGlmIHRoaXMgcnVuIG9mXG4gKiBkZWZsYXRlIHN3aXRjaGVzIGF3YXkgZnJvbSBaX1JMRS4pXG4gKi9cbmZ1bmN0aW9uIGRlZmxhdGVfcmxlKHMsIGZsdXNoKSB7XG4gIHZhciBiZmx1c2g7ICAgICAgICAgICAgLyogc2V0IGlmIGN1cnJlbnQgYmxvY2sgbXVzdCBiZSBmbHVzaGVkICovXG4gIHZhciBwcmV2OyAgICAgICAgICAgICAgLyogYnl0ZSBhdCBkaXN0YW5jZSBvbmUgdG8gbWF0Y2ggKi9cbiAgdmFyIHNjYW4sIHN0cmVuZDsgICAgICAvKiBzY2FuIGdvZXMgdXAgdG8gc3RyZW5kIGZvciBsZW5ndGggb2YgcnVuICovXG5cbiAgdmFyIF93aW4gPSBzLndpbmRvdztcblxuICBmb3IgKDs7KSB7XG4gICAgLyogTWFrZSBzdXJlIHRoYXQgd2UgYWx3YXlzIGhhdmUgZW5vdWdoIGxvb2thaGVhZCwgZXhjZXB0XG4gICAgICogYXQgdGhlIGVuZCBvZiB0aGUgaW5wdXQgZmlsZS4gV2UgbmVlZCBNQVhfTUFUQ0ggYnl0ZXNcbiAgICAgKiBmb3IgdGhlIGxvbmdlc3QgcnVuLCBwbHVzIG9uZSBmb3IgdGhlIHVucm9sbGVkIGxvb3AuXG4gICAgICovXG4gICAgaWYgKHMubG9va2FoZWFkIDw9IE1BWF9NQVRDSCkge1xuICAgICAgZmlsbF93aW5kb3cocyk7XG4gICAgICBpZiAocy5sb29rYWhlYWQgPD0gTUFYX01BVENIICYmIGZsdXNoID09PSBaX05PX0ZMVVNIKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG4gICAgICBpZiAocy5sb29rYWhlYWQgPT09IDApIHsgYnJlYWs7IH0gLyogZmx1c2ggdGhlIGN1cnJlbnQgYmxvY2sgKi9cbiAgICB9XG5cbiAgICAvKiBTZWUgaG93IG1hbnkgdGltZXMgdGhlIHByZXZpb3VzIGJ5dGUgcmVwZWF0cyAqL1xuICAgIHMubWF0Y2hfbGVuZ3RoID0gMDtcbiAgICBpZiAocy5sb29rYWhlYWQgPj0gTUlOX01BVENIICYmIHMuc3Ryc3RhcnQgPiAwKSB7XG4gICAgICBzY2FuID0gcy5zdHJzdGFydCAtIDE7XG4gICAgICBwcmV2ID0gX3dpbltzY2FuXTtcbiAgICAgIGlmIChwcmV2ID09PSBfd2luWysrc2Nhbl0gJiYgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmIHByZXYgPT09IF93aW5bKytzY2FuXSkge1xuICAgICAgICBzdHJlbmQgPSBzLnN0cnN0YXJ0ICsgTUFYX01BVENIO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgLypqc2hpbnQgbm9lbXB0eTpmYWxzZSovXG4gICAgICAgIH0gd2hpbGUgKHByZXYgPT09IF93aW5bKytzY2FuXSAmJiBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiZcbiAgICAgICAgICAgICAgICAgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmIHByZXYgPT09IF93aW5bKytzY2FuXSAmJlxuICAgICAgICAgICAgICAgICBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiYgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmXG4gICAgICAgICAgICAgICAgIHByZXYgPT09IF93aW5bKytzY2FuXSAmJiBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiZcbiAgICAgICAgICAgICAgICAgc2NhbiA8IHN0cmVuZCk7XG4gICAgICAgIHMubWF0Y2hfbGVuZ3RoID0gTUFYX01BVENIIC0gKHN0cmVuZCAtIHNjYW4pO1xuICAgICAgICBpZiAocy5tYXRjaF9sZW5ndGggPiBzLmxvb2thaGVhZCkge1xuICAgICAgICAgIHMubWF0Y2hfbGVuZ3RoID0gcy5sb29rYWhlYWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vQXNzZXJ0KHNjYW4gPD0gcy0+d2luZG93Kyh1SW50KShzLT53aW5kb3dfc2l6ZS0xKSwgXCJ3aWxkIHNjYW5cIik7XG4gICAgfVxuXG4gICAgLyogRW1pdCBtYXRjaCBpZiBoYXZlIHJ1biBvZiBNSU5fTUFUQ0ggb3IgbG9uZ2VyLCBlbHNlIGVtaXQgbGl0ZXJhbCAqL1xuICAgIGlmIChzLm1hdGNoX2xlbmd0aCA+PSBNSU5fTUFUQ0gpIHtcbiAgICAgIC8vY2hlY2tfbWF0Y2gocywgcy5zdHJzdGFydCwgcy5zdHJzdGFydCAtIDEsIHMubWF0Y2hfbGVuZ3RoKTtcblxuICAgICAgLyoqKiBfdHJfdGFsbHlfZGlzdChzLCAxLCBzLm1hdGNoX2xlbmd0aCAtIE1JTl9NQVRDSCwgYmZsdXNoKTsgKioqL1xuICAgICAgYmZsdXNoID0gdHJlZXMuX3RyX3RhbGx5KHMsIDEsIHMubWF0Y2hfbGVuZ3RoIC0gTUlOX01BVENIKTtcblxuICAgICAgcy5sb29rYWhlYWQgLT0gcy5tYXRjaF9sZW5ndGg7XG4gICAgICBzLnN0cnN0YXJ0ICs9IHMubWF0Y2hfbGVuZ3RoO1xuICAgICAgcy5tYXRjaF9sZW5ndGggPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICAvKiBObyBtYXRjaCwgb3V0cHV0IGEgbGl0ZXJhbCBieXRlICovXG4gICAgICAvL1RyYWNldnYoKHN0ZGVycixcIiVjXCIsIHMtPndpbmRvd1tzLT5zdHJzdGFydF0pKTtcbiAgICAgIC8qKiogX3RyX3RhbGx5X2xpdChzLCBzLndpbmRvd1tzLnN0cnN0YXJ0XSwgYmZsdXNoKTsgKioqL1xuICAgICAgYmZsdXNoID0gdHJlZXMuX3RyX3RhbGx5KHMsIDAsIHMud2luZG93W3Muc3Ryc3RhcnRdKTtcblxuICAgICAgcy5sb29rYWhlYWQtLTtcbiAgICAgIHMuc3Ryc3RhcnQrKztcbiAgICB9XG4gICAgaWYgKGJmbHVzaCkge1xuICAgICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgICAgLyoqKi9cbiAgICB9XG4gIH1cbiAgcy5pbnNlcnQgPSAwO1xuICBpZiAoZmx1c2ggPT09IFpfRklOSVNIKSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAxKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgdHJ1ZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19GSU5JU0hfU1RBUlRFRDtcbiAgICB9XG4gICAgLyoqKi9cbiAgICByZXR1cm4gQlNfRklOSVNIX0RPTkU7XG4gIH1cbiAgaWYgKHMubGFzdF9saXQpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgfVxuICAgIC8qKiovXG4gIH1cbiAgcmV0dXJuIEJTX0JMT0NLX0RPTkU7XG59XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogRm9yIFpfSFVGRk1BTl9PTkxZLCBkbyBub3QgbG9vayBmb3IgbWF0Y2hlcy4gIERvIG5vdCBtYWludGFpbiBhIGhhc2ggdGFibGUuXG4gKiAoSXQgd2lsbCBiZSByZWdlbmVyYXRlZCBpZiB0aGlzIHJ1biBvZiBkZWZsYXRlIHN3aXRjaGVzIGF3YXkgZnJvbSBIdWZmbWFuLilcbiAqL1xuZnVuY3Rpb24gZGVmbGF0ZV9odWZmKHMsIGZsdXNoKSB7XG4gIHZhciBiZmx1c2g7ICAgICAgICAgICAgIC8qIHNldCBpZiBjdXJyZW50IGJsb2NrIG11c3QgYmUgZmx1c2hlZCAqL1xuXG4gIGZvciAoOzspIHtcbiAgICAvKiBNYWtlIHN1cmUgdGhhdCB3ZSBoYXZlIGEgbGl0ZXJhbCB0byB3cml0ZS4gKi9cbiAgICBpZiAocy5sb29rYWhlYWQgPT09IDApIHtcbiAgICAgIGZpbGxfd2luZG93KHMpO1xuICAgICAgaWYgKHMubG9va2FoZWFkID09PSAwKSB7XG4gICAgICAgIGlmIChmbHVzaCA9PT0gWl9OT19GTFVTSCkge1xuICAgICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7ICAgICAgLyogZmx1c2ggdGhlIGN1cnJlbnQgYmxvY2sgKi9cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKiBPdXRwdXQgYSBsaXRlcmFsIGJ5dGUgKi9cbiAgICBzLm1hdGNoX2xlbmd0aCA9IDA7XG4gICAgLy9UcmFjZXZ2KChzdGRlcnIsXCIlY1wiLCBzLT53aW5kb3dbcy0+c3Ryc3RhcnRdKSk7XG4gICAgLyoqKiBfdHJfdGFsbHlfbGl0KHMsIHMud2luZG93W3Muc3Ryc3RhcnRdLCBiZmx1c2gpOyAqKiovXG4gICAgYmZsdXNoID0gdHJlZXMuX3RyX3RhbGx5KHMsIDAsIHMud2luZG93W3Muc3Ryc3RhcnRdKTtcbiAgICBzLmxvb2thaGVhZC0tO1xuICAgIHMuc3Ryc3RhcnQrKztcbiAgICBpZiAoYmZsdXNoKSB7XG4gICAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG4gICAgICAvKioqL1xuICAgIH1cbiAgfVxuICBzLmluc2VydCA9IDA7XG4gIGlmIChmbHVzaCA9PT0gWl9GSU5JU0gpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDEpOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCB0cnVlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX0ZJTklTSF9TVEFSVEVEO1xuICAgIH1cbiAgICAvKioqL1xuICAgIHJldHVybiBCU19GSU5JU0hfRE9ORTtcbiAgfVxuICBpZiAocy5sYXN0X2xpdCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICB9XG4gICAgLyoqKi9cbiAgfVxuICByZXR1cm4gQlNfQkxPQ0tfRE9ORTtcbn1cblxuLyogVmFsdWVzIGZvciBtYXhfbGF6eV9tYXRjaCwgZ29vZF9tYXRjaCBhbmQgbWF4X2NoYWluX2xlbmd0aCwgZGVwZW5kaW5nIG9uXG4gKiB0aGUgZGVzaXJlZCBwYWNrIGxldmVsICgwLi45KS4gVGhlIHZhbHVlcyBnaXZlbiBiZWxvdyBoYXZlIGJlZW4gdHVuZWQgdG9cbiAqIGV4Y2x1ZGUgd29yc3QgY2FzZSBwZXJmb3JtYW5jZSBmb3IgcGF0aG9sb2dpY2FsIGZpbGVzLiBCZXR0ZXIgdmFsdWVzIG1heSBiZVxuICogZm91bmQgZm9yIHNwZWNpZmljIGZpbGVzLlxuICovXG5mdW5jdGlvbiBDb25maWcoZ29vZF9sZW5ndGgsIG1heF9sYXp5LCBuaWNlX2xlbmd0aCwgbWF4X2NoYWluLCBmdW5jKSB7XG4gIHRoaXMuZ29vZF9sZW5ndGggPSBnb29kX2xlbmd0aDtcbiAgdGhpcy5tYXhfbGF6eSA9IG1heF9sYXp5O1xuICB0aGlzLm5pY2VfbGVuZ3RoID0gbmljZV9sZW5ndGg7XG4gIHRoaXMubWF4X2NoYWluID0gbWF4X2NoYWluO1xuICB0aGlzLmZ1bmMgPSBmdW5jO1xufVxuXG52YXIgY29uZmlndXJhdGlvbl90YWJsZTtcblxuY29uZmlndXJhdGlvbl90YWJsZSA9IFtcbiAgLyogICAgICBnb29kIGxhenkgbmljZSBjaGFpbiAqL1xuICBuZXcgQ29uZmlnKDAsIDAsIDAsIDAsIGRlZmxhdGVfc3RvcmVkKSwgICAgICAgICAgLyogMCBzdG9yZSBvbmx5ICovXG4gIG5ldyBDb25maWcoNCwgNCwgOCwgNCwgZGVmbGF0ZV9mYXN0KSwgICAgICAgICAgICAvKiAxIG1heCBzcGVlZCwgbm8gbGF6eSBtYXRjaGVzICovXG4gIG5ldyBDb25maWcoNCwgNSwgMTYsIDgsIGRlZmxhdGVfZmFzdCksICAgICAgICAgICAvKiAyICovXG4gIG5ldyBDb25maWcoNCwgNiwgMzIsIDMyLCBkZWZsYXRlX2Zhc3QpLCAgICAgICAgICAvKiAzICovXG5cbiAgbmV3IENvbmZpZyg0LCA0LCAxNiwgMTYsIGRlZmxhdGVfc2xvdyksICAgICAgICAgIC8qIDQgbGF6eSBtYXRjaGVzICovXG4gIG5ldyBDb25maWcoOCwgMTYsIDMyLCAzMiwgZGVmbGF0ZV9zbG93KSwgICAgICAgICAvKiA1ICovXG4gIG5ldyBDb25maWcoOCwgMTYsIDEyOCwgMTI4LCBkZWZsYXRlX3Nsb3cpLCAgICAgICAvKiA2ICovXG4gIG5ldyBDb25maWcoOCwgMzIsIDEyOCwgMjU2LCBkZWZsYXRlX3Nsb3cpLCAgICAgICAvKiA3ICovXG4gIG5ldyBDb25maWcoMzIsIDEyOCwgMjU4LCAxMDI0LCBkZWZsYXRlX3Nsb3cpLCAgICAvKiA4ICovXG4gIG5ldyBDb25maWcoMzIsIDI1OCwgMjU4LCA0MDk2LCBkZWZsYXRlX3Nsb3cpICAgICAvKiA5IG1heCBjb21wcmVzc2lvbiAqL1xuXTtcblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEluaXRpYWxpemUgdGhlIFwibG9uZ2VzdCBtYXRjaFwiIHJvdXRpbmVzIGZvciBhIG5ldyB6bGliIHN0cmVhbVxuICovXG5mdW5jdGlvbiBsbV9pbml0KHMpIHtcbiAgcy53aW5kb3dfc2l6ZSA9IDIgKiBzLndfc2l6ZTtcblxuICAvKioqIENMRUFSX0hBU0gocyk7ICoqKi9cbiAgemVybyhzLmhlYWQpOyAvLyBGaWxsIHdpdGggTklMICg9IDApO1xuXG4gIC8qIFNldCB0aGUgZGVmYXVsdCBjb25maWd1cmF0aW9uIHBhcmFtZXRlcnM6XG4gICAqL1xuICBzLm1heF9sYXp5X21hdGNoID0gY29uZmlndXJhdGlvbl90YWJsZVtzLmxldmVsXS5tYXhfbGF6eTtcbiAgcy5nb29kX21hdGNoID0gY29uZmlndXJhdGlvbl90YWJsZVtzLmxldmVsXS5nb29kX2xlbmd0aDtcbiAgcy5uaWNlX21hdGNoID0gY29uZmlndXJhdGlvbl90YWJsZVtzLmxldmVsXS5uaWNlX2xlbmd0aDtcbiAgcy5tYXhfY2hhaW5fbGVuZ3RoID0gY29uZmlndXJhdGlvbl90YWJsZVtzLmxldmVsXS5tYXhfY2hhaW47XG5cbiAgcy5zdHJzdGFydCA9IDA7XG4gIHMuYmxvY2tfc3RhcnQgPSAwO1xuICBzLmxvb2thaGVhZCA9IDA7XG4gIHMuaW5zZXJ0ID0gMDtcbiAgcy5tYXRjaF9sZW5ndGggPSBzLnByZXZfbGVuZ3RoID0gTUlOX01BVENIIC0gMTtcbiAgcy5tYXRjaF9hdmFpbGFibGUgPSAwO1xuICBzLmluc19oID0gMDtcbn1cblxuXG5mdW5jdGlvbiBEZWZsYXRlU3RhdGUoKSB7XG4gIHRoaXMuc3RybSA9IG51bGw7ICAgICAgICAgICAgLyogcG9pbnRlciBiYWNrIHRvIHRoaXMgemxpYiBzdHJlYW0gKi9cbiAgdGhpcy5zdGF0dXMgPSAwOyAgICAgICAgICAgIC8qIGFzIHRoZSBuYW1lIGltcGxpZXMgKi9cbiAgdGhpcy5wZW5kaW5nX2J1ZiA9IG51bGw7ICAgICAgLyogb3V0cHV0IHN0aWxsIHBlbmRpbmcgKi9cbiAgdGhpcy5wZW5kaW5nX2J1Zl9zaXplID0gMDsgIC8qIHNpemUgb2YgcGVuZGluZ19idWYgKi9cbiAgdGhpcy5wZW5kaW5nX291dCA9IDA7ICAgICAgIC8qIG5leHQgcGVuZGluZyBieXRlIHRvIG91dHB1dCB0byB0aGUgc3RyZWFtICovXG4gIHRoaXMucGVuZGluZyA9IDA7ICAgICAgICAgICAvKiBuYiBvZiBieXRlcyBpbiB0aGUgcGVuZGluZyBidWZmZXIgKi9cbiAgdGhpcy53cmFwID0gMDsgICAgICAgICAgICAgIC8qIGJpdCAwIHRydWUgZm9yIHpsaWIsIGJpdCAxIHRydWUgZm9yIGd6aXAgKi9cbiAgdGhpcy5nemhlYWQgPSBudWxsOyAgICAgICAgIC8qIGd6aXAgaGVhZGVyIGluZm9ybWF0aW9uIHRvIHdyaXRlICovXG4gIHRoaXMuZ3ppbmRleCA9IDA7ICAgICAgICAgICAvKiB3aGVyZSBpbiBleHRyYSwgbmFtZSwgb3IgY29tbWVudCAqL1xuICB0aGlzLm1ldGhvZCA9IFpfREVGTEFURUQ7IC8qIGNhbiBvbmx5IGJlIERFRkxBVEVEICovXG4gIHRoaXMubGFzdF9mbHVzaCA9IC0xOyAgIC8qIHZhbHVlIG9mIGZsdXNoIHBhcmFtIGZvciBwcmV2aW91cyBkZWZsYXRlIGNhbGwgKi9cblxuICB0aGlzLndfc2l6ZSA9IDA7ICAvKiBMWjc3IHdpbmRvdyBzaXplICgzMksgYnkgZGVmYXVsdCkgKi9cbiAgdGhpcy53X2JpdHMgPSAwOyAgLyogbG9nMih3X3NpemUpICAoOC4uMTYpICovXG4gIHRoaXMud19tYXNrID0gMDsgIC8qIHdfc2l6ZSAtIDEgKi9cblxuICB0aGlzLndpbmRvdyA9IG51bGw7XG4gIC8qIFNsaWRpbmcgd2luZG93LiBJbnB1dCBieXRlcyBhcmUgcmVhZCBpbnRvIHRoZSBzZWNvbmQgaGFsZiBvZiB0aGUgd2luZG93LFxuICAgKiBhbmQgbW92ZSB0byB0aGUgZmlyc3QgaGFsZiBsYXRlciB0byBrZWVwIGEgZGljdGlvbmFyeSBvZiBhdCBsZWFzdCB3U2l6ZVxuICAgKiBieXRlcy4gV2l0aCB0aGlzIG9yZ2FuaXphdGlvbiwgbWF0Y2hlcyBhcmUgbGltaXRlZCB0byBhIGRpc3RhbmNlIG9mXG4gICAqIHdTaXplLU1BWF9NQVRDSCBieXRlcywgYnV0IHRoaXMgZW5zdXJlcyB0aGF0IElPIGlzIGFsd2F5c1xuICAgKiBwZXJmb3JtZWQgd2l0aCBhIGxlbmd0aCBtdWx0aXBsZSBvZiB0aGUgYmxvY2sgc2l6ZS5cbiAgICovXG5cbiAgdGhpcy53aW5kb3dfc2l6ZSA9IDA7XG4gIC8qIEFjdHVhbCBzaXplIG9mIHdpbmRvdzogMip3U2l6ZSwgZXhjZXB0IHdoZW4gdGhlIHVzZXIgaW5wdXQgYnVmZmVyXG4gICAqIGlzIGRpcmVjdGx5IHVzZWQgYXMgc2xpZGluZyB3aW5kb3cuXG4gICAqL1xuXG4gIHRoaXMucHJldiA9IG51bGw7XG4gIC8qIExpbmsgdG8gb2xkZXIgc3RyaW5nIHdpdGggc2FtZSBoYXNoIGluZGV4LiBUbyBsaW1pdCB0aGUgc2l6ZSBvZiB0aGlzXG4gICAqIGFycmF5IHRvIDY0SywgdGhpcyBsaW5rIGlzIG1haW50YWluZWQgb25seSBmb3IgdGhlIGxhc3QgMzJLIHN0cmluZ3MuXG4gICAqIEFuIGluZGV4IGluIHRoaXMgYXJyYXkgaXMgdGh1cyBhIHdpbmRvdyBpbmRleCBtb2R1bG8gMzJLLlxuICAgKi9cblxuICB0aGlzLmhlYWQgPSBudWxsOyAgIC8qIEhlYWRzIG9mIHRoZSBoYXNoIGNoYWlucyBvciBOSUwuICovXG5cbiAgdGhpcy5pbnNfaCA9IDA7ICAgICAgIC8qIGhhc2ggaW5kZXggb2Ygc3RyaW5nIHRvIGJlIGluc2VydGVkICovXG4gIHRoaXMuaGFzaF9zaXplID0gMDsgICAvKiBudW1iZXIgb2YgZWxlbWVudHMgaW4gaGFzaCB0YWJsZSAqL1xuICB0aGlzLmhhc2hfYml0cyA9IDA7ICAgLyogbG9nMihoYXNoX3NpemUpICovXG4gIHRoaXMuaGFzaF9tYXNrID0gMDsgICAvKiBoYXNoX3NpemUtMSAqL1xuXG4gIHRoaXMuaGFzaF9zaGlmdCA9IDA7XG4gIC8qIE51bWJlciBvZiBiaXRzIGJ5IHdoaWNoIGluc19oIG11c3QgYmUgc2hpZnRlZCBhdCBlYWNoIGlucHV0XG4gICAqIHN0ZXAuIEl0IG11c3QgYmUgc3VjaCB0aGF0IGFmdGVyIE1JTl9NQVRDSCBzdGVwcywgdGhlIG9sZGVzdFxuICAgKiBieXRlIG5vIGxvbmdlciB0YWtlcyBwYXJ0IGluIHRoZSBoYXNoIGtleSwgdGhhdCBpczpcbiAgICogICBoYXNoX3NoaWZ0ICogTUlOX01BVENIID49IGhhc2hfYml0c1xuICAgKi9cblxuICB0aGlzLmJsb2NrX3N0YXJ0ID0gMDtcbiAgLyogV2luZG93IHBvc2l0aW9uIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIGN1cnJlbnQgb3V0cHV0IGJsb2NrLiBHZXRzXG4gICAqIG5lZ2F0aXZlIHdoZW4gdGhlIHdpbmRvdyBpcyBtb3ZlZCBiYWNrd2FyZHMuXG4gICAqL1xuXG4gIHRoaXMubWF0Y2hfbGVuZ3RoID0gMDsgICAgICAvKiBsZW5ndGggb2YgYmVzdCBtYXRjaCAqL1xuICB0aGlzLnByZXZfbWF0Y2ggPSAwOyAgICAgICAgLyogcHJldmlvdXMgbWF0Y2ggKi9cbiAgdGhpcy5tYXRjaF9hdmFpbGFibGUgPSAwOyAgIC8qIHNldCBpZiBwcmV2aW91cyBtYXRjaCBleGlzdHMgKi9cbiAgdGhpcy5zdHJzdGFydCA9IDA7ICAgICAgICAgIC8qIHN0YXJ0IG9mIHN0cmluZyB0byBpbnNlcnQgKi9cbiAgdGhpcy5tYXRjaF9zdGFydCA9IDA7ICAgICAgIC8qIHN0YXJ0IG9mIG1hdGNoaW5nIHN0cmluZyAqL1xuICB0aGlzLmxvb2thaGVhZCA9IDA7ICAgICAgICAgLyogbnVtYmVyIG9mIHZhbGlkIGJ5dGVzIGFoZWFkIGluIHdpbmRvdyAqL1xuXG4gIHRoaXMucHJldl9sZW5ndGggPSAwO1xuICAvKiBMZW5ndGggb2YgdGhlIGJlc3QgbWF0Y2ggYXQgcHJldmlvdXMgc3RlcC4gTWF0Y2hlcyBub3QgZ3JlYXRlciB0aGFuIHRoaXNcbiAgICogYXJlIGRpc2NhcmRlZC4gVGhpcyBpcyB1c2VkIGluIHRoZSBsYXp5IG1hdGNoIGV2YWx1YXRpb24uXG4gICAqL1xuXG4gIHRoaXMubWF4X2NoYWluX2xlbmd0aCA9IDA7XG4gIC8qIFRvIHNwZWVkIHVwIGRlZmxhdGlvbiwgaGFzaCBjaGFpbnMgYXJlIG5ldmVyIHNlYXJjaGVkIGJleW9uZCB0aGlzXG4gICAqIGxlbmd0aC4gIEEgaGlnaGVyIGxpbWl0IGltcHJvdmVzIGNvbXByZXNzaW9uIHJhdGlvIGJ1dCBkZWdyYWRlcyB0aGVcbiAgICogc3BlZWQuXG4gICAqL1xuXG4gIHRoaXMubWF4X2xhenlfbWF0Y2ggPSAwO1xuICAvKiBBdHRlbXB0IHRvIGZpbmQgYSBiZXR0ZXIgbWF0Y2ggb25seSB3aGVuIHRoZSBjdXJyZW50IG1hdGNoIGlzIHN0cmljdGx5XG4gICAqIHNtYWxsZXIgdGhhbiB0aGlzIHZhbHVlLiBUaGlzIG1lY2hhbmlzbSBpcyB1c2VkIG9ubHkgZm9yIGNvbXByZXNzaW9uXG4gICAqIGxldmVscyA+PSA0LlxuICAgKi9cbiAgLy8gVGhhdCdzIGFsaWFzIHRvIG1heF9sYXp5X21hdGNoLCBkb24ndCB1c2UgZGlyZWN0bHlcbiAgLy90aGlzLm1heF9pbnNlcnRfbGVuZ3RoID0gMDtcbiAgLyogSW5zZXJ0IG5ldyBzdHJpbmdzIGluIHRoZSBoYXNoIHRhYmxlIG9ubHkgaWYgdGhlIG1hdGNoIGxlbmd0aCBpcyBub3RcbiAgICogZ3JlYXRlciB0aGFuIHRoaXMgbGVuZ3RoLiBUaGlzIHNhdmVzIHRpbWUgYnV0IGRlZ3JhZGVzIGNvbXByZXNzaW9uLlxuICAgKiBtYXhfaW5zZXJ0X2xlbmd0aCBpcyB1c2VkIG9ubHkgZm9yIGNvbXByZXNzaW9uIGxldmVscyA8PSAzLlxuICAgKi9cblxuICB0aGlzLmxldmVsID0gMDsgICAgIC8qIGNvbXByZXNzaW9uIGxldmVsICgxLi45KSAqL1xuICB0aGlzLnN0cmF0ZWd5ID0gMDsgIC8qIGZhdm9yIG9yIGZvcmNlIEh1ZmZtYW4gY29kaW5nKi9cblxuICB0aGlzLmdvb2RfbWF0Y2ggPSAwO1xuICAvKiBVc2UgYSBmYXN0ZXIgc2VhcmNoIHdoZW4gdGhlIHByZXZpb3VzIG1hdGNoIGlzIGxvbmdlciB0aGFuIHRoaXMgKi9cblxuICB0aGlzLm5pY2VfbWF0Y2ggPSAwOyAvKiBTdG9wIHNlYXJjaGluZyB3aGVuIGN1cnJlbnQgbWF0Y2ggZXhjZWVkcyB0aGlzICovXG5cbiAgICAgICAgICAgICAgLyogdXNlZCBieSB0cmVlcy5jOiAqL1xuXG4gIC8qIERpZG4ndCB1c2UgY3RfZGF0YSB0eXBlZGVmIGJlbG93IHRvIHN1cHByZXNzIGNvbXBpbGVyIHdhcm5pbmcgKi9cblxuICAvLyBzdHJ1Y3QgY3RfZGF0YV9zIGR5bl9sdHJlZVtIRUFQX1NJWkVdOyAgIC8qIGxpdGVyYWwgYW5kIGxlbmd0aCB0cmVlICovXG4gIC8vIHN0cnVjdCBjdF9kYXRhX3MgZHluX2R0cmVlWzIqRF9DT0RFUysxXTsgLyogZGlzdGFuY2UgdHJlZSAqL1xuICAvLyBzdHJ1Y3QgY3RfZGF0YV9zIGJsX3RyZWVbMipCTF9DT0RFUysxXTsgIC8qIEh1ZmZtYW4gdHJlZSBmb3IgYml0IGxlbmd0aHMgKi9cblxuICAvLyBVc2UgZmxhdCBhcnJheSBvZiBET1VCTEUgc2l6ZSwgd2l0aCBpbnRlcmxlYXZlZCBmYXRhLFxuICAvLyBiZWNhdXNlIEpTIGRvZXMgbm90IHN1cHBvcnQgZWZmZWN0aXZlXG4gIHRoaXMuZHluX2x0cmVlICA9IG5ldyB1dGlscy5CdWYxNihIRUFQX1NJWkUgKiAyKTtcbiAgdGhpcy5keW5fZHRyZWUgID0gbmV3IHV0aWxzLkJ1ZjE2KCgyICogRF9DT0RFUyArIDEpICogMik7XG4gIHRoaXMuYmxfdHJlZSAgICA9IG5ldyB1dGlscy5CdWYxNigoMiAqIEJMX0NPREVTICsgMSkgKiAyKTtcbiAgemVybyh0aGlzLmR5bl9sdHJlZSk7XG4gIHplcm8odGhpcy5keW5fZHRyZWUpO1xuICB6ZXJvKHRoaXMuYmxfdHJlZSk7XG5cbiAgdGhpcy5sX2Rlc2MgICA9IG51bGw7ICAgICAgICAgLyogZGVzYy4gZm9yIGxpdGVyYWwgdHJlZSAqL1xuICB0aGlzLmRfZGVzYyAgID0gbnVsbDsgICAgICAgICAvKiBkZXNjLiBmb3IgZGlzdGFuY2UgdHJlZSAqL1xuICB0aGlzLmJsX2Rlc2MgID0gbnVsbDsgICAgICAgICAvKiBkZXNjLiBmb3IgYml0IGxlbmd0aCB0cmVlICovXG5cbiAgLy91c2ggYmxfY291bnRbTUFYX0JJVFMrMV07XG4gIHRoaXMuYmxfY291bnQgPSBuZXcgdXRpbHMuQnVmMTYoTUFYX0JJVFMgKyAxKTtcbiAgLyogbnVtYmVyIG9mIGNvZGVzIGF0IGVhY2ggYml0IGxlbmd0aCBmb3IgYW4gb3B0aW1hbCB0cmVlICovXG5cbiAgLy9pbnQgaGVhcFsyKkxfQ09ERVMrMV07ICAgICAgLyogaGVhcCB1c2VkIHRvIGJ1aWxkIHRoZSBIdWZmbWFuIHRyZWVzICovXG4gIHRoaXMuaGVhcCA9IG5ldyB1dGlscy5CdWYxNigyICogTF9DT0RFUyArIDEpOyAgLyogaGVhcCB1c2VkIHRvIGJ1aWxkIHRoZSBIdWZmbWFuIHRyZWVzICovXG4gIHplcm8odGhpcy5oZWFwKTtcblxuICB0aGlzLmhlYXBfbGVuID0gMDsgICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIGhlYXAgKi9cbiAgdGhpcy5oZWFwX21heCA9IDA7ICAgICAgICAgICAgICAgLyogZWxlbWVudCBvZiBsYXJnZXN0IGZyZXF1ZW5jeSAqL1xuICAvKiBUaGUgc29ucyBvZiBoZWFwW25dIGFyZSBoZWFwWzIqbl0gYW5kIGhlYXBbMipuKzFdLiBoZWFwWzBdIGlzIG5vdCB1c2VkLlxuICAgKiBUaGUgc2FtZSBoZWFwIGFycmF5IGlzIHVzZWQgdG8gYnVpbGQgYWxsIHRyZWVzLlxuICAgKi9cblxuICB0aGlzLmRlcHRoID0gbmV3IHV0aWxzLkJ1ZjE2KDIgKiBMX0NPREVTICsgMSk7IC8vdWNoIGRlcHRoWzIqTF9DT0RFUysxXTtcbiAgemVybyh0aGlzLmRlcHRoKTtcbiAgLyogRGVwdGggb2YgZWFjaCBzdWJ0cmVlIHVzZWQgYXMgdGllIGJyZWFrZXIgZm9yIHRyZWVzIG9mIGVxdWFsIGZyZXF1ZW5jeVxuICAgKi9cblxuICB0aGlzLmxfYnVmID0gMDsgICAgICAgICAgLyogYnVmZmVyIGluZGV4IGZvciBsaXRlcmFscyBvciBsZW5ndGhzICovXG5cbiAgdGhpcy5saXRfYnVmc2l6ZSA9IDA7XG4gIC8qIFNpemUgb2YgbWF0Y2ggYnVmZmVyIGZvciBsaXRlcmFscy9sZW5ndGhzLiAgVGhlcmUgYXJlIDQgcmVhc29ucyBmb3JcbiAgICogbGltaXRpbmcgbGl0X2J1ZnNpemUgdG8gNjRLOlxuICAgKiAgIC0gZnJlcXVlbmNpZXMgY2FuIGJlIGtlcHQgaW4gMTYgYml0IGNvdW50ZXJzXG4gICAqICAgLSBpZiBjb21wcmVzc2lvbiBpcyBub3Qgc3VjY2Vzc2Z1bCBmb3IgdGhlIGZpcnN0IGJsb2NrLCBhbGwgaW5wdXRcbiAgICogICAgIGRhdGEgaXMgc3RpbGwgaW4gdGhlIHdpbmRvdyBzbyB3ZSBjYW4gc3RpbGwgZW1pdCBhIHN0b3JlZCBibG9jayBldmVuXG4gICAqICAgICB3aGVuIGlucHV0IGNvbWVzIGZyb20gc3RhbmRhcmQgaW5wdXQuICAoVGhpcyBjYW4gYWxzbyBiZSBkb25lIGZvclxuICAgKiAgICAgYWxsIGJsb2NrcyBpZiBsaXRfYnVmc2l6ZSBpcyBub3QgZ3JlYXRlciB0aGFuIDMySy4pXG4gICAqICAgLSBpZiBjb21wcmVzc2lvbiBpcyBub3Qgc3VjY2Vzc2Z1bCBmb3IgYSBmaWxlIHNtYWxsZXIgdGhhbiA2NEssIHdlIGNhblxuICAgKiAgICAgZXZlbiBlbWl0IGEgc3RvcmVkIGZpbGUgaW5zdGVhZCBvZiBhIHN0b3JlZCBibG9jayAoc2F2aW5nIDUgYnl0ZXMpLlxuICAgKiAgICAgVGhpcyBpcyBhcHBsaWNhYmxlIG9ubHkgZm9yIHppcCAobm90IGd6aXAgb3IgemxpYikuXG4gICAqICAgLSBjcmVhdGluZyBuZXcgSHVmZm1hbiB0cmVlcyBsZXNzIGZyZXF1ZW50bHkgbWF5IG5vdCBwcm92aWRlIGZhc3RcbiAgICogICAgIGFkYXB0YXRpb24gdG8gY2hhbmdlcyBpbiB0aGUgaW5wdXQgZGF0YSBzdGF0aXN0aWNzLiAoVGFrZSBmb3JcbiAgICogICAgIGV4YW1wbGUgYSBiaW5hcnkgZmlsZSB3aXRoIHBvb3JseSBjb21wcmVzc2libGUgY29kZSBmb2xsb3dlZCBieVxuICAgKiAgICAgYSBoaWdobHkgY29tcHJlc3NpYmxlIHN0cmluZyB0YWJsZS4pIFNtYWxsZXIgYnVmZmVyIHNpemVzIGdpdmVcbiAgICogICAgIGZhc3QgYWRhcHRhdGlvbiBidXQgaGF2ZSBvZiBjb3Vyc2UgdGhlIG92ZXJoZWFkIG9mIHRyYW5zbWl0dGluZ1xuICAgKiAgICAgdHJlZXMgbW9yZSBmcmVxdWVudGx5LlxuICAgKiAgIC0gSSBjYW4ndCBjb3VudCBhYm92ZSA0XG4gICAqL1xuXG4gIHRoaXMubGFzdF9saXQgPSAwOyAgICAgIC8qIHJ1bm5pbmcgaW5kZXggaW4gbF9idWYgKi9cblxuICB0aGlzLmRfYnVmID0gMDtcbiAgLyogQnVmZmVyIGluZGV4IGZvciBkaXN0YW5jZXMuIFRvIHNpbXBsaWZ5IHRoZSBjb2RlLCBkX2J1ZiBhbmQgbF9idWYgaGF2ZVxuICAgKiB0aGUgc2FtZSBudW1iZXIgb2YgZWxlbWVudHMuIFRvIHVzZSBkaWZmZXJlbnQgbGVuZ3RocywgYW4gZXh0cmEgZmxhZ1xuICAgKiBhcnJheSB3b3VsZCBiZSBuZWNlc3NhcnkuXG4gICAqL1xuXG4gIHRoaXMub3B0X2xlbiA9IDA7ICAgICAgIC8qIGJpdCBsZW5ndGggb2YgY3VycmVudCBibG9jayB3aXRoIG9wdGltYWwgdHJlZXMgKi9cbiAgdGhpcy5zdGF0aWNfbGVuID0gMDsgICAgLyogYml0IGxlbmd0aCBvZiBjdXJyZW50IGJsb2NrIHdpdGggc3RhdGljIHRyZWVzICovXG4gIHRoaXMubWF0Y2hlcyA9IDA7ICAgICAgIC8qIG51bWJlciBvZiBzdHJpbmcgbWF0Y2hlcyBpbiBjdXJyZW50IGJsb2NrICovXG4gIHRoaXMuaW5zZXJ0ID0gMDsgICAgICAgIC8qIGJ5dGVzIGF0IGVuZCBvZiB3aW5kb3cgbGVmdCB0byBpbnNlcnQgKi9cblxuXG4gIHRoaXMuYmlfYnVmID0gMDtcbiAgLyogT3V0cHV0IGJ1ZmZlci4gYml0cyBhcmUgaW5zZXJ0ZWQgc3RhcnRpbmcgYXQgdGhlIGJvdHRvbSAobGVhc3RcbiAgICogc2lnbmlmaWNhbnQgYml0cykuXG4gICAqL1xuICB0aGlzLmJpX3ZhbGlkID0gMDtcbiAgLyogTnVtYmVyIG9mIHZhbGlkIGJpdHMgaW4gYmlfYnVmLiAgQWxsIGJpdHMgYWJvdmUgdGhlIGxhc3QgdmFsaWQgYml0XG4gICAqIGFyZSBhbHdheXMgemVyby5cbiAgICovXG5cbiAgLy8gVXNlZCBmb3Igd2luZG93IG1lbW9yeSBpbml0LiBXZSBzYWZlbHkgaWdub3JlIGl0IGZvciBKUy4gVGhhdCBtYWtlc1xuICAvLyBzZW5zZSBvbmx5IGZvciBwb2ludGVycyBhbmQgbWVtb3J5IGNoZWNrIHRvb2xzLlxuICAvL3RoaXMuaGlnaF93YXRlciA9IDA7XG4gIC8qIEhpZ2ggd2F0ZXIgbWFyayBvZmZzZXQgaW4gd2luZG93IGZvciBpbml0aWFsaXplZCBieXRlcyAtLSBieXRlcyBhYm92ZVxuICAgKiB0aGlzIGFyZSBzZXQgdG8gemVybyBpbiBvcmRlciB0byBhdm9pZCBtZW1vcnkgY2hlY2sgd2FybmluZ3Mgd2hlblxuICAgKiBsb25nZXN0IG1hdGNoIHJvdXRpbmVzIGFjY2VzcyBieXRlcyBwYXN0IHRoZSBpbnB1dC4gIFRoaXMgaXMgdGhlblxuICAgKiB1cGRhdGVkIHRvIHRoZSBuZXcgaGlnaCB3YXRlciBtYXJrLlxuICAgKi9cbn1cblxuXG5mdW5jdGlvbiBkZWZsYXRlUmVzZXRLZWVwKHN0cm0pIHtcbiAgdmFyIHM7XG5cbiAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlKSB7XG4gICAgcmV0dXJuIGVycihzdHJtLCBaX1NUUkVBTV9FUlJPUik7XG4gIH1cblxuICBzdHJtLnRvdGFsX2luID0gc3RybS50b3RhbF9vdXQgPSAwO1xuICBzdHJtLmRhdGFfdHlwZSA9IFpfVU5LTk9XTjtcblxuICBzID0gc3RybS5zdGF0ZTtcbiAgcy5wZW5kaW5nID0gMDtcbiAgcy5wZW5kaW5nX291dCA9IDA7XG5cbiAgaWYgKHMud3JhcCA8IDApIHtcbiAgICBzLndyYXAgPSAtcy53cmFwO1xuICAgIC8qIHdhcyBtYWRlIG5lZ2F0aXZlIGJ5IGRlZmxhdGUoLi4uLCBaX0ZJTklTSCk7ICovXG4gIH1cbiAgcy5zdGF0dXMgPSAocy53cmFwID8gSU5JVF9TVEFURSA6IEJVU1lfU1RBVEUpO1xuICBzdHJtLmFkbGVyID0gKHMud3JhcCA9PT0gMikgP1xuICAgIDAgIC8vIGNyYzMyKDAsIFpfTlVMTCwgMClcbiAgOlxuICAgIDE7IC8vIGFkbGVyMzIoMCwgWl9OVUxMLCAwKVxuICBzLmxhc3RfZmx1c2ggPSBaX05PX0ZMVVNIO1xuICB0cmVlcy5fdHJfaW5pdChzKTtcbiAgcmV0dXJuIFpfT0s7XG59XG5cblxuZnVuY3Rpb24gZGVmbGF0ZVJlc2V0KHN0cm0pIHtcbiAgdmFyIHJldCA9IGRlZmxhdGVSZXNldEtlZXAoc3RybSk7XG4gIGlmIChyZXQgPT09IFpfT0spIHtcbiAgICBsbV9pbml0KHN0cm0uc3RhdGUpO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cblxuZnVuY3Rpb24gZGVmbGF0ZVNldEhlYWRlcihzdHJtLCBoZWFkKSB7XG4gIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSkgeyByZXR1cm4gWl9TVFJFQU1fRVJST1I7IH1cbiAgaWYgKHN0cm0uc3RhdGUud3JhcCAhPT0gMikgeyByZXR1cm4gWl9TVFJFQU1fRVJST1I7IH1cbiAgc3RybS5zdGF0ZS5nemhlYWQgPSBoZWFkO1xuICByZXR1cm4gWl9PSztcbn1cblxuXG5mdW5jdGlvbiBkZWZsYXRlSW5pdDIoc3RybSwgbGV2ZWwsIG1ldGhvZCwgd2luZG93Qml0cywgbWVtTGV2ZWwsIHN0cmF0ZWd5KSB7XG4gIGlmICghc3RybSkgeyAvLyA9PT0gWl9OVUxMXG4gICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICB9XG4gIHZhciB3cmFwID0gMTtcblxuICBpZiAobGV2ZWwgPT09IFpfREVGQVVMVF9DT01QUkVTU0lPTikge1xuICAgIGxldmVsID0gNjtcbiAgfVxuXG4gIGlmICh3aW5kb3dCaXRzIDwgMCkgeyAvKiBzdXBwcmVzcyB6bGliIHdyYXBwZXIgKi9cbiAgICB3cmFwID0gMDtcbiAgICB3aW5kb3dCaXRzID0gLXdpbmRvd0JpdHM7XG4gIH1cblxuICBlbHNlIGlmICh3aW5kb3dCaXRzID4gMTUpIHtcbiAgICB3cmFwID0gMjsgICAgICAgICAgIC8qIHdyaXRlIGd6aXAgd3JhcHBlciBpbnN0ZWFkICovXG4gICAgd2luZG93Qml0cyAtPSAxNjtcbiAgfVxuXG5cbiAgaWYgKG1lbUxldmVsIDwgMSB8fCBtZW1MZXZlbCA+IE1BWF9NRU1fTEVWRUwgfHwgbWV0aG9kICE9PSBaX0RFRkxBVEVEIHx8XG4gICAgd2luZG93Qml0cyA8IDggfHwgd2luZG93Qml0cyA+IDE1IHx8IGxldmVsIDwgMCB8fCBsZXZlbCA+IDkgfHxcbiAgICBzdHJhdGVneSA8IDAgfHwgc3RyYXRlZ3kgPiBaX0ZJWEVEKSB7XG4gICAgcmV0dXJuIGVycihzdHJtLCBaX1NUUkVBTV9FUlJPUik7XG4gIH1cblxuXG4gIGlmICh3aW5kb3dCaXRzID09PSA4KSB7XG4gICAgd2luZG93Qml0cyA9IDk7XG4gIH1cbiAgLyogdW50aWwgMjU2LWJ5dGUgd2luZG93IGJ1ZyBmaXhlZCAqL1xuXG4gIHZhciBzID0gbmV3IERlZmxhdGVTdGF0ZSgpO1xuXG4gIHN0cm0uc3RhdGUgPSBzO1xuICBzLnN0cm0gPSBzdHJtO1xuXG4gIHMud3JhcCA9IHdyYXA7XG4gIHMuZ3poZWFkID0gbnVsbDtcbiAgcy53X2JpdHMgPSB3aW5kb3dCaXRzO1xuICBzLndfc2l6ZSA9IDEgPDwgcy53X2JpdHM7XG4gIHMud19tYXNrID0gcy53X3NpemUgLSAxO1xuXG4gIHMuaGFzaF9iaXRzID0gbWVtTGV2ZWwgKyA3O1xuICBzLmhhc2hfc2l6ZSA9IDEgPDwgcy5oYXNoX2JpdHM7XG4gIHMuaGFzaF9tYXNrID0gcy5oYXNoX3NpemUgLSAxO1xuICBzLmhhc2hfc2hpZnQgPSB+figocy5oYXNoX2JpdHMgKyBNSU5fTUFUQ0ggLSAxKSAvIE1JTl9NQVRDSCk7XG5cbiAgcy53aW5kb3cgPSBuZXcgdXRpbHMuQnVmOChzLndfc2l6ZSAqIDIpO1xuICBzLmhlYWQgPSBuZXcgdXRpbHMuQnVmMTYocy5oYXNoX3NpemUpO1xuICBzLnByZXYgPSBuZXcgdXRpbHMuQnVmMTYocy53X3NpemUpO1xuXG4gIC8vIERvbid0IG5lZWQgbWVtIGluaXQgbWFnaWMgZm9yIEpTLlxuICAvL3MuaGlnaF93YXRlciA9IDA7ICAvKiBub3RoaW5nIHdyaXR0ZW4gdG8gcy0+d2luZG93IHlldCAqL1xuXG4gIHMubGl0X2J1ZnNpemUgPSAxIDw8IChtZW1MZXZlbCArIDYpOyAvKiAxNksgZWxlbWVudHMgYnkgZGVmYXVsdCAqL1xuXG4gIHMucGVuZGluZ19idWZfc2l6ZSA9IHMubGl0X2J1ZnNpemUgKiA0O1xuXG4gIC8vb3ZlcmxheSA9ICh1c2hmICopIFpBTExPQyhzdHJtLCBzLT5saXRfYnVmc2l6ZSwgc2l6ZW9mKHVzaCkrMik7XG4gIC8vcy0+cGVuZGluZ19idWYgPSAodWNoZiAqKSBvdmVybGF5O1xuICBzLnBlbmRpbmdfYnVmID0gbmV3IHV0aWxzLkJ1Zjgocy5wZW5kaW5nX2J1Zl9zaXplKTtcblxuICAvLyBJdCBpcyBvZmZzZXQgZnJvbSBgcy5wZW5kaW5nX2J1ZmAgKHNpemUgaXMgYHMubGl0X2J1ZnNpemUgKiAyYClcbiAgLy9zLT5kX2J1ZiA9IG92ZXJsYXkgKyBzLT5saXRfYnVmc2l6ZS9zaXplb2YodXNoKTtcbiAgcy5kX2J1ZiA9IDEgKiBzLmxpdF9idWZzaXplO1xuXG4gIC8vcy0+bF9idWYgPSBzLT5wZW5kaW5nX2J1ZiArICgxK3NpemVvZih1c2gpKSpzLT5saXRfYnVmc2l6ZTtcbiAgcy5sX2J1ZiA9ICgxICsgMikgKiBzLmxpdF9idWZzaXplO1xuXG4gIHMubGV2ZWwgPSBsZXZlbDtcbiAgcy5zdHJhdGVneSA9IHN0cmF0ZWd5O1xuICBzLm1ldGhvZCA9IG1ldGhvZDtcblxuICByZXR1cm4gZGVmbGF0ZVJlc2V0KHN0cm0pO1xufVxuXG5mdW5jdGlvbiBkZWZsYXRlSW5pdChzdHJtLCBsZXZlbCkge1xuICByZXR1cm4gZGVmbGF0ZUluaXQyKHN0cm0sIGxldmVsLCBaX0RFRkxBVEVELCBNQVhfV0JJVFMsIERFRl9NRU1fTEVWRUwsIFpfREVGQVVMVF9TVFJBVEVHWSk7XG59XG5cblxuZnVuY3Rpb24gZGVmbGF0ZShzdHJtLCBmbHVzaCkge1xuICB2YXIgb2xkX2ZsdXNoLCBzO1xuICB2YXIgYmVnLCB2YWw7IC8vIGZvciBnemlwIGhlYWRlciB3cml0ZSBvbmx5XG5cbiAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlIHx8XG4gICAgZmx1c2ggPiBaX0JMT0NLIHx8IGZsdXNoIDwgMCkge1xuICAgIHJldHVybiBzdHJtID8gZXJyKHN0cm0sIFpfU1RSRUFNX0VSUk9SKSA6IFpfU1RSRUFNX0VSUk9SO1xuICB9XG5cbiAgcyA9IHN0cm0uc3RhdGU7XG5cbiAgaWYgKCFzdHJtLm91dHB1dCB8fFxuICAgICAgKCFzdHJtLmlucHV0ICYmIHN0cm0uYXZhaWxfaW4gIT09IDApIHx8XG4gICAgICAocy5zdGF0dXMgPT09IEZJTklTSF9TVEFURSAmJiBmbHVzaCAhPT0gWl9GSU5JU0gpKSB7XG4gICAgcmV0dXJuIGVycihzdHJtLCAoc3RybS5hdmFpbF9vdXQgPT09IDApID8gWl9CVUZfRVJST1IgOiBaX1NUUkVBTV9FUlJPUik7XG4gIH1cblxuICBzLnN0cm0gPSBzdHJtOyAvKiBqdXN0IGluIGNhc2UgKi9cbiAgb2xkX2ZsdXNoID0gcy5sYXN0X2ZsdXNoO1xuICBzLmxhc3RfZmx1c2ggPSBmbHVzaDtcblxuICAvKiBXcml0ZSB0aGUgaGVhZGVyICovXG4gIGlmIChzLnN0YXR1cyA9PT0gSU5JVF9TVEFURSkge1xuXG4gICAgaWYgKHMud3JhcCA9PT0gMikgeyAvLyBHWklQIGhlYWRlclxuICAgICAgc3RybS5hZGxlciA9IDA7ICAvL2NyYzMyKDBMLCBaX05VTEwsIDApO1xuICAgICAgcHV0X2J5dGUocywgMzEpO1xuICAgICAgcHV0X2J5dGUocywgMTM5KTtcbiAgICAgIHB1dF9ieXRlKHMsIDgpO1xuICAgICAgaWYgKCFzLmd6aGVhZCkgeyAvLyBzLT5nemhlYWQgPT0gWl9OVUxMXG4gICAgICAgIHB1dF9ieXRlKHMsIDApO1xuICAgICAgICBwdXRfYnl0ZShzLCAwKTtcbiAgICAgICAgcHV0X2J5dGUocywgMCk7XG4gICAgICAgIHB1dF9ieXRlKHMsIDApO1xuICAgICAgICBwdXRfYnl0ZShzLCAwKTtcbiAgICAgICAgcHV0X2J5dGUocywgcy5sZXZlbCA9PT0gOSA/IDIgOlxuICAgICAgICAgICAgICAgICAgICAocy5zdHJhdGVneSA+PSBaX0hVRkZNQU5fT05MWSB8fCBzLmxldmVsIDwgMiA/XG4gICAgICAgICAgICAgICAgICAgICA0IDogMCkpO1xuICAgICAgICBwdXRfYnl0ZShzLCBPU19DT0RFKTtcbiAgICAgICAgcy5zdGF0dXMgPSBCVVNZX1NUQVRFO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHB1dF9ieXRlKHMsIChzLmd6aGVhZC50ZXh0ID8gMSA6IDApICtcbiAgICAgICAgICAgICAgICAgICAgKHMuZ3poZWFkLmhjcmMgPyAyIDogMCkgK1xuICAgICAgICAgICAgICAgICAgICAoIXMuZ3poZWFkLmV4dHJhID8gMCA6IDQpICtcbiAgICAgICAgICAgICAgICAgICAgKCFzLmd6aGVhZC5uYW1lID8gMCA6IDgpICtcbiAgICAgICAgICAgICAgICAgICAgKCFzLmd6aGVhZC5jb21tZW50ID8gMCA6IDE2KVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgIHB1dF9ieXRlKHMsIHMuZ3poZWFkLnRpbWUgJiAweGZmKTtcbiAgICAgICAgcHV0X2J5dGUocywgKHMuZ3poZWFkLnRpbWUgPj4gOCkgJiAweGZmKTtcbiAgICAgICAgcHV0X2J5dGUocywgKHMuZ3poZWFkLnRpbWUgPj4gMTYpICYgMHhmZik7XG4gICAgICAgIHB1dF9ieXRlKHMsIChzLmd6aGVhZC50aW1lID4+IDI0KSAmIDB4ZmYpO1xuICAgICAgICBwdXRfYnl0ZShzLCBzLmxldmVsID09PSA5ID8gMiA6XG4gICAgICAgICAgICAgICAgICAgIChzLnN0cmF0ZWd5ID49IFpfSFVGRk1BTl9PTkxZIHx8IHMubGV2ZWwgPCAyID9cbiAgICAgICAgICAgICAgICAgICAgIDQgOiAwKSk7XG4gICAgICAgIHB1dF9ieXRlKHMsIHMuZ3poZWFkLm9zICYgMHhmZik7XG4gICAgICAgIGlmIChzLmd6aGVhZC5leHRyYSAmJiBzLmd6aGVhZC5leHRyYS5sZW5ndGgpIHtcbiAgICAgICAgICBwdXRfYnl0ZShzLCBzLmd6aGVhZC5leHRyYS5sZW5ndGggJiAweGZmKTtcbiAgICAgICAgICBwdXRfYnl0ZShzLCAocy5nemhlYWQuZXh0cmEubGVuZ3RoID4+IDgpICYgMHhmZik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHMuZ3poZWFkLmhjcmMpIHtcbiAgICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzIoc3RybS5hZGxlciwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nLCAwKTtcbiAgICAgICAgfVxuICAgICAgICBzLmd6aW5kZXggPSAwO1xuICAgICAgICBzLnN0YXR1cyA9IEVYVFJBX1NUQVRFO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIC8vIERFRkxBVEUgaGVhZGVyXG4gICAge1xuICAgICAgdmFyIGhlYWRlciA9IChaX0RFRkxBVEVEICsgKChzLndfYml0cyAtIDgpIDw8IDQpKSA8PCA4O1xuICAgICAgdmFyIGxldmVsX2ZsYWdzID0gLTE7XG5cbiAgICAgIGlmIChzLnN0cmF0ZWd5ID49IFpfSFVGRk1BTl9PTkxZIHx8IHMubGV2ZWwgPCAyKSB7XG4gICAgICAgIGxldmVsX2ZsYWdzID0gMDtcbiAgICAgIH0gZWxzZSBpZiAocy5sZXZlbCA8IDYpIHtcbiAgICAgICAgbGV2ZWxfZmxhZ3MgPSAxO1xuICAgICAgfSBlbHNlIGlmIChzLmxldmVsID09PSA2KSB7XG4gICAgICAgIGxldmVsX2ZsYWdzID0gMjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldmVsX2ZsYWdzID0gMztcbiAgICAgIH1cbiAgICAgIGhlYWRlciB8PSAobGV2ZWxfZmxhZ3MgPDwgNik7XG4gICAgICBpZiAocy5zdHJzdGFydCAhPT0gMCkgeyBoZWFkZXIgfD0gUFJFU0VUX0RJQ1Q7IH1cbiAgICAgIGhlYWRlciArPSAzMSAtIChoZWFkZXIgJSAzMSk7XG5cbiAgICAgIHMuc3RhdHVzID0gQlVTWV9TVEFURTtcbiAgICAgIHB1dFNob3J0TVNCKHMsIGhlYWRlcik7XG5cbiAgICAgIC8qIFNhdmUgdGhlIGFkbGVyMzIgb2YgdGhlIHByZXNldCBkaWN0aW9uYXJ5OiAqL1xuICAgICAgaWYgKHMuc3Ryc3RhcnQgIT09IDApIHtcbiAgICAgICAgcHV0U2hvcnRNU0Iocywgc3RybS5hZGxlciA+Pj4gMTYpO1xuICAgICAgICBwdXRTaG9ydE1TQihzLCBzdHJtLmFkbGVyICYgMHhmZmZmKTtcbiAgICAgIH1cbiAgICAgIHN0cm0uYWRsZXIgPSAxOyAvLyBhZGxlcjMyKDBMLCBaX05VTEwsIDApO1xuICAgIH1cbiAgfVxuXG4vLyNpZmRlZiBHWklQXG4gIGlmIChzLnN0YXR1cyA9PT0gRVhUUkFfU1RBVEUpIHtcbiAgICBpZiAocy5nemhlYWQuZXh0cmEvKiAhPSBaX05VTEwqLykge1xuICAgICAgYmVnID0gcy5wZW5kaW5nOyAgLyogc3RhcnQgb2YgYnl0ZXMgdG8gdXBkYXRlIGNyYyAqL1xuXG4gICAgICB3aGlsZSAocy5nemluZGV4IDwgKHMuZ3poZWFkLmV4dHJhLmxlbmd0aCAmIDB4ZmZmZikpIHtcbiAgICAgICAgaWYgKHMucGVuZGluZyA9PT0gcy5wZW5kaW5nX2J1Zl9zaXplKSB7XG4gICAgICAgICAgaWYgKHMuZ3poZWFkLmhjcmMgJiYgcy5wZW5kaW5nID4gYmVnKSB7XG4gICAgICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzIoc3RybS5hZGxlciwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nIC0gYmVnLCBiZWcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmbHVzaF9wZW5kaW5nKHN0cm0pO1xuICAgICAgICAgIGJlZyA9IHMucGVuZGluZztcbiAgICAgICAgICBpZiAocy5wZW5kaW5nID09PSBzLnBlbmRpbmdfYnVmX3NpemUpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwdXRfYnl0ZShzLCBzLmd6aGVhZC5leHRyYVtzLmd6aW5kZXhdICYgMHhmZik7XG4gICAgICAgIHMuZ3ppbmRleCsrO1xuICAgICAgfVxuICAgICAgaWYgKHMuZ3poZWFkLmhjcmMgJiYgcy5wZW5kaW5nID4gYmVnKSB7XG4gICAgICAgIHN0cm0uYWRsZXIgPSBjcmMzMihzdHJtLmFkbGVyLCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmcgLSBiZWcsIGJlZyk7XG4gICAgICB9XG4gICAgICBpZiAocy5nemluZGV4ID09PSBzLmd6aGVhZC5leHRyYS5sZW5ndGgpIHtcbiAgICAgICAgcy5nemluZGV4ID0gMDtcbiAgICAgICAgcy5zdGF0dXMgPSBOQU1FX1NUQVRFO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHMuc3RhdHVzID0gTkFNRV9TVEFURTtcbiAgICB9XG4gIH1cbiAgaWYgKHMuc3RhdHVzID09PSBOQU1FX1NUQVRFKSB7XG4gICAgaWYgKHMuZ3poZWFkLm5hbWUvKiAhPSBaX05VTEwqLykge1xuICAgICAgYmVnID0gcy5wZW5kaW5nOyAgLyogc3RhcnQgb2YgYnl0ZXMgdG8gdXBkYXRlIGNyYyAqL1xuICAgICAgLy9pbnQgdmFsO1xuXG4gICAgICBkbyB7XG4gICAgICAgIGlmIChzLnBlbmRpbmcgPT09IHMucGVuZGluZ19idWZfc2l6ZSkge1xuICAgICAgICAgIGlmIChzLmd6aGVhZC5oY3JjICYmIHMucGVuZGluZyA+IGJlZykge1xuICAgICAgICAgICAgc3RybS5hZGxlciA9IGNyYzMyKHN0cm0uYWRsZXIsIHMucGVuZGluZ19idWYsIHMucGVuZGluZyAtIGJlZywgYmVnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZmx1c2hfcGVuZGluZyhzdHJtKTtcbiAgICAgICAgICBiZWcgPSBzLnBlbmRpbmc7XG4gICAgICAgICAgaWYgKHMucGVuZGluZyA9PT0gcy5wZW5kaW5nX2J1Zl9zaXplKSB7XG4gICAgICAgICAgICB2YWwgPSAxO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEpTIHNwZWNpZmljOiBsaXR0bGUgbWFnaWMgdG8gYWRkIHplcm8gdGVybWluYXRvciB0byBlbmQgb2Ygc3RyaW5nXG4gICAgICAgIGlmIChzLmd6aW5kZXggPCBzLmd6aGVhZC5uYW1lLmxlbmd0aCkge1xuICAgICAgICAgIHZhbCA9IHMuZ3poZWFkLm5hbWUuY2hhckNvZGVBdChzLmd6aW5kZXgrKykgJiAweGZmO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcHV0X2J5dGUocywgdmFsKTtcbiAgICAgIH0gd2hpbGUgKHZhbCAhPT0gMCk7XG5cbiAgICAgIGlmIChzLmd6aGVhZC5oY3JjICYmIHMucGVuZGluZyA+IGJlZykge1xuICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzIoc3RybS5hZGxlciwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nIC0gYmVnLCBiZWcpO1xuICAgICAgfVxuICAgICAgaWYgKHZhbCA9PT0gMCkge1xuICAgICAgICBzLmd6aW5kZXggPSAwO1xuICAgICAgICBzLnN0YXR1cyA9IENPTU1FTlRfU1RBVEU7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcy5zdGF0dXMgPSBDT01NRU5UX1NUQVRFO1xuICAgIH1cbiAgfVxuICBpZiAocy5zdGF0dXMgPT09IENPTU1FTlRfU1RBVEUpIHtcbiAgICBpZiAocy5nemhlYWQuY29tbWVudC8qICE9IFpfTlVMTCovKSB7XG4gICAgICBiZWcgPSBzLnBlbmRpbmc7ICAvKiBzdGFydCBvZiBieXRlcyB0byB1cGRhdGUgY3JjICovXG4gICAgICAvL2ludCB2YWw7XG5cbiAgICAgIGRvIHtcbiAgICAgICAgaWYgKHMucGVuZGluZyA9PT0gcy5wZW5kaW5nX2J1Zl9zaXplKSB7XG4gICAgICAgICAgaWYgKHMuZ3poZWFkLmhjcmMgJiYgcy5wZW5kaW5nID4gYmVnKSB7XG4gICAgICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzIoc3RybS5hZGxlciwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nIC0gYmVnLCBiZWcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmbHVzaF9wZW5kaW5nKHN0cm0pO1xuICAgICAgICAgIGJlZyA9IHMucGVuZGluZztcbiAgICAgICAgICBpZiAocy5wZW5kaW5nID09PSBzLnBlbmRpbmdfYnVmX3NpemUpIHtcbiAgICAgICAgICAgIHZhbCA9IDE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSlMgc3BlY2lmaWM6IGxpdHRsZSBtYWdpYyB0byBhZGQgemVybyB0ZXJtaW5hdG9yIHRvIGVuZCBvZiBzdHJpbmdcbiAgICAgICAgaWYgKHMuZ3ppbmRleCA8IHMuZ3poZWFkLmNvbW1lbnQubGVuZ3RoKSB7XG4gICAgICAgICAgdmFsID0gcy5nemhlYWQuY29tbWVudC5jaGFyQ29kZUF0KHMuZ3ppbmRleCsrKSAmIDB4ZmY7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsID0gMDtcbiAgICAgICAgfVxuICAgICAgICBwdXRfYnl0ZShzLCB2YWwpO1xuICAgICAgfSB3aGlsZSAodmFsICE9PSAwKTtcblxuICAgICAgaWYgKHMuZ3poZWFkLmhjcmMgJiYgcy5wZW5kaW5nID4gYmVnKSB7XG4gICAgICAgIHN0cm0uYWRsZXIgPSBjcmMzMihzdHJtLmFkbGVyLCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmcgLSBiZWcsIGJlZyk7XG4gICAgICB9XG4gICAgICBpZiAodmFsID09PSAwKSB7XG4gICAgICAgIHMuc3RhdHVzID0gSENSQ19TVEFURTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBzLnN0YXR1cyA9IEhDUkNfU1RBVEU7XG4gICAgfVxuICB9XG4gIGlmIChzLnN0YXR1cyA9PT0gSENSQ19TVEFURSkge1xuICAgIGlmIChzLmd6aGVhZC5oY3JjKSB7XG4gICAgICBpZiAocy5wZW5kaW5nICsgMiA+IHMucGVuZGluZ19idWZfc2l6ZSkge1xuICAgICAgICBmbHVzaF9wZW5kaW5nKHN0cm0pO1xuICAgICAgfVxuICAgICAgaWYgKHMucGVuZGluZyArIDIgPD0gcy5wZW5kaW5nX2J1Zl9zaXplKSB7XG4gICAgICAgIHB1dF9ieXRlKHMsIHN0cm0uYWRsZXIgJiAweGZmKTtcbiAgICAgICAgcHV0X2J5dGUocywgKHN0cm0uYWRsZXIgPj4gOCkgJiAweGZmKTtcbiAgICAgICAgc3RybS5hZGxlciA9IDA7IC8vY3JjMzIoMEwsIFpfTlVMTCwgMCk7XG4gICAgICAgIHMuc3RhdHVzID0gQlVTWV9TVEFURTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBzLnN0YXR1cyA9IEJVU1lfU1RBVEU7XG4gICAgfVxuICB9XG4vLyNlbmRpZlxuXG4gIC8qIEZsdXNoIGFzIG11Y2ggcGVuZGluZyBvdXRwdXQgYXMgcG9zc2libGUgKi9cbiAgaWYgKHMucGVuZGluZyAhPT0gMCkge1xuICAgIGZsdXNoX3BlbmRpbmcoc3RybSk7XG4gICAgaWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAvKiBTaW5jZSBhdmFpbF9vdXQgaXMgMCwgZGVmbGF0ZSB3aWxsIGJlIGNhbGxlZCBhZ2FpbiB3aXRoXG4gICAgICAgKiBtb3JlIG91dHB1dCBzcGFjZSwgYnV0IHBvc3NpYmx5IHdpdGggYm90aCBwZW5kaW5nIGFuZFxuICAgICAgICogYXZhaWxfaW4gZXF1YWwgdG8gemVyby4gVGhlcmUgd29uJ3QgYmUgYW55dGhpbmcgdG8gZG8sXG4gICAgICAgKiBidXQgdGhpcyBpcyBub3QgYW4gZXJyb3Igc2l0dWF0aW9uIHNvIG1ha2Ugc3VyZSB3ZVxuICAgICAgICogcmV0dXJuIE9LIGluc3RlYWQgb2YgQlVGX0VSUk9SIGF0IG5leHQgY2FsbCBvZiBkZWZsYXRlOlxuICAgICAgICovXG4gICAgICBzLmxhc3RfZmx1c2ggPSAtMTtcbiAgICAgIHJldHVybiBaX09LO1xuICAgIH1cblxuICAgIC8qIE1ha2Ugc3VyZSB0aGVyZSBpcyBzb21ldGhpbmcgdG8gZG8gYW5kIGF2b2lkIGR1cGxpY2F0ZSBjb25zZWN1dGl2ZVxuICAgICAqIGZsdXNoZXMuIEZvciByZXBlYXRlZCBhbmQgdXNlbGVzcyBjYWxscyB3aXRoIFpfRklOSVNILCB3ZSBrZWVwXG4gICAgICogcmV0dXJuaW5nIFpfU1RSRUFNX0VORCBpbnN0ZWFkIG9mIFpfQlVGX0VSUk9SLlxuICAgICAqL1xuICB9IGVsc2UgaWYgKHN0cm0uYXZhaWxfaW4gPT09IDAgJiYgcmFuayhmbHVzaCkgPD0gcmFuayhvbGRfZmx1c2gpICYmXG4gICAgZmx1c2ggIT09IFpfRklOSVNIKSB7XG4gICAgcmV0dXJuIGVycihzdHJtLCBaX0JVRl9FUlJPUik7XG4gIH1cblxuICAvKiBVc2VyIG11c3Qgbm90IHByb3ZpZGUgbW9yZSBpbnB1dCBhZnRlciB0aGUgZmlyc3QgRklOSVNIOiAqL1xuICBpZiAocy5zdGF0dXMgPT09IEZJTklTSF9TVEFURSAmJiBzdHJtLmF2YWlsX2luICE9PSAwKSB7XG4gICAgcmV0dXJuIGVycihzdHJtLCBaX0JVRl9FUlJPUik7XG4gIH1cblxuICAvKiBTdGFydCBhIG5ldyBibG9jayBvciBjb250aW51ZSB0aGUgY3VycmVudCBvbmUuXG4gICAqL1xuICBpZiAoc3RybS5hdmFpbF9pbiAhPT0gMCB8fCBzLmxvb2thaGVhZCAhPT0gMCB8fFxuICAgIChmbHVzaCAhPT0gWl9OT19GTFVTSCAmJiBzLnN0YXR1cyAhPT0gRklOSVNIX1NUQVRFKSkge1xuICAgIHZhciBic3RhdGUgPSAocy5zdHJhdGVneSA9PT0gWl9IVUZGTUFOX09OTFkpID8gZGVmbGF0ZV9odWZmKHMsIGZsdXNoKSA6XG4gICAgICAocy5zdHJhdGVneSA9PT0gWl9STEUgPyBkZWZsYXRlX3JsZShzLCBmbHVzaCkgOlxuICAgICAgICBjb25maWd1cmF0aW9uX3RhYmxlW3MubGV2ZWxdLmZ1bmMocywgZmx1c2gpKTtcblxuICAgIGlmIChic3RhdGUgPT09IEJTX0ZJTklTSF9TVEFSVEVEIHx8IGJzdGF0ZSA9PT0gQlNfRklOSVNIX0RPTkUpIHtcbiAgICAgIHMuc3RhdHVzID0gRklOSVNIX1NUQVRFO1xuICAgIH1cbiAgICBpZiAoYnN0YXRlID09PSBCU19ORUVEX01PUkUgfHwgYnN0YXRlID09PSBCU19GSU5JU0hfU1RBUlRFRCkge1xuICAgICAgaWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgIHMubGFzdF9mbHVzaCA9IC0xO1xuICAgICAgICAvKiBhdm9pZCBCVUZfRVJST1IgbmV4dCBjYWxsLCBzZWUgYWJvdmUgKi9cbiAgICAgIH1cbiAgICAgIHJldHVybiBaX09LO1xuICAgICAgLyogSWYgZmx1c2ggIT0gWl9OT19GTFVTSCAmJiBhdmFpbF9vdXQgPT0gMCwgdGhlIG5leHQgY2FsbFxuICAgICAgICogb2YgZGVmbGF0ZSBzaG91bGQgdXNlIHRoZSBzYW1lIGZsdXNoIHBhcmFtZXRlciB0byBtYWtlIHN1cmVcbiAgICAgICAqIHRoYXQgdGhlIGZsdXNoIGlzIGNvbXBsZXRlLiBTbyB3ZSBkb24ndCBoYXZlIHRvIG91dHB1dCBhblxuICAgICAgICogZW1wdHkgYmxvY2sgaGVyZSwgdGhpcyB3aWxsIGJlIGRvbmUgYXQgbmV4dCBjYWxsLiBUaGlzIGFsc29cbiAgICAgICAqIGVuc3VyZXMgdGhhdCBmb3IgYSB2ZXJ5IHNtYWxsIG91dHB1dCBidWZmZXIsIHdlIGVtaXQgYXQgbW9zdFxuICAgICAgICogb25lIGVtcHR5IGJsb2NrLlxuICAgICAgICovXG4gICAgfVxuICAgIGlmIChic3RhdGUgPT09IEJTX0JMT0NLX0RPTkUpIHtcbiAgICAgIGlmIChmbHVzaCA9PT0gWl9QQVJUSUFMX0ZMVVNIKSB7XG4gICAgICAgIHRyZWVzLl90cl9hbGlnbihzKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGZsdXNoICE9PSBaX0JMT0NLKSB7IC8qIEZVTExfRkxVU0ggb3IgU1lOQ19GTFVTSCAqL1xuXG4gICAgICAgIHRyZWVzLl90cl9zdG9yZWRfYmxvY2socywgMCwgMCwgZmFsc2UpO1xuICAgICAgICAvKiBGb3IgYSBmdWxsIGZsdXNoLCB0aGlzIGVtcHR5IGJsb2NrIHdpbGwgYmUgcmVjb2duaXplZFxuICAgICAgICAgKiBhcyBhIHNwZWNpYWwgbWFya2VyIGJ5IGluZmxhdGVfc3luYygpLlxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKGZsdXNoID09PSBaX0ZVTExfRkxVU0gpIHtcbiAgICAgICAgICAvKioqIENMRUFSX0hBU0gocyk7ICoqKi8gICAgICAgICAgICAgLyogZm9yZ2V0IGhpc3RvcnkgKi9cbiAgICAgICAgICB6ZXJvKHMuaGVhZCk7IC8vIEZpbGwgd2l0aCBOSUwgKD0gMCk7XG5cbiAgICAgICAgICBpZiAocy5sb29rYWhlYWQgPT09IDApIHtcbiAgICAgICAgICAgIHMuc3Ryc3RhcnQgPSAwO1xuICAgICAgICAgICAgcy5ibG9ja19zdGFydCA9IDA7XG4gICAgICAgICAgICBzLmluc2VydCA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmbHVzaF9wZW5kaW5nKHN0cm0pO1xuICAgICAgaWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgIHMubGFzdF9mbHVzaCA9IC0xOyAvKiBhdm9pZCBCVUZfRVJST1IgYXQgbmV4dCBjYWxsLCBzZWUgYWJvdmUgKi9cbiAgICAgICAgcmV0dXJuIFpfT0s7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8vQXNzZXJ0KHN0cm0tPmF2YWlsX291dCA+IDAsIFwiYnVnMlwiKTtcbiAgLy9pZiAoc3RybS5hdmFpbF9vdXQgPD0gMCkgeyB0aHJvdyBuZXcgRXJyb3IoXCJidWcyXCIpO31cblxuICBpZiAoZmx1c2ggIT09IFpfRklOSVNIKSB7IHJldHVybiBaX09LOyB9XG4gIGlmIChzLndyYXAgPD0gMCkgeyByZXR1cm4gWl9TVFJFQU1fRU5EOyB9XG5cbiAgLyogV3JpdGUgdGhlIHRyYWlsZXIgKi9cbiAgaWYgKHMud3JhcCA9PT0gMikge1xuICAgIHB1dF9ieXRlKHMsIHN0cm0uYWRsZXIgJiAweGZmKTtcbiAgICBwdXRfYnl0ZShzLCAoc3RybS5hZGxlciA+PiA4KSAmIDB4ZmYpO1xuICAgIHB1dF9ieXRlKHMsIChzdHJtLmFkbGVyID4+IDE2KSAmIDB4ZmYpO1xuICAgIHB1dF9ieXRlKHMsIChzdHJtLmFkbGVyID4+IDI0KSAmIDB4ZmYpO1xuICAgIHB1dF9ieXRlKHMsIHN0cm0udG90YWxfaW4gJiAweGZmKTtcbiAgICBwdXRfYnl0ZShzLCAoc3RybS50b3RhbF9pbiA+PiA4KSAmIDB4ZmYpO1xuICAgIHB1dF9ieXRlKHMsIChzdHJtLnRvdGFsX2luID4+IDE2KSAmIDB4ZmYpO1xuICAgIHB1dF9ieXRlKHMsIChzdHJtLnRvdGFsX2luID4+IDI0KSAmIDB4ZmYpO1xuICB9XG4gIGVsc2VcbiAge1xuICAgIHB1dFNob3J0TVNCKHMsIHN0cm0uYWRsZXIgPj4+IDE2KTtcbiAgICBwdXRTaG9ydE1TQihzLCBzdHJtLmFkbGVyICYgMHhmZmZmKTtcbiAgfVxuXG4gIGZsdXNoX3BlbmRpbmcoc3RybSk7XG4gIC8qIElmIGF2YWlsX291dCBpcyB6ZXJvLCB0aGUgYXBwbGljYXRpb24gd2lsbCBjYWxsIGRlZmxhdGUgYWdhaW5cbiAgICogdG8gZmx1c2ggdGhlIHJlc3QuXG4gICAqL1xuICBpZiAocy53cmFwID4gMCkgeyBzLndyYXAgPSAtcy53cmFwOyB9XG4gIC8qIHdyaXRlIHRoZSB0cmFpbGVyIG9ubHkgb25jZSEgKi9cbiAgcmV0dXJuIHMucGVuZGluZyAhPT0gMCA/IFpfT0sgOiBaX1NUUkVBTV9FTkQ7XG59XG5cbmZ1bmN0aW9uIGRlZmxhdGVFbmQoc3RybSkge1xuICB2YXIgc3RhdHVzO1xuXG4gIGlmICghc3RybS8qPT0gWl9OVUxMKi8gfHwgIXN0cm0uc3RhdGUvKj09IFpfTlVMTCovKSB7XG4gICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICB9XG5cbiAgc3RhdHVzID0gc3RybS5zdGF0ZS5zdGF0dXM7XG4gIGlmIChzdGF0dXMgIT09IElOSVRfU1RBVEUgJiZcbiAgICBzdGF0dXMgIT09IEVYVFJBX1NUQVRFICYmXG4gICAgc3RhdHVzICE9PSBOQU1FX1NUQVRFICYmXG4gICAgc3RhdHVzICE9PSBDT01NRU5UX1NUQVRFICYmXG4gICAgc3RhdHVzICE9PSBIQ1JDX1NUQVRFICYmXG4gICAgc3RhdHVzICE9PSBCVVNZX1NUQVRFICYmXG4gICAgc3RhdHVzICE9PSBGSU5JU0hfU1RBVEVcbiAgKSB7XG4gICAgcmV0dXJuIGVycihzdHJtLCBaX1NUUkVBTV9FUlJPUik7XG4gIH1cblxuICBzdHJtLnN0YXRlID0gbnVsbDtcblxuICByZXR1cm4gc3RhdHVzID09PSBCVVNZX1NUQVRFID8gZXJyKHN0cm0sIFpfREFUQV9FUlJPUikgOiBaX09LO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEluaXRpYWxpemVzIHRoZSBjb21wcmVzc2lvbiBkaWN0aW9uYXJ5IGZyb20gdGhlIGdpdmVuIGJ5dGVcbiAqIHNlcXVlbmNlIHdpdGhvdXQgcHJvZHVjaW5nIGFueSBjb21wcmVzc2VkIG91dHB1dC5cbiAqL1xuZnVuY3Rpb24gZGVmbGF0ZVNldERpY3Rpb25hcnkoc3RybSwgZGljdGlvbmFyeSkge1xuICB2YXIgZGljdExlbmd0aCA9IGRpY3Rpb25hcnkubGVuZ3RoO1xuXG4gIHZhciBzO1xuICB2YXIgc3RyLCBuO1xuICB2YXIgd3JhcDtcbiAgdmFyIGF2YWlsO1xuICB2YXIgbmV4dDtcbiAgdmFyIGlucHV0O1xuICB2YXIgdG1wRGljdDtcblxuICBpZiAoIXN0cm0vKj09IFpfTlVMTCovIHx8ICFzdHJtLnN0YXRlLyo9PSBaX05VTEwqLykge1xuICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgfVxuXG4gIHMgPSBzdHJtLnN0YXRlO1xuICB3cmFwID0gcy53cmFwO1xuXG4gIGlmICh3cmFwID09PSAyIHx8ICh3cmFwID09PSAxICYmIHMuc3RhdHVzICE9PSBJTklUX1NUQVRFKSB8fCBzLmxvb2thaGVhZCkge1xuICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgfVxuXG4gIC8qIHdoZW4gdXNpbmcgemxpYiB3cmFwcGVycywgY29tcHV0ZSBBZGxlci0zMiBmb3IgcHJvdmlkZWQgZGljdGlvbmFyeSAqL1xuICBpZiAod3JhcCA9PT0gMSkge1xuICAgIC8qIGFkbGVyMzIoc3RybS0+YWRsZXIsIGRpY3Rpb25hcnksIGRpY3RMZW5ndGgpOyAqL1xuICAgIHN0cm0uYWRsZXIgPSBhZGxlcjMyKHN0cm0uYWRsZXIsIGRpY3Rpb25hcnksIGRpY3RMZW5ndGgsIDApO1xuICB9XG5cbiAgcy53cmFwID0gMDsgICAvKiBhdm9pZCBjb21wdXRpbmcgQWRsZXItMzIgaW4gcmVhZF9idWYgKi9cblxuICAvKiBpZiBkaWN0aW9uYXJ5IHdvdWxkIGZpbGwgd2luZG93LCBqdXN0IHJlcGxhY2UgdGhlIGhpc3RvcnkgKi9cbiAgaWYgKGRpY3RMZW5ndGggPj0gcy53X3NpemUpIHtcbiAgICBpZiAod3JhcCA9PT0gMCkgeyAgICAgICAgICAgIC8qIGFscmVhZHkgZW1wdHkgb3RoZXJ3aXNlICovXG4gICAgICAvKioqIENMRUFSX0hBU0gocyk7ICoqKi9cbiAgICAgIHplcm8ocy5oZWFkKTsgLy8gRmlsbCB3aXRoIE5JTCAoPSAwKTtcbiAgICAgIHMuc3Ryc3RhcnQgPSAwO1xuICAgICAgcy5ibG9ja19zdGFydCA9IDA7XG4gICAgICBzLmluc2VydCA9IDA7XG4gICAgfVxuICAgIC8qIHVzZSB0aGUgdGFpbCAqL1xuICAgIC8vIGRpY3Rpb25hcnkgPSBkaWN0aW9uYXJ5LnNsaWNlKGRpY3RMZW5ndGggLSBzLndfc2l6ZSk7XG4gICAgdG1wRGljdCA9IG5ldyB1dGlscy5CdWY4KHMud19zaXplKTtcbiAgICB1dGlscy5hcnJheVNldCh0bXBEaWN0LCBkaWN0aW9uYXJ5LCBkaWN0TGVuZ3RoIC0gcy53X3NpemUsIHMud19zaXplLCAwKTtcbiAgICBkaWN0aW9uYXJ5ID0gdG1wRGljdDtcbiAgICBkaWN0TGVuZ3RoID0gcy53X3NpemU7XG4gIH1cbiAgLyogaW5zZXJ0IGRpY3Rpb25hcnkgaW50byB3aW5kb3cgYW5kIGhhc2ggKi9cbiAgYXZhaWwgPSBzdHJtLmF2YWlsX2luO1xuICBuZXh0ID0gc3RybS5uZXh0X2luO1xuICBpbnB1dCA9IHN0cm0uaW5wdXQ7XG4gIHN0cm0uYXZhaWxfaW4gPSBkaWN0TGVuZ3RoO1xuICBzdHJtLm5leHRfaW4gPSAwO1xuICBzdHJtLmlucHV0ID0gZGljdGlvbmFyeTtcbiAgZmlsbF93aW5kb3cocyk7XG4gIHdoaWxlIChzLmxvb2thaGVhZCA+PSBNSU5fTUFUQ0gpIHtcbiAgICBzdHIgPSBzLnN0cnN0YXJ0O1xuICAgIG4gPSBzLmxvb2thaGVhZCAtIChNSU5fTUFUQ0ggLSAxKTtcbiAgICBkbyB7XG4gICAgICAvKiBVUERBVEVfSEFTSChzLCBzLT5pbnNfaCwgcy0+d2luZG93W3N0ciArIE1JTl9NQVRDSC0xXSk7ICovXG4gICAgICBzLmluc19oID0gKChzLmluc19oIDw8IHMuaGFzaF9zaGlmdCkgXiBzLndpbmRvd1tzdHIgKyBNSU5fTUFUQ0ggLSAxXSkgJiBzLmhhc2hfbWFzaztcblxuICAgICAgcy5wcmV2W3N0ciAmIHMud19tYXNrXSA9IHMuaGVhZFtzLmluc19oXTtcblxuICAgICAgcy5oZWFkW3MuaW5zX2hdID0gc3RyO1xuICAgICAgc3RyKys7XG4gICAgfSB3aGlsZSAoLS1uKTtcbiAgICBzLnN0cnN0YXJ0ID0gc3RyO1xuICAgIHMubG9va2FoZWFkID0gTUlOX01BVENIIC0gMTtcbiAgICBmaWxsX3dpbmRvdyhzKTtcbiAgfVxuICBzLnN0cnN0YXJ0ICs9IHMubG9va2FoZWFkO1xuICBzLmJsb2NrX3N0YXJ0ID0gcy5zdHJzdGFydDtcbiAgcy5pbnNlcnQgPSBzLmxvb2thaGVhZDtcbiAgcy5sb29rYWhlYWQgPSAwO1xuICBzLm1hdGNoX2xlbmd0aCA9IHMucHJldl9sZW5ndGggPSBNSU5fTUFUQ0ggLSAxO1xuICBzLm1hdGNoX2F2YWlsYWJsZSA9IDA7XG4gIHN0cm0ubmV4dF9pbiA9IG5leHQ7XG4gIHN0cm0uaW5wdXQgPSBpbnB1dDtcbiAgc3RybS5hdmFpbF9pbiA9IGF2YWlsO1xuICBzLndyYXAgPSB3cmFwO1xuICByZXR1cm4gWl9PSztcbn1cblxuXG5leHBvcnRzLmRlZmxhdGVJbml0ID0gZGVmbGF0ZUluaXQ7XG5leHBvcnRzLmRlZmxhdGVJbml0MiA9IGRlZmxhdGVJbml0MjtcbmV4cG9ydHMuZGVmbGF0ZVJlc2V0ID0gZGVmbGF0ZVJlc2V0O1xuZXhwb3J0cy5kZWZsYXRlUmVzZXRLZWVwID0gZGVmbGF0ZVJlc2V0S2VlcDtcbmV4cG9ydHMuZGVmbGF0ZVNldEhlYWRlciA9IGRlZmxhdGVTZXRIZWFkZXI7XG5leHBvcnRzLmRlZmxhdGUgPSBkZWZsYXRlO1xuZXhwb3J0cy5kZWZsYXRlRW5kID0gZGVmbGF0ZUVuZDtcbmV4cG9ydHMuZGVmbGF0ZVNldERpY3Rpb25hcnkgPSBkZWZsYXRlU2V0RGljdGlvbmFyeTtcbmV4cG9ydHMuZGVmbGF0ZUluZm8gPSAncGFrbyBkZWZsYXRlIChmcm9tIE5vZGVjYSBwcm9qZWN0KSc7XG5cbi8qIE5vdCBpbXBsZW1lbnRlZFxuZXhwb3J0cy5kZWZsYXRlQm91bmQgPSBkZWZsYXRlQm91bmQ7XG5leHBvcnRzLmRlZmxhdGVDb3B5ID0gZGVmbGF0ZUNvcHk7XG5leHBvcnRzLmRlZmxhdGVQYXJhbXMgPSBkZWZsYXRlUGFyYW1zO1xuZXhwb3J0cy5kZWZsYXRlUGVuZGluZyA9IGRlZmxhdGVQZW5kaW5nO1xuZXhwb3J0cy5kZWZsYXRlUHJpbWUgPSBkZWZsYXRlUHJpbWU7XG5leHBvcnRzLmRlZmxhdGVUdW5lID0gZGVmbGF0ZVR1bmU7XG4qL1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyBTZWUgc3RhdGUgZGVmcyBmcm9tIGluZmxhdGUuanNcbnZhciBCQUQgPSAzMDsgICAgICAgLyogZ290IGEgZGF0YSBlcnJvciAtLSByZW1haW4gaGVyZSB1bnRpbCByZXNldCAqL1xudmFyIFRZUEUgPSAxMjsgICAgICAvKiBpOiB3YWl0aW5nIGZvciB0eXBlIGJpdHMsIGluY2x1ZGluZyBsYXN0LWZsYWcgYml0ICovXG5cbi8qXG4gICBEZWNvZGUgbGl0ZXJhbCwgbGVuZ3RoLCBhbmQgZGlzdGFuY2UgY29kZXMgYW5kIHdyaXRlIG91dCB0aGUgcmVzdWx0aW5nXG4gICBsaXRlcmFsIGFuZCBtYXRjaCBieXRlcyB1bnRpbCBlaXRoZXIgbm90IGVub3VnaCBpbnB1dCBvciBvdXRwdXQgaXNcbiAgIGF2YWlsYWJsZSwgYW4gZW5kLW9mLWJsb2NrIGlzIGVuY291bnRlcmVkLCBvciBhIGRhdGEgZXJyb3IgaXMgZW5jb3VudGVyZWQuXG4gICBXaGVuIGxhcmdlIGVub3VnaCBpbnB1dCBhbmQgb3V0cHV0IGJ1ZmZlcnMgYXJlIHN1cHBsaWVkIHRvIGluZmxhdGUoKSwgZm9yXG4gICBleGFtcGxlLCBhIDE2SyBpbnB1dCBidWZmZXIgYW5kIGEgNjRLIG91dHB1dCBidWZmZXIsIG1vcmUgdGhhbiA5NSUgb2YgdGhlXG4gICBpbmZsYXRlIGV4ZWN1dGlvbiB0aW1lIGlzIHNwZW50IGluIHRoaXMgcm91dGluZS5cblxuICAgRW50cnkgYXNzdW1wdGlvbnM6XG5cbiAgICAgICAgc3RhdGUubW9kZSA9PT0gTEVOXG4gICAgICAgIHN0cm0uYXZhaWxfaW4gPj0gNlxuICAgICAgICBzdHJtLmF2YWlsX291dCA+PSAyNThcbiAgICAgICAgc3RhcnQgPj0gc3RybS5hdmFpbF9vdXRcbiAgICAgICAgc3RhdGUuYml0cyA8IDhcblxuICAgT24gcmV0dXJuLCBzdGF0ZS5tb2RlIGlzIG9uZSBvZjpcblxuICAgICAgICBMRU4gLS0gcmFuIG91dCBvZiBlbm91Z2ggb3V0cHV0IHNwYWNlIG9yIGVub3VnaCBhdmFpbGFibGUgaW5wdXRcbiAgICAgICAgVFlQRSAtLSByZWFjaGVkIGVuZCBvZiBibG9jayBjb2RlLCBpbmZsYXRlKCkgdG8gaW50ZXJwcmV0IG5leHQgYmxvY2tcbiAgICAgICAgQkFEIC0tIGVycm9yIGluIGJsb2NrIGRhdGFcblxuICAgTm90ZXM6XG5cbiAgICAtIFRoZSBtYXhpbXVtIGlucHV0IGJpdHMgdXNlZCBieSBhIGxlbmd0aC9kaXN0YW5jZSBwYWlyIGlzIDE1IGJpdHMgZm9yIHRoZVxuICAgICAgbGVuZ3RoIGNvZGUsIDUgYml0cyBmb3IgdGhlIGxlbmd0aCBleHRyYSwgMTUgYml0cyBmb3IgdGhlIGRpc3RhbmNlIGNvZGUsXG4gICAgICBhbmQgMTMgYml0cyBmb3IgdGhlIGRpc3RhbmNlIGV4dHJhLiAgVGhpcyB0b3RhbHMgNDggYml0cywgb3Igc2l4IGJ5dGVzLlxuICAgICAgVGhlcmVmb3JlIGlmIHN0cm0uYXZhaWxfaW4gPj0gNiwgdGhlbiB0aGVyZSBpcyBlbm91Z2ggaW5wdXQgdG8gYXZvaWRcbiAgICAgIGNoZWNraW5nIGZvciBhdmFpbGFibGUgaW5wdXQgd2hpbGUgZGVjb2RpbmcuXG5cbiAgICAtIFRoZSBtYXhpbXVtIGJ5dGVzIHRoYXQgYSBzaW5nbGUgbGVuZ3RoL2Rpc3RhbmNlIHBhaXIgY2FuIG91dHB1dCBpcyAyNThcbiAgICAgIGJ5dGVzLCB3aGljaCBpcyB0aGUgbWF4aW11bSBsZW5ndGggdGhhdCBjYW4gYmUgY29kZWQuICBpbmZsYXRlX2Zhc3QoKVxuICAgICAgcmVxdWlyZXMgc3RybS5hdmFpbF9vdXQgPj0gMjU4IGZvciBlYWNoIGxvb3AgdG8gYXZvaWQgY2hlY2tpbmcgZm9yXG4gICAgICBvdXRwdXQgc3BhY2UuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5mbGF0ZV9mYXN0KHN0cm0sIHN0YXJ0KSB7XG4gIHZhciBzdGF0ZTtcbiAgdmFyIF9pbjsgICAgICAgICAgICAgICAgICAgIC8qIGxvY2FsIHN0cm0uaW5wdXQgKi9cbiAgdmFyIGxhc3Q7ICAgICAgICAgICAgICAgICAgIC8qIGhhdmUgZW5vdWdoIGlucHV0IHdoaWxlIGluIDwgbGFzdCAqL1xuICB2YXIgX291dDsgICAgICAgICAgICAgICAgICAgLyogbG9jYWwgc3RybS5vdXRwdXQgKi9cbiAgdmFyIGJlZzsgICAgICAgICAgICAgICAgICAgIC8qIGluZmxhdGUoKSdzIGluaXRpYWwgc3RybS5vdXRwdXQgKi9cbiAgdmFyIGVuZDsgICAgICAgICAgICAgICAgICAgIC8qIHdoaWxlIG91dCA8IGVuZCwgZW5vdWdoIHNwYWNlIGF2YWlsYWJsZSAqL1xuLy8jaWZkZWYgSU5GTEFURV9TVFJJQ1RcbiAgdmFyIGRtYXg7ICAgICAgICAgICAgICAgICAgIC8qIG1heGltdW0gZGlzdGFuY2UgZnJvbSB6bGliIGhlYWRlciAqL1xuLy8jZW5kaWZcbiAgdmFyIHdzaXplOyAgICAgICAgICAgICAgICAgIC8qIHdpbmRvdyBzaXplIG9yIHplcm8gaWYgbm90IHVzaW5nIHdpbmRvdyAqL1xuICB2YXIgd2hhdmU7ICAgICAgICAgICAgICAgICAgLyogdmFsaWQgYnl0ZXMgaW4gdGhlIHdpbmRvdyAqL1xuICB2YXIgd25leHQ7ICAgICAgICAgICAgICAgICAgLyogd2luZG93IHdyaXRlIGluZGV4ICovXG4gIC8vIFVzZSBgc193aW5kb3dgIGluc3RlYWQgYHdpbmRvd2AsIGF2b2lkIGNvbmZsaWN0IHdpdGggaW5zdHJ1bWVudGF0aW9uIHRvb2xzXG4gIHZhciBzX3dpbmRvdzsgICAgICAgICAgICAgICAvKiBhbGxvY2F0ZWQgc2xpZGluZyB3aW5kb3csIGlmIHdzaXplICE9IDAgKi9cbiAgdmFyIGhvbGQ7ICAgICAgICAgICAgICAgICAgIC8qIGxvY2FsIHN0cm0uaG9sZCAqL1xuICB2YXIgYml0czsgICAgICAgICAgICAgICAgICAgLyogbG9jYWwgc3RybS5iaXRzICovXG4gIHZhciBsY29kZTsgICAgICAgICAgICAgICAgICAvKiBsb2NhbCBzdHJtLmxlbmNvZGUgKi9cbiAgdmFyIGRjb2RlOyAgICAgICAgICAgICAgICAgIC8qIGxvY2FsIHN0cm0uZGlzdGNvZGUgKi9cbiAgdmFyIGxtYXNrOyAgICAgICAgICAgICAgICAgIC8qIG1hc2sgZm9yIGZpcnN0IGxldmVsIG9mIGxlbmd0aCBjb2RlcyAqL1xuICB2YXIgZG1hc2s7ICAgICAgICAgICAgICAgICAgLyogbWFzayBmb3IgZmlyc3QgbGV2ZWwgb2YgZGlzdGFuY2UgY29kZXMgKi9cbiAgdmFyIGhlcmU7ICAgICAgICAgICAgICAgICAgIC8qIHJldHJpZXZlZCB0YWJsZSBlbnRyeSAqL1xuICB2YXIgb3A7ICAgICAgICAgICAgICAgICAgICAgLyogY29kZSBiaXRzLCBvcGVyYXRpb24sIGV4dHJhIGJpdHMsIG9yICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiAgd2luZG93IHBvc2l0aW9uLCB3aW5kb3cgYnl0ZXMgdG8gY29weSAqL1xuICB2YXIgbGVuOyAgICAgICAgICAgICAgICAgICAgLyogbWF0Y2ggbGVuZ3RoLCB1bnVzZWQgYnl0ZXMgKi9cbiAgdmFyIGRpc3Q7ICAgICAgICAgICAgICAgICAgIC8qIG1hdGNoIGRpc3RhbmNlICovXG4gIHZhciBmcm9tOyAgICAgICAgICAgICAgICAgICAvKiB3aGVyZSB0byBjb3B5IG1hdGNoIGZyb20gKi9cbiAgdmFyIGZyb21fc291cmNlO1xuXG5cbiAgdmFyIGlucHV0LCBvdXRwdXQ7IC8vIEpTIHNwZWNpZmljLCBiZWNhdXNlIHdlIGhhdmUgbm8gcG9pbnRlcnNcblxuICAvKiBjb3B5IHN0YXRlIHRvIGxvY2FsIHZhcmlhYmxlcyAqL1xuICBzdGF0ZSA9IHN0cm0uc3RhdGU7XG4gIC8vaGVyZSA9IHN0YXRlLmhlcmU7XG4gIF9pbiA9IHN0cm0ubmV4dF9pbjtcbiAgaW5wdXQgPSBzdHJtLmlucHV0O1xuICBsYXN0ID0gX2luICsgKHN0cm0uYXZhaWxfaW4gLSA1KTtcbiAgX291dCA9IHN0cm0ubmV4dF9vdXQ7XG4gIG91dHB1dCA9IHN0cm0ub3V0cHV0O1xuICBiZWcgPSBfb3V0IC0gKHN0YXJ0IC0gc3RybS5hdmFpbF9vdXQpO1xuICBlbmQgPSBfb3V0ICsgKHN0cm0uYXZhaWxfb3V0IC0gMjU3KTtcbi8vI2lmZGVmIElORkxBVEVfU1RSSUNUXG4gIGRtYXggPSBzdGF0ZS5kbWF4O1xuLy8jZW5kaWZcbiAgd3NpemUgPSBzdGF0ZS53c2l6ZTtcbiAgd2hhdmUgPSBzdGF0ZS53aGF2ZTtcbiAgd25leHQgPSBzdGF0ZS53bmV4dDtcbiAgc193aW5kb3cgPSBzdGF0ZS53aW5kb3c7XG4gIGhvbGQgPSBzdGF0ZS5ob2xkO1xuICBiaXRzID0gc3RhdGUuYml0cztcbiAgbGNvZGUgPSBzdGF0ZS5sZW5jb2RlO1xuICBkY29kZSA9IHN0YXRlLmRpc3Rjb2RlO1xuICBsbWFzayA9ICgxIDw8IHN0YXRlLmxlbmJpdHMpIC0gMTtcbiAgZG1hc2sgPSAoMSA8PCBzdGF0ZS5kaXN0Yml0cykgLSAxO1xuXG5cbiAgLyogZGVjb2RlIGxpdGVyYWxzIGFuZCBsZW5ndGgvZGlzdGFuY2VzIHVudGlsIGVuZC1vZi1ibG9jayBvciBub3QgZW5vdWdoXG4gICAgIGlucHV0IGRhdGEgb3Igb3V0cHV0IHNwYWNlICovXG5cbiAgdG9wOlxuICBkbyB7XG4gICAgaWYgKGJpdHMgPCAxNSkge1xuICAgICAgaG9sZCArPSBpbnB1dFtfaW4rK10gPDwgYml0cztcbiAgICAgIGJpdHMgKz0gODtcbiAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7XG4gICAgICBiaXRzICs9IDg7XG4gICAgfVxuXG4gICAgaGVyZSA9IGxjb2RlW2hvbGQgJiBsbWFza107XG5cbiAgICBkb2xlbjpcbiAgICBmb3IgKDs7KSB7IC8vIEdvdG8gZW11bGF0aW9uXG4gICAgICBvcCA9IGhlcmUgPj4+IDI0LypoZXJlLmJpdHMqLztcbiAgICAgIGhvbGQgPj4+PSBvcDtcbiAgICAgIGJpdHMgLT0gb3A7XG4gICAgICBvcCA9IChoZXJlID4+PiAxNikgJiAweGZmLypoZXJlLm9wKi87XG4gICAgICBpZiAob3AgPT09IDApIHsgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIGxpdGVyYWwgKi9cbiAgICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsIGhlcmUudmFsID49IDB4MjAgJiYgaGVyZS52YWwgPCAweDdmID9cbiAgICAgICAgLy8gICAgICAgIFwiaW5mbGF0ZTogICAgICAgICBsaXRlcmFsICclYydcXG5cIiA6XG4gICAgICAgIC8vICAgICAgICBcImluZmxhdGU6ICAgICAgICAgbGl0ZXJhbCAweCUwMnhcXG5cIiwgaGVyZS52YWwpKTtcbiAgICAgICAgb3V0cHV0W19vdXQrK10gPSBoZXJlICYgMHhmZmZmLypoZXJlLnZhbCovO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAob3AgJiAxNikgeyAgICAgICAgICAgICAgICAgICAgIC8qIGxlbmd0aCBiYXNlICovXG4gICAgICAgIGxlbiA9IGhlcmUgJiAweGZmZmYvKmhlcmUudmFsKi87XG4gICAgICAgIG9wICY9IDE1OyAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBleHRyYSBiaXRzICovXG4gICAgICAgIGlmIChvcCkge1xuICAgICAgICAgIGlmIChiaXRzIDwgb3ApIHtcbiAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7XG4gICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxlbiArPSBob2xkICYgKCgxIDw8IG9wKSAtIDEpO1xuICAgICAgICAgIGhvbGQgPj4+PSBvcDtcbiAgICAgICAgICBiaXRzIC09IG9wO1xuICAgICAgICB9XG4gICAgICAgIC8vVHJhY2V2digoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgICAgbGVuZ3RoICV1XFxuXCIsIGxlbikpO1xuICAgICAgICBpZiAoYml0cyA8IDE1KSB7XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtfaW4rK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtfaW4rK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgIH1cbiAgICAgICAgaGVyZSA9IGRjb2RlW2hvbGQgJiBkbWFza107XG5cbiAgICAgICAgZG9kaXN0OlxuICAgICAgICBmb3IgKDs7KSB7IC8vIGdvdG8gZW11bGF0aW9uXG4gICAgICAgICAgb3AgPSBoZXJlID4+PiAyNC8qaGVyZS5iaXRzKi87XG4gICAgICAgICAgaG9sZCA+Pj49IG9wO1xuICAgICAgICAgIGJpdHMgLT0gb3A7XG4gICAgICAgICAgb3AgPSAoaGVyZSA+Pj4gMTYpICYgMHhmZi8qaGVyZS5vcCovO1xuXG4gICAgICAgICAgaWYgKG9wICYgMTYpIHsgICAgICAgICAgICAgICAgICAgICAgLyogZGlzdGFuY2UgYmFzZSAqL1xuICAgICAgICAgICAgZGlzdCA9IGhlcmUgJiAweGZmZmYvKmhlcmUudmFsKi87XG4gICAgICAgICAgICBvcCAmPSAxNTsgICAgICAgICAgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBleHRyYSBiaXRzICovXG4gICAgICAgICAgICBpZiAoYml0cyA8IG9wKSB7XG4gICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7XG4gICAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAgICAgaWYgKGJpdHMgPCBvcCkge1xuICAgICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7XG4gICAgICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkaXN0ICs9IGhvbGQgJiAoKDEgPDwgb3ApIC0gMSk7XG4vLyNpZmRlZiBJTkZMQVRFX1NUUklDVFxuICAgICAgICAgICAgaWYgKGRpc3QgPiBkbWF4KSB7XG4gICAgICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgZGlzdGFuY2UgdG9vIGZhciBiYWNrJztcbiAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICAgICAgYnJlYWsgdG9wO1xuICAgICAgICAgICAgfVxuLy8jZW5kaWZcbiAgICAgICAgICAgIGhvbGQgPj4+PSBvcDtcbiAgICAgICAgICAgIGJpdHMgLT0gb3A7XG4gICAgICAgICAgICAvL1RyYWNldnYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICAgIGRpc3RhbmNlICV1XFxuXCIsIGRpc3QpKTtcbiAgICAgICAgICAgIG9wID0gX291dCAtIGJlZzsgICAgICAgICAgICAgICAgLyogbWF4IGRpc3RhbmNlIGluIG91dHB1dCAqL1xuICAgICAgICAgICAgaWYgKGRpc3QgPiBvcCkgeyAgICAgICAgICAgICAgICAvKiBzZWUgaWYgY29weSBmcm9tIHdpbmRvdyAqL1xuICAgICAgICAgICAgICBvcCA9IGRpc3QgLSBvcDsgICAgICAgICAgICAgICAvKiBkaXN0YW5jZSBiYWNrIGluIHdpbmRvdyAqL1xuICAgICAgICAgICAgICBpZiAob3AgPiB3aGF2ZSkge1xuICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5zYW5lKSB7XG4gICAgICAgICAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGRpc3RhbmNlIHRvbyBmYXIgYmFjayc7XG4gICAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgICAgICAgICAgYnJlYWsgdG9wO1xuICAgICAgICAgICAgICAgIH1cblxuLy8gKCEpIFRoaXMgYmxvY2sgaXMgZGlzYWJsZWQgaW4gemxpYiBkZWZhaWx0cyxcbi8vIGRvbid0IGVuYWJsZSBpdCBmb3IgYmluYXJ5IGNvbXBhdGliaWxpdHlcbi8vI2lmZGVmIElORkxBVEVfQUxMT1dfSU5WQUxJRF9ESVNUQU5DRV9UT09GQVJfQVJSUlxuLy8gICAgICAgICAgICAgICAgaWYgKGxlbiA8PSBvcCAtIHdoYXZlKSB7XG4vLyAgICAgICAgICAgICAgICAgIGRvIHtcbi8vICAgICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IDA7XG4vLyAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tbGVuKTtcbi8vICAgICAgICAgICAgICAgICAgY29udGludWUgdG9wO1xuLy8gICAgICAgICAgICAgICAgfVxuLy8gICAgICAgICAgICAgICAgbGVuIC09IG9wIC0gd2hhdmU7XG4vLyAgICAgICAgICAgICAgICBkbyB7XG4vLyAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gMDtcbi8vICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tb3AgPiB3aGF2ZSk7XG4vLyAgICAgICAgICAgICAgICBpZiAob3AgPT09IDApIHtcbi8vICAgICAgICAgICAgICAgICAgZnJvbSA9IF9vdXQgLSBkaXN0O1xuLy8gICAgICAgICAgICAgICAgICBkbyB7XG4vLyAgICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBvdXRwdXRbZnJvbSsrXTtcbi8vICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoLS1sZW4pO1xuLy8gICAgICAgICAgICAgICAgICBjb250aW51ZSB0b3A7XG4vLyAgICAgICAgICAgICAgICB9XG4vLyNlbmRpZlxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGZyb20gPSAwOyAvLyB3aW5kb3cgaW5kZXhcbiAgICAgICAgICAgICAgZnJvbV9zb3VyY2UgPSBzX3dpbmRvdztcbiAgICAgICAgICAgICAgaWYgKHduZXh0ID09PSAwKSB7ICAgICAgICAgICAvKiB2ZXJ5IGNvbW1vbiBjYXNlICovXG4gICAgICAgICAgICAgICAgZnJvbSArPSB3c2l6ZSAtIG9wO1xuICAgICAgICAgICAgICAgIGlmIChvcCA8IGxlbikgeyAgICAgICAgIC8qIHNvbWUgZnJvbSB3aW5kb3cgKi9cbiAgICAgICAgICAgICAgICAgIGxlbiAtPSBvcDtcbiAgICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBzX3dpbmRvd1tmcm9tKytdO1xuICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoLS1vcCk7XG4gICAgICAgICAgICAgICAgICBmcm9tID0gX291dCAtIGRpc3Q7ICAvKiByZXN0IGZyb20gb3V0cHV0ICovXG4gICAgICAgICAgICAgICAgICBmcm9tX3NvdXJjZSA9IG91dHB1dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSBpZiAod25leHQgPCBvcCkgeyAgICAgIC8qIHdyYXAgYXJvdW5kIHdpbmRvdyAqL1xuICAgICAgICAgICAgICAgIGZyb20gKz0gd3NpemUgKyB3bmV4dCAtIG9wO1xuICAgICAgICAgICAgICAgIG9wIC09IHduZXh0O1xuICAgICAgICAgICAgICAgIGlmIChvcCA8IGxlbikgeyAgICAgICAgIC8qIHNvbWUgZnJvbSBlbmQgb2Ygd2luZG93ICovXG4gICAgICAgICAgICAgICAgICBsZW4gLT0gb3A7XG4gICAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gc193aW5kb3dbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tb3ApO1xuICAgICAgICAgICAgICAgICAgZnJvbSA9IDA7XG4gICAgICAgICAgICAgICAgICBpZiAod25leHQgPCBsZW4pIHsgIC8qIHNvbWUgZnJvbSBzdGFydCBvZiB3aW5kb3cgKi9cbiAgICAgICAgICAgICAgICAgICAgb3AgPSB3bmV4dDtcbiAgICAgICAgICAgICAgICAgICAgbGVuIC09IG9wO1xuICAgICAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBzX3dpbmRvd1tmcm9tKytdO1xuICAgICAgICAgICAgICAgICAgICB9IHdoaWxlICgtLW9wKTtcbiAgICAgICAgICAgICAgICAgICAgZnJvbSA9IF9vdXQgLSBkaXN0OyAgICAgIC8qIHJlc3QgZnJvbSBvdXRwdXQgKi9cbiAgICAgICAgICAgICAgICAgICAgZnJvbV9zb3VyY2UgPSBvdXRwdXQ7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2UgeyAgICAgICAgICAgICAgICAgICAgICAvKiBjb250aWd1b3VzIGluIHdpbmRvdyAqL1xuICAgICAgICAgICAgICAgIGZyb20gKz0gd25leHQgLSBvcDtcbiAgICAgICAgICAgICAgICBpZiAob3AgPCBsZW4pIHsgICAgICAgICAvKiBzb21lIGZyb20gd2luZG93ICovXG4gICAgICAgICAgICAgICAgICBsZW4gLT0gb3A7XG4gICAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gc193aW5kb3dbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tb3ApO1xuICAgICAgICAgICAgICAgICAgZnJvbSA9IF9vdXQgLSBkaXN0OyAgLyogcmVzdCBmcm9tIG91dHB1dCAqL1xuICAgICAgICAgICAgICAgICAgZnJvbV9zb3VyY2UgPSBvdXRwdXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHdoaWxlIChsZW4gPiAyKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBmcm9tX3NvdXJjZVtmcm9tKytdO1xuICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gZnJvbV9zb3VyY2VbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IGZyb21fc291cmNlW2Zyb20rK107XG4gICAgICAgICAgICAgICAgbGVuIC09IDM7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGxlbikge1xuICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gZnJvbV9zb3VyY2VbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICBpZiAobGVuID4gMSkge1xuICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBmcm9tX3NvdXJjZVtmcm9tKytdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIGZyb20gPSBfb3V0IC0gZGlzdDsgICAgICAgICAgLyogY29weSBkaXJlY3QgZnJvbSBvdXRwdXQgKi9cbiAgICAgICAgICAgICAgZG8geyAgICAgICAgICAgICAgICAgICAgICAgIC8qIG1pbmltdW0gbGVuZ3RoIGlzIHRocmVlICovXG4gICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBvdXRwdXRbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IG91dHB1dFtmcm9tKytdO1xuICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gb3V0cHV0W2Zyb20rK107XG4gICAgICAgICAgICAgICAgbGVuIC09IDM7XG4gICAgICAgICAgICAgIH0gd2hpbGUgKGxlbiA+IDIpO1xuICAgICAgICAgICAgICBpZiAobGVuKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBvdXRwdXRbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICBpZiAobGVuID4gMSkge1xuICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBvdXRwdXRbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAoKG9wICYgNjQpID09PSAwKSB7ICAgICAgICAgIC8qIDJuZCBsZXZlbCBkaXN0YW5jZSBjb2RlICovXG4gICAgICAgICAgICBoZXJlID0gZGNvZGVbKGhlcmUgJiAweGZmZmYpLypoZXJlLnZhbCovICsgKGhvbGQgJiAoKDEgPDwgb3ApIC0gMSkpXTtcbiAgICAgICAgICAgIGNvbnRpbnVlIGRvZGlzdDtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGRpc3RhbmNlIGNvZGUnO1xuICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICAgIGJyZWFrIHRvcDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhazsgLy8gbmVlZCB0byBlbXVsYXRlIGdvdG8gdmlhIFwiY29udGludWVcIlxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIGlmICgob3AgJiA2NCkgPT09IDApIHsgICAgICAgICAgICAgIC8qIDJuZCBsZXZlbCBsZW5ndGggY29kZSAqL1xuICAgICAgICBoZXJlID0gbGNvZGVbKGhlcmUgJiAweGZmZmYpLypoZXJlLnZhbCovICsgKGhvbGQgJiAoKDEgPDwgb3ApIC0gMSkpXTtcbiAgICAgICAgY29udGludWUgZG9sZW47XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChvcCAmIDMyKSB7ICAgICAgICAgICAgICAgICAgICAgLyogZW5kLW9mLWJsb2NrICovXG4gICAgICAgIC8vVHJhY2V2digoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgICAgZW5kIG9mIGJsb2NrXFxuXCIpKTtcbiAgICAgICAgc3RhdGUubW9kZSA9IFRZUEU7XG4gICAgICAgIGJyZWFrIHRvcDtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGxpdGVyYWwvbGVuZ3RoIGNvZGUnO1xuICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICBicmVhayB0b3A7XG4gICAgICB9XG5cbiAgICAgIGJyZWFrOyAvLyBuZWVkIHRvIGVtdWxhdGUgZ290byB2aWEgXCJjb250aW51ZVwiXG4gICAgfVxuICB9IHdoaWxlIChfaW4gPCBsYXN0ICYmIF9vdXQgPCBlbmQpO1xuXG4gIC8qIHJldHVybiB1bnVzZWQgYnl0ZXMgKG9uIGVudHJ5LCBiaXRzIDwgOCwgc28gaW4gd29uJ3QgZ28gdG9vIGZhciBiYWNrKSAqL1xuICBsZW4gPSBiaXRzID4+IDM7XG4gIF9pbiAtPSBsZW47XG4gIGJpdHMgLT0gbGVuIDw8IDM7XG4gIGhvbGQgJj0gKDEgPDwgYml0cykgLSAxO1xuXG4gIC8qIHVwZGF0ZSBzdGF0ZSBhbmQgcmV0dXJuICovXG4gIHN0cm0ubmV4dF9pbiA9IF9pbjtcbiAgc3RybS5uZXh0X291dCA9IF9vdXQ7XG4gIHN0cm0uYXZhaWxfaW4gPSAoX2luIDwgbGFzdCA/IDUgKyAobGFzdCAtIF9pbikgOiA1IC0gKF9pbiAtIGxhc3QpKTtcbiAgc3RybS5hdmFpbF9vdXQgPSAoX291dCA8IGVuZCA/IDI1NyArIChlbmQgLSBfb3V0KSA6IDI1NyAtIChfb3V0IC0gZW5kKSk7XG4gIHN0YXRlLmhvbGQgPSBob2xkO1xuICBzdGF0ZS5iaXRzID0gYml0cztcbiAgcmV0dXJuO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuXG52YXIgdXRpbHMgICAgICAgICA9IHJlcXVpcmUoJy4uL3V0aWxzL2NvbW1vbicpO1xudmFyIGFkbGVyMzIgICAgICAgPSByZXF1aXJlKCcuL2FkbGVyMzInKTtcbnZhciBjcmMzMiAgICAgICAgID0gcmVxdWlyZSgnLi9jcmMzMicpO1xudmFyIGluZmxhdGVfZmFzdCAgPSByZXF1aXJlKCcuL2luZmZhc3QnKTtcbnZhciBpbmZsYXRlX3RhYmxlID0gcmVxdWlyZSgnLi9pbmZ0cmVlcycpO1xuXG52YXIgQ09ERVMgPSAwO1xudmFyIExFTlMgPSAxO1xudmFyIERJU1RTID0gMjtcblxuLyogUHVibGljIGNvbnN0YW50cyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cblxuLyogQWxsb3dlZCBmbHVzaCB2YWx1ZXM7IHNlZSBkZWZsYXRlKCkgYW5kIGluZmxhdGUoKSBiZWxvdyBmb3IgZGV0YWlscyAqL1xuLy92YXIgWl9OT19GTFVTSCAgICAgID0gMDtcbi8vdmFyIFpfUEFSVElBTF9GTFVTSCA9IDE7XG4vL3ZhciBaX1NZTkNfRkxVU0ggICAgPSAyO1xuLy92YXIgWl9GVUxMX0ZMVVNIICAgID0gMztcbnZhciBaX0ZJTklTSCAgICAgICAgPSA0O1xudmFyIFpfQkxPQ0sgICAgICAgICA9IDU7XG52YXIgWl9UUkVFUyAgICAgICAgID0gNjtcblxuXG4vKiBSZXR1cm4gY29kZXMgZm9yIHRoZSBjb21wcmVzc2lvbi9kZWNvbXByZXNzaW9uIGZ1bmN0aW9ucy4gTmVnYXRpdmUgdmFsdWVzXG4gKiBhcmUgZXJyb3JzLCBwb3NpdGl2ZSB2YWx1ZXMgYXJlIHVzZWQgZm9yIHNwZWNpYWwgYnV0IG5vcm1hbCBldmVudHMuXG4gKi9cbnZhciBaX09LICAgICAgICAgICAgPSAwO1xudmFyIFpfU1RSRUFNX0VORCAgICA9IDE7XG52YXIgWl9ORUVEX0RJQ1QgICAgID0gMjtcbi8vdmFyIFpfRVJSTk8gICAgICAgICA9IC0xO1xudmFyIFpfU1RSRUFNX0VSUk9SICA9IC0yO1xudmFyIFpfREFUQV9FUlJPUiAgICA9IC0zO1xudmFyIFpfTUVNX0VSUk9SICAgICA9IC00O1xudmFyIFpfQlVGX0VSUk9SICAgICA9IC01O1xuLy92YXIgWl9WRVJTSU9OX0VSUk9SID0gLTY7XG5cbi8qIFRoZSBkZWZsYXRlIGNvbXByZXNzaW9uIG1ldGhvZCAqL1xudmFyIFpfREVGTEFURUQgID0gODtcblxuXG4vKiBTVEFURVMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuXG52YXIgICAgSEVBRCA9IDE7ICAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIG1hZ2ljIGhlYWRlciAqL1xudmFyICAgIEZMQUdTID0gMjsgICAgICAvKiBpOiB3YWl0aW5nIGZvciBtZXRob2QgYW5kIGZsYWdzIChnemlwKSAqL1xudmFyICAgIFRJTUUgPSAzOyAgICAgICAvKiBpOiB3YWl0aW5nIGZvciBtb2RpZmljYXRpb24gdGltZSAoZ3ppcCkgKi9cbnZhciAgICBPUyA9IDQ7ICAgICAgICAgLyogaTogd2FpdGluZyBmb3IgZXh0cmEgZmxhZ3MgYW5kIG9wZXJhdGluZyBzeXN0ZW0gKGd6aXApICovXG52YXIgICAgRVhMRU4gPSA1OyAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIGV4dHJhIGxlbmd0aCAoZ3ppcCkgKi9cbnZhciAgICBFWFRSQSA9IDY7ICAgICAgLyogaTogd2FpdGluZyBmb3IgZXh0cmEgYnl0ZXMgKGd6aXApICovXG52YXIgICAgTkFNRSA9IDc7ICAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIGVuZCBvZiBmaWxlIG5hbWUgKGd6aXApICovXG52YXIgICAgQ09NTUVOVCA9IDg7ICAgIC8qIGk6IHdhaXRpbmcgZm9yIGVuZCBvZiBjb21tZW50IChnemlwKSAqL1xudmFyICAgIEhDUkMgPSA5OyAgICAgICAvKiBpOiB3YWl0aW5nIGZvciBoZWFkZXIgY3JjIChnemlwKSAqL1xudmFyICAgIERJQ1RJRCA9IDEwOyAgICAvKiBpOiB3YWl0aW5nIGZvciBkaWN0aW9uYXJ5IGNoZWNrIHZhbHVlICovXG52YXIgICAgRElDVCA9IDExOyAgICAgIC8qIHdhaXRpbmcgZm9yIGluZmxhdGVTZXREaWN0aW9uYXJ5KCkgY2FsbCAqL1xudmFyICAgICAgICBUWVBFID0gMTI7ICAgICAgLyogaTogd2FpdGluZyBmb3IgdHlwZSBiaXRzLCBpbmNsdWRpbmcgbGFzdC1mbGFnIGJpdCAqL1xudmFyICAgICAgICBUWVBFRE8gPSAxMzsgICAgLyogaTogc2FtZSwgYnV0IHNraXAgY2hlY2sgdG8gZXhpdCBpbmZsYXRlIG9uIG5ldyBibG9jayAqL1xudmFyICAgICAgICBTVE9SRUQgPSAxNDsgICAgLyogaTogd2FpdGluZyBmb3Igc3RvcmVkIHNpemUgKGxlbmd0aCBhbmQgY29tcGxlbWVudCkgKi9cbnZhciAgICAgICAgQ09QWV8gPSAxNTsgICAgIC8qIGkvbzogc2FtZSBhcyBDT1BZIGJlbG93LCBidXQgb25seSBmaXJzdCB0aW1lIGluICovXG52YXIgICAgICAgIENPUFkgPSAxNjsgICAgICAvKiBpL286IHdhaXRpbmcgZm9yIGlucHV0IG9yIG91dHB1dCB0byBjb3B5IHN0b3JlZCBibG9jayAqL1xudmFyICAgICAgICBUQUJMRSA9IDE3OyAgICAgLyogaTogd2FpdGluZyBmb3IgZHluYW1pYyBibG9jayB0YWJsZSBsZW5ndGhzICovXG52YXIgICAgICAgIExFTkxFTlMgPSAxODsgICAvKiBpOiB3YWl0aW5nIGZvciBjb2RlIGxlbmd0aCBjb2RlIGxlbmd0aHMgKi9cbnZhciAgICAgICAgQ09ERUxFTlMgPSAxOTsgIC8qIGk6IHdhaXRpbmcgZm9yIGxlbmd0aC9saXQgYW5kIGRpc3RhbmNlIGNvZGUgbGVuZ3RocyAqL1xudmFyICAgICAgICAgICAgTEVOXyA9IDIwOyAgICAgIC8qIGk6IHNhbWUgYXMgTEVOIGJlbG93LCBidXQgb25seSBmaXJzdCB0aW1lIGluICovXG52YXIgICAgICAgICAgICBMRU4gPSAyMTsgICAgICAgLyogaTogd2FpdGluZyBmb3IgbGVuZ3RoL2xpdC9lb2IgY29kZSAqL1xudmFyICAgICAgICAgICAgTEVORVhUID0gMjI7ICAgIC8qIGk6IHdhaXRpbmcgZm9yIGxlbmd0aCBleHRyYSBiaXRzICovXG52YXIgICAgICAgICAgICBESVNUID0gMjM7ICAgICAgLyogaTogd2FpdGluZyBmb3IgZGlzdGFuY2UgY29kZSAqL1xudmFyICAgICAgICAgICAgRElTVEVYVCA9IDI0OyAgIC8qIGk6IHdhaXRpbmcgZm9yIGRpc3RhbmNlIGV4dHJhIGJpdHMgKi9cbnZhciAgICAgICAgICAgIE1BVENIID0gMjU7ICAgICAvKiBvOiB3YWl0aW5nIGZvciBvdXRwdXQgc3BhY2UgdG8gY29weSBzdHJpbmcgKi9cbnZhciAgICAgICAgICAgIExJVCA9IDI2OyAgICAgICAvKiBvOiB3YWl0aW5nIGZvciBvdXRwdXQgc3BhY2UgdG8gd3JpdGUgbGl0ZXJhbCAqL1xudmFyICAgIENIRUNLID0gMjc7ICAgICAvKiBpOiB3YWl0aW5nIGZvciAzMi1iaXQgY2hlY2sgdmFsdWUgKi9cbnZhciAgICBMRU5HVEggPSAyODsgICAgLyogaTogd2FpdGluZyBmb3IgMzItYml0IGxlbmd0aCAoZ3ppcCkgKi9cbnZhciAgICBET05FID0gMjk7ICAgICAgLyogZmluaXNoZWQgY2hlY2ssIGRvbmUgLS0gcmVtYWluIGhlcmUgdW50aWwgcmVzZXQgKi9cbnZhciAgICBCQUQgPSAzMDsgICAgICAgLyogZ290IGEgZGF0YSBlcnJvciAtLSByZW1haW4gaGVyZSB1bnRpbCByZXNldCAqL1xudmFyICAgIE1FTSA9IDMxOyAgICAgICAvKiBnb3QgYW4gaW5mbGF0ZSgpIG1lbW9yeSBlcnJvciAtLSByZW1haW4gaGVyZSB1bnRpbCByZXNldCAqL1xudmFyICAgIFNZTkMgPSAzMjsgICAgICAvKiBsb29raW5nIGZvciBzeW5jaHJvbml6YXRpb24gYnl0ZXMgdG8gcmVzdGFydCBpbmZsYXRlKCkgKi9cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuXG5cbnZhciBFTk9VR0hfTEVOUyA9IDg1MjtcbnZhciBFTk9VR0hfRElTVFMgPSA1OTI7XG4vL3ZhciBFTk9VR0ggPSAgKEVOT1VHSF9MRU5TK0VOT1VHSF9ESVNUUyk7XG5cbnZhciBNQVhfV0JJVFMgPSAxNTtcbi8qIDMySyBMWjc3IHdpbmRvdyAqL1xudmFyIERFRl9XQklUUyA9IE1BWF9XQklUUztcblxuXG5mdW5jdGlvbiB6c3dhcDMyKHEpIHtcbiAgcmV0dXJuICAoKChxID4+PiAyNCkgJiAweGZmKSArXG4gICAgICAgICAgKChxID4+PiA4KSAmIDB4ZmYwMCkgK1xuICAgICAgICAgICgocSAmIDB4ZmYwMCkgPDwgOCkgK1xuICAgICAgICAgICgocSAmIDB4ZmYpIDw8IDI0KSk7XG59XG5cblxuZnVuY3Rpb24gSW5mbGF0ZVN0YXRlKCkge1xuICB0aGlzLm1vZGUgPSAwOyAgICAgICAgICAgICAvKiBjdXJyZW50IGluZmxhdGUgbW9kZSAqL1xuICB0aGlzLmxhc3QgPSBmYWxzZTsgICAgICAgICAgLyogdHJ1ZSBpZiBwcm9jZXNzaW5nIGxhc3QgYmxvY2sgKi9cbiAgdGhpcy53cmFwID0gMDsgICAgICAgICAgICAgIC8qIGJpdCAwIHRydWUgZm9yIHpsaWIsIGJpdCAxIHRydWUgZm9yIGd6aXAgKi9cbiAgdGhpcy5oYXZlZGljdCA9IGZhbHNlOyAgICAgIC8qIHRydWUgaWYgZGljdGlvbmFyeSBwcm92aWRlZCAqL1xuICB0aGlzLmZsYWdzID0gMDsgICAgICAgICAgICAgLyogZ3ppcCBoZWFkZXIgbWV0aG9kIGFuZCBmbGFncyAoMCBpZiB6bGliKSAqL1xuICB0aGlzLmRtYXggPSAwOyAgICAgICAgICAgICAgLyogemxpYiBoZWFkZXIgbWF4IGRpc3RhbmNlIChJTkZMQVRFX1NUUklDVCkgKi9cbiAgdGhpcy5jaGVjayA9IDA7ICAgICAgICAgICAgIC8qIHByb3RlY3RlZCBjb3B5IG9mIGNoZWNrIHZhbHVlICovXG4gIHRoaXMudG90YWwgPSAwOyAgICAgICAgICAgICAvKiBwcm90ZWN0ZWQgY29weSBvZiBvdXRwdXQgY291bnQgKi9cbiAgLy8gVE9ETzogbWF5IGJlIHt9XG4gIHRoaXMuaGVhZCA9IG51bGw7ICAgICAgICAgICAvKiB3aGVyZSB0byBzYXZlIGd6aXAgaGVhZGVyIGluZm9ybWF0aW9uICovXG5cbiAgLyogc2xpZGluZyB3aW5kb3cgKi9cbiAgdGhpcy53Yml0cyA9IDA7ICAgICAgICAgICAgIC8qIGxvZyBiYXNlIDIgb2YgcmVxdWVzdGVkIHdpbmRvdyBzaXplICovXG4gIHRoaXMud3NpemUgPSAwOyAgICAgICAgICAgICAvKiB3aW5kb3cgc2l6ZSBvciB6ZXJvIGlmIG5vdCB1c2luZyB3aW5kb3cgKi9cbiAgdGhpcy53aGF2ZSA9IDA7ICAgICAgICAgICAgIC8qIHZhbGlkIGJ5dGVzIGluIHRoZSB3aW5kb3cgKi9cbiAgdGhpcy53bmV4dCA9IDA7ICAgICAgICAgICAgIC8qIHdpbmRvdyB3cml0ZSBpbmRleCAqL1xuICB0aGlzLndpbmRvdyA9IG51bGw7ICAgICAgICAgLyogYWxsb2NhdGVkIHNsaWRpbmcgd2luZG93LCBpZiBuZWVkZWQgKi9cblxuICAvKiBiaXQgYWNjdW11bGF0b3IgKi9cbiAgdGhpcy5ob2xkID0gMDsgICAgICAgICAgICAgIC8qIGlucHV0IGJpdCBhY2N1bXVsYXRvciAqL1xuICB0aGlzLmJpdHMgPSAwOyAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGJpdHMgaW4gXCJpblwiICovXG5cbiAgLyogZm9yIHN0cmluZyBhbmQgc3RvcmVkIGJsb2NrIGNvcHlpbmcgKi9cbiAgdGhpcy5sZW5ndGggPSAwOyAgICAgICAgICAgIC8qIGxpdGVyYWwgb3IgbGVuZ3RoIG9mIGRhdGEgdG8gY29weSAqL1xuICB0aGlzLm9mZnNldCA9IDA7ICAgICAgICAgICAgLyogZGlzdGFuY2UgYmFjayB0byBjb3B5IHN0cmluZyBmcm9tICovXG5cbiAgLyogZm9yIHRhYmxlIGFuZCBjb2RlIGRlY29kaW5nICovXG4gIHRoaXMuZXh0cmEgPSAwOyAgICAgICAgICAgICAvKiBleHRyYSBiaXRzIG5lZWRlZCAqL1xuXG4gIC8qIGZpeGVkIGFuZCBkeW5hbWljIGNvZGUgdGFibGVzICovXG4gIHRoaXMubGVuY29kZSA9IG51bGw7ICAgICAgICAgIC8qIHN0YXJ0aW5nIHRhYmxlIGZvciBsZW5ndGgvbGl0ZXJhbCBjb2RlcyAqL1xuICB0aGlzLmRpc3Rjb2RlID0gbnVsbDsgICAgICAgICAvKiBzdGFydGluZyB0YWJsZSBmb3IgZGlzdGFuY2UgY29kZXMgKi9cbiAgdGhpcy5sZW5iaXRzID0gMDsgICAgICAgICAgIC8qIGluZGV4IGJpdHMgZm9yIGxlbmNvZGUgKi9cbiAgdGhpcy5kaXN0Yml0cyA9IDA7ICAgICAgICAgIC8qIGluZGV4IGJpdHMgZm9yIGRpc3Rjb2RlICovXG5cbiAgLyogZHluYW1pYyB0YWJsZSBidWlsZGluZyAqL1xuICB0aGlzLm5jb2RlID0gMDsgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGNvZGUgbGVuZ3RoIGNvZGUgbGVuZ3RocyAqL1xuICB0aGlzLm5sZW4gPSAwOyAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGxlbmd0aCBjb2RlIGxlbmd0aHMgKi9cbiAgdGhpcy5uZGlzdCA9IDA7ICAgICAgICAgICAgIC8qIG51bWJlciBvZiBkaXN0YW5jZSBjb2RlIGxlbmd0aHMgKi9cbiAgdGhpcy5oYXZlID0gMDsgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBjb2RlIGxlbmd0aHMgaW4gbGVuc1tdICovXG4gIHRoaXMubmV4dCA9IG51bGw7ICAgICAgICAgICAgICAvKiBuZXh0IGF2YWlsYWJsZSBzcGFjZSBpbiBjb2Rlc1tdICovXG5cbiAgdGhpcy5sZW5zID0gbmV3IHV0aWxzLkJ1ZjE2KDMyMCk7IC8qIHRlbXBvcmFyeSBzdG9yYWdlIGZvciBjb2RlIGxlbmd0aHMgKi9cbiAgdGhpcy53b3JrID0gbmV3IHV0aWxzLkJ1ZjE2KDI4OCk7IC8qIHdvcmsgYXJlYSBmb3IgY29kZSB0YWJsZSBidWlsZGluZyAqL1xuXG4gIC8qXG4gICBiZWNhdXNlIHdlIGRvbid0IGhhdmUgcG9pbnRlcnMgaW4ganMsIHdlIHVzZSBsZW5jb2RlIGFuZCBkaXN0Y29kZSBkaXJlY3RseVxuICAgYXMgYnVmZmVycyBzbyB3ZSBkb24ndCBuZWVkIGNvZGVzXG4gICovXG4gIC8vdGhpcy5jb2RlcyA9IG5ldyB1dGlscy5CdWYzMihFTk9VR0gpOyAgICAgICAvKiBzcGFjZSBmb3IgY29kZSB0YWJsZXMgKi9cbiAgdGhpcy5sZW5keW4gPSBudWxsOyAgICAgICAgICAgICAgLyogZHluYW1pYyB0YWJsZSBmb3IgbGVuZ3RoL2xpdGVyYWwgY29kZXMgKEpTIHNwZWNpZmljKSAqL1xuICB0aGlzLmRpc3RkeW4gPSBudWxsOyAgICAgICAgICAgICAvKiBkeW5hbWljIHRhYmxlIGZvciBkaXN0YW5jZSBjb2RlcyAoSlMgc3BlY2lmaWMpICovXG4gIHRoaXMuc2FuZSA9IDA7ICAgICAgICAgICAgICAgICAgIC8qIGlmIGZhbHNlLCBhbGxvdyBpbnZhbGlkIGRpc3RhbmNlIHRvbyBmYXIgKi9cbiAgdGhpcy5iYWNrID0gMDsgICAgICAgICAgICAgICAgICAgLyogYml0cyBiYWNrIG9mIGxhc3QgdW5wcm9jZXNzZWQgbGVuZ3RoL2xpdCAqL1xuICB0aGlzLndhcyA9IDA7ICAgICAgICAgICAgICAgICAgICAvKiBpbml0aWFsIGxlbmd0aCBvZiBtYXRjaCAqL1xufVxuXG5mdW5jdGlvbiBpbmZsYXRlUmVzZXRLZWVwKHN0cm0pIHtcbiAgdmFyIHN0YXRlO1xuXG4gIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSkgeyByZXR1cm4gWl9TVFJFQU1fRVJST1I7IH1cbiAgc3RhdGUgPSBzdHJtLnN0YXRlO1xuICBzdHJtLnRvdGFsX2luID0gc3RybS50b3RhbF9vdXQgPSBzdGF0ZS50b3RhbCA9IDA7XG4gIHN0cm0ubXNnID0gJyc7IC8qWl9OVUxMKi9cbiAgaWYgKHN0YXRlLndyYXApIHsgICAgICAgLyogdG8gc3VwcG9ydCBpbGwtY29uY2VpdmVkIEphdmEgdGVzdCBzdWl0ZSAqL1xuICAgIHN0cm0uYWRsZXIgPSBzdGF0ZS53cmFwICYgMTtcbiAgfVxuICBzdGF0ZS5tb2RlID0gSEVBRDtcbiAgc3RhdGUubGFzdCA9IDA7XG4gIHN0YXRlLmhhdmVkaWN0ID0gMDtcbiAgc3RhdGUuZG1heCA9IDMyNzY4O1xuICBzdGF0ZS5oZWFkID0gbnVsbC8qWl9OVUxMKi87XG4gIHN0YXRlLmhvbGQgPSAwO1xuICBzdGF0ZS5iaXRzID0gMDtcbiAgLy9zdGF0ZS5sZW5jb2RlID0gc3RhdGUuZGlzdGNvZGUgPSBzdGF0ZS5uZXh0ID0gc3RhdGUuY29kZXM7XG4gIHN0YXRlLmxlbmNvZGUgPSBzdGF0ZS5sZW5keW4gPSBuZXcgdXRpbHMuQnVmMzIoRU5PVUdIX0xFTlMpO1xuICBzdGF0ZS5kaXN0Y29kZSA9IHN0YXRlLmRpc3RkeW4gPSBuZXcgdXRpbHMuQnVmMzIoRU5PVUdIX0RJU1RTKTtcblxuICBzdGF0ZS5zYW5lID0gMTtcbiAgc3RhdGUuYmFjayA9IC0xO1xuICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6IHJlc2V0XFxuXCIpKTtcbiAgcmV0dXJuIFpfT0s7XG59XG5cbmZ1bmN0aW9uIGluZmxhdGVSZXNldChzdHJtKSB7XG4gIHZhciBzdGF0ZTtcblxuICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUpIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOyB9XG4gIHN0YXRlID0gc3RybS5zdGF0ZTtcbiAgc3RhdGUud3NpemUgPSAwO1xuICBzdGF0ZS53aGF2ZSA9IDA7XG4gIHN0YXRlLnduZXh0ID0gMDtcbiAgcmV0dXJuIGluZmxhdGVSZXNldEtlZXAoc3RybSk7XG5cbn1cblxuZnVuY3Rpb24gaW5mbGF0ZVJlc2V0MihzdHJtLCB3aW5kb3dCaXRzKSB7XG4gIHZhciB3cmFwO1xuICB2YXIgc3RhdGU7XG5cbiAgLyogZ2V0IHRoZSBzdGF0ZSAqL1xuICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUpIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOyB9XG4gIHN0YXRlID0gc3RybS5zdGF0ZTtcblxuICAvKiBleHRyYWN0IHdyYXAgcmVxdWVzdCBmcm9tIHdpbmRvd0JpdHMgcGFyYW1ldGVyICovXG4gIGlmICh3aW5kb3dCaXRzIDwgMCkge1xuICAgIHdyYXAgPSAwO1xuICAgIHdpbmRvd0JpdHMgPSAtd2luZG93Qml0cztcbiAgfVxuICBlbHNlIHtcbiAgICB3cmFwID0gKHdpbmRvd0JpdHMgPj4gNCkgKyAxO1xuICAgIGlmICh3aW5kb3dCaXRzIDwgNDgpIHtcbiAgICAgIHdpbmRvd0JpdHMgJj0gMTU7XG4gICAgfVxuICB9XG5cbiAgLyogc2V0IG51bWJlciBvZiB3aW5kb3cgYml0cywgZnJlZSB3aW5kb3cgaWYgZGlmZmVyZW50ICovXG4gIGlmICh3aW5kb3dCaXRzICYmICh3aW5kb3dCaXRzIDwgOCB8fCB3aW5kb3dCaXRzID4gMTUpKSB7XG4gICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICB9XG4gIGlmIChzdGF0ZS53aW5kb3cgIT09IG51bGwgJiYgc3RhdGUud2JpdHMgIT09IHdpbmRvd0JpdHMpIHtcbiAgICBzdGF0ZS53aW5kb3cgPSBudWxsO1xuICB9XG5cbiAgLyogdXBkYXRlIHN0YXRlIGFuZCByZXNldCB0aGUgcmVzdCBvZiBpdCAqL1xuICBzdGF0ZS53cmFwID0gd3JhcDtcbiAgc3RhdGUud2JpdHMgPSB3aW5kb3dCaXRzO1xuICByZXR1cm4gaW5mbGF0ZVJlc2V0KHN0cm0pO1xufVxuXG5mdW5jdGlvbiBpbmZsYXRlSW5pdDIoc3RybSwgd2luZG93Qml0cykge1xuICB2YXIgcmV0O1xuICB2YXIgc3RhdGU7XG5cbiAgaWYgKCFzdHJtKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUjsgfVxuICAvL3N0cm0ubXNnID0gWl9OVUxMOyAgICAgICAgICAgICAgICAgLyogaW4gY2FzZSB3ZSByZXR1cm4gYW4gZXJyb3IgKi9cblxuICBzdGF0ZSA9IG5ldyBJbmZsYXRlU3RhdGUoKTtcblxuICAvL2lmIChzdGF0ZSA9PT0gWl9OVUxMKSByZXR1cm4gWl9NRU1fRVJST1I7XG4gIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogYWxsb2NhdGVkXFxuXCIpKTtcbiAgc3RybS5zdGF0ZSA9IHN0YXRlO1xuICBzdGF0ZS53aW5kb3cgPSBudWxsLypaX05VTEwqLztcbiAgcmV0ID0gaW5mbGF0ZVJlc2V0MihzdHJtLCB3aW5kb3dCaXRzKTtcbiAgaWYgKHJldCAhPT0gWl9PSykge1xuICAgIHN0cm0uc3RhdGUgPSBudWxsLypaX05VTEwqLztcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBpbmZsYXRlSW5pdChzdHJtKSB7XG4gIHJldHVybiBpbmZsYXRlSW5pdDIoc3RybSwgREVGX1dCSVRTKTtcbn1cblxuXG4vKlxuIFJldHVybiBzdGF0ZSB3aXRoIGxlbmd0aCBhbmQgZGlzdGFuY2UgZGVjb2RpbmcgdGFibGVzIGFuZCBpbmRleCBzaXplcyBzZXQgdG9cbiBmaXhlZCBjb2RlIGRlY29kaW5nLiAgTm9ybWFsbHkgdGhpcyByZXR1cm5zIGZpeGVkIHRhYmxlcyBmcm9tIGluZmZpeGVkLmguXG4gSWYgQlVJTERGSVhFRCBpcyBkZWZpbmVkLCB0aGVuIGluc3RlYWQgdGhpcyByb3V0aW5lIGJ1aWxkcyB0aGUgdGFibGVzIHRoZVxuIGZpcnN0IHRpbWUgaXQncyBjYWxsZWQsIGFuZCByZXR1cm5zIHRob3NlIHRhYmxlcyB0aGUgZmlyc3QgdGltZSBhbmRcbiB0aGVyZWFmdGVyLiAgVGhpcyByZWR1Y2VzIHRoZSBzaXplIG9mIHRoZSBjb2RlIGJ5IGFib3V0IDJLIGJ5dGVzLCBpblxuIGV4Y2hhbmdlIGZvciBhIGxpdHRsZSBleGVjdXRpb24gdGltZS4gIEhvd2V2ZXIsIEJVSUxERklYRUQgc2hvdWxkIG5vdCBiZVxuIHVzZWQgZm9yIHRocmVhZGVkIGFwcGxpY2F0aW9ucywgc2luY2UgdGhlIHJld3JpdGluZyBvZiB0aGUgdGFibGVzIGFuZCB2aXJnaW5cbiBtYXkgbm90IGJlIHRocmVhZC1zYWZlLlxuICovXG52YXIgdmlyZ2luID0gdHJ1ZTtcblxudmFyIGxlbmZpeCwgZGlzdGZpeDsgLy8gV2UgaGF2ZSBubyBwb2ludGVycyBpbiBKUywgc28ga2VlcCB0YWJsZXMgc2VwYXJhdGVcblxuZnVuY3Rpb24gZml4ZWR0YWJsZXMoc3RhdGUpIHtcbiAgLyogYnVpbGQgZml4ZWQgaHVmZm1hbiB0YWJsZXMgaWYgZmlyc3QgY2FsbCAobWF5IG5vdCBiZSB0aHJlYWQgc2FmZSkgKi9cbiAgaWYgKHZpcmdpbikge1xuICAgIHZhciBzeW07XG5cbiAgICBsZW5maXggPSBuZXcgdXRpbHMuQnVmMzIoNTEyKTtcbiAgICBkaXN0Zml4ID0gbmV3IHV0aWxzLkJ1ZjMyKDMyKTtcblxuICAgIC8qIGxpdGVyYWwvbGVuZ3RoIHRhYmxlICovXG4gICAgc3ltID0gMDtcbiAgICB3aGlsZSAoc3ltIDwgMTQ0KSB7IHN0YXRlLmxlbnNbc3ltKytdID0gODsgfVxuICAgIHdoaWxlIChzeW0gPCAyNTYpIHsgc3RhdGUubGVuc1tzeW0rK10gPSA5OyB9XG4gICAgd2hpbGUgKHN5bSA8IDI4MCkgeyBzdGF0ZS5sZW5zW3N5bSsrXSA9IDc7IH1cbiAgICB3aGlsZSAoc3ltIDwgMjg4KSB7IHN0YXRlLmxlbnNbc3ltKytdID0gODsgfVxuXG4gICAgaW5mbGF0ZV90YWJsZShMRU5TLCAgc3RhdGUubGVucywgMCwgMjg4LCBsZW5maXgsICAgMCwgc3RhdGUud29yaywgeyBiaXRzOiA5IH0pO1xuXG4gICAgLyogZGlzdGFuY2UgdGFibGUgKi9cbiAgICBzeW0gPSAwO1xuICAgIHdoaWxlIChzeW0gPCAzMikgeyBzdGF0ZS5sZW5zW3N5bSsrXSA9IDU7IH1cblxuICAgIGluZmxhdGVfdGFibGUoRElTVFMsIHN0YXRlLmxlbnMsIDAsIDMyLCAgIGRpc3RmaXgsIDAsIHN0YXRlLndvcmssIHsgYml0czogNSB9KTtcblxuICAgIC8qIGRvIHRoaXMganVzdCBvbmNlICovXG4gICAgdmlyZ2luID0gZmFsc2U7XG4gIH1cblxuICBzdGF0ZS5sZW5jb2RlID0gbGVuZml4O1xuICBzdGF0ZS5sZW5iaXRzID0gOTtcbiAgc3RhdGUuZGlzdGNvZGUgPSBkaXN0Zml4O1xuICBzdGF0ZS5kaXN0Yml0cyA9IDU7XG59XG5cblxuLypcbiBVcGRhdGUgdGhlIHdpbmRvdyB3aXRoIHRoZSBsYXN0IHdzaXplIChub3JtYWxseSAzMkspIGJ5dGVzIHdyaXR0ZW4gYmVmb3JlXG4gcmV0dXJuaW5nLiAgSWYgd2luZG93IGRvZXMgbm90IGV4aXN0IHlldCwgY3JlYXRlIGl0LiAgVGhpcyBpcyBvbmx5IGNhbGxlZFxuIHdoZW4gYSB3aW5kb3cgaXMgYWxyZWFkeSBpbiB1c2UsIG9yIHdoZW4gb3V0cHV0IGhhcyBiZWVuIHdyaXR0ZW4gZHVyaW5nIHRoaXNcbiBpbmZsYXRlIGNhbGwsIGJ1dCB0aGUgZW5kIG9mIHRoZSBkZWZsYXRlIHN0cmVhbSBoYXMgbm90IGJlZW4gcmVhY2hlZCB5ZXQuXG4gSXQgaXMgYWxzbyBjYWxsZWQgdG8gY3JlYXRlIGEgd2luZG93IGZvciBkaWN0aW9uYXJ5IGRhdGEgd2hlbiBhIGRpY3Rpb25hcnlcbiBpcyBsb2FkZWQuXG5cbiBQcm92aWRpbmcgb3V0cHV0IGJ1ZmZlcnMgbGFyZ2VyIHRoYW4gMzJLIHRvIGluZmxhdGUoKSBzaG91bGQgcHJvdmlkZSBhIHNwZWVkXG4gYWR2YW50YWdlLCBzaW5jZSBvbmx5IHRoZSBsYXN0IDMySyBvZiBvdXRwdXQgaXMgY29waWVkIHRvIHRoZSBzbGlkaW5nIHdpbmRvd1xuIHVwb24gcmV0dXJuIGZyb20gaW5mbGF0ZSgpLCBhbmQgc2luY2UgYWxsIGRpc3RhbmNlcyBhZnRlciB0aGUgZmlyc3QgMzJLIG9mXG4gb3V0cHV0IHdpbGwgZmFsbCBpbiB0aGUgb3V0cHV0IGRhdGEsIG1ha2luZyBtYXRjaCBjb3BpZXMgc2ltcGxlciBhbmQgZmFzdGVyLlxuIFRoZSBhZHZhbnRhZ2UgbWF5IGJlIGRlcGVuZGVudCBvbiB0aGUgc2l6ZSBvZiB0aGUgcHJvY2Vzc29yJ3MgZGF0YSBjYWNoZXMuXG4gKi9cbmZ1bmN0aW9uIHVwZGF0ZXdpbmRvdyhzdHJtLCBzcmMsIGVuZCwgY29weSkge1xuICB2YXIgZGlzdDtcbiAgdmFyIHN0YXRlID0gc3RybS5zdGF0ZTtcblxuICAvKiBpZiBpdCBoYXNuJ3QgYmVlbiBkb25lIGFscmVhZHksIGFsbG9jYXRlIHNwYWNlIGZvciB0aGUgd2luZG93ICovXG4gIGlmIChzdGF0ZS53aW5kb3cgPT09IG51bGwpIHtcbiAgICBzdGF0ZS53c2l6ZSA9IDEgPDwgc3RhdGUud2JpdHM7XG4gICAgc3RhdGUud25leHQgPSAwO1xuICAgIHN0YXRlLndoYXZlID0gMDtcblxuICAgIHN0YXRlLndpbmRvdyA9IG5ldyB1dGlscy5CdWY4KHN0YXRlLndzaXplKTtcbiAgfVxuXG4gIC8qIGNvcHkgc3RhdGUtPndzaXplIG9yIGxlc3Mgb3V0cHV0IGJ5dGVzIGludG8gdGhlIGNpcmN1bGFyIHdpbmRvdyAqL1xuICBpZiAoY29weSA+PSBzdGF0ZS53c2l6ZSkge1xuICAgIHV0aWxzLmFycmF5U2V0KHN0YXRlLndpbmRvdywgc3JjLCBlbmQgLSBzdGF0ZS53c2l6ZSwgc3RhdGUud3NpemUsIDApO1xuICAgIHN0YXRlLnduZXh0ID0gMDtcbiAgICBzdGF0ZS53aGF2ZSA9IHN0YXRlLndzaXplO1xuICB9XG4gIGVsc2Uge1xuICAgIGRpc3QgPSBzdGF0ZS53c2l6ZSAtIHN0YXRlLnduZXh0O1xuICAgIGlmIChkaXN0ID4gY29weSkge1xuICAgICAgZGlzdCA9IGNvcHk7XG4gICAgfVxuICAgIC8vem1lbWNweShzdGF0ZS0+d2luZG93ICsgc3RhdGUtPnduZXh0LCBlbmQgLSBjb3B5LCBkaXN0KTtcbiAgICB1dGlscy5hcnJheVNldChzdGF0ZS53aW5kb3csIHNyYywgZW5kIC0gY29weSwgZGlzdCwgc3RhdGUud25leHQpO1xuICAgIGNvcHkgLT0gZGlzdDtcbiAgICBpZiAoY29weSkge1xuICAgICAgLy96bWVtY3B5KHN0YXRlLT53aW5kb3csIGVuZCAtIGNvcHksIGNvcHkpO1xuICAgICAgdXRpbHMuYXJyYXlTZXQoc3RhdGUud2luZG93LCBzcmMsIGVuZCAtIGNvcHksIGNvcHksIDApO1xuICAgICAgc3RhdGUud25leHQgPSBjb3B5O1xuICAgICAgc3RhdGUud2hhdmUgPSBzdGF0ZS53c2l6ZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBzdGF0ZS53bmV4dCArPSBkaXN0O1xuICAgICAgaWYgKHN0YXRlLnduZXh0ID09PSBzdGF0ZS53c2l6ZSkgeyBzdGF0ZS53bmV4dCA9IDA7IH1cbiAgICAgIGlmIChzdGF0ZS53aGF2ZSA8IHN0YXRlLndzaXplKSB7IHN0YXRlLndoYXZlICs9IGRpc3Q7IH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbmZ1bmN0aW9uIGluZmxhdGUoc3RybSwgZmx1c2gpIHtcbiAgdmFyIHN0YXRlO1xuICB2YXIgaW5wdXQsIG91dHB1dDsgICAgICAgICAgLy8gaW5wdXQvb3V0cHV0IGJ1ZmZlcnNcbiAgdmFyIG5leHQ7ICAgICAgICAgICAgICAgICAgIC8qIG5leHQgaW5wdXQgSU5ERVggKi9cbiAgdmFyIHB1dDsgICAgICAgICAgICAgICAgICAgIC8qIG5leHQgb3V0cHV0IElOREVYICovXG4gIHZhciBoYXZlLCBsZWZ0OyAgICAgICAgICAgICAvKiBhdmFpbGFibGUgaW5wdXQgYW5kIG91dHB1dCAqL1xuICB2YXIgaG9sZDsgICAgICAgICAgICAgICAgICAgLyogYml0IGJ1ZmZlciAqL1xuICB2YXIgYml0czsgICAgICAgICAgICAgICAgICAgLyogYml0cyBpbiBiaXQgYnVmZmVyICovXG4gIHZhciBfaW4sIF9vdXQ7ICAgICAgICAgICAgICAvKiBzYXZlIHN0YXJ0aW5nIGF2YWlsYWJsZSBpbnB1dCBhbmQgb3V0cHV0ICovXG4gIHZhciBjb3B5OyAgICAgICAgICAgICAgICAgICAvKiBudW1iZXIgb2Ygc3RvcmVkIG9yIG1hdGNoIGJ5dGVzIHRvIGNvcHkgKi9cbiAgdmFyIGZyb207ICAgICAgICAgICAgICAgICAgIC8qIHdoZXJlIHRvIGNvcHkgbWF0Y2ggYnl0ZXMgZnJvbSAqL1xuICB2YXIgZnJvbV9zb3VyY2U7XG4gIHZhciBoZXJlID0gMDsgICAgICAgICAgICAgICAvKiBjdXJyZW50IGRlY29kaW5nIHRhYmxlIGVudHJ5ICovXG4gIHZhciBoZXJlX2JpdHMsIGhlcmVfb3AsIGhlcmVfdmFsOyAvLyBwYWtlZCBcImhlcmVcIiBkZW5vcm1hbGl6ZWQgKEpTIHNwZWNpZmljKVxuICAvL3ZhciBsYXN0OyAgICAgICAgICAgICAgICAgICAvKiBwYXJlbnQgdGFibGUgZW50cnkgKi9cbiAgdmFyIGxhc3RfYml0cywgbGFzdF9vcCwgbGFzdF92YWw7IC8vIHBha2VkIFwibGFzdFwiIGRlbm9ybWFsaXplZCAoSlMgc3BlY2lmaWMpXG4gIHZhciBsZW47ICAgICAgICAgICAgICAgICAgICAvKiBsZW5ndGggdG8gY29weSBmb3IgcmVwZWF0cywgYml0cyB0byBkcm9wICovXG4gIHZhciByZXQ7ICAgICAgICAgICAgICAgICAgICAvKiByZXR1cm4gY29kZSAqL1xuICB2YXIgaGJ1ZiA9IG5ldyB1dGlscy5CdWY4KDQpOyAgICAvKiBidWZmZXIgZm9yIGd6aXAgaGVhZGVyIGNyYyBjYWxjdWxhdGlvbiAqL1xuICB2YXIgb3B0cztcblxuICB2YXIgbjsgLy8gdGVtcG9yYXJ5IHZhciBmb3IgTkVFRF9CSVRTXG5cbiAgdmFyIG9yZGVyID0gLyogcGVybXV0YXRpb24gb2YgY29kZSBsZW5ndGhzICovXG4gICAgWyAxNiwgMTcsIDE4LCAwLCA4LCA3LCA5LCA2LCAxMCwgNSwgMTEsIDQsIDEyLCAzLCAxMywgMiwgMTQsIDEsIDE1IF07XG5cblxuICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUgfHwgIXN0cm0ub3V0cHV0IHx8XG4gICAgICAoIXN0cm0uaW5wdXQgJiYgc3RybS5hdmFpbF9pbiAhPT0gMCkpIHtcbiAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gIH1cblxuICBzdGF0ZSA9IHN0cm0uc3RhdGU7XG4gIGlmIChzdGF0ZS5tb2RlID09PSBUWVBFKSB7IHN0YXRlLm1vZGUgPSBUWVBFRE87IH0gICAgLyogc2tpcCBjaGVjayAqL1xuXG5cbiAgLy8tLS0gTE9BRCgpIC0tLVxuICBwdXQgPSBzdHJtLm5leHRfb3V0O1xuICBvdXRwdXQgPSBzdHJtLm91dHB1dDtcbiAgbGVmdCA9IHN0cm0uYXZhaWxfb3V0O1xuICBuZXh0ID0gc3RybS5uZXh0X2luO1xuICBpbnB1dCA9IHN0cm0uaW5wdXQ7XG4gIGhhdmUgPSBzdHJtLmF2YWlsX2luO1xuICBob2xkID0gc3RhdGUuaG9sZDtcbiAgYml0cyA9IHN0YXRlLmJpdHM7XG4gIC8vLS0tXG5cbiAgX2luID0gaGF2ZTtcbiAgX291dCA9IGxlZnQ7XG4gIHJldCA9IFpfT0s7XG5cbiAgaW5mX2xlYXZlOiAvLyBnb3RvIGVtdWxhdGlvblxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChzdGF0ZS5tb2RlKSB7XG4gICAgY2FzZSBIRUFEOlxuICAgICAgaWYgKHN0YXRlLndyYXAgPT09IDApIHtcbiAgICAgICAgc3RhdGUubW9kZSA9IFRZUEVETztcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICAvLz09PSBORUVEQklUUygxNik7XG4gICAgICB3aGlsZSAoYml0cyA8IDE2KSB7XG4gICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICBoYXZlLS07XG4gICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICBiaXRzICs9IDg7XG4gICAgICB9XG4gICAgICAvLz09PS8vXG4gICAgICBpZiAoKHN0YXRlLndyYXAgJiAyKSAmJiBob2xkID09PSAweDhiMWYpIHsgIC8qIGd6aXAgaGVhZGVyICovXG4gICAgICAgIHN0YXRlLmNoZWNrID0gMC8qY3JjMzIoMEwsIFpfTlVMTCwgMCkqLztcbiAgICAgICAgLy89PT0gQ1JDMihzdGF0ZS5jaGVjaywgaG9sZCk7XG4gICAgICAgIGhidWZbMF0gPSBob2xkICYgMHhmZjtcbiAgICAgICAgaGJ1ZlsxXSA9IChob2xkID4+PiA4KSAmIDB4ZmY7XG4gICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzIoc3RhdGUuY2hlY2ssIGhidWYsIDIsIDApO1xuICAgICAgICAvLz09PS8vXG5cbiAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAvLz09PS8vXG4gICAgICAgIHN0YXRlLm1vZGUgPSBGTEFHUztcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBzdGF0ZS5mbGFncyA9IDA7ICAgICAgICAgICAvKiBleHBlY3QgemxpYiBoZWFkZXIgKi9cbiAgICAgIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgIHN0YXRlLmhlYWQuZG9uZSA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKCEoc3RhdGUud3JhcCAmIDEpIHx8ICAgLyogY2hlY2sgaWYgemxpYiBoZWFkZXIgYWxsb3dlZCAqL1xuICAgICAgICAoKChob2xkICYgMHhmZikvKkJJVFMoOCkqLyA8PCA4KSArIChob2xkID4+IDgpKSAlIDMxKSB7XG4gICAgICAgIHN0cm0ubXNnID0gJ2luY29ycmVjdCBoZWFkZXIgY2hlY2snO1xuICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmICgoaG9sZCAmIDB4MGYpLypCSVRTKDQpKi8gIT09IFpfREVGTEFURUQpIHtcbiAgICAgICAgc3RybS5tc2cgPSAndW5rbm93biBjb21wcmVzc2lvbiBtZXRob2QnO1xuICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIC8vLS0tIERST1BCSVRTKDQpIC0tLS8vXG4gICAgICBob2xkID4+Pj0gNDtcbiAgICAgIGJpdHMgLT0gNDtcbiAgICAgIC8vLS0tLy9cbiAgICAgIGxlbiA9IChob2xkICYgMHgwZikvKkJJVFMoNCkqLyArIDg7XG4gICAgICBpZiAoc3RhdGUud2JpdHMgPT09IDApIHtcbiAgICAgICAgc3RhdGUud2JpdHMgPSBsZW47XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChsZW4gPiBzdGF0ZS53Yml0cykge1xuICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIHdpbmRvdyBzaXplJztcbiAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBzdGF0ZS5kbWF4ID0gMSA8PCBsZW47XG4gICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgemxpYiBoZWFkZXIgb2tcXG5cIikpO1xuICAgICAgc3RybS5hZGxlciA9IHN0YXRlLmNoZWNrID0gMS8qYWRsZXIzMigwTCwgWl9OVUxMLCAwKSovO1xuICAgICAgc3RhdGUubW9kZSA9IGhvbGQgJiAweDIwMCA/IERJQ1RJRCA6IFRZUEU7XG4gICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgaG9sZCA9IDA7XG4gICAgICBiaXRzID0gMDtcbiAgICAgIC8vPT09Ly9cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgRkxBR1M6XG4gICAgICAvLz09PSBORUVEQklUUygxNik7ICovXG4gICAgICB3aGlsZSAoYml0cyA8IDE2KSB7XG4gICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICBoYXZlLS07XG4gICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICBiaXRzICs9IDg7XG4gICAgICB9XG4gICAgICAvLz09PS8vXG4gICAgICBzdGF0ZS5mbGFncyA9IGhvbGQ7XG4gICAgICBpZiAoKHN0YXRlLmZsYWdzICYgMHhmZikgIT09IFpfREVGTEFURUQpIHtcbiAgICAgICAgc3RybS5tc2cgPSAndW5rbm93biBjb21wcmVzc2lvbiBtZXRob2QnO1xuICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4ZTAwMCkge1xuICAgICAgICBzdHJtLm1zZyA9ICd1bmtub3duIGhlYWRlciBmbGFncyBzZXQnO1xuICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgIHN0YXRlLmhlYWQudGV4dCA9ICgoaG9sZCA+PiA4KSAmIDEpO1xuICAgICAgfVxuICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwMjAwKSB7XG4gICAgICAgIC8vPT09IENSQzIoc3RhdGUuY2hlY2ssIGhvbGQpO1xuICAgICAgICBoYnVmWzBdID0gaG9sZCAmIDB4ZmY7XG4gICAgICAgIGhidWZbMV0gPSAoaG9sZCA+Pj4gOCkgJiAweGZmO1xuICAgICAgICBzdGF0ZS5jaGVjayA9IGNyYzMyKHN0YXRlLmNoZWNrLCBoYnVmLCAyLCAwKTtcbiAgICAgICAgLy89PT0vL1xuICAgICAgfVxuICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgIGhvbGQgPSAwO1xuICAgICAgYml0cyA9IDA7XG4gICAgICAvLz09PS8vXG4gICAgICBzdGF0ZS5tb2RlID0gVElNRTtcbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICBjYXNlIFRJTUU6XG4gICAgICAvLz09PSBORUVEQklUUygzMik7ICovXG4gICAgICB3aGlsZSAoYml0cyA8IDMyKSB7XG4gICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICBoYXZlLS07XG4gICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICBiaXRzICs9IDg7XG4gICAgICB9XG4gICAgICAvLz09PS8vXG4gICAgICBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICBzdGF0ZS5oZWFkLnRpbWUgPSBob2xkO1xuICAgICAgfVxuICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwMjAwKSB7XG4gICAgICAgIC8vPT09IENSQzQoc3RhdGUuY2hlY2ssIGhvbGQpXG4gICAgICAgIGhidWZbMF0gPSBob2xkICYgMHhmZjtcbiAgICAgICAgaGJ1ZlsxXSA9IChob2xkID4+PiA4KSAmIDB4ZmY7XG4gICAgICAgIGhidWZbMl0gPSAoaG9sZCA+Pj4gMTYpICYgMHhmZjtcbiAgICAgICAgaGJ1ZlszXSA9IChob2xkID4+PiAyNCkgJiAweGZmO1xuICAgICAgICBzdGF0ZS5jaGVjayA9IGNyYzMyKHN0YXRlLmNoZWNrLCBoYnVmLCA0LCAwKTtcbiAgICAgICAgLy89PT1cbiAgICAgIH1cbiAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICBob2xkID0gMDtcbiAgICAgIGJpdHMgPSAwO1xuICAgICAgLy89PT0vL1xuICAgICAgc3RhdGUubW9kZSA9IE9TO1xuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgIGNhc2UgT1M6XG4gICAgICAvLz09PSBORUVEQklUUygxNik7ICovXG4gICAgICB3aGlsZSAoYml0cyA8IDE2KSB7XG4gICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICBoYXZlLS07XG4gICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICBiaXRzICs9IDg7XG4gICAgICB9XG4gICAgICAvLz09PS8vXG4gICAgICBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICBzdGF0ZS5oZWFkLnhmbGFncyA9IChob2xkICYgMHhmZik7XG4gICAgICAgIHN0YXRlLmhlYWQub3MgPSAoaG9sZCA+PiA4KTtcbiAgICAgIH1cbiAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDIwMCkge1xuICAgICAgICAvLz09PSBDUkMyKHN0YXRlLmNoZWNrLCBob2xkKTtcbiAgICAgICAgaGJ1ZlswXSA9IGhvbGQgJiAweGZmO1xuICAgICAgICBoYnVmWzFdID0gKGhvbGQgPj4+IDgpICYgMHhmZjtcbiAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMihzdGF0ZS5jaGVjaywgaGJ1ZiwgMiwgMCk7XG4gICAgICAgIC8vPT09Ly9cbiAgICAgIH1cbiAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICBob2xkID0gMDtcbiAgICAgIGJpdHMgPSAwO1xuICAgICAgLy89PT0vL1xuICAgICAgc3RhdGUubW9kZSA9IEVYTEVOO1xuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgIGNhc2UgRVhMRU46XG4gICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDA0MDApIHtcbiAgICAgICAgLy89PT0gTkVFREJJVFMoMTYpOyAqL1xuICAgICAgICB3aGlsZSAoYml0cyA8IDE2KSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgfVxuICAgICAgICAvLz09PS8vXG4gICAgICAgIHN0YXRlLmxlbmd0aCA9IGhvbGQ7XG4gICAgICAgIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgICAgc3RhdGUuaGVhZC5leHRyYV9sZW4gPSBob2xkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDIwMCkge1xuICAgICAgICAgIC8vPT09IENSQzIoc3RhdGUuY2hlY2ssIGhvbGQpO1xuICAgICAgICAgIGhidWZbMF0gPSBob2xkICYgMHhmZjtcbiAgICAgICAgICBoYnVmWzFdID0gKGhvbGQgPj4+IDgpICYgMHhmZjtcbiAgICAgICAgICBzdGF0ZS5jaGVjayA9IGNyYzMyKHN0YXRlLmNoZWNrLCBoYnVmLCAyLCAwKTtcbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgIH1cbiAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAvLz09PS8vXG4gICAgICB9XG4gICAgICBlbHNlIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgIHN0YXRlLmhlYWQuZXh0cmEgPSBudWxsLypaX05VTEwqLztcbiAgICAgIH1cbiAgICAgIHN0YXRlLm1vZGUgPSBFWFRSQTtcbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICBjYXNlIEVYVFJBOlxuICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwNDAwKSB7XG4gICAgICAgIGNvcHkgPSBzdGF0ZS5sZW5ndGg7XG4gICAgICAgIGlmIChjb3B5ID4gaGF2ZSkgeyBjb3B5ID0gaGF2ZTsgfVxuICAgICAgICBpZiAoY29weSkge1xuICAgICAgICAgIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgICAgICBsZW4gPSBzdGF0ZS5oZWFkLmV4dHJhX2xlbiAtIHN0YXRlLmxlbmd0aDtcbiAgICAgICAgICAgIGlmICghc3RhdGUuaGVhZC5leHRyYSkge1xuICAgICAgICAgICAgICAvLyBVc2UgdW50eXBlZCBhcnJheSBmb3IgbW9yZSBjb252ZW5pZW5kIHByb2Nlc3NpbmcgbGF0ZXJcbiAgICAgICAgICAgICAgc3RhdGUuaGVhZC5leHRyYSA9IG5ldyBBcnJheShzdGF0ZS5oZWFkLmV4dHJhX2xlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB1dGlscy5hcnJheVNldChcbiAgICAgICAgICAgICAgc3RhdGUuaGVhZC5leHRyYSxcbiAgICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICAgIG5leHQsXG4gICAgICAgICAgICAgIC8vIGV4dHJhIGZpZWxkIGlzIGxpbWl0ZWQgdG8gNjU1MzYgYnl0ZXNcbiAgICAgICAgICAgICAgLy8gLSBubyBuZWVkIGZvciBhZGRpdGlvbmFsIHNpemUgY2hlY2tcbiAgICAgICAgICAgICAgY29weSxcbiAgICAgICAgICAgICAgLypsZW4gKyBjb3B5ID4gc3RhdGUuaGVhZC5leHRyYV9tYXggLSBsZW4gPyBzdGF0ZS5oZWFkLmV4dHJhX21heCA6IGNvcHksKi9cbiAgICAgICAgICAgICAgbGVuXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgLy96bWVtY3B5KHN0YXRlLmhlYWQuZXh0cmEgKyBsZW4sIG5leHQsXG4gICAgICAgICAgICAvLyAgICAgICAgbGVuICsgY29weSA+IHN0YXRlLmhlYWQuZXh0cmFfbWF4ID9cbiAgICAgICAgICAgIC8vICAgICAgICBzdGF0ZS5oZWFkLmV4dHJhX21heCAtIGxlbiA6IGNvcHkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDAyMDApIHtcbiAgICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzIoc3RhdGUuY2hlY2ssIGlucHV0LCBjb3B5LCBuZXh0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaGF2ZSAtPSBjb3B5O1xuICAgICAgICAgIG5leHQgKz0gY29weTtcbiAgICAgICAgICBzdGF0ZS5sZW5ndGggLT0gY29weTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGUubGVuZ3RoKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgfVxuICAgICAgc3RhdGUubGVuZ3RoID0gMDtcbiAgICAgIHN0YXRlLm1vZGUgPSBOQU1FO1xuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgIGNhc2UgTkFNRTpcbiAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDgwMCkge1xuICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgY29weSA9IDA7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAvLyBUT0RPOiAyIG9yIDEgYnl0ZXM/XG4gICAgICAgICAgbGVuID0gaW5wdXRbbmV4dCArIGNvcHkrK107XG4gICAgICAgICAgLyogdXNlIGNvbnN0YW50IGxpbWl0IGJlY2F1c2UgaW4ganMgd2Ugc2hvdWxkIG5vdCBwcmVhbGxvY2F0ZSBtZW1vcnkgKi9cbiAgICAgICAgICBpZiAoc3RhdGUuaGVhZCAmJiBsZW4gJiZcbiAgICAgICAgICAgICAgKHN0YXRlLmxlbmd0aCA8IDY1NTM2IC8qc3RhdGUuaGVhZC5uYW1lX21heCovKSkge1xuICAgICAgICAgICAgc3RhdGUuaGVhZC5uYW1lICs9IFN0cmluZy5mcm9tQ2hhckNvZGUobGVuKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gd2hpbGUgKGxlbiAmJiBjb3B5IDwgaGF2ZSk7XG5cbiAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwMjAwKSB7XG4gICAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMihzdGF0ZS5jaGVjaywgaW5wdXQsIGNvcHksIG5leHQpO1xuICAgICAgICB9XG4gICAgICAgIGhhdmUgLT0gY29weTtcbiAgICAgICAgbmV4dCArPSBjb3B5O1xuICAgICAgICBpZiAobGVuKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgfVxuICAgICAgZWxzZSBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICBzdGF0ZS5oZWFkLm5hbWUgPSBudWxsO1xuICAgICAgfVxuICAgICAgc3RhdGUubGVuZ3RoID0gMDtcbiAgICAgIHN0YXRlLm1vZGUgPSBDT01NRU5UO1xuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgIGNhc2UgQ09NTUVOVDpcbiAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MTAwMCkge1xuICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgY29weSA9IDA7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICBsZW4gPSBpbnB1dFtuZXh0ICsgY29weSsrXTtcbiAgICAgICAgICAvKiB1c2UgY29uc3RhbnQgbGltaXQgYmVjYXVzZSBpbiBqcyB3ZSBzaG91bGQgbm90IHByZWFsbG9jYXRlIG1lbW9yeSAqL1xuICAgICAgICAgIGlmIChzdGF0ZS5oZWFkICYmIGxlbiAmJlxuICAgICAgICAgICAgICAoc3RhdGUubGVuZ3RoIDwgNjU1MzYgLypzdGF0ZS5oZWFkLmNvbW1fbWF4Ki8pKSB7XG4gICAgICAgICAgICBzdGF0ZS5oZWFkLmNvbW1lbnQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShsZW4pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSB3aGlsZSAobGVuICYmIGNvcHkgPCBoYXZlKTtcbiAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwMjAwKSB7XG4gICAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMihzdGF0ZS5jaGVjaywgaW5wdXQsIGNvcHksIG5leHQpO1xuICAgICAgICB9XG4gICAgICAgIGhhdmUgLT0gY29weTtcbiAgICAgICAgbmV4dCArPSBjb3B5O1xuICAgICAgICBpZiAobGVuKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgfVxuICAgICAgZWxzZSBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICBzdGF0ZS5oZWFkLmNvbW1lbnQgPSBudWxsO1xuICAgICAgfVxuICAgICAgc3RhdGUubW9kZSA9IEhDUkM7XG4gICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgY2FzZSBIQ1JDOlxuICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwMjAwKSB7XG4gICAgICAgIC8vPT09IE5FRURCSVRTKDE2KTsgKi9cbiAgICAgICAgd2hpbGUgKGJpdHMgPCAxNikge1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0vL1xuICAgICAgICBpZiAoaG9sZCAhPT0gKHN0YXRlLmNoZWNrICYgMHhmZmZmKSkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ2hlYWRlciBjcmMgbWlzbWF0Y2gnO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAvLz09PS8vXG4gICAgICB9XG4gICAgICBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICBzdGF0ZS5oZWFkLmhjcmMgPSAoKHN0YXRlLmZsYWdzID4+IDkpICYgMSk7XG4gICAgICAgIHN0YXRlLmhlYWQuZG9uZSA9IHRydWU7XG4gICAgICB9XG4gICAgICBzdHJtLmFkbGVyID0gc3RhdGUuY2hlY2sgPSAwO1xuICAgICAgc3RhdGUubW9kZSA9IFRZUEU7XG4gICAgICBicmVhaztcbiAgICBjYXNlIERJQ1RJRDpcbiAgICAgIC8vPT09IE5FRURCSVRTKDMyKTsgKi9cbiAgICAgIHdoaWxlIChiaXRzIDwgMzIpIHtcbiAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIGhhdmUtLTtcbiAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgIGJpdHMgKz0gODtcbiAgICAgIH1cbiAgICAgIC8vPT09Ly9cbiAgICAgIHN0cm0uYWRsZXIgPSBzdGF0ZS5jaGVjayA9IHpzd2FwMzIoaG9sZCk7XG4gICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgaG9sZCA9IDA7XG4gICAgICBiaXRzID0gMDtcbiAgICAgIC8vPT09Ly9cbiAgICAgIHN0YXRlLm1vZGUgPSBESUNUO1xuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgIGNhc2UgRElDVDpcbiAgICAgIGlmIChzdGF0ZS5oYXZlZGljdCA9PT0gMCkge1xuICAgICAgICAvLy0tLSBSRVNUT1JFKCkgLS0tXG4gICAgICAgIHN0cm0ubmV4dF9vdXQgPSBwdXQ7XG4gICAgICAgIHN0cm0uYXZhaWxfb3V0ID0gbGVmdDtcbiAgICAgICAgc3RybS5uZXh0X2luID0gbmV4dDtcbiAgICAgICAgc3RybS5hdmFpbF9pbiA9IGhhdmU7XG4gICAgICAgIHN0YXRlLmhvbGQgPSBob2xkO1xuICAgICAgICBzdGF0ZS5iaXRzID0gYml0cztcbiAgICAgICAgLy8tLS1cbiAgICAgICAgcmV0dXJuIFpfTkVFRF9ESUNUO1xuICAgICAgfVxuICAgICAgc3RybS5hZGxlciA9IHN0YXRlLmNoZWNrID0gMS8qYWRsZXIzMigwTCwgWl9OVUxMLCAwKSovO1xuICAgICAgc3RhdGUubW9kZSA9IFRZUEU7XG4gICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgY2FzZSBUWVBFOlxuICAgICAgaWYgKGZsdXNoID09PSBaX0JMT0NLIHx8IGZsdXNoID09PSBaX1RSRUVTKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgIGNhc2UgVFlQRURPOlxuICAgICAgaWYgKHN0YXRlLmxhc3QpIHtcbiAgICAgICAgLy8tLS0gQllURUJJVFMoKSAtLS0vL1xuICAgICAgICBob2xkID4+Pj0gYml0cyAmIDc7XG4gICAgICAgIGJpdHMgLT0gYml0cyAmIDc7XG4gICAgICAgIC8vLS0tLy9cbiAgICAgICAgc3RhdGUubW9kZSA9IENIRUNLO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIC8vPT09IE5FRURCSVRTKDMpOyAqL1xuICAgICAgd2hpbGUgKGJpdHMgPCAzKSB7XG4gICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICBoYXZlLS07XG4gICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICBiaXRzICs9IDg7XG4gICAgICB9XG4gICAgICAvLz09PS8vXG4gICAgICBzdGF0ZS5sYXN0ID0gKGhvbGQgJiAweDAxKS8qQklUUygxKSovO1xuICAgICAgLy8tLS0gRFJPUEJJVFMoMSkgLS0tLy9cbiAgICAgIGhvbGQgPj4+PSAxO1xuICAgICAgYml0cyAtPSAxO1xuICAgICAgLy8tLS0vL1xuXG4gICAgICBzd2l0Y2ggKChob2xkICYgMHgwMykvKkJJVFMoMikqLykge1xuICAgICAgY2FzZSAwOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogc3RvcmVkIGJsb2NrICovXG4gICAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgIHN0b3JlZCBibG9jayVzXFxuXCIsXG4gICAgICAgIC8vICAgICAgICBzdGF0ZS5sYXN0ID8gXCIgKGxhc3QpXCIgOiBcIlwiKSk7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBTVE9SRUQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogZml4ZWQgYmxvY2sgKi9cbiAgICAgICAgZml4ZWR0YWJsZXMoc3RhdGUpO1xuICAgICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgICBmaXhlZCBjb2RlcyBibG9jayVzXFxuXCIsXG4gICAgICAgIC8vICAgICAgICBzdGF0ZS5sYXN0ID8gXCIgKGxhc3QpXCIgOiBcIlwiKSk7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBMRU5fOyAgICAgICAgICAgICAvKiBkZWNvZGUgY29kZXMgKi9cbiAgICAgICAgaWYgKGZsdXNoID09PSBaX1RSRUVTKSB7XG4gICAgICAgICAgLy8tLS0gRFJPUEJJVFMoMikgLS0tLy9cbiAgICAgICAgICBob2xkID4+Pj0gMjtcbiAgICAgICAgICBiaXRzIC09IDI7XG4gICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjogICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIGR5bmFtaWMgYmxvY2sgKi9cbiAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgZHluYW1pYyBjb2RlcyBibG9jayVzXFxuXCIsXG4gICAgICAgIC8vICAgICAgICBzdGF0ZS5sYXN0ID8gXCIgKGxhc3QpXCIgOiBcIlwiKSk7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBUQUJMRTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDM6XG4gICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgYmxvY2sgdHlwZSc7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICB9XG4gICAgICAvLy0tLSBEUk9QQklUUygyKSAtLS0vL1xuICAgICAgaG9sZCA+Pj49IDI7XG4gICAgICBiaXRzIC09IDI7XG4gICAgICAvLy0tLS8vXG4gICAgICBicmVhaztcbiAgICBjYXNlIFNUT1JFRDpcbiAgICAgIC8vLS0tIEJZVEVCSVRTKCkgLS0tLy8gLyogZ28gdG8gYnl0ZSBib3VuZGFyeSAqL1xuICAgICAgaG9sZCA+Pj49IGJpdHMgJiA3O1xuICAgICAgYml0cyAtPSBiaXRzICYgNztcbiAgICAgIC8vLS0tLy9cbiAgICAgIC8vPT09IE5FRURCSVRTKDMyKTsgKi9cbiAgICAgIHdoaWxlIChiaXRzIDwgMzIpIHtcbiAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIGhhdmUtLTtcbiAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgIGJpdHMgKz0gODtcbiAgICAgIH1cbiAgICAgIC8vPT09Ly9cbiAgICAgIGlmICgoaG9sZCAmIDB4ZmZmZikgIT09ICgoaG9sZCA+Pj4gMTYpIF4gMHhmZmZmKSkge1xuICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIHN0b3JlZCBibG9jayBsZW5ndGhzJztcbiAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBzdGF0ZS5sZW5ndGggPSBob2xkICYgMHhmZmZmO1xuICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICBzdG9yZWQgbGVuZ3RoICV1XFxuXCIsXG4gICAgICAvLyAgICAgICAgc3RhdGUubGVuZ3RoKSk7XG4gICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgaG9sZCA9IDA7XG4gICAgICBiaXRzID0gMDtcbiAgICAgIC8vPT09Ly9cbiAgICAgIHN0YXRlLm1vZGUgPSBDT1BZXztcbiAgICAgIGlmIChmbHVzaCA9PT0gWl9UUkVFUykgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICBjYXNlIENPUFlfOlxuICAgICAgc3RhdGUubW9kZSA9IENPUFk7XG4gICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgY2FzZSBDT1BZOlxuICAgICAgY29weSA9IHN0YXRlLmxlbmd0aDtcbiAgICAgIGlmIChjb3B5KSB7XG4gICAgICAgIGlmIChjb3B5ID4gaGF2ZSkgeyBjb3B5ID0gaGF2ZTsgfVxuICAgICAgICBpZiAoY29weSA+IGxlZnQpIHsgY29weSA9IGxlZnQ7IH1cbiAgICAgICAgaWYgKGNvcHkgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIC8vLS0tIHptZW1jcHkocHV0LCBuZXh0LCBjb3B5KTsgLS0tXG4gICAgICAgIHV0aWxzLmFycmF5U2V0KG91dHB1dCwgaW5wdXQsIG5leHQsIGNvcHksIHB1dCk7XG4gICAgICAgIC8vLS0tLy9cbiAgICAgICAgaGF2ZSAtPSBjb3B5O1xuICAgICAgICBuZXh0ICs9IGNvcHk7XG4gICAgICAgIGxlZnQgLT0gY29weTtcbiAgICAgICAgcHV0ICs9IGNvcHk7XG4gICAgICAgIHN0YXRlLmxlbmd0aCAtPSBjb3B5O1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgc3RvcmVkIGVuZFxcblwiKSk7XG4gICAgICBzdGF0ZS5tb2RlID0gVFlQRTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgVEFCTEU6XG4gICAgICAvLz09PSBORUVEQklUUygxNCk7ICovXG4gICAgICB3aGlsZSAoYml0cyA8IDE0KSB7XG4gICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICBoYXZlLS07XG4gICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICBiaXRzICs9IDg7XG4gICAgICB9XG4gICAgICAvLz09PS8vXG4gICAgICBzdGF0ZS5ubGVuID0gKGhvbGQgJiAweDFmKS8qQklUUyg1KSovICsgMjU3O1xuICAgICAgLy8tLS0gRFJPUEJJVFMoNSkgLS0tLy9cbiAgICAgIGhvbGQgPj4+PSA1O1xuICAgICAgYml0cyAtPSA1O1xuICAgICAgLy8tLS0vL1xuICAgICAgc3RhdGUubmRpc3QgPSAoaG9sZCAmIDB4MWYpLypCSVRTKDUpKi8gKyAxO1xuICAgICAgLy8tLS0gRFJPUEJJVFMoNSkgLS0tLy9cbiAgICAgIGhvbGQgPj4+PSA1O1xuICAgICAgYml0cyAtPSA1O1xuICAgICAgLy8tLS0vL1xuICAgICAgc3RhdGUubmNvZGUgPSAoaG9sZCAmIDB4MGYpLypCSVRTKDQpKi8gKyA0O1xuICAgICAgLy8tLS0gRFJPUEJJVFMoNCkgLS0tLy9cbiAgICAgIGhvbGQgPj4+PSA0O1xuICAgICAgYml0cyAtPSA0O1xuICAgICAgLy8tLS0vL1xuLy8jaWZuZGVmIFBLWklQX0JVR19XT1JLQVJPVU5EXG4gICAgICBpZiAoc3RhdGUubmxlbiA+IDI4NiB8fCBzdGF0ZS5uZGlzdCA+IDMwKSB7XG4gICAgICAgIHN0cm0ubXNnID0gJ3RvbyBtYW55IGxlbmd0aCBvciBkaXN0YW5jZSBzeW1ib2xzJztcbiAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4vLyNlbmRpZlxuICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICB0YWJsZSBzaXplcyBva1xcblwiKSk7XG4gICAgICBzdGF0ZS5oYXZlID0gMDtcbiAgICAgIHN0YXRlLm1vZGUgPSBMRU5MRU5TO1xuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgIGNhc2UgTEVOTEVOUzpcbiAgICAgIHdoaWxlIChzdGF0ZS5oYXZlIDwgc3RhdGUubmNvZGUpIHtcbiAgICAgICAgLy89PT0gTkVFREJJVFMoMyk7XG4gICAgICAgIHdoaWxlIChiaXRzIDwgMykge1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0vL1xuICAgICAgICBzdGF0ZS5sZW5zW29yZGVyW3N0YXRlLmhhdmUrK11dID0gKGhvbGQgJiAweDA3KTsvL0JJVFMoMyk7XG4gICAgICAgIC8vLS0tIERST1BCSVRTKDMpIC0tLS8vXG4gICAgICAgIGhvbGQgPj4+PSAzO1xuICAgICAgICBiaXRzIC09IDM7XG4gICAgICAgIC8vLS0tLy9cbiAgICAgIH1cbiAgICAgIHdoaWxlIChzdGF0ZS5oYXZlIDwgMTkpIHtcbiAgICAgICAgc3RhdGUubGVuc1tvcmRlcltzdGF0ZS5oYXZlKytdXSA9IDA7XG4gICAgICB9XG4gICAgICAvLyBXZSBoYXZlIHNlcGFyYXRlIHRhYmxlcyAmIG5vIHBvaW50ZXJzLiAyIGNvbW1lbnRlZCBsaW5lcyBiZWxvdyBub3QgbmVlZGVkLlxuICAgICAgLy9zdGF0ZS5uZXh0ID0gc3RhdGUuY29kZXM7XG4gICAgICAvL3N0YXRlLmxlbmNvZGUgPSBzdGF0ZS5uZXh0O1xuICAgICAgLy8gU3dpdGNoIHRvIHVzZSBkeW5hbWljIHRhYmxlXG4gICAgICBzdGF0ZS5sZW5jb2RlID0gc3RhdGUubGVuZHluO1xuICAgICAgc3RhdGUubGVuYml0cyA9IDc7XG5cbiAgICAgIG9wdHMgPSB7IGJpdHM6IHN0YXRlLmxlbmJpdHMgfTtcbiAgICAgIHJldCA9IGluZmxhdGVfdGFibGUoQ09ERVMsIHN0YXRlLmxlbnMsIDAsIDE5LCBzdGF0ZS5sZW5jb2RlLCAwLCBzdGF0ZS53b3JrLCBvcHRzKTtcbiAgICAgIHN0YXRlLmxlbmJpdHMgPSBvcHRzLmJpdHM7XG5cbiAgICAgIGlmIChyZXQpIHtcbiAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBjb2RlIGxlbmd0aHMgc2V0JztcbiAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgIGNvZGUgbGVuZ3RocyBva1xcblwiKSk7XG4gICAgICBzdGF0ZS5oYXZlID0gMDtcbiAgICAgIHN0YXRlLm1vZGUgPSBDT0RFTEVOUztcbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICBjYXNlIENPREVMRU5TOlxuICAgICAgd2hpbGUgKHN0YXRlLmhhdmUgPCBzdGF0ZS5ubGVuICsgc3RhdGUubmRpc3QpIHtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgIGhlcmUgPSBzdGF0ZS5sZW5jb2RlW2hvbGQgJiAoKDEgPDwgc3RhdGUubGVuYml0cykgLSAxKV07LypCSVRTKHN0YXRlLmxlbmJpdHMpKi9cbiAgICAgICAgICBoZXJlX2JpdHMgPSBoZXJlID4+PiAyNDtcbiAgICAgICAgICBoZXJlX29wID0gKGhlcmUgPj4+IDE2KSAmIDB4ZmY7XG4gICAgICAgICAgaGVyZV92YWwgPSBoZXJlICYgMHhmZmZmO1xuXG4gICAgICAgICAgaWYgKChoZXJlX2JpdHMpIDw9IGJpdHMpIHsgYnJlYWs7IH1cbiAgICAgICAgICAvLy0tLSBQVUxMQllURSgpIC0tLS8vXG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAvLy0tLS8vXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhlcmVfdmFsIDwgMTYpIHtcbiAgICAgICAgICAvLy0tLSBEUk9QQklUUyhoZXJlLmJpdHMpIC0tLS8vXG4gICAgICAgICAgaG9sZCA+Pj49IGhlcmVfYml0cztcbiAgICAgICAgICBiaXRzIC09IGhlcmVfYml0cztcbiAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgc3RhdGUubGVuc1tzdGF0ZS5oYXZlKytdID0gaGVyZV92YWw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgaWYgKGhlcmVfdmFsID09PSAxNikge1xuICAgICAgICAgICAgLy89PT0gTkVFREJJVFMoaGVyZS5iaXRzICsgMik7XG4gICAgICAgICAgICBuID0gaGVyZV9iaXRzICsgMjtcbiAgICAgICAgICAgIHdoaWxlIChiaXRzIDwgbikge1xuICAgICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy89PT0vL1xuICAgICAgICAgICAgLy8tLS0gRFJPUEJJVFMoaGVyZS5iaXRzKSAtLS0vL1xuICAgICAgICAgICAgaG9sZCA+Pj49IGhlcmVfYml0cztcbiAgICAgICAgICAgIGJpdHMgLT0gaGVyZV9iaXRzO1xuICAgICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgICAgaWYgKHN0YXRlLmhhdmUgPT09IDApIHtcbiAgICAgICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBiaXQgbGVuZ3RoIHJlcGVhdCc7XG4gICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGVuID0gc3RhdGUubGVuc1tzdGF0ZS5oYXZlIC0gMV07XG4gICAgICAgICAgICBjb3B5ID0gMyArIChob2xkICYgMHgwMyk7Ly9CSVRTKDIpO1xuICAgICAgICAgICAgLy8tLS0gRFJPUEJJVFMoMikgLS0tLy9cbiAgICAgICAgICAgIGhvbGQgPj4+PSAyO1xuICAgICAgICAgICAgYml0cyAtPSAyO1xuICAgICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmIChoZXJlX3ZhbCA9PT0gMTcpIHtcbiAgICAgICAgICAgIC8vPT09IE5FRURCSVRTKGhlcmUuYml0cyArIDMpO1xuICAgICAgICAgICAgbiA9IGhlcmVfYml0cyArIDM7XG4gICAgICAgICAgICB3aGlsZSAoYml0cyA8IG4pIHtcbiAgICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICAgIC8vLS0tIERST1BCSVRTKGhlcmUuYml0cykgLS0tLy9cbiAgICAgICAgICAgIGhvbGQgPj4+PSBoZXJlX2JpdHM7XG4gICAgICAgICAgICBiaXRzIC09IGhlcmVfYml0cztcbiAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICAgIGxlbiA9IDA7XG4gICAgICAgICAgICBjb3B5ID0gMyArIChob2xkICYgMHgwNyk7Ly9CSVRTKDMpO1xuICAgICAgICAgICAgLy8tLS0gRFJPUEJJVFMoMykgLS0tLy9cbiAgICAgICAgICAgIGhvbGQgPj4+PSAzO1xuICAgICAgICAgICAgYml0cyAtPSAzO1xuICAgICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vPT09IE5FRURCSVRTKGhlcmUuYml0cyArIDcpO1xuICAgICAgICAgICAgbiA9IGhlcmVfYml0cyArIDc7XG4gICAgICAgICAgICB3aGlsZSAoYml0cyA8IG4pIHtcbiAgICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICAgIC8vLS0tIERST1BCSVRTKGhlcmUuYml0cykgLS0tLy9cbiAgICAgICAgICAgIGhvbGQgPj4+PSBoZXJlX2JpdHM7XG4gICAgICAgICAgICBiaXRzIC09IGhlcmVfYml0cztcbiAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICAgIGxlbiA9IDA7XG4gICAgICAgICAgICBjb3B5ID0gMTEgKyAoaG9sZCAmIDB4N2YpOy8vQklUUyg3KTtcbiAgICAgICAgICAgIC8vLS0tIERST1BCSVRTKDcpIC0tLS8vXG4gICAgICAgICAgICBob2xkID4+Pj0gNztcbiAgICAgICAgICAgIGJpdHMgLT0gNztcbiAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHN0YXRlLmhhdmUgKyBjb3B5ID4gc3RhdGUubmxlbiArIHN0YXRlLm5kaXN0KSB7XG4gICAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGJpdCBsZW5ndGggcmVwZWF0JztcbiAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgd2hpbGUgKGNvcHktLSkge1xuICAgICAgICAgICAgc3RhdGUubGVuc1tzdGF0ZS5oYXZlKytdID0gbGVuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKiBoYW5kbGUgZXJyb3IgYnJlYWtzIGluIHdoaWxlICovXG4gICAgICBpZiAoc3RhdGUubW9kZSA9PT0gQkFEKSB7IGJyZWFrOyB9XG5cbiAgICAgIC8qIGNoZWNrIGZvciBlbmQtb2YtYmxvY2sgY29kZSAoYmV0dGVyIGhhdmUgb25lKSAqL1xuICAgICAgaWYgKHN0YXRlLmxlbnNbMjU2XSA9PT0gMCkge1xuICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGNvZGUgLS0gbWlzc2luZyBlbmQtb2YtYmxvY2snO1xuICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgLyogYnVpbGQgY29kZSB0YWJsZXMgLS0gbm90ZTogZG8gbm90IGNoYW5nZSB0aGUgbGVuYml0cyBvciBkaXN0Yml0c1xuICAgICAgICAgdmFsdWVzIGhlcmUgKDkgYW5kIDYpIHdpdGhvdXQgcmVhZGluZyB0aGUgY29tbWVudHMgaW4gaW5mdHJlZXMuaFxuICAgICAgICAgY29uY2VybmluZyB0aGUgRU5PVUdIIGNvbnN0YW50cywgd2hpY2ggZGVwZW5kIG9uIHRob3NlIHZhbHVlcyAqL1xuICAgICAgc3RhdGUubGVuYml0cyA9IDk7XG5cbiAgICAgIG9wdHMgPSB7IGJpdHM6IHN0YXRlLmxlbmJpdHMgfTtcbiAgICAgIHJldCA9IGluZmxhdGVfdGFibGUoTEVOUywgc3RhdGUubGVucywgMCwgc3RhdGUubmxlbiwgc3RhdGUubGVuY29kZSwgMCwgc3RhdGUud29yaywgb3B0cyk7XG4gICAgICAvLyBXZSBoYXZlIHNlcGFyYXRlIHRhYmxlcyAmIG5vIHBvaW50ZXJzLiAyIGNvbW1lbnRlZCBsaW5lcyBiZWxvdyBub3QgbmVlZGVkLlxuICAgICAgLy8gc3RhdGUubmV4dF9pbmRleCA9IG9wdHMudGFibGVfaW5kZXg7XG4gICAgICBzdGF0ZS5sZW5iaXRzID0gb3B0cy5iaXRzO1xuICAgICAgLy8gc3RhdGUubGVuY29kZSA9IHN0YXRlLm5leHQ7XG5cbiAgICAgIGlmIChyZXQpIHtcbiAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBsaXRlcmFsL2xlbmd0aHMgc2V0JztcbiAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHN0YXRlLmRpc3RiaXRzID0gNjtcbiAgICAgIC8vc3RhdGUuZGlzdGNvZGUuY29weShzdGF0ZS5jb2Rlcyk7XG4gICAgICAvLyBTd2l0Y2ggdG8gdXNlIGR5bmFtaWMgdGFibGVcbiAgICAgIHN0YXRlLmRpc3Rjb2RlID0gc3RhdGUuZGlzdGR5bjtcbiAgICAgIG9wdHMgPSB7IGJpdHM6IHN0YXRlLmRpc3RiaXRzIH07XG4gICAgICByZXQgPSBpbmZsYXRlX3RhYmxlKERJU1RTLCBzdGF0ZS5sZW5zLCBzdGF0ZS5ubGVuLCBzdGF0ZS5uZGlzdCwgc3RhdGUuZGlzdGNvZGUsIDAsIHN0YXRlLndvcmssIG9wdHMpO1xuICAgICAgLy8gV2UgaGF2ZSBzZXBhcmF0ZSB0YWJsZXMgJiBubyBwb2ludGVycy4gMiBjb21tZW50ZWQgbGluZXMgYmVsb3cgbm90IG5lZWRlZC5cbiAgICAgIC8vIHN0YXRlLm5leHRfaW5kZXggPSBvcHRzLnRhYmxlX2luZGV4O1xuICAgICAgc3RhdGUuZGlzdGJpdHMgPSBvcHRzLmJpdHM7XG4gICAgICAvLyBzdGF0ZS5kaXN0Y29kZSA9IHN0YXRlLm5leHQ7XG5cbiAgICAgIGlmIChyZXQpIHtcbiAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBkaXN0YW5jZXMgc2V0JztcbiAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICAvL1RyYWNldigoc3RkZXJyLCAnaW5mbGF0ZTogICAgICAgY29kZXMgb2tcXG4nKSk7XG4gICAgICBzdGF0ZS5tb2RlID0gTEVOXztcbiAgICAgIGlmIChmbHVzaCA9PT0gWl9UUkVFUykgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICBjYXNlIExFTl86XG4gICAgICBzdGF0ZS5tb2RlID0gTEVOO1xuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgIGNhc2UgTEVOOlxuICAgICAgaWYgKGhhdmUgPj0gNiAmJiBsZWZ0ID49IDI1OCkge1xuICAgICAgICAvLy0tLSBSRVNUT1JFKCkgLS0tXG4gICAgICAgIHN0cm0ubmV4dF9vdXQgPSBwdXQ7XG4gICAgICAgIHN0cm0uYXZhaWxfb3V0ID0gbGVmdDtcbiAgICAgICAgc3RybS5uZXh0X2luID0gbmV4dDtcbiAgICAgICAgc3RybS5hdmFpbF9pbiA9IGhhdmU7XG4gICAgICAgIHN0YXRlLmhvbGQgPSBob2xkO1xuICAgICAgICBzdGF0ZS5iaXRzID0gYml0cztcbiAgICAgICAgLy8tLS1cbiAgICAgICAgaW5mbGF0ZV9mYXN0KHN0cm0sIF9vdXQpO1xuICAgICAgICAvLy0tLSBMT0FEKCkgLS0tXG4gICAgICAgIHB1dCA9IHN0cm0ubmV4dF9vdXQ7XG4gICAgICAgIG91dHB1dCA9IHN0cm0ub3V0cHV0O1xuICAgICAgICBsZWZ0ID0gc3RybS5hdmFpbF9vdXQ7XG4gICAgICAgIG5leHQgPSBzdHJtLm5leHRfaW47XG4gICAgICAgIGlucHV0ID0gc3RybS5pbnB1dDtcbiAgICAgICAgaGF2ZSA9IHN0cm0uYXZhaWxfaW47XG4gICAgICAgIGhvbGQgPSBzdGF0ZS5ob2xkO1xuICAgICAgICBiaXRzID0gc3RhdGUuYml0cztcbiAgICAgICAgLy8tLS1cblxuICAgICAgICBpZiAoc3RhdGUubW9kZSA9PT0gVFlQRSkge1xuICAgICAgICAgIHN0YXRlLmJhY2sgPSAtMTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHN0YXRlLmJhY2sgPSAwO1xuICAgICAgZm9yICg7Oykge1xuICAgICAgICBoZXJlID0gc3RhdGUubGVuY29kZVtob2xkICYgKCgxIDw8IHN0YXRlLmxlbmJpdHMpIC0gMSldOyAgLypCSVRTKHN0YXRlLmxlbmJpdHMpKi9cbiAgICAgICAgaGVyZV9iaXRzID0gaGVyZSA+Pj4gMjQ7XG4gICAgICAgIGhlcmVfb3AgPSAoaGVyZSA+Pj4gMTYpICYgMHhmZjtcbiAgICAgICAgaGVyZV92YWwgPSBoZXJlICYgMHhmZmZmO1xuXG4gICAgICAgIGlmIChoZXJlX2JpdHMgPD0gYml0cykgeyBicmVhazsgfVxuICAgICAgICAvLy0tLSBQVUxMQllURSgpIC0tLS8vXG4gICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICBoYXZlLS07XG4gICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgIC8vLS0tLy9cbiAgICAgIH1cbiAgICAgIGlmIChoZXJlX29wICYmIChoZXJlX29wICYgMHhmMCkgPT09IDApIHtcbiAgICAgICAgbGFzdF9iaXRzID0gaGVyZV9iaXRzO1xuICAgICAgICBsYXN0X29wID0gaGVyZV9vcDtcbiAgICAgICAgbGFzdF92YWwgPSBoZXJlX3ZhbDtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgIGhlcmUgPSBzdGF0ZS5sZW5jb2RlW2xhc3RfdmFsICtcbiAgICAgICAgICAgICAgICAgICgoaG9sZCAmICgoMSA8PCAobGFzdF9iaXRzICsgbGFzdF9vcCkpIC0gMSkpLypCSVRTKGxhc3QuYml0cyArIGxhc3Qub3ApKi8gPj4gbGFzdF9iaXRzKV07XG4gICAgICAgICAgaGVyZV9iaXRzID0gaGVyZSA+Pj4gMjQ7XG4gICAgICAgICAgaGVyZV9vcCA9IChoZXJlID4+PiAxNikgJiAweGZmO1xuICAgICAgICAgIGhlcmVfdmFsID0gaGVyZSAmIDB4ZmZmZjtcblxuICAgICAgICAgIGlmICgobGFzdF9iaXRzICsgaGVyZV9iaXRzKSA8PSBiaXRzKSB7IGJyZWFrOyB9XG4gICAgICAgICAgLy8tLS0gUFVMTEJZVEUoKSAtLS0vL1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgLy8tLS0vL1xuICAgICAgICB9XG4gICAgICAgIC8vLS0tIERST1BCSVRTKGxhc3QuYml0cykgLS0tLy9cbiAgICAgICAgaG9sZCA+Pj49IGxhc3RfYml0cztcbiAgICAgICAgYml0cyAtPSBsYXN0X2JpdHM7XG4gICAgICAgIC8vLS0tLy9cbiAgICAgICAgc3RhdGUuYmFjayArPSBsYXN0X2JpdHM7XG4gICAgICB9XG4gICAgICAvLy0tLSBEUk9QQklUUyhoZXJlLmJpdHMpIC0tLS8vXG4gICAgICBob2xkID4+Pj0gaGVyZV9iaXRzO1xuICAgICAgYml0cyAtPSBoZXJlX2JpdHM7XG4gICAgICAvLy0tLS8vXG4gICAgICBzdGF0ZS5iYWNrICs9IGhlcmVfYml0cztcbiAgICAgIHN0YXRlLmxlbmd0aCA9IGhlcmVfdmFsO1xuICAgICAgaWYgKGhlcmVfb3AgPT09IDApIHtcbiAgICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsIGhlcmUudmFsID49IDB4MjAgJiYgaGVyZS52YWwgPCAweDdmID9cbiAgICAgICAgLy8gICAgICAgIFwiaW5mbGF0ZTogICAgICAgICBsaXRlcmFsICclYydcXG5cIiA6XG4gICAgICAgIC8vICAgICAgICBcImluZmxhdGU6ICAgICAgICAgbGl0ZXJhbCAweCUwMnhcXG5cIiwgaGVyZS52YWwpKTtcbiAgICAgICAgc3RhdGUubW9kZSA9IExJVDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoaGVyZV9vcCAmIDMyKSB7XG4gICAgICAgIC8vVHJhY2V2digoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgICAgZW5kIG9mIGJsb2NrXFxuXCIpKTtcbiAgICAgICAgc3RhdGUuYmFjayA9IC0xO1xuICAgICAgICBzdGF0ZS5tb2RlID0gVFlQRTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoaGVyZV9vcCAmIDY0KSB7XG4gICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgbGl0ZXJhbC9sZW5ndGggY29kZSc7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgc3RhdGUuZXh0cmEgPSBoZXJlX29wICYgMTU7XG4gICAgICBzdGF0ZS5tb2RlID0gTEVORVhUO1xuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgIGNhc2UgTEVORVhUOlxuICAgICAgaWYgKHN0YXRlLmV4dHJhKSB7XG4gICAgICAgIC8vPT09IE5FRURCSVRTKHN0YXRlLmV4dHJhKTtcbiAgICAgICAgbiA9IHN0YXRlLmV4dHJhO1xuICAgICAgICB3aGlsZSAoYml0cyA8IG4pIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgc3RhdGUubGVuZ3RoICs9IGhvbGQgJiAoKDEgPDwgc3RhdGUuZXh0cmEpIC0gMSkvKkJJVFMoc3RhdGUuZXh0cmEpKi87XG4gICAgICAgIC8vLS0tIERST1BCSVRTKHN0YXRlLmV4dHJhKSAtLS0vL1xuICAgICAgICBob2xkID4+Pj0gc3RhdGUuZXh0cmE7XG4gICAgICAgIGJpdHMgLT0gc3RhdGUuZXh0cmE7XG4gICAgICAgIC8vLS0tLy9cbiAgICAgICAgc3RhdGUuYmFjayArPSBzdGF0ZS5leHRyYTtcbiAgICAgIH1cbiAgICAgIC8vVHJhY2V2digoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgICAgbGVuZ3RoICV1XFxuXCIsIHN0YXRlLmxlbmd0aCkpO1xuICAgICAgc3RhdGUud2FzID0gc3RhdGUubGVuZ3RoO1xuICAgICAgc3RhdGUubW9kZSA9IERJU1Q7XG4gICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgY2FzZSBESVNUOlxuICAgICAgZm9yICg7Oykge1xuICAgICAgICBoZXJlID0gc3RhdGUuZGlzdGNvZGVbaG9sZCAmICgoMSA8PCBzdGF0ZS5kaXN0Yml0cykgLSAxKV07LypCSVRTKHN0YXRlLmRpc3RiaXRzKSovXG4gICAgICAgIGhlcmVfYml0cyA9IGhlcmUgPj4+IDI0O1xuICAgICAgICBoZXJlX29wID0gKGhlcmUgPj4+IDE2KSAmIDB4ZmY7XG4gICAgICAgIGhlcmVfdmFsID0gaGVyZSAmIDB4ZmZmZjtcblxuICAgICAgICBpZiAoKGhlcmVfYml0cykgPD0gYml0cykgeyBicmVhazsgfVxuICAgICAgICAvLy0tLSBQVUxMQllURSgpIC0tLS8vXG4gICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICBoYXZlLS07XG4gICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgIC8vLS0tLy9cbiAgICAgIH1cbiAgICAgIGlmICgoaGVyZV9vcCAmIDB4ZjApID09PSAwKSB7XG4gICAgICAgIGxhc3RfYml0cyA9IGhlcmVfYml0cztcbiAgICAgICAgbGFzdF9vcCA9IGhlcmVfb3A7XG4gICAgICAgIGxhc3RfdmFsID0gaGVyZV92YWw7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICBoZXJlID0gc3RhdGUuZGlzdGNvZGVbbGFzdF92YWwgK1xuICAgICAgICAgICAgICAgICAgKChob2xkICYgKCgxIDw8IChsYXN0X2JpdHMgKyBsYXN0X29wKSkgLSAxKSkvKkJJVFMobGFzdC5iaXRzICsgbGFzdC5vcCkqLyA+PiBsYXN0X2JpdHMpXTtcbiAgICAgICAgICBoZXJlX2JpdHMgPSBoZXJlID4+PiAyNDtcbiAgICAgICAgICBoZXJlX29wID0gKGhlcmUgPj4+IDE2KSAmIDB4ZmY7XG4gICAgICAgICAgaGVyZV92YWwgPSBoZXJlICYgMHhmZmZmO1xuXG4gICAgICAgICAgaWYgKChsYXN0X2JpdHMgKyBoZXJlX2JpdHMpIDw9IGJpdHMpIHsgYnJlYWs7IH1cbiAgICAgICAgICAvLy0tLSBQVUxMQllURSgpIC0tLS8vXG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAvLy0tLS8vXG4gICAgICAgIH1cbiAgICAgICAgLy8tLS0gRFJPUEJJVFMobGFzdC5iaXRzKSAtLS0vL1xuICAgICAgICBob2xkID4+Pj0gbGFzdF9iaXRzO1xuICAgICAgICBiaXRzIC09IGxhc3RfYml0cztcbiAgICAgICAgLy8tLS0vL1xuICAgICAgICBzdGF0ZS5iYWNrICs9IGxhc3RfYml0cztcbiAgICAgIH1cbiAgICAgIC8vLS0tIERST1BCSVRTKGhlcmUuYml0cykgLS0tLy9cbiAgICAgIGhvbGQgPj4+PSBoZXJlX2JpdHM7XG4gICAgICBiaXRzIC09IGhlcmVfYml0cztcbiAgICAgIC8vLS0tLy9cbiAgICAgIHN0YXRlLmJhY2sgKz0gaGVyZV9iaXRzO1xuICAgICAgaWYgKGhlcmVfb3AgJiA2NCkge1xuICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGRpc3RhbmNlIGNvZGUnO1xuICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHN0YXRlLm9mZnNldCA9IGhlcmVfdmFsO1xuICAgICAgc3RhdGUuZXh0cmEgPSAoaGVyZV9vcCkgJiAxNTtcbiAgICAgIHN0YXRlLm1vZGUgPSBESVNURVhUO1xuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgIGNhc2UgRElTVEVYVDpcbiAgICAgIGlmIChzdGF0ZS5leHRyYSkge1xuICAgICAgICAvLz09PSBORUVEQklUUyhzdGF0ZS5leHRyYSk7XG4gICAgICAgIG4gPSBzdGF0ZS5leHRyYTtcbiAgICAgICAgd2hpbGUgKGJpdHMgPCBuKSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgfVxuICAgICAgICAvLz09PS8vXG4gICAgICAgIHN0YXRlLm9mZnNldCArPSBob2xkICYgKCgxIDw8IHN0YXRlLmV4dHJhKSAtIDEpLypCSVRTKHN0YXRlLmV4dHJhKSovO1xuICAgICAgICAvLy0tLSBEUk9QQklUUyhzdGF0ZS5leHRyYSkgLS0tLy9cbiAgICAgICAgaG9sZCA+Pj49IHN0YXRlLmV4dHJhO1xuICAgICAgICBiaXRzIC09IHN0YXRlLmV4dHJhO1xuICAgICAgICAvLy0tLS8vXG4gICAgICAgIHN0YXRlLmJhY2sgKz0gc3RhdGUuZXh0cmE7XG4gICAgICB9XG4vLyNpZmRlZiBJTkZMQVRFX1NUUklDVFxuICAgICAgaWYgKHN0YXRlLm9mZnNldCA+IHN0YXRlLmRtYXgpIHtcbiAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBkaXN0YW5jZSB0b28gZmFyIGJhY2snO1xuICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbi8vI2VuZGlmXG4gICAgICAvL1RyYWNldnYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICAgIGRpc3RhbmNlICV1XFxuXCIsIHN0YXRlLm9mZnNldCkpO1xuICAgICAgc3RhdGUubW9kZSA9IE1BVENIO1xuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgIGNhc2UgTUFUQ0g6XG4gICAgICBpZiAobGVmdCA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgIGNvcHkgPSBfb3V0IC0gbGVmdDtcbiAgICAgIGlmIChzdGF0ZS5vZmZzZXQgPiBjb3B5KSB7ICAgICAgICAgLyogY29weSBmcm9tIHdpbmRvdyAqL1xuICAgICAgICBjb3B5ID0gc3RhdGUub2Zmc2V0IC0gY29weTtcbiAgICAgICAgaWYgKGNvcHkgPiBzdGF0ZS53aGF2ZSkge1xuICAgICAgICAgIGlmIChzdGF0ZS5zYW5lKSB7XG4gICAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGRpc3RhbmNlIHRvbyBmYXIgYmFjayc7XG4gICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuLy8gKCEpIFRoaXMgYmxvY2sgaXMgZGlzYWJsZWQgaW4gemxpYiBkZWZhaWx0cyxcbi8vIGRvbid0IGVuYWJsZSBpdCBmb3IgYmluYXJ5IGNvbXBhdGliaWxpdHlcbi8vI2lmZGVmIElORkxBVEVfQUxMT1dfSU5WQUxJRF9ESVNUQU5DRV9UT09GQVJfQVJSUlxuLy8gICAgICAgICAgVHJhY2UoKHN0ZGVyciwgXCJpbmZsYXRlLmMgdG9vIGZhclxcblwiKSk7XG4vLyAgICAgICAgICBjb3B5IC09IHN0YXRlLndoYXZlO1xuLy8gICAgICAgICAgaWYgKGNvcHkgPiBzdGF0ZS5sZW5ndGgpIHsgY29weSA9IHN0YXRlLmxlbmd0aDsgfVxuLy8gICAgICAgICAgaWYgKGNvcHkgPiBsZWZ0KSB7IGNvcHkgPSBsZWZ0OyB9XG4vLyAgICAgICAgICBsZWZ0IC09IGNvcHk7XG4vLyAgICAgICAgICBzdGF0ZS5sZW5ndGggLT0gY29weTtcbi8vICAgICAgICAgIGRvIHtcbi8vICAgICAgICAgICAgb3V0cHV0W3B1dCsrXSA9IDA7XG4vLyAgICAgICAgICB9IHdoaWxlICgtLWNvcHkpO1xuLy8gICAgICAgICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgeyBzdGF0ZS5tb2RlID0gTEVOOyB9XG4vLyAgICAgICAgICBicmVhaztcbi8vI2VuZGlmXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvcHkgPiBzdGF0ZS53bmV4dCkge1xuICAgICAgICAgIGNvcHkgLT0gc3RhdGUud25leHQ7XG4gICAgICAgICAgZnJvbSA9IHN0YXRlLndzaXplIC0gY29weTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBmcm9tID0gc3RhdGUud25leHQgLSBjb3B5O1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb3B5ID4gc3RhdGUubGVuZ3RoKSB7IGNvcHkgPSBzdGF0ZS5sZW5ndGg7IH1cbiAgICAgICAgZnJvbV9zb3VyY2UgPSBzdGF0ZS53aW5kb3c7XG4gICAgICB9XG4gICAgICBlbHNlIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBjb3B5IGZyb20gb3V0cHV0ICovXG4gICAgICAgIGZyb21fc291cmNlID0gb3V0cHV0O1xuICAgICAgICBmcm9tID0gcHV0IC0gc3RhdGUub2Zmc2V0O1xuICAgICAgICBjb3B5ID0gc3RhdGUubGVuZ3RoO1xuICAgICAgfVxuICAgICAgaWYgKGNvcHkgPiBsZWZ0KSB7IGNvcHkgPSBsZWZ0OyB9XG4gICAgICBsZWZ0IC09IGNvcHk7XG4gICAgICBzdGF0ZS5sZW5ndGggLT0gY29weTtcbiAgICAgIGRvIHtcbiAgICAgICAgb3V0cHV0W3B1dCsrXSA9IGZyb21fc291cmNlW2Zyb20rK107XG4gICAgICB9IHdoaWxlICgtLWNvcHkpO1xuICAgICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgeyBzdGF0ZS5tb2RlID0gTEVOOyB9XG4gICAgICBicmVhaztcbiAgICBjYXNlIExJVDpcbiAgICAgIGlmIChsZWZ0ID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgb3V0cHV0W3B1dCsrXSA9IHN0YXRlLmxlbmd0aDtcbiAgICAgIGxlZnQtLTtcbiAgICAgIHN0YXRlLm1vZGUgPSBMRU47XG4gICAgICBicmVhaztcbiAgICBjYXNlIENIRUNLOlxuICAgICAgaWYgKHN0YXRlLndyYXApIHtcbiAgICAgICAgLy89PT0gTkVFREJJVFMoMzIpO1xuICAgICAgICB3aGlsZSAoYml0cyA8IDMyKSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIC8vIFVzZSAnfCcgaW5zZGVhZCBvZiAnKycgdG8gbWFrZSBzdXJlIHRoYXQgcmVzdWx0IGlzIHNpZ25lZFxuICAgICAgICAgIGhvbGQgfD0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgfVxuICAgICAgICAvLz09PS8vXG4gICAgICAgIF9vdXQgLT0gbGVmdDtcbiAgICAgICAgc3RybS50b3RhbF9vdXQgKz0gX291dDtcbiAgICAgICAgc3RhdGUudG90YWwgKz0gX291dDtcbiAgICAgICAgaWYgKF9vdXQpIHtcbiAgICAgICAgICBzdHJtLmFkbGVyID0gc3RhdGUuY2hlY2sgPVxuICAgICAgICAgICAgICAvKlVQREFURShzdGF0ZS5jaGVjaywgcHV0IC0gX291dCwgX291dCk7Ki9cbiAgICAgICAgICAgICAgKHN0YXRlLmZsYWdzID8gY3JjMzIoc3RhdGUuY2hlY2ssIG91dHB1dCwgX291dCwgcHV0IC0gX291dCkgOiBhZGxlcjMyKHN0YXRlLmNoZWNrLCBvdXRwdXQsIF9vdXQsIHB1dCAtIF9vdXQpKTtcblxuICAgICAgICB9XG4gICAgICAgIF9vdXQgPSBsZWZ0O1xuICAgICAgICAvLyBOQjogY3JjMzIgc3RvcmVkIGFzIHNpZ25lZCAzMi1iaXQgaW50LCB6c3dhcDMyIHJldHVybnMgc2lnbmVkIHRvb1xuICAgICAgICBpZiAoKHN0YXRlLmZsYWdzID8gaG9sZCA6IHpzd2FwMzIoaG9sZCkpICE9PSBzdGF0ZS5jaGVjaykge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ2luY29ycmVjdCBkYXRhIGNoZWNrJztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgIGhvbGQgPSAwO1xuICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgLy89PT0vL1xuICAgICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgY2hlY2sgbWF0Y2hlcyB0cmFpbGVyXFxuXCIpKTtcbiAgICAgIH1cbiAgICAgIHN0YXRlLm1vZGUgPSBMRU5HVEg7XG4gICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgY2FzZSBMRU5HVEg6XG4gICAgICBpZiAoc3RhdGUud3JhcCAmJiBzdGF0ZS5mbGFncykge1xuICAgICAgICAvLz09PSBORUVEQklUUygzMik7XG4gICAgICAgIHdoaWxlIChiaXRzIDwgMzIpIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgaWYgKGhvbGQgIT09IChzdGF0ZS50b3RhbCAmIDB4ZmZmZmZmZmYpKSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAnaW5jb3JyZWN0IGxlbmd0aCBjaGVjayc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICBob2xkID0gMDtcbiAgICAgICAgYml0cyA9IDA7XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgIGxlbmd0aCBtYXRjaGVzIHRyYWlsZXJcXG5cIikpO1xuICAgICAgfVxuICAgICAgc3RhdGUubW9kZSA9IERPTkU7XG4gICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgY2FzZSBET05FOlxuICAgICAgcmV0ID0gWl9TVFJFQU1fRU5EO1xuICAgICAgYnJlYWsgaW5mX2xlYXZlO1xuICAgIGNhc2UgQkFEOlxuICAgICAgcmV0ID0gWl9EQVRBX0VSUk9SO1xuICAgICAgYnJlYWsgaW5mX2xlYXZlO1xuICAgIGNhc2UgTUVNOlxuICAgICAgcmV0dXJuIFpfTUVNX0VSUk9SO1xuICAgIGNhc2UgU1lOQzpcbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICAgIH1cbiAgfVxuXG4gIC8vIGluZl9sZWF2ZSA8LSBoZXJlIGlzIHJlYWwgcGxhY2UgZm9yIFwiZ290byBpbmZfbGVhdmVcIiwgZW11bGF0ZWQgdmlhIFwiYnJlYWsgaW5mX2xlYXZlXCJcblxuICAvKlxuICAgICBSZXR1cm4gZnJvbSBpbmZsYXRlKCksIHVwZGF0aW5nIHRoZSB0b3RhbCBjb3VudHMgYW5kIHRoZSBjaGVjayB2YWx1ZS5cbiAgICAgSWYgdGhlcmUgd2FzIG5vIHByb2dyZXNzIGR1cmluZyB0aGUgaW5mbGF0ZSgpIGNhbGwsIHJldHVybiBhIGJ1ZmZlclxuICAgICBlcnJvci4gIENhbGwgdXBkYXRld2luZG93KCkgdG8gY3JlYXRlIGFuZC9vciB1cGRhdGUgdGhlIHdpbmRvdyBzdGF0ZS5cbiAgICAgTm90ZTogYSBtZW1vcnkgZXJyb3IgZnJvbSBpbmZsYXRlKCkgaXMgbm9uLXJlY292ZXJhYmxlLlxuICAgKi9cblxuICAvLy0tLSBSRVNUT1JFKCkgLS0tXG4gIHN0cm0ubmV4dF9vdXQgPSBwdXQ7XG4gIHN0cm0uYXZhaWxfb3V0ID0gbGVmdDtcbiAgc3RybS5uZXh0X2luID0gbmV4dDtcbiAgc3RybS5hdmFpbF9pbiA9IGhhdmU7XG4gIHN0YXRlLmhvbGQgPSBob2xkO1xuICBzdGF0ZS5iaXRzID0gYml0cztcbiAgLy8tLS1cblxuICBpZiAoc3RhdGUud3NpemUgfHwgKF9vdXQgIT09IHN0cm0uYXZhaWxfb3V0ICYmIHN0YXRlLm1vZGUgPCBCQUQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAoc3RhdGUubW9kZSA8IENIRUNLIHx8IGZsdXNoICE9PSBaX0ZJTklTSCkpKSB7XG4gICAgaWYgKHVwZGF0ZXdpbmRvdyhzdHJtLCBzdHJtLm91dHB1dCwgc3RybS5uZXh0X291dCwgX291dCAtIHN0cm0uYXZhaWxfb3V0KSkge1xuICAgICAgc3RhdGUubW9kZSA9IE1FTTtcbiAgICAgIHJldHVybiBaX01FTV9FUlJPUjtcbiAgICB9XG4gIH1cbiAgX2luIC09IHN0cm0uYXZhaWxfaW47XG4gIF9vdXQgLT0gc3RybS5hdmFpbF9vdXQ7XG4gIHN0cm0udG90YWxfaW4gKz0gX2luO1xuICBzdHJtLnRvdGFsX291dCArPSBfb3V0O1xuICBzdGF0ZS50b3RhbCArPSBfb3V0O1xuICBpZiAoc3RhdGUud3JhcCAmJiBfb3V0KSB7XG4gICAgc3RybS5hZGxlciA9IHN0YXRlLmNoZWNrID0gLypVUERBVEUoc3RhdGUuY2hlY2ssIHN0cm0ubmV4dF9vdXQgLSBfb3V0LCBfb3V0KTsqL1xuICAgICAgKHN0YXRlLmZsYWdzID8gY3JjMzIoc3RhdGUuY2hlY2ssIG91dHB1dCwgX291dCwgc3RybS5uZXh0X291dCAtIF9vdXQpIDogYWRsZXIzMihzdGF0ZS5jaGVjaywgb3V0cHV0LCBfb3V0LCBzdHJtLm5leHRfb3V0IC0gX291dCkpO1xuICB9XG4gIHN0cm0uZGF0YV90eXBlID0gc3RhdGUuYml0cyArIChzdGF0ZS5sYXN0ID8gNjQgOiAwKSArXG4gICAgICAgICAgICAgICAgICAgIChzdGF0ZS5tb2RlID09PSBUWVBFID8gMTI4IDogMCkgK1xuICAgICAgICAgICAgICAgICAgICAoc3RhdGUubW9kZSA9PT0gTEVOXyB8fCBzdGF0ZS5tb2RlID09PSBDT1BZXyA/IDI1NiA6IDApO1xuICBpZiAoKChfaW4gPT09IDAgJiYgX291dCA9PT0gMCkgfHwgZmx1c2ggPT09IFpfRklOSVNIKSAmJiByZXQgPT09IFpfT0spIHtcbiAgICByZXQgPSBaX0JVRl9FUlJPUjtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBpbmZsYXRlRW5kKHN0cm0pIHtcblxuICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUgLyp8fCBzdHJtLT56ZnJlZSA9PSAoZnJlZV9mdW5jKTAqLykge1xuICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgfVxuXG4gIHZhciBzdGF0ZSA9IHN0cm0uc3RhdGU7XG4gIGlmIChzdGF0ZS53aW5kb3cpIHtcbiAgICBzdGF0ZS53aW5kb3cgPSBudWxsO1xuICB9XG4gIHN0cm0uc3RhdGUgPSBudWxsO1xuICByZXR1cm4gWl9PSztcbn1cblxuZnVuY3Rpb24gaW5mbGF0ZUdldEhlYWRlcihzdHJtLCBoZWFkKSB7XG4gIHZhciBzdGF0ZTtcblxuICAvKiBjaGVjayBzdGF0ZSAqL1xuICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUpIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOyB9XG4gIHN0YXRlID0gc3RybS5zdGF0ZTtcbiAgaWYgKChzdGF0ZS53cmFwICYgMikgPT09IDApIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOyB9XG5cbiAgLyogc2F2ZSBoZWFkZXIgc3RydWN0dXJlICovXG4gIHN0YXRlLmhlYWQgPSBoZWFkO1xuICBoZWFkLmRvbmUgPSBmYWxzZTtcbiAgcmV0dXJuIFpfT0s7XG59XG5cbmZ1bmN0aW9uIGluZmxhdGVTZXREaWN0aW9uYXJ5KHN0cm0sIGRpY3Rpb25hcnkpIHtcbiAgdmFyIGRpY3RMZW5ndGggPSBkaWN0aW9uYXJ5Lmxlbmd0aDtcblxuICB2YXIgc3RhdGU7XG4gIHZhciBkaWN0aWQ7XG4gIHZhciByZXQ7XG5cbiAgLyogY2hlY2sgc3RhdGUgKi9cbiAgaWYgKCFzdHJtIC8qID09IFpfTlVMTCAqLyB8fCAhc3RybS5zdGF0ZSAvKiA9PSBaX05VTEwgKi8pIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOyB9XG4gIHN0YXRlID0gc3RybS5zdGF0ZTtcblxuICBpZiAoc3RhdGUud3JhcCAhPT0gMCAmJiBzdGF0ZS5tb2RlICE9PSBESUNUKSB7XG4gICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICB9XG5cbiAgLyogY2hlY2sgZm9yIGNvcnJlY3QgZGljdGlvbmFyeSBpZGVudGlmaWVyICovXG4gIGlmIChzdGF0ZS5tb2RlID09PSBESUNUKSB7XG4gICAgZGljdGlkID0gMTsgLyogYWRsZXIzMigwLCBudWxsLCAwKSovXG4gICAgLyogZGljdGlkID0gYWRsZXIzMihkaWN0aWQsIGRpY3Rpb25hcnksIGRpY3RMZW5ndGgpOyAqL1xuICAgIGRpY3RpZCA9IGFkbGVyMzIoZGljdGlkLCBkaWN0aW9uYXJ5LCBkaWN0TGVuZ3RoLCAwKTtcbiAgICBpZiAoZGljdGlkICE9PSBzdGF0ZS5jaGVjaykge1xuICAgICAgcmV0dXJuIFpfREFUQV9FUlJPUjtcbiAgICB9XG4gIH1cbiAgLyogY29weSBkaWN0aW9uYXJ5IHRvIHdpbmRvdyB1c2luZyB1cGRhdGV3aW5kb3coKSwgd2hpY2ggd2lsbCBhbWVuZCB0aGVcbiAgIGV4aXN0aW5nIGRpY3Rpb25hcnkgaWYgYXBwcm9wcmlhdGUgKi9cbiAgcmV0ID0gdXBkYXRld2luZG93KHN0cm0sIGRpY3Rpb25hcnksIGRpY3RMZW5ndGgsIGRpY3RMZW5ndGgpO1xuICBpZiAocmV0KSB7XG4gICAgc3RhdGUubW9kZSA9IE1FTTtcbiAgICByZXR1cm4gWl9NRU1fRVJST1I7XG4gIH1cbiAgc3RhdGUuaGF2ZWRpY3QgPSAxO1xuICAvLyBUcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgIGRpY3Rpb25hcnkgc2V0XFxuXCIpKTtcbiAgcmV0dXJuIFpfT0s7XG59XG5cbmV4cG9ydHMuaW5mbGF0ZVJlc2V0ID0gaW5mbGF0ZVJlc2V0O1xuZXhwb3J0cy5pbmZsYXRlUmVzZXQyID0gaW5mbGF0ZVJlc2V0MjtcbmV4cG9ydHMuaW5mbGF0ZVJlc2V0S2VlcCA9IGluZmxhdGVSZXNldEtlZXA7XG5leHBvcnRzLmluZmxhdGVJbml0ID0gaW5mbGF0ZUluaXQ7XG5leHBvcnRzLmluZmxhdGVJbml0MiA9IGluZmxhdGVJbml0MjtcbmV4cG9ydHMuaW5mbGF0ZSA9IGluZmxhdGU7XG5leHBvcnRzLmluZmxhdGVFbmQgPSBpbmZsYXRlRW5kO1xuZXhwb3J0cy5pbmZsYXRlR2V0SGVhZGVyID0gaW5mbGF0ZUdldEhlYWRlcjtcbmV4cG9ydHMuaW5mbGF0ZVNldERpY3Rpb25hcnkgPSBpbmZsYXRlU2V0RGljdGlvbmFyeTtcbmV4cG9ydHMuaW5mbGF0ZUluZm8gPSAncGFrbyBpbmZsYXRlIChmcm9tIE5vZGVjYSBwcm9qZWN0KSc7XG5cbi8qIE5vdCBpbXBsZW1lbnRlZFxuZXhwb3J0cy5pbmZsYXRlQ29weSA9IGluZmxhdGVDb3B5O1xuZXhwb3J0cy5pbmZsYXRlR2V0RGljdGlvbmFyeSA9IGluZmxhdGVHZXREaWN0aW9uYXJ5O1xuZXhwb3J0cy5pbmZsYXRlTWFyayA9IGluZmxhdGVNYXJrO1xuZXhwb3J0cy5pbmZsYXRlUHJpbWUgPSBpbmZsYXRlUHJpbWU7XG5leHBvcnRzLmluZmxhdGVTeW5jID0gaW5mbGF0ZVN5bmM7XG5leHBvcnRzLmluZmxhdGVTeW5jUG9pbnQgPSBpbmZsYXRlU3luY1BvaW50O1xuZXhwb3J0cy5pbmZsYXRlVW5kZXJtaW5lID0gaW5mbGF0ZVVuZGVybWluZTtcbiovXG4iLCIndXNlIHN0cmljdCc7XG5cblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMvY29tbW9uJyk7XG5cbnZhciBNQVhCSVRTID0gMTU7XG52YXIgRU5PVUdIX0xFTlMgPSA4NTI7XG52YXIgRU5PVUdIX0RJU1RTID0gNTkyO1xuLy92YXIgRU5PVUdIID0gKEVOT1VHSF9MRU5TK0VOT1VHSF9ESVNUUyk7XG5cbnZhciBDT0RFUyA9IDA7XG52YXIgTEVOUyA9IDE7XG52YXIgRElTVFMgPSAyO1xuXG52YXIgbGJhc2UgPSBbIC8qIExlbmd0aCBjb2RlcyAyNTcuLjI4NSBiYXNlICovXG4gIDMsIDQsIDUsIDYsIDcsIDgsIDksIDEwLCAxMSwgMTMsIDE1LCAxNywgMTksIDIzLCAyNywgMzEsXG4gIDM1LCA0MywgNTEsIDU5LCA2NywgODMsIDk5LCAxMTUsIDEzMSwgMTYzLCAxOTUsIDIyNywgMjU4LCAwLCAwXG5dO1xuXG52YXIgbGV4dCA9IFsgLyogTGVuZ3RoIGNvZGVzIDI1Ny4uMjg1IGV4dHJhICovXG4gIDE2LCAxNiwgMTYsIDE2LCAxNiwgMTYsIDE2LCAxNiwgMTcsIDE3LCAxNywgMTcsIDE4LCAxOCwgMTgsIDE4LFxuICAxOSwgMTksIDE5LCAxOSwgMjAsIDIwLCAyMCwgMjAsIDIxLCAyMSwgMjEsIDIxLCAxNiwgNzIsIDc4XG5dO1xuXG52YXIgZGJhc2UgPSBbIC8qIERpc3RhbmNlIGNvZGVzIDAuLjI5IGJhc2UgKi9cbiAgMSwgMiwgMywgNCwgNSwgNywgOSwgMTMsIDE3LCAyNSwgMzMsIDQ5LCA2NSwgOTcsIDEyOSwgMTkzLFxuICAyNTcsIDM4NSwgNTEzLCA3NjksIDEwMjUsIDE1MzcsIDIwNDksIDMwNzMsIDQwOTcsIDYxNDUsXG4gIDgxOTMsIDEyMjg5LCAxNjM4NSwgMjQ1NzcsIDAsIDBcbl07XG5cbnZhciBkZXh0ID0gWyAvKiBEaXN0YW5jZSBjb2RlcyAwLi4yOSBleHRyYSAqL1xuICAxNiwgMTYsIDE2LCAxNiwgMTcsIDE3LCAxOCwgMTgsIDE5LCAxOSwgMjAsIDIwLCAyMSwgMjEsIDIyLCAyMixcbiAgMjMsIDIzLCAyNCwgMjQsIDI1LCAyNSwgMjYsIDI2LCAyNywgMjcsXG4gIDI4LCAyOCwgMjksIDI5LCA2NCwgNjRcbl07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5mbGF0ZV90YWJsZSh0eXBlLCBsZW5zLCBsZW5zX2luZGV4LCBjb2RlcywgdGFibGUsIHRhYmxlX2luZGV4LCB3b3JrLCBvcHRzKVxue1xuICB2YXIgYml0cyA9IG9wdHMuYml0cztcbiAgICAgIC8vaGVyZSA9IG9wdHMuaGVyZTsgLyogdGFibGUgZW50cnkgZm9yIGR1cGxpY2F0aW9uICovXG5cbiAgdmFyIGxlbiA9IDA7ICAgICAgICAgICAgICAgLyogYSBjb2RlJ3MgbGVuZ3RoIGluIGJpdHMgKi9cbiAgdmFyIHN5bSA9IDA7ICAgICAgICAgICAgICAgLyogaW5kZXggb2YgY29kZSBzeW1ib2xzICovXG4gIHZhciBtaW4gPSAwLCBtYXggPSAwOyAgICAgICAgICAvKiBtaW5pbXVtIGFuZCBtYXhpbXVtIGNvZGUgbGVuZ3RocyAqL1xuICB2YXIgcm9vdCA9IDA7ICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgaW5kZXggYml0cyBmb3Igcm9vdCB0YWJsZSAqL1xuICB2YXIgY3VyciA9IDA7ICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgaW5kZXggYml0cyBmb3IgY3VycmVudCB0YWJsZSAqL1xuICB2YXIgZHJvcCA9IDA7ICAgICAgICAgICAgICAvKiBjb2RlIGJpdHMgdG8gZHJvcCBmb3Igc3ViLXRhYmxlICovXG4gIHZhciBsZWZ0ID0gMDsgICAgICAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIHByZWZpeCBjb2RlcyBhdmFpbGFibGUgKi9cbiAgdmFyIHVzZWQgPSAwOyAgICAgICAgICAgICAgLyogY29kZSBlbnRyaWVzIGluIHRhYmxlIHVzZWQgKi9cbiAgdmFyIGh1ZmYgPSAwOyAgICAgICAgICAgICAgLyogSHVmZm1hbiBjb2RlICovXG4gIHZhciBpbmNyOyAgICAgICAgICAgICAgLyogZm9yIGluY3JlbWVudGluZyBjb2RlLCBpbmRleCAqL1xuICB2YXIgZmlsbDsgICAgICAgICAgICAgIC8qIGluZGV4IGZvciByZXBsaWNhdGluZyBlbnRyaWVzICovXG4gIHZhciBsb3c7ICAgICAgICAgICAgICAgLyogbG93IGJpdHMgZm9yIGN1cnJlbnQgcm9vdCBlbnRyeSAqL1xuICB2YXIgbWFzazsgICAgICAgICAgICAgIC8qIG1hc2sgZm9yIGxvdyByb290IGJpdHMgKi9cbiAgdmFyIG5leHQ7ICAgICAgICAgICAgIC8qIG5leHQgYXZhaWxhYmxlIHNwYWNlIGluIHRhYmxlICovXG4gIHZhciBiYXNlID0gbnVsbDsgICAgIC8qIGJhc2UgdmFsdWUgdGFibGUgdG8gdXNlICovXG4gIHZhciBiYXNlX2luZGV4ID0gMDtcbi8vICB2YXIgc2hvZXh0cmE7ICAgIC8qIGV4dHJhIGJpdHMgdGFibGUgdG8gdXNlICovXG4gIHZhciBlbmQ7ICAgICAgICAgICAgICAgICAgICAvKiB1c2UgYmFzZSBhbmQgZXh0cmEgZm9yIHN5bWJvbCA+IGVuZCAqL1xuICB2YXIgY291bnQgPSBuZXcgdXRpbHMuQnVmMTYoTUFYQklUUyArIDEpOyAvL1tNQVhCSVRTKzFdOyAgICAvKiBudW1iZXIgb2YgY29kZXMgb2YgZWFjaCBsZW5ndGggKi9cbiAgdmFyIG9mZnMgPSBuZXcgdXRpbHMuQnVmMTYoTUFYQklUUyArIDEpOyAvL1tNQVhCSVRTKzFdOyAgICAgLyogb2Zmc2V0cyBpbiB0YWJsZSBmb3IgZWFjaCBsZW5ndGggKi9cbiAgdmFyIGV4dHJhID0gbnVsbDtcbiAgdmFyIGV4dHJhX2luZGV4ID0gMDtcblxuICB2YXIgaGVyZV9iaXRzLCBoZXJlX29wLCBoZXJlX3ZhbDtcblxuICAvKlxuICAgUHJvY2VzcyBhIHNldCBvZiBjb2RlIGxlbmd0aHMgdG8gY3JlYXRlIGEgY2Fub25pY2FsIEh1ZmZtYW4gY29kZS4gIFRoZVxuICAgY29kZSBsZW5ndGhzIGFyZSBsZW5zWzAuLmNvZGVzLTFdLiAgRWFjaCBsZW5ndGggY29ycmVzcG9uZHMgdG8gdGhlXG4gICBzeW1ib2xzIDAuLmNvZGVzLTEuICBUaGUgSHVmZm1hbiBjb2RlIGlzIGdlbmVyYXRlZCBieSBmaXJzdCBzb3J0aW5nIHRoZVxuICAgc3ltYm9scyBieSBsZW5ndGggZnJvbSBzaG9ydCB0byBsb25nLCBhbmQgcmV0YWluaW5nIHRoZSBzeW1ib2wgb3JkZXJcbiAgIGZvciBjb2RlcyB3aXRoIGVxdWFsIGxlbmd0aHMuICBUaGVuIHRoZSBjb2RlIHN0YXJ0cyB3aXRoIGFsbCB6ZXJvIGJpdHNcbiAgIGZvciB0aGUgZmlyc3QgY29kZSBvZiB0aGUgc2hvcnRlc3QgbGVuZ3RoLCBhbmQgdGhlIGNvZGVzIGFyZSBpbnRlZ2VyXG4gICBpbmNyZW1lbnRzIGZvciB0aGUgc2FtZSBsZW5ndGgsIGFuZCB6ZXJvcyBhcmUgYXBwZW5kZWQgYXMgdGhlIGxlbmd0aFxuICAgaW5jcmVhc2VzLiAgRm9yIHRoZSBkZWZsYXRlIGZvcm1hdCwgdGhlc2UgYml0cyBhcmUgc3RvcmVkIGJhY2t3YXJkc1xuICAgZnJvbSB0aGVpciBtb3JlIG5hdHVyYWwgaW50ZWdlciBpbmNyZW1lbnQgb3JkZXJpbmcsIGFuZCBzbyB3aGVuIHRoZVxuICAgZGVjb2RpbmcgdGFibGVzIGFyZSBidWlsdCBpbiB0aGUgbGFyZ2UgbG9vcCBiZWxvdywgdGhlIGludGVnZXIgY29kZXNcbiAgIGFyZSBpbmNyZW1lbnRlZCBiYWNrd2FyZHMuXG5cbiAgIFRoaXMgcm91dGluZSBhc3N1bWVzLCBidXQgZG9lcyBub3QgY2hlY2ssIHRoYXQgYWxsIG9mIHRoZSBlbnRyaWVzIGluXG4gICBsZW5zW10gYXJlIGluIHRoZSByYW5nZSAwLi5NQVhCSVRTLiAgVGhlIGNhbGxlciBtdXN0IGFzc3VyZSB0aGlzLlxuICAgMS4uTUFYQklUUyBpcyBpbnRlcnByZXRlZCBhcyB0aGF0IGNvZGUgbGVuZ3RoLiAgemVybyBtZWFucyB0aGF0IHRoYXRcbiAgIHN5bWJvbCBkb2VzIG5vdCBvY2N1ciBpbiB0aGlzIGNvZGUuXG5cbiAgIFRoZSBjb2RlcyBhcmUgc29ydGVkIGJ5IGNvbXB1dGluZyBhIGNvdW50IG9mIGNvZGVzIGZvciBlYWNoIGxlbmd0aCxcbiAgIGNyZWF0aW5nIGZyb20gdGhhdCBhIHRhYmxlIG9mIHN0YXJ0aW5nIGluZGljZXMgZm9yIGVhY2ggbGVuZ3RoIGluIHRoZVxuICAgc29ydGVkIHRhYmxlLCBhbmQgdGhlbiBlbnRlcmluZyB0aGUgc3ltYm9scyBpbiBvcmRlciBpbiB0aGUgc29ydGVkXG4gICB0YWJsZS4gIFRoZSBzb3J0ZWQgdGFibGUgaXMgd29ya1tdLCB3aXRoIHRoYXQgc3BhY2UgYmVpbmcgcHJvdmlkZWQgYnlcbiAgIHRoZSBjYWxsZXIuXG5cbiAgIFRoZSBsZW5ndGggY291bnRzIGFyZSB1c2VkIGZvciBvdGhlciBwdXJwb3NlcyBhcyB3ZWxsLCBpLmUuIGZpbmRpbmdcbiAgIHRoZSBtaW5pbXVtIGFuZCBtYXhpbXVtIGxlbmd0aCBjb2RlcywgZGV0ZXJtaW5pbmcgaWYgdGhlcmUgYXJlIGFueVxuICAgY29kZXMgYXQgYWxsLCBjaGVja2luZyBmb3IgYSB2YWxpZCBzZXQgb2YgbGVuZ3RocywgYW5kIGxvb2tpbmcgYWhlYWRcbiAgIGF0IGxlbmd0aCBjb3VudHMgdG8gZGV0ZXJtaW5lIHN1Yi10YWJsZSBzaXplcyB3aGVuIGJ1aWxkaW5nIHRoZVxuICAgZGVjb2RpbmcgdGFibGVzLlxuICAgKi9cblxuICAvKiBhY2N1bXVsYXRlIGxlbmd0aHMgZm9yIGNvZGVzIChhc3N1bWVzIGxlbnNbXSBhbGwgaW4gMC4uTUFYQklUUykgKi9cbiAgZm9yIChsZW4gPSAwOyBsZW4gPD0gTUFYQklUUzsgbGVuKyspIHtcbiAgICBjb3VudFtsZW5dID0gMDtcbiAgfVxuICBmb3IgKHN5bSA9IDA7IHN5bSA8IGNvZGVzOyBzeW0rKykge1xuICAgIGNvdW50W2xlbnNbbGVuc19pbmRleCArIHN5bV1dKys7XG4gIH1cblxuICAvKiBib3VuZCBjb2RlIGxlbmd0aHMsIGZvcmNlIHJvb3QgdG8gYmUgd2l0aGluIGNvZGUgbGVuZ3RocyAqL1xuICByb290ID0gYml0cztcbiAgZm9yIChtYXggPSBNQVhCSVRTOyBtYXggPj0gMTsgbWF4LS0pIHtcbiAgICBpZiAoY291bnRbbWF4XSAhPT0gMCkgeyBicmVhazsgfVxuICB9XG4gIGlmIChyb290ID4gbWF4KSB7XG4gICAgcm9vdCA9IG1heDtcbiAgfVxuICBpZiAobWF4ID09PSAwKSB7ICAgICAgICAgICAgICAgICAgICAgLyogbm8gc3ltYm9scyB0byBjb2RlIGF0IGFsbCAqL1xuICAgIC8vdGFibGUub3Bbb3B0cy50YWJsZV9pbmRleF0gPSA2NDsgIC8vaGVyZS5vcCA9ICh2YXIgY2hhcik2NDsgICAgLyogaW52YWxpZCBjb2RlIG1hcmtlciAqL1xuICAgIC8vdGFibGUuYml0c1tvcHRzLnRhYmxlX2luZGV4XSA9IDE7ICAgLy9oZXJlLmJpdHMgPSAodmFyIGNoYXIpMTtcbiAgICAvL3RhYmxlLnZhbFtvcHRzLnRhYmxlX2luZGV4KytdID0gMDsgICAvL2hlcmUudmFsID0gKHZhciBzaG9ydCkwO1xuICAgIHRhYmxlW3RhYmxlX2luZGV4KytdID0gKDEgPDwgMjQpIHwgKDY0IDw8IDE2KSB8IDA7XG5cblxuICAgIC8vdGFibGUub3Bbb3B0cy50YWJsZV9pbmRleF0gPSA2NDtcbiAgICAvL3RhYmxlLmJpdHNbb3B0cy50YWJsZV9pbmRleF0gPSAxO1xuICAgIC8vdGFibGUudmFsW29wdHMudGFibGVfaW5kZXgrK10gPSAwO1xuICAgIHRhYmxlW3RhYmxlX2luZGV4KytdID0gKDEgPDwgMjQpIHwgKDY0IDw8IDE2KSB8IDA7XG5cbiAgICBvcHRzLmJpdHMgPSAxO1xuICAgIHJldHVybiAwOyAgICAgLyogbm8gc3ltYm9scywgYnV0IHdhaXQgZm9yIGRlY29kaW5nIHRvIHJlcG9ydCBlcnJvciAqL1xuICB9XG4gIGZvciAobWluID0gMTsgbWluIDwgbWF4OyBtaW4rKykge1xuICAgIGlmIChjb3VudFttaW5dICE9PSAwKSB7IGJyZWFrOyB9XG4gIH1cbiAgaWYgKHJvb3QgPCBtaW4pIHtcbiAgICByb290ID0gbWluO1xuICB9XG5cbiAgLyogY2hlY2sgZm9yIGFuIG92ZXItc3Vic2NyaWJlZCBvciBpbmNvbXBsZXRlIHNldCBvZiBsZW5ndGhzICovXG4gIGxlZnQgPSAxO1xuICBmb3IgKGxlbiA9IDE7IGxlbiA8PSBNQVhCSVRTOyBsZW4rKykge1xuICAgIGxlZnQgPDw9IDE7XG4gICAgbGVmdCAtPSBjb3VudFtsZW5dO1xuICAgIGlmIChsZWZ0IDwgMCkge1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH0gICAgICAgIC8qIG92ZXItc3Vic2NyaWJlZCAqL1xuICB9XG4gIGlmIChsZWZ0ID4gMCAmJiAodHlwZSA9PT0gQ09ERVMgfHwgbWF4ICE9PSAxKSkge1xuICAgIHJldHVybiAtMTsgICAgICAgICAgICAgICAgICAgICAgLyogaW5jb21wbGV0ZSBzZXQgKi9cbiAgfVxuXG4gIC8qIGdlbmVyYXRlIG9mZnNldHMgaW50byBzeW1ib2wgdGFibGUgZm9yIGVhY2ggbGVuZ3RoIGZvciBzb3J0aW5nICovXG4gIG9mZnNbMV0gPSAwO1xuICBmb3IgKGxlbiA9IDE7IGxlbiA8IE1BWEJJVFM7IGxlbisrKSB7XG4gICAgb2Zmc1tsZW4gKyAxXSA9IG9mZnNbbGVuXSArIGNvdW50W2xlbl07XG4gIH1cblxuICAvKiBzb3J0IHN5bWJvbHMgYnkgbGVuZ3RoLCBieSBzeW1ib2wgb3JkZXIgd2l0aGluIGVhY2ggbGVuZ3RoICovXG4gIGZvciAoc3ltID0gMDsgc3ltIDwgY29kZXM7IHN5bSsrKSB7XG4gICAgaWYgKGxlbnNbbGVuc19pbmRleCArIHN5bV0gIT09IDApIHtcbiAgICAgIHdvcmtbb2Zmc1tsZW5zW2xlbnNfaW5kZXggKyBzeW1dXSsrXSA9IHN5bTtcbiAgICB9XG4gIH1cblxuICAvKlxuICAgQ3JlYXRlIGFuZCBmaWxsIGluIGRlY29kaW5nIHRhYmxlcy4gIEluIHRoaXMgbG9vcCwgdGhlIHRhYmxlIGJlaW5nXG4gICBmaWxsZWQgaXMgYXQgbmV4dCBhbmQgaGFzIGN1cnIgaW5kZXggYml0cy4gIFRoZSBjb2RlIGJlaW5nIHVzZWQgaXMgaHVmZlxuICAgd2l0aCBsZW5ndGggbGVuLiAgVGhhdCBjb2RlIGlzIGNvbnZlcnRlZCB0byBhbiBpbmRleCBieSBkcm9wcGluZyBkcm9wXG4gICBiaXRzIG9mZiBvZiB0aGUgYm90dG9tLiAgRm9yIGNvZGVzIHdoZXJlIGxlbiBpcyBsZXNzIHRoYW4gZHJvcCArIGN1cnIsXG4gICB0aG9zZSB0b3AgZHJvcCArIGN1cnIgLSBsZW4gYml0cyBhcmUgaW5jcmVtZW50ZWQgdGhyb3VnaCBhbGwgdmFsdWVzIHRvXG4gICBmaWxsIHRoZSB0YWJsZSB3aXRoIHJlcGxpY2F0ZWQgZW50cmllcy5cblxuICAgcm9vdCBpcyB0aGUgbnVtYmVyIG9mIGluZGV4IGJpdHMgZm9yIHRoZSByb290IHRhYmxlLiAgV2hlbiBsZW4gZXhjZWVkc1xuICAgcm9vdCwgc3ViLXRhYmxlcyBhcmUgY3JlYXRlZCBwb2ludGVkIHRvIGJ5IHRoZSByb290IGVudHJ5IHdpdGggYW4gaW5kZXhcbiAgIG9mIHRoZSBsb3cgcm9vdCBiaXRzIG9mIGh1ZmYuICBUaGlzIGlzIHNhdmVkIGluIGxvdyB0byBjaGVjayBmb3Igd2hlbiBhXG4gICBuZXcgc3ViLXRhYmxlIHNob3VsZCBiZSBzdGFydGVkLiAgZHJvcCBpcyB6ZXJvIHdoZW4gdGhlIHJvb3QgdGFibGUgaXNcbiAgIGJlaW5nIGZpbGxlZCwgYW5kIGRyb3AgaXMgcm9vdCB3aGVuIHN1Yi10YWJsZXMgYXJlIGJlaW5nIGZpbGxlZC5cblxuICAgV2hlbiBhIG5ldyBzdWItdGFibGUgaXMgbmVlZGVkLCBpdCBpcyBuZWNlc3NhcnkgdG8gbG9vayBhaGVhZCBpbiB0aGVcbiAgIGNvZGUgbGVuZ3RocyB0byBkZXRlcm1pbmUgd2hhdCBzaXplIHN1Yi10YWJsZSBpcyBuZWVkZWQuICBUaGUgbGVuZ3RoXG4gICBjb3VudHMgYXJlIHVzZWQgZm9yIHRoaXMsIGFuZCBzbyBjb3VudFtdIGlzIGRlY3JlbWVudGVkIGFzIGNvZGVzIGFyZVxuICAgZW50ZXJlZCBpbiB0aGUgdGFibGVzLlxuXG4gICB1c2VkIGtlZXBzIHRyYWNrIG9mIGhvdyBtYW55IHRhYmxlIGVudHJpZXMgaGF2ZSBiZWVuIGFsbG9jYXRlZCBmcm9tIHRoZVxuICAgcHJvdmlkZWQgKnRhYmxlIHNwYWNlLiAgSXQgaXMgY2hlY2tlZCBmb3IgTEVOUyBhbmQgRElTVCB0YWJsZXMgYWdhaW5zdFxuICAgdGhlIGNvbnN0YW50cyBFTk9VR0hfTEVOUyBhbmQgRU5PVUdIX0RJU1RTIHRvIGd1YXJkIGFnYWluc3QgY2hhbmdlcyBpblxuICAgdGhlIGluaXRpYWwgcm9vdCB0YWJsZSBzaXplIGNvbnN0YW50cy4gIFNlZSB0aGUgY29tbWVudHMgaW4gaW5mdHJlZXMuaFxuICAgZm9yIG1vcmUgaW5mb3JtYXRpb24uXG5cbiAgIHN5bSBpbmNyZW1lbnRzIHRocm91Z2ggYWxsIHN5bWJvbHMsIGFuZCB0aGUgbG9vcCB0ZXJtaW5hdGVzIHdoZW5cbiAgIGFsbCBjb2RlcyBvZiBsZW5ndGggbWF4LCBpLmUuIGFsbCBjb2RlcywgaGF2ZSBiZWVuIHByb2Nlc3NlZC4gIFRoaXNcbiAgIHJvdXRpbmUgcGVybWl0cyBpbmNvbXBsZXRlIGNvZGVzLCBzbyBhbm90aGVyIGxvb3AgYWZ0ZXIgdGhpcyBvbmUgZmlsbHNcbiAgIGluIHRoZSByZXN0IG9mIHRoZSBkZWNvZGluZyB0YWJsZXMgd2l0aCBpbnZhbGlkIGNvZGUgbWFya2Vycy5cbiAgICovXG5cbiAgLyogc2V0IHVwIGZvciBjb2RlIHR5cGUgKi9cbiAgLy8gcG9vciBtYW4gb3B0aW1pemF0aW9uIC0gdXNlIGlmLWVsc2UgaW5zdGVhZCBvZiBzd2l0Y2gsXG4gIC8vIHRvIGF2b2lkIGRlb3B0cyBpbiBvbGQgdjhcbiAgaWYgKHR5cGUgPT09IENPREVTKSB7XG4gICAgYmFzZSA9IGV4dHJhID0gd29yazsgICAgLyogZHVtbXkgdmFsdWUtLW5vdCB1c2VkICovXG4gICAgZW5kID0gMTk7XG5cbiAgfSBlbHNlIGlmICh0eXBlID09PSBMRU5TKSB7XG4gICAgYmFzZSA9IGxiYXNlO1xuICAgIGJhc2VfaW5kZXggLT0gMjU3O1xuICAgIGV4dHJhID0gbGV4dDtcbiAgICBleHRyYV9pbmRleCAtPSAyNTc7XG4gICAgZW5kID0gMjU2O1xuXG4gIH0gZWxzZSB7ICAgICAgICAgICAgICAgICAgICAvKiBESVNUUyAqL1xuICAgIGJhc2UgPSBkYmFzZTtcbiAgICBleHRyYSA9IGRleHQ7XG4gICAgZW5kID0gLTE7XG4gIH1cblxuICAvKiBpbml0aWFsaXplIG9wdHMgZm9yIGxvb3AgKi9cbiAgaHVmZiA9IDA7ICAgICAgICAgICAgICAgICAgIC8qIHN0YXJ0aW5nIGNvZGUgKi9cbiAgc3ltID0gMDsgICAgICAgICAgICAgICAgICAgIC8qIHN0YXJ0aW5nIGNvZGUgc3ltYm9sICovXG4gIGxlbiA9IG1pbjsgICAgICAgICAgICAgICAgICAvKiBzdGFydGluZyBjb2RlIGxlbmd0aCAqL1xuICBuZXh0ID0gdGFibGVfaW5kZXg7ICAgICAgICAgICAgICAvKiBjdXJyZW50IHRhYmxlIHRvIGZpbGwgaW4gKi9cbiAgY3VyciA9IHJvb3Q7ICAgICAgICAgICAgICAgIC8qIGN1cnJlbnQgdGFibGUgaW5kZXggYml0cyAqL1xuICBkcm9wID0gMDsgICAgICAgICAgICAgICAgICAgLyogY3VycmVudCBiaXRzIHRvIGRyb3AgZnJvbSBjb2RlIGZvciBpbmRleCAqL1xuICBsb3cgPSAtMTsgICAgICAgICAgICAgICAgICAgLyogdHJpZ2dlciBuZXcgc3ViLXRhYmxlIHdoZW4gbGVuID4gcm9vdCAqL1xuICB1c2VkID0gMSA8PCByb290OyAgICAgICAgICAvKiB1c2Ugcm9vdCB0YWJsZSBlbnRyaWVzICovXG4gIG1hc2sgPSB1c2VkIC0gMTsgICAgICAgICAgICAvKiBtYXNrIGZvciBjb21wYXJpbmcgbG93ICovXG5cbiAgLyogY2hlY2sgYXZhaWxhYmxlIHRhYmxlIHNwYWNlICovXG4gIGlmICgodHlwZSA9PT0gTEVOUyAmJiB1c2VkID4gRU5PVUdIX0xFTlMpIHx8XG4gICAgKHR5cGUgPT09IERJU1RTICYmIHVzZWQgPiBFTk9VR0hfRElTVFMpKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cblxuICB2YXIgaSA9IDA7XG4gIC8qIHByb2Nlc3MgYWxsIGNvZGVzIGFuZCBtYWtlIHRhYmxlIGVudHJpZXMgKi9cbiAgZm9yICg7Oykge1xuICAgIGkrKztcbiAgICAvKiBjcmVhdGUgdGFibGUgZW50cnkgKi9cbiAgICBoZXJlX2JpdHMgPSBsZW4gLSBkcm9wO1xuICAgIGlmICh3b3JrW3N5bV0gPCBlbmQpIHtcbiAgICAgIGhlcmVfb3AgPSAwO1xuICAgICAgaGVyZV92YWwgPSB3b3JrW3N5bV07XG4gICAgfVxuICAgIGVsc2UgaWYgKHdvcmtbc3ltXSA+IGVuZCkge1xuICAgICAgaGVyZV9vcCA9IGV4dHJhW2V4dHJhX2luZGV4ICsgd29ya1tzeW1dXTtcbiAgICAgIGhlcmVfdmFsID0gYmFzZVtiYXNlX2luZGV4ICsgd29ya1tzeW1dXTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBoZXJlX29wID0gMzIgKyA2NDsgICAgICAgICAvKiBlbmQgb2YgYmxvY2sgKi9cbiAgICAgIGhlcmVfdmFsID0gMDtcbiAgICB9XG5cbiAgICAvKiByZXBsaWNhdGUgZm9yIHRob3NlIGluZGljZXMgd2l0aCBsb3cgbGVuIGJpdHMgZXF1YWwgdG8gaHVmZiAqL1xuICAgIGluY3IgPSAxIDw8IChsZW4gLSBkcm9wKTtcbiAgICBmaWxsID0gMSA8PCBjdXJyO1xuICAgIG1pbiA9IGZpbGw7ICAgICAgICAgICAgICAgICAvKiBzYXZlIG9mZnNldCB0byBuZXh0IHRhYmxlICovXG4gICAgZG8ge1xuICAgICAgZmlsbCAtPSBpbmNyO1xuICAgICAgdGFibGVbbmV4dCArIChodWZmID4+IGRyb3ApICsgZmlsbF0gPSAoaGVyZV9iaXRzIDw8IDI0KSB8IChoZXJlX29wIDw8IDE2KSB8IGhlcmVfdmFsIHwwO1xuICAgIH0gd2hpbGUgKGZpbGwgIT09IDApO1xuXG4gICAgLyogYmFja3dhcmRzIGluY3JlbWVudCB0aGUgbGVuLWJpdCBjb2RlIGh1ZmYgKi9cbiAgICBpbmNyID0gMSA8PCAobGVuIC0gMSk7XG4gICAgd2hpbGUgKGh1ZmYgJiBpbmNyKSB7XG4gICAgICBpbmNyID4+PSAxO1xuICAgIH1cbiAgICBpZiAoaW5jciAhPT0gMCkge1xuICAgICAgaHVmZiAmPSBpbmNyIC0gMTtcbiAgICAgIGh1ZmYgKz0gaW5jcjtcbiAgICB9IGVsc2Uge1xuICAgICAgaHVmZiA9IDA7XG4gICAgfVxuXG4gICAgLyogZ28gdG8gbmV4dCBzeW1ib2wsIHVwZGF0ZSBjb3VudCwgbGVuICovXG4gICAgc3ltKys7XG4gICAgaWYgKC0tY291bnRbbGVuXSA9PT0gMCkge1xuICAgICAgaWYgKGxlbiA9PT0gbWF4KSB7IGJyZWFrOyB9XG4gICAgICBsZW4gPSBsZW5zW2xlbnNfaW5kZXggKyB3b3JrW3N5bV1dO1xuICAgIH1cblxuICAgIC8qIGNyZWF0ZSBuZXcgc3ViLXRhYmxlIGlmIG5lZWRlZCAqL1xuICAgIGlmIChsZW4gPiByb290ICYmIChodWZmICYgbWFzaykgIT09IGxvdykge1xuICAgICAgLyogaWYgZmlyc3QgdGltZSwgdHJhbnNpdGlvbiB0byBzdWItdGFibGVzICovXG4gICAgICBpZiAoZHJvcCA9PT0gMCkge1xuICAgICAgICBkcm9wID0gcm9vdDtcbiAgICAgIH1cblxuICAgICAgLyogaW5jcmVtZW50IHBhc3QgbGFzdCB0YWJsZSAqL1xuICAgICAgbmV4dCArPSBtaW47ICAgICAgICAgICAgLyogaGVyZSBtaW4gaXMgMSA8PCBjdXJyICovXG5cbiAgICAgIC8qIGRldGVybWluZSBsZW5ndGggb2YgbmV4dCB0YWJsZSAqL1xuICAgICAgY3VyciA9IGxlbiAtIGRyb3A7XG4gICAgICBsZWZ0ID0gMSA8PCBjdXJyO1xuICAgICAgd2hpbGUgKGN1cnIgKyBkcm9wIDwgbWF4KSB7XG4gICAgICAgIGxlZnQgLT0gY291bnRbY3VyciArIGRyb3BdO1xuICAgICAgICBpZiAobGVmdCA8PSAwKSB7IGJyZWFrOyB9XG4gICAgICAgIGN1cnIrKztcbiAgICAgICAgbGVmdCA8PD0gMTtcbiAgICAgIH1cblxuICAgICAgLyogY2hlY2sgZm9yIGVub3VnaCBzcGFjZSAqL1xuICAgICAgdXNlZCArPSAxIDw8IGN1cnI7XG4gICAgICBpZiAoKHR5cGUgPT09IExFTlMgJiYgdXNlZCA+IEVOT1VHSF9MRU5TKSB8fFxuICAgICAgICAodHlwZSA9PT0gRElTVFMgJiYgdXNlZCA+IEVOT1VHSF9ESVNUUykpIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9XG5cbiAgICAgIC8qIHBvaW50IGVudHJ5IGluIHJvb3QgdGFibGUgdG8gc3ViLXRhYmxlICovXG4gICAgICBsb3cgPSBodWZmICYgbWFzaztcbiAgICAgIC8qdGFibGUub3BbbG93XSA9IGN1cnI7XG4gICAgICB0YWJsZS5iaXRzW2xvd10gPSByb290O1xuICAgICAgdGFibGUudmFsW2xvd10gPSBuZXh0IC0gb3B0cy50YWJsZV9pbmRleDsqL1xuICAgICAgdGFibGVbbG93XSA9IChyb290IDw8IDI0KSB8IChjdXJyIDw8IDE2KSB8IChuZXh0IC0gdGFibGVfaW5kZXgpIHwwO1xuICAgIH1cbiAgfVxuXG4gIC8qIGZpbGwgaW4gcmVtYWluaW5nIHRhYmxlIGVudHJ5IGlmIGNvZGUgaXMgaW5jb21wbGV0ZSAoZ3VhcmFudGVlZCB0byBoYXZlXG4gICBhdCBtb3N0IG9uZSByZW1haW5pbmcgZW50cnksIHNpbmNlIGlmIHRoZSBjb2RlIGlzIGluY29tcGxldGUsIHRoZVxuICAgbWF4aW11bSBjb2RlIGxlbmd0aCB0aGF0IHdhcyBhbGxvd2VkIHRvIGdldCB0aGlzIGZhciBpcyBvbmUgYml0KSAqL1xuICBpZiAoaHVmZiAhPT0gMCkge1xuICAgIC8vdGFibGUub3BbbmV4dCArIGh1ZmZdID0gNjQ7ICAgICAgICAgICAgLyogaW52YWxpZCBjb2RlIG1hcmtlciAqL1xuICAgIC8vdGFibGUuYml0c1tuZXh0ICsgaHVmZl0gPSBsZW4gLSBkcm9wO1xuICAgIC8vdGFibGUudmFsW25leHQgKyBodWZmXSA9IDA7XG4gICAgdGFibGVbbmV4dCArIGh1ZmZdID0gKChsZW4gLSBkcm9wKSA8PCAyNCkgfCAoNjQgPDwgMTYpIHwwO1xuICB9XG5cbiAgLyogc2V0IHJldHVybiBwYXJhbWV0ZXJzICovXG4gIC8vb3B0cy50YWJsZV9pbmRleCArPSB1c2VkO1xuICBvcHRzLmJpdHMgPSByb290O1xuICByZXR1cm4gMDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAyOiAgICAgICduZWVkIGRpY3Rpb25hcnknLCAgICAgLyogWl9ORUVEX0RJQ1QgICAgICAgMiAgKi9cbiAgMTogICAgICAnc3RyZWFtIGVuZCcsICAgICAgICAgIC8qIFpfU1RSRUFNX0VORCAgICAgIDEgICovXG4gIDA6ICAgICAgJycsICAgICAgICAgICAgICAgICAgICAvKiBaX09LICAgICAgICAgICAgICAwICAqL1xuICAnLTEnOiAgICdmaWxlIGVycm9yJywgICAgICAgICAgLyogWl9FUlJOTyAgICAgICAgICgtMSkgKi9cbiAgJy0yJzogICAnc3RyZWFtIGVycm9yJywgICAgICAgIC8qIFpfU1RSRUFNX0VSUk9SICAoLTIpICovXG4gICctMyc6ICAgJ2RhdGEgZXJyb3InLCAgICAgICAgICAvKiBaX0RBVEFfRVJST1IgICAgKC0zKSAqL1xuICAnLTQnOiAgICdpbnN1ZmZpY2llbnQgbWVtb3J5JywgLyogWl9NRU1fRVJST1IgICAgICgtNCkgKi9cbiAgJy01JzogICAnYnVmZmVyIGVycm9yJywgICAgICAgIC8qIFpfQlVGX0VSUk9SICAgICAoLTUpICovXG4gICctNic6ICAgJ2luY29tcGF0aWJsZSB2ZXJzaW9uJyAvKiBaX1ZFUlNJT05fRVJST1IgKC02KSAqL1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscy9jb21tb24nKTtcblxuLyogUHVibGljIGNvbnN0YW50cyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cblxuLy92YXIgWl9GSUxURVJFRCAgICAgICAgICA9IDE7XG4vL3ZhciBaX0hVRkZNQU5fT05MWSAgICAgID0gMjtcbi8vdmFyIFpfUkxFICAgICAgICAgICAgICAgPSAzO1xudmFyIFpfRklYRUQgICAgICAgICAgICAgICA9IDQ7XG4vL3ZhciBaX0RFRkFVTFRfU1RSQVRFR1kgID0gMDtcblxuLyogUG9zc2libGUgdmFsdWVzIG9mIHRoZSBkYXRhX3R5cGUgZmllbGQgKHRob3VnaCBzZWUgaW5mbGF0ZSgpKSAqL1xudmFyIFpfQklOQVJZICAgICAgICAgICAgICA9IDA7XG52YXIgWl9URVhUICAgICAgICAgICAgICAgID0gMTtcbi8vdmFyIFpfQVNDSUkgICAgICAgICAgICAgPSAxOyAvLyA9IFpfVEVYVFxudmFyIFpfVU5LTk9XTiAgICAgICAgICAgICA9IDI7XG5cbi8qPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cblxuZnVuY3Rpb24gemVybyhidWYpIHsgdmFyIGxlbiA9IGJ1Zi5sZW5ndGg7IHdoaWxlICgtLWxlbiA+PSAwKSB7IGJ1ZltsZW5dID0gMDsgfSB9XG5cbi8vIEZyb20genV0aWwuaFxuXG52YXIgU1RPUkVEX0JMT0NLID0gMDtcbnZhciBTVEFUSUNfVFJFRVMgPSAxO1xudmFyIERZTl9UUkVFUyAgICA9IDI7XG4vKiBUaGUgdGhyZWUga2luZHMgb2YgYmxvY2sgdHlwZSAqL1xuXG52YXIgTUlOX01BVENIICAgID0gMztcbnZhciBNQVhfTUFUQ0ggICAgPSAyNTg7XG4vKiBUaGUgbWluaW11bSBhbmQgbWF4aW11bSBtYXRjaCBsZW5ndGhzICovXG5cbi8vIEZyb20gZGVmbGF0ZS5oXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEludGVybmFsIGNvbXByZXNzaW9uIHN0YXRlLlxuICovXG5cbnZhciBMRU5HVEhfQ09ERVMgID0gMjk7XG4vKiBudW1iZXIgb2YgbGVuZ3RoIGNvZGVzLCBub3QgY291bnRpbmcgdGhlIHNwZWNpYWwgRU5EX0JMT0NLIGNvZGUgKi9cblxudmFyIExJVEVSQUxTICAgICAgPSAyNTY7XG4vKiBudW1iZXIgb2YgbGl0ZXJhbCBieXRlcyAwLi4yNTUgKi9cblxudmFyIExfQ09ERVMgICAgICAgPSBMSVRFUkFMUyArIDEgKyBMRU5HVEhfQ09ERVM7XG4vKiBudW1iZXIgb2YgTGl0ZXJhbCBvciBMZW5ndGggY29kZXMsIGluY2x1ZGluZyB0aGUgRU5EX0JMT0NLIGNvZGUgKi9cblxudmFyIERfQ09ERVMgICAgICAgPSAzMDtcbi8qIG51bWJlciBvZiBkaXN0YW5jZSBjb2RlcyAqL1xuXG52YXIgQkxfQ09ERVMgICAgICA9IDE5O1xuLyogbnVtYmVyIG9mIGNvZGVzIHVzZWQgdG8gdHJhbnNmZXIgdGhlIGJpdCBsZW5ndGhzICovXG5cbnZhciBIRUFQX1NJWkUgICAgID0gMiAqIExfQ09ERVMgKyAxO1xuLyogbWF4aW11bSBoZWFwIHNpemUgKi9cblxudmFyIE1BWF9CSVRTICAgICAgPSAxNTtcbi8qIEFsbCBjb2RlcyBtdXN0IG5vdCBleGNlZWQgTUFYX0JJVFMgYml0cyAqL1xuXG52YXIgQnVmX3NpemUgICAgICA9IDE2O1xuLyogc2l6ZSBvZiBiaXQgYnVmZmVyIGluIGJpX2J1ZiAqL1xuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29uc3RhbnRzXG4gKi9cblxudmFyIE1BWF9CTF9CSVRTID0gNztcbi8qIEJpdCBsZW5ndGggY29kZXMgbXVzdCBub3QgZXhjZWVkIE1BWF9CTF9CSVRTIGJpdHMgKi9cblxudmFyIEVORF9CTE9DSyAgID0gMjU2O1xuLyogZW5kIG9mIGJsb2NrIGxpdGVyYWwgY29kZSAqL1xuXG52YXIgUkVQXzNfNiAgICAgPSAxNjtcbi8qIHJlcGVhdCBwcmV2aW91cyBiaXQgbGVuZ3RoIDMtNiB0aW1lcyAoMiBiaXRzIG9mIHJlcGVhdCBjb3VudCkgKi9cblxudmFyIFJFUFpfM18xMCAgID0gMTc7XG4vKiByZXBlYXQgYSB6ZXJvIGxlbmd0aCAzLTEwIHRpbWVzICAoMyBiaXRzIG9mIHJlcGVhdCBjb3VudCkgKi9cblxudmFyIFJFUFpfMTFfMTM4ID0gMTg7XG4vKiByZXBlYXQgYSB6ZXJvIGxlbmd0aCAxMS0xMzggdGltZXMgICg3IGJpdHMgb2YgcmVwZWF0IGNvdW50KSAqL1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBjb21tYS1zcGFjaW5nLGFycmF5LWJyYWNrZXQtc3BhY2luZyAqL1xudmFyIGV4dHJhX2xiaXRzID0gICAvKiBleHRyYSBiaXRzIGZvciBlYWNoIGxlbmd0aCBjb2RlICovXG4gIFswLDAsMCwwLDAsMCwwLDAsMSwxLDEsMSwyLDIsMiwyLDMsMywzLDMsNCw0LDQsNCw1LDUsNSw1LDBdO1xuXG52YXIgZXh0cmFfZGJpdHMgPSAgIC8qIGV4dHJhIGJpdHMgZm9yIGVhY2ggZGlzdGFuY2UgY29kZSAqL1xuICBbMCwwLDAsMCwxLDEsMiwyLDMsMyw0LDQsNSw1LDYsNiw3LDcsOCw4LDksOSwxMCwxMCwxMSwxMSwxMiwxMiwxMywxM107XG5cbnZhciBleHRyYV9ibGJpdHMgPSAgLyogZXh0cmEgYml0cyBmb3IgZWFjaCBiaXQgbGVuZ3RoIGNvZGUgKi9cbiAgWzAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMiwzLDddO1xuXG52YXIgYmxfb3JkZXIgPVxuICBbMTYsMTcsMTgsMCw4LDcsOSw2LDEwLDUsMTEsNCwxMiwzLDEzLDIsMTQsMSwxNV07XG4vKiBlc2xpbnQtZW5hYmxlIGNvbW1hLXNwYWNpbmcsYXJyYXktYnJhY2tldC1zcGFjaW5nICovXG5cbi8qIFRoZSBsZW5ndGhzIG9mIHRoZSBiaXQgbGVuZ3RoIGNvZGVzIGFyZSBzZW50IGluIG9yZGVyIG9mIGRlY3JlYXNpbmdcbiAqIHByb2JhYmlsaXR5LCB0byBhdm9pZCB0cmFuc21pdHRpbmcgdGhlIGxlbmd0aHMgZm9yIHVudXNlZCBiaXQgbGVuZ3RoIGNvZGVzLlxuICovXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogTG9jYWwgZGF0YS4gVGhlc2UgYXJlIGluaXRpYWxpemVkIG9ubHkgb25jZS5cbiAqL1xuXG4vLyBXZSBwcmUtZmlsbCBhcnJheXMgd2l0aCAwIHRvIGF2b2lkIHVuaW5pdGlhbGl6ZWQgZ2Fwc1xuXG52YXIgRElTVF9DT0RFX0xFTiA9IDUxMjsgLyogc2VlIGRlZmluaXRpb24gb2YgYXJyYXkgZGlzdF9jb2RlIGJlbG93ICovXG5cbi8vICEhISEgVXNlIGZsYXQgYXJyYXkgaW5zZGVhZCBvZiBzdHJ1Y3R1cmUsIEZyZXEgPSBpKjIsIExlbiA9IGkqMisxXG52YXIgc3RhdGljX2x0cmVlICA9IG5ldyBBcnJheSgoTF9DT0RFUyArIDIpICogMik7XG56ZXJvKHN0YXRpY19sdHJlZSk7XG4vKiBUaGUgc3RhdGljIGxpdGVyYWwgdHJlZS4gU2luY2UgdGhlIGJpdCBsZW5ndGhzIGFyZSBpbXBvc2VkLCB0aGVyZSBpcyBub1xuICogbmVlZCBmb3IgdGhlIExfQ09ERVMgZXh0cmEgY29kZXMgdXNlZCBkdXJpbmcgaGVhcCBjb25zdHJ1Y3Rpb24uIEhvd2V2ZXJcbiAqIFRoZSBjb2RlcyAyODYgYW5kIDI4NyBhcmUgbmVlZGVkIHRvIGJ1aWxkIGEgY2Fub25pY2FsIHRyZWUgKHNlZSBfdHJfaW5pdFxuICogYmVsb3cpLlxuICovXG5cbnZhciBzdGF0aWNfZHRyZWUgID0gbmV3IEFycmF5KERfQ09ERVMgKiAyKTtcbnplcm8oc3RhdGljX2R0cmVlKTtcbi8qIFRoZSBzdGF0aWMgZGlzdGFuY2UgdHJlZS4gKEFjdHVhbGx5IGEgdHJpdmlhbCB0cmVlIHNpbmNlIGFsbCBjb2RlcyB1c2VcbiAqIDUgYml0cy4pXG4gKi9cblxudmFyIF9kaXN0X2NvZGUgICAgPSBuZXcgQXJyYXkoRElTVF9DT0RFX0xFTik7XG56ZXJvKF9kaXN0X2NvZGUpO1xuLyogRGlzdGFuY2UgY29kZXMuIFRoZSBmaXJzdCAyNTYgdmFsdWVzIGNvcnJlc3BvbmQgdG8gdGhlIGRpc3RhbmNlc1xuICogMyAuLiAyNTgsIHRoZSBsYXN0IDI1NiB2YWx1ZXMgY29ycmVzcG9uZCB0byB0aGUgdG9wIDggYml0cyBvZlxuICogdGhlIDE1IGJpdCBkaXN0YW5jZXMuXG4gKi9cblxudmFyIF9sZW5ndGhfY29kZSAgPSBuZXcgQXJyYXkoTUFYX01BVENIIC0gTUlOX01BVENIICsgMSk7XG56ZXJvKF9sZW5ndGhfY29kZSk7XG4vKiBsZW5ndGggY29kZSBmb3IgZWFjaCBub3JtYWxpemVkIG1hdGNoIGxlbmd0aCAoMCA9PSBNSU5fTUFUQ0gpICovXG5cbnZhciBiYXNlX2xlbmd0aCAgID0gbmV3IEFycmF5KExFTkdUSF9DT0RFUyk7XG56ZXJvKGJhc2VfbGVuZ3RoKTtcbi8qIEZpcnN0IG5vcm1hbGl6ZWQgbGVuZ3RoIGZvciBlYWNoIGNvZGUgKDAgPSBNSU5fTUFUQ0gpICovXG5cbnZhciBiYXNlX2Rpc3QgICAgID0gbmV3IEFycmF5KERfQ09ERVMpO1xuemVybyhiYXNlX2Rpc3QpO1xuLyogRmlyc3Qgbm9ybWFsaXplZCBkaXN0YW5jZSBmb3IgZWFjaCBjb2RlICgwID0gZGlzdGFuY2Ugb2YgMSkgKi9cblxuXG5mdW5jdGlvbiBTdGF0aWNUcmVlRGVzYyhzdGF0aWNfdHJlZSwgZXh0cmFfYml0cywgZXh0cmFfYmFzZSwgZWxlbXMsIG1heF9sZW5ndGgpIHtcblxuICB0aGlzLnN0YXRpY190cmVlICA9IHN0YXRpY190cmVlOyAgLyogc3RhdGljIHRyZWUgb3IgTlVMTCAqL1xuICB0aGlzLmV4dHJhX2JpdHMgICA9IGV4dHJhX2JpdHM7ICAgLyogZXh0cmEgYml0cyBmb3IgZWFjaCBjb2RlIG9yIE5VTEwgKi9cbiAgdGhpcy5leHRyYV9iYXNlICAgPSBleHRyYV9iYXNlOyAgIC8qIGJhc2UgaW5kZXggZm9yIGV4dHJhX2JpdHMgKi9cbiAgdGhpcy5lbGVtcyAgICAgICAgPSBlbGVtczsgICAgICAgIC8qIG1heCBudW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIHRyZWUgKi9cbiAgdGhpcy5tYXhfbGVuZ3RoICAgPSBtYXhfbGVuZ3RoOyAgIC8qIG1heCBiaXQgbGVuZ3RoIGZvciB0aGUgY29kZXMgKi9cblxuICAvLyBzaG93IGlmIGBzdGF0aWNfdHJlZWAgaGFzIGRhdGEgb3IgZHVtbXkgLSBuZWVkZWQgZm9yIG1vbm9tb3JwaGljIG9iamVjdHNcbiAgdGhpcy5oYXNfc3RyZWUgICAgPSBzdGF0aWNfdHJlZSAmJiBzdGF0aWNfdHJlZS5sZW5ndGg7XG59XG5cblxudmFyIHN0YXRpY19sX2Rlc2M7XG52YXIgc3RhdGljX2RfZGVzYztcbnZhciBzdGF0aWNfYmxfZGVzYztcblxuXG5mdW5jdGlvbiBUcmVlRGVzYyhkeW5fdHJlZSwgc3RhdF9kZXNjKSB7XG4gIHRoaXMuZHluX3RyZWUgPSBkeW5fdHJlZTsgICAgIC8qIHRoZSBkeW5hbWljIHRyZWUgKi9cbiAgdGhpcy5tYXhfY29kZSA9IDA7ICAgICAgICAgICAgLyogbGFyZ2VzdCBjb2RlIHdpdGggbm9uIHplcm8gZnJlcXVlbmN5ICovXG4gIHRoaXMuc3RhdF9kZXNjID0gc3RhdF9kZXNjOyAgIC8qIHRoZSBjb3JyZXNwb25kaW5nIHN0YXRpYyB0cmVlICovXG59XG5cblxuXG5mdW5jdGlvbiBkX2NvZGUoZGlzdCkge1xuICByZXR1cm4gZGlzdCA8IDI1NiA/IF9kaXN0X2NvZGVbZGlzdF0gOiBfZGlzdF9jb2RlWzI1NiArIChkaXN0ID4+PiA3KV07XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBPdXRwdXQgYSBzaG9ydCBMU0IgZmlyc3Qgb24gdGhlIHN0cmVhbS5cbiAqIElOIGFzc2VydGlvbjogdGhlcmUgaXMgZW5vdWdoIHJvb20gaW4gcGVuZGluZ0J1Zi5cbiAqL1xuZnVuY3Rpb24gcHV0X3Nob3J0KHMsIHcpIHtcbi8vICAgIHB1dF9ieXRlKHMsICh1Y2gpKCh3KSAmIDB4ZmYpKTtcbi8vICAgIHB1dF9ieXRlKHMsICh1Y2gpKCh1c2gpKHcpID4+IDgpKTtcbiAgcy5wZW5kaW5nX2J1ZltzLnBlbmRpbmcrK10gPSAodykgJiAweGZmO1xuICBzLnBlbmRpbmdfYnVmW3MucGVuZGluZysrXSA9ICh3ID4+PiA4KSAmIDB4ZmY7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTZW5kIGEgdmFsdWUgb24gYSBnaXZlbiBudW1iZXIgb2YgYml0cy5cbiAqIElOIGFzc2VydGlvbjogbGVuZ3RoIDw9IDE2IGFuZCB2YWx1ZSBmaXRzIGluIGxlbmd0aCBiaXRzLlxuICovXG5mdW5jdGlvbiBzZW5kX2JpdHMocywgdmFsdWUsIGxlbmd0aCkge1xuICBpZiAocy5iaV92YWxpZCA+IChCdWZfc2l6ZSAtIGxlbmd0aCkpIHtcbiAgICBzLmJpX2J1ZiB8PSAodmFsdWUgPDwgcy5iaV92YWxpZCkgJiAweGZmZmY7XG4gICAgcHV0X3Nob3J0KHMsIHMuYmlfYnVmKTtcbiAgICBzLmJpX2J1ZiA9IHZhbHVlID4+IChCdWZfc2l6ZSAtIHMuYmlfdmFsaWQpO1xuICAgIHMuYmlfdmFsaWQgKz0gbGVuZ3RoIC0gQnVmX3NpemU7XG4gIH0gZWxzZSB7XG4gICAgcy5iaV9idWYgfD0gKHZhbHVlIDw8IHMuYmlfdmFsaWQpICYgMHhmZmZmO1xuICAgIHMuYmlfdmFsaWQgKz0gbGVuZ3RoO1xuICB9XG59XG5cblxuZnVuY3Rpb24gc2VuZF9jb2RlKHMsIGMsIHRyZWUpIHtcbiAgc2VuZF9iaXRzKHMsIHRyZWVbYyAqIDJdLyouQ29kZSovLCB0cmVlW2MgKiAyICsgMV0vKi5MZW4qLyk7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBSZXZlcnNlIHRoZSBmaXJzdCBsZW4gYml0cyBvZiBhIGNvZGUsIHVzaW5nIHN0cmFpZ2h0Zm9yd2FyZCBjb2RlIChhIGZhc3RlclxuICogbWV0aG9kIHdvdWxkIHVzZSBhIHRhYmxlKVxuICogSU4gYXNzZXJ0aW9uOiAxIDw9IGxlbiA8PSAxNVxuICovXG5mdW5jdGlvbiBiaV9yZXZlcnNlKGNvZGUsIGxlbikge1xuICB2YXIgcmVzID0gMDtcbiAgZG8ge1xuICAgIHJlcyB8PSBjb2RlICYgMTtcbiAgICBjb2RlID4+Pj0gMTtcbiAgICByZXMgPDw9IDE7XG4gIH0gd2hpbGUgKC0tbGVuID4gMCk7XG4gIHJldHVybiByZXMgPj4+IDE7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBGbHVzaCB0aGUgYml0IGJ1ZmZlciwga2VlcGluZyBhdCBtb3N0IDcgYml0cyBpbiBpdC5cbiAqL1xuZnVuY3Rpb24gYmlfZmx1c2gocykge1xuICBpZiAocy5iaV92YWxpZCA9PT0gMTYpIHtcbiAgICBwdXRfc2hvcnQocywgcy5iaV9idWYpO1xuICAgIHMuYmlfYnVmID0gMDtcbiAgICBzLmJpX3ZhbGlkID0gMDtcblxuICB9IGVsc2UgaWYgKHMuYmlfdmFsaWQgPj0gOCkge1xuICAgIHMucGVuZGluZ19idWZbcy5wZW5kaW5nKytdID0gcy5iaV9idWYgJiAweGZmO1xuICAgIHMuYmlfYnVmID4+PSA4O1xuICAgIHMuYmlfdmFsaWQgLT0gODtcbiAgfVxufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29tcHV0ZSB0aGUgb3B0aW1hbCBiaXQgbGVuZ3RocyBmb3IgYSB0cmVlIGFuZCB1cGRhdGUgdGhlIHRvdGFsIGJpdCBsZW5ndGhcbiAqIGZvciB0aGUgY3VycmVudCBibG9jay5cbiAqIElOIGFzc2VydGlvbjogdGhlIGZpZWxkcyBmcmVxIGFuZCBkYWQgYXJlIHNldCwgaGVhcFtoZWFwX21heF0gYW5kXG4gKiAgICBhYm92ZSBhcmUgdGhlIHRyZWUgbm9kZXMgc29ydGVkIGJ5IGluY3JlYXNpbmcgZnJlcXVlbmN5LlxuICogT1VUIGFzc2VydGlvbnM6IHRoZSBmaWVsZCBsZW4gaXMgc2V0IHRvIHRoZSBvcHRpbWFsIGJpdCBsZW5ndGgsIHRoZVxuICogICAgIGFycmF5IGJsX2NvdW50IGNvbnRhaW5zIHRoZSBmcmVxdWVuY2llcyBmb3IgZWFjaCBiaXQgbGVuZ3RoLlxuICogICAgIFRoZSBsZW5ndGggb3B0X2xlbiBpcyB1cGRhdGVkOyBzdGF0aWNfbGVuIGlzIGFsc28gdXBkYXRlZCBpZiBzdHJlZSBpc1xuICogICAgIG5vdCBudWxsLlxuICovXG5mdW5jdGlvbiBnZW5fYml0bGVuKHMsIGRlc2MpXG4vLyAgICBkZWZsYXRlX3N0YXRlICpzO1xuLy8gICAgdHJlZV9kZXNjICpkZXNjOyAgICAvKiB0aGUgdHJlZSBkZXNjcmlwdG9yICovXG57XG4gIHZhciB0cmVlICAgICAgICAgICAgPSBkZXNjLmR5bl90cmVlO1xuICB2YXIgbWF4X2NvZGUgICAgICAgID0gZGVzYy5tYXhfY29kZTtcbiAgdmFyIHN0cmVlICAgICAgICAgICA9IGRlc2Muc3RhdF9kZXNjLnN0YXRpY190cmVlO1xuICB2YXIgaGFzX3N0cmVlICAgICAgID0gZGVzYy5zdGF0X2Rlc2MuaGFzX3N0cmVlO1xuICB2YXIgZXh0cmEgICAgICAgICAgID0gZGVzYy5zdGF0X2Rlc2MuZXh0cmFfYml0cztcbiAgdmFyIGJhc2UgICAgICAgICAgICA9IGRlc2Muc3RhdF9kZXNjLmV4dHJhX2Jhc2U7XG4gIHZhciBtYXhfbGVuZ3RoICAgICAgPSBkZXNjLnN0YXRfZGVzYy5tYXhfbGVuZ3RoO1xuICB2YXIgaDsgICAgICAgICAgICAgIC8qIGhlYXAgaW5kZXggKi9cbiAgdmFyIG4sIG07ICAgICAgICAgICAvKiBpdGVyYXRlIG92ZXIgdGhlIHRyZWUgZWxlbWVudHMgKi9cbiAgdmFyIGJpdHM7ICAgICAgICAgICAvKiBiaXQgbGVuZ3RoICovXG4gIHZhciB4Yml0czsgICAgICAgICAgLyogZXh0cmEgYml0cyAqL1xuICB2YXIgZjsgICAgICAgICAgICAgIC8qIGZyZXF1ZW5jeSAqL1xuICB2YXIgb3ZlcmZsb3cgPSAwOyAgIC8qIG51bWJlciBvZiBlbGVtZW50cyB3aXRoIGJpdCBsZW5ndGggdG9vIGxhcmdlICovXG5cbiAgZm9yIChiaXRzID0gMDsgYml0cyA8PSBNQVhfQklUUzsgYml0cysrKSB7XG4gICAgcy5ibF9jb3VudFtiaXRzXSA9IDA7XG4gIH1cblxuICAvKiBJbiBhIGZpcnN0IHBhc3MsIGNvbXB1dGUgdGhlIG9wdGltYWwgYml0IGxlbmd0aHMgKHdoaWNoIG1heVxuICAgKiBvdmVyZmxvdyBpbiB0aGUgY2FzZSBvZiB0aGUgYml0IGxlbmd0aCB0cmVlKS5cbiAgICovXG4gIHRyZWVbcy5oZWFwW3MuaGVhcF9tYXhdICogMiArIDFdLyouTGVuKi8gPSAwOyAvKiByb290IG9mIHRoZSBoZWFwICovXG5cbiAgZm9yIChoID0gcy5oZWFwX21heCArIDE7IGggPCBIRUFQX1NJWkU7IGgrKykge1xuICAgIG4gPSBzLmhlYXBbaF07XG4gICAgYml0cyA9IHRyZWVbdHJlZVtuICogMiArIDFdLyouRGFkKi8gKiAyICsgMV0vKi5MZW4qLyArIDE7XG4gICAgaWYgKGJpdHMgPiBtYXhfbGVuZ3RoKSB7XG4gICAgICBiaXRzID0gbWF4X2xlbmd0aDtcbiAgICAgIG92ZXJmbG93Kys7XG4gICAgfVxuICAgIHRyZWVbbiAqIDIgKyAxXS8qLkxlbiovID0gYml0cztcbiAgICAvKiBXZSBvdmVyd3JpdGUgdHJlZVtuXS5EYWQgd2hpY2ggaXMgbm8gbG9uZ2VyIG5lZWRlZCAqL1xuXG4gICAgaWYgKG4gPiBtYXhfY29kZSkgeyBjb250aW51ZTsgfSAvKiBub3QgYSBsZWFmIG5vZGUgKi9cblxuICAgIHMuYmxfY291bnRbYml0c10rKztcbiAgICB4Yml0cyA9IDA7XG4gICAgaWYgKG4gPj0gYmFzZSkge1xuICAgICAgeGJpdHMgPSBleHRyYVtuIC0gYmFzZV07XG4gICAgfVxuICAgIGYgPSB0cmVlW24gKiAyXS8qLkZyZXEqLztcbiAgICBzLm9wdF9sZW4gKz0gZiAqIChiaXRzICsgeGJpdHMpO1xuICAgIGlmIChoYXNfc3RyZWUpIHtcbiAgICAgIHMuc3RhdGljX2xlbiArPSBmICogKHN0cmVlW24gKiAyICsgMV0vKi5MZW4qLyArIHhiaXRzKTtcbiAgICB9XG4gIH1cbiAgaWYgKG92ZXJmbG93ID09PSAwKSB7IHJldHVybjsgfVxuXG4gIC8vIFRyYWNlKChzdGRlcnIsXCJcXG5iaXQgbGVuZ3RoIG92ZXJmbG93XFxuXCIpKTtcbiAgLyogVGhpcyBoYXBwZW5zIGZvciBleGFtcGxlIG9uIG9iajIgYW5kIHBpYyBvZiB0aGUgQ2FsZ2FyeSBjb3JwdXMgKi9cblxuICAvKiBGaW5kIHRoZSBmaXJzdCBiaXQgbGVuZ3RoIHdoaWNoIGNvdWxkIGluY3JlYXNlOiAqL1xuICBkbyB7XG4gICAgYml0cyA9IG1heF9sZW5ndGggLSAxO1xuICAgIHdoaWxlIChzLmJsX2NvdW50W2JpdHNdID09PSAwKSB7IGJpdHMtLTsgfVxuICAgIHMuYmxfY291bnRbYml0c10tLTsgICAgICAvKiBtb3ZlIG9uZSBsZWFmIGRvd24gdGhlIHRyZWUgKi9cbiAgICBzLmJsX2NvdW50W2JpdHMgKyAxXSArPSAyOyAvKiBtb3ZlIG9uZSBvdmVyZmxvdyBpdGVtIGFzIGl0cyBicm90aGVyICovXG4gICAgcy5ibF9jb3VudFttYXhfbGVuZ3RoXS0tO1xuICAgIC8qIFRoZSBicm90aGVyIG9mIHRoZSBvdmVyZmxvdyBpdGVtIGFsc28gbW92ZXMgb25lIHN0ZXAgdXAsXG4gICAgICogYnV0IHRoaXMgZG9lcyBub3QgYWZmZWN0IGJsX2NvdW50W21heF9sZW5ndGhdXG4gICAgICovXG4gICAgb3ZlcmZsb3cgLT0gMjtcbiAgfSB3aGlsZSAob3ZlcmZsb3cgPiAwKTtcblxuICAvKiBOb3cgcmVjb21wdXRlIGFsbCBiaXQgbGVuZ3Rocywgc2Nhbm5pbmcgaW4gaW5jcmVhc2luZyBmcmVxdWVuY3kuXG4gICAqIGggaXMgc3RpbGwgZXF1YWwgdG8gSEVBUF9TSVpFLiAoSXQgaXMgc2ltcGxlciB0byByZWNvbnN0cnVjdCBhbGxcbiAgICogbGVuZ3RocyBpbnN0ZWFkIG9mIGZpeGluZyBvbmx5IHRoZSB3cm9uZyBvbmVzLiBUaGlzIGlkZWEgaXMgdGFrZW5cbiAgICogZnJvbSAnYXInIHdyaXR0ZW4gYnkgSGFydWhpa28gT2t1bXVyYS4pXG4gICAqL1xuICBmb3IgKGJpdHMgPSBtYXhfbGVuZ3RoOyBiaXRzICE9PSAwOyBiaXRzLS0pIHtcbiAgICBuID0gcy5ibF9jb3VudFtiaXRzXTtcbiAgICB3aGlsZSAobiAhPT0gMCkge1xuICAgICAgbSA9IHMuaGVhcFstLWhdO1xuICAgICAgaWYgKG0gPiBtYXhfY29kZSkgeyBjb250aW51ZTsgfVxuICAgICAgaWYgKHRyZWVbbSAqIDIgKyAxXS8qLkxlbiovICE9PSBiaXRzKSB7XG4gICAgICAgIC8vIFRyYWNlKChzdGRlcnIsXCJjb2RlICVkIGJpdHMgJWQtPiVkXFxuXCIsIG0sIHRyZWVbbV0uTGVuLCBiaXRzKSk7XG4gICAgICAgIHMub3B0X2xlbiArPSAoYml0cyAtIHRyZWVbbSAqIDIgKyAxXS8qLkxlbiovKSAqIHRyZWVbbSAqIDJdLyouRnJlcSovO1xuICAgICAgICB0cmVlW20gKiAyICsgMV0vKi5MZW4qLyA9IGJpdHM7XG4gICAgICB9XG4gICAgICBuLS07XG4gICAgfVxuICB9XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBHZW5lcmF0ZSB0aGUgY29kZXMgZm9yIGEgZ2l2ZW4gdHJlZSBhbmQgYml0IGNvdW50cyAod2hpY2ggbmVlZCBub3QgYmVcbiAqIG9wdGltYWwpLlxuICogSU4gYXNzZXJ0aW9uOiB0aGUgYXJyYXkgYmxfY291bnQgY29udGFpbnMgdGhlIGJpdCBsZW5ndGggc3RhdGlzdGljcyBmb3JcbiAqIHRoZSBnaXZlbiB0cmVlIGFuZCB0aGUgZmllbGQgbGVuIGlzIHNldCBmb3IgYWxsIHRyZWUgZWxlbWVudHMuXG4gKiBPVVQgYXNzZXJ0aW9uOiB0aGUgZmllbGQgY29kZSBpcyBzZXQgZm9yIGFsbCB0cmVlIGVsZW1lbnRzIG9mIG5vblxuICogICAgIHplcm8gY29kZSBsZW5ndGguXG4gKi9cbmZ1bmN0aW9uIGdlbl9jb2Rlcyh0cmVlLCBtYXhfY29kZSwgYmxfY291bnQpXG4vLyAgICBjdF9kYXRhICp0cmVlOyAgICAgICAgICAgICAvKiB0aGUgdHJlZSB0byBkZWNvcmF0ZSAqL1xuLy8gICAgaW50IG1heF9jb2RlOyAgICAgICAgICAgICAgLyogbGFyZ2VzdCBjb2RlIHdpdGggbm9uIHplcm8gZnJlcXVlbmN5ICovXG4vLyAgICB1c2hmICpibF9jb3VudDsgICAgICAgICAgICAvKiBudW1iZXIgb2YgY29kZXMgYXQgZWFjaCBiaXQgbGVuZ3RoICovXG57XG4gIHZhciBuZXh0X2NvZGUgPSBuZXcgQXJyYXkoTUFYX0JJVFMgKyAxKTsgLyogbmV4dCBjb2RlIHZhbHVlIGZvciBlYWNoIGJpdCBsZW5ndGggKi9cbiAgdmFyIGNvZGUgPSAwOyAgICAgICAgICAgICAgLyogcnVubmluZyBjb2RlIHZhbHVlICovXG4gIHZhciBiaXRzOyAgICAgICAgICAgICAgICAgIC8qIGJpdCBpbmRleCAqL1xuICB2YXIgbjsgICAgICAgICAgICAgICAgICAgICAvKiBjb2RlIGluZGV4ICovXG5cbiAgLyogVGhlIGRpc3RyaWJ1dGlvbiBjb3VudHMgYXJlIGZpcnN0IHVzZWQgdG8gZ2VuZXJhdGUgdGhlIGNvZGUgdmFsdWVzXG4gICAqIHdpdGhvdXQgYml0IHJldmVyc2FsLlxuICAgKi9cbiAgZm9yIChiaXRzID0gMTsgYml0cyA8PSBNQVhfQklUUzsgYml0cysrKSB7XG4gICAgbmV4dF9jb2RlW2JpdHNdID0gY29kZSA9IChjb2RlICsgYmxfY291bnRbYml0cyAtIDFdKSA8PCAxO1xuICB9XG4gIC8qIENoZWNrIHRoYXQgdGhlIGJpdCBjb3VudHMgaW4gYmxfY291bnQgYXJlIGNvbnNpc3RlbnQuIFRoZSBsYXN0IGNvZGVcbiAgICogbXVzdCBiZSBhbGwgb25lcy5cbiAgICovXG4gIC8vQXNzZXJ0IChjb2RlICsgYmxfY291bnRbTUFYX0JJVFNdLTEgPT0gKDE8PE1BWF9CSVRTKS0xLFxuICAvLyAgICAgICAgXCJpbmNvbnNpc3RlbnQgYml0IGNvdW50c1wiKTtcbiAgLy9UcmFjZXYoKHN0ZGVycixcIlxcbmdlbl9jb2RlczogbWF4X2NvZGUgJWQgXCIsIG1heF9jb2RlKSk7XG5cbiAgZm9yIChuID0gMDsgIG4gPD0gbWF4X2NvZGU7IG4rKykge1xuICAgIHZhciBsZW4gPSB0cmVlW24gKiAyICsgMV0vKi5MZW4qLztcbiAgICBpZiAobGVuID09PSAwKSB7IGNvbnRpbnVlOyB9XG4gICAgLyogTm93IHJldmVyc2UgdGhlIGJpdHMgKi9cbiAgICB0cmVlW24gKiAyXS8qLkNvZGUqLyA9IGJpX3JldmVyc2UobmV4dF9jb2RlW2xlbl0rKywgbGVuKTtcblxuICAgIC8vVHJhY2Vjdih0cmVlICE9IHN0YXRpY19sdHJlZSwgKHN0ZGVycixcIlxcbm4gJTNkICVjIGwgJTJkIGMgJTR4ICgleCkgXCIsXG4gICAgLy8gICAgIG4sIChpc2dyYXBoKG4pID8gbiA6ICcgJyksIGxlbiwgdHJlZVtuXS5Db2RlLCBuZXh0X2NvZGVbbGVuXS0xKSk7XG4gIH1cbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEluaXRpYWxpemUgdGhlIHZhcmlvdXMgJ2NvbnN0YW50JyB0YWJsZXMuXG4gKi9cbmZ1bmN0aW9uIHRyX3N0YXRpY19pbml0KCkge1xuICB2YXIgbjsgICAgICAgIC8qIGl0ZXJhdGVzIG92ZXIgdHJlZSBlbGVtZW50cyAqL1xuICB2YXIgYml0czsgICAgIC8qIGJpdCBjb3VudGVyICovXG4gIHZhciBsZW5ndGg7ICAgLyogbGVuZ3RoIHZhbHVlICovXG4gIHZhciBjb2RlOyAgICAgLyogY29kZSB2YWx1ZSAqL1xuICB2YXIgZGlzdDsgICAgIC8qIGRpc3RhbmNlIGluZGV4ICovXG4gIHZhciBibF9jb3VudCA9IG5ldyBBcnJheShNQVhfQklUUyArIDEpO1xuICAvKiBudW1iZXIgb2YgY29kZXMgYXQgZWFjaCBiaXQgbGVuZ3RoIGZvciBhbiBvcHRpbWFsIHRyZWUgKi9cblxuICAvLyBkbyBjaGVjayBpbiBfdHJfaW5pdCgpXG4gIC8vaWYgKHN0YXRpY19pbml0X2RvbmUpIHJldHVybjtcblxuICAvKiBGb3Igc29tZSBlbWJlZGRlZCB0YXJnZXRzLCBnbG9iYWwgdmFyaWFibGVzIGFyZSBub3QgaW5pdGlhbGl6ZWQ6ICovXG4vKiNpZmRlZiBOT19JTklUX0dMT0JBTF9QT0lOVEVSU1xuICBzdGF0aWNfbF9kZXNjLnN0YXRpY190cmVlID0gc3RhdGljX2x0cmVlO1xuICBzdGF0aWNfbF9kZXNjLmV4dHJhX2JpdHMgPSBleHRyYV9sYml0cztcbiAgc3RhdGljX2RfZGVzYy5zdGF0aWNfdHJlZSA9IHN0YXRpY19kdHJlZTtcbiAgc3RhdGljX2RfZGVzYy5leHRyYV9iaXRzID0gZXh0cmFfZGJpdHM7XG4gIHN0YXRpY19ibF9kZXNjLmV4dHJhX2JpdHMgPSBleHRyYV9ibGJpdHM7XG4jZW5kaWYqL1xuXG4gIC8qIEluaXRpYWxpemUgdGhlIG1hcHBpbmcgbGVuZ3RoICgwLi4yNTUpIC0+IGxlbmd0aCBjb2RlICgwLi4yOCkgKi9cbiAgbGVuZ3RoID0gMDtcbiAgZm9yIChjb2RlID0gMDsgY29kZSA8IExFTkdUSF9DT0RFUyAtIDE7IGNvZGUrKykge1xuICAgIGJhc2VfbGVuZ3RoW2NvZGVdID0gbGVuZ3RoO1xuICAgIGZvciAobiA9IDA7IG4gPCAoMSA8PCBleHRyYV9sYml0c1tjb2RlXSk7IG4rKykge1xuICAgICAgX2xlbmd0aF9jb2RlW2xlbmd0aCsrXSA9IGNvZGU7XG4gICAgfVxuICB9XG4gIC8vQXNzZXJ0IChsZW5ndGggPT0gMjU2LCBcInRyX3N0YXRpY19pbml0OiBsZW5ndGggIT0gMjU2XCIpO1xuICAvKiBOb3RlIHRoYXQgdGhlIGxlbmd0aCAyNTUgKG1hdGNoIGxlbmd0aCAyNTgpIGNhbiBiZSByZXByZXNlbnRlZFxuICAgKiBpbiB0d28gZGlmZmVyZW50IHdheXM6IGNvZGUgMjg0ICsgNSBiaXRzIG9yIGNvZGUgMjg1LCBzbyB3ZVxuICAgKiBvdmVyd3JpdGUgbGVuZ3RoX2NvZGVbMjU1XSB0byB1c2UgdGhlIGJlc3QgZW5jb2Rpbmc6XG4gICAqL1xuICBfbGVuZ3RoX2NvZGVbbGVuZ3RoIC0gMV0gPSBjb2RlO1xuXG4gIC8qIEluaXRpYWxpemUgdGhlIG1hcHBpbmcgZGlzdCAoMC4uMzJLKSAtPiBkaXN0IGNvZGUgKDAuLjI5KSAqL1xuICBkaXN0ID0gMDtcbiAgZm9yIChjb2RlID0gMDsgY29kZSA8IDE2OyBjb2RlKyspIHtcbiAgICBiYXNlX2Rpc3RbY29kZV0gPSBkaXN0O1xuICAgIGZvciAobiA9IDA7IG4gPCAoMSA8PCBleHRyYV9kYml0c1tjb2RlXSk7IG4rKykge1xuICAgICAgX2Rpc3RfY29kZVtkaXN0KytdID0gY29kZTtcbiAgICB9XG4gIH1cbiAgLy9Bc3NlcnQgKGRpc3QgPT0gMjU2LCBcInRyX3N0YXRpY19pbml0OiBkaXN0ICE9IDI1NlwiKTtcbiAgZGlzdCA+Pj0gNzsgLyogZnJvbSBub3cgb24sIGFsbCBkaXN0YW5jZXMgYXJlIGRpdmlkZWQgYnkgMTI4ICovXG4gIGZvciAoOyBjb2RlIDwgRF9DT0RFUzsgY29kZSsrKSB7XG4gICAgYmFzZV9kaXN0W2NvZGVdID0gZGlzdCA8PCA3O1xuICAgIGZvciAobiA9IDA7IG4gPCAoMSA8PCAoZXh0cmFfZGJpdHNbY29kZV0gLSA3KSk7IG4rKykge1xuICAgICAgX2Rpc3RfY29kZVsyNTYgKyBkaXN0KytdID0gY29kZTtcbiAgICB9XG4gIH1cbiAgLy9Bc3NlcnQgKGRpc3QgPT0gMjU2LCBcInRyX3N0YXRpY19pbml0OiAyNTYrZGlzdCAhPSA1MTJcIik7XG5cbiAgLyogQ29uc3RydWN0IHRoZSBjb2RlcyBvZiB0aGUgc3RhdGljIGxpdGVyYWwgdHJlZSAqL1xuICBmb3IgKGJpdHMgPSAwOyBiaXRzIDw9IE1BWF9CSVRTOyBiaXRzKyspIHtcbiAgICBibF9jb3VudFtiaXRzXSA9IDA7XG4gIH1cblxuICBuID0gMDtcbiAgd2hpbGUgKG4gPD0gMTQzKSB7XG4gICAgc3RhdGljX2x0cmVlW24gKiAyICsgMV0vKi5MZW4qLyA9IDg7XG4gICAgbisrO1xuICAgIGJsX2NvdW50WzhdKys7XG4gIH1cbiAgd2hpbGUgKG4gPD0gMjU1KSB7XG4gICAgc3RhdGljX2x0cmVlW24gKiAyICsgMV0vKi5MZW4qLyA9IDk7XG4gICAgbisrO1xuICAgIGJsX2NvdW50WzldKys7XG4gIH1cbiAgd2hpbGUgKG4gPD0gMjc5KSB7XG4gICAgc3RhdGljX2x0cmVlW24gKiAyICsgMV0vKi5MZW4qLyA9IDc7XG4gICAgbisrO1xuICAgIGJsX2NvdW50WzddKys7XG4gIH1cbiAgd2hpbGUgKG4gPD0gMjg3KSB7XG4gICAgc3RhdGljX2x0cmVlW24gKiAyICsgMV0vKi5MZW4qLyA9IDg7XG4gICAgbisrO1xuICAgIGJsX2NvdW50WzhdKys7XG4gIH1cbiAgLyogQ29kZXMgMjg2IGFuZCAyODcgZG8gbm90IGV4aXN0LCBidXQgd2UgbXVzdCBpbmNsdWRlIHRoZW0gaW4gdGhlXG4gICAqIHRyZWUgY29uc3RydWN0aW9uIHRvIGdldCBhIGNhbm9uaWNhbCBIdWZmbWFuIHRyZWUgKGxvbmdlc3QgY29kZVxuICAgKiBhbGwgb25lcylcbiAgICovXG4gIGdlbl9jb2RlcyhzdGF0aWNfbHRyZWUsIExfQ09ERVMgKyAxLCBibF9jb3VudCk7XG5cbiAgLyogVGhlIHN0YXRpYyBkaXN0YW5jZSB0cmVlIGlzIHRyaXZpYWw6ICovXG4gIGZvciAobiA9IDA7IG4gPCBEX0NPREVTOyBuKyspIHtcbiAgICBzdGF0aWNfZHRyZWVbbiAqIDIgKyAxXS8qLkxlbiovID0gNTtcbiAgICBzdGF0aWNfZHRyZWVbbiAqIDJdLyouQ29kZSovID0gYmlfcmV2ZXJzZShuLCA1KTtcbiAgfVxuXG4gIC8vIE5vdyBkYXRhIHJlYWR5IGFuZCB3ZSBjYW4gaW5pdCBzdGF0aWMgdHJlZXNcbiAgc3RhdGljX2xfZGVzYyA9IG5ldyBTdGF0aWNUcmVlRGVzYyhzdGF0aWNfbHRyZWUsIGV4dHJhX2xiaXRzLCBMSVRFUkFMUyArIDEsIExfQ09ERVMsIE1BWF9CSVRTKTtcbiAgc3RhdGljX2RfZGVzYyA9IG5ldyBTdGF0aWNUcmVlRGVzYyhzdGF0aWNfZHRyZWUsIGV4dHJhX2RiaXRzLCAwLCAgICAgICAgICBEX0NPREVTLCBNQVhfQklUUyk7XG4gIHN0YXRpY19ibF9kZXNjID0gbmV3IFN0YXRpY1RyZWVEZXNjKG5ldyBBcnJheSgwKSwgZXh0cmFfYmxiaXRzLCAwLCAgICAgICAgIEJMX0NPREVTLCBNQVhfQkxfQklUUyk7XG5cbiAgLy9zdGF0aWNfaW5pdF9kb25lID0gdHJ1ZTtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEluaXRpYWxpemUgYSBuZXcgYmxvY2suXG4gKi9cbmZ1bmN0aW9uIGluaXRfYmxvY2socykge1xuICB2YXIgbjsgLyogaXRlcmF0ZXMgb3ZlciB0cmVlIGVsZW1lbnRzICovXG5cbiAgLyogSW5pdGlhbGl6ZSB0aGUgdHJlZXMuICovXG4gIGZvciAobiA9IDA7IG4gPCBMX0NPREVTOyAgbisrKSB7IHMuZHluX2x0cmVlW24gKiAyXS8qLkZyZXEqLyA9IDA7IH1cbiAgZm9yIChuID0gMDsgbiA8IERfQ09ERVM7ICBuKyspIHsgcy5keW5fZHRyZWVbbiAqIDJdLyouRnJlcSovID0gMDsgfVxuICBmb3IgKG4gPSAwOyBuIDwgQkxfQ09ERVM7IG4rKykgeyBzLmJsX3RyZWVbbiAqIDJdLyouRnJlcSovID0gMDsgfVxuXG4gIHMuZHluX2x0cmVlW0VORF9CTE9DSyAqIDJdLyouRnJlcSovID0gMTtcbiAgcy5vcHRfbGVuID0gcy5zdGF0aWNfbGVuID0gMDtcbiAgcy5sYXN0X2xpdCA9IHMubWF0Y2hlcyA9IDA7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBGbHVzaCB0aGUgYml0IGJ1ZmZlciBhbmQgYWxpZ24gdGhlIG91dHB1dCBvbiBhIGJ5dGUgYm91bmRhcnlcbiAqL1xuZnVuY3Rpb24gYmlfd2luZHVwKHMpXG57XG4gIGlmIChzLmJpX3ZhbGlkID4gOCkge1xuICAgIHB1dF9zaG9ydChzLCBzLmJpX2J1Zik7XG4gIH0gZWxzZSBpZiAocy5iaV92YWxpZCA+IDApIHtcbiAgICAvL3B1dF9ieXRlKHMsIChCeXRlKXMtPmJpX2J1Zik7XG4gICAgcy5wZW5kaW5nX2J1ZltzLnBlbmRpbmcrK10gPSBzLmJpX2J1ZjtcbiAgfVxuICBzLmJpX2J1ZiA9IDA7XG4gIHMuYmlfdmFsaWQgPSAwO1xufVxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvcHkgYSBzdG9yZWQgYmxvY2ssIHN0b3JpbmcgZmlyc3QgdGhlIGxlbmd0aCBhbmQgaXRzXG4gKiBvbmUncyBjb21wbGVtZW50IGlmIHJlcXVlc3RlZC5cbiAqL1xuZnVuY3Rpb24gY29weV9ibG9jayhzLCBidWYsIGxlbiwgaGVhZGVyKVxuLy9EZWZsYXRlU3RhdGUgKnM7XG4vL2NoYXJmICAgICpidWY7ICAgIC8qIHRoZSBpbnB1dCBkYXRhICovXG4vL3Vuc2lnbmVkIGxlbjsgICAgIC8qIGl0cyBsZW5ndGggKi9cbi8vaW50ICAgICAgaGVhZGVyOyAgLyogdHJ1ZSBpZiBibG9jayBoZWFkZXIgbXVzdCBiZSB3cml0dGVuICovXG57XG4gIGJpX3dpbmR1cChzKTsgICAgICAgIC8qIGFsaWduIG9uIGJ5dGUgYm91bmRhcnkgKi9cblxuICBpZiAoaGVhZGVyKSB7XG4gICAgcHV0X3Nob3J0KHMsIGxlbik7XG4gICAgcHV0X3Nob3J0KHMsIH5sZW4pO1xuICB9XG4vLyAgd2hpbGUgKGxlbi0tKSB7XG4vLyAgICBwdXRfYnl0ZShzLCAqYnVmKyspO1xuLy8gIH1cbiAgdXRpbHMuYXJyYXlTZXQocy5wZW5kaW5nX2J1Ziwgcy53aW5kb3csIGJ1ZiwgbGVuLCBzLnBlbmRpbmcpO1xuICBzLnBlbmRpbmcgKz0gbGVuO1xufVxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvbXBhcmVzIHRvIHN1YnRyZWVzLCB1c2luZyB0aGUgdHJlZSBkZXB0aCBhcyB0aWUgYnJlYWtlciB3aGVuXG4gKiB0aGUgc3VidHJlZXMgaGF2ZSBlcXVhbCBmcmVxdWVuY3kuIFRoaXMgbWluaW1pemVzIHRoZSB3b3JzdCBjYXNlIGxlbmd0aC5cbiAqL1xuZnVuY3Rpb24gc21hbGxlcih0cmVlLCBuLCBtLCBkZXB0aCkge1xuICB2YXIgX24yID0gbiAqIDI7XG4gIHZhciBfbTIgPSBtICogMjtcbiAgcmV0dXJuICh0cmVlW19uMl0vKi5GcmVxKi8gPCB0cmVlW19tMl0vKi5GcmVxKi8gfHxcbiAgICAgICAgICh0cmVlW19uMl0vKi5GcmVxKi8gPT09IHRyZWVbX20yXS8qLkZyZXEqLyAmJiBkZXB0aFtuXSA8PSBkZXB0aFttXSkpO1xufVxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFJlc3RvcmUgdGhlIGhlYXAgcHJvcGVydHkgYnkgbW92aW5nIGRvd24gdGhlIHRyZWUgc3RhcnRpbmcgYXQgbm9kZSBrLFxuICogZXhjaGFuZ2luZyBhIG5vZGUgd2l0aCB0aGUgc21hbGxlc3Qgb2YgaXRzIHR3byBzb25zIGlmIG5lY2Vzc2FyeSwgc3RvcHBpbmdcbiAqIHdoZW4gdGhlIGhlYXAgcHJvcGVydHkgaXMgcmUtZXN0YWJsaXNoZWQgKGVhY2ggZmF0aGVyIHNtYWxsZXIgdGhhbiBpdHNcbiAqIHR3byBzb25zKS5cbiAqL1xuZnVuY3Rpb24gcHFkb3duaGVhcChzLCB0cmVlLCBrKVxuLy8gICAgZGVmbGF0ZV9zdGF0ZSAqcztcbi8vICAgIGN0X2RhdGEgKnRyZWU7ICAvKiB0aGUgdHJlZSB0byByZXN0b3JlICovXG4vLyAgICBpbnQgazsgICAgICAgICAgICAgICAvKiBub2RlIHRvIG1vdmUgZG93biAqL1xue1xuICB2YXIgdiA9IHMuaGVhcFtrXTtcbiAgdmFyIGogPSBrIDw8IDE7ICAvKiBsZWZ0IHNvbiBvZiBrICovXG4gIHdoaWxlIChqIDw9IHMuaGVhcF9sZW4pIHtcbiAgICAvKiBTZXQgaiB0byB0aGUgc21hbGxlc3Qgb2YgdGhlIHR3byBzb25zOiAqL1xuICAgIGlmIChqIDwgcy5oZWFwX2xlbiAmJlxuICAgICAgc21hbGxlcih0cmVlLCBzLmhlYXBbaiArIDFdLCBzLmhlYXBbal0sIHMuZGVwdGgpKSB7XG4gICAgICBqKys7XG4gICAgfVxuICAgIC8qIEV4aXQgaWYgdiBpcyBzbWFsbGVyIHRoYW4gYm90aCBzb25zICovXG4gICAgaWYgKHNtYWxsZXIodHJlZSwgdiwgcy5oZWFwW2pdLCBzLmRlcHRoKSkgeyBicmVhazsgfVxuXG4gICAgLyogRXhjaGFuZ2UgdiB3aXRoIHRoZSBzbWFsbGVzdCBzb24gKi9cbiAgICBzLmhlYXBba10gPSBzLmhlYXBbal07XG4gICAgayA9IGo7XG5cbiAgICAvKiBBbmQgY29udGludWUgZG93biB0aGUgdHJlZSwgc2V0dGluZyBqIHRvIHRoZSBsZWZ0IHNvbiBvZiBrICovXG4gICAgaiA8PD0gMTtcbiAgfVxuICBzLmhlYXBba10gPSB2O1xufVxuXG5cbi8vIGlubGluZWQgbWFudWFsbHlcbi8vIHZhciBTTUFMTEVTVCA9IDE7XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2VuZCB0aGUgYmxvY2sgZGF0YSBjb21wcmVzc2VkIHVzaW5nIHRoZSBnaXZlbiBIdWZmbWFuIHRyZWVzXG4gKi9cbmZ1bmN0aW9uIGNvbXByZXNzX2Jsb2NrKHMsIGx0cmVlLCBkdHJlZSlcbi8vICAgIGRlZmxhdGVfc3RhdGUgKnM7XG4vLyAgICBjb25zdCBjdF9kYXRhICpsdHJlZTsgLyogbGl0ZXJhbCB0cmVlICovXG4vLyAgICBjb25zdCBjdF9kYXRhICpkdHJlZTsgLyogZGlzdGFuY2UgdHJlZSAqL1xue1xuICB2YXIgZGlzdDsgICAgICAgICAgIC8qIGRpc3RhbmNlIG9mIG1hdGNoZWQgc3RyaW5nICovXG4gIHZhciBsYzsgICAgICAgICAgICAgLyogbWF0Y2ggbGVuZ3RoIG9yIHVubWF0Y2hlZCBjaGFyIChpZiBkaXN0ID09IDApICovXG4gIHZhciBseCA9IDA7ICAgICAgICAgLyogcnVubmluZyBpbmRleCBpbiBsX2J1ZiAqL1xuICB2YXIgY29kZTsgICAgICAgICAgIC8qIHRoZSBjb2RlIHRvIHNlbmQgKi9cbiAgdmFyIGV4dHJhOyAgICAgICAgICAvKiBudW1iZXIgb2YgZXh0cmEgYml0cyB0byBzZW5kICovXG5cbiAgaWYgKHMubGFzdF9saXQgIT09IDApIHtcbiAgICBkbyB7XG4gICAgICBkaXN0ID0gKHMucGVuZGluZ19idWZbcy5kX2J1ZiArIGx4ICogMl0gPDwgOCkgfCAocy5wZW5kaW5nX2J1ZltzLmRfYnVmICsgbHggKiAyICsgMV0pO1xuICAgICAgbGMgPSBzLnBlbmRpbmdfYnVmW3MubF9idWYgKyBseF07XG4gICAgICBseCsrO1xuXG4gICAgICBpZiAoZGlzdCA9PT0gMCkge1xuICAgICAgICBzZW5kX2NvZGUocywgbGMsIGx0cmVlKTsgLyogc2VuZCBhIGxpdGVyYWwgYnl0ZSAqL1xuICAgICAgICAvL1RyYWNlY3YoaXNncmFwaChsYyksIChzdGRlcnIsXCIgJyVjJyBcIiwgbGMpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8qIEhlcmUsIGxjIGlzIHRoZSBtYXRjaCBsZW5ndGggLSBNSU5fTUFUQ0ggKi9cbiAgICAgICAgY29kZSA9IF9sZW5ndGhfY29kZVtsY107XG4gICAgICAgIHNlbmRfY29kZShzLCBjb2RlICsgTElURVJBTFMgKyAxLCBsdHJlZSk7IC8qIHNlbmQgdGhlIGxlbmd0aCBjb2RlICovXG4gICAgICAgIGV4dHJhID0gZXh0cmFfbGJpdHNbY29kZV07XG4gICAgICAgIGlmIChleHRyYSAhPT0gMCkge1xuICAgICAgICAgIGxjIC09IGJhc2VfbGVuZ3RoW2NvZGVdO1xuICAgICAgICAgIHNlbmRfYml0cyhzLCBsYywgZXh0cmEpOyAgICAgICAvKiBzZW5kIHRoZSBleHRyYSBsZW5ndGggYml0cyAqL1xuICAgICAgICB9XG4gICAgICAgIGRpc3QtLTsgLyogZGlzdCBpcyBub3cgdGhlIG1hdGNoIGRpc3RhbmNlIC0gMSAqL1xuICAgICAgICBjb2RlID0gZF9jb2RlKGRpc3QpO1xuICAgICAgICAvL0Fzc2VydCAoY29kZSA8IERfQ09ERVMsIFwiYmFkIGRfY29kZVwiKTtcblxuICAgICAgICBzZW5kX2NvZGUocywgY29kZSwgZHRyZWUpOyAgICAgICAvKiBzZW5kIHRoZSBkaXN0YW5jZSBjb2RlICovXG4gICAgICAgIGV4dHJhID0gZXh0cmFfZGJpdHNbY29kZV07XG4gICAgICAgIGlmIChleHRyYSAhPT0gMCkge1xuICAgICAgICAgIGRpc3QgLT0gYmFzZV9kaXN0W2NvZGVdO1xuICAgICAgICAgIHNlbmRfYml0cyhzLCBkaXN0LCBleHRyYSk7ICAgLyogc2VuZCB0aGUgZXh0cmEgZGlzdGFuY2UgYml0cyAqL1xuICAgICAgICB9XG4gICAgICB9IC8qIGxpdGVyYWwgb3IgbWF0Y2ggcGFpciA/ICovXG5cbiAgICAgIC8qIENoZWNrIHRoYXQgdGhlIG92ZXJsYXkgYmV0d2VlbiBwZW5kaW5nX2J1ZiBhbmQgZF9idWYrbF9idWYgaXMgb2s6ICovXG4gICAgICAvL0Fzc2VydCgodUludCkocy0+cGVuZGluZykgPCBzLT5saXRfYnVmc2l6ZSArIDIqbHgsXG4gICAgICAvLyAgICAgICBcInBlbmRpbmdCdWYgb3ZlcmZsb3dcIik7XG5cbiAgICB9IHdoaWxlIChseCA8IHMubGFzdF9saXQpO1xuICB9XG5cbiAgc2VuZF9jb2RlKHMsIEVORF9CTE9DSywgbHRyZWUpO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29uc3RydWN0IG9uZSBIdWZmbWFuIHRyZWUgYW5kIGFzc2lnbnMgdGhlIGNvZGUgYml0IHN0cmluZ3MgYW5kIGxlbmd0aHMuXG4gKiBVcGRhdGUgdGhlIHRvdGFsIGJpdCBsZW5ndGggZm9yIHRoZSBjdXJyZW50IGJsb2NrLlxuICogSU4gYXNzZXJ0aW9uOiB0aGUgZmllbGQgZnJlcSBpcyBzZXQgZm9yIGFsbCB0cmVlIGVsZW1lbnRzLlxuICogT1VUIGFzc2VydGlvbnM6IHRoZSBmaWVsZHMgbGVuIGFuZCBjb2RlIGFyZSBzZXQgdG8gdGhlIG9wdGltYWwgYml0IGxlbmd0aFxuICogICAgIGFuZCBjb3JyZXNwb25kaW5nIGNvZGUuIFRoZSBsZW5ndGggb3B0X2xlbiBpcyB1cGRhdGVkOyBzdGF0aWNfbGVuIGlzXG4gKiAgICAgYWxzbyB1cGRhdGVkIGlmIHN0cmVlIGlzIG5vdCBudWxsLiBUaGUgZmllbGQgbWF4X2NvZGUgaXMgc2V0LlxuICovXG5mdW5jdGlvbiBidWlsZF90cmVlKHMsIGRlc2MpXG4vLyAgICBkZWZsYXRlX3N0YXRlICpzO1xuLy8gICAgdHJlZV9kZXNjICpkZXNjOyAvKiB0aGUgdHJlZSBkZXNjcmlwdG9yICovXG57XG4gIHZhciB0cmVlICAgICA9IGRlc2MuZHluX3RyZWU7XG4gIHZhciBzdHJlZSAgICA9IGRlc2Muc3RhdF9kZXNjLnN0YXRpY190cmVlO1xuICB2YXIgaGFzX3N0cmVlID0gZGVzYy5zdGF0X2Rlc2MuaGFzX3N0cmVlO1xuICB2YXIgZWxlbXMgICAgPSBkZXNjLnN0YXRfZGVzYy5lbGVtcztcbiAgdmFyIG4sIG07ICAgICAgICAgIC8qIGl0ZXJhdGUgb3ZlciBoZWFwIGVsZW1lbnRzICovXG4gIHZhciBtYXhfY29kZSA9IC0xOyAvKiBsYXJnZXN0IGNvZGUgd2l0aCBub24gemVybyBmcmVxdWVuY3kgKi9cbiAgdmFyIG5vZGU7ICAgICAgICAgIC8qIG5ldyBub2RlIGJlaW5nIGNyZWF0ZWQgKi9cblxuICAvKiBDb25zdHJ1Y3QgdGhlIGluaXRpYWwgaGVhcCwgd2l0aCBsZWFzdCBmcmVxdWVudCBlbGVtZW50IGluXG4gICAqIGhlYXBbU01BTExFU1RdLiBUaGUgc29ucyBvZiBoZWFwW25dIGFyZSBoZWFwWzIqbl0gYW5kIGhlYXBbMipuKzFdLlxuICAgKiBoZWFwWzBdIGlzIG5vdCB1c2VkLlxuICAgKi9cbiAgcy5oZWFwX2xlbiA9IDA7XG4gIHMuaGVhcF9tYXggPSBIRUFQX1NJWkU7XG5cbiAgZm9yIChuID0gMDsgbiA8IGVsZW1zOyBuKyspIHtcbiAgICBpZiAodHJlZVtuICogMl0vKi5GcmVxKi8gIT09IDApIHtcbiAgICAgIHMuaGVhcFsrK3MuaGVhcF9sZW5dID0gbWF4X2NvZGUgPSBuO1xuICAgICAgcy5kZXB0aFtuXSA9IDA7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgdHJlZVtuICogMiArIDFdLyouTGVuKi8gPSAwO1xuICAgIH1cbiAgfVxuXG4gIC8qIFRoZSBwa3ppcCBmb3JtYXQgcmVxdWlyZXMgdGhhdCBhdCBsZWFzdCBvbmUgZGlzdGFuY2UgY29kZSBleGlzdHMsXG4gICAqIGFuZCB0aGF0IGF0IGxlYXN0IG9uZSBiaXQgc2hvdWxkIGJlIHNlbnQgZXZlbiBpZiB0aGVyZSBpcyBvbmx5IG9uZVxuICAgKiBwb3NzaWJsZSBjb2RlLiBTbyB0byBhdm9pZCBzcGVjaWFsIGNoZWNrcyBsYXRlciBvbiB3ZSBmb3JjZSBhdCBsZWFzdFxuICAgKiB0d28gY29kZXMgb2Ygbm9uIHplcm8gZnJlcXVlbmN5LlxuICAgKi9cbiAgd2hpbGUgKHMuaGVhcF9sZW4gPCAyKSB7XG4gICAgbm9kZSA9IHMuaGVhcFsrK3MuaGVhcF9sZW5dID0gKG1heF9jb2RlIDwgMiA/ICsrbWF4X2NvZGUgOiAwKTtcbiAgICB0cmVlW25vZGUgKiAyXS8qLkZyZXEqLyA9IDE7XG4gICAgcy5kZXB0aFtub2RlXSA9IDA7XG4gICAgcy5vcHRfbGVuLS07XG5cbiAgICBpZiAoaGFzX3N0cmVlKSB7XG4gICAgICBzLnN0YXRpY19sZW4gLT0gc3RyZWVbbm9kZSAqIDIgKyAxXS8qLkxlbiovO1xuICAgIH1cbiAgICAvKiBub2RlIGlzIDAgb3IgMSBzbyBpdCBkb2VzIG5vdCBoYXZlIGV4dHJhIGJpdHMgKi9cbiAgfVxuICBkZXNjLm1heF9jb2RlID0gbWF4X2NvZGU7XG5cbiAgLyogVGhlIGVsZW1lbnRzIGhlYXBbaGVhcF9sZW4vMisxIC4uIGhlYXBfbGVuXSBhcmUgbGVhdmVzIG9mIHRoZSB0cmVlLFxuICAgKiBlc3RhYmxpc2ggc3ViLWhlYXBzIG9mIGluY3JlYXNpbmcgbGVuZ3RoczpcbiAgICovXG4gIGZvciAobiA9IChzLmhlYXBfbGVuID4+IDEvKmludCAvMiovKTsgbiA+PSAxOyBuLS0pIHsgcHFkb3duaGVhcChzLCB0cmVlLCBuKTsgfVxuXG4gIC8qIENvbnN0cnVjdCB0aGUgSHVmZm1hbiB0cmVlIGJ5IHJlcGVhdGVkbHkgY29tYmluaW5nIHRoZSBsZWFzdCB0d29cbiAgICogZnJlcXVlbnQgbm9kZXMuXG4gICAqL1xuICBub2RlID0gZWxlbXM7ICAgICAgICAgICAgICAvKiBuZXh0IGludGVybmFsIG5vZGUgb2YgdGhlIHRyZWUgKi9cbiAgZG8ge1xuICAgIC8vcHFyZW1vdmUocywgdHJlZSwgbik7ICAvKiBuID0gbm9kZSBvZiBsZWFzdCBmcmVxdWVuY3kgKi9cbiAgICAvKioqIHBxcmVtb3ZlICoqKi9cbiAgICBuID0gcy5oZWFwWzEvKlNNQUxMRVNUKi9dO1xuICAgIHMuaGVhcFsxLypTTUFMTEVTVCovXSA9IHMuaGVhcFtzLmhlYXBfbGVuLS1dO1xuICAgIHBxZG93bmhlYXAocywgdHJlZSwgMS8qU01BTExFU1QqLyk7XG4gICAgLyoqKi9cblxuICAgIG0gPSBzLmhlYXBbMS8qU01BTExFU1QqL107IC8qIG0gPSBub2RlIG9mIG5leHQgbGVhc3QgZnJlcXVlbmN5ICovXG5cbiAgICBzLmhlYXBbLS1zLmhlYXBfbWF4XSA9IG47IC8qIGtlZXAgdGhlIG5vZGVzIHNvcnRlZCBieSBmcmVxdWVuY3kgKi9cbiAgICBzLmhlYXBbLS1zLmhlYXBfbWF4XSA9IG07XG5cbiAgICAvKiBDcmVhdGUgYSBuZXcgbm9kZSBmYXRoZXIgb2YgbiBhbmQgbSAqL1xuICAgIHRyZWVbbm9kZSAqIDJdLyouRnJlcSovID0gdHJlZVtuICogMl0vKi5GcmVxKi8gKyB0cmVlW20gKiAyXS8qLkZyZXEqLztcbiAgICBzLmRlcHRoW25vZGVdID0gKHMuZGVwdGhbbl0gPj0gcy5kZXB0aFttXSA/IHMuZGVwdGhbbl0gOiBzLmRlcHRoW21dKSArIDE7XG4gICAgdHJlZVtuICogMiArIDFdLyouRGFkKi8gPSB0cmVlW20gKiAyICsgMV0vKi5EYWQqLyA9IG5vZGU7XG5cbiAgICAvKiBhbmQgaW5zZXJ0IHRoZSBuZXcgbm9kZSBpbiB0aGUgaGVhcCAqL1xuICAgIHMuaGVhcFsxLypTTUFMTEVTVCovXSA9IG5vZGUrKztcbiAgICBwcWRvd25oZWFwKHMsIHRyZWUsIDEvKlNNQUxMRVNUKi8pO1xuXG4gIH0gd2hpbGUgKHMuaGVhcF9sZW4gPj0gMik7XG5cbiAgcy5oZWFwWy0tcy5oZWFwX21heF0gPSBzLmhlYXBbMS8qU01BTExFU1QqL107XG5cbiAgLyogQXQgdGhpcyBwb2ludCwgdGhlIGZpZWxkcyBmcmVxIGFuZCBkYWQgYXJlIHNldC4gV2UgY2FuIG5vd1xuICAgKiBnZW5lcmF0ZSB0aGUgYml0IGxlbmd0aHMuXG4gICAqL1xuICBnZW5fYml0bGVuKHMsIGRlc2MpO1xuXG4gIC8qIFRoZSBmaWVsZCBsZW4gaXMgbm93IHNldCwgd2UgY2FuIGdlbmVyYXRlIHRoZSBiaXQgY29kZXMgKi9cbiAgZ2VuX2NvZGVzKHRyZWUsIG1heF9jb2RlLCBzLmJsX2NvdW50KTtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNjYW4gYSBsaXRlcmFsIG9yIGRpc3RhbmNlIHRyZWUgdG8gZGV0ZXJtaW5lIHRoZSBmcmVxdWVuY2llcyBvZiB0aGUgY29kZXNcbiAqIGluIHRoZSBiaXQgbGVuZ3RoIHRyZWUuXG4gKi9cbmZ1bmN0aW9uIHNjYW5fdHJlZShzLCB0cmVlLCBtYXhfY29kZSlcbi8vICAgIGRlZmxhdGVfc3RhdGUgKnM7XG4vLyAgICBjdF9kYXRhICp0cmVlOyAgIC8qIHRoZSB0cmVlIHRvIGJlIHNjYW5uZWQgKi9cbi8vICAgIGludCBtYXhfY29kZTsgICAgLyogYW5kIGl0cyBsYXJnZXN0IGNvZGUgb2Ygbm9uIHplcm8gZnJlcXVlbmN5ICovXG57XG4gIHZhciBuOyAgICAgICAgICAgICAgICAgICAgIC8qIGl0ZXJhdGVzIG92ZXIgYWxsIHRyZWUgZWxlbWVudHMgKi9cbiAgdmFyIHByZXZsZW4gPSAtMTsgICAgICAgICAgLyogbGFzdCBlbWl0dGVkIGxlbmd0aCAqL1xuICB2YXIgY3VybGVuOyAgICAgICAgICAgICAgICAvKiBsZW5ndGggb2YgY3VycmVudCBjb2RlICovXG5cbiAgdmFyIG5leHRsZW4gPSB0cmVlWzAgKiAyICsgMV0vKi5MZW4qLzsgLyogbGVuZ3RoIG9mIG5leHQgY29kZSAqL1xuXG4gIHZhciBjb3VudCA9IDA7ICAgICAgICAgICAgIC8qIHJlcGVhdCBjb3VudCBvZiB0aGUgY3VycmVudCBjb2RlICovXG4gIHZhciBtYXhfY291bnQgPSA3OyAgICAgICAgIC8qIG1heCByZXBlYXQgY291bnQgKi9cbiAgdmFyIG1pbl9jb3VudCA9IDQ7ICAgICAgICAgLyogbWluIHJlcGVhdCBjb3VudCAqL1xuXG4gIGlmIChuZXh0bGVuID09PSAwKSB7XG4gICAgbWF4X2NvdW50ID0gMTM4O1xuICAgIG1pbl9jb3VudCA9IDM7XG4gIH1cbiAgdHJlZVsobWF4X2NvZGUgKyAxKSAqIDIgKyAxXS8qLkxlbiovID0gMHhmZmZmOyAvKiBndWFyZCAqL1xuXG4gIGZvciAobiA9IDA7IG4gPD0gbWF4X2NvZGU7IG4rKykge1xuICAgIGN1cmxlbiA9IG5leHRsZW47XG4gICAgbmV4dGxlbiA9IHRyZWVbKG4gKyAxKSAqIDIgKyAxXS8qLkxlbiovO1xuXG4gICAgaWYgKCsrY291bnQgPCBtYXhfY291bnQgJiYgY3VybGVuID09PSBuZXh0bGVuKSB7XG4gICAgICBjb250aW51ZTtcblxuICAgIH0gZWxzZSBpZiAoY291bnQgPCBtaW5fY291bnQpIHtcbiAgICAgIHMuYmxfdHJlZVtjdXJsZW4gKiAyXS8qLkZyZXEqLyArPSBjb3VudDtcblxuICAgIH0gZWxzZSBpZiAoY3VybGVuICE9PSAwKSB7XG5cbiAgICAgIGlmIChjdXJsZW4gIT09IHByZXZsZW4pIHsgcy5ibF90cmVlW2N1cmxlbiAqIDJdLyouRnJlcSovKys7IH1cbiAgICAgIHMuYmxfdHJlZVtSRVBfM182ICogMl0vKi5GcmVxKi8rKztcblxuICAgIH0gZWxzZSBpZiAoY291bnQgPD0gMTApIHtcbiAgICAgIHMuYmxfdHJlZVtSRVBaXzNfMTAgKiAyXS8qLkZyZXEqLysrO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIHMuYmxfdHJlZVtSRVBaXzExXzEzOCAqIDJdLyouRnJlcSovKys7XG4gICAgfVxuXG4gICAgY291bnQgPSAwO1xuICAgIHByZXZsZW4gPSBjdXJsZW47XG5cbiAgICBpZiAobmV4dGxlbiA9PT0gMCkge1xuICAgICAgbWF4X2NvdW50ID0gMTM4O1xuICAgICAgbWluX2NvdW50ID0gMztcblxuICAgIH0gZWxzZSBpZiAoY3VybGVuID09PSBuZXh0bGVuKSB7XG4gICAgICBtYXhfY291bnQgPSA2O1xuICAgICAgbWluX2NvdW50ID0gMztcblxuICAgIH0gZWxzZSB7XG4gICAgICBtYXhfY291bnQgPSA3O1xuICAgICAgbWluX2NvdW50ID0gNDtcbiAgICB9XG4gIH1cbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNlbmQgYSBsaXRlcmFsIG9yIGRpc3RhbmNlIHRyZWUgaW4gY29tcHJlc3NlZCBmb3JtLCB1c2luZyB0aGUgY29kZXMgaW5cbiAqIGJsX3RyZWUuXG4gKi9cbmZ1bmN0aW9uIHNlbmRfdHJlZShzLCB0cmVlLCBtYXhfY29kZSlcbi8vICAgIGRlZmxhdGVfc3RhdGUgKnM7XG4vLyAgICBjdF9kYXRhICp0cmVlOyAvKiB0aGUgdHJlZSB0byBiZSBzY2FubmVkICovXG4vLyAgICBpbnQgbWF4X2NvZGU7ICAgICAgIC8qIGFuZCBpdHMgbGFyZ2VzdCBjb2RlIG9mIG5vbiB6ZXJvIGZyZXF1ZW5jeSAqL1xue1xuICB2YXIgbjsgICAgICAgICAgICAgICAgICAgICAvKiBpdGVyYXRlcyBvdmVyIGFsbCB0cmVlIGVsZW1lbnRzICovXG4gIHZhciBwcmV2bGVuID0gLTE7ICAgICAgICAgIC8qIGxhc3QgZW1pdHRlZCBsZW5ndGggKi9cbiAgdmFyIGN1cmxlbjsgICAgICAgICAgICAgICAgLyogbGVuZ3RoIG9mIGN1cnJlbnQgY29kZSAqL1xuXG4gIHZhciBuZXh0bGVuID0gdHJlZVswICogMiArIDFdLyouTGVuKi87IC8qIGxlbmd0aCBvZiBuZXh0IGNvZGUgKi9cblxuICB2YXIgY291bnQgPSAwOyAgICAgICAgICAgICAvKiByZXBlYXQgY291bnQgb2YgdGhlIGN1cnJlbnQgY29kZSAqL1xuICB2YXIgbWF4X2NvdW50ID0gNzsgICAgICAgICAvKiBtYXggcmVwZWF0IGNvdW50ICovXG4gIHZhciBtaW5fY291bnQgPSA0OyAgICAgICAgIC8qIG1pbiByZXBlYXQgY291bnQgKi9cblxuICAvKiB0cmVlW21heF9jb2RlKzFdLkxlbiA9IC0xOyAqLyAgLyogZ3VhcmQgYWxyZWFkeSBzZXQgKi9cbiAgaWYgKG5leHRsZW4gPT09IDApIHtcbiAgICBtYXhfY291bnQgPSAxMzg7XG4gICAgbWluX2NvdW50ID0gMztcbiAgfVxuXG4gIGZvciAobiA9IDA7IG4gPD0gbWF4X2NvZGU7IG4rKykge1xuICAgIGN1cmxlbiA9IG5leHRsZW47XG4gICAgbmV4dGxlbiA9IHRyZWVbKG4gKyAxKSAqIDIgKyAxXS8qLkxlbiovO1xuXG4gICAgaWYgKCsrY291bnQgPCBtYXhfY291bnQgJiYgY3VybGVuID09PSBuZXh0bGVuKSB7XG4gICAgICBjb250aW51ZTtcblxuICAgIH0gZWxzZSBpZiAoY291bnQgPCBtaW5fY291bnQpIHtcbiAgICAgIGRvIHsgc2VuZF9jb2RlKHMsIGN1cmxlbiwgcy5ibF90cmVlKTsgfSB3aGlsZSAoLS1jb3VudCAhPT0gMCk7XG5cbiAgICB9IGVsc2UgaWYgKGN1cmxlbiAhPT0gMCkge1xuICAgICAgaWYgKGN1cmxlbiAhPT0gcHJldmxlbikge1xuICAgICAgICBzZW5kX2NvZGUocywgY3VybGVuLCBzLmJsX3RyZWUpO1xuICAgICAgICBjb3VudC0tO1xuICAgICAgfVxuICAgICAgLy9Bc3NlcnQoY291bnQgPj0gMyAmJiBjb3VudCA8PSA2LCBcIiAzXzY/XCIpO1xuICAgICAgc2VuZF9jb2RlKHMsIFJFUF8zXzYsIHMuYmxfdHJlZSk7XG4gICAgICBzZW5kX2JpdHMocywgY291bnQgLSAzLCAyKTtcblxuICAgIH0gZWxzZSBpZiAoY291bnQgPD0gMTApIHtcbiAgICAgIHNlbmRfY29kZShzLCBSRVBaXzNfMTAsIHMuYmxfdHJlZSk7XG4gICAgICBzZW5kX2JpdHMocywgY291bnQgLSAzLCAzKTtcblxuICAgIH0gZWxzZSB7XG4gICAgICBzZW5kX2NvZGUocywgUkVQWl8xMV8xMzgsIHMuYmxfdHJlZSk7XG4gICAgICBzZW5kX2JpdHMocywgY291bnQgLSAxMSwgNyk7XG4gICAgfVxuXG4gICAgY291bnQgPSAwO1xuICAgIHByZXZsZW4gPSBjdXJsZW47XG4gICAgaWYgKG5leHRsZW4gPT09IDApIHtcbiAgICAgIG1heF9jb3VudCA9IDEzODtcbiAgICAgIG1pbl9jb3VudCA9IDM7XG5cbiAgICB9IGVsc2UgaWYgKGN1cmxlbiA9PT0gbmV4dGxlbikge1xuICAgICAgbWF4X2NvdW50ID0gNjtcbiAgICAgIG1pbl9jb3VudCA9IDM7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgbWF4X2NvdW50ID0gNztcbiAgICAgIG1pbl9jb3VudCA9IDQ7XG4gICAgfVxuICB9XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb25zdHJ1Y3QgdGhlIEh1ZmZtYW4gdHJlZSBmb3IgdGhlIGJpdCBsZW5ndGhzIGFuZCByZXR1cm4gdGhlIGluZGV4IGluXG4gKiBibF9vcmRlciBvZiB0aGUgbGFzdCBiaXQgbGVuZ3RoIGNvZGUgdG8gc2VuZC5cbiAqL1xuZnVuY3Rpb24gYnVpbGRfYmxfdHJlZShzKSB7XG4gIHZhciBtYXhfYmxpbmRleDsgIC8qIGluZGV4IG9mIGxhc3QgYml0IGxlbmd0aCBjb2RlIG9mIG5vbiB6ZXJvIGZyZXEgKi9cblxuICAvKiBEZXRlcm1pbmUgdGhlIGJpdCBsZW5ndGggZnJlcXVlbmNpZXMgZm9yIGxpdGVyYWwgYW5kIGRpc3RhbmNlIHRyZWVzICovXG4gIHNjYW5fdHJlZShzLCBzLmR5bl9sdHJlZSwgcy5sX2Rlc2MubWF4X2NvZGUpO1xuICBzY2FuX3RyZWUocywgcy5keW5fZHRyZWUsIHMuZF9kZXNjLm1heF9jb2RlKTtcblxuICAvKiBCdWlsZCB0aGUgYml0IGxlbmd0aCB0cmVlOiAqL1xuICBidWlsZF90cmVlKHMsIHMuYmxfZGVzYyk7XG4gIC8qIG9wdF9sZW4gbm93IGluY2x1ZGVzIHRoZSBsZW5ndGggb2YgdGhlIHRyZWUgcmVwcmVzZW50YXRpb25zLCBleGNlcHRcbiAgICogdGhlIGxlbmd0aHMgb2YgdGhlIGJpdCBsZW5ndGhzIGNvZGVzIGFuZCB0aGUgNSs1KzQgYml0cyBmb3IgdGhlIGNvdW50cy5cbiAgICovXG5cbiAgLyogRGV0ZXJtaW5lIHRoZSBudW1iZXIgb2YgYml0IGxlbmd0aCBjb2RlcyB0byBzZW5kLiBUaGUgcGt6aXAgZm9ybWF0XG4gICAqIHJlcXVpcmVzIHRoYXQgYXQgbGVhc3QgNCBiaXQgbGVuZ3RoIGNvZGVzIGJlIHNlbnQuIChhcHBub3RlLnR4dCBzYXlzXG4gICAqIDMgYnV0IHRoZSBhY3R1YWwgdmFsdWUgdXNlZCBpcyA0LilcbiAgICovXG4gIGZvciAobWF4X2JsaW5kZXggPSBCTF9DT0RFUyAtIDE7IG1heF9ibGluZGV4ID49IDM7IG1heF9ibGluZGV4LS0pIHtcbiAgICBpZiAocy5ibF90cmVlW2JsX29yZGVyW21heF9ibGluZGV4XSAqIDIgKyAxXS8qLkxlbiovICE9PSAwKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgLyogVXBkYXRlIG9wdF9sZW4gdG8gaW5jbHVkZSB0aGUgYml0IGxlbmd0aCB0cmVlIGFuZCBjb3VudHMgKi9cbiAgcy5vcHRfbGVuICs9IDMgKiAobWF4X2JsaW5kZXggKyAxKSArIDUgKyA1ICsgNDtcbiAgLy9UcmFjZXYoKHN0ZGVyciwgXCJcXG5keW4gdHJlZXM6IGR5biAlbGQsIHN0YXQgJWxkXCIsXG4gIC8vICAgICAgICBzLT5vcHRfbGVuLCBzLT5zdGF0aWNfbGVuKSk7XG5cbiAgcmV0dXJuIG1heF9ibGluZGV4O1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2VuZCB0aGUgaGVhZGVyIGZvciBhIGJsb2NrIHVzaW5nIGR5bmFtaWMgSHVmZm1hbiB0cmVlczogdGhlIGNvdW50cywgdGhlXG4gKiBsZW5ndGhzIG9mIHRoZSBiaXQgbGVuZ3RoIGNvZGVzLCB0aGUgbGl0ZXJhbCB0cmVlIGFuZCB0aGUgZGlzdGFuY2UgdHJlZS5cbiAqIElOIGFzc2VydGlvbjogbGNvZGVzID49IDI1NywgZGNvZGVzID49IDEsIGJsY29kZXMgPj0gNC5cbiAqL1xuZnVuY3Rpb24gc2VuZF9hbGxfdHJlZXMocywgbGNvZGVzLCBkY29kZXMsIGJsY29kZXMpXG4vLyAgICBkZWZsYXRlX3N0YXRlICpzO1xuLy8gICAgaW50IGxjb2RlcywgZGNvZGVzLCBibGNvZGVzOyAvKiBudW1iZXIgb2YgY29kZXMgZm9yIGVhY2ggdHJlZSAqL1xue1xuICB2YXIgcmFuazsgICAgICAgICAgICAgICAgICAgIC8qIGluZGV4IGluIGJsX29yZGVyICovXG5cbiAgLy9Bc3NlcnQgKGxjb2RlcyA+PSAyNTcgJiYgZGNvZGVzID49IDEgJiYgYmxjb2RlcyA+PSA0LCBcIm5vdCBlbm91Z2ggY29kZXNcIik7XG4gIC8vQXNzZXJ0IChsY29kZXMgPD0gTF9DT0RFUyAmJiBkY29kZXMgPD0gRF9DT0RFUyAmJiBibGNvZGVzIDw9IEJMX0NPREVTLFxuICAvLyAgICAgICAgXCJ0b28gbWFueSBjb2Rlc1wiKTtcbiAgLy9UcmFjZXYoKHN0ZGVyciwgXCJcXG5ibCBjb3VudHM6IFwiKSk7XG4gIHNlbmRfYml0cyhzLCBsY29kZXMgLSAyNTcsIDUpOyAvKiBub3QgKzI1NSBhcyBzdGF0ZWQgaW4gYXBwbm90ZS50eHQgKi9cbiAgc2VuZF9iaXRzKHMsIGRjb2RlcyAtIDEsICAgNSk7XG4gIHNlbmRfYml0cyhzLCBibGNvZGVzIC0gNCwgIDQpOyAvKiBub3QgLTMgYXMgc3RhdGVkIGluIGFwcG5vdGUudHh0ICovXG4gIGZvciAocmFuayA9IDA7IHJhbmsgPCBibGNvZGVzOyByYW5rKyspIHtcbiAgICAvL1RyYWNldigoc3RkZXJyLCBcIlxcbmJsIGNvZGUgJTJkIFwiLCBibF9vcmRlcltyYW5rXSkpO1xuICAgIHNlbmRfYml0cyhzLCBzLmJsX3RyZWVbYmxfb3JkZXJbcmFua10gKiAyICsgMV0vKi5MZW4qLywgMyk7XG4gIH1cbiAgLy9UcmFjZXYoKHN0ZGVyciwgXCJcXG5ibCB0cmVlOiBzZW50ICVsZFwiLCBzLT5iaXRzX3NlbnQpKTtcblxuICBzZW5kX3RyZWUocywgcy5keW5fbHRyZWUsIGxjb2RlcyAtIDEpOyAvKiBsaXRlcmFsIHRyZWUgKi9cbiAgLy9UcmFjZXYoKHN0ZGVyciwgXCJcXG5saXQgdHJlZTogc2VudCAlbGRcIiwgcy0+Yml0c19zZW50KSk7XG5cbiAgc2VuZF90cmVlKHMsIHMuZHluX2R0cmVlLCBkY29kZXMgLSAxKTsgLyogZGlzdGFuY2UgdHJlZSAqL1xuICAvL1RyYWNldigoc3RkZXJyLCBcIlxcbmRpc3QgdHJlZTogc2VudCAlbGRcIiwgcy0+Yml0c19zZW50KSk7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDaGVjayBpZiB0aGUgZGF0YSB0eXBlIGlzIFRFWFQgb3IgQklOQVJZLCB1c2luZyB0aGUgZm9sbG93aW5nIGFsZ29yaXRobTpcbiAqIC0gVEVYVCBpZiB0aGUgdHdvIGNvbmRpdGlvbnMgYmVsb3cgYXJlIHNhdGlzZmllZDpcbiAqICAgIGEpIFRoZXJlIGFyZSBubyBub24tcG9ydGFibGUgY29udHJvbCBjaGFyYWN0ZXJzIGJlbG9uZ2luZyB0byB0aGVcbiAqICAgICAgIFwiYmxhY2sgbGlzdFwiICgwLi42LCAxNC4uMjUsIDI4Li4zMSkuXG4gKiAgICBiKSBUaGVyZSBpcyBhdCBsZWFzdCBvbmUgcHJpbnRhYmxlIGNoYXJhY3RlciBiZWxvbmdpbmcgdG8gdGhlXG4gKiAgICAgICBcIndoaXRlIGxpc3RcIiAoOSB7VEFCfSwgMTAge0xGfSwgMTMge0NSfSwgMzIuLjI1NSkuXG4gKiAtIEJJTkFSWSBvdGhlcndpc2UuXG4gKiAtIFRoZSBmb2xsb3dpbmcgcGFydGlhbGx5LXBvcnRhYmxlIGNvbnRyb2wgY2hhcmFjdGVycyBmb3JtIGFcbiAqICAgXCJncmF5IGxpc3RcIiB0aGF0IGlzIGlnbm9yZWQgaW4gdGhpcyBkZXRlY3Rpb24gYWxnb3JpdGhtOlxuICogICAoNyB7QkVMfSwgOCB7QlN9LCAxMSB7VlR9LCAxMiB7RkZ9LCAyNiB7U1VCfSwgMjcge0VTQ30pLlxuICogSU4gYXNzZXJ0aW9uOiB0aGUgZmllbGRzIEZyZXEgb2YgZHluX2x0cmVlIGFyZSBzZXQuXG4gKi9cbmZ1bmN0aW9uIGRldGVjdF9kYXRhX3R5cGUocykge1xuICAvKiBibGFja19tYXNrIGlzIHRoZSBiaXQgbWFzayBvZiBibGFjay1saXN0ZWQgYnl0ZXNcbiAgICogc2V0IGJpdHMgMC4uNiwgMTQuLjI1LCBhbmQgMjguLjMxXG4gICAqIDB4ZjNmZmMwN2YgPSBiaW5hcnkgMTExMTAwMTExMTExMTExMTExMDAwMDAwMDExMTExMTFcbiAgICovXG4gIHZhciBibGFja19tYXNrID0gMHhmM2ZmYzA3ZjtcbiAgdmFyIG47XG5cbiAgLyogQ2hlY2sgZm9yIG5vbi10ZXh0dWFsIChcImJsYWNrLWxpc3RlZFwiKSBieXRlcy4gKi9cbiAgZm9yIChuID0gMDsgbiA8PSAzMTsgbisrLCBibGFja19tYXNrID4+Pj0gMSkge1xuICAgIGlmICgoYmxhY2tfbWFzayAmIDEpICYmIChzLmR5bl9sdHJlZVtuICogMl0vKi5GcmVxKi8gIT09IDApKSB7XG4gICAgICByZXR1cm4gWl9CSU5BUlk7XG4gICAgfVxuICB9XG5cbiAgLyogQ2hlY2sgZm9yIHRleHR1YWwgKFwid2hpdGUtbGlzdGVkXCIpIGJ5dGVzLiAqL1xuICBpZiAocy5keW5fbHRyZWVbOSAqIDJdLyouRnJlcSovICE9PSAwIHx8IHMuZHluX2x0cmVlWzEwICogMl0vKi5GcmVxKi8gIT09IDAgfHxcbiAgICAgIHMuZHluX2x0cmVlWzEzICogMl0vKi5GcmVxKi8gIT09IDApIHtcbiAgICByZXR1cm4gWl9URVhUO1xuICB9XG4gIGZvciAobiA9IDMyOyBuIDwgTElURVJBTFM7IG4rKykge1xuICAgIGlmIChzLmR5bl9sdHJlZVtuICogMl0vKi5GcmVxKi8gIT09IDApIHtcbiAgICAgIHJldHVybiBaX1RFWFQ7XG4gICAgfVxuICB9XG5cbiAgLyogVGhlcmUgYXJlIG5vIFwiYmxhY2stbGlzdGVkXCIgb3IgXCJ3aGl0ZS1saXN0ZWRcIiBieXRlczpcbiAgICogdGhpcyBzdHJlYW0gZWl0aGVyIGlzIGVtcHR5IG9yIGhhcyB0b2xlcmF0ZWQgKFwiZ3JheS1saXN0ZWRcIikgYnl0ZXMgb25seS5cbiAgICovXG4gIHJldHVybiBaX0JJTkFSWTtcbn1cblxuXG52YXIgc3RhdGljX2luaXRfZG9uZSA9IGZhbHNlO1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEluaXRpYWxpemUgdGhlIHRyZWUgZGF0YSBzdHJ1Y3R1cmVzIGZvciBhIG5ldyB6bGliIHN0cmVhbS5cbiAqL1xuZnVuY3Rpb24gX3RyX2luaXQocylcbntcblxuICBpZiAoIXN0YXRpY19pbml0X2RvbmUpIHtcbiAgICB0cl9zdGF0aWNfaW5pdCgpO1xuICAgIHN0YXRpY19pbml0X2RvbmUgPSB0cnVlO1xuICB9XG5cbiAgcy5sX2Rlc2MgID0gbmV3IFRyZWVEZXNjKHMuZHluX2x0cmVlLCBzdGF0aWNfbF9kZXNjKTtcbiAgcy5kX2Rlc2MgID0gbmV3IFRyZWVEZXNjKHMuZHluX2R0cmVlLCBzdGF0aWNfZF9kZXNjKTtcbiAgcy5ibF9kZXNjID0gbmV3IFRyZWVEZXNjKHMuYmxfdHJlZSwgc3RhdGljX2JsX2Rlc2MpO1xuXG4gIHMuYmlfYnVmID0gMDtcbiAgcy5iaV92YWxpZCA9IDA7XG5cbiAgLyogSW5pdGlhbGl6ZSB0aGUgZmlyc3QgYmxvY2sgb2YgdGhlIGZpcnN0IGZpbGU6ICovXG4gIGluaXRfYmxvY2socyk7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTZW5kIGEgc3RvcmVkIGJsb2NrXG4gKi9cbmZ1bmN0aW9uIF90cl9zdG9yZWRfYmxvY2socywgYnVmLCBzdG9yZWRfbGVuLCBsYXN0KVxuLy9EZWZsYXRlU3RhdGUgKnM7XG4vL2NoYXJmICpidWY7ICAgICAgIC8qIGlucHV0IGJsb2NrICovXG4vL3VsZyBzdG9yZWRfbGVuOyAgIC8qIGxlbmd0aCBvZiBpbnB1dCBibG9jayAqL1xuLy9pbnQgbGFzdDsgICAgICAgICAvKiBvbmUgaWYgdGhpcyBpcyB0aGUgbGFzdCBibG9jayBmb3IgYSBmaWxlICovXG57XG4gIHNlbmRfYml0cyhzLCAoU1RPUkVEX0JMT0NLIDw8IDEpICsgKGxhc3QgPyAxIDogMCksIDMpOyAgICAvKiBzZW5kIGJsb2NrIHR5cGUgKi9cbiAgY29weV9ibG9jayhzLCBidWYsIHN0b3JlZF9sZW4sIHRydWUpOyAvKiB3aXRoIGhlYWRlciAqL1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2VuZCBvbmUgZW1wdHkgc3RhdGljIGJsb2NrIHRvIGdpdmUgZW5vdWdoIGxvb2thaGVhZCBmb3IgaW5mbGF0ZS5cbiAqIFRoaXMgdGFrZXMgMTAgYml0cywgb2Ygd2hpY2ggNyBtYXkgcmVtYWluIGluIHRoZSBiaXQgYnVmZmVyLlxuICovXG5mdW5jdGlvbiBfdHJfYWxpZ24ocykge1xuICBzZW5kX2JpdHMocywgU1RBVElDX1RSRUVTIDw8IDEsIDMpO1xuICBzZW5kX2NvZGUocywgRU5EX0JMT0NLLCBzdGF0aWNfbHRyZWUpO1xuICBiaV9mbHVzaChzKTtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIERldGVybWluZSB0aGUgYmVzdCBlbmNvZGluZyBmb3IgdGhlIGN1cnJlbnQgYmxvY2s6IGR5bmFtaWMgdHJlZXMsIHN0YXRpY1xuICogdHJlZXMgb3Igc3RvcmUsIGFuZCBvdXRwdXQgdGhlIGVuY29kZWQgYmxvY2sgdG8gdGhlIHppcCBmaWxlLlxuICovXG5mdW5jdGlvbiBfdHJfZmx1c2hfYmxvY2socywgYnVmLCBzdG9yZWRfbGVuLCBsYXN0KVxuLy9EZWZsYXRlU3RhdGUgKnM7XG4vL2NoYXJmICpidWY7ICAgICAgIC8qIGlucHV0IGJsb2NrLCBvciBOVUxMIGlmIHRvbyBvbGQgKi9cbi8vdWxnIHN0b3JlZF9sZW47ICAgLyogbGVuZ3RoIG9mIGlucHV0IGJsb2NrICovXG4vL2ludCBsYXN0OyAgICAgICAgIC8qIG9uZSBpZiB0aGlzIGlzIHRoZSBsYXN0IGJsb2NrIGZvciBhIGZpbGUgKi9cbntcbiAgdmFyIG9wdF9sZW5iLCBzdGF0aWNfbGVuYjsgIC8qIG9wdF9sZW4gYW5kIHN0YXRpY19sZW4gaW4gYnl0ZXMgKi9cbiAgdmFyIG1heF9ibGluZGV4ID0gMDsgICAgICAgIC8qIGluZGV4IG9mIGxhc3QgYml0IGxlbmd0aCBjb2RlIG9mIG5vbiB6ZXJvIGZyZXEgKi9cblxuICAvKiBCdWlsZCB0aGUgSHVmZm1hbiB0cmVlcyB1bmxlc3MgYSBzdG9yZWQgYmxvY2sgaXMgZm9yY2VkICovXG4gIGlmIChzLmxldmVsID4gMCkge1xuXG4gICAgLyogQ2hlY2sgaWYgdGhlIGZpbGUgaXMgYmluYXJ5IG9yIHRleHQgKi9cbiAgICBpZiAocy5zdHJtLmRhdGFfdHlwZSA9PT0gWl9VTktOT1dOKSB7XG4gICAgICBzLnN0cm0uZGF0YV90eXBlID0gZGV0ZWN0X2RhdGFfdHlwZShzKTtcbiAgICB9XG5cbiAgICAvKiBDb25zdHJ1Y3QgdGhlIGxpdGVyYWwgYW5kIGRpc3RhbmNlIHRyZWVzICovXG4gICAgYnVpbGRfdHJlZShzLCBzLmxfZGVzYyk7XG4gICAgLy8gVHJhY2V2KChzdGRlcnIsIFwiXFxubGl0IGRhdGE6IGR5biAlbGQsIHN0YXQgJWxkXCIsIHMtPm9wdF9sZW4sXG4gICAgLy8gICAgICAgIHMtPnN0YXRpY19sZW4pKTtcblxuICAgIGJ1aWxkX3RyZWUocywgcy5kX2Rlc2MpO1xuICAgIC8vIFRyYWNldigoc3RkZXJyLCBcIlxcbmRpc3QgZGF0YTogZHluICVsZCwgc3RhdCAlbGRcIiwgcy0+b3B0X2xlbixcbiAgICAvLyAgICAgICAgcy0+c3RhdGljX2xlbikpO1xuICAgIC8qIEF0IHRoaXMgcG9pbnQsIG9wdF9sZW4gYW5kIHN0YXRpY19sZW4gYXJlIHRoZSB0b3RhbCBiaXQgbGVuZ3RocyBvZlxuICAgICAqIHRoZSBjb21wcmVzc2VkIGJsb2NrIGRhdGEsIGV4Y2x1ZGluZyB0aGUgdHJlZSByZXByZXNlbnRhdGlvbnMuXG4gICAgICovXG5cbiAgICAvKiBCdWlsZCB0aGUgYml0IGxlbmd0aCB0cmVlIGZvciB0aGUgYWJvdmUgdHdvIHRyZWVzLCBhbmQgZ2V0IHRoZSBpbmRleFxuICAgICAqIGluIGJsX29yZGVyIG9mIHRoZSBsYXN0IGJpdCBsZW5ndGggY29kZSB0byBzZW5kLlxuICAgICAqL1xuICAgIG1heF9ibGluZGV4ID0gYnVpbGRfYmxfdHJlZShzKTtcblxuICAgIC8qIERldGVybWluZSB0aGUgYmVzdCBlbmNvZGluZy4gQ29tcHV0ZSB0aGUgYmxvY2sgbGVuZ3RocyBpbiBieXRlcy4gKi9cbiAgICBvcHRfbGVuYiA9IChzLm9wdF9sZW4gKyAzICsgNykgPj4+IDM7XG4gICAgc3RhdGljX2xlbmIgPSAocy5zdGF0aWNfbGVuICsgMyArIDcpID4+PiAzO1xuXG4gICAgLy8gVHJhY2V2KChzdGRlcnIsIFwiXFxub3B0ICVsdSglbHUpIHN0YXQgJWx1KCVsdSkgc3RvcmVkICVsdSBsaXQgJXUgXCIsXG4gICAgLy8gICAgICAgIG9wdF9sZW5iLCBzLT5vcHRfbGVuLCBzdGF0aWNfbGVuYiwgcy0+c3RhdGljX2xlbiwgc3RvcmVkX2xlbixcbiAgICAvLyAgICAgICAgcy0+bGFzdF9saXQpKTtcblxuICAgIGlmIChzdGF0aWNfbGVuYiA8PSBvcHRfbGVuYikgeyBvcHRfbGVuYiA9IHN0YXRpY19sZW5iOyB9XG5cbiAgfSBlbHNlIHtcbiAgICAvLyBBc3NlcnQoYnVmICE9IChjaGFyKikwLCBcImxvc3QgYnVmXCIpO1xuICAgIG9wdF9sZW5iID0gc3RhdGljX2xlbmIgPSBzdG9yZWRfbGVuICsgNTsgLyogZm9yY2UgYSBzdG9yZWQgYmxvY2sgKi9cbiAgfVxuXG4gIGlmICgoc3RvcmVkX2xlbiArIDQgPD0gb3B0X2xlbmIpICYmIChidWYgIT09IC0xKSkge1xuICAgIC8qIDQ6IHR3byB3b3JkcyBmb3IgdGhlIGxlbmd0aHMgKi9cblxuICAgIC8qIFRoZSB0ZXN0IGJ1ZiAhPSBOVUxMIGlzIG9ubHkgbmVjZXNzYXJ5IGlmIExJVF9CVUZTSVpFID4gV1NJWkUuXG4gICAgICogT3RoZXJ3aXNlIHdlIGNhbid0IGhhdmUgcHJvY2Vzc2VkIG1vcmUgdGhhbiBXU0laRSBpbnB1dCBieXRlcyBzaW5jZVxuICAgICAqIHRoZSBsYXN0IGJsb2NrIGZsdXNoLCBiZWNhdXNlIGNvbXByZXNzaW9uIHdvdWxkIGhhdmUgYmVlblxuICAgICAqIHN1Y2Nlc3NmdWwuIElmIExJVF9CVUZTSVpFIDw9IFdTSVpFLCBpdCBpcyBuZXZlciB0b28gbGF0ZSB0b1xuICAgICAqIHRyYW5zZm9ybSBhIGJsb2NrIGludG8gYSBzdG9yZWQgYmxvY2suXG4gICAgICovXG4gICAgX3RyX3N0b3JlZF9ibG9jayhzLCBidWYsIHN0b3JlZF9sZW4sIGxhc3QpO1xuXG4gIH0gZWxzZSBpZiAocy5zdHJhdGVneSA9PT0gWl9GSVhFRCB8fCBzdGF0aWNfbGVuYiA9PT0gb3B0X2xlbmIpIHtcblxuICAgIHNlbmRfYml0cyhzLCAoU1RBVElDX1RSRUVTIDw8IDEpICsgKGxhc3QgPyAxIDogMCksIDMpO1xuICAgIGNvbXByZXNzX2Jsb2NrKHMsIHN0YXRpY19sdHJlZSwgc3RhdGljX2R0cmVlKTtcblxuICB9IGVsc2Uge1xuICAgIHNlbmRfYml0cyhzLCAoRFlOX1RSRUVTIDw8IDEpICsgKGxhc3QgPyAxIDogMCksIDMpO1xuICAgIHNlbmRfYWxsX3RyZWVzKHMsIHMubF9kZXNjLm1heF9jb2RlICsgMSwgcy5kX2Rlc2MubWF4X2NvZGUgKyAxLCBtYXhfYmxpbmRleCArIDEpO1xuICAgIGNvbXByZXNzX2Jsb2NrKHMsIHMuZHluX2x0cmVlLCBzLmR5bl9kdHJlZSk7XG4gIH1cbiAgLy8gQXNzZXJ0IChzLT5jb21wcmVzc2VkX2xlbiA9PSBzLT5iaXRzX3NlbnQsIFwiYmFkIGNvbXByZXNzZWQgc2l6ZVwiKTtcbiAgLyogVGhlIGFib3ZlIGNoZWNrIGlzIG1hZGUgbW9kIDJeMzIsIGZvciBmaWxlcyBsYXJnZXIgdGhhbiA1MTIgTUJcbiAgICogYW5kIHVMb25nIGltcGxlbWVudGVkIG9uIDMyIGJpdHMuXG4gICAqL1xuICBpbml0X2Jsb2NrKHMpO1xuXG4gIGlmIChsYXN0KSB7XG4gICAgYmlfd2luZHVwKHMpO1xuICB9XG4gIC8vIFRyYWNldigoc3RkZXJyLFwiXFxuY29tcHJsZW4gJWx1KCVsdSkgXCIsIHMtPmNvbXByZXNzZWRfbGVuPj4zLFxuICAvLyAgICAgICBzLT5jb21wcmVzc2VkX2xlbi03Kmxhc3QpKTtcbn1cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTYXZlIHRoZSBtYXRjaCBpbmZvIGFuZCB0YWxseSB0aGUgZnJlcXVlbmN5IGNvdW50cy4gUmV0dXJuIHRydWUgaWZcbiAqIHRoZSBjdXJyZW50IGJsb2NrIG11c3QgYmUgZmx1c2hlZC5cbiAqL1xuZnVuY3Rpb24gX3RyX3RhbGx5KHMsIGRpc3QsIGxjKVxuLy8gICAgZGVmbGF0ZV9zdGF0ZSAqcztcbi8vICAgIHVuc2lnbmVkIGRpc3Q7ICAvKiBkaXN0YW5jZSBvZiBtYXRjaGVkIHN0cmluZyAqL1xuLy8gICAgdW5zaWduZWQgbGM7ICAgIC8qIG1hdGNoIGxlbmd0aC1NSU5fTUFUQ0ggb3IgdW5tYXRjaGVkIGNoYXIgKGlmIGRpc3Q9PTApICovXG57XG4gIC8vdmFyIG91dF9sZW5ndGgsIGluX2xlbmd0aCwgZGNvZGU7XG5cbiAgcy5wZW5kaW5nX2J1ZltzLmRfYnVmICsgcy5sYXN0X2xpdCAqIDJdICAgICA9IChkaXN0ID4+PiA4KSAmIDB4ZmY7XG4gIHMucGVuZGluZ19idWZbcy5kX2J1ZiArIHMubGFzdF9saXQgKiAyICsgMV0gPSBkaXN0ICYgMHhmZjtcblxuICBzLnBlbmRpbmdfYnVmW3MubF9idWYgKyBzLmxhc3RfbGl0XSA9IGxjICYgMHhmZjtcbiAgcy5sYXN0X2xpdCsrO1xuXG4gIGlmIChkaXN0ID09PSAwKSB7XG4gICAgLyogbGMgaXMgdGhlIHVubWF0Y2hlZCBjaGFyICovXG4gICAgcy5keW5fbHRyZWVbbGMgKiAyXS8qLkZyZXEqLysrO1xuICB9IGVsc2Uge1xuICAgIHMubWF0Y2hlcysrO1xuICAgIC8qIEhlcmUsIGxjIGlzIHRoZSBtYXRjaCBsZW5ndGggLSBNSU5fTUFUQ0ggKi9cbiAgICBkaXN0LS07ICAgICAgICAgICAgIC8qIGRpc3QgPSBtYXRjaCBkaXN0YW5jZSAtIDEgKi9cbiAgICAvL0Fzc2VydCgodXNoKWRpc3QgPCAodXNoKU1BWF9ESVNUKHMpICYmXG4gICAgLy8gICAgICAgKHVzaClsYyA8PSAodXNoKShNQVhfTUFUQ0gtTUlOX01BVENIKSAmJlxuICAgIC8vICAgICAgICh1c2gpZF9jb2RlKGRpc3QpIDwgKHVzaClEX0NPREVTLCAgXCJfdHJfdGFsbHk6IGJhZCBtYXRjaFwiKTtcblxuICAgIHMuZHluX2x0cmVlWyhfbGVuZ3RoX2NvZGVbbGNdICsgTElURVJBTFMgKyAxKSAqIDJdLyouRnJlcSovKys7XG4gICAgcy5keW5fZHRyZWVbZF9jb2RlKGRpc3QpICogMl0vKi5GcmVxKi8rKztcbiAgfVxuXG4vLyAoISkgVGhpcyBibG9jayBpcyBkaXNhYmxlZCBpbiB6bGliIGRlZmFpbHRzLFxuLy8gZG9uJ3QgZW5hYmxlIGl0IGZvciBiaW5hcnkgY29tcGF0aWJpbGl0eVxuXG4vLyNpZmRlZiBUUlVOQ0FURV9CTE9DS1xuLy8gIC8qIFRyeSB0byBndWVzcyBpZiBpdCBpcyBwcm9maXRhYmxlIHRvIHN0b3AgdGhlIGN1cnJlbnQgYmxvY2sgaGVyZSAqL1xuLy8gIGlmICgocy5sYXN0X2xpdCAmIDB4MWZmZikgPT09IDAgJiYgcy5sZXZlbCA+IDIpIHtcbi8vICAgIC8qIENvbXB1dGUgYW4gdXBwZXIgYm91bmQgZm9yIHRoZSBjb21wcmVzc2VkIGxlbmd0aCAqL1xuLy8gICAgb3V0X2xlbmd0aCA9IHMubGFzdF9saXQqODtcbi8vICAgIGluX2xlbmd0aCA9IHMuc3Ryc3RhcnQgLSBzLmJsb2NrX3N0YXJ0O1xuLy9cbi8vICAgIGZvciAoZGNvZGUgPSAwOyBkY29kZSA8IERfQ09ERVM7IGRjb2RlKyspIHtcbi8vICAgICAgb3V0X2xlbmd0aCArPSBzLmR5bl9kdHJlZVtkY29kZSoyXS8qLkZyZXEqLyAqICg1ICsgZXh0cmFfZGJpdHNbZGNvZGVdKTtcbi8vICAgIH1cbi8vICAgIG91dF9sZW5ndGggPj4+PSAzO1xuLy8gICAgLy9UcmFjZXYoKHN0ZGVycixcIlxcbmxhc3RfbGl0ICV1LCBpbiAlbGQsIG91dCB+JWxkKCVsZCUlKSBcIixcbi8vICAgIC8vICAgICAgIHMtPmxhc3RfbGl0LCBpbl9sZW5ndGgsIG91dF9sZW5ndGgsXG4vLyAgICAvLyAgICAgICAxMDBMIC0gb3V0X2xlbmd0aCoxMDBML2luX2xlbmd0aCkpO1xuLy8gICAgaWYgKHMubWF0Y2hlcyA8IChzLmxhc3RfbGl0Pj4xKS8qaW50IC8yKi8gJiYgb3V0X2xlbmd0aCA8IChpbl9sZW5ndGg+PjEpLyppbnQgLzIqLykge1xuLy8gICAgICByZXR1cm4gdHJ1ZTtcbi8vICAgIH1cbi8vICB9XG4vLyNlbmRpZlxuXG4gIHJldHVybiAocy5sYXN0X2xpdCA9PT0gcy5saXRfYnVmc2l6ZSAtIDEpO1xuICAvKiBXZSBhdm9pZCBlcXVhbGl0eSB3aXRoIGxpdF9idWZzaXplIGJlY2F1c2Ugb2Ygd3JhcGFyb3VuZCBhdCA2NEtcbiAgICogb24gMTYgYml0IG1hY2hpbmVzIGFuZCBiZWNhdXNlIHN0b3JlZCBibG9ja3MgYXJlIHJlc3RyaWN0ZWQgdG9cbiAgICogNjRLLTEgYnl0ZXMuXG4gICAqL1xufVxuXG5leHBvcnRzLl90cl9pbml0ICA9IF90cl9pbml0O1xuZXhwb3J0cy5fdHJfc3RvcmVkX2Jsb2NrID0gX3RyX3N0b3JlZF9ibG9jaztcbmV4cG9ydHMuX3RyX2ZsdXNoX2Jsb2NrICA9IF90cl9mbHVzaF9ibG9jaztcbmV4cG9ydHMuX3RyX3RhbGx5ID0gX3RyX3RhbGx5O1xuZXhwb3J0cy5fdHJfYWxpZ24gPSBfdHJfYWxpZ247XG4iLCIndXNlIHN0cmljdCc7XG5cblxuZnVuY3Rpb24gWlN0cmVhbSgpIHtcbiAgLyogbmV4dCBpbnB1dCBieXRlICovXG4gIHRoaXMuaW5wdXQgPSBudWxsOyAvLyBKUyBzcGVjaWZpYywgYmVjYXVzZSB3ZSBoYXZlIG5vIHBvaW50ZXJzXG4gIHRoaXMubmV4dF9pbiA9IDA7XG4gIC8qIG51bWJlciBvZiBieXRlcyBhdmFpbGFibGUgYXQgaW5wdXQgKi9cbiAgdGhpcy5hdmFpbF9pbiA9IDA7XG4gIC8qIHRvdGFsIG51bWJlciBvZiBpbnB1dCBieXRlcyByZWFkIHNvIGZhciAqL1xuICB0aGlzLnRvdGFsX2luID0gMDtcbiAgLyogbmV4dCBvdXRwdXQgYnl0ZSBzaG91bGQgYmUgcHV0IHRoZXJlICovXG4gIHRoaXMub3V0cHV0ID0gbnVsbDsgLy8gSlMgc3BlY2lmaWMsIGJlY2F1c2Ugd2UgaGF2ZSBubyBwb2ludGVyc1xuICB0aGlzLm5leHRfb3V0ID0gMDtcbiAgLyogcmVtYWluaW5nIGZyZWUgc3BhY2UgYXQgb3V0cHV0ICovXG4gIHRoaXMuYXZhaWxfb3V0ID0gMDtcbiAgLyogdG90YWwgbnVtYmVyIG9mIGJ5dGVzIG91dHB1dCBzbyBmYXIgKi9cbiAgdGhpcy50b3RhbF9vdXQgPSAwO1xuICAvKiBsYXN0IGVycm9yIG1lc3NhZ2UsIE5VTEwgaWYgbm8gZXJyb3IgKi9cbiAgdGhpcy5tc2cgPSAnJy8qWl9OVUxMKi87XG4gIC8qIG5vdCB2aXNpYmxlIGJ5IGFwcGxpY2F0aW9ucyAqL1xuICB0aGlzLnN0YXRlID0gbnVsbDtcbiAgLyogYmVzdCBndWVzcyBhYm91dCB0aGUgZGF0YSB0eXBlOiBiaW5hcnkgb3IgdGV4dCAqL1xuICB0aGlzLmRhdGFfdHlwZSA9IDIvKlpfVU5LTk9XTiovO1xuICAvKiBhZGxlcjMyIHZhbHVlIG9mIHRoZSB1bmNvbXByZXNzZWQgZGF0YSAqL1xuICB0aGlzLmFkbGVyID0gMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBaU3RyZWFtO1xuIiwidmFyIG1zZyA9IHJlcXVpcmUoJ3Bha28vbGliL3psaWIvbWVzc2FnZXMnKTtcbnZhciB6c3RyZWFtID0gcmVxdWlyZSgncGFrby9saWIvemxpYi96c3RyZWFtJyk7XG52YXIgemxpYl9kZWZsYXRlID0gcmVxdWlyZSgncGFrby9saWIvemxpYi9kZWZsYXRlLmpzJyk7XG52YXIgemxpYl9pbmZsYXRlID0gcmVxdWlyZSgncGFrby9saWIvemxpYi9pbmZsYXRlLmpzJyk7XG52YXIgY29uc3RhbnRzID0gcmVxdWlyZSgncGFrby9saWIvemxpYi9jb25zdGFudHMnKTtcblxuZm9yICh2YXIga2V5IGluIGNvbnN0YW50cykge1xuICBleHBvcnRzW2tleV0gPSBjb25zdGFudHNba2V5XTtcbn1cblxuLy8gemxpYiBtb2Rlc1xuZXhwb3J0cy5OT05FID0gMDtcbmV4cG9ydHMuREVGTEFURSA9IDE7XG5leHBvcnRzLklORkxBVEUgPSAyO1xuZXhwb3J0cy5HWklQID0gMztcbmV4cG9ydHMuR1VOWklQID0gNDtcbmV4cG9ydHMuREVGTEFURVJBVyA9IDU7XG5leHBvcnRzLklORkxBVEVSQVcgPSA2O1xuZXhwb3J0cy5VTlpJUCA9IDc7XG5cbi8qKlxuICogRW11bGF0ZSBOb2RlJ3MgemxpYiBDKysgbGF5ZXIgZm9yIHVzZSBieSB0aGUgSlMgbGF5ZXIgaW4gaW5kZXguanNcbiAqL1xuZnVuY3Rpb24gWmxpYihtb2RlKSB7XG4gIGlmIChtb2RlIDwgZXhwb3J0cy5ERUZMQVRFIHx8IG1vZGUgPiBleHBvcnRzLlVOWklQKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJCYWQgYXJndW1lbnRcIik7XG4gICAgXG4gIHRoaXMubW9kZSA9IG1vZGU7XG4gIHRoaXMuaW5pdF9kb25lID0gZmFsc2U7XG4gIHRoaXMud3JpdGVfaW5fcHJvZ3Jlc3MgPSBmYWxzZTtcbiAgdGhpcy5wZW5kaW5nX2Nsb3NlID0gZmFsc2U7XG4gIHRoaXMud2luZG93Qml0cyA9IDA7XG4gIHRoaXMubGV2ZWwgPSAwO1xuICB0aGlzLm1lbUxldmVsID0gMDtcbiAgdGhpcy5zdHJhdGVneSA9IDA7XG4gIHRoaXMuZGljdGlvbmFyeSA9IG51bGw7XG59XG5cblpsaWIucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbih3aW5kb3dCaXRzLCBsZXZlbCwgbWVtTGV2ZWwsIHN0cmF0ZWd5LCBkaWN0aW9uYXJ5KSB7XG4gIHRoaXMud2luZG93Qml0cyA9IHdpbmRvd0JpdHM7XG4gIHRoaXMubGV2ZWwgPSBsZXZlbDtcbiAgdGhpcy5tZW1MZXZlbCA9IG1lbUxldmVsO1xuICB0aGlzLnN0cmF0ZWd5ID0gc3RyYXRlZ3k7XG4gIC8vIGRpY3Rpb25hcnkgbm90IHN1cHBvcnRlZC5cbiAgXG4gIGlmICh0aGlzLm1vZGUgPT09IGV4cG9ydHMuR1pJUCB8fCB0aGlzLm1vZGUgPT09IGV4cG9ydHMuR1VOWklQKVxuICAgIHRoaXMud2luZG93Qml0cyArPSAxNjtcbiAgICBcbiAgaWYgKHRoaXMubW9kZSA9PT0gZXhwb3J0cy5VTlpJUClcbiAgICB0aGlzLndpbmRvd0JpdHMgKz0gMzI7XG4gICAgXG4gIGlmICh0aGlzLm1vZGUgPT09IGV4cG9ydHMuREVGTEFURVJBVyB8fCB0aGlzLm1vZGUgPT09IGV4cG9ydHMuSU5GTEFURVJBVylcbiAgICB0aGlzLndpbmRvd0JpdHMgPSAtdGhpcy53aW5kb3dCaXRzO1xuICAgIFxuICB0aGlzLnN0cm0gPSBuZXcgenN0cmVhbSgpO1xuICBcbiAgc3dpdGNoICh0aGlzLm1vZGUpIHtcbiAgICBjYXNlIGV4cG9ydHMuREVGTEFURTpcbiAgICBjYXNlIGV4cG9ydHMuR1pJUDpcbiAgICBjYXNlIGV4cG9ydHMuREVGTEFURVJBVzpcbiAgICAgIHZhciBzdGF0dXMgPSB6bGliX2RlZmxhdGUuZGVmbGF0ZUluaXQyKFxuICAgICAgICB0aGlzLnN0cm0sXG4gICAgICAgIHRoaXMubGV2ZWwsXG4gICAgICAgIGV4cG9ydHMuWl9ERUZMQVRFRCxcbiAgICAgICAgdGhpcy53aW5kb3dCaXRzLFxuICAgICAgICB0aGlzLm1lbUxldmVsLFxuICAgICAgICB0aGlzLnN0cmF0ZWd5XG4gICAgICApO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBleHBvcnRzLklORkxBVEU6XG4gICAgY2FzZSBleHBvcnRzLkdVTlpJUDpcbiAgICBjYXNlIGV4cG9ydHMuSU5GTEFURVJBVzpcbiAgICBjYXNlIGV4cG9ydHMuVU5aSVA6XG4gICAgICB2YXIgc3RhdHVzICA9IHpsaWJfaW5mbGF0ZS5pbmZsYXRlSW5pdDIoXG4gICAgICAgIHRoaXMuc3RybSxcbiAgICAgICAgdGhpcy53aW5kb3dCaXRzXG4gICAgICApO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gbW9kZSBcIiArIHRoaXMubW9kZSk7XG4gIH1cbiAgXG4gIGlmIChzdGF0dXMgIT09IGV4cG9ydHMuWl9PSykge1xuICAgIHRoaXMuX2Vycm9yKHN0YXR1cyk7XG4gICAgcmV0dXJuO1xuICB9XG4gIFxuICB0aGlzLndyaXRlX2luX3Byb2dyZXNzID0gZmFsc2U7XG4gIHRoaXMuaW5pdF9kb25lID0gdHJ1ZTtcbn07XG5cblpsaWIucHJvdG90eXBlLnBhcmFtcyA9IGZ1bmN0aW9uKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoXCJkZWZsYXRlUGFyYW1zIE5vdCBzdXBwb3J0ZWRcIik7XG59O1xuXG5abGliLnByb3RvdHlwZS5fd3JpdGVDaGVjayA9IGZ1bmN0aW9uKCkge1xuICBpZiAoIXRoaXMuaW5pdF9kb25lKVxuICAgIHRocm93IG5ldyBFcnJvcihcIndyaXRlIGJlZm9yZSBpbml0XCIpO1xuICAgIFxuICBpZiAodGhpcy5tb2RlID09PSBleHBvcnRzLk5PTkUpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiYWxyZWFkeSBmaW5hbGl6ZWRcIik7XG4gICAgXG4gIGlmICh0aGlzLndyaXRlX2luX3Byb2dyZXNzKVxuICAgIHRocm93IG5ldyBFcnJvcihcIndyaXRlIGFscmVhZHkgaW4gcHJvZ3Jlc3NcIik7XG4gICAgXG4gIGlmICh0aGlzLnBlbmRpbmdfY2xvc2UpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiY2xvc2UgaXMgcGVuZGluZ1wiKTtcbn07XG5cblpsaWIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24oZmx1c2gsIGlucHV0LCBpbl9vZmYsIGluX2xlbiwgb3V0LCBvdXRfb2ZmLCBvdXRfbGVuKSB7ICAgIFxuICB0aGlzLl93cml0ZUNoZWNrKCk7XG4gIHRoaXMud3JpdGVfaW5fcHJvZ3Jlc3MgPSB0cnVlO1xuICBcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgIHNlbGYud3JpdGVfaW5fcHJvZ3Jlc3MgPSBmYWxzZTtcbiAgICB2YXIgcmVzID0gc2VsZi5fd3JpdGUoZmx1c2gsIGlucHV0LCBpbl9vZmYsIGluX2xlbiwgb3V0LCBvdXRfb2ZmLCBvdXRfbGVuKTtcbiAgICBzZWxmLmNhbGxiYWNrKHJlc1swXSwgcmVzWzFdKTtcbiAgICBcbiAgICBpZiAoc2VsZi5wZW5kaW5nX2Nsb3NlKVxuICAgICAgc2VsZi5jbG9zZSgpO1xuICB9KTtcbiAgXG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gc2V0IG1ldGhvZCBmb3IgTm9kZSBidWZmZXJzLCB1c2VkIGJ5IHBha29cbmZ1bmN0aW9uIGJ1ZmZlclNldChkYXRhLCBvZmZzZXQpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9IGRhdGFbaV07XG4gIH1cbn1cblxuWmxpYi5wcm90b3R5cGUud3JpdGVTeW5jID0gZnVuY3Rpb24oZmx1c2gsIGlucHV0LCBpbl9vZmYsIGluX2xlbiwgb3V0LCBvdXRfb2ZmLCBvdXRfbGVuKSB7XG4gIHRoaXMuX3dyaXRlQ2hlY2soKTtcbiAgcmV0dXJuIHRoaXMuX3dyaXRlKGZsdXNoLCBpbnB1dCwgaW5fb2ZmLCBpbl9sZW4sIG91dCwgb3V0X29mZiwgb3V0X2xlbik7XG59O1xuXG5abGliLnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbihmbHVzaCwgaW5wdXQsIGluX29mZiwgaW5fbGVuLCBvdXQsIG91dF9vZmYsIG91dF9sZW4pIHtcbiAgdGhpcy53cml0ZV9pbl9wcm9ncmVzcyA9IHRydWU7XG4gIFxuICBpZiAoZmx1c2ggIT09IGV4cG9ydHMuWl9OT19GTFVTSCAmJlxuICAgICAgZmx1c2ggIT09IGV4cG9ydHMuWl9QQVJUSUFMX0ZMVVNIICYmXG4gICAgICBmbHVzaCAhPT0gZXhwb3J0cy5aX1NZTkNfRkxVU0ggJiZcbiAgICAgIGZsdXNoICE9PSBleHBvcnRzLlpfRlVMTF9GTFVTSCAmJlxuICAgICAgZmx1c2ggIT09IGV4cG9ydHMuWl9GSU5JU0ggJiZcbiAgICAgIGZsdXNoICE9PSBleHBvcnRzLlpfQkxPQ0spIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGZsdXNoIHZhbHVlXCIpO1xuICB9XG4gIFxuICBpZiAoaW5wdXQgPT0gbnVsbCkge1xuICAgIGlucHV0ID0gbmV3IEJ1ZmZlcigwKTtcbiAgICBpbl9sZW4gPSAwO1xuICAgIGluX29mZiA9IDA7XG4gIH1cbiAgXG4gIGlmIChvdXQuX3NldClcbiAgICBvdXQuc2V0ID0gb3V0Ll9zZXQ7XG4gIGVsc2VcbiAgICBvdXQuc2V0ID0gYnVmZmVyU2V0O1xuICBcbiAgdmFyIHN0cm0gPSB0aGlzLnN0cm07XG4gIHN0cm0uYXZhaWxfaW4gPSBpbl9sZW47XG4gIHN0cm0uaW5wdXQgPSBpbnB1dDtcbiAgc3RybS5uZXh0X2luID0gaW5fb2ZmO1xuICBzdHJtLmF2YWlsX291dCA9IG91dF9sZW47XG4gIHN0cm0ub3V0cHV0ID0gb3V0O1xuICBzdHJtLm5leHRfb3V0ID0gb3V0X29mZjtcbiAgXG4gIHN3aXRjaCAodGhpcy5tb2RlKSB7XG4gICAgY2FzZSBleHBvcnRzLkRFRkxBVEU6XG4gICAgY2FzZSBleHBvcnRzLkdaSVA6XG4gICAgY2FzZSBleHBvcnRzLkRFRkxBVEVSQVc6XG4gICAgICB2YXIgc3RhdHVzID0gemxpYl9kZWZsYXRlLmRlZmxhdGUoc3RybSwgZmx1c2gpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBleHBvcnRzLlVOWklQOlxuICAgIGNhc2UgZXhwb3J0cy5JTkZMQVRFOlxuICAgIGNhc2UgZXhwb3J0cy5HVU5aSVA6XG4gICAgY2FzZSBleHBvcnRzLklORkxBVEVSQVc6XG4gICAgICB2YXIgc3RhdHVzID0gemxpYl9pbmZsYXRlLmluZmxhdGUoc3RybSwgZmx1c2gpO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gbW9kZSBcIiArIHRoaXMubW9kZSk7XG4gIH1cbiAgXG4gIGlmIChzdGF0dXMgIT09IGV4cG9ydHMuWl9TVFJFQU1fRU5EICYmIHN0YXR1cyAhPT0gZXhwb3J0cy5aX09LKSB7XG4gICAgdGhpcy5fZXJyb3Ioc3RhdHVzKTtcbiAgfVxuICBcbiAgdGhpcy53cml0ZV9pbl9wcm9ncmVzcyA9IGZhbHNlO1xuICByZXR1cm4gW3N0cm0uYXZhaWxfaW4sIHN0cm0uYXZhaWxfb3V0XTtcbn07XG5cblpsaWIucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLndyaXRlX2luX3Byb2dyZXNzKSB7XG4gICAgdGhpcy5wZW5kaW5nX2Nsb3NlID0gdHJ1ZTtcbiAgICByZXR1cm47XG4gIH1cbiAgXG4gIHRoaXMucGVuZGluZ19jbG9zZSA9IGZhbHNlO1xuICBcbiAgaWYgKHRoaXMubW9kZSA9PT0gZXhwb3J0cy5ERUZMQVRFIHx8IHRoaXMubW9kZSA9PT0gZXhwb3J0cy5HWklQIHx8IHRoaXMubW9kZSA9PT0gZXhwb3J0cy5ERUZMQVRFUkFXKSB7XG4gICAgemxpYl9kZWZsYXRlLmRlZmxhdGVFbmQodGhpcy5zdHJtKTtcbiAgfSBlbHNlIHtcbiAgICB6bGliX2luZmxhdGUuaW5mbGF0ZUVuZCh0aGlzLnN0cm0pO1xuICB9XG4gIFxuICB0aGlzLm1vZGUgPSBleHBvcnRzLk5PTkU7XG59O1xuXG5abGliLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uKCkge1xuICBzd2l0Y2ggKHRoaXMubW9kZSkge1xuICAgIGNhc2UgZXhwb3J0cy5ERUZMQVRFOlxuICAgIGNhc2UgZXhwb3J0cy5ERUZMQVRFUkFXOlxuICAgICAgdmFyIHN0YXR1cyA9IHpsaWJfZGVmbGF0ZS5kZWZsYXRlUmVzZXQodGhpcy5zdHJtKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgZXhwb3J0cy5JTkZMQVRFOlxuICAgIGNhc2UgZXhwb3J0cy5JTkZMQVRFUkFXOlxuICAgICAgdmFyIHN0YXR1cyA9IHpsaWJfaW5mbGF0ZS5pbmZsYXRlUmVzZXQodGhpcy5zdHJtKTtcbiAgICAgIGJyZWFrO1xuICB9XG4gIFxuICBpZiAoc3RhdHVzICE9PSBleHBvcnRzLlpfT0spIHtcbiAgICB0aGlzLl9lcnJvcihzdGF0dXMpO1xuICB9XG59O1xuXG5abGliLnByb3RvdHlwZS5fZXJyb3IgPSBmdW5jdGlvbihzdGF0dXMpIHtcbiAgdGhpcy5vbmVycm9yKG1zZ1tzdGF0dXNdICsgJzogJyArIHRoaXMuc3RybS5tc2csIHN0YXR1cyk7XG4gIFxuICB0aGlzLndyaXRlX2luX3Byb2dyZXNzID0gZmFsc2U7XG4gIGlmICh0aGlzLnBlbmRpbmdfY2xvc2UpXG4gICAgdGhpcy5jbG9zZSgpO1xufTtcblxuZXhwb3J0cy5abGliID0gWmxpYjtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG52YXIgVHJhbnNmb3JtID0gcmVxdWlyZSgnX3N0cmVhbV90cmFuc2Zvcm0nKTtcblxudmFyIGJpbmRpbmcgPSByZXF1aXJlKCcuL2JpbmRpbmcnKTtcbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xudmFyIGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpLm9rO1xuXG4vLyB6bGliIGRvZXNuJ3QgcHJvdmlkZSB0aGVzZSwgc28ga2x1ZGdlIHRoZW0gaW4gZm9sbG93aW5nIHRoZSBzYW1lXG4vLyBjb25zdCBuYW1pbmcgc2NoZW1lIHpsaWIgdXNlcy5cbmJpbmRpbmcuWl9NSU5fV0lORE9XQklUUyA9IDg7XG5iaW5kaW5nLlpfTUFYX1dJTkRPV0JJVFMgPSAxNTtcbmJpbmRpbmcuWl9ERUZBVUxUX1dJTkRPV0JJVFMgPSAxNTtcblxuLy8gZmV3ZXIgdGhhbiA2NCBieXRlcyBwZXIgY2h1bmsgaXMgc3R1cGlkLlxuLy8gdGVjaG5pY2FsbHkgaXQgY291bGQgd29yayB3aXRoIGFzIGZldyBhcyA4LCBidXQgZXZlbiA2NCBieXRlc1xuLy8gaXMgYWJzdXJkbHkgbG93LiAgVXN1YWxseSBhIE1CIG9yIG1vcmUgaXMgYmVzdC5cbmJpbmRpbmcuWl9NSU5fQ0hVTksgPSA2NDtcbmJpbmRpbmcuWl9NQVhfQ0hVTksgPSBJbmZpbml0eTtcbmJpbmRpbmcuWl9ERUZBVUxUX0NIVU5LID0gKDE2ICogMTAyNCk7XG5cbmJpbmRpbmcuWl9NSU5fTUVNTEVWRUwgPSAxO1xuYmluZGluZy5aX01BWF9NRU1MRVZFTCA9IDk7XG5iaW5kaW5nLlpfREVGQVVMVF9NRU1MRVZFTCA9IDg7XG5cbmJpbmRpbmcuWl9NSU5fTEVWRUwgPSAtMTtcbmJpbmRpbmcuWl9NQVhfTEVWRUwgPSA5O1xuYmluZGluZy5aX0RFRkFVTFRfTEVWRUwgPSBiaW5kaW5nLlpfREVGQVVMVF9DT01QUkVTU0lPTjtcblxuLy8gZXhwb3NlIGFsbCB0aGUgemxpYiBjb25zdGFudHNcbk9iamVjdC5rZXlzKGJpbmRpbmcpLmZvckVhY2goZnVuY3Rpb24oaykge1xuICBpZiAoay5tYXRjaCgvXlovKSkgZXhwb3J0c1trXSA9IGJpbmRpbmdba107XG59KTtcblxuLy8gdHJhbnNsYXRpb24gdGFibGUgZm9yIHJldHVybiBjb2Rlcy5cbmV4cG9ydHMuY29kZXMgPSB7XG4gIFpfT0s6IGJpbmRpbmcuWl9PSyxcbiAgWl9TVFJFQU1fRU5EOiBiaW5kaW5nLlpfU1RSRUFNX0VORCxcbiAgWl9ORUVEX0RJQ1Q6IGJpbmRpbmcuWl9ORUVEX0RJQ1QsXG4gIFpfRVJSTk86IGJpbmRpbmcuWl9FUlJOTyxcbiAgWl9TVFJFQU1fRVJST1I6IGJpbmRpbmcuWl9TVFJFQU1fRVJST1IsXG4gIFpfREFUQV9FUlJPUjogYmluZGluZy5aX0RBVEFfRVJST1IsXG4gIFpfTUVNX0VSUk9SOiBiaW5kaW5nLlpfTUVNX0VSUk9SLFxuICBaX0JVRl9FUlJPUjogYmluZGluZy5aX0JVRl9FUlJPUixcbiAgWl9WRVJTSU9OX0VSUk9SOiBiaW5kaW5nLlpfVkVSU0lPTl9FUlJPUlxufTtcblxuT2JqZWN0LmtleXMoZXhwb3J0cy5jb2RlcykuZm9yRWFjaChmdW5jdGlvbihrKSB7XG4gIGV4cG9ydHMuY29kZXNbZXhwb3J0cy5jb2Rlc1trXV0gPSBrO1xufSk7XG5cbmV4cG9ydHMuRGVmbGF0ZSA9IERlZmxhdGU7XG5leHBvcnRzLkluZmxhdGUgPSBJbmZsYXRlO1xuZXhwb3J0cy5HemlwID0gR3ppcDtcbmV4cG9ydHMuR3VuemlwID0gR3VuemlwO1xuZXhwb3J0cy5EZWZsYXRlUmF3ID0gRGVmbGF0ZVJhdztcbmV4cG9ydHMuSW5mbGF0ZVJhdyA9IEluZmxhdGVSYXc7XG5leHBvcnRzLlVuemlwID0gVW56aXA7XG5cbmV4cG9ydHMuY3JlYXRlRGVmbGF0ZSA9IGZ1bmN0aW9uKG8pIHtcbiAgcmV0dXJuIG5ldyBEZWZsYXRlKG8pO1xufTtcblxuZXhwb3J0cy5jcmVhdGVJbmZsYXRlID0gZnVuY3Rpb24obykge1xuICByZXR1cm4gbmV3IEluZmxhdGUobyk7XG59O1xuXG5leHBvcnRzLmNyZWF0ZURlZmxhdGVSYXcgPSBmdW5jdGlvbihvKSB7XG4gIHJldHVybiBuZXcgRGVmbGF0ZVJhdyhvKTtcbn07XG5cbmV4cG9ydHMuY3JlYXRlSW5mbGF0ZVJhdyA9IGZ1bmN0aW9uKG8pIHtcbiAgcmV0dXJuIG5ldyBJbmZsYXRlUmF3KG8pO1xufTtcblxuZXhwb3J0cy5jcmVhdGVHemlwID0gZnVuY3Rpb24obykge1xuICByZXR1cm4gbmV3IEd6aXAobyk7XG59O1xuXG5leHBvcnRzLmNyZWF0ZUd1bnppcCA9IGZ1bmN0aW9uKG8pIHtcbiAgcmV0dXJuIG5ldyBHdW56aXAobyk7XG59O1xuXG5leHBvcnRzLmNyZWF0ZVVuemlwID0gZnVuY3Rpb24obykge1xuICByZXR1cm4gbmV3IFVuemlwKG8pO1xufTtcblxuXG4vLyBDb252ZW5pZW5jZSBtZXRob2RzLlxuLy8gY29tcHJlc3MvZGVjb21wcmVzcyBhIHN0cmluZyBvciBidWZmZXIgaW4gb25lIHN0ZXAuXG5leHBvcnRzLmRlZmxhdGUgPSBmdW5jdGlvbihidWZmZXIsIG9wdHMsIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gb3B0cztcbiAgICBvcHRzID0ge307XG4gIH1cbiAgcmV0dXJuIHpsaWJCdWZmZXIobmV3IERlZmxhdGUob3B0cyksIGJ1ZmZlciwgY2FsbGJhY2spO1xufTtcblxuZXhwb3J0cy5kZWZsYXRlU3luYyA9IGZ1bmN0aW9uKGJ1ZmZlciwgb3B0cykge1xuICByZXR1cm4gemxpYkJ1ZmZlclN5bmMobmV3IERlZmxhdGUob3B0cyksIGJ1ZmZlcik7XG59O1xuXG5leHBvcnRzLmd6aXAgPSBmdW5jdGlvbihidWZmZXIsIG9wdHMsIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gb3B0cztcbiAgICBvcHRzID0ge307XG4gIH1cbiAgcmV0dXJuIHpsaWJCdWZmZXIobmV3IEd6aXAob3B0cyksIGJ1ZmZlciwgY2FsbGJhY2spO1xufTtcblxuZXhwb3J0cy5nemlwU3luYyA9IGZ1bmN0aW9uKGJ1ZmZlciwgb3B0cykge1xuICByZXR1cm4gemxpYkJ1ZmZlclN5bmMobmV3IEd6aXAob3B0cyksIGJ1ZmZlcik7XG59O1xuXG5leHBvcnRzLmRlZmxhdGVSYXcgPSBmdW5jdGlvbihidWZmZXIsIG9wdHMsIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gb3B0cztcbiAgICBvcHRzID0ge307XG4gIH1cbiAgcmV0dXJuIHpsaWJCdWZmZXIobmV3IERlZmxhdGVSYXcob3B0cyksIGJ1ZmZlciwgY2FsbGJhY2spO1xufTtcblxuZXhwb3J0cy5kZWZsYXRlUmF3U3luYyA9IGZ1bmN0aW9uKGJ1ZmZlciwgb3B0cykge1xuICByZXR1cm4gemxpYkJ1ZmZlclN5bmMobmV3IERlZmxhdGVSYXcob3B0cyksIGJ1ZmZlcik7XG59O1xuXG5leHBvcnRzLnVuemlwID0gZnVuY3Rpb24oYnVmZmVyLCBvcHRzLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IG9wdHM7XG4gICAgb3B0cyA9IHt9O1xuICB9XG4gIHJldHVybiB6bGliQnVmZmVyKG5ldyBVbnppcChvcHRzKSwgYnVmZmVyLCBjYWxsYmFjayk7XG59O1xuXG5leHBvcnRzLnVuemlwU3luYyA9IGZ1bmN0aW9uKGJ1ZmZlciwgb3B0cykge1xuICByZXR1cm4gemxpYkJ1ZmZlclN5bmMobmV3IFVuemlwKG9wdHMpLCBidWZmZXIpO1xufTtcblxuZXhwb3J0cy5pbmZsYXRlID0gZnVuY3Rpb24oYnVmZmVyLCBvcHRzLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IG9wdHM7XG4gICAgb3B0cyA9IHt9O1xuICB9XG4gIHJldHVybiB6bGliQnVmZmVyKG5ldyBJbmZsYXRlKG9wdHMpLCBidWZmZXIsIGNhbGxiYWNrKTtcbn07XG5cbmV4cG9ydHMuaW5mbGF0ZVN5bmMgPSBmdW5jdGlvbihidWZmZXIsIG9wdHMpIHtcbiAgcmV0dXJuIHpsaWJCdWZmZXJTeW5jKG5ldyBJbmZsYXRlKG9wdHMpLCBidWZmZXIpO1xufTtcblxuZXhwb3J0cy5ndW56aXAgPSBmdW5jdGlvbihidWZmZXIsIG9wdHMsIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gb3B0cztcbiAgICBvcHRzID0ge307XG4gIH1cbiAgcmV0dXJuIHpsaWJCdWZmZXIobmV3IEd1bnppcChvcHRzKSwgYnVmZmVyLCBjYWxsYmFjayk7XG59O1xuXG5leHBvcnRzLmd1bnppcFN5bmMgPSBmdW5jdGlvbihidWZmZXIsIG9wdHMpIHtcbiAgcmV0dXJuIHpsaWJCdWZmZXJTeW5jKG5ldyBHdW56aXAob3B0cyksIGJ1ZmZlcik7XG59O1xuXG5leHBvcnRzLmluZmxhdGVSYXcgPSBmdW5jdGlvbihidWZmZXIsIG9wdHMsIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gb3B0cztcbiAgICBvcHRzID0ge307XG4gIH1cbiAgcmV0dXJuIHpsaWJCdWZmZXIobmV3IEluZmxhdGVSYXcob3B0cyksIGJ1ZmZlciwgY2FsbGJhY2spO1xufTtcblxuZXhwb3J0cy5pbmZsYXRlUmF3U3luYyA9IGZ1bmN0aW9uKGJ1ZmZlciwgb3B0cykge1xuICByZXR1cm4gemxpYkJ1ZmZlclN5bmMobmV3IEluZmxhdGVSYXcob3B0cyksIGJ1ZmZlcik7XG59O1xuXG5mdW5jdGlvbiB6bGliQnVmZmVyKGVuZ2luZSwgYnVmZmVyLCBjYWxsYmFjaykge1xuICB2YXIgYnVmZmVycyA9IFtdO1xuICB2YXIgbnJlYWQgPSAwO1xuXG4gIGVuZ2luZS5vbignZXJyb3InLCBvbkVycm9yKTtcbiAgZW5naW5lLm9uKCdlbmQnLCBvbkVuZCk7XG5cbiAgZW5naW5lLmVuZChidWZmZXIpO1xuICBmbG93KCk7XG5cbiAgZnVuY3Rpb24gZmxvdygpIHtcbiAgICB2YXIgY2h1bms7XG4gICAgd2hpbGUgKG51bGwgIT09IChjaHVuayA9IGVuZ2luZS5yZWFkKCkpKSB7XG4gICAgICBidWZmZXJzLnB1c2goY2h1bmspO1xuICAgICAgbnJlYWQgKz0gY2h1bmsubGVuZ3RoO1xuICAgIH1cbiAgICBlbmdpbmUub25jZSgncmVhZGFibGUnLCBmbG93KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uRXJyb3IoZXJyKSB7XG4gICAgZW5naW5lLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbkVuZCk7XG4gICAgZW5naW5lLnJlbW92ZUxpc3RlbmVyKCdyZWFkYWJsZScsIGZsb3cpO1xuICAgIGNhbGxiYWNrKGVycik7XG4gIH1cblxuICBmdW5jdGlvbiBvbkVuZCgpIHtcbiAgICB2YXIgYnVmID0gQnVmZmVyLmNvbmNhdChidWZmZXJzLCBucmVhZCk7XG4gICAgYnVmZmVycyA9IFtdO1xuICAgIGNhbGxiYWNrKG51bGwsIGJ1Zik7XG4gICAgZW5naW5lLmNsb3NlKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gemxpYkJ1ZmZlclN5bmMoZW5naW5lLCBidWZmZXIpIHtcbiAgaWYgKHR5cGVvZiBidWZmZXIgPT09ICdzdHJpbmcnKVxuICAgIGJ1ZmZlciA9IG5ldyBCdWZmZXIoYnVmZmVyKTtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmZmVyKSlcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdOb3QgYSBzdHJpbmcgb3IgYnVmZmVyJyk7XG5cbiAgdmFyIGZsdXNoRmxhZyA9IGJpbmRpbmcuWl9GSU5JU0g7XG5cbiAgcmV0dXJuIGVuZ2luZS5fcHJvY2Vzc0NodW5rKGJ1ZmZlciwgZmx1c2hGbGFnKTtcbn1cblxuLy8gZ2VuZXJpYyB6bGliXG4vLyBtaW5pbWFsIDItYnl0ZSBoZWFkZXJcbmZ1bmN0aW9uIERlZmxhdGUob3B0cykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRGVmbGF0ZSkpIHJldHVybiBuZXcgRGVmbGF0ZShvcHRzKTtcbiAgWmxpYi5jYWxsKHRoaXMsIG9wdHMsIGJpbmRpbmcuREVGTEFURSk7XG59XG5cbmZ1bmN0aW9uIEluZmxhdGUob3B0cykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgSW5mbGF0ZSkpIHJldHVybiBuZXcgSW5mbGF0ZShvcHRzKTtcbiAgWmxpYi5jYWxsKHRoaXMsIG9wdHMsIGJpbmRpbmcuSU5GTEFURSk7XG59XG5cblxuXG4vLyBnemlwIC0gYmlnZ2VyIGhlYWRlciwgc2FtZSBkZWZsYXRlIGNvbXByZXNzaW9uXG5mdW5jdGlvbiBHemlwKG9wdHMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEd6aXApKSByZXR1cm4gbmV3IEd6aXAob3B0cyk7XG4gIFpsaWIuY2FsbCh0aGlzLCBvcHRzLCBiaW5kaW5nLkdaSVApO1xufVxuXG5mdW5jdGlvbiBHdW56aXAob3B0cykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgR3VuemlwKSkgcmV0dXJuIG5ldyBHdW56aXAob3B0cyk7XG4gIFpsaWIuY2FsbCh0aGlzLCBvcHRzLCBiaW5kaW5nLkdVTlpJUCk7XG59XG5cblxuXG4vLyByYXcgLSBubyBoZWFkZXJcbmZ1bmN0aW9uIERlZmxhdGVSYXcob3B0cykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRGVmbGF0ZVJhdykpIHJldHVybiBuZXcgRGVmbGF0ZVJhdyhvcHRzKTtcbiAgWmxpYi5jYWxsKHRoaXMsIG9wdHMsIGJpbmRpbmcuREVGTEFURVJBVyk7XG59XG5cbmZ1bmN0aW9uIEluZmxhdGVSYXcob3B0cykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgSW5mbGF0ZVJhdykpIHJldHVybiBuZXcgSW5mbGF0ZVJhdyhvcHRzKTtcbiAgWmxpYi5jYWxsKHRoaXMsIG9wdHMsIGJpbmRpbmcuSU5GTEFURVJBVyk7XG59XG5cblxuLy8gYXV0by1kZXRlY3QgaGVhZGVyLlxuZnVuY3Rpb24gVW56aXAob3B0cykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgVW56aXApKSByZXR1cm4gbmV3IFVuemlwKG9wdHMpO1xuICBabGliLmNhbGwodGhpcywgb3B0cywgYmluZGluZy5VTlpJUCk7XG59XG5cblxuLy8gdGhlIFpsaWIgY2xhc3MgdGhleSBhbGwgaW5oZXJpdCBmcm9tXG4vLyBUaGlzIHRoaW5nIG1hbmFnZXMgdGhlIHF1ZXVlIG9mIHJlcXVlc3RzLCBhbmQgcmV0dXJuc1xuLy8gdHJ1ZSBvciBmYWxzZSBpZiB0aGVyZSBpcyBhbnl0aGluZyBpbiB0aGUgcXVldWUgd2hlblxuLy8geW91IGNhbGwgdGhlIC53cml0ZSgpIG1ldGhvZC5cblxuZnVuY3Rpb24gWmxpYihvcHRzLCBtb2RlKSB7XG4gIHRoaXMuX29wdHMgPSBvcHRzID0gb3B0cyB8fCB7fTtcbiAgdGhpcy5fY2h1bmtTaXplID0gb3B0cy5jaHVua1NpemUgfHwgZXhwb3J0cy5aX0RFRkFVTFRfQ0hVTks7XG5cbiAgVHJhbnNmb3JtLmNhbGwodGhpcywgb3B0cyk7XG5cbiAgaWYgKG9wdHMuZmx1c2gpIHtcbiAgICBpZiAob3B0cy5mbHVzaCAhPT0gYmluZGluZy5aX05PX0ZMVVNIICYmXG4gICAgICAgIG9wdHMuZmx1c2ggIT09IGJpbmRpbmcuWl9QQVJUSUFMX0ZMVVNIICYmXG4gICAgICAgIG9wdHMuZmx1c2ggIT09IGJpbmRpbmcuWl9TWU5DX0ZMVVNIICYmXG4gICAgICAgIG9wdHMuZmx1c2ggIT09IGJpbmRpbmcuWl9GVUxMX0ZMVVNIICYmXG4gICAgICAgIG9wdHMuZmx1c2ggIT09IGJpbmRpbmcuWl9GSU5JU0ggJiZcbiAgICAgICAgb3B0cy5mbHVzaCAhPT0gYmluZGluZy5aX0JMT0NLKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgZmx1c2ggZmxhZzogJyArIG9wdHMuZmx1c2gpO1xuICAgIH1cbiAgfVxuICB0aGlzLl9mbHVzaEZsYWcgPSBvcHRzLmZsdXNoIHx8IGJpbmRpbmcuWl9OT19GTFVTSDtcblxuICBpZiAob3B0cy5jaHVua1NpemUpIHtcbiAgICBpZiAob3B0cy5jaHVua1NpemUgPCBleHBvcnRzLlpfTUlOX0NIVU5LIHx8XG4gICAgICAgIG9wdHMuY2h1bmtTaXplID4gZXhwb3J0cy5aX01BWF9DSFVOSykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNodW5rIHNpemU6ICcgKyBvcHRzLmNodW5rU2l6ZSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKG9wdHMud2luZG93Qml0cykge1xuICAgIGlmIChvcHRzLndpbmRvd0JpdHMgPCBleHBvcnRzLlpfTUlOX1dJTkRPV0JJVFMgfHxcbiAgICAgICAgb3B0cy53aW5kb3dCaXRzID4gZXhwb3J0cy5aX01BWF9XSU5ET1dCSVRTKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgd2luZG93Qml0czogJyArIG9wdHMud2luZG93Qml0cyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKG9wdHMubGV2ZWwpIHtcbiAgICBpZiAob3B0cy5sZXZlbCA8IGV4cG9ydHMuWl9NSU5fTEVWRUwgfHxcbiAgICAgICAgb3B0cy5sZXZlbCA+IGV4cG9ydHMuWl9NQVhfTEVWRUwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjb21wcmVzc2lvbiBsZXZlbDogJyArIG9wdHMubGV2ZWwpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChvcHRzLm1lbUxldmVsKSB7XG4gICAgaWYgKG9wdHMubWVtTGV2ZWwgPCBleHBvcnRzLlpfTUlOX01FTUxFVkVMIHx8XG4gICAgICAgIG9wdHMubWVtTGV2ZWwgPiBleHBvcnRzLlpfTUFYX01FTUxFVkVMKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbWVtTGV2ZWw6ICcgKyBvcHRzLm1lbUxldmVsKTtcbiAgICB9XG4gIH1cblxuICBpZiAob3B0cy5zdHJhdGVneSkge1xuICAgIGlmIChvcHRzLnN0cmF0ZWd5ICE9IGV4cG9ydHMuWl9GSUxURVJFRCAmJlxuICAgICAgICBvcHRzLnN0cmF0ZWd5ICE9IGV4cG9ydHMuWl9IVUZGTUFOX09OTFkgJiZcbiAgICAgICAgb3B0cy5zdHJhdGVneSAhPSBleHBvcnRzLlpfUkxFICYmXG4gICAgICAgIG9wdHMuc3RyYXRlZ3kgIT0gZXhwb3J0cy5aX0ZJWEVEICYmXG4gICAgICAgIG9wdHMuc3RyYXRlZ3kgIT0gZXhwb3J0cy5aX0RFRkFVTFRfU1RSQVRFR1kpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdHJhdGVneTogJyArIG9wdHMuc3RyYXRlZ3kpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChvcHRzLmRpY3Rpb25hcnkpIHtcbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihvcHRzLmRpY3Rpb25hcnkpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgZGljdGlvbmFyeTogaXQgc2hvdWxkIGJlIGEgQnVmZmVyIGluc3RhbmNlJyk7XG4gICAgfVxuICB9XG5cbiAgdGhpcy5fYmluZGluZyA9IG5ldyBiaW5kaW5nLlpsaWIobW9kZSk7XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB0aGlzLl9oYWRFcnJvciA9IGZhbHNlO1xuICB0aGlzLl9iaW5kaW5nLm9uZXJyb3IgPSBmdW5jdGlvbihtZXNzYWdlLCBlcnJubykge1xuICAgIC8vIHRoZXJlIGlzIG5vIHdheSB0byBjbGVhbmx5IHJlY292ZXIuXG4gICAgLy8gY29udGludWluZyBvbmx5IG9ic2N1cmVzIHByb2JsZW1zLlxuICAgIHNlbGYuX2JpbmRpbmcgPSBudWxsO1xuICAgIHNlbGYuX2hhZEVycm9yID0gdHJ1ZTtcblxuICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICBlcnJvci5lcnJubyA9IGVycm5vO1xuICAgIGVycm9yLmNvZGUgPSBleHBvcnRzLmNvZGVzW2Vycm5vXTtcbiAgICBzZWxmLmVtaXQoJ2Vycm9yJywgZXJyb3IpO1xuICB9O1xuXG4gIHZhciBsZXZlbCA9IGV4cG9ydHMuWl9ERUZBVUxUX0NPTVBSRVNTSU9OO1xuICBpZiAodHlwZW9mIG9wdHMubGV2ZWwgPT09ICdudW1iZXInKSBsZXZlbCA9IG9wdHMubGV2ZWw7XG5cbiAgdmFyIHN0cmF0ZWd5ID0gZXhwb3J0cy5aX0RFRkFVTFRfU1RSQVRFR1k7XG4gIGlmICh0eXBlb2Ygb3B0cy5zdHJhdGVneSA9PT0gJ251bWJlcicpIHN0cmF0ZWd5ID0gb3B0cy5zdHJhdGVneTtcblxuICB0aGlzLl9iaW5kaW5nLmluaXQob3B0cy53aW5kb3dCaXRzIHx8IGV4cG9ydHMuWl9ERUZBVUxUX1dJTkRPV0JJVFMsXG4gICAgICAgICAgICAgICAgICAgICBsZXZlbCxcbiAgICAgICAgICAgICAgICAgICAgIG9wdHMubWVtTGV2ZWwgfHwgZXhwb3J0cy5aX0RFRkFVTFRfTUVNTEVWRUwsXG4gICAgICAgICAgICAgICAgICAgICBzdHJhdGVneSxcbiAgICAgICAgICAgICAgICAgICAgIG9wdHMuZGljdGlvbmFyeSk7XG5cbiAgdGhpcy5fYnVmZmVyID0gbmV3IEJ1ZmZlcih0aGlzLl9jaHVua1NpemUpO1xuICB0aGlzLl9vZmZzZXQgPSAwO1xuICB0aGlzLl9jbG9zZWQgPSBmYWxzZTtcbiAgdGhpcy5fbGV2ZWwgPSBsZXZlbDtcbiAgdGhpcy5fc3RyYXRlZ3kgPSBzdHJhdGVneTtcblxuICB0aGlzLm9uY2UoJ2VuZCcsIHRoaXMuY2xvc2UpO1xufVxuXG51dGlsLmluaGVyaXRzKFpsaWIsIFRyYW5zZm9ybSk7XG5cblpsaWIucHJvdG90eXBlLnBhcmFtcyA9IGZ1bmN0aW9uKGxldmVsLCBzdHJhdGVneSwgY2FsbGJhY2spIHtcbiAgaWYgKGxldmVsIDwgZXhwb3J0cy5aX01JTl9MRVZFTCB8fFxuICAgICAgbGV2ZWwgPiBleHBvcnRzLlpfTUFYX0xFVkVMKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0ludmFsaWQgY29tcHJlc3Npb24gbGV2ZWw6ICcgKyBsZXZlbCk7XG4gIH1cbiAgaWYgKHN0cmF0ZWd5ICE9IGV4cG9ydHMuWl9GSUxURVJFRCAmJlxuICAgICAgc3RyYXRlZ3kgIT0gZXhwb3J0cy5aX0hVRkZNQU5fT05MWSAmJlxuICAgICAgc3RyYXRlZ3kgIT0gZXhwb3J0cy5aX1JMRSAmJlxuICAgICAgc3RyYXRlZ3kgIT0gZXhwb3J0cy5aX0ZJWEVEICYmXG4gICAgICBzdHJhdGVneSAhPSBleHBvcnRzLlpfREVGQVVMVF9TVFJBVEVHWSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgc3RyYXRlZ3k6ICcgKyBzdHJhdGVneSk7XG4gIH1cblxuICBpZiAodGhpcy5fbGV2ZWwgIT09IGxldmVsIHx8IHRoaXMuX3N0cmF0ZWd5ICE9PSBzdHJhdGVneSkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB0aGlzLmZsdXNoKGJpbmRpbmcuWl9TWU5DX0ZMVVNILCBmdW5jdGlvbigpIHtcbiAgICAgIHNlbGYuX2JpbmRpbmcucGFyYW1zKGxldmVsLCBzdHJhdGVneSk7XG4gICAgICBpZiAoIXNlbGYuX2hhZEVycm9yKSB7XG4gICAgICAgIHNlbGYuX2xldmVsID0gbGV2ZWw7XG4gICAgICAgIHNlbGYuX3N0cmF0ZWd5ID0gc3RyYXRlZ3k7XG4gICAgICAgIGlmIChjYWxsYmFjaykgY2FsbGJhY2soKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBwcm9jZXNzLm5leHRUaWNrKGNhbGxiYWNrKTtcbiAgfVxufTtcblxuWmxpYi5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX2JpbmRpbmcucmVzZXQoKTtcbn07XG5cbi8vIFRoaXMgaXMgdGhlIF9mbHVzaCBmdW5jdGlvbiBjYWxsZWQgYnkgdGhlIHRyYW5zZm9ybSBjbGFzcyxcbi8vIGludGVybmFsbHksIHdoZW4gdGhlIGxhc3QgY2h1bmsgaGFzIGJlZW4gd3JpdHRlbi5cblpsaWIucHJvdG90eXBlLl9mbHVzaCA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gIHRoaXMuX3RyYW5zZm9ybShuZXcgQnVmZmVyKDApLCAnJywgY2FsbGJhY2spO1xufTtcblxuWmxpYi5wcm90b3R5cGUuZmx1c2ggPSBmdW5jdGlvbihraW5kLCBjYWxsYmFjaykge1xuICB2YXIgd3MgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuXG4gIGlmICh0eXBlb2Yga2luZCA9PT0gJ2Z1bmN0aW9uJyB8fCAoa2luZCA9PT0gdm9pZCAwICYmICFjYWxsYmFjaykpIHtcbiAgICBjYWxsYmFjayA9IGtpbmQ7XG4gICAga2luZCA9IGJpbmRpbmcuWl9GVUxMX0ZMVVNIO1xuICB9XG5cbiAgaWYgKHdzLmVuZGVkKSB7XG4gICAgaWYgKGNhbGxiYWNrKVxuICAgICAgcHJvY2Vzcy5uZXh0VGljayhjYWxsYmFjayk7XG4gIH0gZWxzZSBpZiAod3MuZW5kaW5nKSB7XG4gICAgaWYgKGNhbGxiYWNrKVxuICAgICAgdGhpcy5vbmNlKCdlbmQnLCBjYWxsYmFjayk7XG4gIH0gZWxzZSBpZiAod3MubmVlZERyYWluKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHRoaXMub25jZSgnZHJhaW4nLCBmdW5jdGlvbigpIHtcbiAgICAgIHNlbGYuZmx1c2goY2FsbGJhY2spO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuX2ZsdXNoRmxhZyA9IGtpbmQ7XG4gICAgdGhpcy53cml0ZShuZXcgQnVmZmVyKDApLCAnJywgY2FsbGJhY2spO1xuICB9XG59O1xuXG5abGliLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gIGlmIChjYWxsYmFjaylcbiAgICBwcm9jZXNzLm5leHRUaWNrKGNhbGxiYWNrKTtcblxuICBpZiAodGhpcy5fY2xvc2VkKVxuICAgIHJldHVybjtcblxuICB0aGlzLl9jbG9zZWQgPSB0cnVlO1xuXG4gIHRoaXMuX2JpbmRpbmcuY2xvc2UoKTtcblxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgc2VsZi5lbWl0KCdjbG9zZScpO1xuICB9KTtcbn07XG5cblpsaWIucHJvdG90eXBlLl90cmFuc2Zvcm0gPSBmdW5jdGlvbihjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHZhciBmbHVzaEZsYWc7XG4gIHZhciB3cyA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG4gIHZhciBlbmRpbmcgPSB3cy5lbmRpbmcgfHwgd3MuZW5kZWQ7XG4gIHZhciBsYXN0ID0gZW5kaW5nICYmICghY2h1bmsgfHwgd3MubGVuZ3RoID09PSBjaHVuay5sZW5ndGgpO1xuXG4gIGlmICghY2h1bmsgPT09IG51bGwgJiYgIUJ1ZmZlci5pc0J1ZmZlcihjaHVuaykpXG4gICAgcmV0dXJuIGNiKG5ldyBFcnJvcignaW52YWxpZCBpbnB1dCcpKTtcblxuICAvLyBJZiBpdCdzIHRoZSBsYXN0IGNodW5rLCBvciBhIGZpbmFsIGZsdXNoLCB3ZSB1c2UgdGhlIFpfRklOSVNIIGZsdXNoIGZsYWcuXG4gIC8vIElmIGl0J3MgZXhwbGljaXRseSBmbHVzaGluZyBhdCBzb21lIG90aGVyIHRpbWUsIHRoZW4gd2UgdXNlXG4gIC8vIFpfRlVMTF9GTFVTSC4gT3RoZXJ3aXNlLCB1c2UgWl9OT19GTFVTSCBmb3IgbWF4aW11bSBjb21wcmVzc2lvblxuICAvLyBnb29kbmVzcy5cbiAgaWYgKGxhc3QpXG4gICAgZmx1c2hGbGFnID0gYmluZGluZy5aX0ZJTklTSDtcbiAgZWxzZSB7XG4gICAgZmx1c2hGbGFnID0gdGhpcy5fZmx1c2hGbGFnO1xuICAgIC8vIG9uY2Ugd2UndmUgZmx1c2hlZCB0aGUgbGFzdCBvZiB0aGUgcXVldWUsIHN0b3AgZmx1c2hpbmcgYW5kXG4gICAgLy8gZ28gYmFjayB0byB0aGUgbm9ybWFsIGJlaGF2aW9yLlxuICAgIGlmIChjaHVuay5sZW5ndGggPj0gd3MubGVuZ3RoKSB7XG4gICAgICB0aGlzLl9mbHVzaEZsYWcgPSB0aGlzLl9vcHRzLmZsdXNoIHx8IGJpbmRpbmcuWl9OT19GTFVTSDtcbiAgICB9XG4gIH1cblxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHRoaXMuX3Byb2Nlc3NDaHVuayhjaHVuaywgZmx1c2hGbGFnLCBjYik7XG59O1xuXG5abGliLnByb3RvdHlwZS5fcHJvY2Vzc0NodW5rID0gZnVuY3Rpb24oY2h1bmssIGZsdXNoRmxhZywgY2IpIHtcbiAgdmFyIGF2YWlsSW5CZWZvcmUgPSBjaHVuayAmJiBjaHVuay5sZW5ndGg7XG4gIHZhciBhdmFpbE91dEJlZm9yZSA9IHRoaXMuX2NodW5rU2l6ZSAtIHRoaXMuX29mZnNldDtcbiAgdmFyIGluT2ZmID0gMDtcblxuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgdmFyIGFzeW5jID0gdHlwZW9mIGNiID09PSAnZnVuY3Rpb24nO1xuXG4gIGlmICghYXN5bmMpIHtcbiAgICB2YXIgYnVmZmVycyA9IFtdO1xuICAgIHZhciBucmVhZCA9IDA7XG5cbiAgICB2YXIgZXJyb3I7XG4gICAgdGhpcy5vbignZXJyb3InLCBmdW5jdGlvbihlcikge1xuICAgICAgZXJyb3IgPSBlcjtcbiAgICB9KTtcblxuICAgIGRvIHtcbiAgICAgIHZhciByZXMgPSB0aGlzLl9iaW5kaW5nLndyaXRlU3luYyhmbHVzaEZsYWcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2h1bmssIC8vIGluXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5PZmYsIC8vIGluX29mZlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF2YWlsSW5CZWZvcmUsIC8vIGluX2xlblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2J1ZmZlciwgLy8gb3V0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fb2Zmc2V0LCAvL291dF9vZmZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdmFpbE91dEJlZm9yZSk7IC8vIG91dF9sZW5cbiAgICB9IHdoaWxlICghdGhpcy5faGFkRXJyb3IgJiYgY2FsbGJhY2socmVzWzBdLCByZXNbMV0pKTtcblxuICAgIGlmICh0aGlzLl9oYWRFcnJvcikge1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuXG4gICAgdmFyIGJ1ZiA9IEJ1ZmZlci5jb25jYXQoYnVmZmVycywgbnJlYWQpO1xuICAgIHRoaXMuY2xvc2UoKTtcblxuICAgIHJldHVybiBidWY7XG4gIH1cblxuICB2YXIgcmVxID0gdGhpcy5fYmluZGluZy53cml0ZShmbHVzaEZsYWcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNodW5rLCAvLyBpblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbk9mZiwgLy8gaW5fb2ZmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF2YWlsSW5CZWZvcmUsIC8vIGluX2xlblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9idWZmZXIsIC8vIG91dFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9vZmZzZXQsIC8vb3V0X29mZlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdmFpbE91dEJlZm9yZSk7IC8vIG91dF9sZW5cblxuICByZXEuYnVmZmVyID0gY2h1bms7XG4gIHJlcS5jYWxsYmFjayA9IGNhbGxiYWNrO1xuXG4gIGZ1bmN0aW9uIGNhbGxiYWNrKGF2YWlsSW5BZnRlciwgYXZhaWxPdXRBZnRlcikge1xuICAgIGlmIChzZWxmLl9oYWRFcnJvcilcbiAgICAgIHJldHVybjtcblxuICAgIHZhciBoYXZlID0gYXZhaWxPdXRCZWZvcmUgLSBhdmFpbE91dEFmdGVyO1xuICAgIGFzc2VydChoYXZlID49IDAsICdoYXZlIHNob3VsZCBub3QgZ28gZG93bicpO1xuXG4gICAgaWYgKGhhdmUgPiAwKSB7XG4gICAgICB2YXIgb3V0ID0gc2VsZi5fYnVmZmVyLnNsaWNlKHNlbGYuX29mZnNldCwgc2VsZi5fb2Zmc2V0ICsgaGF2ZSk7XG4gICAgICBzZWxmLl9vZmZzZXQgKz0gaGF2ZTtcbiAgICAgIC8vIHNlcnZlIHNvbWUgb3V0cHV0IHRvIHRoZSBjb25zdW1lci5cbiAgICAgIGlmIChhc3luYykge1xuICAgICAgICBzZWxmLnB1c2gob3V0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJ1ZmZlcnMucHVzaChvdXQpO1xuICAgICAgICBucmVhZCArPSBvdXQubGVuZ3RoO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGV4aGF1c3RlZCB0aGUgb3V0cHV0IGJ1ZmZlciwgb3IgdXNlZCBhbGwgdGhlIGlucHV0IGNyZWF0ZSBhIG5ldyBvbmUuXG4gICAgaWYgKGF2YWlsT3V0QWZ0ZXIgPT09IDAgfHwgc2VsZi5fb2Zmc2V0ID49IHNlbGYuX2NodW5rU2l6ZSkge1xuICAgICAgYXZhaWxPdXRCZWZvcmUgPSBzZWxmLl9jaHVua1NpemU7XG4gICAgICBzZWxmLl9vZmZzZXQgPSAwO1xuICAgICAgc2VsZi5fYnVmZmVyID0gbmV3IEJ1ZmZlcihzZWxmLl9jaHVua1NpemUpO1xuICAgIH1cblxuICAgIGlmIChhdmFpbE91dEFmdGVyID09PSAwKSB7XG4gICAgICAvLyBOb3QgYWN0dWFsbHkgZG9uZS4gIE5lZWQgdG8gcmVwcm9jZXNzLlxuICAgICAgLy8gQWxzbywgdXBkYXRlIHRoZSBhdmFpbEluQmVmb3JlIHRvIHRoZSBhdmFpbEluQWZ0ZXIgdmFsdWUsXG4gICAgICAvLyBzbyB0aGF0IGlmIHdlIGhhdmUgdG8gaGl0IGl0IGEgdGhpcmQgKGZvdXJ0aCwgZXRjLikgdGltZSxcbiAgICAgIC8vIGl0J2xsIGhhdmUgdGhlIGNvcnJlY3QgYnl0ZSBjb3VudHMuXG4gICAgICBpbk9mZiArPSAoYXZhaWxJbkJlZm9yZSAtIGF2YWlsSW5BZnRlcik7XG4gICAgICBhdmFpbEluQmVmb3JlID0gYXZhaWxJbkFmdGVyO1xuXG4gICAgICBpZiAoIWFzeW5jKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcblxuICAgICAgdmFyIG5ld1JlcSA9IHNlbGYuX2JpbmRpbmcud3JpdGUoZmx1c2hGbGFnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2h1bmssXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbk9mZixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF2YWlsSW5CZWZvcmUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9idWZmZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9vZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9jaHVua1NpemUpO1xuICAgICAgbmV3UmVxLmNhbGxiYWNrID0gY2FsbGJhY2s7IC8vIHRoaXMgc2FtZSBmdW5jdGlvblxuICAgICAgbmV3UmVxLmJ1ZmZlciA9IGNodW5rO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghYXN5bmMpXG4gICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICAvLyBmaW5pc2hlZCB3aXRoIHRoZSBjaHVuay5cbiAgICBjYigpO1xuICB9XG59O1xuXG51dGlsLmluaGVyaXRzKERlZmxhdGUsIFpsaWIpO1xudXRpbC5pbmhlcml0cyhJbmZsYXRlLCBabGliKTtcbnV0aWwuaW5oZXJpdHMoR3ppcCwgWmxpYik7XG51dGlsLmluaGVyaXRzKEd1bnppcCwgWmxpYik7XG51dGlsLmluaGVyaXRzKERlZmxhdGVSYXcsIFpsaWIpO1xudXRpbC5pbmhlcml0cyhJbmZsYXRlUmF3LCBabGliKTtcbnV0aWwuaW5oZXJpdHMoVW56aXAsIFpsaWIpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgYnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJyk7XG52YXIgQnVmZmVyID0gYnVmZmVyLkJ1ZmZlcjtcbnZhciBTbG93QnVmZmVyID0gYnVmZmVyLlNsb3dCdWZmZXI7XG52YXIgTUFYX0xFTiA9IGJ1ZmZlci5rTWF4TGVuZ3RoIHx8IDIxNDc0ODM2NDc7XG5leHBvcnRzLmFsbG9jID0gZnVuY3Rpb24gYWxsb2Moc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiBCdWZmZXIuYWxsb2MgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gQnVmZmVyLmFsbG9jKHNpemUsIGZpbGwsIGVuY29kaW5nKTtcbiAgfVxuICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2VuY29kaW5nIG11c3Qgbm90IGJlIG51bWJlcicpO1xuICB9XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdzaXplIG11c3QgYmUgYSBudW1iZXInKTtcbiAgfVxuICBpZiAoc2l6ZSA+IE1BWF9MRU4pIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc2l6ZSBpcyB0b28gbGFyZ2UnKTtcbiAgfVxuICB2YXIgZW5jID0gZW5jb2Rpbmc7XG4gIHZhciBfZmlsbCA9IGZpbGw7XG4gIGlmIChfZmlsbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jID0gdW5kZWZpbmVkO1xuICAgIF9maWxsID0gMDtcbiAgfVxuICB2YXIgYnVmID0gbmV3IEJ1ZmZlcihzaXplKTtcbiAgaWYgKHR5cGVvZiBfZmlsbCA9PT0gJ3N0cmluZycpIHtcbiAgICB2YXIgZmlsbEJ1ZiA9IG5ldyBCdWZmZXIoX2ZpbGwsIGVuYyk7XG4gICAgdmFyIGZsZW4gPSBmaWxsQnVmLmxlbmd0aDtcbiAgICB2YXIgaSA9IC0xO1xuICAgIHdoaWxlICgrK2kgPCBzaXplKSB7XG4gICAgICBidWZbaV0gPSBmaWxsQnVmW2kgJSBmbGVuXTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgYnVmLmZpbGwoX2ZpbGwpO1xuICB9XG4gIHJldHVybiBidWY7XG59XG5leHBvcnRzLmFsbG9jVW5zYWZlID0gZnVuY3Rpb24gYWxsb2NVbnNhZmUoc2l6ZSkge1xuICBpZiAodHlwZW9mIEJ1ZmZlci5hbGxvY1Vuc2FmZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBCdWZmZXIuYWxsb2NVbnNhZmUoc2l6ZSk7XG4gIH1cbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3NpemUgbXVzdCBiZSBhIG51bWJlcicpO1xuICB9XG4gIGlmIChzaXplID4gTUFYX0xFTikge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdzaXplIGlzIHRvbyBsYXJnZScpO1xuICB9XG4gIHJldHVybiBuZXcgQnVmZmVyKHNpemUpO1xufVxuZXhwb3J0cy5mcm9tID0gZnVuY3Rpb24gZnJvbSh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICh0eXBlb2YgQnVmZmVyLmZyb20gPT09ICdmdW5jdGlvbicgJiYgKCFnbG9iYWwuVWludDhBcnJheSB8fCBVaW50OEFycmF5LmZyb20gIT09IEJ1ZmZlci5mcm9tKSkge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbSh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKTtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBhIG51bWJlcicpO1xuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIG5ldyBCdWZmZXIodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQpO1xuICB9XG4gIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIHZhbHVlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICB2YXIgb2Zmc2V0ID0gZW5jb2RpbmdPck9mZnNldDtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgcmV0dXJuIG5ldyBCdWZmZXIodmFsdWUpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9mZnNldCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIG9mZnNldCA9IDA7XG4gICAgfVxuICAgIHZhciBsZW4gPSBsZW5ndGg7XG4gICAgaWYgKHR5cGVvZiBsZW4gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBsZW4gPSB2YWx1ZS5ieXRlTGVuZ3RoIC0gb2Zmc2V0O1xuICAgIH1cbiAgICBpZiAob2Zmc2V0ID49IHZhbHVlLmJ5dGVMZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcXCdvZmZzZXRcXCcgaXMgb3V0IG9mIGJvdW5kcycpO1xuICAgIH1cbiAgICBpZiAobGVuID4gdmFsdWUuYnl0ZUxlbmd0aCAtIG9mZnNldCkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1xcJ2xlbmd0aFxcJyBpcyBvdXQgb2YgYm91bmRzJyk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgQnVmZmVyKHZhbHVlLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgbGVuKSk7XG4gIH1cbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2YWx1ZSkpIHtcbiAgICB2YXIgb3V0ID0gbmV3IEJ1ZmZlcih2YWx1ZS5sZW5ndGgpO1xuICAgIHZhbHVlLmNvcHkob3V0LCAwLCAwLCB2YWx1ZS5sZW5ndGgpO1xuICAgIHJldHVybiBvdXQ7XG4gIH1cbiAgaWYgKHZhbHVlKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpIHx8ICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIHZhbHVlLmJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB8fCAnbGVuZ3RoJyBpbiB2YWx1ZSkge1xuICAgICAgcmV0dXJuIG5ldyBCdWZmZXIodmFsdWUpO1xuICAgIH1cbiAgICBpZiAodmFsdWUudHlwZSA9PT0gJ0J1ZmZlcicgJiYgQXJyYXkuaXNBcnJheSh2YWx1ZS5kYXRhKSkge1xuICAgICAgcmV0dXJuIG5ldyBCdWZmZXIodmFsdWUuZGF0YSk7XG4gICAgfVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcignRmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZywgQnVmZmVyLCAnICsgJ0FycmF5QnVmZmVyLCBBcnJheSwgb3IgYXJyYXktbGlrZSBvYmplY3QuJyk7XG59XG5leHBvcnRzLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uIGFsbG9jVW5zYWZlU2xvdyhzaXplKSB7XG4gIGlmICh0eXBlb2YgQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBCdWZmZXIuYWxsb2NVbnNhZmVTbG93KHNpemUpO1xuICB9XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdzaXplIG11c3QgYmUgYSBudW1iZXInKTtcbiAgfVxuICBpZiAoc2l6ZSA+PSBNQVhfTEVOKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NpemUgaXMgdG9vIGxhcmdlJyk7XG4gIH1cbiAgcmV0dXJuIG5ldyBTbG93QnVmZmVyKHNpemUpO1xufVxuIiwiLyohXG4gKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci5cbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8ZmVyb3NzQGZlcm9zcy5vcmc+IDxodHRwOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cblxuJ3VzZSBzdHJpY3QnXG5cbnZhciBiYXNlNjQgPSByZXF1aXJlKCdiYXNlNjQtanMnKVxudmFyIGllZWU3NTQgPSByZXF1aXJlKCdpZWVlNzU0JylcbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnaXNhcnJheScpXG5cbmV4cG9ydHMuQnVmZmVyID0gQnVmZmVyXG5leHBvcnRzLlNsb3dCdWZmZXIgPSBTbG93QnVmZmVyXG5leHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTID0gNTBcblxuLyoqXG4gKiBJZiBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgOlxuICogICA9PT0gdHJ1ZSAgICBVc2UgVWludDhBcnJheSBpbXBsZW1lbnRhdGlvbiAoZmFzdGVzdClcbiAqICAgPT09IGZhbHNlICAgVXNlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiAobW9zdCBjb21wYXRpYmxlLCBldmVuIElFNilcbiAqXG4gKiBCcm93c2VycyB0aGF0IHN1cHBvcnQgdHlwZWQgYXJyYXlzIGFyZSBJRSAxMCssIEZpcmVmb3ggNCssIENocm9tZSA3KywgU2FmYXJpIDUuMSssXG4gKiBPcGVyYSAxMS42KywgaU9TIDQuMisuXG4gKlxuICogRHVlIHRvIHZhcmlvdXMgYnJvd3NlciBidWdzLCBzb21ldGltZXMgdGhlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiB3aWxsIGJlIHVzZWQgZXZlblxuICogd2hlbiB0aGUgYnJvd3NlciBzdXBwb3J0cyB0eXBlZCBhcnJheXMuXG4gKlxuICogTm90ZTpcbiAqXG4gKiAgIC0gRmlyZWZveCA0LTI5IGxhY2tzIHN1cHBvcnQgZm9yIGFkZGluZyBuZXcgcHJvcGVydGllcyB0byBgVWludDhBcnJheWAgaW5zdGFuY2VzLFxuICogICAgIFNlZTogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njk1NDM4LlxuICpcbiAqICAgLSBDaHJvbWUgOS0xMCBpcyBtaXNzaW5nIHRoZSBgVHlwZWRBcnJheS5wcm90b3R5cGUuc3ViYXJyYXlgIGZ1bmN0aW9uLlxuICpcbiAqICAgLSBJRTEwIGhhcyBhIGJyb2tlbiBgVHlwZWRBcnJheS5wcm90b3R5cGUuc3ViYXJyYXlgIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgYXJyYXlzIG9mXG4gKiAgICAgaW5jb3JyZWN0IGxlbmd0aCBpbiBzb21lIHNpdHVhdGlvbnMuXG5cbiAqIFdlIGRldGVjdCB0aGVzZSBidWdneSBicm93c2VycyBhbmQgc2V0IGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGAgdG8gYGZhbHNlYCBzbyB0aGV5XG4gKiBnZXQgdGhlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiwgd2hpY2ggaXMgc2xvd2VyIGJ1dCBiZWhhdmVzIGNvcnJlY3RseS5cbiAqL1xuQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgPSBnbG9iYWwuVFlQRURfQVJSQVlfU1VQUE9SVCAhPT0gdW5kZWZpbmVkXG4gID8gZ2xvYmFsLlRZUEVEX0FSUkFZX1NVUFBPUlRcbiAgOiB0eXBlZEFycmF5U3VwcG9ydCgpXG5cbi8qXG4gKiBFeHBvcnQga01heExlbmd0aCBhZnRlciB0eXBlZCBhcnJheSBzdXBwb3J0IGlzIGRldGVybWluZWQuXG4gKi9cbmV4cG9ydHMua01heExlbmd0aCA9IGtNYXhMZW5ndGgoKVxuXG5mdW5jdGlvbiB0eXBlZEFycmF5U3VwcG9ydCAoKSB7XG4gIHRyeSB7XG4gICAgdmFyIGFyciA9IG5ldyBVaW50OEFycmF5KDEpXG4gICAgYXJyLl9fcHJvdG9fXyA9IHtfX3Byb3RvX186IFVpbnQ4QXJyYXkucHJvdG90eXBlLCBmb286IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDQyIH19XG4gICAgcmV0dXJuIGFyci5mb28oKSA9PT0gNDIgJiYgLy8gdHlwZWQgYXJyYXkgaW5zdGFuY2VzIGNhbiBiZSBhdWdtZW50ZWRcbiAgICAgICAgdHlwZW9mIGFyci5zdWJhcnJheSA9PT0gJ2Z1bmN0aW9uJyAmJiAvLyBjaHJvbWUgOS0xMCBsYWNrIGBzdWJhcnJheWBcbiAgICAgICAgYXJyLnN1YmFycmF5KDEsIDEpLmJ5dGVMZW5ndGggPT09IDAgLy8gaWUxMCBoYXMgYnJva2VuIGBzdWJhcnJheWBcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbmZ1bmN0aW9uIGtNYXhMZW5ndGggKCkge1xuICByZXR1cm4gQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRcbiAgICA/IDB4N2ZmZmZmZmZcbiAgICA6IDB4M2ZmZmZmZmZcbn1cblxuZnVuY3Rpb24gY3JlYXRlQnVmZmVyICh0aGF0LCBsZW5ndGgpIHtcbiAgaWYgKGtNYXhMZW5ndGgoKSA8IGxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbnZhbGlkIHR5cGVkIGFycmF5IGxlbmd0aCcpXG4gIH1cbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2UsIGZvciBiZXN0IHBlcmZvcm1hbmNlXG4gICAgdGhhdCA9IG5ldyBVaW50OEFycmF5KGxlbmd0aClcbiAgICB0aGF0Ll9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgfSBlbHNlIHtcbiAgICAvLyBGYWxsYmFjazogUmV0dXJuIGFuIG9iamVjdCBpbnN0YW5jZSBvZiB0aGUgQnVmZmVyIGNsYXNzXG4gICAgaWYgKHRoYXQgPT09IG51bGwpIHtcbiAgICAgIHRoYXQgPSBuZXcgQnVmZmVyKGxlbmd0aClcbiAgICB9XG4gICAgdGhhdC5sZW5ndGggPSBsZW5ndGhcbiAgfVxuXG4gIHJldHVybiB0aGF0XG59XG5cbi8qKlxuICogVGhlIEJ1ZmZlciBjb25zdHJ1Y3RvciByZXR1cm5zIGluc3RhbmNlcyBvZiBgVWludDhBcnJheWAgdGhhdCBoYXZlIHRoZWlyXG4gKiBwcm90b3R5cGUgY2hhbmdlZCB0byBgQnVmZmVyLnByb3RvdHlwZWAuIEZ1cnRoZXJtb3JlLCBgQnVmZmVyYCBpcyBhIHN1YmNsYXNzIG9mXG4gKiBgVWludDhBcnJheWAsIHNvIHRoZSByZXR1cm5lZCBpbnN0YW5jZXMgd2lsbCBoYXZlIGFsbCB0aGUgbm9kZSBgQnVmZmVyYCBtZXRob2RzXG4gKiBhbmQgdGhlIGBVaW50OEFycmF5YCBtZXRob2RzLiBTcXVhcmUgYnJhY2tldCBub3RhdGlvbiB3b3JrcyBhcyBleHBlY3RlZCAtLSBpdFxuICogcmV0dXJucyBhIHNpbmdsZSBvY3RldC5cbiAqXG4gKiBUaGUgYFVpbnQ4QXJyYXlgIHByb3RvdHlwZSByZW1haW5zIHVubW9kaWZpZWQuXG4gKi9cblxuZnVuY3Rpb24gQnVmZmVyIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmICEodGhpcyBpbnN0YW5jZW9mIEJ1ZmZlcikpIHtcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcihhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIC8vIENvbW1vbiBjYXNlLlxuICBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcbiAgICBpZiAodHlwZW9mIGVuY29kaW5nT3JPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdJZiBlbmNvZGluZyBpcyBzcGVjaWZpZWQgdGhlbiB0aGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZydcbiAgICAgIClcbiAgICB9XG4gICAgcmV0dXJuIGFsbG9jVW5zYWZlKHRoaXMsIGFyZylcbiAgfVxuICByZXR1cm4gZnJvbSh0aGlzLCBhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnBvb2xTaXplID0gODE5MiAvLyBub3QgdXNlZCBieSB0aGlzIGltcGxlbWVudGF0aW9uXG5cbi8vIFRPRE86IExlZ2FjeSwgbm90IG5lZWRlZCBhbnltb3JlLiBSZW1vdmUgaW4gbmV4dCBtYWpvciB2ZXJzaW9uLlxuQnVmZmVyLl9hdWdtZW50ID0gZnVuY3Rpb24gKGFycikge1xuICBhcnIuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICByZXR1cm4gYXJyXG59XG5cbmZ1bmN0aW9uIGZyb20gKHRoYXQsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgYSBudW1iZXInKVxuICB9XG5cbiAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgdmFsdWUgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIHJldHVybiBmcm9tQXJyYXlCdWZmZXIodGhhdCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGZyb21TdHJpbmcodGhhdCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQpXG4gIH1cblxuICByZXR1cm4gZnJvbU9iamVjdCh0aGF0LCB2YWx1ZSlcbn1cblxuLyoqXG4gKiBGdW5jdGlvbmFsbHkgZXF1aXZhbGVudCB0byBCdWZmZXIoYXJnLCBlbmNvZGluZykgYnV0IHRocm93cyBhIFR5cGVFcnJvclxuICogaWYgdmFsdWUgaXMgYSBudW1iZXIuXG4gKiBCdWZmZXIuZnJvbShzdHJbLCBlbmNvZGluZ10pXG4gKiBCdWZmZXIuZnJvbShhcnJheSlcbiAqIEJ1ZmZlci5mcm9tKGJ1ZmZlcilcbiAqIEJ1ZmZlci5mcm9tKGFycmF5QnVmZmVyWywgYnl0ZU9mZnNldFssIGxlbmd0aF1dKVxuICoqL1xuQnVmZmVyLmZyb20gPSBmdW5jdGlvbiAodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gZnJvbShudWxsLCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG5pZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgQnVmZmVyLnByb3RvdHlwZS5fX3Byb3RvX18gPSBVaW50OEFycmF5LnByb3RvdHlwZVxuICBCdWZmZXIuX19wcm90b19fID0gVWludDhBcnJheVxuICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnNwZWNpZXMgJiZcbiAgICAgIEJ1ZmZlcltTeW1ib2wuc3BlY2llc10gPT09IEJ1ZmZlcikge1xuICAgIC8vIEZpeCBzdWJhcnJheSgpIGluIEVTMjAxNi4gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9wdWxsLzk3XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlciwgU3ltYm9sLnNwZWNpZXMsIHtcbiAgICAgIHZhbHVlOiBudWxsLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSlcbiAgfVxufVxuXG5mdW5jdGlvbiBhc3NlcnRTaXplIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfSBlbHNlIGlmIChzaXplIDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBuZWdhdGl2ZScpXG4gIH1cbn1cblxuZnVuY3Rpb24gYWxsb2MgKHRoYXQsIHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgaWYgKHNpemUgPD0gMCkge1xuICAgIHJldHVybiBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSlcbiAgfVxuICBpZiAoZmlsbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gT25seSBwYXkgYXR0ZW50aW9uIHRvIGVuY29kaW5nIGlmIGl0J3MgYSBzdHJpbmcuIFRoaXNcbiAgICAvLyBwcmV2ZW50cyBhY2NpZGVudGFsbHkgc2VuZGluZyBpbiBhIG51bWJlciB0aGF0IHdvdWxkXG4gICAgLy8gYmUgaW50ZXJwcmV0dGVkIGFzIGEgc3RhcnQgb2Zmc2V0LlxuICAgIHJldHVybiB0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnXG4gICAgICA/IGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKS5maWxsKGZpbGwsIGVuY29kaW5nKVxuICAgICAgOiBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSkuZmlsbChmaWxsKVxuICB9XG4gIHJldHVybiBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSlcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiBhbGxvYyhzaXplWywgZmlsbFssIGVuY29kaW5nXV0pXG4gKiovXG5CdWZmZXIuYWxsb2MgPSBmdW5jdGlvbiAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGFsbG9jKG51bGwsIHNpemUsIGZpbGwsIGVuY29kaW5nKVxufVxuXG5mdW5jdGlvbiBhbGxvY1Vuc2FmZSAodGhhdCwgc2l6ZSkge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSA8IDAgPyAwIDogY2hlY2tlZChzaXplKSB8IDApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemU7ICsraSkge1xuICAgICAgdGhhdFtpXSA9IDBcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIEJ1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZSA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShudWxsLCBzaXplKVxufVxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIFNsb3dCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShudWxsLCBzaXplKVxufVxuXG5mdW5jdGlvbiBmcm9tU3RyaW5nICh0aGF0LCBzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnIHx8IGVuY29kaW5nID09PSAnJykge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gIH1cblxuICBpZiAoIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiZW5jb2RpbmdcIiBtdXN0IGJlIGEgdmFsaWQgc3RyaW5nIGVuY29kaW5nJylcbiAgfVxuXG4gIHZhciBsZW5ndGggPSBieXRlTGVuZ3RoKHN0cmluZywgZW5jb2RpbmcpIHwgMFxuICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIGxlbmd0aClcblxuICB2YXIgYWN0dWFsID0gdGhhdC53cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuXG4gIGlmIChhY3R1YWwgIT09IGxlbmd0aCkge1xuICAgIC8vIFdyaXRpbmcgYSBoZXggc3RyaW5nLCBmb3IgZXhhbXBsZSwgdGhhdCBjb250YWlucyBpbnZhbGlkIGNoYXJhY3RlcnMgd2lsbFxuICAgIC8vIGNhdXNlIGV2ZXJ5dGhpbmcgYWZ0ZXIgdGhlIGZpcnN0IGludmFsaWQgY2hhcmFjdGVyIHRvIGJlIGlnbm9yZWQuIChlLmcuXG4gICAgLy8gJ2FieHhjZCcgd2lsbCBiZSB0cmVhdGVkIGFzICdhYicpXG4gICAgdGhhdCA9IHRoYXQuc2xpY2UoMCwgYWN0dWFsKVxuICB9XG5cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5TGlrZSAodGhhdCwgYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCA8IDAgPyAwIDogY2hlY2tlZChhcnJheS5sZW5ndGgpIHwgMFxuICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIGxlbmd0aClcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgIHRoYXRbaV0gPSBhcnJheVtpXSAmIDI1NVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUJ1ZmZlciAodGhhdCwgYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICBhcnJheS5ieXRlTGVuZ3RoIC8vIHRoaXMgdGhyb3dzIGlmIGBhcnJheWAgaXMgbm90IGEgdmFsaWQgQXJyYXlCdWZmZXJcblxuICBpZiAoYnl0ZU9mZnNldCA8IDAgfHwgYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXFwnb2Zmc2V0XFwnIGlzIG91dCBvZiBib3VuZHMnKVxuICB9XG5cbiAgaWYgKGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0ICsgKGxlbmd0aCB8fCAwKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcXCdsZW5ndGhcXCcgaXMgb3V0IG9mIGJvdW5kcycpXG4gIH1cblxuICBpZiAoYnl0ZU9mZnNldCA9PT0gdW5kZWZpbmVkICYmIGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheSlcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQpXG4gIH0gZWxzZSB7XG4gICAgYXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2UsIGZvciBiZXN0IHBlcmZvcm1hbmNlXG4gICAgdGhhdCA9IGFycmF5XG4gICAgdGhhdC5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIH0gZWxzZSB7XG4gICAgLy8gRmFsbGJhY2s6IFJldHVybiBhbiBvYmplY3QgaW5zdGFuY2Ugb2YgdGhlIEJ1ZmZlciBjbGFzc1xuICAgIHRoYXQgPSBmcm9tQXJyYXlMaWtlKHRoYXQsIGFycmF5KVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21PYmplY3QgKHRoYXQsIG9iaikge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKG9iaikpIHtcbiAgICB2YXIgbGVuID0gY2hlY2tlZChvYmoubGVuZ3RoKSB8IDBcbiAgICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIGxlbilcblxuICAgIGlmICh0aGF0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoYXRcbiAgICB9XG5cbiAgICBvYmouY29weSh0aGF0LCAwLCAwLCBsZW4pXG4gICAgcmV0dXJuIHRoYXRcbiAgfVxuXG4gIGlmIChvYmopIHtcbiAgICBpZiAoKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgb2JqLmJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB8fCAnbGVuZ3RoJyBpbiBvYmopIHtcbiAgICAgIGlmICh0eXBlb2Ygb2JqLmxlbmd0aCAhPT0gJ251bWJlcicgfHwgaXNuYW4ob2JqLmxlbmd0aCkpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcih0aGF0LCAwKVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZyb21BcnJheUxpa2UodGhhdCwgb2JqKVxuICAgIH1cblxuICAgIGlmIChvYmoudHlwZSA9PT0gJ0J1ZmZlcicgJiYgaXNBcnJheShvYmouZGF0YSkpIHtcbiAgICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKHRoYXQsIG9iai5kYXRhKVxuICAgIH1cbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCBvciBhcnJheS1saWtlIG9iamVjdC4nKVxufVxuXG5mdW5jdGlvbiBjaGVja2VkIChsZW5ndGgpIHtcbiAgLy8gTm90ZTogY2Fubm90IHVzZSBgbGVuZ3RoIDwga01heExlbmd0aCgpYCBoZXJlIGJlY2F1c2UgdGhhdCBmYWlscyB3aGVuXG4gIC8vIGxlbmd0aCBpcyBOYU4gKHdoaWNoIGlzIG90aGVyd2lzZSBjb2VyY2VkIHRvIHplcm8uKVxuICBpZiAobGVuZ3RoID49IGtNYXhMZW5ndGgoKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIGFsbG9jYXRlIEJ1ZmZlciBsYXJnZXIgdGhhbiBtYXhpbXVtICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICdzaXplOiAweCcgKyBrTWF4TGVuZ3RoKCkudG9TdHJpbmcoMTYpICsgJyBieXRlcycpXG4gIH1cbiAgcmV0dXJuIGxlbmd0aCB8IDBcbn1cblxuZnVuY3Rpb24gU2xvd0J1ZmZlciAobGVuZ3RoKSB7XG4gIGlmICgrbGVuZ3RoICE9IGxlbmd0aCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcVxuICAgIGxlbmd0aCA9IDBcbiAgfVxuICByZXR1cm4gQnVmZmVyLmFsbG9jKCtsZW5ndGgpXG59XG5cbkJ1ZmZlci5pc0J1ZmZlciA9IGZ1bmN0aW9uIGlzQnVmZmVyIChiKSB7XG4gIHJldHVybiAhIShiICE9IG51bGwgJiYgYi5faXNCdWZmZXIpXG59XG5cbkJ1ZmZlci5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAoYSwgYikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihhKSB8fCAhQnVmZmVyLmlzQnVmZmVyKGIpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnRzIG11c3QgYmUgQnVmZmVycycpXG4gIH1cblxuICBpZiAoYSA9PT0gYikgcmV0dXJuIDBcblxuICB2YXIgeCA9IGEubGVuZ3RoXG4gIHZhciB5ID0gYi5sZW5ndGhcblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gTWF0aC5taW4oeCwgeSk7IGkgPCBsZW47ICsraSkge1xuICAgIGlmIChhW2ldICE9PSBiW2ldKSB7XG4gICAgICB4ID0gYVtpXVxuICAgICAgeSA9IGJbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG5CdWZmZXIuaXNFbmNvZGluZyA9IGZ1bmN0aW9uIGlzRW5jb2RpbmcgKGVuY29kaW5nKSB7XG4gIHN3aXRjaCAoU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgY2FzZSAnYXNjaWknOlxuICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5CdWZmZXIuY29uY2F0ID0gZnVuY3Rpb24gY29uY2F0IChsaXN0LCBsZW5ndGgpIHtcbiAgaWYgKCFpc0FycmF5KGxpc3QpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgfVxuXG4gIGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBCdWZmZXIuYWxsb2MoMClcbiAgfVxuXG4gIHZhciBpXG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGxlbmd0aCA9IDBcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgICAgbGVuZ3RoICs9IGxpc3RbaV0ubGVuZ3RoXG4gICAgfVxuICB9XG5cbiAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShsZW5ndGgpXG4gIHZhciBwb3MgPSAwXG4gIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGJ1ZiA9IGxpc3RbaV1cbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICAgIH1cbiAgICBidWYuY29weShidWZmZXIsIHBvcylcbiAgICBwb3MgKz0gYnVmLmxlbmd0aFxuICB9XG4gIHJldHVybiBidWZmZXJcbn1cblxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHN0cmluZykpIHtcbiAgICByZXR1cm4gc3RyaW5nLmxlbmd0aFxuICB9XG4gIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBBcnJheUJ1ZmZlci5pc1ZpZXcgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgIChBcnJheUJ1ZmZlci5pc1ZpZXcoc3RyaW5nKSB8fCBzdHJpbmcgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikpIHtcbiAgICByZXR1cm4gc3RyaW5nLmJ5dGVMZW5ndGhcbiAgfVxuICBpZiAodHlwZW9mIHN0cmluZyAhPT0gJ3N0cmluZycpIHtcbiAgICBzdHJpbmcgPSAnJyArIHN0cmluZ1xuICB9XG5cbiAgdmFyIGxlbiA9IHN0cmluZy5sZW5ndGhcbiAgaWYgKGxlbiA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBVc2UgYSBmb3IgbG9vcCB0byBhdm9pZCByZWN1cnNpb25cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGVuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgIGNhc2UgdW5kZWZpbmVkOlxuICAgICAgICByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiBsZW4gKiAyXG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gbGVuID4+PiAxXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGggLy8gYXNzdW1lIHV0ZjhcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cbkJ1ZmZlci5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuXG5mdW5jdGlvbiBzbG93VG9TdHJpbmcgKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG5cbiAgLy8gTm8gbmVlZCB0byB2ZXJpZnkgdGhhdCBcInRoaXMubGVuZ3RoIDw9IE1BWF9VSU5UMzJcIiBzaW5jZSBpdCdzIGEgcmVhZC1vbmx5XG4gIC8vIHByb3BlcnR5IG9mIGEgdHlwZWQgYXJyYXkuXG5cbiAgLy8gVGhpcyBiZWhhdmVzIG5laXRoZXIgbGlrZSBTdHJpbmcgbm9yIFVpbnQ4QXJyYXkgaW4gdGhhdCB3ZSBzZXQgc3RhcnQvZW5kXG4gIC8vIHRvIHRoZWlyIHVwcGVyL2xvd2VyIGJvdW5kcyBpZiB0aGUgdmFsdWUgcGFzc2VkIGlzIG91dCBvZiByYW5nZS5cbiAgLy8gdW5kZWZpbmVkIGlzIGhhbmRsZWQgc3BlY2lhbGx5IGFzIHBlciBFQ01BLTI2MiA2dGggRWRpdGlvbixcbiAgLy8gU2VjdGlvbiAxMy4zLjMuNyBSdW50aW1lIFNlbWFudGljczogS2V5ZWRCaW5kaW5nSW5pdGlhbGl6YXRpb24uXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkIHx8IHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIC8vIFJldHVybiBlYXJseSBpZiBzdGFydCA+IHRoaXMubGVuZ3RoLiBEb25lIGhlcmUgdG8gcHJldmVudCBwb3RlbnRpYWwgdWludDMyXG4gIC8vIGNvZXJjaW9uIGZhaWwgYmVsb3cuXG4gIGlmIChzdGFydCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoZW5kID09PSB1bmRlZmluZWQgfHwgZW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKGVuZCA8PSAwKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICAvLyBGb3JjZSBjb2Vyc2lvbiB0byB1aW50MzIuIFRoaXMgd2lsbCBhbHNvIGNvZXJjZSBmYWxzZXkvTmFOIHZhbHVlcyB0byAwLlxuICBlbmQgPj4+PSAwXG4gIHN0YXJ0ID4+Pj0gMFxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxhdGluMVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdXRmMTZsZVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9IChlbmNvZGluZyArICcnKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG4vLyBUaGUgcHJvcGVydHkgaXMgdXNlZCBieSBgQnVmZmVyLmlzQnVmZmVyYCBhbmQgYGlzLWJ1ZmZlcmAgKGluIFNhZmFyaSA1LTcpIHRvIGRldGVjdFxuLy8gQnVmZmVyIGluc3RhbmNlcy5cbkJ1ZmZlci5wcm90b3R5cGUuX2lzQnVmZmVyID0gdHJ1ZVxuXG5mdW5jdGlvbiBzd2FwIChiLCBuLCBtKSB7XG4gIHZhciBpID0gYltuXVxuICBiW25dID0gYlttXVxuICBiW21dID0gaVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAxNiA9IGZ1bmN0aW9uIHN3YXAxNiAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgMiAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMTYtYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gMikge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDEpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMzIgPSBmdW5jdGlvbiBzd2FwMzIgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDQgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDMyLWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAzKVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyAyKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDY0ID0gZnVuY3Rpb24gc3dhcDY0ICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA4ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA2NC1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA4KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgNylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgNilcbiAgICBzd2FwKHRoaXMsIGkgKyAyLCBpICsgNSlcbiAgICBzd2FwKHRoaXMsIGkgKyAzLCBpICsgNClcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICB2YXIgbGVuZ3RoID0gdGhpcy5sZW5ndGggfCAwXG4gIGlmIChsZW5ndGggPT09IDApIHJldHVybiAnJ1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCAwLCBsZW5ndGgpXG4gIHJldHVybiBzbG93VG9TdHJpbmcuYXBwbHkodGhpcywgYXJndW1lbnRzKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyAoYikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihiKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIGlmICh0aGlzID09PSBiKSByZXR1cm4gdHJ1ZVxuICByZXR1cm4gQnVmZmVyLmNvbXBhcmUodGhpcywgYikgPT09IDBcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gaW5zcGVjdCAoKSB7XG4gIHZhciBzdHIgPSAnJ1xuICB2YXIgbWF4ID0gZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFU1xuICBpZiAodGhpcy5sZW5ndGggPiAwKSB7XG4gICAgc3RyID0gdGhpcy50b1N0cmluZygnaGV4JywgMCwgbWF4KS5tYXRjaCgvLnsyfS9nKS5qb2luKCcgJylcbiAgICBpZiAodGhpcy5sZW5ndGggPiBtYXgpIHN0ciArPSAnIC4uLiAnXG4gIH1cbiAgcmV0dXJuICc8QnVmZmVyICcgKyBzdHIgKyAnPidcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAodGFyZ2V0LCBzdGFydCwgZW5kLCB0aGlzU3RhcnQsIHRoaXNFbmQpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGFyZ2V0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICB9XG5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICBzdGFydCA9IDBcbiAgfVxuICBpZiAoZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmQgPSB0YXJnZXQgPyB0YXJnZXQubGVuZ3RoIDogMFxuICB9XG4gIGlmICh0aGlzU3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNTdGFydCA9IDBcbiAgfVxuICBpZiAodGhpc0VuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc0VuZCA9IHRoaXMubGVuZ3RoXG4gIH1cblxuICBpZiAoc3RhcnQgPCAwIHx8IGVuZCA+IHRhcmdldC5sZW5ndGggfHwgdGhpc1N0YXJ0IDwgMCB8fCB0aGlzRW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCAmJiBzdGFydCA+PSBlbmQpIHtcbiAgICByZXR1cm4gMFxuICB9XG4gIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCkge1xuICAgIHJldHVybiAtMVxuICB9XG4gIGlmIChzdGFydCA+PSBlbmQpIHtcbiAgICByZXR1cm4gMVxuICB9XG5cbiAgc3RhcnQgPj4+PSAwXG4gIGVuZCA+Pj49IDBcbiAgdGhpc1N0YXJ0ID4+Pj0gMFxuICB0aGlzRW5kID4+Pj0gMFxuXG4gIGlmICh0aGlzID09PSB0YXJnZXQpIHJldHVybiAwXG5cbiAgdmFyIHggPSB0aGlzRW5kIC0gdGhpc1N0YXJ0XG4gIHZhciB5ID0gZW5kIC0gc3RhcnRcbiAgdmFyIGxlbiA9IE1hdGgubWluKHgsIHkpXG5cbiAgdmFyIHRoaXNDb3B5ID0gdGhpcy5zbGljZSh0aGlzU3RhcnQsIHRoaXNFbmQpXG4gIHZhciB0YXJnZXRDb3B5ID0gdGFyZ2V0LnNsaWNlKHN0YXJ0LCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIGlmICh0aGlzQ29weVtpXSAhPT0gdGFyZ2V0Q29weVtpXSkge1xuICAgICAgeCA9IHRoaXNDb3B5W2ldXG4gICAgICB5ID0gdGFyZ2V0Q29weVtpXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbi8vIEZpbmRzIGVpdGhlciB0aGUgZmlyc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0ID49IGBieXRlT2Zmc2V0YCxcbi8vIE9SIHRoZSBsYXN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA8PSBgYnl0ZU9mZnNldGAuXG4vL1xuLy8gQXJndW1lbnRzOlxuLy8gLSBidWZmZXIgLSBhIEJ1ZmZlciB0byBzZWFyY2hcbi8vIC0gdmFsIC0gYSBzdHJpbmcsIEJ1ZmZlciwgb3IgbnVtYmVyXG4vLyAtIGJ5dGVPZmZzZXQgLSBhbiBpbmRleCBpbnRvIGBidWZmZXJgOyB3aWxsIGJlIGNsYW1wZWQgdG8gYW4gaW50MzJcbi8vIC0gZW5jb2RpbmcgLSBhbiBvcHRpb25hbCBlbmNvZGluZywgcmVsZXZhbnQgaXMgdmFsIGlzIGEgc3RyaW5nXG4vLyAtIGRpciAtIHRydWUgZm9yIGluZGV4T2YsIGZhbHNlIGZvciBsYXN0SW5kZXhPZlxuZnVuY3Rpb24gYmlkaXJlY3Rpb25hbEluZGV4T2YgKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIC8vIEVtcHR5IGJ1ZmZlciBtZWFucyBubyBtYXRjaFxuICBpZiAoYnVmZmVyLmxlbmd0aCA9PT0gMCkgcmV0dXJuIC0xXG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXRcbiAgaWYgKHR5cGVvZiBieXRlT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gYnl0ZU9mZnNldFxuICAgIGJ5dGVPZmZzZXQgPSAwXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA+IDB4N2ZmZmZmZmYpIHtcbiAgICBieXRlT2Zmc2V0ID0gMHg3ZmZmZmZmZlxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAtMHg4MDAwMDAwMCkge1xuICAgIGJ5dGVPZmZzZXQgPSAtMHg4MDAwMDAwMFxuICB9XG4gIGJ5dGVPZmZzZXQgPSArYnl0ZU9mZnNldCAgLy8gQ29lcmNlIHRvIE51bWJlci5cbiAgaWYgKGlzTmFOKGJ5dGVPZmZzZXQpKSB7XG4gICAgLy8gYnl0ZU9mZnNldDogaXQgaXQncyB1bmRlZmluZWQsIG51bGwsIE5hTiwgXCJmb29cIiwgZXRjLCBzZWFyY2ggd2hvbGUgYnVmZmVyXG4gICAgYnl0ZU9mZnNldCA9IGRpciA/IDAgOiAoYnVmZmVyLmxlbmd0aCAtIDEpXG4gIH1cblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldDogbmVnYXRpdmUgb2Zmc2V0cyBzdGFydCBmcm9tIHRoZSBlbmQgb2YgdGhlIGJ1ZmZlclxuICBpZiAoYnl0ZU9mZnNldCA8IDApIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoICsgYnl0ZU9mZnNldFxuICBpZiAoYnl0ZU9mZnNldCA+PSBidWZmZXIubGVuZ3RoKSB7XG4gICAgaWYgKGRpcikgcmV0dXJuIC0xXG4gICAgZWxzZSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCAtIDFcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgMCkge1xuICAgIGlmIChkaXIpIGJ5dGVPZmZzZXQgPSAwXG4gICAgZWxzZSByZXR1cm4gLTFcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSB2YWxcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFsID0gQnVmZmVyLmZyb20odmFsLCBlbmNvZGluZylcbiAgfVxuXG4gIC8vIEZpbmFsbHksIHNlYXJjaCBlaXRoZXIgaW5kZXhPZiAoaWYgZGlyIGlzIHRydWUpIG9yIGxhc3RJbmRleE9mXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsKSkge1xuICAgIC8vIFNwZWNpYWwgY2FzZTogbG9va2luZyBmb3IgZW1wdHkgc3RyaW5nL2J1ZmZlciBhbHdheXMgZmFpbHNcbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIC0xXG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAweEZGIC8vIFNlYXJjaCBmb3IgYSBieXRlIHZhbHVlIFswLTI1NV1cbiAgICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiZcbiAgICAgICAgdHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmIChkaXIpIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5sYXN0SW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgWyB2YWwgXSwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ3ZhbCBtdXN0IGJlIHN0cmluZywgbnVtYmVyIG9yIEJ1ZmZlcicpXG59XG5cbmZ1bmN0aW9uIGFycmF5SW5kZXhPZiAoYXJyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgdmFyIGluZGV4U2l6ZSA9IDFcbiAgdmFyIGFyckxlbmd0aCA9IGFyci5sZW5ndGhcbiAgdmFyIHZhbExlbmd0aCA9IHZhbC5sZW5ndGhcblxuICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgaWYgKGVuY29kaW5nID09PSAndWNzMicgfHwgZW5jb2RpbmcgPT09ICd1Y3MtMicgfHxcbiAgICAgICAgZW5jb2RpbmcgPT09ICd1dGYxNmxlJyB8fCBlbmNvZGluZyA9PT0gJ3V0Zi0xNmxlJykge1xuICAgICAgaWYgKGFyci5sZW5ndGggPCAyIHx8IHZhbC5sZW5ndGggPCAyKSB7XG4gICAgICAgIHJldHVybiAtMVxuICAgICAgfVxuICAgICAgaW5kZXhTaXplID0gMlxuICAgICAgYXJyTGVuZ3RoIC89IDJcbiAgICAgIHZhbExlbmd0aCAvPSAyXG4gICAgICBieXRlT2Zmc2V0IC89IDJcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWFkIChidWYsIGkpIHtcbiAgICBpZiAoaW5kZXhTaXplID09PSAxKSB7XG4gICAgICByZXR1cm4gYnVmW2ldXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBidWYucmVhZFVJbnQxNkJFKGkgKiBpbmRleFNpemUpXG4gICAgfVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKGRpcikge1xuICAgIHZhciBmb3VuZEluZGV4ID0gLTFcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpIDwgYXJyTGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChyZWFkKGFyciwgaSkgPT09IHJlYWQodmFsLCBmb3VuZEluZGV4ID09PSAtMSA/IDAgOiBpIC0gZm91bmRJbmRleCkpIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggPT09IC0xKSBmb3VuZEluZGV4ID0gaVxuICAgICAgICBpZiAoaSAtIGZvdW5kSW5kZXggKyAxID09PSB2YWxMZW5ndGgpIHJldHVybiBmb3VuZEluZGV4ICogaW5kZXhTaXplXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZm91bmRJbmRleCAhPT0gLTEpIGkgLT0gaSAtIGZvdW5kSW5kZXhcbiAgICAgICAgZm91bmRJbmRleCA9IC0xXG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChieXRlT2Zmc2V0ICsgdmFsTGVuZ3RoID4gYXJyTGVuZ3RoKSBieXRlT2Zmc2V0ID0gYXJyTGVuZ3RoIC0gdmFsTGVuZ3RoXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciBmb3VuZCA9IHRydWVcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdmFsTGVuZ3RoOyBqKyspIHtcbiAgICAgICAgaWYgKHJlYWQoYXJyLCBpICsgaikgIT09IHJlYWQodmFsLCBqKSkge1xuICAgICAgICAgIGZvdW5kID0gZmFsc2VcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZm91bmQpIHJldHVybiBpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5jbHVkZXMgPSBmdW5jdGlvbiBpbmNsdWRlcyAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gdGhpcy5pbmRleE9mKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpICE9PSAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiBpbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCB0cnVlKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmxhc3RJbmRleE9mID0gZnVuY3Rpb24gbGFzdEluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGZhbHNlKVxufVxuXG5mdW5jdGlvbiBoZXhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIG9mZnNldCA9IE51bWJlcihvZmZzZXQpIHx8IDBcbiAgdmFyIHJlbWFpbmluZyA9IGJ1Zi5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSBOdW1iZXIobGVuZ3RoKVxuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICAgIH1cbiAgfVxuXG4gIC8vIG11c3QgYmUgYW4gZXZlbiBudW1iZXIgb2YgZGlnaXRzXG4gIHZhciBzdHJMZW4gPSBzdHJpbmcubGVuZ3RoXG4gIGlmIChzdHJMZW4gJSAyICE9PSAwKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGhleCBzdHJpbmcnKVxuXG4gIGlmIChsZW5ndGggPiBzdHJMZW4gLyAyKSB7XG4gICAgbGVuZ3RoID0gc3RyTGVuIC8gMlxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgcGFyc2VkID0gcGFyc2VJbnQoc3RyaW5nLnN1YnN0cihpICogMiwgMiksIDE2KVxuICAgIGlmIChpc05hTihwYXJzZWQpKSByZXR1cm4gaVxuICAgIGJ1ZltvZmZzZXQgKyBpXSA9IHBhcnNlZFxuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIHV0ZjhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjhUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGFzY2lpV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihhc2NpaVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gbGF0aW4xV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYXNjaWlXcml0ZShidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGJhc2U2NFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYmFzZTY0VG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiB1Y3MyV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGYxNmxlVG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gd3JpdGUgKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKSB7XG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcpXG4gIGlmIChvZmZzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBvZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBvZmZzZXRcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgb2Zmc2V0WywgbGVuZ3RoXVssIGVuY29kaW5nXSlcbiAgfSBlbHNlIGlmIChpc0Zpbml0ZShvZmZzZXQpKSB7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICAgIGlmIChpc0Zpbml0ZShsZW5ndGgpKSB7XG4gICAgICBsZW5ndGggPSBsZW5ndGggfCAwXG4gICAgICBpZiAoZW5jb2RpbmcgPT09IHVuZGVmaW5lZCkgZW5jb2RpbmcgPSAndXRmOCdcbiAgICB9IGVsc2Uge1xuICAgICAgZW5jb2RpbmcgPSBsZW5ndGhcbiAgICAgIGxlbmd0aCA9IHVuZGVmaW5lZFxuICAgIH1cbiAgLy8gbGVnYWN5IHdyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldCwgbGVuZ3RoKSAtIHJlbW92ZSBpbiB2MC4xM1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdCdWZmZXIud3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0WywgbGVuZ3RoXSkgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZCdcbiAgICApXG4gIH1cblxuICB2YXIgcmVtYWluaW5nID0gdGhpcy5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkIHx8IGxlbmd0aCA+IHJlbWFpbmluZykgbGVuZ3RoID0gcmVtYWluaW5nXG5cbiAgaWYgKChzdHJpbmcubGVuZ3RoID4gMCAmJiAobGVuZ3RoIDwgMCB8fCBvZmZzZXQgPCAwKSkgfHwgb2Zmc2V0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byB3cml0ZSBvdXRzaWRlIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsYXRpbjFXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICAvLyBXYXJuaW5nOiBtYXhMZW5ndGggbm90IHRha2VuIGludG8gYWNjb3VudCBpbiBiYXNlNjRXcml0ZVxuICAgICAgICByZXR1cm4gYmFzZTY0V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHVjczJXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04gKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdCdWZmZXInLFxuICAgIGRhdGE6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2FyciB8fCB0aGlzLCAwKVxuICB9XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKHN0YXJ0ID09PSAwICYmIGVuZCA9PT0gYnVmLmxlbmd0aCkge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1Zi5zbGljZShzdGFydCwgZW5kKSlcbiAgfVxufVxuXG5mdW5jdGlvbiB1dGY4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG4gIHZhciByZXMgPSBbXVxuXG4gIHZhciBpID0gc3RhcnRcbiAgd2hpbGUgKGkgPCBlbmQpIHtcbiAgICB2YXIgZmlyc3RCeXRlID0gYnVmW2ldXG4gICAgdmFyIGNvZGVQb2ludCA9IG51bGxcbiAgICB2YXIgYnl0ZXNQZXJTZXF1ZW5jZSA9IChmaXJzdEJ5dGUgPiAweEVGKSA/IDRcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4REYpID8gM1xuICAgICAgOiAoZmlyc3RCeXRlID4gMHhCRikgPyAyXG4gICAgICA6IDFcblxuICAgIGlmIChpICsgYnl0ZXNQZXJTZXF1ZW5jZSA8PSBlbmQpIHtcbiAgICAgIHZhciBzZWNvbmRCeXRlLCB0aGlyZEJ5dGUsIGZvdXJ0aEJ5dGUsIHRlbXBDb2RlUG9pbnRcblxuICAgICAgc3dpdGNoIChieXRlc1BlclNlcXVlbmNlKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBpZiAoZmlyc3RCeXRlIDwgMHg4MCkge1xuICAgICAgICAgICAgY29kZVBvaW50ID0gZmlyc3RCeXRlXG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4MUYpIDw8IDB4NiB8IChzZWNvbmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3Rikge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweEMgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4NiB8ICh0aGlyZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGRiAmJiAodGVtcENvZGVQb2ludCA8IDB4RDgwMCB8fCB0ZW1wQ29kZVBvaW50ID4gMHhERkZGKSkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBmb3VydGhCeXRlID0gYnVmW2kgKyAzXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAoZm91cnRoQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHgxMiB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHhDIHwgKHRoaXJkQnl0ZSAmIDB4M0YpIDw8IDB4NiB8IChmb3VydGhCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHhGRkZGICYmIHRlbXBDb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjb2RlUG9pbnQgPT09IG51bGwpIHtcbiAgICAgIC8vIHdlIGRpZCBub3QgZ2VuZXJhdGUgYSB2YWxpZCBjb2RlUG9pbnQgc28gaW5zZXJ0IGFcbiAgICAgIC8vIHJlcGxhY2VtZW50IGNoYXIgKFUrRkZGRCkgYW5kIGFkdmFuY2Ugb25seSAxIGJ5dGVcbiAgICAgIGNvZGVQb2ludCA9IDB4RkZGRFxuICAgICAgYnl0ZXNQZXJTZXF1ZW5jZSA9IDFcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA+IDB4RkZGRikge1xuICAgICAgLy8gZW5jb2RlIHRvIHV0ZjE2IChzdXJyb2dhdGUgcGFpciBkYW5jZSlcbiAgICAgIGNvZGVQb2ludCAtPSAweDEwMDAwXG4gICAgICByZXMucHVzaChjb2RlUG9pbnQgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApXG4gICAgICBjb2RlUG9pbnQgPSAweERDMDAgfCBjb2RlUG9pbnQgJiAweDNGRlxuICAgIH1cblxuICAgIHJlcy5wdXNoKGNvZGVQb2ludClcbiAgICBpICs9IGJ5dGVzUGVyU2VxdWVuY2VcbiAgfVxuXG4gIHJldHVybiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkocmVzKVxufVxuXG4vLyBCYXNlZCBvbiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yMjc0NzI3Mi82ODA3NDIsIHRoZSBicm93c2VyIHdpdGhcbi8vIHRoZSBsb3dlc3QgbGltaXQgaXMgQ2hyb21lLCB3aXRoIDB4MTAwMDAgYXJncy5cbi8vIFdlIGdvIDEgbWFnbml0dWRlIGxlc3MsIGZvciBzYWZldHlcbnZhciBNQVhfQVJHVU1FTlRTX0xFTkdUSCA9IDB4MTAwMFxuXG5mdW5jdGlvbiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkgKGNvZGVQb2ludHMpIHtcbiAgdmFyIGxlbiA9IGNvZGVQb2ludHMubGVuZ3RoXG4gIGlmIChsZW4gPD0gTUFYX0FSR1VNRU5UU19MRU5HVEgpIHtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNvZGVQb2ludHMpIC8vIGF2b2lkIGV4dHJhIHNsaWNlKClcbiAgfVxuXG4gIC8vIERlY29kZSBpbiBjaHVua3MgdG8gYXZvaWQgXCJjYWxsIHN0YWNrIHNpemUgZXhjZWVkZWRcIi5cbiAgdmFyIHJlcyA9ICcnXG4gIHZhciBpID0gMFxuICB3aGlsZSAoaSA8IGxlbikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFxuICAgICAgU3RyaW5nLFxuICAgICAgY29kZVBvaW50cy5zbGljZShpLCBpICs9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKVxuICAgIClcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldICYgMHg3RilcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGxhdGluMVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGhleFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcblxuICBpZiAoIXN0YXJ0IHx8IHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIGlmICghZW5kIHx8IGVuZCA8IDAgfHwgZW5kID4gbGVuKSBlbmQgPSBsZW5cblxuICB2YXIgb3V0ID0gJydcbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICBvdXQgKz0gdG9IZXgoYnVmW2ldKVxuICB9XG4gIHJldHVybiBvdXRcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGJ5dGVzID0gYnVmLnNsaWNlKHN0YXJ0LCBlbmQpXG4gIHZhciByZXMgPSAnJ1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0gKyBieXRlc1tpICsgMV0gKiAyNTYpXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gc2xpY2UgKHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIHN0YXJ0ID0gfn5zdGFydFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IH5+ZW5kXG5cbiAgaWYgKHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ICs9IGxlblxuICAgIGlmIChzdGFydCA8IDApIHN0YXJ0ID0gMFxuICB9IGVsc2UgaWYgKHN0YXJ0ID4gbGVuKSB7XG4gICAgc3RhcnQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCAwKSB7XG4gICAgZW5kICs9IGxlblxuICAgIGlmIChlbmQgPCAwKSBlbmQgPSAwXG4gIH0gZWxzZSBpZiAoZW5kID4gbGVuKSB7XG4gICAgZW5kID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgdmFyIG5ld0J1ZlxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICBuZXdCdWYgPSB0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpXG4gICAgbmV3QnVmLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgfSBlbHNlIHtcbiAgICB2YXIgc2xpY2VMZW4gPSBlbmQgLSBzdGFydFxuICAgIG5ld0J1ZiA9IG5ldyBCdWZmZXIoc2xpY2VMZW4sIHVuZGVmaW5lZClcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNsaWNlTGVuOyArK2kpIHtcbiAgICAgIG5ld0J1ZltpXSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXdCdWZcbn1cblxuLypcbiAqIE5lZWQgdG8gbWFrZSBzdXJlIHRoYXQgYnVmZmVyIGlzbid0IHRyeWluZyB0byB3cml0ZSBvdXQgb2YgYm91bmRzLlxuICovXG5mdW5jdGlvbiBjaGVja09mZnNldCAob2Zmc2V0LCBleHQsIGxlbmd0aCkge1xuICBpZiAoKG9mZnNldCAlIDEpICE9PSAwIHx8IG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdvZmZzZXQgaXMgbm90IHVpbnQnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gbGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVHJ5aW5nIHRvIGFjY2VzcyBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRMRSA9IGZ1bmN0aW9uIHJlYWRVSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRCRSA9IGZ1bmN0aW9uIHJlYWRVSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG4gIH1cblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdXG4gIHZhciBtdWwgPSAxXG4gIHdoaWxlIChieXRlTGVuZ3RoID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDggPSBmdW5jdGlvbiByZWFkVUludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkUgPSBmdW5jdGlvbiByZWFkVUludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgOCkgfCB0aGlzW29mZnNldCArIDFdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkxFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICgodGhpc1tvZmZzZXRdKSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikpICtcbiAgICAgICh0aGlzW29mZnNldCArIDNdICogMHgxMDAwMDAwKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdICogMHgxMDAwMDAwKSArXG4gICAgKCh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgIHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludExFID0gZnVuY3Rpb24gcmVhZEludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludEJFID0gZnVuY3Rpb24gcmVhZEludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoXG4gIHZhciBtdWwgPSAxXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0taV1cbiAgd2hpbGUgKGkgPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1pXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDggPSBmdW5jdGlvbiByZWFkSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICBpZiAoISh0aGlzW29mZnNldF0gJiAweDgwKSkgcmV0dXJuICh0aGlzW29mZnNldF0pXG4gIHJldHVybiAoKDB4ZmYgLSB0aGlzW29mZnNldF0gKyAxKSAqIC0xKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFID0gZnVuY3Rpb24gcmVhZEludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIDFdIHwgKHRoaXNbb2Zmc2V0XSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyTEUgPSBmdW5jdGlvbiByZWFkSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdKSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10gPDwgMjQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyQkUgPSBmdW5jdGlvbiByZWFkSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDI0KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0TEUgPSBmdW5jdGlvbiByZWFkRmxvYXRMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0QkUgPSBmdW5jdGlvbiByZWFkRmxvYXRCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVMRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgNTIsIDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUJFID0gZnVuY3Rpb24gcmVhZERvdWJsZUJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgNTIsIDgpXG59XG5cbmZ1bmN0aW9uIGNoZWNrSW50IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJidWZmZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyIGluc3RhbmNlJylcbiAgaWYgKHZhbHVlID4gbWF4IHx8IHZhbHVlIDwgbWluKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IGlzIG91dCBvZiBib3VuZHMnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50OCA9IGZ1bmN0aW9uIHdyaXRlVUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHhmZiwgMClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5mdW5jdGlvbiBvYmplY3RXcml0ZVVJbnQxNiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmYgKyB2YWx1ZSArIDFcbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihidWYubGVuZ3RoIC0gb2Zmc2V0LCAyKTsgaSA8IGo7ICsraSkge1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9ICh2YWx1ZSAmICgweGZmIDw8ICg4ICogKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkpKSkgPj4+XG4gICAgICAobGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpKSAqIDhcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5mdW5jdGlvbiBvYmplY3RXcml0ZVVJbnQzMiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4oYnVmLmxlbmd0aCAtIG9mZnNldCwgNCk7IGkgPCBqOyArK2kpIHtcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSAodmFsdWUgPj4+IChsaXR0bGVFbmRpYW4gPyBpIDogMyAtIGkpICogOCkgJiAweGZmXG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50TEUgPSBmdW5jdGlvbiB3cml0ZUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gMFxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgLSAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50QkUgPSBmdW5jdGlvbiB3cml0ZUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IDBcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgKyAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uIHdyaXRlSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweDdmLCAtMHg4MClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmYgKyB2YWx1ZSArIDFcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuZnVuY3Rpb24gY2hlY2tJRUVFNzU0IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxuICBpZiAob2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRmxvYXQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgNCwgMy40MDI4MjM0NjYzODUyODg2ZSszOCwgLTMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgMjMsIDQpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gZnVuY3Rpb24gd3JpdGVGbG9hdExFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gd3JpdGVEb3VibGUgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgOCwgMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgsIC0xLjc5NzY5MzEzNDg2MjMxNTdFKzMwOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCA1MiwgOClcbiAgcmV0dXJuIG9mZnNldCArIDhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG4vLyBjb3B5KHRhcmdldEJ1ZmZlciwgdGFyZ2V0U3RhcnQ9MCwgc291cmNlU3RhcnQ9MCwgc291cmNlRW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5ICh0YXJnZXQsIHRhcmdldFN0YXJ0LCBzdGFydCwgZW5kKSB7XG4gIGlmICghc3RhcnQpIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCAmJiBlbmQgIT09IDApIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXRTdGFydCA+PSB0YXJnZXQubGVuZ3RoKSB0YXJnZXRTdGFydCA9IHRhcmdldC5sZW5ndGhcbiAgaWYgKCF0YXJnZXRTdGFydCkgdGFyZ2V0U3RhcnQgPSAwXG4gIGlmIChlbmQgPiAwICYmIGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIC8vIENvcHkgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuIDBcbiAgaWYgKHRhcmdldC5sZW5ndGggPT09IDAgfHwgdGhpcy5sZW5ndGggPT09IDApIHJldHVybiAwXG5cbiAgLy8gRmF0YWwgZXJyb3IgY29uZGl0aW9uc1xuICBpZiAodGFyZ2V0U3RhcnQgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3RhcmdldFN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICB9XG4gIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgaWYgKGVuZCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VFbmQgb3V0IG9mIGJvdW5kcycpXG5cbiAgLy8gQXJlIHdlIG9vYj9cbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0IDwgZW5kIC0gc3RhcnQpIHtcbiAgICBlbmQgPSB0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgKyBzdGFydFxuICB9XG5cbiAgdmFyIGxlbiA9IGVuZCAtIHN0YXJ0XG4gIHZhciBpXG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCAmJiBzdGFydCA8IHRhcmdldFN0YXJ0ICYmIHRhcmdldFN0YXJ0IDwgZW5kKSB7XG4gICAgLy8gZGVzY2VuZGluZyBjb3B5IGZyb20gZW5kXG4gICAgZm9yIChpID0gbGVuIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9IGVsc2UgaWYgKGxlbiA8IDEwMDAgfHwgIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gYXNjZW5kaW5nIGNvcHkgZnJvbSBzdGFydFxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRTdGFydF0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgVWludDhBcnJheS5wcm90b3R5cGUuc2V0LmNhbGwoXG4gICAgICB0YXJnZXQsXG4gICAgICB0aGlzLnN1YmFycmF5KHN0YXJ0LCBzdGFydCArIGxlbiksXG4gICAgICB0YXJnZXRTdGFydFxuICAgIClcbiAgfVxuXG4gIHJldHVybiBsZW5cbn1cblxuLy8gVXNhZ2U6XG4vLyAgICBidWZmZXIuZmlsbChudW1iZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKGJ1ZmZlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoc3RyaW5nWywgb2Zmc2V0WywgZW5kXV1bLCBlbmNvZGluZ10pXG5CdWZmZXIucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiBmaWxsICh2YWwsIHN0YXJ0LCBlbmQsIGVuY29kaW5nKSB7XG4gIC8vIEhhbmRsZSBzdHJpbmcgY2FzZXM6XG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIGlmICh0eXBlb2Ygc3RhcnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IHN0YXJ0XG4gICAgICBzdGFydCA9IDBcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZW5kID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBlbmRcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfVxuICAgIGlmICh2YWwubGVuZ3RoID09PSAxKSB7XG4gICAgICB2YXIgY29kZSA9IHZhbC5jaGFyQ29kZUF0KDApXG4gICAgICBpZiAoY29kZSA8IDI1Nikge1xuICAgICAgICB2YWwgPSBjb2RlXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2VuY29kaW5nIG11c3QgYmUgYSBzdHJpbmcnKVxuICAgIH1cbiAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJyAmJiAhQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMjU1XG4gIH1cblxuICAvLyBJbnZhbGlkIHJhbmdlcyBhcmUgbm90IHNldCB0byBhIGRlZmF1bHQsIHNvIGNhbiByYW5nZSBjaGVjayBlYXJseS5cbiAgaWYgKHN0YXJ0IDwgMCB8fCB0aGlzLmxlbmd0aCA8IHN0YXJ0IHx8IHRoaXMubGVuZ3RoIDwgZW5kKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ091dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHN0YXJ0ID0gc3RhcnQgPj4+IDBcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyB0aGlzLmxlbmd0aCA6IGVuZCA+Pj4gMFxuXG4gIGlmICghdmFsKSB2YWwgPSAwXG5cbiAgdmFyIGlcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgICAgdGhpc1tpXSA9IHZhbFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgYnl0ZXMgPSBCdWZmZXIuaXNCdWZmZXIodmFsKVxuICAgICAgPyB2YWxcbiAgICAgIDogdXRmOFRvQnl0ZXMobmV3IEJ1ZmZlcih2YWwsIGVuY29kaW5nKS50b1N0cmluZygpKVxuICAgIHZhciBsZW4gPSBieXRlcy5sZW5ndGhcbiAgICBmb3IgKGkgPSAwOyBpIDwgZW5kIC0gc3RhcnQ7ICsraSkge1xuICAgICAgdGhpc1tpICsgc3RhcnRdID0gYnl0ZXNbaSAlIGxlbl1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpc1xufVxuXG4vLyBIRUxQRVIgRlVOQ1RJT05TXG4vLyA9PT09PT09PT09PT09PT09XG5cbnZhciBJTlZBTElEX0JBU0U2NF9SRSA9IC9bXitcXC8wLTlBLVphLXotX10vZ1xuXG5mdW5jdGlvbiBiYXNlNjRjbGVhbiAoc3RyKSB7XG4gIC8vIE5vZGUgc3RyaXBzIG91dCBpbnZhbGlkIGNoYXJhY3RlcnMgbGlrZSBcXG4gYW5kIFxcdCBmcm9tIHRoZSBzdHJpbmcsIGJhc2U2NC1qcyBkb2VzIG5vdFxuICBzdHIgPSBzdHJpbmd0cmltKHN0cikucmVwbGFjZShJTlZBTElEX0JBU0U2NF9SRSwgJycpXG4gIC8vIE5vZGUgY29udmVydHMgc3RyaW5ncyB3aXRoIGxlbmd0aCA8IDIgdG8gJydcbiAgaWYgKHN0ci5sZW5ndGggPCAyKSByZXR1cm4gJydcbiAgLy8gTm9kZSBhbGxvd3MgZm9yIG5vbi1wYWRkZWQgYmFzZTY0IHN0cmluZ3MgKG1pc3NpbmcgdHJhaWxpbmcgPT09KSwgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHdoaWxlIChzdHIubGVuZ3RoICUgNCAhPT0gMCkge1xuICAgIHN0ciA9IHN0ciArICc9J1xuICB9XG4gIHJldHVybiBzdHJcbn1cblxuZnVuY3Rpb24gc3RyaW5ndHJpbSAoc3RyKSB7XG4gIGlmIChzdHIudHJpbSkgcmV0dXJuIHN0ci50cmltKClcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJylcbn1cblxuZnVuY3Rpb24gdG9IZXggKG4pIHtcbiAgaWYgKG4gPCAxNikgcmV0dXJuICcwJyArIG4udG9TdHJpbmcoMTYpXG4gIHJldHVybiBuLnRvU3RyaW5nKDE2KVxufVxuXG5mdW5jdGlvbiB1dGY4VG9CeXRlcyAoc3RyaW5nLCB1bml0cykge1xuICB1bml0cyA9IHVuaXRzIHx8IEluZmluaXR5XG4gIHZhciBjb2RlUG9pbnRcbiAgdmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGhcbiAgdmFyIGxlYWRTdXJyb2dhdGUgPSBudWxsXG4gIHZhciBieXRlcyA9IFtdXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGNvZGVQb2ludCA9IHN0cmluZy5jaGFyQ29kZUF0KGkpXG5cbiAgICAvLyBpcyBzdXJyb2dhdGUgY29tcG9uZW50XG4gICAgaWYgKGNvZGVQb2ludCA+IDB4RDdGRiAmJiBjb2RlUG9pbnQgPCAweEUwMDApIHtcbiAgICAgIC8vIGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoIWxlYWRTdXJyb2dhdGUpIHtcbiAgICAgICAgLy8gbm8gbGVhZCB5ZXRcbiAgICAgICAgaWYgKGNvZGVQb2ludCA+IDB4REJGRikge1xuICAgICAgICAgIC8vIHVuZXhwZWN0ZWQgdHJhaWxcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9IGVsc2UgaWYgKGkgKyAxID09PSBsZW5ndGgpIHtcbiAgICAgICAgICAvLyB1bnBhaXJlZCBsZWFkXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHZhbGlkIGxlYWRcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIDIgbGVhZHMgaW4gYSByb3dcbiAgICAgIGlmIChjb2RlUG9pbnQgPCAweERDMDApIHtcbiAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gdmFsaWQgc3Vycm9nYXRlIHBhaXJcbiAgICAgIGNvZGVQb2ludCA9IChsZWFkU3Vycm9nYXRlIC0gMHhEODAwIDw8IDEwIHwgY29kZVBvaW50IC0gMHhEQzAwKSArIDB4MTAwMDBcbiAgICB9IGVsc2UgaWYgKGxlYWRTdXJyb2dhdGUpIHtcbiAgICAgIC8vIHZhbGlkIGJtcCBjaGFyLCBidXQgbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgIH1cblxuICAgIGxlYWRTdXJyb2dhdGUgPSBudWxsXG5cbiAgICAvLyBlbmNvZGUgdXRmOFxuICAgIGlmIChjb2RlUG9pbnQgPCAweDgwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDEpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goY29kZVBvaW50KVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHg4MDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiB8IDB4QzAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDMpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgfCAweEUwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSA0KSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHgxMiB8IDB4RjAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29kZSBwb2ludCcpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpVG9CeXRlcyAoc3RyKSB7XG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIC8vIE5vZGUncyBjb2RlIHNlZW1zIHRvIGJlIGRvaW5nIHRoaXMgYW5kIG5vdCAmIDB4N0YuLlxuICAgIGJ5dGVBcnJheS5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpICYgMHhGRilcbiAgfVxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVUb0J5dGVzIChzdHIsIHVuaXRzKSB7XG4gIHZhciBjLCBoaSwgbG9cbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG5cbiAgICBjID0gc3RyLmNoYXJDb2RlQXQoaSlcbiAgICBoaSA9IGMgPj4gOFxuICAgIGxvID0gYyAlIDI1NlxuICAgIGJ5dGVBcnJheS5wdXNoKGxvKVxuICAgIGJ5dGVBcnJheS5wdXNoKGhpKVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiBiYXNlNjRUb0J5dGVzIChzdHIpIHtcbiAgcmV0dXJuIGJhc2U2NC50b0J5dGVBcnJheShiYXNlNjRjbGVhbihzdHIpKVxufVxuXG5mdW5jdGlvbiBibGl0QnVmZmVyIChzcmMsIGRzdCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGlmICgoaSArIG9mZnNldCA+PSBkc3QubGVuZ3RoKSB8fCAoaSA+PSBzcmMubGVuZ3RoKSkgYnJlYWtcbiAgICBkc3RbaSArIG9mZnNldF0gPSBzcmNbaV1cbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiBpc25hbiAodmFsKSB7XG4gIHJldHVybiB2YWwgIT09IHZhbCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNlbGYtY29tcGFyZVxufVxuIiwidmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG5cbm1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoYXJyKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKGFycikgPT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIFZBUklBQkxFUyAvL1xuXG52YXIgRkxPQVQzMl9WSUVXID0gbmV3IEZsb2F0MzJBcnJheSggMSApO1xudmFyIFVJTlQzMl9WSUVXID0gbmV3IFVpbnQzMkFycmF5KCBGTE9BVDMyX1ZJRVcuYnVmZmVyICk7XG5cbi8vIDEgMTExMTExMTEgMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAgPT4gNDI4NjU3ODY4OCA9PiAweGZmODAwMDAwIChzZWUgSUVFRSA3NTQtMjAwOClcbnZhciBOSU5GID0gMHhmZjgwMDAwMDtcblxuLy8gU2V0IHRoZSBBcnJheUJ1ZmZlciBiaXQgc2VxdWVuY2U6XG5VSU5UMzJfVklFV1sgMCBdID0gTklORjtcblxuXG4vLyBFWFBPUlRTIC8vXG5cbm1vZHVsZS5leHBvcnRzID0gRkxPQVQzMl9WSUVXWyAwIF07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIFZBUklBQkxFUyAvL1xuXG52YXIgRkxPQVQzMl9WSUVXID0gbmV3IEZsb2F0MzJBcnJheSggMSApO1xudmFyIFVJTlQzMl9WSUVXID0gbmV3IFVpbnQzMkFycmF5KCBGTE9BVDMyX1ZJRVcuYnVmZmVyICk7XG5cbi8vIDAgMTExMTExMTEgMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAgPT4gMjEzOTA5NTA0MCA9PiAweDdmODAwMDAwIChzZWUgSUVFRSA3NTQtMjAwOClcbnZhciBQSU5GID0gMHg3ZjgwMDAwMDtcblxuLy8gU2V0IHRoZSBBcnJheUJ1ZmZlciBiaXQgc2VxdWVuY2U6XG5VSU5UMzJfVklFV1sgMCBdID0gUElORjtcblxuXG4vLyBFWFBPUlRTIC8vXG5cbm1vZHVsZS5leHBvcnRzID0gRkxPQVQzMl9WSUVXWyAwIF07XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gTk9URTogVGhlc2UgdHlwZSBjaGVja2luZyBmdW5jdGlvbnMgaW50ZW50aW9uYWxseSBkb24ndCB1c2UgYGluc3RhbmNlb2ZgXG4vLyBiZWNhdXNlIGl0IGlzIGZyYWdpbGUgYW5kIGNhbiBiZSBlYXNpbHkgZmFrZWQgd2l0aCBgT2JqZWN0LmNyZWF0ZSgpYC5cblxuZnVuY3Rpb24gaXNBcnJheShhcmcpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheShhcmcpO1xuICB9XG4gIHJldHVybiBvYmplY3RUb1N0cmluZyhhcmcpID09PSAnW29iamVjdCBBcnJheV0nO1xufVxuZXhwb3J0cy5pc0FycmF5ID0gaXNBcnJheTtcblxuZnVuY3Rpb24gaXNCb29sZWFuKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nO1xufVxuZXhwb3J0cy5pc0Jvb2xlYW4gPSBpc0Jvb2xlYW47XG5cbmZ1bmN0aW9uIGlzTnVsbChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsID0gaXNOdWxsO1xuXG5mdW5jdGlvbiBpc051bGxPclVuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGxPclVuZGVmaW5lZCA9IGlzTnVsbE9yVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xufVxuZXhwb3J0cy5pc051bWJlciA9IGlzTnVtYmVyO1xuXG5mdW5jdGlvbiBpc1N0cmluZyhhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnO1xufVxuZXhwb3J0cy5pc1N0cmluZyA9IGlzU3RyaW5nO1xuXG5mdW5jdGlvbiBpc1N5bWJvbChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnO1xufVxuZXhwb3J0cy5pc1N5bWJvbCA9IGlzU3ltYm9sO1xuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwO1xufVxuZXhwb3J0cy5pc1VuZGVmaW5lZCA9IGlzVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc1JlZ0V4cChyZSkge1xuICByZXR1cm4gb2JqZWN0VG9TdHJpbmcocmUpID09PSAnW29iamVjdCBSZWdFeHBdJztcbn1cbmV4cG9ydHMuaXNSZWdFeHAgPSBpc1JlZ0V4cDtcblxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG59XG5leHBvcnRzLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG5cbmZ1bmN0aW9uIGlzRGF0ZShkKSB7XG4gIHJldHVybiBvYmplY3RUb1N0cmluZyhkKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xufVxuZXhwb3J0cy5pc0RhdGUgPSBpc0RhdGU7XG5cbmZ1bmN0aW9uIGlzRXJyb3IoZSkge1xuICByZXR1cm4gKG9iamVjdFRvU3RyaW5nKGUpID09PSAnW29iamVjdCBFcnJvcl0nIHx8IGUgaW5zdGFuY2VvZiBFcnJvcik7XG59XG5leHBvcnRzLmlzRXJyb3IgPSBpc0Vycm9yO1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcbn1cbmV4cG9ydHMuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG5cbmZ1bmN0aW9uIGlzUHJpbWl0aXZlKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnYm9vbGVhbicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdudW1iZXInIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3RyaW5nJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCcgfHwgIC8vIEVTNiBzeW1ib2xcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICd1bmRlZmluZWQnO1xufVxuZXhwb3J0cy5pc1ByaW1pdGl2ZSA9IGlzUHJpbWl0aXZlO1xuXG5leHBvcnRzLmlzQnVmZmVyID0gQnVmZmVyLmlzQnVmZmVyO1xuXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyhvKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobyk7XG59XG4iLCIvKiEgZGljb20tcGFyc2VyIC0gdjEuNy4zIC0gMjAxNi0wOC0xOCB8IChjKSAyMDE0IENocmlzIEhhZmV5IHwgaHR0cHM6Ly9naXRodWIuY29tL2NoYWZleS9kaWNvbVBhcnNlciAqL1xuKGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XG5cbiAgICAvLyBub2RlLmpzXG4gICAgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgLy8gQU1ELiBSZWdpc3RlciBhcyBhbiBhbm9ueW1vdXMgbW9kdWxlLlxuICAgICAgICBkZWZpbmUoW10sIGZhY3RvcnkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEJyb3dzZXIgZ2xvYmFsc1xuICAgICAgICBpZih0eXBlb2YgY29ybmVyc3RvbmUgPT09ICd1bmRlZmluZWQnKXtcbiAgICAgICAgICAgIGRpY29tUGFyc2VyID0ge307XG5cbiAgICAgICAgICAgIC8vIG1ldGVvclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBQYWNrYWdlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHJvb3QuZGljb21QYXJzZXIgPSBkaWNvbVBhcnNlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBkaWNvbVBhcnNlciA9IGZhY3RvcnkoKTtcbiAgICB9XG59KHRoaXMsIGZ1bmN0aW9uICgpIHtcblxuLyoqXG4gKiBQYXJzZXMgYSBESUNPTSBQMTAgYnl0ZSBhcnJheSBhbmQgcmV0dXJucyBhIERhdGFTZXQgb2JqZWN0IHdpdGggdGhlIHBhcnNlZCBlbGVtZW50cy4gIElmIHRoZSBvcHRpb25zXG4gKiBhcmd1bWVudCBpcyBzdXBwbGllZCBhbmQgaXQgY29udGFpbnMgdGhlIHVudGlsVGFnIHByb3BlcnR5LCBwYXJzaW5nIHdpbGwgc3RvcCBvbmNlIHRoYXRcbiAqIHRhZyBpcyBlbmNvdXRlcmVkLiAgVGhpcyBjYW4gYmUgdXNlZCB0byBwYXJzZSBwYXJ0aWFsIGJ5dGUgc3RyZWFtcy5cbiAqXG4gKiBAcGFyYW0gYnl0ZUFycmF5IHRoZSBieXRlIGFycmF5XG4gKiBAcGFyYW0gb3B0aW9ucyBvYmplY3QgdG8gY29udHJvbCBwYXJzaW5nIGJlaGF2aW9yIChvcHRpb25hbClcbiAqIEByZXR1cm5zIHtEYXRhU2V0fVxuICogQHRocm93cyBlcnJvciBpZiBhbiBlcnJvciBvY2N1cnMgd2hpbGUgcGFyc2luZy4gIFRoZSBleGNlcHRpb24gb2JqZWN0IHdpbGwgY29udGFpbiBhIHByb3BlcnR5IGRhdGFTZXQgd2l0aCB0aGVcbiAqICAgICAgICAgZWxlbWVudHMgc3VjY2Vzc2Z1bGx5IHBhcnNlZCBiZWZvcmUgdGhlIGVycm9yLlxuICovXG52YXIgZGljb21QYXJzZXIgPSAoZnVuY3Rpb24oZGljb21QYXJzZXIpIHtcbiAgICBpZihkaWNvbVBhcnNlciA9PT0gdW5kZWZpbmVkKVxuICAgIHtcbiAgICAgICAgZGljb21QYXJzZXIgPSB7fTtcbiAgICB9XG5cbiAgICBkaWNvbVBhcnNlci5wYXJzZURpY29tID0gZnVuY3Rpb24oYnl0ZUFycmF5LCBvcHRpb25zKSB7XG5cbiAgICAgICAgaWYoYnl0ZUFycmF5ID09PSB1bmRlZmluZWQpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRocm93IFwiZGljb21QYXJzZXIucGFyc2VEaWNvbTogbWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXIgJ2J5dGVBcnJheSdcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHJlYWRUcmFuc2ZlclN5bnRheChtZXRhSGVhZGVyRGF0YVNldCkge1xuICAgICAgICAgICAgaWYobWV0YUhlYWRlckRhdGFTZXQuZWxlbWVudHMueDAwMDIwMDEwID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyAnZGljb21QYXJzZXIucGFyc2VEaWNvbTogbWlzc2luZyByZXF1aXJlZCBtZXRhIGhlYWRlciBhdHRyaWJ1dGUgMDAwMiwwMDEwJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB0cmFuc2ZlclN5bnRheEVsZW1lbnQgPSBtZXRhSGVhZGVyRGF0YVNldC5lbGVtZW50cy54MDAwMjAwMTA7XG4gICAgICAgICAgICByZXR1cm4gZGljb21QYXJzZXIucmVhZEZpeGVkU3RyaW5nKGJ5dGVBcnJheSwgdHJhbnNmZXJTeW50YXhFbGVtZW50LmRhdGFPZmZzZXQsIHRyYW5zZmVyU3ludGF4RWxlbWVudC5sZW5ndGgpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gaXNFeHBsaWNpdCh0cmFuc2ZlclN5bnRheCkge1xuICAgICAgICAgICAgaWYodHJhbnNmZXJTeW50YXggPT09ICcxLjIuODQwLjEwMDA4LjEuMicpIC8vIGltcGxpY2l0IGxpdHRsZSBlbmRpYW5cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBhbGwgb3RoZXIgdHJhbnNmZXIgc3ludGF4ZXMgc2hvdWxkIGJlIGV4cGxpY2l0XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGdldERhdGFTZXRCeXRlU3RyZWFtKHRyYW5zZmVyU3ludGF4LCBwb3NpdGlvbikge1xuICAgICAgICAgICAgaWYodHJhbnNmZXJTeW50YXggPT09ICcxLjIuODQwLjEwMDA4LjEuMi4xLjk5JylcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAvLyBpZiBhbiBpbmZhbHRlciBjYWxsYmFjayBpcyByZWdpc3RlcmVkLCB1c2UgaXRcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmluZmxhdGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmdWxsQnl0ZUFycmF5Q2FsbGJhY2sgPSBvcHRpb25zLmluZmxhdGVyKGJ5dGVBcnJheSwgcG9zaXRpb24pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IGRpY29tUGFyc2VyLkJ5dGVTdHJlYW0oZGljb21QYXJzZXIubGl0dGxlRW5kaWFuQnl0ZUFycmF5UGFyc2VyLCBmdWxsQnl0ZUFycmF5Q2FsbGJhY2ssIDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBpZiBydW5uaW5nIG9uIG5vZGUsIHVzZSB0aGUgemxpYiBsaWJyYXJ5IHRvIGluZmxhdGVcbiAgICAgICAgICAgICAgICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzQyMjQ2MDYvaG93LXRvLWNoZWNrLXdoZXRoZXItYS1zY3JpcHQtaXMtcnVubmluZy11bmRlci1ub2RlLWpzXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdGhpcy5tb2R1bGUgIT09IG1vZHVsZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBpbmZsYXRlIGl0XG4gICAgICAgICAgICAgICAgICAgIHZhciB6bGliID0gcmVxdWlyZSgnemxpYicpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGVmbGF0ZWRCdWZmZXIgPSBkaWNvbVBhcnNlci5zaGFyZWRDb3B5KGJ5dGVBcnJheSwgcG9zaXRpb24sIGJ5dGVBcnJheS5sZW5ndGggLSBwb3NpdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmZsYXRlZEJ1ZmZlciA9IHpsaWIuaW5mbGF0ZVJhd1N5bmMoZGVmbGF0ZWRCdWZmZXIpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGNyZWF0ZSBhIHNpbmdsZSBieXRlIGFycmF5IHdpdGggdGhlIGZ1bGwgaGVhZGVyIGJ5dGVzIGFuZCB0aGUgaW5mbGF0ZWQgYnl0ZXNcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZ1bGxCeXRlQXJyYXlCdWZmZXIgPSBkaWNvbVBhcnNlci5hbGxvYyhieXRlQXJyYXksIGluZmxhdGVkQnVmZmVyLmxlbmd0aCArIHBvc2l0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgYnl0ZUFycmF5LmNvcHkoZnVsbEJ5dGVBcnJheUJ1ZmZlciwgMCwgMCwgcG9zaXRpb24pO1xuICAgICAgICAgICAgICAgICAgICBpbmZsYXRlZEJ1ZmZlci5jb3B5KGZ1bGxCeXRlQXJyYXlCdWZmZXIsIHBvc2l0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBkaWNvbVBhcnNlci5CeXRlU3RyZWFtKGRpY29tUGFyc2VyLmxpdHRsZUVuZGlhbkJ5dGVBcnJheVBhcnNlciwgZnVsbEJ5dGVBcnJheUJ1ZmZlciwgMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGlmIHBha28gaXMgZGVmaW5lZCAtIHVzZSBpdC4gIFRoaXMgaXMgdGhlIHdlYiBicm93c2VyIHBhdGhcbiAgICAgICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWNhL3Bha29cbiAgICAgICAgICAgICAgICBlbHNlIGlmKHR5cGVvZiBwYWtvICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGluZmxhdGUgaXRcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRlZmxhdGVkID0gYnl0ZUFycmF5LnNsaWNlKHBvc2l0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluZmxhdGVkID0gcGFrby5pbmZsYXRlUmF3KGRlZmxhdGVkKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBjcmVhdGUgYSBzaW5nbGUgYnl0ZSBhcnJheSB3aXRoIHRoZSBmdWxsIGhlYWRlciBieXRlcyBhbmQgdGhlIGluZmxhdGVkIGJ5dGVzXG4gICAgICAgICAgICAgICAgICAgIHZhciBmdWxsQnl0ZUFycmF5ID0gZGljb21QYXJzZXIuYWxsb2MoYnl0ZUFycmF5LCBpbmZsYXRlZC5sZW5ndGggKyBwb3NpdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIGZ1bGxCeXRlQXJyYXkuc2V0KGJ5dGVBcnJheS5zbGljZSgwLCBwb3NpdGlvbiksIDApO1xuICAgICAgICAgICAgICAgICAgICBmdWxsQnl0ZUFycmF5LnNldChpbmZsYXRlZCwgcG9zaXRpb24pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IGRpY29tUGFyc2VyLkJ5dGVTdHJlYW0oZGljb21QYXJzZXIubGl0dGxlRW5kaWFuQnl0ZUFycmF5UGFyc2VyLCBmdWxsQnl0ZUFycmF5LCAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gdGhyb3cgZXhjZXB0aW9uIHNpbmNlIG5vIGluZmxhdGVyIGlzIGF2YWlsYWJsZVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyAnZGljb21QYXJzZXIucGFyc2VEaWNvbTogbm8gaW5mbGF0ZXIgYXZhaWxhYmxlIHRvIGhhbmRsZSBkZWZsYXRlIHRyYW5zZmVyIHN5bnRheCc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYodHJhbnNmZXJTeW50YXggPT09ICcxLjIuODQwLjEwMDA4LjEuMi4yJykgLy8gZXhwbGljaXQgYmlnIGVuZGlhblxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgZGljb21QYXJzZXIuQnl0ZVN0cmVhbShkaWNvbVBhcnNlci5iaWdFbmRpYW5CeXRlQXJyYXlQYXJzZXIsIGJ5dGVBcnJheSwgcG9zaXRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIC8vIGFsbCBvdGhlciB0cmFuc2ZlciBzeW50YXhlcyBhcmUgbGl0dGxlIGVuZGlhbjsgb25seSB0aGUgcGl4ZWwgZW5jb2RpbmcgZGlmZmVyc1xuICAgICAgICAgICAgICAgIC8vIG1ha2UgYSBuZXcgc3RyZWFtIHNvIHRoZSBtZXRhaGVhZGVyIHdhcm5pbmdzIGRvbid0IGNvbWUgYWxvbmcgZm9yIHRoZSByaWRlXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBkaWNvbVBhcnNlci5CeXRlU3RyZWFtKGRpY29tUGFyc2VyLmxpdHRsZUVuZGlhbkJ5dGVBcnJheVBhcnNlciwgYnl0ZUFycmF5LCBwb3NpdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBtZXJnZURhdGFTZXRzKG1ldGFIZWFkZXJEYXRhU2V0LCBpbnN0YW5jZURhdGFTZXQpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGZvciAodmFyIHByb3BlcnR5TmFtZSBpbiBtZXRhSGVhZGVyRGF0YVNldC5lbGVtZW50cylcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpZihtZXRhSGVhZGVyRGF0YVNldC5lbGVtZW50cy5oYXNPd25Qcm9wZXJ0eShwcm9wZXJ0eU5hbWUpKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2VEYXRhU2V0LmVsZW1lbnRzW3Byb3BlcnR5TmFtZV0gPSBtZXRhSGVhZGVyRGF0YVNldC5lbGVtZW50c1twcm9wZXJ0eU5hbWVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXRhSGVhZGVyRGF0YVNldC53YXJuaW5ncyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgaW5zdGFuY2VEYXRhU2V0Lndhcm5pbmdzID0gbWV0YUhlYWRlckRhdGFTZXQud2FybmluZ3MuY29uY2F0KGluc3RhbmNlRGF0YVNldC53YXJuaW5ncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaW5zdGFuY2VEYXRhU2V0O1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gcmVhZERhdGFTZXQobWV0YUhlYWRlckRhdGFTZXQpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciB0cmFuc2ZlclN5bnRheCA9IHJlYWRUcmFuc2ZlclN5bnRheChtZXRhSGVhZGVyRGF0YVNldCk7XG4gICAgICAgICAgICB2YXIgZXhwbGljaXQgPSBpc0V4cGxpY2l0KHRyYW5zZmVyU3ludGF4KTtcbiAgICAgICAgICAgIHZhciBkYXRhU2V0Qnl0ZVN0cmVhbSA9IGdldERhdGFTZXRCeXRlU3RyZWFtKHRyYW5zZmVyU3ludGF4LCBtZXRhSGVhZGVyRGF0YVNldC5wb3NpdGlvbik7XG5cbiAgICAgICAgICAgIHZhciBlbGVtZW50cyA9IHt9O1xuICAgICAgICAgICAgdmFyIGRhdGFTZXQgPSBuZXcgZGljb21QYXJzZXIuRGF0YVNldChkYXRhU2V0Qnl0ZVN0cmVhbS5ieXRlQXJyYXlQYXJzZXIsIGRhdGFTZXRCeXRlU3RyZWFtLmJ5dGVBcnJheSwgZWxlbWVudHMpO1xuICAgICAgICAgICAgZGF0YVNldC53YXJuaW5ncyA9IGRhdGFTZXRCeXRlU3RyZWFtLndhcm5pbmdzO1xuXG4gICAgICAgICAgICB0cnl7XG4gICAgICAgICAgICAgICAgaWYoZXhwbGljaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgZGljb21QYXJzZXIucGFyc2VEaWNvbURhdGFTZXRFeHBsaWNpdChkYXRhU2V0LCBkYXRhU2V0Qnl0ZVN0cmVhbSwgZGF0YVNldEJ5dGVTdHJlYW0uYnl0ZUFycmF5Lmxlbmd0aCwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGRpY29tUGFyc2VyLnBhcnNlRGljb21EYXRhU2V0SW1wbGljaXQoZGF0YVNldCwgZGF0YVNldEJ5dGVTdHJlYW0sIGRhdGFTZXRCeXRlU3RyZWFtLmJ5dGVBcnJheS5sZW5ndGgsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoKGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgZXggPSB7XG4gICAgICAgICAgICAgICAgICAgIGV4Y2VwdGlvbjogZSxcbiAgICAgICAgICAgICAgICAgICAgZGF0YVNldDogZGF0YVNldFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdGhyb3cgZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZGF0YVNldDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG1haW4gZnVuY3Rpb24gaGVyZVxuICAgICAgICBmdW5jdGlvbiBwYXJzZVRoZUJ5dGVTdHJlYW0oKSB7XG4gICAgICAgICAgICB2YXIgbWV0YUhlYWRlckRhdGFTZXQgPSBkaWNvbVBhcnNlci5yZWFkUGFydDEwSGVhZGVyKGJ5dGVBcnJheSwgb3B0aW9ucyk7XG5cbiAgICAgICAgICAgIHZhciBkYXRhU2V0ID0gcmVhZERhdGFTZXQobWV0YUhlYWRlckRhdGFTZXQpO1xuXG4gICAgICAgICAgICByZXR1cm4gbWVyZ2VEYXRhU2V0cyhtZXRhSGVhZGVyRGF0YVNldCwgZGF0YVNldCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUaGlzIGlzIHdoZXJlIHdlIGFjdHVhbGx5IHN0YXJ0IHBhcnNpbmdcbiAgICAgICAgcmV0dXJuIHBhcnNlVGhlQnl0ZVN0cmVhbSgpO1xuICAgIH07XG5cbiAgICByZXR1cm4gZGljb21QYXJzZXI7XG59KShkaWNvbVBhcnNlcik7XG5cbi8qKlxuICogVXRpbGl0eSBmdW5jdGlvbiBmb3IgY3JlYXRpbmcgYSBiYXNpYyBvZmZzZXQgdGFibGUgZm9yIEpQRUcgdHJhbnNmZXIgc3ludGF4ZXNcbiAqL1xuXG52YXIgZGljb21QYXJzZXIgPSAoZnVuY3Rpb24gKGRpY29tUGFyc2VyKVxue1xuICBcInVzZSBzdHJpY3RcIjtcblxuICBpZihkaWNvbVBhcnNlciA9PT0gdW5kZWZpbmVkKVxuICB7XG4gICAgZGljb21QYXJzZXIgPSB7fTtcbiAgfVxuXG4gIC8vIEVhY2ggSlBFRyBpbWFnZSBoYXMgYW4gZW5kIG9mIGltYWdlIG1hcmtlciAweEZGRDlcbiAgZnVuY3Rpb24gaXNFbmRPZkltYWdlTWFya2VyKGRhdGFTZXQsIHBvc2l0aW9uKSB7XG4gICAgcmV0dXJuIChkYXRhU2V0LmJ5dGVBcnJheVtwb3NpdGlvbl0gPT09IDB4RkYgJiZcbiAgICBkYXRhU2V0LmJ5dGVBcnJheVtwb3NpdGlvbiArIDFdID09PSAweEQ5KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzRnJhZ21lbnRFbmRPZkltYWdlKGRhdGFTZXQsIHBpeGVsRGF0YUVsZW1lbnQsIGZyYWdtZW50SW5kZXgpIHtcbiAgICB2YXIgZnJhZ21lbnQgPSBwaXhlbERhdGFFbGVtZW50LmZyYWdtZW50c1tmcmFnbWVudEluZGV4XTtcbiAgICAvLyBOZWVkIHRvIGNoZWNrIHRoZSBsYXN0IHR3byBieXRlcyBhbmQgdGhlIGxhc3QgdGhyZWUgYnl0ZXMgZm9yIG1hcmtlciBzaW5jZSBvZGQgbGVuZ3RoXG4gICAgLy8gZnJhZ21lbnRzIGFyZSB6ZXJvIHBhZGRlZFxuICAgIGlmKGlzRW5kT2ZJbWFnZU1hcmtlcihkYXRhU2V0LCBmcmFnbWVudC5wb3NpdGlvbiArIGZyYWdtZW50Lmxlbmd0aCAtIDIpIHx8XG4gICAgICBpc0VuZE9mSW1hZ2VNYXJrZXIoZGF0YVNldCwgZnJhZ21lbnQucG9zaXRpb24gKyBmcmFnbWVudC5sZW5ndGggLSAzKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbmRMYXN0SW1hZ2VGcmFtZUZyYWdtZW50SW5kZXgoZGF0YVNldCwgcGl4ZWxEYXRhRWxlbWVudCwgc3RhcnRGcmFnbWVudCkge1xuICAgIGZvcih2YXIgZnJhZ21lbnRJbmRleD1zdGFydEZyYWdtZW50OyBmcmFnbWVudEluZGV4IDwgcGl4ZWxEYXRhRWxlbWVudC5mcmFnbWVudHMubGVuZ3RoOyBmcmFnbWVudEluZGV4KyspIHtcbiAgICAgIGlmKGlzRnJhZ21lbnRFbmRPZkltYWdlKGRhdGFTZXQsIHBpeGVsRGF0YUVsZW1lbnQsIGZyYWdtZW50SW5kZXgpKSB7XG4gICAgICAgIHJldHVybiBmcmFnbWVudEluZGV4O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgYmFzaWMgb2Zmc2V0IHRhYmxlIGJ5IHNjYW5uaW5nIGZyYWdtZW50cyBmb3IgSlBFRyBzdGFydCBvZiBpbWFnZSBhbmQgZW5kIE9mIEltYWdlIG1hcmtlcnNcbiAgICogQHBhcmFtIHtvYmplY3R9IGRhdGFTZXQgLSB0aGUgcGFyc2VkIGRpY29tIGRhdGFzZXRcbiAgICogQHBhcmFtIHtvYmplY3R9IHBpeGVsRGF0YUVsZW1lbnQgLSB0aGUgcGl4ZWwgZGF0YSBlbGVtZW50XG4gICAqIEBwYXJhbSBbZnJhZ21lbnRzXSAtIG9wdGlvbmFsIGFycmF5IG9mIG9iamVjdHMgZGVzY3JpYmluZyBlYWNoIGZyYWdtZW50IChvZmZzZXQsIHBvc2l0aW9uLCBsZW5ndGgpXG4gICAqIEByZXR1cm5zIHtBcnJheX0gYmFzaWMgb2Zmc2V0IHRhYmxlIChhcnJheSBvZiBvZmZzZXRzIHRvIGJlZ2lubmluZyBvZiBlYWNoIGZyYW1lKVxuICAgKi9cbiAgZGljb21QYXJzZXIuY3JlYXRlSlBFR0Jhc2ljT2Zmc2V0VGFibGUgPSBmdW5jdGlvbihkYXRhU2V0LCBwaXhlbERhdGFFbGVtZW50LCBmcmFnbWVudHMpIHtcbiAgICAvLyBWYWxpZGF0ZSBwYXJhbWV0ZXJzXG4gICAgaWYoZGF0YVNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyAnZGljb21QYXJzZXIuY3JlYXRlSlBFR0Jhc2ljT2Zmc2V0VGFibGU6IG1pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyIGRhdGFTZXQnO1xuICAgIH1cbiAgICBpZihwaXhlbERhdGFFbGVtZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93ICdkaWNvbVBhcnNlci5jcmVhdGVKUEVHQmFzaWNPZmZzZXRUYWJsZTogbWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXIgcGl4ZWxEYXRhRWxlbWVudCc7XG4gICAgfVxuICAgIGlmKHBpeGVsRGF0YUVsZW1lbnQudGFnICE9PSAneDdmZTAwMDEwJykge1xuICAgICAgdGhyb3cgXCJkaWNvbVBhcnNlci5jcmVhdGVKUEVHQmFzaWNPZmZzZXRUYWJsZTogcGFyYW1ldGVyICdwaXhlbERhdGFFbGVtZW50JyByZWZlcnMgdG8gbm9uIHBpeGVsIGRhdGEgdGFnIChleHBlY3RlZCB0YWcgPSB4N2ZlMDAwMTAnXCI7XG4gICAgfVxuICAgIGlmKHBpeGVsRGF0YUVsZW1lbnQuZW5jYXBzdWxhdGVkUGl4ZWxEYXRhICE9PSB0cnVlKSB7XG4gICAgICB0aHJvdyBcImRpY29tUGFyc2VyLmNyZWF0ZUpQRUdCYXNpY09mZnNldFRhYmxlOiBwYXJhbWV0ZXIgJ3BpeGVsRGF0YUVsZW1lbnQnIHJlZmVycyB0byBwaXhlbCBkYXRhIGVsZW1lbnQgdGhhdCBkb2VzIG5vdCBoYXZlIGVuY2Fwc3VsYXRlZCBwaXhlbCBkYXRhXCI7XG4gICAgfVxuICAgIGlmKHBpeGVsRGF0YUVsZW1lbnQuaGFkVW5kZWZpbmVkTGVuZ3RoICE9PSB0cnVlKSB7XG4gICAgICB0aHJvdyBcImRpY29tUGFyc2VyLmNyZWF0ZUpQRUdCYXNpY09mZnNldFRhYmxlOiBwYXJhbWV0ZXIgJ3BpeGVsRGF0YUVsZW1lbnQnIHJlZmVycyB0byBwaXhlbCBkYXRhIGVsZW1lbnQgdGhhdCBkb2VzIG5vdCBoYXZlIGVuY2Fwc3VsYXRlZCBwaXhlbCBkYXRhXCI7XG4gICAgfVxuICAgIGlmKHBpeGVsRGF0YUVsZW1lbnQuYmFzaWNPZmZzZXRUYWJsZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBcImRpY29tUGFyc2VyLmNyZWF0ZUpQRUdCYXNpY09mZnNldFRhYmxlOiBwYXJhbWV0ZXIgJ3BpeGVsRGF0YUVsZW1lbnQnIHJlZmVycyB0byBwaXhlbCBkYXRhIGVsZW1lbnQgdGhhdCBkb2VzIG5vdCBoYXZlIGVuY2Fwc3VsYXRlZCBwaXhlbCBkYXRhXCI7XG4gICAgfVxuICAgIGlmKHBpeGVsRGF0YUVsZW1lbnQuZnJhZ21lbnRzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IFwiZGljb21QYXJzZXIuY3JlYXRlSlBFR0Jhc2ljT2Zmc2V0VGFibGU6IHBhcmFtZXRlciAncGl4ZWxEYXRhRWxlbWVudCcgcmVmZXJzIHRvIHBpeGVsIGRhdGEgZWxlbWVudCB0aGF0IGRvZXMgbm90IGhhdmUgZW5jYXBzdWxhdGVkIHBpeGVsIGRhdGFcIjtcbiAgICB9XG4gICAgaWYocGl4ZWxEYXRhRWxlbWVudC5mcmFnbWVudHMubGVuZ3RoIDw9IDApIHtcbiAgICAgIHRocm93IFwiZGljb21QYXJzZXIuY3JlYXRlSlBFR0Jhc2ljT2Zmc2V0VGFibGU6IHBhcmFtZXRlciAncGl4ZWxEYXRhRWxlbWVudCcgcmVmZXJzIHRvIHBpeGVsIGRhdGEgZWxlbWVudCB0aGF0IGRvZXMgbm90IGhhdmUgZW5jYXBzdWxhdGVkIHBpeGVsIGRhdGFcIjtcbiAgICB9XG4gICAgaWYoZnJhZ21lbnRzICYmIGZyYWdtZW50cy5sZW5ndGggPD0wKSB7XG4gICAgICB0aHJvdyBcImRpY29tUGFyc2VyLmNyZWF0ZUpQRUdCYXNpY09mZnNldFRhYmxlOiBwYXJhbWV0ZXIgJ2ZyYWdtZW50cycgbXVzdCBub3QgYmUgemVybyBsZW5ndGhcIjtcbiAgICB9XG5cbiAgICAvLyBEZWZhdWx0IHZhbHVlc1xuICAgIGZyYWdtZW50cyA9IGZyYWdtZW50cyB8fCBwaXhlbERhdGFFbGVtZW50LmZyYWdtZW50cztcblxuICAgIHZhciBiYXNpY09mZnNldFRhYmxlID0gW107XG5cbiAgICB2YXIgc3RhcnRGcmFnbWVudEluZGV4ID0gMDtcblxuICAgIHdoaWxlKHRydWUpIHtcbiAgICAgIC8vIEFkZCB0aGUgb2Zmc2V0IGZvciB0aGUgc3RhcnQgZnJhZ21lbnRcbiAgICAgIGJhc2ljT2Zmc2V0VGFibGUucHVzaChwaXhlbERhdGFFbGVtZW50LmZyYWdtZW50c1tzdGFydEZyYWdtZW50SW5kZXhdLm9mZnNldCk7XG4gICAgICB2YXIgZW5kRnJhZ21lbnRJbmRleCA9IGZpbmRMYXN0SW1hZ2VGcmFtZUZyYWdtZW50SW5kZXgoZGF0YVNldCwgcGl4ZWxEYXRhRWxlbWVudCwgc3RhcnRGcmFnbWVudEluZGV4KTtcbiAgICAgIGlmKGVuZEZyYWdtZW50SW5kZXggPT09IHVuZGVmaW5lZCB8fCBlbmRGcmFnbWVudEluZGV4ID09PSBwaXhlbERhdGFFbGVtZW50LmZyYWdtZW50cy5sZW5ndGggLTEpIHtcbiAgICAgICAgcmV0dXJuIGJhc2ljT2Zmc2V0VGFibGU7XG4gICAgICB9XG4gICAgICBzdGFydEZyYWdtZW50SW5kZXggPSBlbmRGcmFnbWVudEluZGV4ICsgMTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIGRpY29tUGFyc2VyO1xufShkaWNvbVBhcnNlcikpO1xudmFyIGRpY29tUGFyc2VyID0gKGZ1bmN0aW9uIChkaWNvbVBhcnNlcikge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgaWYgKGRpY29tUGFyc2VyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZGljb21QYXJzZXIgPSB7fTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBjb252ZXJ0cyBhbiBleHBsaWNpdCBkYXRhU2V0IHRvIGEgamF2YXNjcmlwdCBvYmplY3RcbiAgICAgKiBAcGFyYW0gZGF0YVNldFxuICAgICAqIEBwYXJhbSBvcHRpb25zXG4gICAgICovXG4gICAgZGljb21QYXJzZXIuZXhwbGljaXREYXRhU2V0VG9KUyA9IGZ1bmN0aW9uIChkYXRhU2V0LCBvcHRpb25zKSB7XG5cbiAgICAgICAgaWYoZGF0YVNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyAnZGljb21QYXJzZXIuZXhwbGljaXREYXRhU2V0VG9KUzogbWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXIgZGF0YVNldCc7XG4gICAgICAgIH1cblxuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7XG4gICAgICAgICAgICBvbWl0UHJpdmF0ZUF0dGlidXRlczogdHJ1ZSwgLy8gdHJ1ZSBpZiBwcml2YXRlIGVsZW1lbnRzIHNob3VsZCBiZSBvbWl0dGVkXG4gICAgICAgICAgICBtYXhFbGVtZW50TGVuZ3RoIDogMTI4ICAgICAgLy8gbWF4aW11bSBlbGVtZW50IGxlbmd0aCB0byB0cnkgYW5kIGNvbnZlcnQgdG8gc3RyaW5nIGZvcm1hdFxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciByZXN1bHQgPSB7XG5cbiAgICAgICAgfTtcblxuICAgICAgICBmb3IodmFyIHRhZyBpbiBkYXRhU2V0LmVsZW1lbnRzKSB7XG4gICAgICAgICAgICB2YXIgZWxlbWVudCA9IGRhdGFTZXQuZWxlbWVudHNbdGFnXTtcblxuICAgICAgICAgICAgLy8gc2tpcCB0aGlzIGVsZW1lbnQgaWYgaXQgYSBwcml2YXRlIGVsZW1lbnQgYW5kIG91ciBvcHRpb25zIHNwZWNpZnkgdGhhdCB3ZSBzaG91bGRcbiAgICAgICAgICAgIGlmKG9wdGlvbnMub21pdFByaXZhdGVBdHRpYnV0ZXMgPT09IHRydWUgJiYgZGljb21QYXJzZXIuaXNQcml2YXRlVGFnKHRhZykpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKGVsZW1lbnQuaXRlbXMpIHtcbiAgICAgICAgICAgICAgICAvLyBoYW5kbGUgc2VxdWVuY2VzXG4gICAgICAgICAgICAgICAgdmFyIHNlcXVlbmNlSXRlbXMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IodmFyIGk9MDsgaSA8IGVsZW1lbnQuaXRlbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgc2VxdWVuY2VJdGVtcy5wdXNoKGRpY29tUGFyc2VyLmV4cGxpY2l0RGF0YVNldFRvSlMoZWxlbWVudC5pdGVtc1tpXS5kYXRhU2V0LCBvcHRpb25zKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdFt0YWddID0gc2VxdWVuY2VJdGVtcztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGFzU3RyaW5nO1xuICAgICAgICAgICAgICAgIGFzU3RyaW5nID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGlmKGVsZW1lbnQubGVuZ3RoIDwgb3B0aW9ucy5tYXhFbGVtZW50TGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGFzU3RyaW5nID0gZGljb21QYXJzZXIuZXhwbGljaXRFbGVtZW50VG9TdHJpbmcoZGF0YVNldCwgZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYoYXNTdHJpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRbdGFnXSA9IGFzU3RyaW5nO1xuICAgICAgICAgICAgICAgIH0gIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRbdGFnXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFPZmZzZXQ6IGVsZW1lbnQuZGF0YU9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlbmd0aCA6IGVsZW1lbnQubGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG5cbiAgICByZXR1cm4gZGljb21QYXJzZXI7XG59KGRpY29tUGFyc2VyKSk7XG52YXIgZGljb21QYXJzZXIgPSAoZnVuY3Rpb24gKGRpY29tUGFyc2VyKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBpZiAoZGljb21QYXJzZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBkaWNvbVBhcnNlciA9IHt9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGFuIGV4cGxpY2l0IFZSIGVsZW1lbnQgdG8gYSBzdHJpbmcgb3IgdW5kZWZpbmVkIGlmIGl0IGlzIG5vdCBwb3NzaWJsZSB0byBjb252ZXJ0LlxuICAgICAqIFRocm93cyBhbiBlcnJvciBpZiBhbiBpbXBsaWNpdCBlbGVtZW50IGlzIHN1cHBsaWVkXG4gICAgICogQHBhcmFtIGRhdGFTZXRcbiAgICAgKiBAcGFyYW0gZWxlbWVudFxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIGRpY29tUGFyc2VyLmV4cGxpY2l0RWxlbWVudFRvU3RyaW5nID0gZnVuY3Rpb24oZGF0YVNldCwgZWxlbWVudClcbiAgICB7XG4gICAgICAgIGlmKGRhdGFTZXQgPT09IHVuZGVmaW5lZCB8fCBlbGVtZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93ICdkaWNvbVBhcnNlci5leHBsaWNpdEVsZW1lbnRUb1N0cmluZzogbWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXJzJztcbiAgICAgICAgfVxuICAgICAgICBpZihlbGVtZW50LnZyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93ICdkaWNvbVBhcnNlci5leHBsaWNpdEVsZW1lbnRUb1N0cmluZzogY2Fubm90IGNvbnZlcnQgaW1wbGljaXQgZWxlbWVudCB0byBzdHJpbmcnO1xuICAgICAgICB9XG4gICAgICAgIHZhciB2ciA9IGVsZW1lbnQudnI7XG4gICAgICAgIHZhciB0YWcgPSBlbGVtZW50LnRhZztcblxuICAgICAgICB2YXIgdGV4dFJlc3VsdDtcblxuICAgICAgICBmdW5jdGlvbiBtdWx0aUVsZW1lbnRUb1N0cmluZyhudW1JdGVtcywgZnVuYykge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFwiXCI7XG4gICAgICAgICAgICBmb3IodmFyIGk9MDsgaSA8IG51bUl0ZW1zOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZihpICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnLyc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBmdW5jLmNhbGwoZGF0YVNldCwgdGFnLCBpKS50b1N0cmluZygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKGRpY29tUGFyc2VyLmlzU3RyaW5nVnIodnIpID09PSB0cnVlKVxuICAgICAgICB7XG4gICAgICAgICAgICB0ZXh0UmVzdWx0ID0gZGF0YVNldC5zdHJpbmcodGFnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2ciA9PSAnQVQnKSB7XG4gICAgICAgICAgICB2YXIgbnVtID0gZGF0YVNldC51aW50MzIodGFnKTtcbiAgICAgICAgICAgIGlmKG51bSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChudW0gPCAwKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG51bSA9IDB4RkZGRkZGRkYgKyBudW0gKyAxO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gJ3gnICsgbnVtLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZyID09ICdVUycpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRleHRSZXN1bHQgPSBtdWx0aUVsZW1lbnRUb1N0cmluZyhlbGVtZW50Lmxlbmd0aCAvIDIsIGRhdGFTZXQudWludDE2KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmKHZyID09PSAnU1MnKVxuICAgICAgICB7XG4gICAgICAgICAgICB0ZXh0UmVzdWx0ID0gbXVsdGlFbGVtZW50VG9TdHJpbmcoZWxlbWVudC5sZW5ndGggLyAyLCBkYXRhU2V0LmludDE2KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2ciA9PSAnVUwnKVxuICAgICAgICB7XG4gICAgICAgICAgICB0ZXh0UmVzdWx0ID0gbXVsdGlFbGVtZW50VG9TdHJpbmcoZWxlbWVudC5sZW5ndGggLyA0LCBkYXRhU2V0LnVpbnQzMik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZih2ciA9PT0gJ1NMJylcbiAgICAgICAge1xuICAgICAgICAgICAgdGV4dFJlc3VsdCA9IG11bHRpRWxlbWVudFRvU3RyaW5nKGVsZW1lbnQubGVuZ3RoIC8gNCwgZGF0YVNldC5pbnQzMik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZih2ciA9PSAnRkQnKVxuICAgICAgICB7XG4gICAgICAgICAgICB0ZXh0UmVzdWx0ID0gbXVsdGlFbGVtZW50VG9TdHJpbmcoZWxlbWVudC5sZW5ndGggLyA4LCBkYXRhU2V0LmRvdWJsZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZih2ciA9PSAnRkwnKVxuICAgICAgICB7XG4gICAgICAgICAgICB0ZXh0UmVzdWx0ID0gbXVsdGlFbGVtZW50VG9TdHJpbmcoZWxlbWVudC5sZW5ndGggLyA0LCBkYXRhU2V0LmZsb2F0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0ZXh0UmVzdWx0O1xuICAgIH07XG4gICAgcmV0dXJuIGRpY29tUGFyc2VyO1xufShkaWNvbVBhcnNlcikpO1xuLyoqXG4gKiBVdGlsaXR5IGZ1bmN0aW9ucyBmb3IgZGVhbGluZyB3aXRoIERJQ09NXG4gKi9cblxudmFyIGRpY29tUGFyc2VyID0gKGZ1bmN0aW9uIChkaWNvbVBhcnNlcilcbntcbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgaWYoZGljb21QYXJzZXIgPT09IHVuZGVmaW5lZClcbiAge1xuICAgIGRpY29tUGFyc2VyID0ge307XG4gIH1cblxuICAvLyBhbGdvcml0aG0gYmFzZWQgb24gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xNDMzMDMwL3ZhbGlkYXRlLW51bWJlci1vZi1kYXlzLWluLWEtZ2l2ZW4tbW9udGhcbiAgZnVuY3Rpb24gZGF5c0luTW9udGgobSwgeSkgeyAvLyBtIGlzIDAgaW5kZXhlZDogMC0xMVxuICAgIHN3aXRjaCAobSkge1xuICAgICAgY2FzZSAyIDpcbiAgICAgICAgcmV0dXJuICh5ICUgNCA9PSAwICYmIHkgJSAxMDApIHx8IHkgJSA0MDAgPT0gMCA/IDI5IDogMjg7XG4gICAgICBjYXNlIDkgOiBjYXNlIDQgOiBjYXNlIDYgOiBjYXNlIDExIDpcbiAgICAgIHJldHVybiAzMDtcbiAgICAgIGRlZmF1bHQgOlxuICAgICAgICByZXR1cm4gMzFcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpc1ZhbGlkRGF0ZShkLCBtLCB5KSB7XG4gICAgLy8gbWFrZSB5ZWFyIGlzIGEgbnVtYmVyXG4gICAgaWYoaXNOYU4oeSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIG0gPiAwICYmIG0gPD0gMTIgJiYgZCA+IDAgJiYgZCA8PSBkYXlzSW5Nb250aChtLCB5KTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIFBhcnNlcyBhIERBIGZvcm1hdHRlZCBzdHJpbmcgaW50byBhIEphdmFzY3JpcHQgb2JqZWN0XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBkYXRlIGEgc3RyaW5nIGluIHRoZSBEQSBWUiBmb3JtYXRcbiAgICogQHBhcmFtIHtib29sZWFufSBbdmFsaWRhdGVdIC0gdHJ1ZSBpZiBhbiBleGNlcHRpb24gc2hvdWxkIGJlIHRocm93biBpZiB0aGUgZGF0ZSBpcyBpbnZhbGlkXG4gICAqIEByZXR1cm5zIHsqfSBKYXZhc2NyaXB0IG9iamVjdCB3aXRoIHByb3BlcnRpZXMgeWVhciwgbW9udGggYW5kIGRheSBvciB1bmRlZmluZWQgaWYgbm90IHByZXNlbnQgb3Igbm90IDggYnl0ZXMgbG9uZ1xuICAgKi9cbiAgZGljb21QYXJzZXIucGFyc2VEQSA9IGZ1bmN0aW9uKGRhdGUsIHZhbGlkYXRlKVxuICB7XG4gICAgaWYoZGF0ZSAmJiBkYXRlLmxlbmd0aCA9PT0gOClcbiAgICB7XG4gICAgICB2YXIgeXl5eSA9IHBhcnNlSW50KGRhdGUuc3Vic3RyaW5nKDAsIDQpLCAxMCk7XG4gICAgICB2YXIgbW0gPSBwYXJzZUludChkYXRlLnN1YnN0cmluZyg0LCA2KSwgMTApO1xuICAgICAgdmFyIGRkID0gcGFyc2VJbnQoZGF0ZS5zdWJzdHJpbmcoNiwgOCksIDEwKTtcblxuICAgICAgaWYodmFsaWRhdGUpIHtcbiAgICAgICAgaWYgKGlzVmFsaWREYXRlKGRkLCBtbSwgeXl5eSkgIT09IHRydWUpIHtcbiAgICAgICAgICB0aHJvdyBcImludmFsaWQgREEgJ1wiICsgZGF0ZSArIFwiJ1wiO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICB5ZWFyOiB5eXl5LFxuICAgICAgICBtb250aDogbW0sXG4gICAgICAgIGRheTogZGRcbiAgICAgIH07XG4gICAgfVxuICAgIGlmKHZhbGlkYXRlKSB7XG4gICAgICB0aHJvdyBcImludmFsaWQgREEgJ1wiICsgZGF0ZSArIFwiJ1wiO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9O1xuXG4gIHJldHVybiBkaWNvbVBhcnNlcjtcbn0oZGljb21QYXJzZXIpKTtcbi8qKlxuICogVXRpbGl0eSBmdW5jdGlvbnMgZm9yIGRlYWxpbmcgd2l0aCBESUNPTVxuICovXG5cbnZhciBkaWNvbVBhcnNlciA9IChmdW5jdGlvbiAoZGljb21QYXJzZXIpXG57XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIGlmKGRpY29tUGFyc2VyID09PSB1bmRlZmluZWQpXG4gIHtcbiAgICBkaWNvbVBhcnNlciA9IHt9O1xuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlcyBhIFRNIGZvcm1hdHRlZCBzdHJpbmcgaW50byBhIGphdmFzY3JpcHQgb2JqZWN0IHdpdGggcHJvcGVydGllcyBmb3IgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMgYW5kIGZyYWN0aW9uYWxTZWNvbmRzXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0aW1lIC0gYSBzdHJpbmcgaW4gdGhlIFRNIFZSIGZvcm1hdFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFt2YWxpZGF0ZV0gLSB0cnVlIGlmIGFuIGV4Y2VwdGlvbiBzaG91bGQgYmUgdGhyb3duIGlmIHRoZSBkYXRlIGlzIGludmFsaWRcbiAgICogQHJldHVybnMgeyp9IGphdmFzY3JpcHQgb2JqZWN0IHdpdGggcHJvcGVydGllcyBmb3IgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMgYW5kIGZyYWN0aW9uYWxTZWNvbmRzIG9yIHVuZGVmaW5lZCBpZiBubyBlbGVtZW50IG9yIGRhdGEuICBNaXNzaW5nIGZpZWxkcyBhcmUgc2V0IHRvIHVuZGVmaW5lZFxuICAgKi9cbiAgZGljb21QYXJzZXIucGFyc2VUTSA9IGZ1bmN0aW9uKHRpbWUsIHZhbGlkYXRlKSB7XG5cbiAgICBpZiAodGltZS5sZW5ndGggPj0gMikgLy8gbXVzdCBhdCBsZWFzdCBoYXZlIEhIXG4gICAge1xuICAgICAgLy8gMDEyMzQ1Njc4OVxuICAgICAgLy8gSEhNTVNTLkZGRkZGRlxuICAgICAgdmFyIGhoID0gcGFyc2VJbnQodGltZS5zdWJzdHJpbmcoMCwgMiksIDEwKTtcbiAgICAgIHZhciBtbSA9IHRpbWUubGVuZ3RoID49IDQgPyBwYXJzZUludCh0aW1lLnN1YnN0cmluZygyLCA0KSwgMTApIDogdW5kZWZpbmVkO1xuICAgICAgdmFyIHNzID0gdGltZS5sZW5ndGggPj0gNiA/IHBhcnNlSW50KHRpbWUuc3Vic3RyaW5nKDQsIDYpLCAxMCkgOiB1bmRlZmluZWQ7XG4gICAgICB2YXIgZmZmZmZmID0gdGltZS5sZW5ndGggPj0gOCA/IHBhcnNlSW50KHRpbWUuc3Vic3RyaW5nKDcsIDEzKSwgMTApIDogdW5kZWZpbmVkO1xuXG4gICAgICBpZih2YWxpZGF0ZSkge1xuICAgICAgICBpZigoaXNOYU4oaGgpKSB8fFxuICAgICAgICAgIChtbSAhPT0gdW5kZWZpbmVkICYmIGlzTmFOKG1tKSkgfHxcbiAgICAgICAgICAoc3MgIT09IHVuZGVmaW5lZCAmJiBpc05hTihzcykpIHx8XG4gICAgICAgICAgKGZmZmZmZiAhPT0gdW5kZWZpbmVkICYmIGlzTmFOKGZmZmZmZikpIHx8XG4gICAgICAgICAgKGhoIDwgMCB8fCBoaCA+IDIzKSB8fFxuICAgICAgICAgIChtbSAmJiAobW0gPDAgfHwgbW0gPiA1OSkpICB8fFxuICAgICAgICAgIChzcyAmJiAoc3MgPDAgfHwgc3MgPiA1OSkpICB8fFxuICAgICAgICAgIChmZmZmZmYgJiYgKGZmZmZmZiA8MCB8fCBmZmZmZmYgPiA5OTk5OTkpKSlcbiAgICAgICAge1xuICAgICAgICAgIHRocm93IFwiaW52YWxpZCBUTSAnXCIgKyB0aW1lICsgXCInXCI7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaG91cnM6IGhoLFxuICAgICAgICBtaW51dGVzOiBtbSxcbiAgICAgICAgc2Vjb25kczogc3MsXG4gICAgICAgIGZyYWN0aW9uYWxTZWNvbmRzOiBmZmZmZmZcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYodmFsaWRhdGUpIHtcbiAgICAgIHRocm93IFwiaW52YWxpZCBUTSAnXCIgKyB0aW1lICsgXCInXCI7XG4gICAgfVxuXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfTtcblxuICByZXR1cm4gZGljb21QYXJzZXI7XG59KGRpY29tUGFyc2VyKSk7XG4vKipcbiAqIFV0aWxpdHkgZnVuY3Rpb25zIGZvciBkZWFsaW5nIHdpdGggRElDT01cbiAqL1xuXG52YXIgZGljb21QYXJzZXIgPSAoZnVuY3Rpb24gKGRpY29tUGFyc2VyKVxue1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgaWYoZGljb21QYXJzZXIgPT09IHVuZGVmaW5lZClcbiAgICB7XG4gICAgICAgIGRpY29tUGFyc2VyID0ge307XG4gICAgfVxuXG4gICAgdmFyIHN0cmluZ1ZycyA9IHtcbiAgICAgICAgQUU6IHRydWUsXG4gICAgICAgIEFTOiB0cnVlLFxuICAgICAgICBBVDogZmFsc2UsXG4gICAgICAgIENTOiB0cnVlLFxuICAgICAgICBEQTogdHJ1ZSxcbiAgICAgICAgRFM6IHRydWUsXG4gICAgICAgIERUOiB0cnVlLFxuICAgICAgICBGTDogZmFsc2UsXG4gICAgICAgIEZEOiBmYWxzZSxcbiAgICAgICAgSVM6IHRydWUsXG4gICAgICAgIExPOiB0cnVlLFxuICAgICAgICBMVDogdHJ1ZSxcbiAgICAgICAgT0I6IGZhbHNlLFxuICAgICAgICBPRDogZmFsc2UsXG4gICAgICAgIE9GOiBmYWxzZSxcbiAgICAgICAgT1c6IGZhbHNlLFxuICAgICAgICBQTjogdHJ1ZSxcbiAgICAgICAgU0g6IHRydWUsXG4gICAgICAgIFNMOiBmYWxzZSxcbiAgICAgICAgU1E6IGZhbHNlLFxuICAgICAgICBTUzogZmFsc2UsXG4gICAgICAgIFNUOiB0cnVlLFxuICAgICAgICBUTTogdHJ1ZSxcbiAgICAgICAgVUk6IHRydWUsXG4gICAgICAgIFVMOiBmYWxzZSxcbiAgICAgICAgVU46IHVuZGVmaW5lZCwgLy8gZHVubm9cbiAgICAgICAgVVI6IHRydWUsXG4gICAgICAgIFVTOiBmYWxzZSxcbiAgICAgICAgVVQ6IHRydWVcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVGVzdHMgdG8gc2VlIGlmIHZyIGlzIGEgc3RyaW5nIG9yIG5vdC5cbiAgICAgKiBAcGFyYW0gdnJcbiAgICAgKiBAcmV0dXJucyB0cnVlIGlmIHN0cmluZywgZmFsc2UgaXQgbm90IHN0cmluZywgdW5kZWZpbmVkIGlmIHVua25vd24gdnIgb3IgVU4gdHlwZVxuICAgICAqL1xuICAgIGRpY29tUGFyc2VyLmlzU3RyaW5nVnIgPSBmdW5jdGlvbih2cilcbiAgICB7XG4gICAgICAgIHJldHVybiBzdHJpbmdWcnNbdnJdO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUZXN0cyB0byBzZWUgaWYgYSBnaXZlbiB0YWcgaW4gdGhlIGZvcm1hdCB4Z2dnZ2VlZWUgaXMgYSBwcml2YXRlIHRhZyBvciBub3RcbiAgICAgKiBAcGFyYW0gdGFnXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgZGljb21QYXJzZXIuaXNQcml2YXRlVGFnID0gZnVuY3Rpb24odGFnKVxuICAgIHtcbiAgICAgICAgdmFyIGxhc3RHcm91cERpZ2l0ID0gcGFyc2VJbnQodGFnWzRdKTtcbiAgICAgICAgdmFyIGdyb3VwSXNPZGQgPSAobGFzdEdyb3VwRGlnaXQgJSAyKSA9PT0gMTtcbiAgICAgICAgcmV0dXJuIGdyb3VwSXNPZGQ7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFBhcnNlcyBhIFBOIGZvcm1hdHRlZCBzdHJpbmcgaW50byBhIGphdmFzY3JpcHQgb2JqZWN0IHdpdGggcHJvcGVydGllcyBmb3IgZ2l2ZW5OYW1lLCBmYW1pbHlOYW1lLCBtaWRkbGVOYW1lLCBwcmVmaXggYW5kIHN1ZmZpeFxuICAgICAqIEBwYXJhbSBwZXJzb25OYW1lIGEgc3RyaW5nIGluIHRoZSBQTiBWUiBmb3JtYXRcbiAgICAgKiBAcGFyYW0gaW5kZXhcbiAgICAgKiBAcmV0dXJucyB7Kn0gamF2YXNjcmlwdCBvYmplY3Qgd2l0aCBwcm9wZXJ0aWVzIGZvciBnaXZlbk5hbWUsIGZhbWlseU5hbWUsIG1pZGRsZU5hbWUsIHByZWZpeCBhbmQgc3VmZml4IG9yIHVuZGVmaW5lZCBpZiBubyBlbGVtZW50IG9yIGRhdGFcbiAgICAgKi9cbiAgICBkaWNvbVBhcnNlci5wYXJzZVBOID0gZnVuY3Rpb24ocGVyc29uTmFtZSkge1xuICAgICAgICBpZihwZXJzb25OYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN0cmluZ1ZhbHVlcyA9IHBlcnNvbk5hbWUuc3BsaXQoJ14nKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGZhbWlseU5hbWU6IHN0cmluZ1ZhbHVlc1swXSxcbiAgICAgICAgICAgIGdpdmVuTmFtZTogc3RyaW5nVmFsdWVzWzFdLFxuICAgICAgICAgICAgbWlkZGxlTmFtZTogc3RyaW5nVmFsdWVzWzJdLFxuICAgICAgICAgICAgcHJlZml4OiBzdHJpbmdWYWx1ZXNbM10sXG4gICAgICAgICAgICBzdWZmaXg6IHN0cmluZ1ZhbHVlc1s0XVxuICAgICAgICB9O1xuICAgIH07XG5cblxuXG4gICAgcmV0dXJuIGRpY29tUGFyc2VyO1xufShkaWNvbVBhcnNlcikpO1xuLyoqXG4gKiBGdW5jdGlvbmFsaXR5IGZvciBleHRyYWN0aW5nIGVuY2Fwc3VsYXRlZCBwaXhlbCBkYXRhXG4gKi9cblxudmFyIGRpY29tUGFyc2VyID0gKGZ1bmN0aW9uIChkaWNvbVBhcnNlcilcbntcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGlmKGRpY29tUGFyc2VyID09PSB1bmRlZmluZWQpXG4gICAge1xuICAgICAgICBkaWNvbVBhcnNlciA9IHt9O1xuICAgIH1cblxuICAgIHZhciBkZXByZWNhdGVkTm90aWNlTG9nZ2VkID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBwaXhlbCBkYXRhIGZvciB0aGUgc3BlY2lmaWVkIGZyYW1lIGluIGFuIGVuY2Fwc3VsYXRlZCBwaXhlbCBkYXRhIGVsZW1lbnQuICBJZiBubyBiYXNpYyBvZmZzZXRcbiAgICAgKiB0YWJsZSBpcyBwcmVzZW50LCBpdCBhc3N1bWVzIHRoYXQgYWxsIGZyYWdtZW50cyBhcmUgZm9yIG9uZSBmcmFtZS4gIE5vdGUgdGhhdCB0aGlzIGFzc3VtcHRpb24vbG9naWMgaXMgbm90XG4gICAgICogdmFsaWQgZm9yIG11bHRpLWZyYW1lIGluc3RhbmNlcyBzbyB0aGlzIGZ1bmN0aW9uIGhhcyBiZWVuIGRlcHJlY2F0ZWQgYW5kIHdpbGwgZXZlbnR1YWxseSBiZSByZW1vdmVkLiAgQ29kZVxuICAgICAqIHNob3VsZCBiZSB1cGRhdGVkIHRvIHVzZSByZWFkRW5jYXBzdWxhdGVkUGl4ZWxEYXRhRnJvbUZyYWdtZW50cygpIG9yIHJlYWRFbmNhcHN1bGF0ZWRJbWFnZUZyYW1lKClcbiAgICAgKlxuICAgICAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMS42IC0gdXNlIHJlYWRFbmNhcHN1bGF0ZWRQaXhlbERhdGFGcm9tRnJhZ21lbnRzKCkgb3IgcmVhZEVuY2Fwc3VsYXRlZEltYWdlRnJhbWUoKVxuICAgICAqIEBwYXJhbSBkYXRhU2V0IC0gdGhlIGRhdGFTZXQgY29udGFpbmluZyB0aGUgZW5jYXBzdWxhdGVkIHBpeGVsIGRhdGFcbiAgICAgKiBAcGFyYW0gcGl4ZWxEYXRhRWxlbWVudCAtIHRoZSBwaXhlbCBkYXRhIGVsZW1lbnQgKHg3ZmUwMDAxMCkgdG8gZXh0cmFjdCB0aGUgZnJhbWUgZnJvbVxuICAgICAqIEBwYXJhbSBmcmFtZSAtIHRoZSB6ZXJvIGJhc2VkIGZyYW1lIGluZGV4XG4gICAgICogQHJldHVybnMge29iamVjdH0gd2l0aCB0aGUgZW5jYXBzdWxhdGVkIHBpeGVsIGRhdGFcbiAgICAgKi9cblxuXG4gICAgZGljb21QYXJzZXIucmVhZEVuY2Fwc3VsYXRlZFBpeGVsRGF0YSA9IGZ1bmN0aW9uKGRhdGFTZXQsIHBpeGVsRGF0YUVsZW1lbnQsIGZyYW1lKVxuICAgIHtcbiAgICAgICAgaWYoIWRlcHJlY2F0ZWROb3RpY2VMb2dnZWQpIHtcbiAgICAgICAgICAgIGRlcHJlY2F0ZWROb3RpY2VMb2dnZWQgPSB0cnVlO1xuICAgICAgICAgICAgaWYoY29uc29sZSAmJiBjb25zb2xlLmxvZykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiV0FSTklORzogZGljb21QYXJzZXIucmVhZEVuY2Fwc3VsYXRlZFBpeGVsRGF0YSgpIGhhcyBiZWVuIGRlcHJlY2F0ZWRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZihkYXRhU2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IFwiZGljb21QYXJzZXIucmVhZEVuY2Fwc3VsYXRlZFBpeGVsRGF0YTogbWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXIgJ2RhdGFTZXQnXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYocGl4ZWxEYXRhRWxlbWVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBcImRpY29tUGFyc2VyLnJlYWRFbmNhcHN1bGF0ZWRQaXhlbERhdGE6IG1pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyICdlbGVtZW50J1wiO1xuICAgICAgICB9XG4gICAgICAgIGlmKGZyYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IFwiZGljb21QYXJzZXIucmVhZEVuY2Fwc3VsYXRlZFBpeGVsRGF0YTogbWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXIgJ2ZyYW1lJ1wiO1xuICAgICAgICB9XG4gICAgICAgIGlmKHBpeGVsRGF0YUVsZW1lbnQudGFnICE9PSAneDdmZTAwMDEwJykge1xuICAgICAgICAgICAgdGhyb3cgXCJkaWNvbVBhcnNlci5yZWFkRW5jYXBzdWxhdGVkUGl4ZWxEYXRhOiBwYXJhbWV0ZXIgJ2VsZW1lbnQnIHJlZmVycyB0byBub24gcGl4ZWwgZGF0YSB0YWcgKGV4cGVjdGVkIHRhZyA9IHg3ZmUwMDAxMCdcIjtcbiAgICAgICAgfVxuICAgICAgICBpZihwaXhlbERhdGFFbGVtZW50LmVuY2Fwc3VsYXRlZFBpeGVsRGF0YSAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgdGhyb3cgXCJkaWNvbVBhcnNlci5yZWFkRW5jYXBzdWxhdGVkUGl4ZWxEYXRhOiBwYXJhbWV0ZXIgJ2VsZW1lbnQnIHJlZmVycyB0byBwaXhlbCBkYXRhIGVsZW1lbnQgdGhhdCBkb2VzIG5vdCBoYXZlIGVuY2Fwc3VsYXRlZCBwaXhlbCBkYXRhXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYocGl4ZWxEYXRhRWxlbWVudC5oYWRVbmRlZmluZWRMZW5ndGggIT09IHRydWUpIHtcbiAgICAgICAgICAgIHRocm93IFwiZGljb21QYXJzZXIucmVhZEVuY2Fwc3VsYXRlZFBpeGVsRGF0YTogcGFyYW1ldGVyICdlbGVtZW50JyByZWZlcnMgdG8gcGl4ZWwgZGF0YSBlbGVtZW50IHRoYXQgZG9lcyBub3QgaGF2ZSBlbmNhcHN1bGF0ZWQgcGl4ZWwgZGF0YVwiO1xuICAgICAgICB9XG4gICAgICAgIGlmKHBpeGVsRGF0YUVsZW1lbnQuYmFzaWNPZmZzZXRUYWJsZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBcImRpY29tUGFyc2VyLnJlYWRFbmNhcHN1bGF0ZWRQaXhlbERhdGE6IHBhcmFtZXRlciAnZWxlbWVudCcgcmVmZXJzIHRvIHBpeGVsIGRhdGEgZWxlbWVudCB0aGF0IGRvZXMgbm90IGhhdmUgZW5jYXBzdWxhdGVkIHBpeGVsIGRhdGFcIjtcbiAgICAgICAgfVxuICAgICAgICBpZihwaXhlbERhdGFFbGVtZW50LmZyYWdtZW50cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBcImRpY29tUGFyc2VyLnJlYWRFbmNhcHN1bGF0ZWRQaXhlbERhdGE6IHBhcmFtZXRlciAnZWxlbWVudCcgcmVmZXJzIHRvIHBpeGVsIGRhdGEgZWxlbWVudCB0aGF0IGRvZXMgbm90IGhhdmUgZW5jYXBzdWxhdGVkIHBpeGVsIGRhdGFcIjtcbiAgICAgICAgfVxuICAgICAgICBpZihmcmFtZSA8IDApIHtcbiAgICAgICAgICAgIHRocm93IFwiZGljb21QYXJzZXIucmVhZEVuY2Fwc3VsYXRlZFBpeGVsRGF0YTogcGFyYW1ldGVyICdmcmFtZScgbXVzdCBiZSA+PSAwXCI7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB0aGUgYmFzaWMgb2Zmc2V0IHRhYmxlIGlzIG5vdCBlbXB0eSwgd2UgY2FuIGV4dHJhY3QgdGhlIGZyYW1lXG4gICAgICAgIGlmKHBpeGVsRGF0YUVsZW1lbnQuYmFzaWNPZmZzZXRUYWJsZS5sZW5ndGggIT09IDApXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiBkaWNvbVBhcnNlci5yZWFkRW5jYXBzdWxhdGVkSW1hZ2VGcmFtZShkYXRhU2V0LCBwaXhlbERhdGFFbGVtZW50LCBmcmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICAvLyBObyBiYXNpYyBvZmZzZXQgdGFibGUsIGFzc3VtZSBhbGwgZnJhZ21lbnRzIGFyZSBmb3Igb25lIGZyYW1lIC0gTk9URSB0aGF0IHRoaXMgaXMgTk9UIGEgdmFsaWRcbiAgICAgICAgICAgIC8vIGFzc3VtcHRpb24gYnV0IGlzIHRoZSBvcmlnaW5hbCBiZWhhdmlvciBzbyB3ZSBhcmUga2VlcGluZyBpdCBmb3Igbm93XG4gICAgICAgICAgICByZXR1cm4gZGljb21QYXJzZXIucmVhZEVuY2Fwc3VsYXRlZFBpeGVsRGF0YUZyb21GcmFnbWVudHMoZGF0YVNldCwgcGl4ZWxEYXRhRWxlbWVudCwgMCwgcGl4ZWxEYXRhRWxlbWVudC5mcmFnbWVudHMubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gZGljb21QYXJzZXI7XG59KGRpY29tUGFyc2VyKSk7XG5cbi8qKlxuICpcbiAqIEludGVybmFsIGhlbHBlciBmdW5jdGlvbiB0byBhbGxvY2F0ZSBuZXcgYnl0ZUFycmF5IGJ1ZmZlcnNcbiAqL1xudmFyIGRpY29tUGFyc2VyID0gKGZ1bmN0aW9uIChkaWNvbVBhcnNlcilcbntcbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgaWYoZGljb21QYXJzZXIgPT09IHVuZGVmaW5lZClcbiAge1xuICAgIGRpY29tUGFyc2VyID0ge307XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBieXRlQXJyYXkgb2YgdGhlIHNhbWUgdHlwZSAoVWludDhBcnJheSBvciBCdWZmZXIpIG9mIHRoZSBzcGVjaWZpZWQgbGVuZ3RoLlxuICAgKiBAcGFyYW0gYnl0ZUFycmF5IHRoZSB1bmRlcmx5aW5nIGJ5dGVBcnJheSAoZWl0aGVyIFVpbnQ4QXJyYXkgb3IgQnVmZmVyKVxuICAgKiBAcGFyYW0gbGVuZ3RoIG51bWJlciBvZiBieXRlcyBvZiB0aGUgQnl0ZSBBcnJheVxuICAgKiBAcmV0dXJucyB7b2JqZWN0fSBVaW50OEFycmF5IG9yIEJ1ZmZlciBkZXBlbmRpbmcgb24gdGhlIHR5cGUgb2YgYnl0ZUFycmF5XG4gICAqL1xuICBkaWNvbVBhcnNlci5hbGxvYyA9IGZ1bmN0aW9uKGJ5dGVBcnJheSwgbGVuZ3RoKSB7XG4gICAgaWYgKHR5cGVvZiBCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIGJ5dGVBcnJheSBpbnN0YW5jZW9mIEJ1ZmZlcikge1xuICAgICAgcmV0dXJuIEJ1ZmZlci5hbGxvYyhsZW5ndGgpO1xuICAgIH1cbiAgICBlbHNlIGlmKGJ5dGVBcnJheSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShsZW5ndGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyAnZGljb21QYXJzZXIuYWxsb2M6IHVua25vd24gdHlwZSBmb3IgYnl0ZUFycmF5JztcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIGRpY29tUGFyc2VyO1xufShkaWNvbVBhcnNlcikpO1xuLyoqXG4gKiBJbnRlcm5hbCBoZWxwZXIgZnVuY3Rpb25zIGZvciBwYXJzaW5nIGRpZmZlcmVudCB0eXBlcyBmcm9tIGEgYmlnLWVuZGlhbiBieXRlIGFycmF5XG4gKi9cblxudmFyIGRpY29tUGFyc2VyID0gKGZ1bmN0aW9uIChkaWNvbVBhcnNlcilcbntcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGlmKGRpY29tUGFyc2VyID09PSB1bmRlZmluZWQpXG4gICAge1xuICAgICAgICBkaWNvbVBhcnNlciA9IHt9O1xuICAgIH1cblxuICAgIGRpY29tUGFyc2VyLmJpZ0VuZGlhbkJ5dGVBcnJheVBhcnNlciA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqXG4gICAgICAgICAqIFBhcnNlcyBhbiB1bnNpZ25lZCBpbnQgMTYgZnJvbSBhIGJpZy1lbmRpYW4gYnl0ZSBhcnJheVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gYnl0ZUFycmF5IHRoZSBieXRlIGFycmF5IHRvIHJlYWQgZnJvbVxuICAgICAgICAgKiBAcGFyYW0gcG9zaXRpb24gdGhlIHBvc2l0aW9uIGluIHRoZSBieXRlIGFycmF5IHRvIHJlYWQgZnJvbVxuICAgICAgICAgKiBAcmV0dXJucyB7Kn0gdGhlIHBhcnNlZCB1bnNpZ25lZCBpbnQgMTZcbiAgICAgICAgICogQHRocm93cyBlcnJvciBpZiBidWZmZXIgb3ZlcnJlYWQgd291bGQgb2NjdXJcbiAgICAgICAgICogQGFjY2VzcyBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICByZWFkVWludDE2OiBmdW5jdGlvbiAoYnl0ZUFycmF5LCBwb3NpdGlvbikge1xuICAgICAgICAgICAgaWYgKHBvc2l0aW9uIDwgMCkge1xuICAgICAgICAgICAgICAgIHRocm93ICdiaWdFbmRpYW5CeXRlQXJyYXlQYXJzZXIucmVhZFVpbnQxNjogcG9zaXRpb24gY2Fubm90IGJlIGxlc3MgdGhhbiAwJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwb3NpdGlvbiArIDIgPiBieXRlQXJyYXkubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgJ2JpZ0VuZGlhbkJ5dGVBcnJheVBhcnNlci5yZWFkVWludDE2OiBhdHRlbXB0IHRvIHJlYWQgcGFzdCBlbmQgb2YgYnVmZmVyJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAoYnl0ZUFycmF5W3Bvc2l0aW9uXSA8PCA4KSArIGJ5dGVBcnJheVtwb3NpdGlvbiArIDFdO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKlxuICAgICAgICAgKiBQYXJzZXMgYSBzaWduZWQgaW50IDE2IGZyb20gYSBiaWctZW5kaWFuIGJ5dGUgYXJyYXlcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGJ5dGVBcnJheSB0aGUgYnl0ZSBhcnJheSB0byByZWFkIGZyb21cbiAgICAgICAgICogQHBhcmFtIHBvc2l0aW9uIHRoZSBwb3NpdGlvbiBpbiB0aGUgYnl0ZSBhcnJheSB0byByZWFkIGZyb21cbiAgICAgICAgICogQHJldHVybnMgeyp9IHRoZSBwYXJzZWQgc2lnbmVkIGludCAxNlxuICAgICAgICAgKiBAdGhyb3dzIGVycm9yIGlmIGJ1ZmZlciBvdmVycmVhZCB3b3VsZCBvY2N1clxuICAgICAgICAgKiBAYWNjZXNzIHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHJlYWRJbnQxNjogZnVuY3Rpb24gKGJ5dGVBcnJheSwgcG9zaXRpb24pIHtcbiAgICAgICAgICAgIGlmIChwb3NpdGlvbiA8IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyAnYmlnRW5kaWFuQnl0ZUFycmF5UGFyc2VyLnJlYWRJbnQxNjogcG9zaXRpb24gY2Fubm90IGJlIGxlc3MgdGhhbiAwJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwb3NpdGlvbiArIDIgPiBieXRlQXJyYXkubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgJ2JpZ0VuZGlhbkJ5dGVBcnJheVBhcnNlci5yZWFkSW50MTY6IGF0dGVtcHQgdG8gcmVhZCBwYXN0IGVuZCBvZiBidWZmZXInO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGludDE2ID0gKGJ5dGVBcnJheVtwb3NpdGlvbl0gPDwgOCkgKyBieXRlQXJyYXlbcG9zaXRpb24gKyAxXTtcbiAgICAgICAgICAgIC8vIGZpeCBzaWduXG4gICAgICAgICAgICBpZiAoaW50MTYgJiAweDgwMDApIHtcbiAgICAgICAgICAgICAgICBpbnQxNiA9IGludDE2IC0gMHhGRkZGIC0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpbnQxNjtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUGFyc2VzIGFuIHVuc2lnbmVkIGludCAzMiBmcm9tIGEgYmlnLWVuZGlhbiBieXRlIGFycmF5XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBieXRlQXJyYXkgdGhlIGJ5dGUgYXJyYXkgdG8gcmVhZCBmcm9tXG4gICAgICAgICAqIEBwYXJhbSBwb3NpdGlvbiB0aGUgcG9zaXRpb24gaW4gdGhlIGJ5dGUgYXJyYXkgdG8gcmVhZCBmcm9tXG4gICAgICAgICAqIEByZXR1cm5zIHsqfSB0aGUgcGFyc2VkIHVuc2lnbmVkIGludCAzMlxuICAgICAgICAgKiBAdGhyb3dzIGVycm9yIGlmIGJ1ZmZlciBvdmVycmVhZCB3b3VsZCBvY2N1clxuICAgICAgICAgKiBAYWNjZXNzIHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHJlYWRVaW50MzI6IGZ1bmN0aW9uIChieXRlQXJyYXksIHBvc2l0aW9uKSB7XG4gICAgICAgICAgICBpZiAocG9zaXRpb24gPCAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgJ2JpZ0VuZGlhbkJ5dGVBcnJheVBhcnNlci5yZWFkVWludDMyOiBwb3NpdGlvbiBjYW5ub3QgYmUgbGVzcyB0aGFuIDAnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocG9zaXRpb24gKyA0ID4gYnl0ZUFycmF5Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRocm93ICdiaWdFbmRpYW5CeXRlQXJyYXlQYXJzZXIucmVhZFVpbnQzMjogYXR0ZW1wdCB0byByZWFkIHBhc3QgZW5kIG9mIGJ1ZmZlcic7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciB1aW50MzIgPSAoMjU2ICogKDI1NiAqICgyNTYgKiBieXRlQXJyYXlbcG9zaXRpb25dICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBieXRlQXJyYXlbcG9zaXRpb24gKyAxXSkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ5dGVBcnJheVtwb3NpdGlvbiArIDJdKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnl0ZUFycmF5W3Bvc2l0aW9uICsgM10pO1xuXG4gICAgICAgICAgICByZXR1cm4gdWludDMyO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQYXJzZXMgYSBzaWduZWQgaW50IDMyIGZyb20gYSBiaWctZW5kaWFuIGJ5dGUgYXJyYXlcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGJ5dGVBcnJheSB0aGUgYnl0ZSBhcnJheSB0byByZWFkIGZyb21cbiAgICAgICAgICogQHBhcmFtIHBvc2l0aW9uIHRoZSBwb3NpdGlvbiBpbiB0aGUgYnl0ZSBhcnJheSB0byByZWFkIGZyb21cbiAgICAgICAgICogQHJldHVybnMgeyp9IHRoZSBwYXJzZWQgc2lnbmVkIGludCAzMlxuICAgICAgICAgKiBAdGhyb3dzIGVycm9yIGlmIGJ1ZmZlciBvdmVycmVhZCB3b3VsZCBvY2N1clxuICAgICAgICAgKiBAYWNjZXNzIHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHJlYWRJbnQzMjogZnVuY3Rpb24gKGJ5dGVBcnJheSwgcG9zaXRpb24pIHtcbiAgICAgICAgICAgIGlmIChwb3NpdGlvbiA8IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyAnYmlnRW5kaWFuQnl0ZUFycmF5UGFyc2VyLnJlYWRJbnQzMjogcG9zaXRpb24gY2Fubm90IGJlIGxlc3MgdGhhbiAwJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHBvc2l0aW9uICsgNCA+IGJ5dGVBcnJheS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyAnYmlnRW5kaWFuQnl0ZUFycmF5UGFyc2VyLnJlYWRJbnQzMjogYXR0ZW1wdCB0byByZWFkIHBhc3QgZW5kIG9mIGJ1ZmZlcic7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBpbnQzMiA9ICgoYnl0ZUFycmF5W3Bvc2l0aW9uXSA8PCAyNCkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgIChieXRlQXJyYXlbcG9zaXRpb24gKyAxXSA8PCAxNikgK1xuICAgICAgICAgICAgICAgICAgICAgICAgIChieXRlQXJyYXlbcG9zaXRpb24gKyAyXSA8PCA4KSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGJ5dGVBcnJheVtwb3NpdGlvbiArIDNdKTtcblxuICAgICAgICAgICAgcmV0dXJuIGludDMyO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQYXJzZXMgMzItYml0IGZsb2F0IGZyb20gYSBiaWctZW5kaWFuIGJ5dGUgYXJyYXlcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGJ5dGVBcnJheSB0aGUgYnl0ZSBhcnJheSB0byByZWFkIGZyb21cbiAgICAgICAgICogQHBhcmFtIHBvc2l0aW9uIHRoZSBwb3NpdGlvbiBpbiB0aGUgYnl0ZSBhcnJheSB0byByZWFkIGZyb21cbiAgICAgICAgICogQHJldHVybnMgeyp9IHRoZSBwYXJzZWQgMzItYml0IGZsb2F0XG4gICAgICAgICAqIEB0aHJvd3MgZXJyb3IgaWYgYnVmZmVyIG92ZXJyZWFkIHdvdWxkIG9jY3VyXG4gICAgICAgICAqIEBhY2Nlc3MgcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgcmVhZEZsb2F0OiBmdW5jdGlvbiAoYnl0ZUFycmF5LCBwb3NpdGlvbikge1xuICAgICAgICAgICAgaWYgKHBvc2l0aW9uIDwgMCkge1xuICAgICAgICAgICAgICAgIHRocm93ICdiaWdFbmRpYW5CeXRlQXJyYXlQYXJzZXIucmVhZEZsb2F0OiBwb3NpdGlvbiBjYW5ub3QgYmUgbGVzcyB0aGFuIDAnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocG9zaXRpb24gKyA0ID4gYnl0ZUFycmF5Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRocm93ICdiaWdFbmRpYW5CeXRlQXJyYXlQYXJzZXIucmVhZEZsb2F0OiBhdHRlbXB0IHRvIHJlYWQgcGFzdCBlbmQgb2YgYnVmZmVyJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSSBhbSBzdXJlIHRoZXJlIGlzIGEgYmV0dGVyIHdheSB0aGFuIHRoaXMgYnV0IHRoaXMgc2hvdWxkIGJlIHNhZmVcbiAgICAgICAgICAgIHZhciBieXRlQXJyYXlGb3JQYXJzaW5nRmxvYXQgPSBuZXcgVWludDhBcnJheSg0KTtcbiAgICAgICAgICAgIGJ5dGVBcnJheUZvclBhcnNpbmdGbG9hdFszXSA9IGJ5dGVBcnJheVtwb3NpdGlvbl07XG4gICAgICAgICAgICBieXRlQXJyYXlGb3JQYXJzaW5nRmxvYXRbMl0gPSBieXRlQXJyYXlbcG9zaXRpb24gKyAxXTtcbiAgICAgICAgICAgIGJ5dGVBcnJheUZvclBhcnNpbmdGbG9hdFsxXSA9IGJ5dGVBcnJheVtwb3NpdGlvbiArIDJdO1xuICAgICAgICAgICAgYnl0ZUFycmF5Rm9yUGFyc2luZ0Zsb2F0WzBdID0gYnl0ZUFycmF5W3Bvc2l0aW9uICsgM107XG4gICAgICAgICAgICB2YXIgZmxvYXRBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoYnl0ZUFycmF5Rm9yUGFyc2luZ0Zsb2F0LmJ1ZmZlcik7XG4gICAgICAgICAgICByZXR1cm4gZmxvYXRBcnJheVswXTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUGFyc2VzIDY0LWJpdCBmbG9hdCBmcm9tIGEgYmlnLWVuZGlhbiBieXRlIGFycmF5XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBieXRlQXJyYXkgdGhlIGJ5dGUgYXJyYXkgdG8gcmVhZCBmcm9tXG4gICAgICAgICAqIEBwYXJhbSBwb3NpdGlvbiB0aGUgcG9zaXRpb24gaW4gdGhlIGJ5dGUgYXJyYXkgdG8gcmVhZCBmcm9tXG4gICAgICAgICAqIEByZXR1cm5zIHsqfSB0aGUgcGFyc2VkIDY0LWJpdCBmbG9hdFxuICAgICAgICAgKiBAdGhyb3dzIGVycm9yIGlmIGJ1ZmZlciBvdmVycmVhZCB3b3VsZCBvY2N1clxuICAgICAgICAgKiBAYWNjZXNzIHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHJlYWREb3VibGU6IGZ1bmN0aW9uIChieXRlQXJyYXksIHBvc2l0aW9uKSB7XG4gICAgICAgICAgICBpZiAocG9zaXRpb24gPCAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgJ2JpZ0VuZGlhbkJ5dGVBcnJheVBhcnNlci5yZWFkRG91YmxlOiBwb3NpdGlvbiBjYW5ub3QgYmUgbGVzcyB0aGFuIDAnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocG9zaXRpb24gKyA4ID4gYnl0ZUFycmF5Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRocm93ICdiaWdFbmRpYW5CeXRlQXJyYXlQYXJzZXIucmVhZERvdWJsZTogYXR0ZW1wdCB0byByZWFkIHBhc3QgZW5kIG9mIGJ1ZmZlcic7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEkgYW0gc3VyZSB0aGVyZSBpcyBhIGJldHRlciB3YXkgdGhhbiB0aGlzIGJ1dCB0aGlzIHNob3VsZCBiZSBzYWZlXG4gICAgICAgICAgICB2YXIgYnl0ZUFycmF5Rm9yUGFyc2luZ0Zsb2F0ID0gbmV3IFVpbnQ4QXJyYXkoOCk7XG4gICAgICAgICAgICBieXRlQXJyYXlGb3JQYXJzaW5nRmxvYXRbN10gPSBieXRlQXJyYXlbcG9zaXRpb25dO1xuICAgICAgICAgICAgYnl0ZUFycmF5Rm9yUGFyc2luZ0Zsb2F0WzZdID0gYnl0ZUFycmF5W3Bvc2l0aW9uICsgMV07XG4gICAgICAgICAgICBieXRlQXJyYXlGb3JQYXJzaW5nRmxvYXRbNV0gPSBieXRlQXJyYXlbcG9zaXRpb24gKyAyXTtcbiAgICAgICAgICAgIGJ5dGVBcnJheUZvclBhcnNpbmdGbG9hdFs0XSA9IGJ5dGVBcnJheVtwb3NpdGlvbiArIDNdO1xuICAgICAgICAgICAgYnl0ZUFycmF5Rm9yUGFyc2luZ0Zsb2F0WzNdID0gYnl0ZUFycmF5W3Bvc2l0aW9uICsgNF07XG4gICAgICAgICAgICBieXRlQXJyYXlGb3JQYXJzaW5nRmxvYXRbMl0gPSBieXRlQXJyYXlbcG9zaXRpb24gKyA1XTtcbiAgICAgICAgICAgIGJ5dGVBcnJheUZvclBhcnNpbmdGbG9hdFsxXSA9IGJ5dGVBcnJheVtwb3NpdGlvbiArIDZdO1xuICAgICAgICAgICAgYnl0ZUFycmF5Rm9yUGFyc2luZ0Zsb2F0WzBdID0gYnl0ZUFycmF5W3Bvc2l0aW9uICsgN107XG4gICAgICAgICAgICB2YXIgZmxvYXRBcnJheSA9IG5ldyBGbG9hdDY0QXJyYXkoYnl0ZUFycmF5Rm9yUGFyc2luZ0Zsb2F0LmJ1ZmZlcik7XG4gICAgICAgICAgICByZXR1cm4gZmxvYXRBcnJheVswXTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gZGljb21QYXJzZXI7XG59KGRpY29tUGFyc2VyKSk7XG4vKipcbiAqIEludGVybmFsIGhlbHBlciBmdW5jdGlvbnMgY29tbW9uIHRvIHBhcnNpbmcgYnl0ZSBhcnJheXMgb2YgYW55IHR5cGVcbiAqL1xuXG52YXIgZGljb21QYXJzZXIgPSAoZnVuY3Rpb24gKGRpY29tUGFyc2VyKVxue1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgaWYoZGljb21QYXJzZXIgPT09IHVuZGVmaW5lZClcbiAgICB7XG4gICAgICAgIGRpY29tUGFyc2VyID0ge307XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVhZHMgYSBzdHJpbmcgb2YgOC1iaXQgY2hhcmFjdGVycyBmcm9tIGFuIGFycmF5IG9mIGJ5dGVzIGFuZCBhZHZhbmNlc1xuICAgICAqIHRoZSBwb3NpdGlvbiBieSBsZW5ndGggYnl0ZXMuICBBIG51bGwgdGVybWluYXRvciB3aWxsIGVuZCB0aGUgc3RyaW5nXG4gICAgICogYnV0IHdpbGwgbm90IGVmZmVjdCBhZHZhbmNlbWVudCBvZiB0aGUgcG9zaXRpb24uICBUcmFpbGluZyBhbmQgbGVhZGluZ1xuICAgICAqIHNwYWNlcyBhcmUgcHJlc2VydmVkIChub3QgdHJpbW1lZClcbiAgICAgKiBAcGFyYW0gYnl0ZUFycmF5IHRoZSBieXRlQXJyYXkgdG8gcmVhZCBmcm9tXG4gICAgICogQHBhcmFtIHBvc2l0aW9uIHRoZSBwb3NpdGlvbiBpbiB0aGUgYnl0ZSBhcnJheSB0byByZWFkIGZyb21cbiAgICAgKiBAcGFyYW0gbGVuZ3RoIHRoZSBtYXhpbXVtIG51bWJlciBvZiBieXRlcyB0byBwYXJzZVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IHRoZSBwYXJzZWQgc3RyaW5nXG4gICAgICogQHRocm93cyBlcnJvciBpZiBidWZmZXIgb3ZlcnJlYWQgd291bGQgb2NjdXJcbiAgICAgKiBAYWNjZXNzIHByaXZhdGVcbiAgICAgKi9cbiAgICBkaWNvbVBhcnNlci5yZWFkRml4ZWRTdHJpbmcgPSBmdW5jdGlvbihieXRlQXJyYXksIHBvc2l0aW9uLCBsZW5ndGgpXG4gICAge1xuICAgICAgICBpZihsZW5ndGggPCAwKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aHJvdyAnZGljb21QYXJzZXIucmVhZEZpeGVkU3RyaW5nIC0gbGVuZ3RoIGNhbm5vdCBiZSBsZXNzIHRoYW4gMCc7XG4gICAgICAgIH1cblxuICAgICAgICBpZihwb3NpdGlvbiArIGxlbmd0aCA+IGJ5dGVBcnJheS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93ICdkaWNvbVBhcnNlci5yZWFkRml4ZWRTdHJpbmc6IGF0dGVtcHQgdG8gcmVhZCBwYXN0IGVuZCBvZiBidWZmZXInO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlc3VsdCA9IFwiXCI7XG4gICAgICAgIHZhciBieXRlO1xuICAgICAgICBmb3IodmFyIGk9MDsgaSA8IGxlbmd0aDsgaSsrKVxuICAgICAgICB7XG4gICAgICAgICAgICBieXRlID0gYnl0ZUFycmF5W3Bvc2l0aW9uICsgaV07XG4gICAgICAgICAgICBpZihieXRlID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcG9zaXRpb24gKz0gIGxlbmd0aDtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG5cblxuICAgIHJldHVybiBkaWNvbVBhcnNlcjtcbn0oZGljb21QYXJzZXIpKTtcbi8qKlxuICpcbiAqIEludGVybmFsIGhlbHBlciBjbGFzcyB0byBhc3Npc3Qgd2l0aCBwYXJzaW5nLiBTdXBwb3J0cyByZWFkaW5nIGZyb20gYSBieXRlXG4gKiBzdHJlYW0gY29udGFpbmVkIGluIGEgVWludDhBcnJheS4gIEV4YW1wbGUgdXNhZ2U6XG4gKlxuICogIHZhciBieXRlQXJyYXkgPSBuZXcgVWludDhBcnJheSgzMik7XG4gKiAgdmFyIGJ5dGVTdHJlYW0gPSBuZXcgZGljb21QYXJzZXIuQnl0ZVN0cmVhbShkaWNvbVBhcnNlci5saXR0bGVFbmRpYW5CeXRlQXJyYXlQYXJzZXIsIGJ5dGVBcnJheSk7XG4gKlxuICogKi9cbnZhciBkaWNvbVBhcnNlciA9IChmdW5jdGlvbiAoZGljb21QYXJzZXIpXG57XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBpZihkaWNvbVBhcnNlciA9PT0gdW5kZWZpbmVkKVxuICAgIHtcbiAgICAgICAgZGljb21QYXJzZXIgPSB7fTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvciBmb3IgQnl0ZVN0cmVhbSBvYmplY3RzLlxuICAgICAqIEBwYXJhbSBieXRlQXJyYXlQYXJzZXIgYSBwYXJzZXIgZm9yIHBhcnNpbmcgdGhlIGJ5dGUgYXJyYXlcbiAgICAgKiBAcGFyYW0gYnl0ZUFycmF5IGEgVWludDhBcnJheSBjb250YWluaW5nIHRoZSBieXRlIHN0cmVhbVxuICAgICAqIEBwYXJhbSBwb3NpdGlvbiAob3B0aW9uYWwpIHRoZSBwb3NpdGlvbiB0byBzdGFydCByZWFkaW5nIGZyb20uICAwIGlmIG5vdCBzcGVjaWZpZWRcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAdGhyb3dzIHdpbGwgdGhyb3cgYW4gZXJyb3IgaWYgdGhlIGJ5dGVBcnJheVBhcnNlciBwYXJhbWV0ZXIgaXMgbm90IHByZXNlbnRcbiAgICAgKiBAdGhyb3dzIHdpbGwgdGhyb3cgYW4gZXJyb3IgaWYgdGhlIGJ5dGVBcnJheSBwYXJhbWV0ZXIgaXMgbm90IHByZXNlbnQgb3IgaW52YWxpZFxuICAgICAqIEB0aHJvd3Mgd2lsbCB0aHJvdyBhbiBlcnJvciBpZiB0aGUgcG9zaXRpb24gcGFyYW1ldGVyIGlzIG5vdCBpbnNpZGUgdGhlIGJ5dGUgYXJyYXlcbiAgICAgKi9cbiAgICBkaWNvbVBhcnNlci5CeXRlU3RyZWFtID0gZnVuY3Rpb24oYnl0ZUFycmF5UGFyc2VyLCBieXRlQXJyYXksIHBvc2l0aW9uKSB7XG4gICAgICAgIGlmKGJ5dGVBcnJheVBhcnNlciA9PT0gdW5kZWZpbmVkKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aHJvdyBcImRpY29tUGFyc2VyLkJ5dGVTdHJlYW06IG1pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyICdieXRlQXJyYXlQYXJzZXInXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYoYnl0ZUFycmF5ID09PSB1bmRlZmluZWQpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRocm93IFwiZGljb21QYXJzZXIuQnl0ZVN0cmVhbTogbWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXIgJ2J5dGVBcnJheSdcIjtcbiAgICAgICAgfVxuICAgICAgICBpZigoYnl0ZUFycmF5IGluc3RhbmNlb2YgVWludDhBcnJheSkgPT09IGZhbHNlICYmXG4gICAgICAgICAgKGJ5dGVBcnJheSBpbnN0YW5jZW9mIEJ1ZmZlcikgPT09IGZhbHNlICkge1xuICAgICAgICAgICAgdGhyb3cgJ2RpY29tUGFyc2VyLkJ5dGVTdHJlYW06IHBhcmFtZXRlciBieXRlQXJyYXkgaXMgbm90IG9mIHR5cGUgVWludDhBcnJheSBvciBCdWZmZXInO1xuICAgICAgICB9XG4gICAgICAgIGlmKHBvc2l0aW9uIDwgMClcbiAgICAgICAge1xuICAgICAgICAgICAgdGhyb3cgXCJkaWNvbVBhcnNlci5CeXRlU3RyZWFtOiBwYXJhbWV0ZXIgJ3Bvc2l0aW9uJyBjYW5ub3QgYmUgbGVzcyB0aGFuIDBcIjtcbiAgICAgICAgfVxuICAgICAgICBpZihwb3NpdGlvbiA+PSBieXRlQXJyYXkubGVuZ3RoKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aHJvdyBcImRpY29tUGFyc2VyLkJ5dGVTdHJlYW06IHBhcmFtZXRlciAncG9zaXRpb24nIGNhbm5vdCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gJ2J5dGVBcnJheScgbGVuZ3RoXCI7XG5cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmJ5dGVBcnJheVBhcnNlciA9IGJ5dGVBcnJheVBhcnNlcjtcbiAgICAgICAgdGhpcy5ieXRlQXJyYXkgPSBieXRlQXJyYXk7XG4gICAgICAgIHRoaXMucG9zaXRpb24gPSBwb3NpdGlvbiA/IHBvc2l0aW9uIDogMDtcbiAgICAgICAgdGhpcy53YXJuaW5ncyA9IFtdOyAvLyBhcnJheSBvZiBzdHJpbmcgd2FybmluZ3MgZW5jb3VudGVyZWQgd2hpbGUgcGFyc2luZ1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTYWZlbHkgc2Vla3MgdGhyb3VnaCB0aGUgYnl0ZSBzdHJlYW0uICBXaWxsIHRocm93IGFuIGV4Y2VwdGlvbiBpZiBhbiBhdHRlbXB0XG4gICAgICogaXMgbWFkZSB0byBzZWVrIG91dHNpZGUgb2YgdGhlIGJ5dGUgYXJyYXkuXG4gICAgICogQHBhcmFtIG9mZnNldCB0aGUgbnVtYmVyIG9mIGJ5dGVzIHRvIGFkZCB0byB0aGUgcG9zaXRpb25cbiAgICAgKiBAdGhyb3dzIGVycm9yIGlmIHNlZWsgd291bGQgY2F1c2UgcG9zaXRpb24gdG8gYmUgb3V0c2lkZSBvZiB0aGUgYnl0ZUFycmF5XG4gICAgICovXG4gICAgZGljb21QYXJzZXIuQnl0ZVN0cmVhbS5wcm90b3R5cGUuc2VlayA9IGZ1bmN0aW9uKG9mZnNldClcbiAgICB7XG4gICAgICAgIGlmKHRoaXMucG9zaXRpb24gKyBvZmZzZXQgPCAwKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aHJvdyBcImRpY29tUGFyc2VyLkJ5dGVTdHJlYW0ucHJvdG90eXBlLnNlZWs6IGNhbm5vdCBzZWVrIHRvIHBvc2l0aW9uIDwgMFwiO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucG9zaXRpb24gKz0gb2Zmc2V0O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbmV3IEJ5dGVTdHJlYW0gb2JqZWN0IGZyb20gdGhlIGN1cnJlbnQgcG9zaXRpb24gYW5kIG9mIHRoZSByZXF1ZXN0ZWQgbnVtYmVyIG9mIGJ5dGVzXG4gICAgICogQHBhcmFtIG51bUJ5dGVzIHRoZSBsZW5ndGggb2YgdGhlIGJ5dGUgYXJyYXkgZm9yIHRoZSBCeXRlU3RyZWFtIHRvIGNvbnRhaW5cbiAgICAgKiBAcmV0dXJucyB7ZGljb21QYXJzZXIuQnl0ZVN0cmVhbX1cbiAgICAgKiBAdGhyb3dzIGVycm9yIGlmIGJ1ZmZlciBvdmVycmVhZCB3b3VsZCBvY2N1clxuICAgICAqL1xuICAgIGRpY29tUGFyc2VyLkJ5dGVTdHJlYW0ucHJvdG90eXBlLnJlYWRCeXRlU3RyZWFtID0gZnVuY3Rpb24obnVtQnl0ZXMpXG4gICAge1xuICAgICAgICBpZih0aGlzLnBvc2l0aW9uICsgbnVtQnl0ZXMgPiB0aGlzLmJ5dGVBcnJheS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93ICdkaWNvbVBhcnNlci5CeXRlU3RyZWFtLnByb3RvdHlwZS5yZWFkQnl0ZVN0cmVhbTogcmVhZEJ5dGVTdHJlYW0gLSBidWZmZXIgb3ZlcnJlYWQnO1xuICAgICAgICB9XG4gICAgICAgIHZhciBieXRlQXJyYXlWaWV3ID0gZGljb21QYXJzZXIuc2hhcmVkQ29weSh0aGlzLmJ5dGVBcnJheSwgdGhpcy5wb3NpdGlvbiwgbnVtQnl0ZXMpO1xuICAgICAgICB0aGlzLnBvc2l0aW9uICs9IG51bUJ5dGVzO1xuICAgICAgICByZXR1cm4gbmV3IGRpY29tUGFyc2VyLkJ5dGVTdHJlYW0odGhpcy5ieXRlQXJyYXlQYXJzZXIsIGJ5dGVBcnJheVZpZXcpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFBhcnNlcyBhbiB1bnNpZ25lZCBpbnQgMTYgZnJvbSBhIGJ5dGUgYXJyYXkgYW5kIGFkdmFuY2VzXG4gICAgICogdGhlIHBvc2l0aW9uIGJ5IDIgYnl0ZXNcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHsqfSB0aGUgcGFyc2VkIHVuc2lnbmVkIGludCAxNlxuICAgICAqIEB0aHJvd3MgZXJyb3IgaWYgYnVmZmVyIG92ZXJyZWFkIHdvdWxkIG9jY3VyXG4gICAgICovXG4gICAgZGljb21QYXJzZXIuQnl0ZVN0cmVhbS5wcm90b3R5cGUucmVhZFVpbnQxNiA9IGZ1bmN0aW9uKClcbiAgICB7XG4gICAgICAgIHZhciByZXN1bHQgPSB0aGlzLmJ5dGVBcnJheVBhcnNlci5yZWFkVWludDE2KHRoaXMuYnl0ZUFycmF5LCB0aGlzLnBvc2l0aW9uKTtcbiAgICAgICAgdGhpcy5wb3NpdGlvbiArPSAyO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBQYXJzZXMgYW4gdW5zaWduZWQgaW50IDMyIGZyb20gYSBieXRlIGFycmF5IGFuZCBhZHZhbmNlc1xuICAgICAqIHRoZSBwb3NpdGlvbiBieSAyIGJ5dGVzXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Kn0gdGhlIHBhcnNlIHVuc2lnbmVkIGludCAzMlxuICAgICAqIEB0aHJvd3MgZXJyb3IgaWYgYnVmZmVyIG92ZXJyZWFkIHdvdWxkIG9jY3VyXG4gICAgICovXG4gICAgZGljb21QYXJzZXIuQnl0ZVN0cmVhbS5wcm90b3R5cGUucmVhZFVpbnQzMiA9IGZ1bmN0aW9uKClcbiAgICB7XG4gICAgICAgIHZhciByZXN1bHQgPSB0aGlzLmJ5dGVBcnJheVBhcnNlci5yZWFkVWludDMyKHRoaXMuYnl0ZUFycmF5LCB0aGlzLnBvc2l0aW9uKTtcbiAgICAgICAgdGhpcy5wb3NpdGlvbiArPSA0O1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZWFkcyBhIHN0cmluZyBvZiA4LWJpdCBjaGFyYWN0ZXJzIGZyb20gYW4gYXJyYXkgb2YgYnl0ZXMgYW5kIGFkdmFuY2VzXG4gICAgICogdGhlIHBvc2l0aW9uIGJ5IGxlbmd0aCBieXRlcy4gIEEgbnVsbCB0ZXJtaW5hdG9yIHdpbGwgZW5kIHRoZSBzdHJpbmdcbiAgICAgKiBidXQgd2lsbCBub3QgZWZmZWN0IGFkdmFuY2VtZW50IG9mIHRoZSBwb3NpdGlvbi5cbiAgICAgKiBAcGFyYW0gbGVuZ3RoIHRoZSBtYXhpbXVtIG51bWJlciBvZiBieXRlcyB0byBwYXJzZVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IHRoZSBwYXJzZWQgc3RyaW5nXG4gICAgICogQHRocm93cyBlcnJvciBpZiBidWZmZXIgb3ZlcnJlYWQgd291bGQgb2NjdXJcbiAgICAgKi9cbiAgICBkaWNvbVBhcnNlci5CeXRlU3RyZWFtLnByb3RvdHlwZS5yZWFkRml4ZWRTdHJpbmcgPSBmdW5jdGlvbihsZW5ndGgpXG4gICAge1xuICAgICAgICB2YXIgcmVzdWx0ID0gZGljb21QYXJzZXIucmVhZEZpeGVkU3RyaW5nKHRoaXMuYnl0ZUFycmF5LCB0aGlzLnBvc2l0aW9uLCBsZW5ndGgpO1xuICAgICAgICB0aGlzLnBvc2l0aW9uICs9IGxlbmd0aDtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgcmV0dXJuIGRpY29tUGFyc2VyO1xufShkaWNvbVBhcnNlcikpO1xuLyoqXG4gKlxuICogVGhlIERhdGFTZXQgY2xhc3MgZW5jYXBzdWxhdGVzIGEgY29sbGVjdGlvbiBvZiBESUNPTSBFbGVtZW50cyBhbmQgcHJvdmlkZXMgdmFyaW91cyBmdW5jdGlvbnNcbiAqIHRvIGFjY2VzcyB0aGUgZGF0YSBpbiB0aG9zZSBlbGVtZW50c1xuICpcbiAqIFJ1bGVzIGZvciBoYW5kbGluZyBwYWRkZWQgc3BhY2VzOlxuICogRFMgPSBTdHJpcCBsZWFkaW5nIGFuZCB0cmFpbGluZyBzcGFjZXNcbiAqIERUID0gU3RyaXAgdHJhaWxpbmcgc3BhY2VzXG4gKiBJUyA9IFN0cmlwIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHNwYWNlc1xuICogUE4gPSBTdHJpcCB0cmFpbGluZyBzcGFjZXNcbiAqIFRNID0gU3RyaXAgdHJhaWxpbmcgc3BhY2VzXG4gKiBBRSA9IFN0cmlwIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHNwYWNlc1xuICogQ1MgPSBTdHJpcCBsZWFkaW5nIGFuZCB0cmFpbGluZyBzcGFjZXNcbiAqIFNIID0gU3RyaXAgbGVhZGluZyBhbmQgdHJhaWxpbmcgc3BhY2VzXG4gKiBMTyA9IFN0cmlwIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHNwYWNlc1xuICogTFQgPSBTdHJpcCB0cmFpbGluZyBzcGFjZXNcbiAqIFNUID0gU3RyaXAgdHJhaWxpbmcgc3BhY2VzXG4gKiBVVCA9IFN0cmlwIHRyYWlsaW5nIHNwYWNlc1xuICpcbiAqL1xudmFyIGRpY29tUGFyc2VyID0gKGZ1bmN0aW9uIChkaWNvbVBhcnNlcilcbntcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGlmKGRpY29tUGFyc2VyID09PSB1bmRlZmluZWQpXG4gICAge1xuICAgICAgICBkaWNvbVBhcnNlciA9IHt9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldEJ5dGVBcnJheVBhcnNlcihlbGVtZW50LCBkZWZhdWx0UGFyc2VyKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIChlbGVtZW50LnBhcnNlciAhPT0gdW5kZWZpbmVkID8gZWxlbWVudC5wYXJzZXIgOiBkZWZhdWx0UGFyc2VyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RzIGEgbmV3IERhdGFTZXQgZ2l2ZW4gYnl0ZUFycmF5IGFuZCBjb2xsZWN0aW9uIG9mIGVsZW1lbnRzXG4gICAgICogQHBhcmFtIGJ5dGVBcnJheVBhcnNlclxuICAgICAqIEBwYXJhbSBieXRlQXJyYXlcbiAgICAgKiBAcGFyYW0gZWxlbWVudHNcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKi9cbiAgICBkaWNvbVBhcnNlci5EYXRhU2V0ID0gZnVuY3Rpb24oYnl0ZUFycmF5UGFyc2VyLCBieXRlQXJyYXksIGVsZW1lbnRzKVxuICAgIHtcbiAgICAgICAgdGhpcy5ieXRlQXJyYXlQYXJzZXIgPSBieXRlQXJyYXlQYXJzZXI7XG4gICAgICAgIHRoaXMuYnl0ZUFycmF5ID0gYnl0ZUFycmF5O1xuICAgICAgICB0aGlzLmVsZW1lbnRzID0gZWxlbWVudHM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEZpbmRzIHRoZSBlbGVtZW50IGZvciB0YWcgYW5kIHJldHVybnMgYW4gdW5zaWduZWQgaW50IDE2IGlmIGl0IGV4aXN0cyBhbmQgaGFzIGRhdGFcbiAgICAgKiBAcGFyYW0gdGFnIFRoZSBESUNPTSB0YWcgaW4gdGhlIGZvcm1hdCB4R0dHR0VFRUVcbiAgICAgKiBAcGFyYW0gaW5kZXggdGhlIGluZGV4IG9mIHRoZSB2YWx1ZSBpbiBhIG11bHRpdmFsdWVkIGVsZW1lbnQuICBEZWZhdWx0IGlzIGluZGV4IDAgaWYgbm90IHN1cHBsaWVkXG4gICAgICogQHJldHVybnMgeyp9IHVuc2lnbmVkIGludCAxNiBvciB1bmRlZmluZWQgaWYgdGhlIGF0dHJpYnV0ZSBpcyBub3QgcHJlc2VudCBvciBoYXMgZGF0YSBvZiBsZW5ndGggMFxuICAgICAqL1xuICAgIGRpY29tUGFyc2VyLkRhdGFTZXQucHJvdG90eXBlLnVpbnQxNiA9IGZ1bmN0aW9uKHRhZywgaW5kZXgpXG4gICAge1xuICAgICAgICB2YXIgZWxlbWVudCA9IHRoaXMuZWxlbWVudHNbdGFnXTtcbiAgICAgICAgaW5kZXggPSAoaW5kZXggIT09IHVuZGVmaW5lZCkgPyBpbmRleCA6IDA7XG4gICAgICAgIGlmKGVsZW1lbnQgJiYgZWxlbWVudC5sZW5ndGggIT09IDApXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRCeXRlQXJyYXlQYXJzZXIoZWxlbWVudCwgdGhpcy5ieXRlQXJyYXlQYXJzZXIpLnJlYWRVaW50MTYodGhpcy5ieXRlQXJyYXksIGVsZW1lbnQuZGF0YU9mZnNldCArIChpbmRleCAqMikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEZpbmRzIHRoZSBlbGVtZW50IGZvciB0YWcgYW5kIHJldHVybnMgYW4gc2lnbmVkIGludCAxNiBpZiBpdCBleGlzdHMgYW5kIGhhcyBkYXRhXG4gICAgICogQHBhcmFtIHRhZyBUaGUgRElDT00gdGFnIGluIHRoZSBmb3JtYXQgeEdHR0dFRUVFXG4gICAgICogQHBhcmFtIGluZGV4IHRoZSBpbmRleCBvZiB0aGUgdmFsdWUgaW4gYSBtdWx0aXZhbHVlZCBlbGVtZW50LiAgRGVmYXVsdCBpcyBpbmRleCAwIGlmIG5vdCBzdXBwbGllZFxuICAgICAqIEByZXR1cm5zIHsqfSBzaWduZWQgaW50IDE2IG9yIHVuZGVmaW5lZCBpZiB0aGUgYXR0cmlidXRlIGlzIG5vdCBwcmVzZW50IG9yIGhhcyBkYXRhIG9mIGxlbmd0aCAwXG4gICAgICovXG4gICAgZGljb21QYXJzZXIuRGF0YVNldC5wcm90b3R5cGUuaW50MTYgPSBmdW5jdGlvbih0YWcsIGluZGV4KVxuICAgIHtcbiAgICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLmVsZW1lbnRzW3RhZ107XG4gICAgICAgIGluZGV4ID0gKGluZGV4ICE9PSB1bmRlZmluZWQpID8gaW5kZXggOiAwO1xuICAgICAgICBpZihlbGVtZW50ICYmIGVsZW1lbnQubGVuZ3RoICE9PSAwKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0Qnl0ZUFycmF5UGFyc2VyKGVsZW1lbnQsIHRoaXMuYnl0ZUFycmF5UGFyc2VyKS5yZWFkSW50MTYodGhpcy5ieXRlQXJyYXksIGVsZW1lbnQuZGF0YU9mZnNldCArIChpbmRleCAqIDIpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBGaW5kcyB0aGUgZWxlbWVudCBmb3IgdGFnIGFuZCByZXR1cm5zIGFuIHVuc2lnbmVkIGludCAzMiBpZiBpdCBleGlzdHMgYW5kIGhhcyBkYXRhXG4gICAgICogQHBhcmFtIHRhZyBUaGUgRElDT00gdGFnIGluIHRoZSBmb3JtYXQgeEdHR0dFRUVFXG4gICAgICogQHBhcmFtIGluZGV4IHRoZSBpbmRleCBvZiB0aGUgdmFsdWUgaW4gYSBtdWx0aXZhbHVlZCBlbGVtZW50LiAgRGVmYXVsdCBpcyBpbmRleCAwIGlmIG5vdCBzdXBwbGllZFxuICAgICAqIEByZXR1cm5zIHsqfSB1bnNpZ25lZCBpbnQgMzIgb3IgdW5kZWZpbmVkIGlmIHRoZSBhdHRyaWJ1dGUgaXMgbm90IHByZXNlbnQgb3IgaGFzIGRhdGEgb2YgbGVuZ3RoIDBcbiAgICAgKi9cbiAgICBkaWNvbVBhcnNlci5EYXRhU2V0LnByb3RvdHlwZS51aW50MzIgPSBmdW5jdGlvbih0YWcsIGluZGV4KVxuICAgIHtcbiAgICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLmVsZW1lbnRzW3RhZ107XG4gICAgICAgIGluZGV4ID0gKGluZGV4ICE9PSB1bmRlZmluZWQpID8gaW5kZXggOiAwO1xuICAgICAgICBpZihlbGVtZW50ICYmIGVsZW1lbnQubGVuZ3RoICE9PSAwKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0Qnl0ZUFycmF5UGFyc2VyKGVsZW1lbnQsIHRoaXMuYnl0ZUFycmF5UGFyc2VyKS5yZWFkVWludDMyKHRoaXMuYnl0ZUFycmF5LCBlbGVtZW50LmRhdGFPZmZzZXQgKyAoaW5kZXggKiA0KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRmluZHMgdGhlIGVsZW1lbnQgZm9yIHRhZyBhbmQgcmV0dXJucyBhbiBzaWduZWQgaW50IDMyIGlmIGl0IGV4aXN0cyBhbmQgaGFzIGRhdGFcbiAgICAgKiBAcGFyYW0gdGFnIFRoZSBESUNPTSB0YWcgaW4gdGhlIGZvcm1hdCB4R0dHR0VFRUVcbiAgICAgKiBAcGFyYW0gaW5kZXggdGhlIGluZGV4IG9mIHRoZSB2YWx1ZSBpbiBhIG11bHRpdmFsdWVkIGVsZW1lbnQuICBEZWZhdWx0IGlzIGluZGV4IDAgaWYgbm90IHN1cHBsaWVkXG4gICAgICogQHJldHVybnMgeyp9IHNpZ25lZCBpbnQgMzIgb3IgdW5kZWZpbmVkIGlmIHRoZSBhdHRyaWJ1dGUgaXMgbm90IHByZXNlbnQgb3IgaGFzIGRhdGEgb2YgbGVuZ3RoIDBcbiAgICAgKi9cbiAgICBkaWNvbVBhcnNlci5EYXRhU2V0LnByb3RvdHlwZS5pbnQzMiA9IGZ1bmN0aW9uKHRhZywgaW5kZXgpXG4gICAge1xuICAgICAgICB2YXIgZWxlbWVudCA9IHRoaXMuZWxlbWVudHNbdGFnXTtcbiAgICAgICAgaW5kZXggPSAoaW5kZXggIT09IHVuZGVmaW5lZCkgPyBpbmRleCA6IDA7XG4gICAgICAgIGlmKGVsZW1lbnQgJiYgZWxlbWVudC5sZW5ndGggIT09IDApXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRCeXRlQXJyYXlQYXJzZXIoZWxlbWVudCwgdGhpcy5ieXRlQXJyYXlQYXJzZXIpLnJlYWRJbnQzMih0aGlzLmJ5dGVBcnJheSwgZWxlbWVudC5kYXRhT2Zmc2V0ICsgKGluZGV4ICogNCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEZpbmRzIHRoZSBlbGVtZW50IGZvciB0YWcgYW5kIHJldHVybnMgYSAzMiBiaXQgZmxvYXRpbmcgcG9pbnQgbnVtYmVyIChWUj1GTCkgaWYgaXQgZXhpc3RzIGFuZCBoYXMgZGF0YVxuICAgICAqIEBwYXJhbSB0YWcgVGhlIERJQ09NIHRhZyBpbiB0aGUgZm9ybWF0IHhHR0dHRUVFRVxuICAgICAqIEBwYXJhbSBpbmRleCB0aGUgaW5kZXggb2YgdGhlIHZhbHVlIGluIGEgbXVsdGl2YWx1ZWQgZWxlbWVudC4gIERlZmF1bHQgaXMgaW5kZXggMCBpZiBub3Qgc3VwcGxpZWRcbiAgICAgKiBAcmV0dXJucyB7Kn0gZmxvYXQgb3IgdW5kZWZpbmVkIGlmIHRoZSBhdHRyaWJ1dGUgaXMgbm90IHByZXNlbnQgb3IgaGFzIGRhdGEgb2YgbGVuZ3RoIDBcbiAgICAgKi9cbiAgICBkaWNvbVBhcnNlci5EYXRhU2V0LnByb3RvdHlwZS5mbG9hdCA9IGZ1bmN0aW9uKHRhZywgaW5kZXgpXG4gICAge1xuICAgICAgICB2YXIgZWxlbWVudCA9IHRoaXMuZWxlbWVudHNbdGFnXTtcbiAgICAgICAgaW5kZXggPSAoaW5kZXggIT09IHVuZGVmaW5lZCkgPyBpbmRleCA6IDA7XG4gICAgICAgIGlmKGVsZW1lbnQgJiYgZWxlbWVudC5sZW5ndGggIT09IDApXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRCeXRlQXJyYXlQYXJzZXIoZWxlbWVudCwgdGhpcy5ieXRlQXJyYXlQYXJzZXIpLnJlYWRGbG9hdCh0aGlzLmJ5dGVBcnJheSwgZWxlbWVudC5kYXRhT2Zmc2V0ICsgKGluZGV4ICogNCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEZpbmRzIHRoZSBlbGVtZW50IGZvciB0YWcgYW5kIHJldHVybnMgYSA2NCBiaXQgZmxvYXRpbmcgcG9pbnQgbnVtYmVyIChWUj1GRCkgaWYgaXQgZXhpc3RzIGFuZCBoYXMgZGF0YVxuICAgICAqIEBwYXJhbSB0YWcgVGhlIERJQ09NIHRhZyBpbiB0aGUgZm9ybWF0IHhHR0dHRUVFRVxuICAgICAqIEBwYXJhbSBpbmRleCB0aGUgaW5kZXggb2YgdGhlIHZhbHVlIGluIGEgbXVsdGl2YWx1ZWQgZWxlbWVudC4gIERlZmF1bHQgaXMgaW5kZXggMCBpZiBub3Qgc3VwcGxpZWRcbiAgICAgKiBAcmV0dXJucyB7Kn0gZmxvYXQgb3IgdW5kZWZpbmVkIGlmIHRoZSBhdHRyaWJ1dGUgaXMgbm90IHByZXNlbnQgb3IgZG9lc24ndCBoYXMgZGF0YSBvZiBsZW5ndGggMFxuICAgICAqL1xuICAgIGRpY29tUGFyc2VyLkRhdGFTZXQucHJvdG90eXBlLmRvdWJsZSA9IGZ1bmN0aW9uKHRhZywgaW5kZXgpXG4gICAge1xuICAgICAgICB2YXIgZWxlbWVudCA9IHRoaXMuZWxlbWVudHNbdGFnXTtcbiAgICAgICAgaW5kZXggPSAoaW5kZXggIT09IHVuZGVmaW5lZCkgPyBpbmRleCA6IDA7XG4gICAgICAgIGlmKGVsZW1lbnQgJiYgZWxlbWVudC5sZW5ndGggIT09IDApXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRCeXRlQXJyYXlQYXJzZXIoZWxlbWVudCwgdGhpcy5ieXRlQXJyYXlQYXJzZXIpLnJlYWREb3VibGUodGhpcy5ieXRlQXJyYXksIGVsZW1lbnQuZGF0YU9mZnNldCArIChpbmRleCAqIDgpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBudW1iZXIgb2Ygc3RyaW5nIHZhbHVlcyBmb3IgdGhlIGVsZW1lbnRcbiAgICAgKiBAcGFyYW0gdGFnIFRoZSBESUNPTSB0YWcgaW4gdGhlIGZvcm1hdCB4R0dHR0VFRUVcbiAgICAgKiBAcmV0dXJucyB7Kn0gdGhlIG51bWJlciBvZiBzdHJpbmcgdmFsdWVzIG9yIHVuZGVmaW5lZCBpZiB0aGUgYXR0cmlidXRlIGlzIG5vdCBwcmVzZW50IG9yIGhhcyB6ZXJvIGxlbmd0aCBkYXRhXG4gICAgICovXG4gICAgZGljb21QYXJzZXIuRGF0YVNldC5wcm90b3R5cGUubnVtU3RyaW5nVmFsdWVzID0gZnVuY3Rpb24odGFnKVxuICAgIHtcbiAgICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLmVsZW1lbnRzW3RhZ107XG4gICAgICAgIGlmKGVsZW1lbnQgJiYgZWxlbWVudC5sZW5ndGggPiAwKVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgZml4ZWRTdHJpbmcgPSBkaWNvbVBhcnNlci5yZWFkRml4ZWRTdHJpbmcodGhpcy5ieXRlQXJyYXksIGVsZW1lbnQuZGF0YU9mZnNldCwgZWxlbWVudC5sZW5ndGgpO1xuICAgICAgICAgICAgdmFyIG51bU1hdGNoaW5nID0gZml4ZWRTdHJpbmcubWF0Y2goL1xcXFwvZyk7XG4gICAgICAgICAgICBpZihudW1NYXRjaGluZyA9PT0gbnVsbClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudW1NYXRjaGluZy5sZW5ndGggKyAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBzdHJpbmcgZm9yIHRoZSBlbGVtZW50LiAgSWYgaW5kZXggaXMgcHJvdmlkZWQsIHRoZSBlbGVtZW50IGlzIGFzc3VtZWQgdG8gYmVcbiAgICAgKiBtdWx0aS12YWx1ZWQgYW5kIHdpbGwgcmV0dXJuIHRoZSBjb21wb25lbnQgc3BlY2lmaWVkIGJ5IGluZGV4LiAgVW5kZWZpbmVkIGlzIHJldHVybmVkXG4gICAgICogaWYgdGhlcmUgaXMgbm8gY29tcG9uZW50IHdpdGggdGhlIHNwZWNpZmllZCBpbmRleCwgdGhlIGVsZW1lbnQgZG9lcyBub3QgZXhpc3Qgb3IgaXMgemVybyBsZW5ndGguXG4gICAgICpcbiAgICAgKiBVc2UgdGhpcyBmdW5jdGlvbiBmb3IgVlIgdHlwZXMgb2YgQUUsIENTLCBTSCBhbmQgTE9cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0YWcgVGhlIERJQ09NIHRhZyBpbiB0aGUgZm9ybWF0IHhHR0dHRUVFRVxuICAgICAqIEBwYXJhbSBpbmRleCB0aGUgaW5kZXggb2YgdGhlIGRlc2lyZWQgdmFsdWUgaW4gYSBtdWx0aSB2YWx1ZWQgc3RyaW5nIG9yIHVuZGVmaW5lZCBmb3IgdGhlIGVudGlyZSBzdHJpbmdcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBkaWNvbVBhcnNlci5EYXRhU2V0LnByb3RvdHlwZS5zdHJpbmcgPSBmdW5jdGlvbih0YWcsIGluZGV4KVxuICAgIHtcbiAgICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLmVsZW1lbnRzW3RhZ107XG4gICAgICAgIGlmKGVsZW1lbnQgJiYgZWxlbWVudC5sZW5ndGggPiAwKVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgZml4ZWRTdHJpbmcgPSBkaWNvbVBhcnNlci5yZWFkRml4ZWRTdHJpbmcodGhpcy5ieXRlQXJyYXksIGVsZW1lbnQuZGF0YU9mZnNldCwgZWxlbWVudC5sZW5ndGgpO1xuICAgICAgICAgICAgaWYoaW5kZXggPj0gMClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWVzID0gZml4ZWRTdHJpbmcuc3BsaXQoJ1xcXFwnKTtcbiAgICAgICAgICAgICAgICAvLyB0cmltIHRyYWlsaW5nIHNwYWNlc1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZXNbaW5kZXhdLnRyaW0oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAvLyB0cmltIHRyYWlsaW5nIHNwYWNlc1xuICAgICAgICAgICAgICAgIHJldHVybiBmaXhlZFN0cmluZy50cmltKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHN0cmluZyB3aXRoIHRoZSBsZWFkaW5nIHNwYWNlcyBwcmVzZXJ2ZWQgYW5kIHRyYWlsaW5nIHNwYWNlcyByZW1vdmVkLlxuICAgICAqXG4gICAgICogVXNlIHRoaXMgZnVuY3Rpb24gdG8gYWNjZXNzIGRhdGEgZm9yIFZScyBvZiB0eXBlIFVULCBTVCBhbmQgTFRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB0YWdcbiAgICAgKiBAcGFyYW0gaW5kZXhcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBkaWNvbVBhcnNlci5EYXRhU2V0LnByb3RvdHlwZS50ZXh0ID0gZnVuY3Rpb24odGFnLCBpbmRleClcbiAgICB7XG4gICAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5lbGVtZW50c1t0YWddO1xuICAgICAgICBpZihlbGVtZW50ICYmIGVsZW1lbnQubGVuZ3RoID4gMClcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIGZpeGVkU3RyaW5nID0gZGljb21QYXJzZXIucmVhZEZpeGVkU3RyaW5nKHRoaXMuYnl0ZUFycmF5LCBlbGVtZW50LmRhdGFPZmZzZXQsIGVsZW1lbnQubGVuZ3RoKTtcbiAgICAgICAgICAgIGlmKGluZGV4ID49IDApXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlcyA9IGZpeGVkU3RyaW5nLnNwbGl0KCdcXFxcJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlc1tpbmRleF0ucmVwbGFjZSgvICskLywgJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJldHVybiBmaXhlZFN0cmluZy5yZXBsYWNlKC8gKyQvLCAnJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUGFyc2VzIGEgc3RyaW5nIHRvIGEgZmxvYXQgZm9yIHRoZSBzcGVjaWZpZWQgaW5kZXggaW4gYSBtdWx0aS12YWx1ZWQgZWxlbWVudC4gIElmIGluZGV4IGlzIG5vdCBzcGVjaWZpZWQsXG4gICAgICogdGhlIGZpcnN0IHZhbHVlIGluIGEgbXVsdGktdmFsdWVkIFZSIHdpbGwgYmUgcGFyc2VkIGlmIHByZXNlbnQuXG4gICAgICogQHBhcmFtIHRhZyBUaGUgRElDT00gdGFnIGluIHRoZSBmb3JtYXQgeEdHR0dFRUVFXG4gICAgICogQHBhcmFtIGluZGV4IHRoZSBpbmRleCBvZiB0aGUgZGVzaXJlZCB2YWx1ZSBpbiBhIG11bHRpIHZhbHVlZCBzdHJpbmcgb3IgdW5kZWZpbmVkIGZvciB0aGUgZmlyc3QgdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7Kn0gYSBmbG9hdGluZyBwb2ludCBudW1iZXIgb3IgdW5kZWZpbmVkIGlmIG5vdCBwcmVzZW50IG9yIGRhdGEgbm90IGxvbmcgZW5vdWdoXG4gICAgICovXG4gICAgZGljb21QYXJzZXIuRGF0YVNldC5wcm90b3R5cGUuZmxvYXRTdHJpbmcgPSBmdW5jdGlvbih0YWcsIGluZGV4KVxuICAgIHtcbiAgICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLmVsZW1lbnRzW3RhZ107XG4gICAgICAgIGlmKGVsZW1lbnQgJiYgZWxlbWVudC5sZW5ndGggPiAwKVxuICAgICAgICB7XG4gICAgICAgICAgICBpbmRleCA9IChpbmRleCAhPT0gdW5kZWZpbmVkKSA/IGluZGV4IDogMDtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuc3RyaW5nKHRhZywgaW5kZXgpO1xuICAgICAgICAgICAgaWYodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUZsb2F0KHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBQYXJzZXMgYSBzdHJpbmcgdG8gYW4gaW50ZWdlciBmb3IgdGhlIHNwZWNpZmllZCBpbmRleCBpbiBhIG11bHRpLXZhbHVlZCBlbGVtZW50LiAgSWYgaW5kZXggaXMgbm90IHNwZWNpZmllZCxcbiAgICAgKiB0aGUgZmlyc3QgdmFsdWUgaW4gYSBtdWx0aS12YWx1ZWQgVlIgd2lsbCBiZSBwYXJzZWQgaWYgcHJlc2VudC5cbiAgICAgKiBAcGFyYW0gdGFnIFRoZSBESUNPTSB0YWcgaW4gdGhlIGZvcm1hdCB4R0dHR0VFRUVcbiAgICAgKiBAcGFyYW0gaW5kZXggdGhlIGluZGV4IG9mIHRoZSBkZXNpcmVkIHZhbHVlIGluIGEgbXVsdGkgdmFsdWVkIHN0cmluZyBvciB1bmRlZmluZWQgZm9yIHRoZSBmaXJzdCB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHsqfSBhbiBpbnRlZ2VyIG9yIHVuZGVmaW5lZCBpZiBub3QgcHJlc2VudCBvciBkYXRhIG5vdCBsb25nIGVub3VnaFxuICAgICAqL1xuICAgIGRpY29tUGFyc2VyLkRhdGFTZXQucHJvdG90eXBlLmludFN0cmluZyA9IGZ1bmN0aW9uKHRhZywgaW5kZXgpXG4gICAge1xuICAgICAgICB2YXIgZWxlbWVudCA9IHRoaXMuZWxlbWVudHNbdGFnXTtcbiAgICAgICAgaWYoZWxlbWVudCAmJiBlbGVtZW50Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGluZGV4ID0gKGluZGV4ICE9PSB1bmRlZmluZWQpID8gaW5kZXggOiAwO1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5zdHJpbmcodGFnLCBpbmRleCk7XG4gICAgICAgICAgICBpZih2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH07XG5cbiAgICAvL2RpY29tUGFyc2VyLkRhdGFTZXQgPSBEYXRhU2V0O1xuXG4gICAgcmV0dXJuIGRpY29tUGFyc2VyO1xufShkaWNvbVBhcnNlcikpO1xuLyoqXG4gKiBJbnRlcm5hbCBoZWxwZXIgZnVuY3Rpb25zIGZvciBwYXJzaW5nIERJQ09NIGVsZW1lbnRzXG4gKi9cblxudmFyIGRpY29tUGFyc2VyID0gKGZ1bmN0aW9uIChkaWNvbVBhcnNlcilcbntcbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgaWYoZGljb21QYXJzZXIgPT09IHVuZGVmaW5lZClcbiAge1xuICAgIGRpY29tUGFyc2VyID0ge307XG4gIH1cblxuICAvKipcbiAgICogcmVhZHMgZnJvbSB0aGUgYnl0ZSBzdHJlYW0gdW50aWwgaXQgZmluZHMgdGhlIG1hZ2ljIG51bWJlciBmb3IgdGhlIFNlcXVlbmNlIERlbGltaXRhdGlvbiBJdGVtIGl0ZW1cbiAgICogYW5kIHRoZW4gc2V0cyB0aGUgbGVuZ3RoIG9mIHRoZSBlbGVtZW50XG4gICAqIEBwYXJhbSBieXRlU3RyZWFtXG4gICAqIEBwYXJhbSBlbGVtZW50XG4gICAqL1xuICBkaWNvbVBhcnNlci5maW5kQW5kU2V0VU5FbGVtZW50TGVuZ3RoID0gZnVuY3Rpb24oYnl0ZVN0cmVhbSwgZWxlbWVudClcbiAge1xuICAgIGlmKGJ5dGVTdHJlYW0gPT09IHVuZGVmaW5lZClcbiAgICB7XG4gICAgICB0aHJvdyBcImRpY29tUGFyc2VyLmZpbmRBbmRTZXRVTkVsZW1lbnRMZW5ndGg6IG1pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyICdieXRlU3RyZWFtJ1wiO1xuICAgIH1cblxuICAgIHZhciBpdGVtRGVsaW1pdGF0aW9uSXRlbUxlbmd0aCA9IDg7IC8vIGdyb3VwLCBlbGVtZW50LCBsZW5ndGhcbiAgICB2YXIgbWF4UG9zaXRpb24gPSBieXRlU3RyZWFtLmJ5dGVBcnJheS5sZW5ndGggLSBpdGVtRGVsaW1pdGF0aW9uSXRlbUxlbmd0aDtcbiAgICB3aGlsZShieXRlU3RyZWFtLnBvc2l0aW9uIDw9IG1heFBvc2l0aW9uKVxuICAgIHtcbiAgICAgIHZhciBncm91cE51bWJlcjtcbiAgICAgIGdyb3VwTnVtYmVyID0gYnl0ZVN0cmVhbS5yZWFkVWludDE2KCk7XG4gICAgICBpZihncm91cE51bWJlciA9PT0gMHhmZmZlKVxuICAgICAge1xuICAgICAgICB2YXIgZWxlbWVudE51bWJlcjtcbiAgICAgICAgZWxlbWVudE51bWJlciA9IGJ5dGVTdHJlYW0ucmVhZFVpbnQxNigpO1xuICAgICAgICBpZihlbGVtZW50TnVtYmVyID09PSAweGUwZGQpXG4gICAgICAgIHtcbiAgICAgICAgICAvLyBOT1RFOiBJdCB3b3VsZCBiZSBiZXR0ZXIgdG8gYWxzbyBjaGVjayBmb3IgdGhlIGxlbmd0aCB0byBiZSAwIGFzIHBhcnQgb2YgdGhlIGNoZWNrIGFib3ZlXG4gICAgICAgICAgLy8gYnV0IHdlIHdpbGwganVzdCBsb2cgYSB3YXJuaW5nIGZvciBub3dcbiAgICAgICAgICB2YXIgaXRlbURlbGltaXRlckxlbmd0aDtcbiAgICAgICAgICBpdGVtRGVsaW1pdGVyTGVuZ3RoID0gYnl0ZVN0cmVhbS5yZWFkVWludDMyKCk7IC8vIHRoZSBsZW5ndGhcbiAgICAgICAgICBpZihpdGVtRGVsaW1pdGVyTGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICBieXRlU3RyZWFtLndhcm5pbmdzKCdlbmNvdW50ZXJlZCBub24gemVybyBsZW5ndGggZm9sbG93aW5nIGl0ZW0gZGVsaW1pdGVyIGF0IHBvc2l0aW9uJyArIGJ5dGVTdHJlYW0ucG9zaXRpb24gLSA0ICsgXCIgd2hpbGUgcmVhZGluZyBlbGVtZW50IG9mIHVuZGVmaW5lZCBsZW5ndGggd2l0aCB0YWcgJyArIGVsZW1lbnQudGFnXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbGVtZW50Lmxlbmd0aCA9IGJ5dGVTdHJlYW0ucG9zaXRpb24gLSBlbGVtZW50LmRhdGFPZmZzZXQ7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gTm8gaXRlbSBkZWxpbWl0YXRpb24gaXRlbSAtIHNpbGVudGx5IHNldCB0aGUgbGVuZ3RoIHRvIHRoZSBlbmQgb2YgdGhlIGJ1ZmZlciBhbmQgc2V0IHRoZSBwb3NpdGlvbiBwYXN0IHRoZSBlbmQgb2YgdGhlIGJ1ZmZlclxuICAgIGVsZW1lbnQubGVuZ3RoID0gYnl0ZVN0cmVhbS5ieXRlQXJyYXkubGVuZ3RoIC0gZWxlbWVudC5kYXRhT2Zmc2V0O1xuICAgIGJ5dGVTdHJlYW0uc2VlayhieXRlU3RyZWFtLmJ5dGVBcnJheS5sZW5ndGggLSBieXRlU3RyZWFtLnBvc2l0aW9uKTtcbiAgfTtcblxuXG4gIHJldHVybiBkaWNvbVBhcnNlcjtcbn0oZGljb21QYXJzZXIpKTtcbi8qKlxuICogSW50ZXJuYWwgaGVscGVyIGZ1bmN0aW9ucyBmb3IgcGFyc2luZyBESUNPTSBlbGVtZW50c1xuICovXG5cbnZhciBkaWNvbVBhcnNlciA9IChmdW5jdGlvbiAoZGljb21QYXJzZXIpXG57XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBpZihkaWNvbVBhcnNlciA9PT0gdW5kZWZpbmVkKVxuICAgIHtcbiAgICAgICAgZGljb21QYXJzZXIgPSB7fTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWFkcyBhbiBlbmNhcHN1bGF0ZWQgcGl4ZWwgZGF0YSBlbGVtZW50IGFuZCBhZGRzIGFuIGFycmF5IG9mIGZyYWdtZW50cyB0byB0aGUgZWxlbWVudFxuICAgICAqIGNvbnRhaW5pbmcgdGhlIG9mZnNldCBhbmQgbGVuZ3RoIG9mIGVhY2ggZnJhZ21lbnQgYW5kIGFueSBvZmZzZXRzIGZyb20gdGhlIGJhc2ljIG9mZnNldFxuICAgICAqIHRhYmxlXG4gICAgICogQHBhcmFtIGJ5dGVTdHJlYW1cbiAgICAgKiBAcGFyYW0gZWxlbWVudFxuICAgICAqL1xuICAgIGRpY29tUGFyc2VyLmZpbmRFbmRPZkVuY2Fwc3VsYXRlZEVsZW1lbnQgPSBmdW5jdGlvbihieXRlU3RyZWFtLCBlbGVtZW50LCB3YXJuaW5ncylcbiAgICB7XG4gICAgICAgIGlmKGJ5dGVTdHJlYW0gPT09IHVuZGVmaW5lZClcbiAgICAgICAge1xuICAgICAgICAgICAgdGhyb3cgXCJkaWNvbVBhcnNlci5maW5kRW5kT2ZFbmNhcHN1bGF0ZWRFbGVtZW50OiBtaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlciAnYnl0ZVN0cmVhbSdcIjtcbiAgICAgICAgfVxuICAgICAgICBpZihlbGVtZW50ID09PSB1bmRlZmluZWQpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRocm93IFwiZGljb21QYXJzZXIuZmluZEVuZE9mRW5jYXBzdWxhdGVkRWxlbWVudDogbWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXIgJ2VsZW1lbnQnXCI7XG4gICAgICAgIH1cblxuICAgICAgICBlbGVtZW50LmVuY2Fwc3VsYXRlZFBpeGVsRGF0YSA9IHRydWU7XG4gICAgICAgIGVsZW1lbnQuYmFzaWNPZmZzZXRUYWJsZSA9IFtdO1xuICAgICAgICBlbGVtZW50LmZyYWdtZW50cyA9IFtdO1xuICAgICAgICB2YXIgYmFzaWNPZmZzZXRUYWJsZUl0ZW1UYWcgPSBkaWNvbVBhcnNlci5yZWFkVGFnKGJ5dGVTdHJlYW0pO1xuICAgICAgICBpZihiYXNpY09mZnNldFRhYmxlSXRlbVRhZyAhPT0gJ3hmZmZlZTAwMCcpIHtcbiAgICAgICAgICAgIHRocm93IFwiZGljb21QYXJzZXIuZmluZEVuZE9mRW5jYXBzdWxhdGVkRWxlbWVudDogYmFzaWMgb2Zmc2V0IHRhYmxlIG5vdCBmb3VuZFwiO1xuICAgICAgICB9XG4gICAgICAgIHZhciBiYXNpY09mZnNldFRhYmxlSXRlbWxlbmd0aCA9IGJ5dGVTdHJlYW0ucmVhZFVpbnQzMigpO1xuICAgICAgICB2YXIgbnVtRnJhZ21lbnRzID0gYmFzaWNPZmZzZXRUYWJsZUl0ZW1sZW5ndGggLyA0O1xuICAgICAgICBmb3IodmFyIGkgPTA7IGkgPCBudW1GcmFnbWVudHM7IGkrKykge1xuICAgICAgICAgICAgdmFyIG9mZnNldCA9IGJ5dGVTdHJlYW0ucmVhZFVpbnQzMigpO1xuICAgICAgICAgICAgZWxlbWVudC5iYXNpY09mZnNldFRhYmxlLnB1c2gob2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYmFzZU9mZnNldCA9IGJ5dGVTdHJlYW0ucG9zaXRpb247XG5cbiAgICAgICAgd2hpbGUoYnl0ZVN0cmVhbS5wb3NpdGlvbiA8IGJ5dGVTdHJlYW0uYnl0ZUFycmF5Lmxlbmd0aClcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIHRhZyA9IGRpY29tUGFyc2VyLnJlYWRUYWcoYnl0ZVN0cmVhbSk7XG4gICAgICAgICAgICB2YXIgbGVuZ3RoID0gYnl0ZVN0cmVhbS5yZWFkVWludDMyKCk7XG4gICAgICAgICAgICBpZih0YWcgPT09ICd4ZmZmZWUwZGQnKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGJ5dGVTdHJlYW0uc2VlayhsZW5ndGgpO1xuICAgICAgICAgICAgICAgIGVsZW1lbnQubGVuZ3RoID0gYnl0ZVN0cmVhbS5wb3NpdGlvbiAtIGVsZW1lbnQuZGF0YU9mZnNldDtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmKHRhZyA9PT0gJ3hmZmZlZTAwMCcpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5mcmFnbWVudHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIG9mZnNldDogYnl0ZVN0cmVhbS5wb3NpdGlvbiAtIGJhc2VPZmZzZXQgLSA4LFxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiA6IGJ5dGVTdHJlYW0ucG9zaXRpb24sXG4gICAgICAgICAgICAgICAgICAgIGxlbmd0aCA6IGxlbmd0aFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYod2FybmluZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgd2FybmluZ3MucHVzaCgndW5leHBlY3RlZCB0YWcgJyArIHRhZyArICcgd2hpbGUgc2VhcmNoaW5nIGZvciBlbmQgb2YgcGl4ZWwgZGF0YSBlbGVtZW50IHdpdGggdW5kZWZpbmVkIGxlbmd0aCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZihsZW5ndGggPiBieXRlU3RyZWFtLmJ5dGVBcnJheS5sZW5ndGggLSBieXRlU3RyZWFtLnBvc2l0aW9uKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZml4IGxlbmd0aFxuICAgICAgICAgICAgICAgICAgICBsZW5ndGggPSBieXRlU3RyZWFtLmJ5dGVBcnJheS5sZW5ndGggLSBieXRlU3RyZWFtLnBvc2l0aW9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbGVtZW50LmZyYWdtZW50cy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiBieXRlU3RyZWFtLnBvc2l0aW9uIC0gYmFzZU9mZnNldCAtIDgsXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uIDogYnl0ZVN0cmVhbS5wb3NpdGlvbixcbiAgICAgICAgICAgICAgICAgICAgbGVuZ3RoIDogbGVuZ3RoXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYnl0ZVN0cmVhbS5zZWVrKGxlbmd0aCk7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5sZW5ndGggPSBieXRlU3RyZWFtLnBvc2l0aW9uIC0gZWxlbWVudC5kYXRhT2Zmc2V0O1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnl0ZVN0cmVhbS5zZWVrKGxlbmd0aCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZih3YXJuaW5ncykge1xuICAgICAgICAgICAgd2FybmluZ3MucHVzaChcInBpeGVsIGRhdGEgZWxlbWVudCBcIiArIGVsZW1lbnQudGFnICsgXCIgbWlzc2luZyBzZXF1ZW5jZSBkZWxpbWl0ZXIgdGFnIHhmZmZlZTBkZFwiKTtcbiAgICAgICAgfVxuICAgIH07XG5cblxuICAgIHJldHVybiBkaWNvbVBhcnNlcjtcbn0oZGljb21QYXJzZXIpKTtcbi8qKlxuICogSW50ZXJuYWwgaGVscGVyIGZ1bmN0aW9ucyBmb3IgcGFyc2luZyBESUNPTSBlbGVtZW50c1xuICovXG5cbnZhciBkaWNvbVBhcnNlciA9IChmdW5jdGlvbiAoZGljb21QYXJzZXIpXG57XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBpZihkaWNvbVBhcnNlciA9PT0gdW5kZWZpbmVkKVxuICAgIHtcbiAgICAgICAgZGljb21QYXJzZXIgPSB7fTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiByZWFkcyBmcm9tIHRoZSBieXRlIHN0cmVhbSB1bnRpbCBpdCBmaW5kcyB0aGUgbWFnaWMgbnVtYmVycyBmb3IgdGhlIGl0ZW0gZGVsaW1pdGF0aW9uIGl0ZW1cbiAgICAgKiBhbmQgdGhlbiBzZXRzIHRoZSBsZW5ndGggb2YgdGhlIGVsZW1lbnRcbiAgICAgKiBAcGFyYW0gYnl0ZVN0cmVhbVxuICAgICAqIEBwYXJhbSBlbGVtZW50XG4gICAgICovXG4gICAgZGljb21QYXJzZXIuZmluZEl0ZW1EZWxpbWl0YXRpb25JdGVtQW5kU2V0RWxlbWVudExlbmd0aCA9IGZ1bmN0aW9uKGJ5dGVTdHJlYW0sIGVsZW1lbnQpXG4gICAge1xuICAgICAgICBpZihieXRlU3RyZWFtID09PSB1bmRlZmluZWQpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRocm93IFwiZGljb21QYXJzZXIucmVhZERpY29tRWxlbWVudEltcGxpY2l0OiBtaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlciAnYnl0ZVN0cmVhbSdcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpdGVtRGVsaW1pdGF0aW9uSXRlbUxlbmd0aCA9IDg7IC8vIGdyb3VwLCBlbGVtZW50LCBsZW5ndGhcbiAgICAgICAgdmFyIG1heFBvc2l0aW9uID0gYnl0ZVN0cmVhbS5ieXRlQXJyYXkubGVuZ3RoIC0gaXRlbURlbGltaXRhdGlvbkl0ZW1MZW5ndGg7XG4gICAgICAgIHdoaWxlKGJ5dGVTdHJlYW0ucG9zaXRpb24gPD0gbWF4UG9zaXRpb24pXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciBncm91cE51bWJlciA9IGJ5dGVTdHJlYW0ucmVhZFVpbnQxNigpO1xuICAgICAgICAgICAgaWYoZ3JvdXBOdW1iZXIgPT09IDB4ZmZmZSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB2YXIgZWxlbWVudE51bWJlciA9IGJ5dGVTdHJlYW0ucmVhZFVpbnQxNigpO1xuICAgICAgICAgICAgICAgIGlmKGVsZW1lbnROdW1iZXIgPT09IDB4ZTAwZClcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE5PVEU6IEl0IHdvdWxkIGJlIGJldHRlciB0byBhbHNvIGNoZWNrIGZvciB0aGUgbGVuZ3RoIHRvIGJlIDAgYXMgcGFydCBvZiB0aGUgY2hlY2sgYWJvdmVcbiAgICAgICAgICAgICAgICAgICAgLy8gYnV0IHdlIHdpbGwganVzdCBsb2cgYSB3YXJuaW5nIGZvciBub3dcbiAgICAgICAgICAgICAgICAgICAgdmFyIGl0ZW1EZWxpbWl0ZXJMZW5ndGggPSBieXRlU3RyZWFtLnJlYWRVaW50MzIoKTsgLy8gdGhlIGxlbmd0aFxuICAgICAgICAgICAgICAgICAgICBpZihpdGVtRGVsaW1pdGVyTGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBieXRlU3RyZWFtLndhcm5pbmdzKCdlbmNvdW50ZXJlZCBub24gemVybyBsZW5ndGggZm9sbG93aW5nIGl0ZW0gZGVsaW1pdGVyIGF0IHBvc2l0aW9uJyArIGJ5dGVTdHJlYW0ucG9zaXRpb24gLSA0ICsgXCIgd2hpbGUgcmVhZGluZyBlbGVtZW50IG9mIHVuZGVmaW5lZCBsZW5ndGggd2l0aCB0YWcgJyArIGVsZW1lbnQudGFnXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQubGVuZ3RoID0gYnl0ZVN0cmVhbS5wb3NpdGlvbiAtIGVsZW1lbnQuZGF0YU9mZnNldDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE5vIGl0ZW0gZGVsaW1pdGF0aW9uIGl0ZW0gLSBzaWxlbnRseSBzZXQgdGhlIGxlbmd0aCB0byB0aGUgZW5kIG9mIHRoZSBidWZmZXIgYW5kIHNldCB0aGUgcG9zaXRpb24gcGFzdCB0aGUgZW5kIG9mIHRoZSBidWZmZXJcbiAgICAgICAgZWxlbWVudC5sZW5ndGggPSBieXRlU3RyZWFtLmJ5dGVBcnJheS5sZW5ndGggLSBlbGVtZW50LmRhdGFPZmZzZXQ7XG4gICAgICAgIGJ5dGVTdHJlYW0uc2VlayhieXRlU3RyZWFtLmJ5dGVBcnJheS5sZW5ndGggLSBieXRlU3RyZWFtLnBvc2l0aW9uKTtcbiAgICB9O1xuXG5cbiAgICByZXR1cm4gZGljb21QYXJzZXI7XG59KGRpY29tUGFyc2VyKSk7XG4vKipcbiAqIEludGVybmFsIGhlbHBlciBmdW5jdGlvbnMgZm9yIHBhcnNpbmcgZGlmZmVyZW50IHR5cGVzIGZyb20gYSBsaXR0bGUtZW5kaWFuIGJ5dGUgYXJyYXlcbiAqL1xuXG52YXIgZGljb21QYXJzZXIgPSAoZnVuY3Rpb24gKGRpY29tUGFyc2VyKVxue1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgaWYoZGljb21QYXJzZXIgPT09IHVuZGVmaW5lZClcbiAgICB7XG4gICAgICAgIGRpY29tUGFyc2VyID0ge307XG4gICAgfVxuXG4gICAgZGljb21QYXJzZXIubGl0dGxlRW5kaWFuQnl0ZUFycmF5UGFyc2VyID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICpcbiAgICAgICAgICogUGFyc2VzIGFuIHVuc2lnbmVkIGludCAxNiBmcm9tIGEgbGl0dGxlLWVuZGlhbiBieXRlIGFycmF5XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBieXRlQXJyYXkgdGhlIGJ5dGUgYXJyYXkgdG8gcmVhZCBmcm9tXG4gICAgICAgICAqIEBwYXJhbSBwb3NpdGlvbiB0aGUgcG9zaXRpb24gaW4gdGhlIGJ5dGUgYXJyYXkgdG8gcmVhZCBmcm9tXG4gICAgICAgICAqIEByZXR1cm5zIHsqfSB0aGUgcGFyc2VkIHVuc2lnbmVkIGludCAxNlxuICAgICAgICAgKiBAdGhyb3dzIGVycm9yIGlmIGJ1ZmZlciBvdmVycmVhZCB3b3VsZCBvY2N1clxuICAgICAgICAgKiBAYWNjZXNzIHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHJlYWRVaW50MTY6IGZ1bmN0aW9uIChieXRlQXJyYXksIHBvc2l0aW9uKSB7XG4gICAgICAgICAgICBpZiAocG9zaXRpb24gPCAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgJ2xpdHRsZUVuZGlhbkJ5dGVBcnJheVBhcnNlci5yZWFkVWludDE2OiBwb3NpdGlvbiBjYW5ub3QgYmUgbGVzcyB0aGFuIDAnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBvc2l0aW9uICsgMiA+IGJ5dGVBcnJheS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyAnbGl0dGxlRW5kaWFuQnl0ZUFycmF5UGFyc2VyLnJlYWRVaW50MTY6IGF0dGVtcHQgdG8gcmVhZCBwYXN0IGVuZCBvZiBidWZmZXInO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGJ5dGVBcnJheVtwb3NpdGlvbl0gKyAoYnl0ZUFycmF5W3Bvc2l0aW9uICsgMV0gKiAyNTYpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKlxuICAgICAgICAgKiBQYXJzZXMgYSBzaWduZWQgaW50IDE2IGZyb20gYSBsaXR0bGUtZW5kaWFuIGJ5dGUgYXJyYXlcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGJ5dGVBcnJheSB0aGUgYnl0ZSBhcnJheSB0byByZWFkIGZyb21cbiAgICAgICAgICogQHBhcmFtIHBvc2l0aW9uIHRoZSBwb3NpdGlvbiBpbiB0aGUgYnl0ZSBhcnJheSB0byByZWFkIGZyb21cbiAgICAgICAgICogQHJldHVybnMgeyp9IHRoZSBwYXJzZWQgc2lnbmVkIGludCAxNlxuICAgICAgICAgKiBAdGhyb3dzIGVycm9yIGlmIGJ1ZmZlciBvdmVycmVhZCB3b3VsZCBvY2N1clxuICAgICAgICAgKiBAYWNjZXNzIHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHJlYWRJbnQxNjogZnVuY3Rpb24gKGJ5dGVBcnJheSwgcG9zaXRpb24pIHtcbiAgICAgICAgICAgIGlmIChwb3NpdGlvbiA8IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyAnbGl0dGxlRW5kaWFuQnl0ZUFycmF5UGFyc2VyLnJlYWRJbnQxNjogcG9zaXRpb24gY2Fubm90IGJlIGxlc3MgdGhhbiAwJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwb3NpdGlvbiArIDIgPiBieXRlQXJyYXkubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgJ2xpdHRsZUVuZGlhbkJ5dGVBcnJheVBhcnNlci5yZWFkSW50MTY6IGF0dGVtcHQgdG8gcmVhZCBwYXN0IGVuZCBvZiBidWZmZXInO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGludDE2ID0gYnl0ZUFycmF5W3Bvc2l0aW9uXSArIChieXRlQXJyYXlbcG9zaXRpb24gKyAxXSA8PCA4KTtcbiAgICAgICAgICAgIC8vIGZpeCBzaWduXG4gICAgICAgICAgICBpZiAoaW50MTYgJiAweDgwMDApIHtcbiAgICAgICAgICAgICAgICBpbnQxNiA9IGludDE2IC0gMHhGRkZGIC0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpbnQxNjtcbiAgICAgICAgfSxcblxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQYXJzZXMgYW4gdW5zaWduZWQgaW50IDMyIGZyb20gYSBsaXR0bGUtZW5kaWFuIGJ5dGUgYXJyYXlcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGJ5dGVBcnJheSB0aGUgYnl0ZSBhcnJheSB0byByZWFkIGZyb21cbiAgICAgICAgICogQHBhcmFtIHBvc2l0aW9uIHRoZSBwb3NpdGlvbiBpbiB0aGUgYnl0ZSBhcnJheSB0byByZWFkIGZyb21cbiAgICAgICAgICogQHJldHVybnMgeyp9IHRoZSBwYXJzZWQgdW5zaWduZWQgaW50IDMyXG4gICAgICAgICAqIEB0aHJvd3MgZXJyb3IgaWYgYnVmZmVyIG92ZXJyZWFkIHdvdWxkIG9jY3VyXG4gICAgICAgICAqIEBhY2Nlc3MgcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgcmVhZFVpbnQzMjogZnVuY3Rpb24gKGJ5dGVBcnJheSwgcG9zaXRpb24pIHtcbiAgICAgICAgICAgIGlmIChwb3NpdGlvbiA8IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyAnbGl0dGxlRW5kaWFuQnl0ZUFycmF5UGFyc2VyLnJlYWRVaW50MzI6IHBvc2l0aW9uIGNhbm5vdCBiZSBsZXNzIHRoYW4gMCc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChwb3NpdGlvbiArIDQgPiBieXRlQXJyYXkubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgJ2xpdHRsZUVuZGlhbkJ5dGVBcnJheVBhcnNlci5yZWFkVWludDMyOiBhdHRlbXB0IHRvIHJlYWQgcGFzdCBlbmQgb2YgYnVmZmVyJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHVpbnQzMiA9IChieXRlQXJyYXlbcG9zaXRpb25dICtcbiAgICAgICAgICAgIChieXRlQXJyYXlbcG9zaXRpb24gKyAxXSAqIDI1NikgK1xuICAgICAgICAgICAgKGJ5dGVBcnJheVtwb3NpdGlvbiArIDJdICogMjU2ICogMjU2KSArXG4gICAgICAgICAgICAoYnl0ZUFycmF5W3Bvc2l0aW9uICsgM10gKiAyNTYgKiAyNTYgKiAyNTYgKSk7XG5cbiAgICAgICAgICAgIHJldHVybiB1aW50MzI7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFBhcnNlcyBhIHNpZ25lZCBpbnQgMzIgZnJvbSBhIGxpdHRsZS1lbmRpYW4gYnl0ZSBhcnJheVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gYnl0ZUFycmF5IHRoZSBieXRlIGFycmF5IHRvIHJlYWQgZnJvbVxuICAgICAgICAgKiBAcGFyYW0gcG9zaXRpb24gdGhlIHBvc2l0aW9uIGluIHRoZSBieXRlIGFycmF5IHRvIHJlYWQgZnJvbVxuICAgICAgICAgKiBAcmV0dXJucyB7Kn0gdGhlIHBhcnNlZCB1bnNpZ25lZCBpbnQgMzJcbiAgICAgICAgICogQHRocm93cyBlcnJvciBpZiBidWZmZXIgb3ZlcnJlYWQgd291bGQgb2NjdXJcbiAgICAgICAgICogQGFjY2VzcyBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICByZWFkSW50MzI6IGZ1bmN0aW9uIChieXRlQXJyYXksIHBvc2l0aW9uKSB7XG4gICAgICAgICAgICBpZiAocG9zaXRpb24gPCAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgJ2xpdHRsZUVuZGlhbkJ5dGVBcnJheVBhcnNlci5yZWFkSW50MzI6IHBvc2l0aW9uIGNhbm5vdCBiZSBsZXNzIHRoYW4gMCc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChwb3NpdGlvbiArIDQgPiBieXRlQXJyYXkubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgJ2xpdHRsZUVuZGlhbkJ5dGVBcnJheVBhcnNlci5yZWFkSW50MzI6IGF0dGVtcHQgdG8gcmVhZCBwYXN0IGVuZCBvZiBidWZmZXInO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgaW50MzIgPSAoYnl0ZUFycmF5W3Bvc2l0aW9uXSArXG4gICAgICAgICAgICAoYnl0ZUFycmF5W3Bvc2l0aW9uICsgMV0gPDwgOCkgK1xuICAgICAgICAgICAgKGJ5dGVBcnJheVtwb3NpdGlvbiArIDJdIDw8IDE2KSArXG4gICAgICAgICAgICAoYnl0ZUFycmF5W3Bvc2l0aW9uICsgM10gPDwgMjQpKTtcblxuICAgICAgICAgICAgcmV0dXJuIGludDMyO1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFBhcnNlcyAzMi1iaXQgZmxvYXQgZnJvbSBhIGxpdHRsZS1lbmRpYW4gYnl0ZSBhcnJheVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gYnl0ZUFycmF5IHRoZSBieXRlIGFycmF5IHRvIHJlYWQgZnJvbVxuICAgICAgICAgKiBAcGFyYW0gcG9zaXRpb24gdGhlIHBvc2l0aW9uIGluIHRoZSBieXRlIGFycmF5IHRvIHJlYWQgZnJvbVxuICAgICAgICAgKiBAcmV0dXJucyB7Kn0gdGhlIHBhcnNlZCAzMi1iaXQgZmxvYXRcbiAgICAgICAgICogQHRocm93cyBlcnJvciBpZiBidWZmZXIgb3ZlcnJlYWQgd291bGQgb2NjdXJcbiAgICAgICAgICogQGFjY2VzcyBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICByZWFkRmxvYXQ6IGZ1bmN0aW9uIChieXRlQXJyYXksIHBvc2l0aW9uKSB7XG4gICAgICAgICAgICBpZiAocG9zaXRpb24gPCAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgJ2xpdHRsZUVuZGlhbkJ5dGVBcnJheVBhcnNlci5yZWFkRmxvYXQ6IHBvc2l0aW9uIGNhbm5vdCBiZSBsZXNzIHRoYW4gMCc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChwb3NpdGlvbiArIDQgPiBieXRlQXJyYXkubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgJ2xpdHRsZUVuZGlhbkJ5dGVBcnJheVBhcnNlci5yZWFkRmxvYXQ6IGF0dGVtcHQgdG8gcmVhZCBwYXN0IGVuZCBvZiBidWZmZXInO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJIGFtIHN1cmUgdGhlcmUgaXMgYSBiZXR0ZXIgd2F5IHRoYW4gdGhpcyBidXQgdGhpcyBzaG91bGQgYmUgc2FmZVxuICAgICAgICAgICAgdmFyIGJ5dGVBcnJheUZvclBhcnNpbmdGbG9hdCA9IG5ldyBVaW50OEFycmF5KDQpO1xuICAgICAgICAgICAgYnl0ZUFycmF5Rm9yUGFyc2luZ0Zsb2F0WzBdID0gYnl0ZUFycmF5W3Bvc2l0aW9uXTtcbiAgICAgICAgICAgIGJ5dGVBcnJheUZvclBhcnNpbmdGbG9hdFsxXSA9IGJ5dGVBcnJheVtwb3NpdGlvbiArIDFdO1xuICAgICAgICAgICAgYnl0ZUFycmF5Rm9yUGFyc2luZ0Zsb2F0WzJdID0gYnl0ZUFycmF5W3Bvc2l0aW9uICsgMl07XG4gICAgICAgICAgICBieXRlQXJyYXlGb3JQYXJzaW5nRmxvYXRbM10gPSBieXRlQXJyYXlbcG9zaXRpb24gKyAzXTtcbiAgICAgICAgICAgIHZhciBmbG9hdEFycmF5ID0gbmV3IEZsb2F0MzJBcnJheShieXRlQXJyYXlGb3JQYXJzaW5nRmxvYXQuYnVmZmVyKTtcbiAgICAgICAgICAgIHJldHVybiBmbG9hdEFycmF5WzBdO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQYXJzZXMgNjQtYml0IGZsb2F0IGZyb20gYSBsaXR0bGUtZW5kaWFuIGJ5dGUgYXJyYXlcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGJ5dGVBcnJheSB0aGUgYnl0ZSBhcnJheSB0byByZWFkIGZyb21cbiAgICAgICAgICogQHBhcmFtIHBvc2l0aW9uIHRoZSBwb3NpdGlvbiBpbiB0aGUgYnl0ZSBhcnJheSB0byByZWFkIGZyb21cbiAgICAgICAgICogQHJldHVybnMgeyp9IHRoZSBwYXJzZWQgNjQtYml0IGZsb2F0XG4gICAgICAgICAqIEB0aHJvd3MgZXJyb3IgaWYgYnVmZmVyIG92ZXJyZWFkIHdvdWxkIG9jY3VyXG4gICAgICAgICAqIEBhY2Nlc3MgcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgcmVhZERvdWJsZTogZnVuY3Rpb24gKGJ5dGVBcnJheSwgcG9zaXRpb24pIHtcbiAgICAgICAgICAgIGlmIChwb3NpdGlvbiA8IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyAnbGl0dGxlRW5kaWFuQnl0ZUFycmF5UGFyc2VyLnJlYWREb3VibGU6IHBvc2l0aW9uIGNhbm5vdCBiZSBsZXNzIHRoYW4gMCc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChwb3NpdGlvbiArIDggPiBieXRlQXJyYXkubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgJ2xpdHRsZUVuZGlhbkJ5dGVBcnJheVBhcnNlci5yZWFkRG91YmxlOiBhdHRlbXB0IHRvIHJlYWQgcGFzdCBlbmQgb2YgYnVmZmVyJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSSBhbSBzdXJlIHRoZXJlIGlzIGEgYmV0dGVyIHdheSB0aGFuIHRoaXMgYnV0IHRoaXMgc2hvdWxkIGJlIHNhZmVcbiAgICAgICAgICAgIHZhciBieXRlQXJyYXlGb3JQYXJzaW5nRmxvYXQgPSBuZXcgVWludDhBcnJheSg4KTtcbiAgICAgICAgICAgIGJ5dGVBcnJheUZvclBhcnNpbmdGbG9hdFswXSA9IGJ5dGVBcnJheVtwb3NpdGlvbl07XG4gICAgICAgICAgICBieXRlQXJyYXlGb3JQYXJzaW5nRmxvYXRbMV0gPSBieXRlQXJyYXlbcG9zaXRpb24gKyAxXTtcbiAgICAgICAgICAgIGJ5dGVBcnJheUZvclBhcnNpbmdGbG9hdFsyXSA9IGJ5dGVBcnJheVtwb3NpdGlvbiArIDJdO1xuICAgICAgICAgICAgYnl0ZUFycmF5Rm9yUGFyc2luZ0Zsb2F0WzNdID0gYnl0ZUFycmF5W3Bvc2l0aW9uICsgM107XG4gICAgICAgICAgICBieXRlQXJyYXlGb3JQYXJzaW5nRmxvYXRbNF0gPSBieXRlQXJyYXlbcG9zaXRpb24gKyA0XTtcbiAgICAgICAgICAgIGJ5dGVBcnJheUZvclBhcnNpbmdGbG9hdFs1XSA9IGJ5dGVBcnJheVtwb3NpdGlvbiArIDVdO1xuICAgICAgICAgICAgYnl0ZUFycmF5Rm9yUGFyc2luZ0Zsb2F0WzZdID0gYnl0ZUFycmF5W3Bvc2l0aW9uICsgNl07XG4gICAgICAgICAgICBieXRlQXJyYXlGb3JQYXJzaW5nRmxvYXRbN10gPSBieXRlQXJyYXlbcG9zaXRpb24gKyA3XTtcbiAgICAgICAgICAgIHZhciBmbG9hdEFycmF5ID0gbmV3IEZsb2F0NjRBcnJheShieXRlQXJyYXlGb3JQYXJzaW5nRmxvYXQuYnVmZmVyKTtcbiAgICAgICAgICAgIHJldHVybiBmbG9hdEFycmF5WzBdO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBkaWNvbVBhcnNlcjtcbn0oZGljb21QYXJzZXIpKTtcbi8qKlxuICogSW50ZXJuYWwgaGVscGVyIGZ1bmN0aW9ucyBmb3IgcGFyc2luZyBpbXBsaWNpdCBhbmQgZXhwbGljaXQgRElDT00gZGF0YSBzZXRzXG4gKi9cblxudmFyIGRpY29tUGFyc2VyID0gKGZ1bmN0aW9uIChkaWNvbVBhcnNlcilcbntcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGlmKGRpY29tUGFyc2VyID09PSB1bmRlZmluZWQpXG4gICAge1xuICAgICAgICBkaWNvbVBhcnNlciA9IHt9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHJlYWRzIGFuIGV4cGxpY2l0IGRhdGEgc2V0XG4gICAgICogQHBhcmFtIGJ5dGVTdHJlYW0gdGhlIGJ5dGUgc3RyZWFtIHRvIHJlYWQgZnJvbVxuICAgICAqIEBwYXJhbSBtYXhQb3NpdGlvbiB0aGUgbWF4aW11bSBwb3NpdGlvbiB0byByZWFkIHVwIHRvIChvcHRpb25hbCAtIG9ubHkgbmVlZGVkIHdoZW4gcmVhZGluZyBzZXF1ZW5jZSBpdGVtcylcbiAgICAgKi9cbiAgICBkaWNvbVBhcnNlci5wYXJzZURpY29tRGF0YVNldEV4cGxpY2l0ID0gZnVuY3Rpb24gKGRhdGFTZXQsIGJ5dGVTdHJlYW0sIG1heFBvc2l0aW9uLCBvcHRpb25zKSB7XG5cbiAgICAgICAgbWF4UG9zaXRpb24gPSAobWF4UG9zaXRpb24gPT09IHVuZGVmaW5lZCkgPyBieXRlU3RyZWFtLmJ5dGVBcnJheS5sZW5ndGggOiBtYXhQb3NpdGlvbiA7XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgICAgIGlmKGJ5dGVTdHJlYW0gPT09IHVuZGVmaW5lZClcbiAgICAgICAge1xuICAgICAgICAgICAgdGhyb3cgXCJkaWNvbVBhcnNlci5wYXJzZURpY29tRGF0YVNldEV4cGxpY2l0OiBtaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlciAnYnl0ZVN0cmVhbSdcIjtcbiAgICAgICAgfVxuICAgICAgICBpZihtYXhQb3NpdGlvbiA8IGJ5dGVTdHJlYW0ucG9zaXRpb24gfHwgbWF4UG9zaXRpb24gPiBieXRlU3RyZWFtLmJ5dGVBcnJheS5sZW5ndGgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRocm93IFwiZGljb21QYXJzZXIucGFyc2VEaWNvbURhdGFTZXRFeHBsaWNpdDogaW52YWxpZCB2YWx1ZSBmb3IgcGFyYW1ldGVyICdtYXhQb3NpdGlvbidcIjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZWxlbWVudHMgPSBkYXRhU2V0LmVsZW1lbnRzO1xuXG4gICAgICAgIHdoaWxlKGJ5dGVTdHJlYW0ucG9zaXRpb24gPCBtYXhQb3NpdGlvbilcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSBkaWNvbVBhcnNlci5yZWFkRGljb21FbGVtZW50RXhwbGljaXQoYnl0ZVN0cmVhbSwgZGF0YVNldC53YXJuaW5ncywgb3B0aW9ucy51bnRpbFRhZyk7XG4gICAgICAgICAgICBlbGVtZW50c1tlbGVtZW50LnRhZ10gPSBlbGVtZW50O1xuICAgICAgICAgICAgaWYoZWxlbWVudC50YWcgPT09IG9wdGlvbnMudW50aWxUYWcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYoYnl0ZVN0cmVhbS5wb3NpdGlvbiA+IG1heFBvc2l0aW9uKSB7XG4gICAgICAgICAgICB0aHJvdyBcImRpY29tUGFyc2VyOnBhcnNlRGljb21EYXRhU2V0RXhwbGljaXQ6IGJ1ZmZlciBvdmVycnVuXCI7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogcmVhZHMgYW4gaW1wbGljaXQgZGF0YSBzZXRcbiAgICAgKiBAcGFyYW0gYnl0ZVN0cmVhbSB0aGUgYnl0ZSBzdHJlYW0gdG8gcmVhZCBmcm9tXG4gICAgICogQHBhcmFtIG1heFBvc2l0aW9uIHRoZSBtYXhpbXVtIHBvc2l0aW9uIHRvIHJlYWQgdXAgdG8gKG9wdGlvbmFsIC0gb25seSBuZWVkZWQgd2hlbiByZWFkaW5nIHNlcXVlbmNlIGl0ZW1zKVxuICAgICAqL1xuICAgIGRpY29tUGFyc2VyLnBhcnNlRGljb21EYXRhU2V0SW1wbGljaXQgPSBmdW5jdGlvbihkYXRhU2V0LCBieXRlU3RyZWFtLCBtYXhQb3NpdGlvbiwgb3B0aW9ucylcbiAgICB7XG4gICAgICAgIG1heFBvc2l0aW9uID0gKG1heFBvc2l0aW9uID09PSB1bmRlZmluZWQpID8gZGF0YVNldC5ieXRlQXJyYXkubGVuZ3RoIDogbWF4UG9zaXRpb24gO1xuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgICAgICBpZihieXRlU3RyZWFtID09PSB1bmRlZmluZWQpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRocm93IFwiZGljb21QYXJzZXIucGFyc2VEaWNvbURhdGFTZXRJbXBsaWNpdDogbWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXIgJ2J5dGVTdHJlYW0nXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYobWF4UG9zaXRpb24gPCBieXRlU3RyZWFtLnBvc2l0aW9uIHx8IG1heFBvc2l0aW9uID4gYnl0ZVN0cmVhbS5ieXRlQXJyYXkubGVuZ3RoKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aHJvdyBcImRpY29tUGFyc2VyLnBhcnNlRGljb21EYXRhU2V0SW1wbGljaXQ6IGludmFsaWQgdmFsdWUgZm9yIHBhcmFtZXRlciAnbWF4UG9zaXRpb24nXCI7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZWxlbWVudHMgPSBkYXRhU2V0LmVsZW1lbnRzO1xuXG4gICAgICAgIHdoaWxlKGJ5dGVTdHJlYW0ucG9zaXRpb24gPCBtYXhQb3NpdGlvbilcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSBkaWNvbVBhcnNlci5yZWFkRGljb21FbGVtZW50SW1wbGljaXQoYnl0ZVN0cmVhbSwgb3B0aW9ucy51bnRpbFRhZywgb3B0aW9ucy52ckNhbGxiYWNrKTtcbiAgICAgICAgICAgIGVsZW1lbnRzW2VsZW1lbnQudGFnXSA9IGVsZW1lbnQ7XG4gICAgICAgICAgICBpZihlbGVtZW50LnRhZyA9PT0gb3B0aW9ucy51bnRpbFRhZykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gZGljb21QYXJzZXI7XG59KGRpY29tUGFyc2VyKSk7XG5cbi8qKlxuICogSW50ZXJuYWwgaGVscGVyIGZ1bmN0aW9ucyBmb3IgZm9yIHBhcnNpbmcgRElDT00gZWxlbWVudHNcbiAqL1xuXG52YXIgZGljb21QYXJzZXIgPSAoZnVuY3Rpb24gKGRpY29tUGFyc2VyKVxue1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgaWYoZGljb21QYXJzZXIgPT09IHVuZGVmaW5lZClcbiAgICB7XG4gICAgICAgIGRpY29tUGFyc2VyID0ge307XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0RGF0YUxlbmd0aFNpemVJbkJ5dGVzRm9yVlIodnIpXG4gICAge1xuICAgICAgICBpZiggdnIgPT09ICdPQicgfHxcbiAgICAgICAgICAgIHZyID09PSAnT1cnIHx8XG4gICAgICAgICAgICB2ciA9PT0gJ1NRJyB8fFxuICAgICAgICAgICAgdnIgPT09ICdPRicgfHxcbiAgICAgICAgICAgIHZyID09PSAnVVQnIHx8XG4gICAgICAgICAgICB2ciA9PT0gJ1VOJylcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIDQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gMjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGRpY29tUGFyc2VyLnJlYWREaWNvbUVsZW1lbnRFeHBsaWNpdCA9IGZ1bmN0aW9uKGJ5dGVTdHJlYW0sIHdhcm5pbmdzLCB1bnRpbFRhZylcbiAgICB7XG4gICAgICAgIGlmKGJ5dGVTdHJlYW0gPT09IHVuZGVmaW5lZClcbiAgICAgICAge1xuICAgICAgICAgICAgdGhyb3cgXCJkaWNvbVBhcnNlci5yZWFkRGljb21FbGVtZW50RXhwbGljaXQ6IG1pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyICdieXRlU3RyZWFtJ1wiO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGVsZW1lbnQgPSB7XG4gICAgICAgICAgICB0YWcgOiBkaWNvbVBhcnNlci5yZWFkVGFnKGJ5dGVTdHJlYW0pLFxuICAgICAgICAgICAgdnIgOiBieXRlU3RyZWFtLnJlYWRGaXhlZFN0cmluZygyKVxuICAgICAgICAgICAgLy8gbGVuZ3RoIHNldCBiZWxvdyBiYXNlZCBvbiBWUlxuICAgICAgICAgICAgLy8gZGF0YU9mZnNldCBzZXQgYmVsb3cgYmFzZWQgb24gVlIgYW5kIHNpemUgb2YgbGVuZ3RoXG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGRhdGFMZW5ndGhTaXplQnl0ZXMgPSBnZXREYXRhTGVuZ3RoU2l6ZUluQnl0ZXNGb3JWUihlbGVtZW50LnZyKTtcbiAgICAgICAgaWYoZGF0YUxlbmd0aFNpemVCeXRlcyA9PT0gMilcbiAgICAgICAge1xuICAgICAgICAgICAgZWxlbWVudC5sZW5ndGggPSBieXRlU3RyZWFtLnJlYWRVaW50MTYoKTtcbiAgICAgICAgICAgIGVsZW1lbnQuZGF0YU9mZnNldCA9IGJ5dGVTdHJlYW0ucG9zaXRpb247XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICBieXRlU3RyZWFtLnNlZWsoMik7XG4gICAgICAgICAgICBlbGVtZW50Lmxlbmd0aCA9IGJ5dGVTdHJlYW0ucmVhZFVpbnQzMigpO1xuICAgICAgICAgICAgZWxlbWVudC5kYXRhT2Zmc2V0ID0gYnl0ZVN0cmVhbS5wb3NpdGlvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKGVsZW1lbnQubGVuZ3RoID09PSA0Mjk0OTY3Mjk1KVxuICAgICAgICB7XG4gICAgICAgICAgICBlbGVtZW50LmhhZFVuZGVmaW5lZExlbmd0aCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZihlbGVtZW50LnRhZyA9PT0gdW50aWxUYWcpIHtcbiAgICAgICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgVlIgaXMgU1EsIHBhcnNlIHRoZSBzZXF1ZW5jZSBpdGVtc1xuICAgICAgICBpZihlbGVtZW50LnZyID09PSAnU1EnKVxuICAgICAgICB7XG4gICAgICAgICAgICBkaWNvbVBhcnNlci5yZWFkU2VxdWVuY2VJdGVtc0V4cGxpY2l0KGJ5dGVTdHJlYW0sIGVsZW1lbnQsIHdhcm5pbmdzKTtcbiAgICAgICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgICAgICB9XG5cblxuICAgICAgICBpZihlbGVtZW50Lmxlbmd0aCA9PT0gNDI5NDk2NzI5NSlcbiAgICAgICAge1xuICAgICAgICAgICAgaWYoZWxlbWVudC50YWcgPT09ICd4N2ZlMDAwMTAnKSB7XG4gICAgICAgICAgICAgICAgZGljb21QYXJzZXIuZmluZEVuZE9mRW5jYXBzdWxhdGVkRWxlbWVudChieXRlU3RyZWFtLCBlbGVtZW50LCB3YXJuaW5ncyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgICAgICAgICB9ICAgZWxzZSBpZihlbGVtZW50LnZyID09PSAnVU4nKSB7XG4gICAgICAgICAgICAgICAgZGljb21QYXJzZXIuZmluZEFuZFNldFVORWxlbWVudExlbmd0aChieXRlU3RyZWFtLCBlbGVtZW50KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZWxlbWVudDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZGljb21QYXJzZXIucmVhZFNlcXVlbmNlSXRlbXNJbXBsaWNpdChieXRlU3RyZWFtLCBlbGVtZW50KTtcbiAgICAgICAgICAgICAgICAvL2RpY29tUGFyc2VyLmZpbmRJdGVtRGVsaW1pdGF0aW9uSXRlbUFuZFNldEVsZW1lbnRMZW5ndGgoYnl0ZVN0cmVhbSwgZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBieXRlU3RyZWFtLnNlZWsoZWxlbWVudC5sZW5ndGgpO1xuICAgICAgICByZXR1cm4gZWxlbWVudDtcbiAgICB9O1xuXG4gICAgcmV0dXJuIGRpY29tUGFyc2VyO1xufShkaWNvbVBhcnNlcikpO1xuLyoqXG4gKiBJbnRlcm5hbCBoZWxwZXIgZnVuY3Rpb25zIGZvciBmb3IgcGFyc2luZyBESUNPTSBlbGVtZW50c1xuICovXG5cbnZhciBkaWNvbVBhcnNlciA9IChmdW5jdGlvbiAoZGljb21QYXJzZXIpXG57XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBpZihkaWNvbVBhcnNlciA9PT0gdW5kZWZpbmVkKVxuICAgIHtcbiAgICAgICAgZGljb21QYXJzZXIgPSB7fTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1NlcXVlbmNlKGVsZW1lbnQsIGJ5dGVTdHJlYW0sIHZyQ2FsbGJhY2spIHtcbiAgICAgICAgLy8gaWYgYSBkYXRhIGRpY3Rpb25hcnkgY2FsbGJhY2sgd2FzIHByb3ZpZGVkLCB1c2UgdGhhdCB0byB2ZXJpZnkgdGhhdCB0aGUgZWxlbWVudCBpcyBhIHNlcXVlbmNlLlxuICAgICAgICBpZiAodHlwZW9mIHZyQ2FsbGJhY2sgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gKHZyQ2FsbGJhY2soZWxlbWVudC50YWcpID09PSAnU1EnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKGJ5dGVTdHJlYW0ucG9zaXRpb24gKyA0KSA8PSBieXRlU3RyZWFtLmJ5dGVBcnJheS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBuZXh0VGFnID0gZGljb21QYXJzZXIucmVhZFRhZyhieXRlU3RyZWFtKTtcbiAgICAgICAgICAgIGJ5dGVTdHJlYW0uc2VlaygtNCk7XG4gICAgICAgICAgICAvLyBJdGVtIHN0YXJ0IHRhZyAoZmZmZSxlMDAwKSBvciBzZXF1ZW5jZSBkZWxpbWl0ZXIgKGkuZS4gZW5kIG9mIHNlcXVlbmNlKSB0YWcgKDBmZmZlLGUwZGQpXG4gICAgICAgICAgICAvLyBUaGVzZSBhcmUgdGhlIHRhZ3MgdGhhdCBjb3VsZCBwb3RlbnRpYWxseSBiZSBmb3VuZCBkaXJlY3RseSBhZnRlciBhIHNlcXVlbmNlIHN0YXJ0IHRhZyAodGhlIGRlbGltaXRlclxuICAgICAgICAgICAgLy8gaXMgZm91bmQgaW4gdGhlIGNhc2Ugb2YgYW4gZW1wdHkgc2VxdWVuY2UpLiBUaGlzIGlzIG5vdCAxMDAlIHNhZmUgYmVjYXVzZSBhIG5vbi1zZXF1ZW5jZSBpdGVtXG4gICAgICAgICAgICAvLyBjb3VsZCBoYXZlIGRhdGEgdGhhdCBoYXMgdGhlc2UgYnl0ZXMsIGJ1dCB0aGlzIGlzIGhvdyB0byBkbyBpdCB3aXRob3V0IGEgZGF0YSBkaWN0aW9uYXJ5LlxuICAgICAgICAgICAgcmV0dXJuIChuZXh0VGFnID09PSAneGZmZmVlMDAwJykgfHwgKG5leHRUYWcgPT09ICd4ZmZmZWUwZGQnKTtcbiAgICAgICAgfVxuICAgICAgICBieXRlU3RyZWFtLndhcm5pbmdzLnB1c2goJ2VvZiBlbmNvdW50ZXJlZCBiZWZvcmUgZmluZGluZyBzZXF1ZW5jZSBpdGVtIHRhZyBvciBzZXF1ZW5jZSBkZWxpbWl0ZXIgdGFnIGluIHBlZWtpbmcgdG8gZGV0ZXJtaW5lIFZSJyk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBkaWNvbVBhcnNlci5yZWFkRGljb21FbGVtZW50SW1wbGljaXQgPSBmdW5jdGlvbihieXRlU3RyZWFtLCB1bnRpbFRhZywgdnJDYWxsYmFjaylcbiAgICB7XG4gICAgICAgIGlmKGJ5dGVTdHJlYW0gPT09IHVuZGVmaW5lZClcbiAgICAgICAge1xuICAgICAgICAgICAgdGhyb3cgXCJkaWNvbVBhcnNlci5yZWFkRGljb21FbGVtZW50SW1wbGljaXQ6IG1pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyICdieXRlU3RyZWFtJ1wiO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGVsZW1lbnQgPSB7XG4gICAgICAgICAgICB0YWcgOiBkaWNvbVBhcnNlci5yZWFkVGFnKGJ5dGVTdHJlYW0pLFxuICAgICAgICAgICAgbGVuZ3RoOiBieXRlU3RyZWFtLnJlYWRVaW50MzIoKSxcbiAgICAgICAgICAgIGRhdGFPZmZzZXQgOiAgYnl0ZVN0cmVhbS5wb3NpdGlvblxuICAgICAgICB9O1xuXG4gICAgICAgIGlmKGVsZW1lbnQubGVuZ3RoID09PSA0Mjk0OTY3Mjk1KSB7XG4gICAgICAgICAgICBlbGVtZW50LmhhZFVuZGVmaW5lZExlbmd0aCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZihlbGVtZW50LnRhZyA9PT0gdW50aWxUYWcpIHtcbiAgICAgICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzU2VxdWVuY2UoZWxlbWVudCwgYnl0ZVN0cmVhbSwgdnJDYWxsYmFjaykpIHtcbiAgICAgICAgICAgIC8vIHBhcnNlIHRoZSBzZXF1ZW5jZVxuICAgICAgICAgICAgZGljb21QYXJzZXIucmVhZFNlcXVlbmNlSXRlbXNJbXBsaWNpdChieXRlU3RyZWFtLCBlbGVtZW50KTtcbiAgICAgICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgZWxlbWVudCBpcyBub3QgYSBzZXF1ZW5jZSBhbmQgaGFzIHVuZGVmaW5lZCBsZW5ndGgsIHdlIGhhdmUgdG9cbiAgICAgICAgLy8gc2NhbiB0aGUgZGF0YSBmb3IgYSBtYWdpYyBudW1iZXIgdG8gZmlndXJlIG91dCB3aGVuIGl0IGVuZHMuXG4gICAgICAgIGlmKGVsZW1lbnQuaGFkVW5kZWZpbmVkTGVuZ3RoKVxuICAgICAgICB7XG4gICAgICAgICAgICBkaWNvbVBhcnNlci5maW5kSXRlbURlbGltaXRhdGlvbkl0ZW1BbmRTZXRFbGVtZW50TGVuZ3RoKGJ5dGVTdHJlYW0sIGVsZW1lbnQpO1xuICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBub24gc2VxdWVuY2UgZWxlbWVudCB3aXRoIGtub3duIGxlbmd0aCwgc2tpcCBvdmVyIHRoZSBkYXRhIHBhcnRcbiAgICAgICAgYnl0ZVN0cmVhbS5zZWVrKGVsZW1lbnQubGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfTtcblxuXG4gICAgcmV0dXJuIGRpY29tUGFyc2VyO1xufShkaWNvbVBhcnNlcikpO1xuLyoqXG4gKiBGdW5jdGlvbmFsaXR5IGZvciBleHRyYWN0aW5nIGVuY2Fwc3VsYXRlZCBwaXhlbCBkYXRhXG4gKi9cblxudmFyIGRpY29tUGFyc2VyID0gKGZ1bmN0aW9uIChkaWNvbVBhcnNlcilcbntcbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgaWYoZGljb21QYXJzZXIgPT09IHVuZGVmaW5lZClcbiAge1xuICAgIGRpY29tUGFyc2VyID0ge307XG4gIH1cblxuICBmdW5jdGlvbiBmaW5kRnJhZ21lbnRJbmRleFdpdGhPZmZzZXQoZnJhZ21lbnRzLCBvZmZzZXQpIHtcbiAgICBmb3IodmFyIGk9MDsgaSA8IGZyYWdtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYoZnJhZ21lbnRzW2ldLm9mZnNldCA9PT0gb2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiBpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNhbGN1bGF0ZU51bWJlck9mRnJhZ21lbnRzRm9yRnJhbWUoZnJhbWVJbmRleCwgYmFzaWNPZmZzZXRUYWJsZSwgZnJhZ21lbnRzLCBzdGFydEZyYWdtZW50SW5kZXgpIHtcbiAgICAvLyBzcGVjaWFsIGNhc2UgZm9yIGxhc3QgZnJhbWVcbiAgICBpZihmcmFtZUluZGV4ID09PSBiYXNpY09mZnNldFRhYmxlLmxlbmd0aCAtMSkge1xuICAgICAgcmV0dXJuIGZyYWdtZW50cy5sZW5ndGggLSBzdGFydEZyYWdtZW50SW5kZXg7XG4gICAgfVxuXG4gICAgLy8gaXRlcmF0ZSB0aHJvdWdoIGVhY2ggZnJhZ21lbnQgbG9va2luZyBmb3IgdGhlIG9uZSBtYXRjaGluZyB0aGUgb2Zmc2V0IGZvciB0aGUgbmV4dCBmcmFtZVxuICAgIHZhciBuZXh0RnJhbWVPZmZzZXQgPSBiYXNpY09mZnNldFRhYmxlW2ZyYW1lSW5kZXggKyAxXTtcbiAgICBmb3IodmFyIGk9c3RhcnRGcmFnbWVudEluZGV4ICsgMTsgaSA8IGZyYWdtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYoZnJhZ21lbnRzW2ldLm9mZnNldCA9PT0gbmV4dEZyYW1lT2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiBpIC0gc3RhcnRGcmFnbWVudEluZGV4O1xuICAgICAgfVxuICAgIH1cblxuICAgIHRocm93IFwiZGljb21QYXJzZXIuY2FsY3VsYXRlTnVtYmVyT2ZGcmFnbWVudHNGb3JGcmFtZTogY291bGQgbm90IGZpbmQgZnJhZ21lbnQgd2l0aCBvZmZzZXQgbWF0Y2hpbmcgYmFzaWMgb2Zmc2V0IHRhYmxlXCI7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcGl4ZWwgZGF0YSBmb3IgdGhlIHNwZWNpZmllZCBmcmFtZSBpbiBhbiBlbmNhcHN1bGF0ZWQgcGl4ZWwgZGF0YSBlbGVtZW50IHRoYXQgaGFzIGEgbm9uXG4gICAqIGVtcHR5IGJhc2ljIG9mZnNldCB0YWJsZS4gIE5vdGUgdGhhdCB0aGlzIGZ1bmN0aW9uIHdpbGwgZmFpbCBpZiB0aGUgYmFzaWMgb2Zmc2V0IHRhYmxlIGlzIGVtcHR5IC0gaW4gdGhhdFxuICAgKiBjYXNlIHlvdSBuZWVkIHRvIGRldGVybWluZSB3aGljaCBmcmFnbWVudHMgbWFwIHRvIHdoaWNoIGZyYW1lcyBhbmQgcmVhZCB0aGVtIHVzaW5nXG4gICAqIHJlYWRFbmNhcHN1bGF0ZWRQaXhlbERhdGFGcm9tRnJhZ21lbnRzKCkuICBBbHNvIHNlZSB0aGUgZnVuY3Rpb24gY3JlYXRlSkVQR0Jhc2ljT2Zmc2V0VGFibGUoKSB0byBzZWVcbiAgICogaG93IGEgYmFzaWMgb2Zmc2V0IHRhYmxlIGNhbiBiZSBjcmVhdGVkIGZvciBKUEVHIGltYWdlc1xuICAgKlxuICAgKiBAcGFyYW0gZGF0YVNldCAtIHRoZSBkYXRhU2V0IGNvbnRhaW5pbmcgdGhlIGVuY2Fwc3VsYXRlZCBwaXhlbCBkYXRhXG4gICAqIEBwYXJhbSBwaXhlbERhdGFFbGVtZW50IC0gdGhlIHBpeGVsIGRhdGEgZWxlbWVudCAoeDdmZTAwMDEwKSB0byBleHRyYWN0IHRoZSBmcmFtZSBmcm9tXG4gICAqIEBwYXJhbSBmcmFtZUluZGV4IC0gdGhlIHplcm8gYmFzZWQgZnJhbWUgaW5kZXhcbiAgICogQHBhcmFtIFtiYXNpY09mZnNldFRhYmxlXSAtIG9wdGlvbmFsIGFycmF5IG9mIHN0YXJ0aW5nIG9mZnNldHMgZm9yIGZyYW1lc1xuICAgKiBAcGFyYW0gW2ZyYWdtZW50c10gLSBvcHRpb25hbCBhcnJheSBvZiBvYmplY3RzIGRlc2NyaWJpbmcgZWFjaCBmcmFnbWVudCAob2Zmc2V0LCBwb3NpdGlvbiwgbGVuZ3RoKVxuICAgKiBAcmV0dXJucyB7b2JqZWN0fSB3aXRoIHRoZSBlbmNhcHN1bGF0ZWQgcGl4ZWwgZGF0YVxuICAgKi9cbiAgZGljb21QYXJzZXIucmVhZEVuY2Fwc3VsYXRlZEltYWdlRnJhbWUgPSBmdW5jdGlvbihkYXRhU2V0LCBwaXhlbERhdGFFbGVtZW50LCBmcmFtZUluZGV4LCBiYXNpY09mZnNldFRhYmxlLCBmcmFnbWVudHMpXG4gIHtcbiAgICAvLyBkZWZhdWx0IHBhcmFtZXRlcnNcbiAgICBiYXNpY09mZnNldFRhYmxlID0gYmFzaWNPZmZzZXRUYWJsZSB8fCBwaXhlbERhdGFFbGVtZW50LmJhc2ljT2Zmc2V0VGFibGU7XG4gICAgZnJhZ21lbnRzID0gZnJhZ21lbnRzIHx8IHBpeGVsRGF0YUVsZW1lbnQuZnJhZ21lbnRzO1xuXG4gICAgLy8gVmFsaWRhdGUgcGFyYW1ldGVyc1xuICAgIGlmKGRhdGFTZXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgXCJkaWNvbVBhcnNlci5yZWFkRW5jYXBzdWxhdGVkSW1hZ2VGcmFtZTogbWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXIgJ2RhdGFTZXQnXCI7XG4gICAgfVxuICAgIGlmKHBpeGVsRGF0YUVsZW1lbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgXCJkaWNvbVBhcnNlci5yZWFkRW5jYXBzdWxhdGVkSW1hZ2VGcmFtZTogbWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXIgJ3BpeGVsRGF0YUVsZW1lbnQnXCI7XG4gICAgfVxuICAgIGlmKGZyYW1lSW5kZXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgXCJkaWNvbVBhcnNlci5yZWFkRW5jYXBzdWxhdGVkSW1hZ2VGcmFtZTogbWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXIgJ2ZyYW1lSW5kZXgnXCI7XG4gICAgfVxuICAgIGlmKGJhc2ljT2Zmc2V0VGFibGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgXCJkaWNvbVBhcnNlci5yZWFkRW5jYXBzdWxhdGVkSW1hZ2VGcmFtZTogcGFyYW1ldGVyICdwaXhlbERhdGFFbGVtZW50JyBkb2VzIG5vdCBoYXZlIGJhc2ljT2Zmc2V0VGFibGVcIjtcbiAgICB9XG4gICAgaWYocGl4ZWxEYXRhRWxlbWVudC50YWcgIT09ICd4N2ZlMDAwMTAnKSB7XG4gICAgICB0aHJvdyBcImRpY29tUGFyc2VyLnJlYWRFbmNhcHN1bGF0ZWRJbWFnZUZyYW1lOiBwYXJhbWV0ZXIgJ3BpeGVsRGF0YUVsZW1lbnQnIHJlZmVycyB0byBub24gcGl4ZWwgZGF0YSB0YWcgKGV4cGVjdGVkIHRhZyA9IHg3ZmUwMDAxMCdcIjtcbiAgICB9XG4gICAgaWYocGl4ZWxEYXRhRWxlbWVudC5lbmNhcHN1bGF0ZWRQaXhlbERhdGEgIT09IHRydWUpIHtcbiAgICAgIHRocm93IFwiZGljb21QYXJzZXIucmVhZEVuY2Fwc3VsYXRlZEltYWdlRnJhbWU6IHBhcmFtZXRlciAncGl4ZWxEYXRhRWxlbWVudCcgcmVmZXJzIHRvIHBpeGVsIGRhdGEgZWxlbWVudCB0aGF0IGRvZXMgbm90IGhhdmUgZW5jYXBzdWxhdGVkIHBpeGVsIGRhdGFcIjtcbiAgICB9XG4gICAgaWYocGl4ZWxEYXRhRWxlbWVudC5oYWRVbmRlZmluZWRMZW5ndGggIT09IHRydWUpIHtcbiAgICAgIHRocm93IFwiZGljb21QYXJzZXIucmVhZEVuY2Fwc3VsYXRlZEltYWdlRnJhbWU6IHBhcmFtZXRlciAncGl4ZWxEYXRhRWxlbWVudCcgcmVmZXJzIHRvIHBpeGVsIGRhdGEgZWxlbWVudCB0aGF0IGRvZXMgbm90IGhhdmUgdW5kZWZpbmVkIGxlbmd0aFwiO1xuICAgIH1cbiAgICBpZihwaXhlbERhdGFFbGVtZW50LmZyYWdtZW50cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBcImRpY29tUGFyc2VyLnJlYWRFbmNhcHN1bGF0ZWRJbWFnZUZyYW1lOiBwYXJhbWV0ZXIgJ3BpeGVsRGF0YUVsZW1lbnQnIHJlZmVycyB0byBwaXhlbCBkYXRhIGVsZW1lbnQgdGhhdCBkb2VzIG5vdCBoYXZlIGZyYWdtZW50c1wiO1xuICAgIH1cbiAgICBpZihiYXNpY09mZnNldFRhYmxlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgXCJkaWNvbVBhcnNlci5yZWFkRW5jYXBzdWxhdGVkSW1hZ2VGcmFtZTogYmFzaWNPZmZzZXRUYWJsZSBoYXMgemVybyBlbnRyaWVzXCI7XG4gICAgfVxuICAgIGlmKGZyYW1lSW5kZXggPCAwKSB7XG4gICAgICB0aHJvdyBcImRpY29tUGFyc2VyLnJlYWRFbmNhcHN1bGF0ZWRJbWFnZUZyYW1lOiBwYXJhbWV0ZXIgJ2ZyYW1lSW5kZXgnIG11c3QgYmUgPj0gMFwiO1xuICAgIH1cbiAgICBpZihmcmFtZUluZGV4ID49IGJhc2ljT2Zmc2V0VGFibGUubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBcImRpY29tUGFyc2VyLnJlYWRFbmNhcHN1bGF0ZWRJbWFnZUZyYW1lOiBwYXJhbWV0ZXIgJ2ZyYW1lSW5kZXgnIG11c3QgYmUgPCBiYXNpY09mZnNldFRhYmxlLmxlbmd0aFwiO1xuICAgIH1cblxuICAgIC8vIGZpbmQgc3RhcnRpbmcgZnJhZ21lbnQgYmFzZWQgb24gdGhlIG9mZnNldCBmb3IgdGhlIGZyYW1lIGluIHRoZSBiYXNpYyBvZmZzZXQgdGFibGVcbiAgICB2YXIgb2Zmc2V0ID0gYmFzaWNPZmZzZXRUYWJsZVtmcmFtZUluZGV4XTtcbiAgICB2YXIgc3RhcnRGcmFnbWVudEluZGV4ID0gZmluZEZyYWdtZW50SW5kZXhXaXRoT2Zmc2V0KGZyYWdtZW50cywgb2Zmc2V0KTtcbiAgICBpZihzdGFydEZyYWdtZW50SW5kZXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgXCJkaWNvbVBhcnNlci5yZWFkRW5jYXBzdWxhdGVkSW1hZ2VGcmFtZTogdW5hYmxlIHRvIGZpbmQgZnJhZ21lbnQgdGhhdCBtYXRjaGVzIGJhc2ljIG9mZnNldCB0YWJsZSBlbnRyeVwiO1xuICAgIH1cblxuICAgIC8vIGNhbGN1bGF0ZSB0aGUgbnVtYmVyIG9mIGZyYWdtZW50cyBmb3IgdGhpcyBmcmFtZVxuICAgIHZhciBudW1GcmFnbWVudHMgPSBjYWxjdWxhdGVOdW1iZXJPZkZyYWdtZW50c0ZvckZyYW1lKGZyYW1lSW5kZXgsIGJhc2ljT2Zmc2V0VGFibGUsIGZyYWdtZW50cywgc3RhcnRGcmFnbWVudEluZGV4KTtcblxuICAgIC8vIG5vdyBleHRyYWN0IHRoZSBmcmFtZSBmcm9tIHRoZSBmcmFnbWVudHNcbiAgICByZXR1cm4gZGljb21QYXJzZXIucmVhZEVuY2Fwc3VsYXRlZFBpeGVsRGF0YUZyb21GcmFnbWVudHMoZGF0YVNldCwgcGl4ZWxEYXRhRWxlbWVudCwgc3RhcnRGcmFnbWVudEluZGV4LCBudW1GcmFnbWVudHMsIGZyYWdtZW50cyk7XG4gIH07XG5cbiAgcmV0dXJuIGRpY29tUGFyc2VyO1xufShkaWNvbVBhcnNlcikpO1xuXG4vKipcbiAqIEZ1bmN0aW9uYWxpdHkgZm9yIGV4dHJhY3RpbmcgZW5jYXBzdWxhdGVkIHBpeGVsIGRhdGFcbiAqL1xuXG52YXIgZGljb21QYXJzZXIgPSAoZnVuY3Rpb24gKGRpY29tUGFyc2VyKVxue1xuICBcInVzZSBzdHJpY3RcIjtcblxuICBpZihkaWNvbVBhcnNlciA9PT0gdW5kZWZpbmVkKVxuICB7XG4gICAgZGljb21QYXJzZXIgPSB7fTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNhbGN1bGF0ZUJ1ZmZlclNpemUoZnJhZ21lbnRzLCBzdGFydEZyYWdtZW50LCBudW1GcmFnbWVudHMpIHtcbiAgICB2YXIgYnVmZmVyU2l6ZSA9IDA7XG4gICAgZm9yKHZhciBpPXN0YXJ0RnJhZ21lbnQ7IGkgPCBzdGFydEZyYWdtZW50ICsgbnVtRnJhZ21lbnRzOyBpKyspIHtcbiAgICAgIGJ1ZmZlclNpemUgKz0gZnJhZ21lbnRzW2ldLmxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIGJ1ZmZlclNpemU7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZW5jYXBzdWxhdGVkIHBpeGVsIGRhdGEgZnJvbSB0aGUgc3BlY2lmaWVkIGZyYWdtZW50cy4gIFVzZSB0aGlzIGZ1bmN0aW9uIHdoZW4geW91IGtub3dcbiAgICogdGhlIGZyYWdtZW50cyB5b3Ugd2FudCB0byBleHRyYWN0IGRhdGEgZnJvbS4gIFNlZVxuICAgKlxuICAgKiBAcGFyYW0gZGF0YVNldCAtIHRoZSBkYXRhU2V0IGNvbnRhaW5pbmcgdGhlIGVuY2Fwc3VsYXRlZCBwaXhlbCBkYXRhXG4gICAqIEBwYXJhbSBwaXhlbERhdGFFbGVtZW50IC0gdGhlIHBpeGVsIGRhdGEgZWxlbWVudCAoeDdmZTAwMDEwKSB0byBleHRyYWN0IHRoZSBmcmFnbWVudCBkYXRhIGZyb21cbiAgICogQHBhcmFtIHN0YXJ0RnJhZ21lbnRJbmRleCAtIHplcm8gYmFzZWQgaW5kZXggb2YgdGhlIGZpcnN0IGZyYWdtZW50IHRvIGV4dHJhY3QgZnJvbVxuICAgKiBAcGFyYW0gW251bUZyYWdtZW50c10gLSB0aGUgbnVtYmVyIG9mIGZyYWdtZW50cyB0byBleHRyYWN0IGZyb20sIGRlZmF1bHQgaXMgMVxuICAgKiBAcGFyYW0gW2ZyYWdtZW50c10gLSBvcHRpb25hbCBhcnJheSBvZiBvYmplY3RzIGRlc2NyaWJpbmcgZWFjaCBmcmFnbWVudCAob2Zmc2V0LCBwb3NpdGlvbiwgbGVuZ3RoKVxuICAgKiBAcmV0dXJucyB7b2JqZWN0fSBieXRlIGFycmF5IHdpdGggdGhlIGVuY2Fwc3VsYXRlZCBwaXhlbCBkYXRhXG4gICAqL1xuICBkaWNvbVBhcnNlci5yZWFkRW5jYXBzdWxhdGVkUGl4ZWxEYXRhRnJvbUZyYWdtZW50cyA9IGZ1bmN0aW9uKGRhdGFTZXQsIHBpeGVsRGF0YUVsZW1lbnQsIHN0YXJ0RnJhZ21lbnRJbmRleCwgbnVtRnJhZ21lbnRzLCBmcmFnbWVudHMpXG4gIHtcbiAgICAvLyBkZWZhdWx0IHZhbHVlc1xuICAgIG51bUZyYWdtZW50cyA9IG51bUZyYWdtZW50cyB8fCAxO1xuICAgIGZyYWdtZW50cyA9IGZyYWdtZW50cyB8fCBwaXhlbERhdGFFbGVtZW50LmZyYWdtZW50cztcblxuICAgIC8vIGNoZWNrIHBhcmFtZXRlcnNcbiAgICBpZihkYXRhU2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IFwiZGljb21QYXJzZXIucmVhZEVuY2Fwc3VsYXRlZFBpeGVsRGF0YUZyb21GcmFnbWVudHM6IG1pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyICdkYXRhU2V0J1wiO1xuICAgIH1cbiAgICBpZihwaXhlbERhdGFFbGVtZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IFwiZGljb21QYXJzZXIucmVhZEVuY2Fwc3VsYXRlZFBpeGVsRGF0YUZyb21GcmFnbWVudHM6IG1pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyICdwaXhlbERhdGFFbGVtZW50J1wiO1xuICAgIH1cbiAgICBpZihzdGFydEZyYWdtZW50SW5kZXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgXCJkaWNvbVBhcnNlci5yZWFkRW5jYXBzdWxhdGVkUGl4ZWxEYXRhRnJvbUZyYWdtZW50czogbWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXIgJ3N0YXJ0RnJhZ21lbnRJbmRleCdcIjtcbiAgICB9XG4gICAgaWYobnVtRnJhZ21lbnRzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IFwiZGljb21QYXJzZXIucmVhZEVuY2Fwc3VsYXRlZFBpeGVsRGF0YUZyb21GcmFnbWVudHM6IG1pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyICdudW1GcmFnbWVudHMnXCI7XG4gICAgfVxuICAgIGlmKHBpeGVsRGF0YUVsZW1lbnQudGFnICE9PSAneDdmZTAwMDEwJykge1xuICAgICAgdGhyb3cgXCJkaWNvbVBhcnNlci5yZWFkRW5jYXBzdWxhdGVkUGl4ZWxEYXRhRnJvbUZyYWdtZW50czogcGFyYW1ldGVyICdwaXhlbERhdGFFbGVtZW50JyByZWZlcnMgdG8gbm9uIHBpeGVsIGRhdGEgdGFnIChleHBlY3RlZCB0YWcgPSB4N2ZlMDAwMTAnXCI7XG4gICAgfVxuICAgIGlmKHBpeGVsRGF0YUVsZW1lbnQuZW5jYXBzdWxhdGVkUGl4ZWxEYXRhICE9PSB0cnVlKSB7XG4gICAgICB0aHJvdyBcImRpY29tUGFyc2VyLnJlYWRFbmNhcHN1bGF0ZWRQaXhlbERhdGFGcm9tRnJhZ21lbnRzOiBwYXJhbWV0ZXIgJ3BpeGVsRGF0YUVsZW1lbnQnIHJlZmVycyB0byBwaXhlbCBkYXRhIGVsZW1lbnQgdGhhdCBkb2VzIG5vdCBoYXZlIGVuY2Fwc3VsYXRlZCBwaXhlbCBkYXRhXCI7XG4gICAgfVxuICAgIGlmKHBpeGVsRGF0YUVsZW1lbnQuaGFkVW5kZWZpbmVkTGVuZ3RoICE9PSB0cnVlKSB7XG4gICAgICB0aHJvdyBcImRpY29tUGFyc2VyLnJlYWRFbmNhcHN1bGF0ZWRQaXhlbERhdGFGcm9tRnJhZ21lbnRzOiBwYXJhbWV0ZXIgJ3BpeGVsRGF0YUVsZW1lbnQnIHJlZmVycyB0byBwaXhlbCBkYXRhIGVsZW1lbnQgdGhhdCBkb2VzIG5vdCBoYXZlIGVuY2Fwc3VsYXRlZCBwaXhlbCBkYXRhXCI7XG4gICAgfVxuICAgIGlmKHBpeGVsRGF0YUVsZW1lbnQuYmFzaWNPZmZzZXRUYWJsZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBcImRpY29tUGFyc2VyLnJlYWRFbmNhcHN1bGF0ZWRQaXhlbERhdGFGcm9tRnJhZ21lbnRzOiBwYXJhbWV0ZXIgJ3BpeGVsRGF0YUVsZW1lbnQnIHJlZmVycyB0byBwaXhlbCBkYXRhIGVsZW1lbnQgdGhhdCBkb2VzIG5vdCBoYXZlIGVuY2Fwc3VsYXRlZCBwaXhlbCBkYXRhXCI7XG4gICAgfVxuICAgIGlmKHBpeGVsRGF0YUVsZW1lbnQuZnJhZ21lbnRzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IFwiZGljb21QYXJzZXIucmVhZEVuY2Fwc3VsYXRlZFBpeGVsRGF0YUZyb21GcmFnbWVudHM6IHBhcmFtZXRlciAncGl4ZWxEYXRhRWxlbWVudCcgcmVmZXJzIHRvIHBpeGVsIGRhdGEgZWxlbWVudCB0aGF0IGRvZXMgbm90IGhhdmUgZW5jYXBzdWxhdGVkIHBpeGVsIGRhdGFcIjtcbiAgICB9XG4gICAgaWYocGl4ZWxEYXRhRWxlbWVudC5mcmFnbWVudHMubGVuZ3RoIDw9IDApIHtcbiAgICAgIHRocm93IFwiZGljb21QYXJzZXIucmVhZEVuY2Fwc3VsYXRlZFBpeGVsRGF0YUZyb21GcmFnbWVudHM6IHBhcmFtZXRlciAncGl4ZWxEYXRhRWxlbWVudCcgcmVmZXJzIHRvIHBpeGVsIGRhdGEgZWxlbWVudCB0aGF0IGRvZXMgbm90IGhhdmUgZW5jYXBzdWxhdGVkIHBpeGVsIGRhdGFcIjtcbiAgICB9XG4gICAgaWYoc3RhcnRGcmFnbWVudEluZGV4IDwgMCkge1xuICAgICAgdGhyb3cgXCJkaWNvbVBhcnNlci5yZWFkRW5jYXBzdWxhdGVkUGl4ZWxEYXRhRnJvbUZyYWdtZW50czogcGFyYW1ldGVyICdzdGFydEZyYWdtZW50SW5kZXgnIG11c3QgYmUgPj0gMFwiO1xuICAgIH1cbiAgICBpZihzdGFydEZyYWdtZW50SW5kZXggPj0gcGl4ZWxEYXRhRWxlbWVudC5mcmFnbWVudHMubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBcImRpY29tUGFyc2VyLnJlYWRFbmNhcHN1bGF0ZWRQaXhlbERhdGFGcm9tRnJhZ21lbnRzOiBwYXJhbWV0ZXIgJ3N0YXJ0RnJhZ21lbnRJbmRleCcgbXVzdCBiZSA8IG51bWJlciBvZiBmcmFnbWVudHNcIjtcbiAgICB9XG4gICAgaWYobnVtRnJhZ21lbnRzIDwgMSkge1xuICAgICAgdGhyb3cgXCJkaWNvbVBhcnNlci5yZWFkRW5jYXBzdWxhdGVkUGl4ZWxEYXRhRnJvbUZyYWdtZW50czogcGFyYW1ldGVyICdudW1GcmFnbWVudHMnIG11c3QgYmUgPiAwXCI7XG4gICAgfVxuICAgIGlmKHN0YXJ0RnJhZ21lbnRJbmRleCArIG51bUZyYWdtZW50cyA+IHBpeGVsRGF0YUVsZW1lbnQuZnJhZ21lbnRzLmxlbmd0aCkge1xuICAgICAgdGhyb3cgXCJkaWNvbVBhcnNlci5yZWFkRW5jYXBzdWxhdGVkUGl4ZWxEYXRhRnJvbUZyYWdtZW50czogcGFyYW1ldGVyICdzdGFydEZyYWdtZW50JyArICdudW1GcmFnbWVudHMnIDwgbnVtYmVyIG9mIGZyYWdtZW50c1wiO1xuICAgIH1cblxuICAgIC8vIGNyZWF0ZSBieXRlIHN0cmVhbSBvbiB0aGUgZGF0YSBmb3IgdGhpcyBwaXhlbCBkYXRhIGVsZW1lbnRcbiAgICB2YXIgYnl0ZVN0cmVhbSA9IG5ldyBkaWNvbVBhcnNlci5CeXRlU3RyZWFtKGRhdGFTZXQuYnl0ZUFycmF5UGFyc2VyLCBkYXRhU2V0LmJ5dGVBcnJheSwgcGl4ZWxEYXRhRWxlbWVudC5kYXRhT2Zmc2V0KTtcblxuICAgIC8vIHNlZWsgcGFzdCB0aGUgYmFzaWMgb2Zmc2V0IHRhYmxlIChubyBuZWVkIHRvIHBhcnNlIGl0IGFnYWluIHNpbmNlIHdlIGFscmVhZHkgaGF2ZSlcbiAgICB2YXIgYmFzaWNPZmZzZXRUYWJsZSA9IGRpY29tUGFyc2VyLnJlYWRTZXF1ZW5jZUl0ZW0oYnl0ZVN0cmVhbSk7XG4gICAgaWYoYmFzaWNPZmZzZXRUYWJsZS50YWcgIT09ICd4ZmZmZWUwMDAnKVxuICAgIHtcbiAgICAgIHRocm93IFwiZGljb21QYXJzZXIucmVhZEVuY2Fwc3VsYXRlZFBpeGVsRGF0YTogbWlzc2luZyBiYXNpYyBvZmZzZXQgdGFibGUgeGZmZmVlMDAwXCI7XG4gICAgfVxuICAgIGJ5dGVTdHJlYW0uc2VlayhiYXNpY09mZnNldFRhYmxlLmxlbmd0aCk7XG5cbiAgICB2YXIgZnJhZ21lbnRaZXJvUG9zaXRpb24gPSBieXRlU3RyZWFtLnBvc2l0aW9uO1xuICAgIHZhciBmcmFnbWVudEhlYWRlclNpemUgPSA4OyAvLyB0YWcgKyBsZW5ndGhcblxuICAgIC8vIGlmIHRoZXJlIGlzIG9ubHkgb25lIGZyYWdtZW50LCByZXR1cm4gYSB2aWV3IG9uIHRoaXMgYXJyYXkgdG8gYXZvaWQgY29weWluZ1xuICAgIGlmKG51bUZyYWdtZW50cyA9PT0gMSkge1xuICAgICAgcmV0dXJuIGRpY29tUGFyc2VyLnNoYXJlZENvcHkoYnl0ZVN0cmVhbS5ieXRlQXJyYXksIGZyYWdtZW50WmVyb1Bvc2l0aW9uICsgZnJhZ21lbnRzW3N0YXJ0RnJhZ21lbnRJbmRleF0ub2Zmc2V0ICsgZnJhZ21lbnRIZWFkZXJTaXplLCBmcmFnbWVudHNbc3RhcnRGcmFnbWVudEluZGV4XS5sZW5ndGgpO1xuICAgIH1cblxuICAgIC8vIG1vcmUgdGhhbiBvbmUgZnJhZ21lbnQsIGNvbWJpbmUgYWxsIG9mIHRoZSBmcmFnbWVudHMgaW50byBvbmUgYnVmZmVyXG4gICAgdmFyIGJ1ZmZlclNpemUgPSBjYWxjdWxhdGVCdWZmZXJTaXplKGZyYWdtZW50cywgc3RhcnRGcmFnbWVudEluZGV4LCBudW1GcmFnbWVudHMpO1xuXG4gICAgdmFyIHBpeGVsRGF0YSA9IGRpY29tUGFyc2VyLmFsbG9jKGJ5dGVTdHJlYW0uYnl0ZUFycmF5LCBidWZmZXJTaXplKTtcblxuICAgIHZhciBwaXhlbERhdGFJbmRleCA9IDA7XG4gICAgZm9yKHZhciBpPXN0YXJ0RnJhZ21lbnRJbmRleDsgaSA8IHN0YXJ0RnJhZ21lbnRJbmRleCArIG51bUZyYWdtZW50czsgaSsrKSB7XG4gICAgICB2YXIgZnJhZ21lbnRPZmZzZXQgPSBmcmFnbWVudFplcm9Qb3NpdGlvbiArIGZyYWdtZW50c1tpXS5vZmZzZXQgKyBmcmFnbWVudEhlYWRlclNpemU7XG4gICAgICBmb3IodmFyIGo9MDsgaiA8IGZyYWdtZW50c1tpXS5sZW5ndGg7IGorKykge1xuICAgICAgICBwaXhlbERhdGFbcGl4ZWxEYXRhSW5kZXgrK10gPSBieXRlU3RyZWFtLmJ5dGVBcnJheVtmcmFnbWVudE9mZnNldCsrXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcGl4ZWxEYXRhO1xuICB9O1xuXG4gIHJldHVybiBkaWNvbVBhcnNlcjtcbn0oZGljb21QYXJzZXIpKTtcblxuLyoqXG4gKiBQYXJzZXMgYSBESUNPTSBQMTAgYnl0ZSBhcnJheSBhbmQgcmV0dXJucyBhIERhdGFTZXQgb2JqZWN0IHdpdGggdGhlIHBhcnNlZCBlbGVtZW50cy4gIElmIHRoZSBvcHRpb25zXG4gKiBhcmd1bWVudCBpcyBzdXBwbGllZCBhbmQgaXQgY29udGFpbnMgdGhlIHVudGlsVGFnIHByb3BlcnR5LCBwYXJzaW5nIHdpbGwgc3RvcCBvbmNlIHRoYXRcbiAqIHRhZyBpcyBlbmNvdXRlcmVkLiAgVGhpcyBjYW4gYmUgdXNlZCB0byBwYXJzZSBwYXJ0aWFsIGJ5dGUgc3RyZWFtcy5cbiAqXG4gKiBAcGFyYW0gYnl0ZUFycmF5IHRoZSBieXRlIGFycmF5XG4gKiBAcGFyYW0gb3B0aW9ucyBvYmplY3QgdG8gY29udHJvbCBwYXJzaW5nIGJlaGF2aW9yIChvcHRpb25hbClcbiAqIEByZXR1cm5zIHtEYXRhU2V0fVxuICogQHRocm93cyBlcnJvciBpZiBhbiBlcnJvciBvY2N1cnMgd2hpbGUgcGFyc2luZy4gIFRoZSBleGNlcHRpb24gb2JqZWN0IHdpbGwgY29udGFpbiBhIHByb3BlcnR5IGRhdGFTZXQgd2l0aCB0aGVcbiAqICAgICAgICAgZWxlbWVudHMgc3VjY2Vzc2Z1bGx5IHBhcnNlZCBiZWZvcmUgdGhlIGVycm9yLlxuICovXG52YXIgZGljb21QYXJzZXIgPSAoZnVuY3Rpb24oZGljb21QYXJzZXIpIHtcbiAgaWYoZGljb21QYXJzZXIgPT09IHVuZGVmaW5lZClcbiAge1xuICAgIGRpY29tUGFyc2VyID0ge307XG4gIH1cblxuICBkaWNvbVBhcnNlci5yZWFkUGFydDEwSGVhZGVyID0gZnVuY3Rpb24oYnl0ZUFycmF5LCBvcHRpb25zKSB7XG5cbiAgICBpZihieXRlQXJyYXkgPT09IHVuZGVmaW5lZClcbiAgICB7XG4gICAgICB0aHJvdyBcImRpY29tUGFyc2VyLnJlYWRQYXJ0MTBIZWFkZXI6IG1pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyICdieXRlQXJyYXknXCI7XG4gICAgfVxuXG4gICAgdmFyIGxpdHRsZUVuZGlhbkJ5dGVTdHJlYW0gPSBuZXcgZGljb21QYXJzZXIuQnl0ZVN0cmVhbShkaWNvbVBhcnNlci5saXR0bGVFbmRpYW5CeXRlQXJyYXlQYXJzZXIsIGJ5dGVBcnJheSk7XG5cbiAgICBmdW5jdGlvbiByZWFkUHJlZml4KClcbiAgICB7XG4gICAgICBsaXR0bGVFbmRpYW5CeXRlU3RyZWFtLnNlZWsoMTI4KTtcbiAgICAgIHZhciBwcmVmaXggPSBsaXR0bGVFbmRpYW5CeXRlU3RyZWFtLnJlYWRGaXhlZFN0cmluZyg0KTtcbiAgICAgIGlmKHByZWZpeCAhPT0gXCJESUNNXCIpXG4gICAgICB7XG4gICAgICAgIHRocm93IFwiZGljb21QYXJzZXIucmVhZFBhcnQxMEhlYWRlcjogRElDTSBwcmVmaXggbm90IGZvdW5kIGF0IGxvY2F0aW9uIDEzMiAtIHRoaXMgaXMgbm90IGEgdmFsaWQgRElDT00gUDEwIGZpbGUuXCI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gbWFpbiBmdW5jdGlvbiBoZXJlXG4gICAgZnVuY3Rpb24gcmVhZFRoZUhlYWRlcigpIHtcbiAgICAgIC8vIFBlciB0aGUgRElDT00gc3RhbmRhcmQsIHRoZSBoZWFkZXIgaXMgYWx3YXlzIGVuY29kZWQgaW4gRXhwbGljaXQgVlIgTGl0dGxlIEVuZGlhbiAoc2VlIFBTMy4xMCwgc2VjdGlvbiA3LjEpXG4gICAgICAvLyBzbyB1c2UgbGl0dGxlRW5kaWFuQnl0ZVN0cmVhbSB0aHJvdWdob3V0IHRoaXMgbWV0aG9kIHJlZ2FyZGxlc3Mgb2YgdGhlIHRyYW5zZmVyIHN5bnRheFxuICAgICAgcmVhZFByZWZpeCgpO1xuXG4gICAgICB2YXIgd2FybmluZ3MgPSBbXTtcbiAgICAgIHZhciBlbGVtZW50cyA9IHt9O1xuICAgICAgd2hpbGUobGl0dGxlRW5kaWFuQnl0ZVN0cmVhbS5wb3NpdGlvbiA8IGxpdHRsZUVuZGlhbkJ5dGVTdHJlYW0uYnl0ZUFycmF5Lmxlbmd0aCkge1xuICAgICAgICB2YXIgcG9zaXRpb24gPSBsaXR0bGVFbmRpYW5CeXRlU3RyZWFtLnBvc2l0aW9uO1xuICAgICAgICB2YXIgZWxlbWVudCA9IGRpY29tUGFyc2VyLnJlYWREaWNvbUVsZW1lbnRFeHBsaWNpdChsaXR0bGVFbmRpYW5CeXRlU3RyZWFtLCB3YXJuaW5ncyk7XG4gICAgICAgIGlmKGVsZW1lbnQudGFnID4gJ3gwMDAyZmZmZicpIHtcbiAgICAgICAgICBsaXR0bGVFbmRpYW5CeXRlU3RyZWFtLnBvc2l0aW9uID0gcG9zaXRpb247XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2FjaGUgdGhlIGxpdHRsZUVuZGlhbkJ5dGVBcnJheVBhcnNlciBmb3IgbWV0YSBoZWFkZXIgZWxlbWVudHMsIHNpbmNlIHRoZSByZXN0IG9mIHRoZSBkYXRhIHNldCBtYXkgYmUgYmlnIGVuZGlhblxuICAgICAgICAvLyBhbmQgdGhpcyBwYXJzZXIgd2lsbCBiZSBuZWVkZWQgbGF0ZXIgaWYgdGhlIG1ldGEgaGVhZGVyIHZhbHVlcyBhcmUgdG8gYmUgcmVhZC5cbiAgICAgICAgZWxlbWVudC5wYXJzZXIgPSBkaWNvbVBhcnNlci5saXR0bGVFbmRpYW5CeXRlQXJyYXlQYXJzZXI7XG4gICAgICAgIGVsZW1lbnRzW2VsZW1lbnQudGFnXSA9IGVsZW1lbnQ7XG4gICAgICB9XG4gICAgICB2YXIgbWV0YUhlYWRlckRhdGFTZXQgPSBuZXcgZGljb21QYXJzZXIuRGF0YVNldChsaXR0bGVFbmRpYW5CeXRlU3RyZWFtLmJ5dGVBcnJheVBhcnNlciwgbGl0dGxlRW5kaWFuQnl0ZVN0cmVhbS5ieXRlQXJyYXksIGVsZW1lbnRzKTtcbiAgICAgIG1ldGFIZWFkZXJEYXRhU2V0Lndhcm5pbmdzID0gbGl0dGxlRW5kaWFuQnl0ZVN0cmVhbS53YXJuaW5ncztcbiAgICAgIG1ldGFIZWFkZXJEYXRhU2V0LnBvc2l0aW9uID0gbGl0dGxlRW5kaWFuQnl0ZVN0cmVhbS5wb3NpdGlvbjtcbiAgICAgIHJldHVybiBtZXRhSGVhZGVyRGF0YVNldDtcbiAgICB9XG5cbiAgICAvLyBUaGlzIGlzIHdoZXJlIHdlIGFjdHVhbGx5IHN0YXJ0IHBhcnNpbmdcbiAgICByZXR1cm4gcmVhZFRoZUhlYWRlcigpO1xuICB9O1xuXG4gIHJldHVybiBkaWNvbVBhcnNlcjtcbn0pKGRpY29tUGFyc2VyKTtcblxuLyoqXG4gKiBJbnRlcm5hbCBoZWxwZXIgZnVuY3Rpb25zIGZvciBwYXJzaW5nIERJQ09NIGVsZW1lbnRzXG4gKi9cblxudmFyIGRpY29tUGFyc2VyID0gKGZ1bmN0aW9uIChkaWNvbVBhcnNlcilcbntcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGlmKGRpY29tUGFyc2VyID09PSB1bmRlZmluZWQpXG4gICAge1xuICAgICAgICBkaWNvbVBhcnNlciA9IHt9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlYWREaWNvbURhdGFTZXRFeHBsaWNpdFVuZGVmaW5lZExlbmd0aChieXRlU3RyZWFtLCB3YXJuaW5ncylcbiAgICB7XG4gICAgICAgIHZhciBlbGVtZW50cyA9IHt9O1xuXG4gICAgICAgIHdoaWxlKGJ5dGVTdHJlYW0ucG9zaXRpb24gPCBieXRlU3RyZWFtLmJ5dGVBcnJheS5sZW5ndGgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciBlbGVtZW50ID0gZGljb21QYXJzZXIucmVhZERpY29tRWxlbWVudEV4cGxpY2l0KGJ5dGVTdHJlYW0sIHdhcm5pbmdzKTtcbiAgICAgICAgICAgIGVsZW1lbnRzW2VsZW1lbnQudGFnXSA9IGVsZW1lbnQ7XG5cbiAgICAgICAgICAgIC8vIHdlIGhpdCBhbiBpdGVtIGRlbGltaXRlciB0YWcsIHJldHVybiB0aGUgY3VycmVudCBvZmZzZXQgdG8gbWFya1xuICAgICAgICAgICAgLy8gdGhlIGVuZCBvZiB0aGlzIHNlcXVlbmNlIGl0ZW1cbiAgICAgICAgICAgIGlmKGVsZW1lbnQudGFnID09PSAneGZmZmVlMDBkJylcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IGRpY29tUGFyc2VyLkRhdGFTZXQoYnl0ZVN0cmVhbS5ieXRlQXJyYXlQYXJzZXIsIGJ5dGVTdHJlYW0uYnl0ZUFycmF5LCBlbGVtZW50cyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGVvZiBlbmNvdW50ZXJlZCAtIGxvZyBhIHdhcm5pbmcgYW5kIHJldHVybiB3aGF0IHdlIGhhdmUgZm9yIHRoZSBlbGVtZW50XG4gICAgICAgIHdhcm5pbmdzLnB1c2goJ2VvZiBlbmNvdW50ZXJlZCBiZWZvcmUgZmluZGluZyBpdGVtIGRlbGltaXRlciB0YWcgd2hpbGUgcmVhZGluZyBzZXF1ZW5jZSBpdGVtIG9mIHVuZGVmaW5lZCBsZW5ndGgnKTtcbiAgICAgICAgcmV0dXJuIG5ldyBkaWNvbVBhcnNlci5EYXRhU2V0KGJ5dGVTdHJlYW0uYnl0ZUFycmF5UGFyc2VyLCBieXRlU3RyZWFtLmJ5dGVBcnJheSwgZWxlbWVudHMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlYWRTZXF1ZW5jZUl0ZW1FeHBsaWNpdChieXRlU3RyZWFtLCB3YXJuaW5ncylcbiAgICB7XG4gICAgICAgIHZhciBpdGVtID0gZGljb21QYXJzZXIucmVhZFNlcXVlbmNlSXRlbShieXRlU3RyZWFtKTtcblxuICAgICAgICBpZihpdGVtLmxlbmd0aCA9PT0gNDI5NDk2NzI5NSlcbiAgICAgICAge1xuICAgICAgICAgICAgaXRlbS5oYWRVbmRlZmluZWRMZW5ndGggPSB0cnVlO1xuICAgICAgICAgICAgaXRlbS5kYXRhU2V0ID0gcmVhZERpY29tRGF0YVNldEV4cGxpY2l0VW5kZWZpbmVkTGVuZ3RoKGJ5dGVTdHJlYW0sIHdhcm5pbmdzKTtcbiAgICAgICAgICAgIGl0ZW0ubGVuZ3RoID0gYnl0ZVN0cmVhbS5wb3NpdGlvbiAtIGl0ZW0uZGF0YU9mZnNldDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIGl0ZW0uZGF0YVNldCA9IG5ldyBkaWNvbVBhcnNlci5EYXRhU2V0KGJ5dGVTdHJlYW0uYnl0ZUFycmF5UGFyc2VyLCBieXRlU3RyZWFtLmJ5dGVBcnJheSwge30pO1xuICAgICAgICAgICAgZGljb21QYXJzZXIucGFyc2VEaWNvbURhdGFTZXRFeHBsaWNpdChpdGVtLmRhdGFTZXQsIGJ5dGVTdHJlYW0sIGJ5dGVTdHJlYW0ucG9zaXRpb24gKyBpdGVtLmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVhZFNRRWxlbWVudFVuZGVmaW5lZExlbmd0aEV4cGxpY2l0KGJ5dGVTdHJlYW0sIGVsZW1lbnQsIHdhcm5pbmdzKVxuICAgIHtcbiAgICAgICAgd2hpbGUoKGJ5dGVTdHJlYW0ucG9zaXRpb24gKyA0KSA8PSBieXRlU3RyZWFtLmJ5dGVBcnJheS5sZW5ndGgpXG4gICAgICAgIHtcbiAgICAgICAgICAvLyBlbmQgcmVhZGluZyB0aGlzIHNlcXVlbmNlIGlmIHRoZSBuZXh0IHRhZyBpcyB0aGUgc2VxdWVuY2UgZGVsaW1pdGF0aW9uIGl0ZW1cbiAgICAgICAgICB2YXIgbmV4dFRhZyA9IGRpY29tUGFyc2VyLnJlYWRUYWcoYnl0ZVN0cmVhbSk7XG4gICAgICAgICAgYnl0ZVN0cmVhbS5zZWVrKC00KTtcbiAgICAgICAgICBpZiAobmV4dFRhZyA9PT0gJ3hmZmZlZTBkZCcpIHtcbiAgICAgICAgICAgIC8vIHNldCB0aGUgY29ycmVjdCBsZW5ndGhcbiAgICAgICAgICAgIGVsZW1lbnQubGVuZ3RoID0gYnl0ZVN0cmVhbS5wb3NpdGlvbiAtIGVsZW1lbnQuZGF0YU9mZnNldDtcbiAgICAgICAgICAgIGJ5dGVTdHJlYW0uc2Vlayg4KTtcbiAgICAgICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGl0ZW0gPSByZWFkU2VxdWVuY2VJdGVtRXhwbGljaXQoYnl0ZVN0cmVhbSwgd2FybmluZ3MpO1xuICAgICAgICAgICAgZWxlbWVudC5pdGVtcy5wdXNoKGl0ZW0pO1xuICAgICAgICB9XG4gICAgICAgIHdhcm5pbmdzLnB1c2goJ2VvZiBlbmNvdW50ZXJlZCBiZWZvcmUgZmluZGluZyBzZXF1ZW5jZSBkZWxpbWl0YXRpb24gdGFnIHdoaWxlIHJlYWRpbmcgc2VxdWVuY2Ugb2YgdW5kZWZpbmVkIGxlbmd0aCcpO1xuICAgICAgICBlbGVtZW50Lmxlbmd0aCA9IGJ5dGVTdHJlYW0ucG9zaXRpb24gLSBlbGVtZW50LmRhdGFPZmZzZXQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVhZFNRRWxlbWVudEtub3duTGVuZ3RoRXhwbGljaXQoYnl0ZVN0cmVhbSwgZWxlbWVudCwgd2FybmluZ3MpXG4gICAge1xuICAgICAgICB2YXIgbWF4UG9zaXRpb24gPSBlbGVtZW50LmRhdGFPZmZzZXQgKyBlbGVtZW50Lmxlbmd0aDtcbiAgICAgICAgd2hpbGUoYnl0ZVN0cmVhbS5wb3NpdGlvbiA8IG1heFBvc2l0aW9uKVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgaXRlbSA9IHJlYWRTZXF1ZW5jZUl0ZW1FeHBsaWNpdChieXRlU3RyZWFtLCB3YXJuaW5ncyk7XG4gICAgICAgICAgICBlbGVtZW50Lml0ZW1zLnB1c2goaXRlbSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBkaWNvbVBhcnNlci5yZWFkU2VxdWVuY2VJdGVtc0V4cGxpY2l0ID0gZnVuY3Rpb24oYnl0ZVN0cmVhbSwgZWxlbWVudCwgd2FybmluZ3MpXG4gICAge1xuICAgICAgICBpZihieXRlU3RyZWFtID09PSB1bmRlZmluZWQpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRocm93IFwiZGljb21QYXJzZXIucmVhZFNlcXVlbmNlSXRlbXNFeHBsaWNpdDogbWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXIgJ2J5dGVTdHJlYW0nXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYoZWxlbWVudCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aHJvdyBcImRpY29tUGFyc2VyLnJlYWRTZXF1ZW5jZUl0ZW1zRXhwbGljaXQ6IG1pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyICdlbGVtZW50J1wiO1xuICAgICAgICB9XG5cbiAgICAgICAgZWxlbWVudC5pdGVtcyA9IFtdO1xuXG4gICAgICAgIGlmKGVsZW1lbnQubGVuZ3RoID09PSA0Mjk0OTY3Mjk1KVxuICAgICAgICB7XG4gICAgICAgICAgICByZWFkU1FFbGVtZW50VW5kZWZpbmVkTGVuZ3RoRXhwbGljaXQoYnl0ZVN0cmVhbSwgZWxlbWVudCwgd2FybmluZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgcmVhZFNRRWxlbWVudEtub3duTGVuZ3RoRXhwbGljaXQoYnl0ZVN0cmVhbSwgZWxlbWVudCwgd2FybmluZ3MpO1xuICAgICAgICB9XG4gICAgfTtcblxuXG4gICAgcmV0dXJuIGRpY29tUGFyc2VyO1xufShkaWNvbVBhcnNlcikpO1xuLyoqXG4gKiBJbnRlcm5hbCBoZWxwZXIgZnVuY3Rpb25zIGZvciBwYXJzaW5nIERJQ09NIGVsZW1lbnRzXG4gKi9cblxudmFyIGRpY29tUGFyc2VyID0gKGZ1bmN0aW9uIChkaWNvbVBhcnNlcilcbntcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGlmKGRpY29tUGFyc2VyID09PSB1bmRlZmluZWQpXG4gICAge1xuICAgICAgICBkaWNvbVBhcnNlciA9IHt9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlYWREaWNvbURhdGFTZXRJbXBsaWNpdFVuZGVmaW5lZExlbmd0aChieXRlU3RyZWFtLCB2ckNhbGxiYWNrKVxuICAgIHtcbiAgICAgICAgdmFyIGVsZW1lbnRzID0ge307XG5cbiAgICAgICAgd2hpbGUoYnl0ZVN0cmVhbS5wb3NpdGlvbiA8IGJ5dGVTdHJlYW0uYnl0ZUFycmF5Lmxlbmd0aClcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSBkaWNvbVBhcnNlci5yZWFkRGljb21FbGVtZW50SW1wbGljaXQoYnl0ZVN0cmVhbSwgdW5kZWZpbmVkLCB2ckNhbGxiYWNrKTtcbiAgICAgICAgICAgIGVsZW1lbnRzW2VsZW1lbnQudGFnXSA9IGVsZW1lbnQ7XG5cbiAgICAgICAgICAgIC8vIHdlIGhpdCBhbiBpdGVtIGRlbGltaXRlciB0YWcsIHJldHVybiB0aGUgY3VycmVudCBvZmZzZXQgdG8gbWFya1xuICAgICAgICAgICAgLy8gdGhlIGVuZCBvZiB0aGlzIHNlcXVlbmNlIGl0ZW1cbiAgICAgICAgICAgIGlmKGVsZW1lbnQudGFnID09PSAneGZmZmVlMDBkJylcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IGRpY29tUGFyc2VyLkRhdGFTZXQoYnl0ZVN0cmVhbS5ieXRlQXJyYXlQYXJzZXIsIGJ5dGVTdHJlYW0uYnl0ZUFycmF5LCBlbGVtZW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gZW9mIGVuY291bnRlcmVkIC0gbG9nIGEgd2FybmluZyBhbmQgcmV0dXJuIHdoYXQgd2UgaGF2ZSBmb3IgdGhlIGVsZW1lbnRcbiAgICAgICAgYnl0ZVN0cmVhbS53YXJuaW5ncy5wdXNoKCdlb2YgZW5jb3VudGVyZWQgYmVmb3JlIGZpbmRpbmcgc2VxdWVuY2UgaXRlbSBkZWxpbWl0ZXIgaW4gc2VxdWVuY2UgaXRlbSBvZiB1bmRlZmluZWQgbGVuZ3RoJyk7XG4gICAgICAgIHJldHVybiBuZXcgZGljb21QYXJzZXIuRGF0YVNldChieXRlU3RyZWFtLmJ5dGVBcnJheVBhcnNlciwgYnl0ZVN0cmVhbS5ieXRlQXJyYXksIGVsZW1lbnRzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZWFkU2VxdWVuY2VJdGVtSW1wbGljaXQoYnl0ZVN0cmVhbSwgdnJDYWxsYmFjaylcbiAgICB7XG4gICAgICAgIHZhciBpdGVtID0gZGljb21QYXJzZXIucmVhZFNlcXVlbmNlSXRlbShieXRlU3RyZWFtKTtcblxuICAgICAgICBpZihpdGVtLmxlbmd0aCA9PT0gNDI5NDk2NzI5NSlcbiAgICAgICAge1xuICAgICAgICAgICAgaXRlbS5oYWRVbmRlZmluZWRMZW5ndGggPSB0cnVlO1xuICAgICAgICAgICAgaXRlbS5kYXRhU2V0ID0gcmVhZERpY29tRGF0YVNldEltcGxpY2l0VW5kZWZpbmVkTGVuZ3RoKGJ5dGVTdHJlYW0sIHZyQ2FsbGJhY2spO1xuICAgICAgICAgICAgaXRlbS5sZW5ndGggPSBieXRlU3RyZWFtLnBvc2l0aW9uIC0gaXRlbS5kYXRhT2Zmc2V0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgaXRlbS5kYXRhU2V0ID0gbmV3IGRpY29tUGFyc2VyLkRhdGFTZXQoYnl0ZVN0cmVhbS5ieXRlQXJyYXlQYXJzZXIsIGJ5dGVTdHJlYW0uYnl0ZUFycmF5LCB7fSk7XG4gICAgICAgICAgICBkaWNvbVBhcnNlci5wYXJzZURpY29tRGF0YVNldEltcGxpY2l0KGl0ZW0uZGF0YVNldCwgYnl0ZVN0cmVhbSwgYnl0ZVN0cmVhbS5wb3NpdGlvbiArIGl0ZW0ubGVuZ3RoLCB7dnJDYWxsYmFjazogdnJDYWxsYmFja30pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpdGVtO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlYWRTUUVsZW1lbnRVbmRlZmluZWRMZW5ndGhJbXBsaWNpdChieXRlU3RyZWFtLCBlbGVtZW50LCB2ckNhbGxiYWNrKVxuICAgIHtcbiAgICAgICAgd2hpbGUoKGJ5dGVTdHJlYW0ucG9zaXRpb24gKyA0KSA8PSBieXRlU3RyZWFtLmJ5dGVBcnJheS5sZW5ndGgpXG4gICAgICAgIHtcbiAgICAgICAgICAvLyBlbmQgcmVhZGluZyB0aGlzIHNlcXVlbmNlIGlmIHRoZSBuZXh0IHRhZyBpcyB0aGUgc2VxdWVuY2UgZGVsaW1pdGF0aW9uIGl0ZW1cbiAgICAgICAgICB2YXIgbmV4dFRhZyA9IGRpY29tUGFyc2VyLnJlYWRUYWcoYnl0ZVN0cmVhbSk7XG4gICAgICAgICAgYnl0ZVN0cmVhbS5zZWVrKC00KTtcbiAgICAgICAgICBpZiAobmV4dFRhZyA9PT0gJ3hmZmZlZTBkZCcpIHtcbiAgICAgICAgICAgIC8vIHNldCB0aGUgY29ycmVjdCBsZW5ndGhcbiAgICAgICAgICAgIGVsZW1lbnQubGVuZ3RoID0gYnl0ZVN0cmVhbS5wb3NpdGlvbiAtIGVsZW1lbnQuZGF0YU9mZnNldDtcbiAgICAgICAgICAgIGJ5dGVTdHJlYW0uc2Vlayg4KTtcbiAgICAgICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBpdGVtID0gcmVhZFNlcXVlbmNlSXRlbUltcGxpY2l0KGJ5dGVTdHJlYW0sIHZyQ2FsbGJhY2spO1xuICAgICAgICAgIGVsZW1lbnQuaXRlbXMucHVzaChpdGVtKTtcbiAgICAgICAgfVxuICAgICAgICBieXRlU3RyZWFtLndhcm5pbmdzLnB1c2goJ2VvZiBlbmNvdW50ZXJlZCBiZWZvcmUgZmluZGluZyBzZXF1ZW5jZSBkZWxpbWl0ZXIgaW4gc2VxdWVuY2Ugb2YgdW5kZWZpbmVkIGxlbmd0aCcpO1xuICAgICAgICBlbGVtZW50Lmxlbmd0aCA9IGJ5dGVTdHJlYW0uYnl0ZUFycmF5Lmxlbmd0aCAtIGVsZW1lbnQuZGF0YU9mZnNldDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZWFkU1FFbGVtZW50S25vd25MZW5ndGhJbXBsaWNpdChieXRlU3RyZWFtLCBlbGVtZW50LCB2ckNhbGxiYWNrKVxuICAgIHtcbiAgICAgICAgdmFyIG1heFBvc2l0aW9uID0gZWxlbWVudC5kYXRhT2Zmc2V0ICsgZWxlbWVudC5sZW5ndGg7XG4gICAgICAgIHdoaWxlKGJ5dGVTdHJlYW0ucG9zaXRpb24gPCBtYXhQb3NpdGlvbilcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIGl0ZW0gPSByZWFkU2VxdWVuY2VJdGVtSW1wbGljaXQoYnl0ZVN0cmVhbSwgdnJDYWxsYmFjayk7XG4gICAgICAgICAgICBlbGVtZW50Lml0ZW1zLnB1c2goaXRlbSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWFkcyBzZXF1ZW5jZSBpdGVtcyBmb3IgYW4gZWxlbWVudCBpbiBhbiBpbXBsaWNpdCBsaXR0bGUgZW5kaWFuIGJ5dGUgc3RyZWFtXG4gICAgICogQHBhcmFtIGJ5dGVTdHJlYW0gdGhlIGltcGxpY2l0IGxpdHRsZSBlbmRpYW4gYnl0ZSBzdHJlYW1cbiAgICAgKiBAcGFyYW0gZWxlbWVudCB0aGUgZWxlbWVudCB0byByZWFkIHRoZSBzZXF1ZW5jZSBpdGVtcyBmb3JcbiAgICAgKiBAcGFyYW0gdnJDYWxsYmFjayBhbiBvcHRpb25hbCBtZXRob2QgdGhhdCByZXR1cm5zIGEgVlIgc3RyaW5nIGdpdmVuIGEgdGFnXG4gICAgICovXG4gICAgZGljb21QYXJzZXIucmVhZFNlcXVlbmNlSXRlbXNJbXBsaWNpdCA9IGZ1bmN0aW9uKGJ5dGVTdHJlYW0sIGVsZW1lbnQsIHZyQ2FsbGJhY2spXG4gICAge1xuICAgICAgICBpZihieXRlU3RyZWFtID09PSB1bmRlZmluZWQpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRocm93IFwiZGljb21QYXJzZXIucmVhZFNlcXVlbmNlSXRlbXNJbXBsaWNpdDogbWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXIgJ2J5dGVTdHJlYW0nXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYoZWxlbWVudCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aHJvdyBcImRpY29tUGFyc2VyLnJlYWRTZXF1ZW5jZUl0ZW1zSW1wbGljaXQ6IG1pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyICdlbGVtZW50J1wiO1xuICAgICAgICB9XG5cbiAgICAgICAgZWxlbWVudC5pdGVtcyA9IFtdO1xuXG4gICAgICAgIGlmKGVsZW1lbnQubGVuZ3RoID09PSA0Mjk0OTY3Mjk1KVxuICAgICAgICB7XG4gICAgICAgICAgICByZWFkU1FFbGVtZW50VW5kZWZpbmVkTGVuZ3RoSW1wbGljaXQoYnl0ZVN0cmVhbSwgZWxlbWVudCwgdnJDYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICByZWFkU1FFbGVtZW50S25vd25MZW5ndGhJbXBsaWNpdChieXRlU3RyZWFtLCBlbGVtZW50LCB2ckNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gZGljb21QYXJzZXI7XG59KGRpY29tUGFyc2VyKSk7XG4vKipcbiAqIEludGVybmFsIGhlbHBlciBmdW5jdGlvbnMgZm9yIHBhcnNpbmcgRElDT00gZWxlbWVudHNcbiAqL1xuXG52YXIgZGljb21QYXJzZXIgPSAoZnVuY3Rpb24gKGRpY29tUGFyc2VyKVxue1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgaWYoZGljb21QYXJzZXIgPT09IHVuZGVmaW5lZClcbiAgICB7XG4gICAgICAgIGRpY29tUGFyc2VyID0ge307XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVhZHMgdGhlIHRhZyBhbmQgbGVuZ3RoIG9mIGEgc2VxdWVuY2UgaXRlbSBhbmQgcmV0dXJucyB0aGVtIGFzIGFuIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllc1xuICAgICAqICB0YWcgOiBzdHJpbmcgZm9yIHRoZSB0YWcgb2YgdGhpcyBlbGVtZW50IGluIHRoZSBmb3JtYXQgeGdnZ2dlZWVlXG4gICAgICogIGxlbmd0aDogdGhlIG51bWJlciBvZiBieXRlcyBpbiB0aGlzIGl0ZW0gb3IgNDI5NDk2NzI5NSBpZiB1bmRlZmluZWRcbiAgICAgKiAgZGF0YU9mZnNldDogdGhlIG9mZnNldCBpbnRvIHRoZSBieXRlU3RyZWFtIG9mIHRoZSBkYXRhIGZvciB0aGlzIGl0ZW1cbiAgICAgKiBAcGFyYW0gYnl0ZVN0cmVhbSB0aGUgYnl0ZVxuICAgICAqIEByZXR1cm5zIHt7dGFnOiBzdHJpbmcsIGxlbmd0aDogaW50ZWdlciwgZGF0YU9mZnNldDogaW50ZWdlcn19XG4gICAgICovXG4gICAgZGljb21QYXJzZXIucmVhZFNlcXVlbmNlSXRlbSA9IGZ1bmN0aW9uKGJ5dGVTdHJlYW0pXG4gICAge1xuICAgICAgICBpZihieXRlU3RyZWFtID09PSB1bmRlZmluZWQpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRocm93IFwiZGljb21QYXJzZXIucmVhZFNlcXVlbmNlSXRlbTogbWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXIgJ2J5dGVTdHJlYW0nXCI7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZWxlbWVudCA9IHtcbiAgICAgICAgICAgIHRhZyA6IGRpY29tUGFyc2VyLnJlYWRUYWcoYnl0ZVN0cmVhbSksXG4gICAgICAgICAgICBsZW5ndGggOiBieXRlU3RyZWFtLnJlYWRVaW50MzIoKSxcbiAgICAgICAgICAgIGRhdGFPZmZzZXQgOiAgYnl0ZVN0cmVhbS5wb3NpdGlvblxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChlbGVtZW50LnRhZyAhPT0gJ3hmZmZlZTAwMCcpIHtcbiAgICAgICAgICAgIHZhciBzdGFydFBvc2l0aW9uID0gYnl0ZVN0cmVhbS5wb3NpdGlvbjtcbiAgICAgICAgICAgIHRocm93IFwiZGljb21QYXJzZXIucmVhZFNlcXVlbmNlSXRlbTogaXRlbSB0YWcgKEZGRkUsRTAwMCkgbm90IGZvdW5kIGF0IG9mZnNldCBcIiArIHN0YXJ0UG9zaXRpb247XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZWxlbWVudDtcbiAgICB9O1xuXG5cbiAgICByZXR1cm4gZGljb21QYXJzZXI7XG59KGRpY29tUGFyc2VyKSk7XG4vKipcbiAqIEludGVybmFsIGhlbHBlciBmdW5jdGlvbnMgZm9yIHBhcnNpbmcgRElDT00gZWxlbWVudHNcbiAqL1xuXG52YXIgZGljb21QYXJzZXIgPSAoZnVuY3Rpb24gKGRpY29tUGFyc2VyKVxue1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgaWYoZGljb21QYXJzZXIgPT09IHVuZGVmaW5lZClcbiAgICB7XG4gICAgICAgIGRpY29tUGFyc2VyID0ge307XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVhZHMgYSB0YWcgKGdyb3VwIG51bWJlciBhbmQgZWxlbWVudCBudW1iZXIpIGZyb20gYSBieXRlU3RyZWFtXG4gICAgICogQHBhcmFtIGJ5dGVTdHJlYW0gdGhlIGJ5dGUgc3RyZWFtIHRvIHJlYWQgZnJvbVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IHRoZSB0YWcgaW4gZm9ybWF0IHhnZ2dnZWVlZSB3aGVyZSBnZ2dnIGlzIHRoZSBsb3dlcmNhc2UgaGV4IHZhbHVlIG9mIHRoZSBncm91cCBudW1iZXJcbiAgICAgKiBhbmQgZWVlZSBpcyB0aGUgbG93ZXIgY2FzZSBoZXggdmFsdWUgb2YgdGhlIGVsZW1lbnQgbnVtYmVyXG4gICAgICovXG4gICAgZGljb21QYXJzZXIucmVhZFRhZyA9IGZ1bmN0aW9uKGJ5dGVTdHJlYW0pXG4gICAge1xuICAgICAgICBpZihieXRlU3RyZWFtID09PSB1bmRlZmluZWQpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRocm93IFwiZGljb21QYXJzZXIucmVhZFRhZzogbWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXIgJ2J5dGVTdHJlYW0nXCI7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZ3JvdXBOdW1iZXIgPSAgYnl0ZVN0cmVhbS5yZWFkVWludDE2KCkgKiAyNTYgKiAyNTY7XG4gICAgICAgIHZhciBlbGVtZW50TnVtYmVyID0gYnl0ZVN0cmVhbS5yZWFkVWludDE2KCk7XG4gICAgICAgIHZhciB0YWcgPSBcInhcIiArICgnMDAwMDAwMDAnICsgKGdyb3VwTnVtYmVyICsgZWxlbWVudE51bWJlcikudG9TdHJpbmcoMTYpKS5zdWJzdHIoLTgpO1xuICAgICAgICByZXR1cm4gdGFnO1xuICAgIH07XG5cbiAgICByZXR1cm4gZGljb21QYXJzZXI7XG59KGRpY29tUGFyc2VyKSk7XG4vKipcbiAqXG4gKiBJbnRlcm5hbCBoZWxwZXIgZnVuY3Rpb24gdG8gY3JlYXRlIGEgc2hhcmVkIGNvcHkgb2YgYSBieXRlQXJyYXlcbiAqXG4gKi9cbnZhciBkaWNvbVBhcnNlciA9IChmdW5jdGlvbiAoZGljb21QYXJzZXIpXG57XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIGlmKGRpY29tUGFyc2VyID09PSB1bmRlZmluZWQpXG4gIHtcbiAgICBkaWNvbVBhcnNlciA9IHt9O1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSB2aWV3IG9mIHRoZSB1bmRlcmx5aW5nIGJ5dGVBcnJheS4gIFRoZSB2aWV3IGlzIG9mIHRoZSBzYW1lIHR5cGUgYXMgdGhlIGJ5dGVBcnJheSAoZS5nLlxuICAgKiBVaW50OEFycmF5IG9yIEJ1ZmZlcikgYW5kIHNoYXJlcyB0aGUgc2FtZSB1bmRlcmx5aW5nIG1lbW9yeSAoY2hhbmdpbmcgb25lIGNoYW5nZXMgdGhlIG90aGVyKVxuICAgKiBAcGFyYW0gYnl0ZUFycmF5IHRoZSB1bmRlcmx5aW5nIGJ5dGVBcnJheSAoZWl0aGVyIFVpbnQ4QXJyYXkgb3IgQnVmZmVyKVxuICAgKiBAcGFyYW0gYnl0ZU9mZnNldCBvZmZzZXQgaW50byB0aGUgdW5kZXJseWluZyBieXRlQXJyYXkgdG8gY3JlYXRlIHRoZSB2aWV3IG9mXG4gICAqIEBwYXJhbSBsZW5ndGggbnVtYmVyIG9mIGJ5dGVzIGluIHRoZSB2aWV3XG4gICAqIEByZXR1cm5zIHtvYmplY3R9IFVpbnQ4QXJyYXkgb3IgQnVmZmVyIGRlcGVuZGluZyBvbiB0aGUgdHlwZSBvZiBieXRlQXJyYXlcbiAgICovXG4gIGRpY29tUGFyc2VyLnNoYXJlZENvcHkgPSBmdW5jdGlvbihieXRlQXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICAgIGlmICh0eXBlb2YgQnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiBieXRlQXJyYXkgaW5zdGFuY2VvZiBCdWZmZXIpIHtcbiAgICAgIHJldHVybiBieXRlQXJyYXkuc2xpY2UoYnl0ZU9mZnNldCwgYnl0ZU9mZnNldCArIGxlbmd0aCk7XG4gICAgfVxuICAgIGVsc2UgaWYoYnl0ZUFycmF5IGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGJ5dGVBcnJheS5idWZmZXIsIGJ5dGVBcnJheS5ieXRlT2Zmc2V0ICsgYnl0ZU9mZnNldCwgbGVuZ3RoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgJ2RpY29tUGFyc2VyLmZyb206IHVua25vd24gdHlwZSBmb3IgYnl0ZUFycmF5JztcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIGRpY29tUGFyc2VyO1xufShkaWNvbVBhcnNlcikpO1xuLyoqXG4gKiBWZXJzaW9uXG4gKi9cblxudmFyIGRpY29tUGFyc2VyID0gKGZ1bmN0aW9uIChkaWNvbVBhcnNlcilcbntcbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgaWYoZGljb21QYXJzZXIgPT09IHVuZGVmaW5lZClcbiAge1xuICAgIGRpY29tUGFyc2VyID0ge307XG4gIH1cblxuICBkaWNvbVBhcnNlci52ZXJzaW9uID0gXCIxLjcuM1wiO1xuXG4gIHJldHVybiBkaWNvbVBhcnNlcjtcbn0oZGljb21QYXJzZXIpKTtcbiAgICByZXR1cm4gZGljb21QYXJzZXI7XG59KSk7XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICB0aGlzLl9ldmVudHMgPSB0aGlzLl9ldmVudHMgfHwge307XG4gIHRoaXMuX21heExpc3RlbmVycyA9IHRoaXMuX21heExpc3RlbmVycyB8fCB1bmRlZmluZWQ7XG59XG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjtcblxuLy8gQmFja3dhcmRzLWNvbXBhdCB3aXRoIG5vZGUgMC4xMC54XG5FdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9ldmVudHMgPSB1bmRlZmluZWQ7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9tYXhMaXN0ZW5lcnMgPSB1bmRlZmluZWQ7XG5cbi8vIEJ5IGRlZmF1bHQgRXZlbnRFbWl0dGVycyB3aWxsIHByaW50IGEgd2FybmluZyBpZiBtb3JlIHRoYW4gMTAgbGlzdGVuZXJzIGFyZVxuLy8gYWRkZWQgdG8gaXQuIFRoaXMgaXMgYSB1c2VmdWwgZGVmYXVsdCB3aGljaCBoZWxwcyBmaW5kaW5nIG1lbW9yeSBsZWFrcy5cbkV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzID0gMTA7XG5cbi8vIE9idmlvdXNseSBub3QgYWxsIEVtaXR0ZXJzIHNob3VsZCBiZSBsaW1pdGVkIHRvIDEwLiBUaGlzIGZ1bmN0aW9uIGFsbG93c1xuLy8gdGhhdCB0byBiZSBpbmNyZWFzZWQuIFNldCB0byB6ZXJvIGZvciB1bmxpbWl0ZWQuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnNldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uKG4pIHtcbiAgaWYgKCFpc051bWJlcihuKSB8fCBuIDwgMCB8fCBpc05hTihuKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ24gbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlcicpO1xuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSBuO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgdmFyIGVyLCBoYW5kbGVyLCBsZW4sIGFyZ3MsIGksIGxpc3RlbmVycztcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcblxuICAvLyBJZiB0aGVyZSBpcyBubyAnZXJyb3InIGV2ZW50IGxpc3RlbmVyIHRoZW4gdGhyb3cuXG4gIGlmICh0eXBlID09PSAnZXJyb3InKSB7XG4gICAgaWYgKCF0aGlzLl9ldmVudHMuZXJyb3IgfHxcbiAgICAgICAgKGlzT2JqZWN0KHRoaXMuX2V2ZW50cy5lcnJvcikgJiYgIXRoaXMuX2V2ZW50cy5lcnJvci5sZW5ndGgpKSB7XG4gICAgICBlciA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIGlmIChlciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQXQgbGVhc3QgZ2l2ZSBzb21lIGtpbmQgb2YgY29udGV4dCB0byB0aGUgdXNlclxuICAgICAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdVbmNhdWdodCwgdW5zcGVjaWZpZWQgXCJlcnJvclwiIGV2ZW50LiAoJyArIGVyICsgJyknKTtcbiAgICAgICAgZXJyLmNvbnRleHQgPSBlcjtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGhhbmRsZXIgPSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgaWYgKGlzVW5kZWZpbmVkKGhhbmRsZXIpKVxuICAgIHJldHVybiBmYWxzZTtcblxuICBpZiAoaXNGdW5jdGlvbihoYW5kbGVyKSkge1xuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgLy8gZmFzdCBjYXNlc1xuICAgICAgY2FzZSAxOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcywgYXJndW1lbnRzWzFdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDM6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzLCBhcmd1bWVudHNbMV0sIGFyZ3VtZW50c1syXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgLy8gc2xvd2VyXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgaGFuZGxlci5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QoaGFuZGxlcikpIHtcbiAgICBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICBsaXN0ZW5lcnMgPSBoYW5kbGVyLnNsaWNlKCk7XG4gICAgbGVuID0gbGlzdGVuZXJzLmxlbmd0aDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspXG4gICAgICBsaXN0ZW5lcnNbaV0uYXBwbHkodGhpcywgYXJncyk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgbTtcblxuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpXG4gICAgdGhpcy5fZXZlbnRzID0ge307XG5cbiAgLy8gVG8gYXZvaWQgcmVjdXJzaW9uIGluIHRoZSBjYXNlIHRoYXQgdHlwZSA9PT0gXCJuZXdMaXN0ZW5lclwiISBCZWZvcmVcbiAgLy8gYWRkaW5nIGl0IHRvIHRoZSBsaXN0ZW5lcnMsIGZpcnN0IGVtaXQgXCJuZXdMaXN0ZW5lclwiLlxuICBpZiAodGhpcy5fZXZlbnRzLm5ld0xpc3RlbmVyKVxuICAgIHRoaXMuZW1pdCgnbmV3TGlzdGVuZXInLCB0eXBlLFxuICAgICAgICAgICAgICBpc0Z1bmN0aW9uKGxpc3RlbmVyLmxpc3RlbmVyKSA/XG4gICAgICAgICAgICAgIGxpc3RlbmVyLmxpc3RlbmVyIDogbGlzdGVuZXIpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgIC8vIE9wdGltaXplIHRoZSBjYXNlIG9mIG9uZSBsaXN0ZW5lci4gRG9uJ3QgbmVlZCB0aGUgZXh0cmEgYXJyYXkgb2JqZWN0LlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXSA9IGxpc3RlbmVyO1xuICBlbHNlIGlmIChpc09iamVjdCh0aGlzLl9ldmVudHNbdHlwZV0pKVxuICAgIC8vIElmIHdlJ3ZlIGFscmVhZHkgZ290IGFuIGFycmF5LCBqdXN0IGFwcGVuZC5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0ucHVzaChsaXN0ZW5lcik7XG4gIGVsc2VcbiAgICAvLyBBZGRpbmcgdGhlIHNlY29uZCBlbGVtZW50LCBuZWVkIHRvIGNoYW5nZSB0byBhcnJheS5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0gPSBbdGhpcy5fZXZlbnRzW3R5cGVdLCBsaXN0ZW5lcl07XG5cbiAgLy8gQ2hlY2sgZm9yIGxpc3RlbmVyIGxlYWtcbiAgaWYgKGlzT2JqZWN0KHRoaXMuX2V2ZW50c1t0eXBlXSkgJiYgIXRoaXMuX2V2ZW50c1t0eXBlXS53YXJuZWQpIHtcbiAgICBpZiAoIWlzVW5kZWZpbmVkKHRoaXMuX21heExpc3RlbmVycykpIHtcbiAgICAgIG0gPSB0aGlzLl9tYXhMaXN0ZW5lcnM7XG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSBFdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycztcbiAgICB9XG5cbiAgICBpZiAobSAmJiBtID4gMCAmJiB0aGlzLl9ldmVudHNbdHlwZV0ubGVuZ3RoID4gbSkge1xuICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdLndhcm5lZCA9IHRydWU7XG4gICAgICBjb25zb2xlLmVycm9yKCcobm9kZSkgd2FybmluZzogcG9zc2libGUgRXZlbnRFbWl0dGVyIG1lbW9yeSAnICtcbiAgICAgICAgICAgICAgICAgICAgJ2xlYWsgZGV0ZWN0ZWQuICVkIGxpc3RlbmVycyBhZGRlZC4gJyArXG4gICAgICAgICAgICAgICAgICAgICdVc2UgZW1pdHRlci5zZXRNYXhMaXN0ZW5lcnMoKSB0byBpbmNyZWFzZSBsaW1pdC4nLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9ldmVudHNbdHlwZV0ubGVuZ3RoKTtcbiAgICAgIGlmICh0eXBlb2YgY29uc29sZS50cmFjZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBub3Qgc3VwcG9ydGVkIGluIElFIDEwXG4gICAgICAgIGNvbnNvbGUudHJhY2UoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgdmFyIGZpcmVkID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gZygpIHtcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGcpO1xuXG4gICAgaWYgKCFmaXJlZCkge1xuICAgICAgZmlyZWQgPSB0cnVlO1xuICAgICAgbGlzdGVuZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gIH1cblxuICBnLmxpc3RlbmVyID0gbGlzdGVuZXI7XG4gIHRoaXMub24odHlwZSwgZyk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBlbWl0cyBhICdyZW1vdmVMaXN0ZW5lcicgZXZlbnQgaWZmIHRoZSBsaXN0ZW5lciB3YXMgcmVtb3ZlZFxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBsaXN0LCBwb3NpdGlvbiwgbGVuZ3RoLCBpO1xuXG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50cyB8fCAhdGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIGxpc3QgPSB0aGlzLl9ldmVudHNbdHlwZV07XG4gIGxlbmd0aCA9IGxpc3QubGVuZ3RoO1xuICBwb3NpdGlvbiA9IC0xO1xuXG4gIGlmIChsaXN0ID09PSBsaXN0ZW5lciB8fFxuICAgICAgKGlzRnVuY3Rpb24obGlzdC5saXN0ZW5lcikgJiYgbGlzdC5saXN0ZW5lciA9PT0gbGlzdGVuZXIpKSB7XG4gICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICBpZiAodGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3RlbmVyKTtcblxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KGxpc3QpKSB7XG4gICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gPiAwOykge1xuICAgICAgaWYgKGxpc3RbaV0gPT09IGxpc3RlbmVyIHx8XG4gICAgICAgICAgKGxpc3RbaV0ubGlzdGVuZXIgJiYgbGlzdFtpXS5saXN0ZW5lciA9PT0gbGlzdGVuZXIpKSB7XG4gICAgICAgIHBvc2l0aW9uID0gaTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHBvc2l0aW9uIDwgMClcbiAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgaWYgKGxpc3QubGVuZ3RoID09PSAxKSB7XG4gICAgICBsaXN0Lmxlbmd0aCA9IDA7XG4gICAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIH0gZWxzZSB7XG4gICAgICBsaXN0LnNwbGljZShwb3NpdGlvbiwgMSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0ZW5lcik7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIga2V5LCBsaXN0ZW5lcnM7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgLy8gbm90IGxpc3RlbmluZyBmb3IgcmVtb3ZlTGlzdGVuZXIsIG5vIG5lZWQgdG8gZW1pdFxuICBpZiAoIXRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcikge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKVxuICAgICAgdGhpcy5fZXZlbnRzID0ge307XG4gICAgZWxzZSBpZiAodGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIGVtaXQgcmVtb3ZlTGlzdGVuZXIgZm9yIGFsbCBsaXN0ZW5lcnMgb24gYWxsIGV2ZW50c1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIGZvciAoa2V5IGluIHRoaXMuX2V2ZW50cykge1xuICAgICAgaWYgKGtleSA9PT0gJ3JlbW92ZUxpc3RlbmVyJykgY29udGludWU7XG4gICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhrZXkpO1xuICAgIH1cbiAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygncmVtb3ZlTGlzdGVuZXInKTtcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICBpZiAoaXNGdW5jdGlvbihsaXN0ZW5lcnMpKSB7XG4gICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnMpO1xuICB9IGVsc2UgaWYgKGxpc3RlbmVycykge1xuICAgIC8vIExJRk8gb3JkZXJcbiAgICB3aGlsZSAobGlzdGVuZXJzLmxlbmd0aClcbiAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzW2xpc3RlbmVycy5sZW5ndGggLSAxXSk7XG4gIH1cbiAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIgcmV0O1xuICBpZiAoIXRoaXMuX2V2ZW50cyB8fCAhdGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgIHJldCA9IFtdO1xuICBlbHNlIGlmIChpc0Z1bmN0aW9uKHRoaXMuX2V2ZW50c1t0eXBlXSkpXG4gICAgcmV0ID0gW3RoaXMuX2V2ZW50c1t0eXBlXV07XG4gIGVsc2VcbiAgICByZXQgPSB0aGlzLl9ldmVudHNbdHlwZV0uc2xpY2UoKTtcbiAgcmV0dXJuIHJldDtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgaWYgKHRoaXMuX2V2ZW50cykge1xuICAgIHZhciBldmxpc3RlbmVyID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gICAgaWYgKGlzRnVuY3Rpb24oZXZsaXN0ZW5lcikpXG4gICAgICByZXR1cm4gMTtcbiAgICBlbHNlIGlmIChldmxpc3RlbmVyKVxuICAgICAgcmV0dXJuIGV2bGlzdGVuZXIubGVuZ3RoO1xuICB9XG4gIHJldHVybiAwO1xufTtcblxuRXZlbnRFbWl0dGVyLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbihlbWl0dGVyLCB0eXBlKSB7XG4gIHJldHVybiBlbWl0dGVyLmxpc3RlbmVyQ291bnQodHlwZSk7XG59O1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcbn1cblxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG59XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09PSB2b2lkIDA7XG59XG4iLCJleHBvcnRzLnJlYWQgPSBmdW5jdGlvbiAoYnVmZmVyLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbVxuICB2YXIgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIG5CaXRzID0gLTdcbiAgdmFyIGkgPSBpc0xFID8gKG5CeXRlcyAtIDEpIDogMFxuICB2YXIgZCA9IGlzTEUgPyAtMSA6IDFcbiAgdmFyIHMgPSBidWZmZXJbb2Zmc2V0ICsgaV1cblxuICBpICs9IGRcblxuICBlID0gcyAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBzID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBlTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IGUgPSBlICogMjU2ICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgbSA9IGUgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgZSA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gbUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBtID0gbSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIGlmIChlID09PSAwKSB7XG4gICAgZSA9IDEgLSBlQmlhc1xuICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHtcbiAgICByZXR1cm4gbSA/IE5hTiA6ICgocyA/IC0xIDogMSkgKiBJbmZpbml0eSlcbiAgfSBlbHNlIHtcbiAgICBtID0gbSArIE1hdGgucG93KDIsIG1MZW4pXG4gICAgZSA9IGUgLSBlQmlhc1xuICB9XG4gIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogTWF0aC5wb3coMiwgZSAtIG1MZW4pXG59XG5cbmV4cG9ydHMud3JpdGUgPSBmdW5jdGlvbiAoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG0sIGNcbiAgdmFyIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBydCA9IChtTGVuID09PSAyMyA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMClcbiAgdmFyIGkgPSBpc0xFID8gMCA6IChuQnl0ZXMgLSAxKVxuICB2YXIgZCA9IGlzTEUgPyAxIDogLTFcbiAgdmFyIHMgPSB2YWx1ZSA8IDAgfHwgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDApID8gMSA6IDBcblxuICB2YWx1ZSA9IE1hdGguYWJzKHZhbHVlKVxuXG4gIGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgbSA9IGlzTmFOKHZhbHVlKSA/IDEgOiAwXG4gICAgZSA9IGVNYXhcbiAgfSBlbHNlIHtcbiAgICBlID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMilcbiAgICBpZiAodmFsdWUgKiAoYyA9IE1hdGgucG93KDIsIC1lKSkgPCAxKSB7XG4gICAgICBlLS1cbiAgICAgIGMgKj0gMlxuICAgIH1cbiAgICBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIHZhbHVlICs9IHJ0IC8gY1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSArPSBydCAqIE1hdGgucG93KDIsIDEgLSBlQmlhcylcbiAgICB9XG4gICAgaWYgKHZhbHVlICogYyA+PSAyKSB7XG4gICAgICBlKytcbiAgICAgIGMgLz0gMlxuICAgIH1cblxuICAgIGlmIChlICsgZUJpYXMgPj0gZU1heCkge1xuICAgICAgbSA9IDBcbiAgICAgIGUgPSBlTWF4XG4gICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgbSA9ICh2YWx1ZSAqIGMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gZSArIGVCaWFzXG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSB2YWx1ZSAqIE1hdGgucG93KDIsIGVCaWFzIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IDBcbiAgICB9XG4gIH1cblxuICBmb3IgKDsgbUxlbiA+PSA4OyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBtICYgMHhmZiwgaSArPSBkLCBtIC89IDI1NiwgbUxlbiAtPSA4KSB7fVxuXG4gIGUgPSAoZSA8PCBtTGVuKSB8IG1cbiAgZUxlbiArPSBtTGVuXG4gIGZvciAoOyBlTGVuID4gMDsgYnVmZmVyW29mZnNldCArIGldID0gZSAmIDB4ZmYsIGkgKz0gZCwgZSAvPSAyNTYsIGVMZW4gLT0gOCkge31cblxuICBidWZmZXJbb2Zmc2V0ICsgaSAtIGRdIHw9IHMgKiAxMjhcbn1cbiIsImlmICh0eXBlb2YgT2JqZWN0LmNyZWF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAvLyBpbXBsZW1lbnRhdGlvbiBmcm9tIHN0YW5kYXJkIG5vZGUuanMgJ3V0aWwnIG1vZHVsZVxuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgY3Rvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ3Rvci5wcm90b3R5cGUsIHtcbiAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgIHZhbHVlOiBjdG9yLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfVxuICAgIH0pO1xuICB9O1xufSBlbHNlIHtcbiAgLy8gb2xkIHNjaG9vbCBzaGltIGZvciBvbGQgYnJvd3NlcnNcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgIHZhciBUZW1wQ3RvciA9IGZ1bmN0aW9uICgpIHt9XG4gICAgVGVtcEN0b3IucHJvdG90eXBlID0gc3VwZXJDdG9yLnByb3RvdHlwZVxuICAgIGN0b3IucHJvdG90eXBlID0gbmV3IFRlbXBDdG9yKClcbiAgICBjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGN0b3JcbiAgfVxufVxuIiwiLyohXG4gKiBEZXRlcm1pbmUgaWYgYW4gb2JqZWN0IGlzIGEgQnVmZmVyXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGZlcm9zc0BmZXJvc3Mub3JnPiA8aHR0cDovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cblxuLy8gVGhlIF9pc0J1ZmZlciBjaGVjayBpcyBmb3IgU2FmYXJpIDUtNyBzdXBwb3J0LCBiZWNhdXNlIGl0J3MgbWlzc2luZ1xuLy8gT2JqZWN0LnByb3RvdHlwZS5jb25zdHJ1Y3Rvci4gUmVtb3ZlIHRoaXMgZXZlbnR1YWxseVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiBvYmogIT0gbnVsbCAmJiAoaXNCdWZmZXIob2JqKSB8fCBpc1Nsb3dCdWZmZXIob2JqKSB8fCAhIW9iai5faXNCdWZmZXIpXG59XG5cbmZ1bmN0aW9uIGlzQnVmZmVyIChvYmopIHtcbiAgcmV0dXJuICEhb2JqLmNvbnN0cnVjdG9yICYmIHR5cGVvZiBvYmouY29uc3RydWN0b3IuaXNCdWZmZXIgPT09ICdmdW5jdGlvbicgJiYgb2JqLmNvbnN0cnVjdG9yLmlzQnVmZmVyKG9iailcbn1cblxuLy8gRm9yIE5vZGUgdjAuMTAgc3VwcG9ydC4gUmVtb3ZlIHRoaXMgZXZlbnR1YWxseS5cbmZ1bmN0aW9uIGlzU2xvd0J1ZmZlciAob2JqKSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqLnJlYWRGbG9hdExFID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBvYmouc2xpY2UgPT09ICdmdW5jdGlvbicgJiYgaXNCdWZmZXIob2JqLnNsaWNlKDAsIDApKVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoQykgMjAxNSBNaWNoYWVsIE1hcnRpbmV6XG4gKiBDaGFuZ2VzOiBBZGRlZCBzdXBwb3J0IGZvciBzZWxlY3Rpb24gdmFsdWVzIDItNywgZml4ZWQgbWlub3IgYnVncyAmXG4gKiB3YXJuaW5ncywgc3BsaXQgaW50byBtdWx0aXBsZSBjbGFzcyBmaWxlcywgYW5kIGdlbmVyYWwgY2xlYW4gdXAuXG4gKlxuICogMDgtMjUtMjAxNTogSGVsbXV0IERlcnNjaCBhZ3JlZWQgdG8gYSBsaWNlbnNlIGNoYW5nZSBmcm9tIExHUEwgdG8gTUlULlxuICovXG5cbi8qXG4gKiBDb3B5cmlnaHQgKEMpIEhlbG11dCBEZXJzY2hcbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxuLypqc2xpbnQgYnJvd3NlcjogdHJ1ZSwgbm9kZTogdHJ1ZSAqL1xuLypnbG9iYWwgcmVxdWlyZSwgbW9kdWxlICovXG5cblwidXNlIHN0cmljdFwiO1xuXG4vKioqIEltcG9ydHMgKioqL1xudmFyIGpwZWcgPSBqcGVnIHx8IHt9O1xuanBlZy5sb3NzbGVzcyA9IGpwZWcubG9zc2xlc3MgfHwge307XG5cblxuLyoqKiBDb25zdHJ1Y3RvciAqKiovXG5qcGVnLmxvc3NsZXNzLkNvbXBvbmVudFNwZWMgPSBqcGVnLmxvc3NsZXNzLkNvbXBvbmVudFNwZWMgfHwgZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuaFNhbXAgPSAwOyAvLyBIb3Jpem9udGFsIHNhbXBsaW5nIGZhY3RvclxuICAgIHRoaXMucXVhbnRUYWJsZVNlbCA9IDA7IC8vIFF1YW50aXphdGlvbiB0YWJsZSBkZXN0aW5hdGlvbiBzZWxlY3RvclxuICAgIHRoaXMudlNhbXAgPSAwOyAvLyBWZXJ0aWNhbFxufTtcblxuXG4vKioqIEV4cG9ydHMgKioqL1xuXG52YXIgbW9kdWxlVHlwZSA9IHR5cGVvZiBtb2R1bGU7XG5pZiAoKG1vZHVsZVR5cGUgIT09ICd1bmRlZmluZWQnKSAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgIG1vZHVsZS5leHBvcnRzID0ganBlZy5sb3NzbGVzcy5Db21wb25lbnRTcGVjO1xufVxuIiwiLypcbiAqIENvcHlyaWdodCAoQykgMjAxNSBNaWNoYWVsIE1hcnRpbmV6XG4gKiBDaGFuZ2VzOiBBZGRlZCBzdXBwb3J0IGZvciBzZWxlY3Rpb24gdmFsdWVzIDItNywgZml4ZWQgbWlub3IgYnVncyAmXG4gKiB3YXJuaW5ncywgc3BsaXQgaW50byBtdWx0aXBsZSBjbGFzcyBmaWxlcywgYW5kIGdlbmVyYWwgY2xlYW4gdXAuXG4gKlxuICogMDgtMjUtMjAxNTogSGVsbXV0IERlcnNjaCBhZ3JlZWQgdG8gYSBsaWNlbnNlIGNoYW5nZSBmcm9tIExHUEwgdG8gTUlULlxuICovXG5cbi8qXG4gKiBDb3B5cmlnaHQgKEMpIEhlbG11dCBEZXJzY2hcbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxuLypqc2xpbnQgYnJvd3NlcjogdHJ1ZSwgbm9kZTogdHJ1ZSAqL1xuLypnbG9iYWwgcmVxdWlyZSwgbW9kdWxlICovXG5cblwidXNlIHN0cmljdFwiO1xuXG4vKioqIEltcG9ydHMgKioqL1xudmFyIGpwZWcgPSBqcGVnIHx8IHt9O1xuanBlZy5sb3NzbGVzcyA9IGpwZWcubG9zc2xlc3MgfHwge307XG5cblxuLyoqKiBDb25zdHJ1Y3RvciAqKiovXG5qcGVnLmxvc3NsZXNzLkRhdGFTdHJlYW0gPSBqcGVnLmxvc3NsZXNzLkRhdGFTdHJlYW0gfHwgZnVuY3Rpb24gKGRhdGEsIG9mZnNldCwgbGVuZ3RoKSB7XG4gICAgdGhpcy5idWZmZXIgPSBuZXcgRGF0YVZpZXcoZGF0YSwgb2Zmc2V0LCBsZW5ndGgpO1xuICAgIHRoaXMuaW5kZXggPSAwO1xufTtcblxuXG5cbmpwZWcubG9zc2xlc3MuRGF0YVN0cmVhbS5wcm90b3R5cGUuZ2V0MTYgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHZhbHVlID0gdGhpcy5idWZmZXIuZ2V0VWludDE2KHRoaXMuaW5kZXgsIGZhbHNlKTtcbiAgICB0aGlzLmluZGV4ICs9IDI7XG4gICAgcmV0dXJuIHZhbHVlO1xufTtcblxuXG5cbmpwZWcubG9zc2xlc3MuRGF0YVN0cmVhbS5wcm90b3R5cGUuZ2V0OCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdmFsdWUgPSB0aGlzLmJ1ZmZlci5nZXRVaW50OCh0aGlzLmluZGV4KTtcbiAgICB0aGlzLmluZGV4ICs9IDE7XG4gICAgcmV0dXJuIHZhbHVlO1xufTtcblxuXG4vKioqIEV4cG9ydHMgKioqL1xuXG52YXIgbW9kdWxlVHlwZSA9IHR5cGVvZiBtb2R1bGU7XG5pZiAoKG1vZHVsZVR5cGUgIT09ICd1bmRlZmluZWQnKSAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgIG1vZHVsZS5leHBvcnRzID0ganBlZy5sb3NzbGVzcy5EYXRhU3RyZWFtO1xufVxuIiwiLypcbiAqIENvcHlyaWdodCAoQykgMjAxNSBNaWNoYWVsIE1hcnRpbmV6XG4gKiBDaGFuZ2VzOiBBZGRlZCBzdXBwb3J0IGZvciBzZWxlY3Rpb24gdmFsdWVzIDItNywgZml4ZWQgbWlub3IgYnVncyAmXG4gKiB3YXJuaW5ncywgc3BsaXQgaW50byBtdWx0aXBsZSBjbGFzcyBmaWxlcywgYW5kIGdlbmVyYWwgY2xlYW4gdXAuXG4gKlxuICogMDgtMjUtMjAxNTogSGVsbXV0IERlcnNjaCBhZ3JlZWQgdG8gYSBsaWNlbnNlIGNoYW5nZSBmcm9tIExHUEwgdG8gTUlULlxuICovXG5cbi8qXG4gKiBDb3B5cmlnaHQgKEMpIEhlbG11dCBEZXJzY2hcbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxuLypqc2xpbnQgYnJvd3NlcjogdHJ1ZSwgbm9kZTogdHJ1ZSAqL1xuLypnbG9iYWwgcmVxdWlyZSwgbW9kdWxlICovXG5cblwidXNlIHN0cmljdFwiO1xuXG4vKioqIEltcG9ydHMgKioqL1xudmFyIGpwZWcgPSBqcGVnIHx8IHt9O1xuanBlZy5sb3NzbGVzcyA9IGpwZWcubG9zc2xlc3MgfHwge307XG5qcGVnLmxvc3NsZXNzLkRhdGFTdHJlYW0gPSBqcGVnLmxvc3NsZXNzLkRhdGFTdHJlYW0gfHwgKCh0eXBlb2YgcmVxdWlyZSAhPT0gJ3VuZGVmaW5lZCcpID8gcmVxdWlyZSgnLi9kYXRhLXN0cmVhbS5qcycpIDogbnVsbCk7XG5qcGVnLmxvc3NsZXNzLkh1ZmZtYW5UYWJsZSA9IGpwZWcubG9zc2xlc3MuSHVmZm1hblRhYmxlIHx8ICgodHlwZW9mIHJlcXVpcmUgIT09ICd1bmRlZmluZWQnKSA/IHJlcXVpcmUoJy4vaHVmZm1hbi10YWJsZS5qcycpIDogbnVsbCk7XG5qcGVnLmxvc3NsZXNzLlF1YW50aXphdGlvblRhYmxlID0ganBlZy5sb3NzbGVzcy5RdWFudGl6YXRpb25UYWJsZSB8fCAoKHR5cGVvZiByZXF1aXJlICE9PSAndW5kZWZpbmVkJykgPyByZXF1aXJlKCcuL3F1YW50aXphdGlvbi10YWJsZS5qcycpIDogbnVsbCk7XG5qcGVnLmxvc3NsZXNzLlNjYW5IZWFkZXIgPSBqcGVnLmxvc3NsZXNzLlNjYW5IZWFkZXIgfHwgKCh0eXBlb2YgcmVxdWlyZSAhPT0gJ3VuZGVmaW5lZCcpID8gcmVxdWlyZSgnLi9zY2FuLWhlYWRlci5qcycpIDogbnVsbCk7XG5qcGVnLmxvc3NsZXNzLkZyYW1lSGVhZGVyID0ganBlZy5sb3NzbGVzcy5GcmFtZUhlYWRlciB8fCAoKHR5cGVvZiByZXF1aXJlICE9PSAndW5kZWZpbmVkJykgPyByZXF1aXJlKCcuL2ZyYW1lLWhlYWRlci5qcycpIDogbnVsbCk7XG5qcGVnLmxvc3NsZXNzLlV0aWxzID0ganBlZy5sb3NzbGVzcy5VdGlscyB8fCAoKHR5cGVvZiByZXF1aXJlICE9PSAndW5kZWZpbmVkJykgPyByZXF1aXJlKCcuL3V0aWxzLmpzJykgOiBudWxsKTtcblxuXG4vKioqIENvbnN0cnVjdG9yICoqKi9cbmpwZWcubG9zc2xlc3MuRGVjb2RlciA9IGpwZWcubG9zc2xlc3MuRGVjb2RlciB8fCBmdW5jdGlvbiAoYnVmZmVyLCBudW1CeXRlcykge1xuICAgIHRoaXMuYnVmZmVyID0gYnVmZmVyO1xuICAgIHRoaXMuZnJhbWUgPSBuZXcganBlZy5sb3NzbGVzcy5GcmFtZUhlYWRlcigpO1xuICAgIHRoaXMuaHVmZlRhYmxlID0gbmV3IGpwZWcubG9zc2xlc3MuSHVmZm1hblRhYmxlKCk7XG4gICAgdGhpcy5xdWFudFRhYmxlID0gbmV3IGpwZWcubG9zc2xlc3MuUXVhbnRpemF0aW9uVGFibGUoKTtcbiAgICB0aGlzLnNjYW4gPSBuZXcganBlZy5sb3NzbGVzcy5TY2FuSGVhZGVyKCk7XG4gICAgdGhpcy5EVSA9IGpwZWcubG9zc2xlc3MuVXRpbHMuY3JlYXRlQXJyYXkoMTAsIDQsIDY0KTsgLy8gYXQgbW9zdCAxMCBkYXRhIHVuaXRzIGluIGEgTUNVLCBhdCBtb3N0IDQgZGF0YSB1bml0cyBpbiBvbmUgY29tcG9uZW50XG4gICAgdGhpcy5IdWZmVGFiID0ganBlZy5sb3NzbGVzcy5VdGlscy5jcmVhdGVBcnJheSg0LCAyLCA1MCAqIDI1Nik7XG4gICAgdGhpcy5JRENUX1NvdXJjZSA9IFtdO1xuICAgIHRoaXMubkJsb2NrID0gW107IC8vIG51bWJlciBvZiBibG9ja3MgaW4gdGhlIGktdGggQ29tcCBpbiBhIHNjYW5cbiAgICB0aGlzLmFjVGFiID0ganBlZy5sb3NzbGVzcy5VdGlscy5jcmVhdGVBcnJheSgxMCwgMSk7IC8vIGFjIEh1ZmZUYWIgZm9yIHRoZSBpLXRoIENvbXAgaW4gYSBzY2FuXG4gICAgdGhpcy5kY1RhYiA9IGpwZWcubG9zc2xlc3MuVXRpbHMuY3JlYXRlQXJyYXkoMTAsIDEpOyAvLyBkYyBIdWZmVGFiIGZvciB0aGUgaS10aCBDb21wIGluIGEgc2NhblxuICAgIHRoaXMucVRhYiA9IGpwZWcubG9zc2xlc3MuVXRpbHMuY3JlYXRlQXJyYXkoMTAsIDEpOyAvLyBxdWFudGl6YXRpb24gdGFibGUgZm9yIHRoZSBpLXRoIENvbXAgaW4gYSBzY2FuXG4gICAgdGhpcy5tYXJrZXIgPSAwO1xuICAgIHRoaXMubWFya2VySW5kZXggPSAwO1xuICAgIHRoaXMubnVtQ29tcCA9IDA7XG4gICAgdGhpcy5yZXN0YXJ0SW50ZXJ2YWwgPSAwO1xuICAgIHRoaXMuc2VsZWN0aW9uID0gMDtcbiAgICB0aGlzLnhEaW0gPSAwO1xuICAgIHRoaXMueURpbSA9IDA7XG4gICAgdGhpcy54TG9jID0gMDtcbiAgICB0aGlzLnlMb2MgPSAwO1xuICAgIHRoaXMubnVtQnl0ZXMgPSAwO1xuICAgIHRoaXMub3V0cHV0RGF0YSA9IG51bGw7XG4gICAgdGhpcy5yZXN0YXJ0aW5nID0gZmFsc2U7XG4gICAgdGhpcy5tYXNrID0gMDtcblxuICAgIGlmICh0eXBlb2YgbnVtQnl0ZXMgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgdGhpcy5udW1CeXRlcyA9IG51bUJ5dGVzO1xuICAgIH1cbn07XG5cblxuLyoqKiBTdGF0aWMgUHNldWRvLWNvbnN0YW50cyAqKiovXG5cbmpwZWcubG9zc2xlc3MuRGVjb2Rlci5JRENUX1AgPSBbMCwgNSwgNDAsIDE2LCA0NSwgMiwgNywgNDIsIDIxLCA1NiwgOCwgNjEsIDE4LCA0NywgMSwgNCwgNDEsIDIzLCA1OCwgMTMsIDMyLCAyNCwgMzcsIDEwLCA2MywgMTcsIDQ0LCAzLCA2LCA0MywgMjAsXG4gICAgNTcsIDE1LCAzNCwgMjksIDQ4LCA1MywgMjYsIDM5LCA5LCA2MCwgMTksIDQ2LCAyMiwgNTksIDEyLCAzMywgMzEsIDUwLCA1NSwgMjUsIDM2LCAxMSwgNjIsIDE0LCAzNSwgMjgsIDQ5LCA1MiwgMjcsIDM4LCAzMCwgNTEsIDU0XTtcbmpwZWcubG9zc2xlc3MuRGVjb2Rlci5UQUJMRSA9IFswLCAxLCA1LCA2LCAxNCwgMTUsIDI3LCAyOCwgMiwgNCwgNywgMTMsIDE2LCAyNiwgMjksIDQyLCAzLCA4LCAxMiwgMTcsIDI1LCAzMCwgNDEsIDQzLCA5LCAxMSwgMTgsIDI0LCAzMSwgNDAsIDQ0LCA1MyxcbiAgICAxMCwgMTksIDIzLCAzMiwgMzksIDQ1LCA1MiwgNTQsIDIwLCAyMiwgMzMsIDM4LCA0NiwgNTEsIDU1LCA2MCwgMjEsIDM0LCAzNywgNDcsIDUwLCA1NiwgNTksIDYxLCAzNSwgMzYsIDQ4LCA0OSwgNTcsIDU4LCA2MiwgNjNdO1xuanBlZy5sb3NzbGVzcy5EZWNvZGVyLk1BWF9IVUZGTUFOX1NVQlRSRUUgPSA1MDtcbmpwZWcubG9zc2xlc3MuRGVjb2Rlci5NU0IgPSAweDgwMDAwMDAwO1xuanBlZy5sb3NzbGVzcy5EZWNvZGVyLlJFU1RBUlRfTUFSS0VSX0JFR0lOID0gMHhGRkQwO1xuanBlZy5sb3NzbGVzcy5EZWNvZGVyLlJFU1RBUlRfTUFSS0VSX0VORCA9IDB4RkZENztcblxuLyoqKiBQcm90b3R5cGUgTWV0aG9kcyAqKiovXG5cbmpwZWcubG9zc2xlc3MuRGVjb2Rlci5wcm90b3R5cGUuZGVjb21wcmVzcyA9IGZ1bmN0aW9uIChidWZmZXIsIG9mZnNldCwgbGVuZ3RoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGVjb2RlKGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgpLmJ1ZmZlcjtcbn07XG5cblxuXG5qcGVnLmxvc3NsZXNzLkRlY29kZXIucHJvdG90eXBlLmRlY29kZSA9IGZ1bmN0aW9uIChidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBudW1CeXRlcykge1xuICAgIC8qanNsaW50IGJpdHdpc2U6IHRydWUgKi9cblxuICAgIHZhciBjdXJyZW50LCBzY2FuTnVtID0gMCwgcHJlZCA9IFtdLCBpLCBjb21wTiwgdGVtcCA9IFtdLCBpbmRleCA9IFtdLCBtY3VOdW07XG5cbiAgICBpZiAodHlwZW9mIGJ1ZmZlciAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IGJ1ZmZlcjtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG51bUJ5dGVzICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHRoaXMubnVtQnl0ZXMgPSBudW1CeXRlcztcbiAgICB9XG5cbiAgICB0aGlzLnN0cmVhbSA9IG5ldyBqcGVnLmxvc3NsZXNzLkRhdGFTdHJlYW0odGhpcy5idWZmZXIsIG9mZnNldCwgbGVuZ3RoKTtcbiAgICB0aGlzLmJ1ZmZlciA9IG51bGw7XG5cbiAgICB0aGlzLnhMb2MgPSAwO1xuICAgIHRoaXMueUxvYyA9IDA7XG4gICAgY3VycmVudCA9IHRoaXMuc3RyZWFtLmdldDE2KCk7XG5cbiAgICBpZiAoY3VycmVudCAhPT0gMHhGRkQ4KSB7IC8vIFNPSVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb3QgYSBKUEVHIGZpbGVcIik7XG4gICAgfVxuXG4gICAgY3VycmVudCA9IHRoaXMuc3RyZWFtLmdldDE2KCk7XG5cbiAgICB3aGlsZSAoKCgoY3VycmVudCA+PiA0KSAhPT0gMHgwRkZDKSB8fCAoY3VycmVudCA9PT0gMHhGRkM0KSkpIHsgLy8gU09GIDB+MTVcbiAgICAgICAgc3dpdGNoIChjdXJyZW50KSB7XG4gICAgICAgICAgICBjYXNlIDB4RkZDNDogLy8gREhUXG4gICAgICAgICAgICAgICAgdGhpcy5odWZmVGFibGUucmVhZCh0aGlzLnN0cmVhbSwgdGhpcy5IdWZmVGFiKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMHhGRkNDOiAvLyBEQUNcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQcm9ncmFtIGRvZXNuJ3Qgc3VwcG9ydCBhcml0aG1ldGljIGNvZGluZy4gKGZvcm1hdCB0aHJvdyBuZXcgSU9FeGNlcHRpb24pXCIpO1xuICAgICAgICAgICAgY2FzZSAweEZGREI6XG4gICAgICAgICAgICAgICAgdGhpcy5xdWFudFRhYmxlLnJlYWQodGhpcy5zdHJlYW0sIGpwZWcubG9zc2xlc3MuRGVjb2Rlci5UQUJMRSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDB4RkZERDpcbiAgICAgICAgICAgICAgICB0aGlzLnJlc3RhcnRJbnRlcnZhbCA9IHRoaXMucmVhZE51bWJlcigpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAweEZGRTA6XG4gICAgICAgICAgICBjYXNlIDB4RkZFMTpcbiAgICAgICAgICAgIGNhc2UgMHhGRkUyOlxuICAgICAgICAgICAgY2FzZSAweEZGRTM6XG4gICAgICAgICAgICBjYXNlIDB4RkZFNDpcbiAgICAgICAgICAgIGNhc2UgMHhGRkU1OlxuICAgICAgICAgICAgY2FzZSAweEZGRTY6XG4gICAgICAgICAgICBjYXNlIDB4RkZFNzpcbiAgICAgICAgICAgIGNhc2UgMHhGRkU4OlxuICAgICAgICAgICAgY2FzZSAweEZGRTk6XG4gICAgICAgICAgICBjYXNlIDB4RkZFQTpcbiAgICAgICAgICAgIGNhc2UgMHhGRkVCOlxuICAgICAgICAgICAgY2FzZSAweEZGRUM6XG4gICAgICAgICAgICBjYXNlIDB4RkZFRDpcbiAgICAgICAgICAgIGNhc2UgMHhGRkVFOlxuICAgICAgICAgICAgY2FzZSAweEZGRUY6XG4gICAgICAgICAgICAgICAgdGhpcy5yZWFkQXBwKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDB4RkZGRTpcbiAgICAgICAgICAgICAgICB0aGlzLnJlYWRDb21tZW50KCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGlmICgoY3VycmVudCA+PiA4KSAhPT0gMHhGRikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFUlJPUjogZm9ybWF0IHRocm93IG5ldyBJT0V4Y2VwdGlvbiEgKGRlY29kZSlcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY3VycmVudCA9IHRoaXMuc3RyZWFtLmdldDE2KCk7XG4gICAgfVxuXG4gICAgaWYgKChjdXJyZW50IDwgMHhGRkMwKSB8fCAoY3VycmVudCA+IDB4RkZDNykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRVJST1I6IGNvdWxkIG5vdCBoYW5kbGUgYXJpdGhtZXRpYyBjb2RlIVwiKTtcbiAgICB9XG5cbiAgICB0aGlzLmZyYW1lLnJlYWQodGhpcy5zdHJlYW0pO1xuICAgIGN1cnJlbnQgPSB0aGlzLnN0cmVhbS5nZXQxNigpO1xuXG4gICAgZG8ge1xuICAgICAgICB3aGlsZSAoY3VycmVudCAhPT0gMHgwRkZEQSkgeyAvLyBTT1NcbiAgICAgICAgICAgIHN3aXRjaCAoY3VycmVudCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMHhGRkM0OiAvLyBESFRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5odWZmVGFibGUucmVhZCh0aGlzLnN0cmVhbSwgdGhpcy5IdWZmVGFiKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAweEZGQ0M6IC8vIERBQ1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQcm9ncmFtIGRvZXNuJ3Qgc3VwcG9ydCBhcml0aG1ldGljIGNvZGluZy4gKGZvcm1hdCB0aHJvdyBuZXcgSU9FeGNlcHRpb24pXCIpO1xuICAgICAgICAgICAgICAgIGNhc2UgMHhGRkRCOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnF1YW50VGFibGUucmVhZCh0aGlzLnN0cmVhbSwganBlZy5sb3NzbGVzcy5EZWNvZGVyLlRBQkxFKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAweEZGREQ6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVzdGFydEludGVydmFsID0gdGhpcy5yZWFkTnVtYmVyKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMHhGRkUwOlxuICAgICAgICAgICAgICAgIGNhc2UgMHhGRkUxOlxuICAgICAgICAgICAgICAgIGNhc2UgMHhGRkUyOlxuICAgICAgICAgICAgICAgIGNhc2UgMHhGRkUzOlxuICAgICAgICAgICAgICAgIGNhc2UgMHhGRkU0OlxuICAgICAgICAgICAgICAgIGNhc2UgMHhGRkU1OlxuICAgICAgICAgICAgICAgIGNhc2UgMHhGRkU2OlxuICAgICAgICAgICAgICAgIGNhc2UgMHhGRkU3OlxuICAgICAgICAgICAgICAgIGNhc2UgMHhGRkU4OlxuICAgICAgICAgICAgICAgIGNhc2UgMHhGRkU5OlxuICAgICAgICAgICAgICAgIGNhc2UgMHhGRkVBOlxuICAgICAgICAgICAgICAgIGNhc2UgMHhGRkVCOlxuICAgICAgICAgICAgICAgIGNhc2UgMHhGRkVDOlxuICAgICAgICAgICAgICAgIGNhc2UgMHhGRkVEOlxuICAgICAgICAgICAgICAgIGNhc2UgMHhGRkVFOlxuICAgICAgICAgICAgICAgIGNhc2UgMHhGRkVGOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlYWRBcHAoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAweEZGRkU6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVhZENvbW1lbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKChjdXJyZW50ID4+IDgpICE9PSAweEZGKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFUlJPUjogZm9ybWF0IHRocm93IG5ldyBJT0V4Y2VwdGlvbiEgKFBhcnNlci5kZWNvZGUpXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGN1cnJlbnQgPSB0aGlzLnN0cmVhbS5nZXQxNigpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5wcmVjaXNpb24gPSB0aGlzLmZyYW1lLnByZWNpc2lvbjtcbiAgICAgICAgdGhpcy5jb21wb25lbnRzID0gdGhpcy5mcmFtZS5jb21wb25lbnRzO1xuXG4gICAgICAgIGlmICghdGhpcy5udW1CeXRlcykge1xuICAgICAgICAgICAgdGhpcy5udW1CeXRlcyA9IHBhcnNlSW50KE1hdGguY2VpbCh0aGlzLnByZWNpc2lvbiAvIDgpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLm51bUJ5dGVzID09IDEpIHtcbiAgICAgICAgICAgIHRoaXMubWFzayA9IDB4RkY7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm1hc2sgPSAweEZGRkY7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNjYW4ucmVhZCh0aGlzLnN0cmVhbSk7XG4gICAgICAgIHRoaXMubnVtQ29tcCA9IHRoaXMuc2Nhbi5udW1Db21wO1xuICAgICAgICB0aGlzLnNlbGVjdGlvbiA9IHRoaXMuc2Nhbi5zZWxlY3Rpb247XG5cbiAgICAgICAgaWYgKHRoaXMubnVtQnl0ZXMgPT09IDEpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm51bUNvbXAgPT09IDMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdldHRlciA9IHRoaXMuZ2V0VmFsdWVSR0I7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXR0ZXIgPSB0aGlzLnNldFZhbHVlUkdCO1xuICAgICAgICAgICAgICAgIHRoaXMub3V0cHV0ID0gdGhpcy5vdXRwdXRSR0I7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZ2V0dGVyID0gdGhpcy5nZXRWYWx1ZTg7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXR0ZXIgPSB0aGlzLnNldFZhbHVlODtcbiAgICAgICAgICAgICAgICB0aGlzLm91dHB1dCA9IHRoaXMub3V0cHV0U2luZ2xlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5nZXR0ZXIgPSB0aGlzLmdldFZhbHVlMTY7XG4gICAgICAgICAgICB0aGlzLnNldHRlciA9IHRoaXMuc2V0VmFsdWUxNjtcbiAgICAgICAgICAgIHRoaXMub3V0cHV0ID0gdGhpcy5vdXRwdXRTaW5nbGU7XG4gICAgICAgIH1cblxuICAgICAgICBzd2l0Y2ggKHRoaXMuc2VsZWN0aW9uKSB7XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RvciA9IHRoaXMuc2VsZWN0MjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdG9yID0gdGhpcy5zZWxlY3QzO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0b3IgPSB0aGlzLnNlbGVjdDQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RvciA9IHRoaXMuc2VsZWN0NTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdG9yID0gdGhpcy5zZWxlY3Q2O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0b3IgPSB0aGlzLnNlbGVjdDc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0b3IgPSB0aGlzLnNlbGVjdDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNjYW5Db21wcyA9IHRoaXMuc2Nhbi5jb21wb25lbnRzO1xuICAgICAgICB0aGlzLnF1YW50VGFibGVzID0gdGhpcy5xdWFudFRhYmxlLnF1YW50VGFibGVzO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLm51bUNvbXA7IGkrPTEpIHtcbiAgICAgICAgICAgIGNvbXBOID0gdGhpcy5zY2FuQ29tcHNbaV0uc2NhbkNvbXBTZWw7XG4gICAgICAgICAgICB0aGlzLnFUYWJbaV0gPSB0aGlzLnF1YW50VGFibGVzW3RoaXMuY29tcG9uZW50c1tjb21wTl0ucXVhbnRUYWJsZVNlbF07XG4gICAgICAgICAgICB0aGlzLm5CbG9ja1tpXSA9IHRoaXMuY29tcG9uZW50c1tjb21wTl0udlNhbXAgKiB0aGlzLmNvbXBvbmVudHNbY29tcE5dLmhTYW1wO1xuICAgICAgICAgICAgdGhpcy5kY1RhYltpXSA9IHRoaXMuSHVmZlRhYlt0aGlzLnNjYW5Db21wc1tpXS5kY1RhYlNlbF1bMF07XG4gICAgICAgICAgICB0aGlzLmFjVGFiW2ldID0gdGhpcy5IdWZmVGFiW3RoaXMuc2NhbkNvbXBzW2ldLmFjVGFiU2VsXVsxXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMueERpbSA9IHRoaXMuZnJhbWUuZGltWDtcbiAgICAgICAgdGhpcy55RGltID0gdGhpcy5mcmFtZS5kaW1ZO1xuICAgICAgICB0aGlzLm91dHB1dERhdGEgPSBuZXcgRGF0YVZpZXcobmV3IEFycmF5QnVmZmVyKHRoaXMueERpbSAqIHRoaXMueURpbSAqIHRoaXMubnVtQnl0ZXMgKiB0aGlzLm51bUNvbXApKTtcblxuICAgICAgICBzY2FuTnVtKz0xO1xuXG4gICAgICAgIHdoaWxlICh0cnVlKSB7IC8vIERlY29kZSBvbmUgc2NhblxuICAgICAgICAgICAgdGVtcFswXSA9IDA7XG4gICAgICAgICAgICBpbmRleFswXSA9IDA7XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCAxMDsgaSs9MSkge1xuICAgICAgICAgICAgICAgIHByZWRbaV0gPSAoMSA8PCAodGhpcy5wcmVjaXNpb24gLSAxKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLnJlc3RhcnRJbnRlcnZhbCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSB0aGlzLmRlY29kZVVuaXQocHJlZCwgdGVtcCwgaW5kZXgpO1xuXG4gICAgICAgICAgICAgICAgd2hpbGUgKChjdXJyZW50ID09PSAwKSAmJiAoKHRoaXMueExvYyA8IHRoaXMueERpbSkgJiYgKHRoaXMueUxvYyA8IHRoaXMueURpbSkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3V0cHV0KHByZWQpO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50ID0gdGhpcy5kZWNvZGVVbml0KHByZWQsIHRlbXAsIGluZGV4KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBicmVhazsgLy9jdXJyZW50PU1BUktFUlxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKG1jdU51bSA9IDA7IG1jdU51bSA8IHRoaXMucmVzdGFydEludGVydmFsOyBtY3VOdW0rPTEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc3RhcnRpbmcgPSAobWN1TnVtID09IDApO1xuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSB0aGlzLmRlY29kZVVuaXQocHJlZCwgdGVtcCwgaW5kZXgpO1xuICAgICAgICAgICAgICAgIHRoaXMub3V0cHV0KHByZWQpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnQgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoY3VycmVudCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm1hcmtlckluZGV4ICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQgPSAoMHhGRjAwIHwgdGhpcy5tYXJrZXIpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1hcmtlckluZGV4ID0gMDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50ID0gdGhpcy5zdHJlYW0uZ2V0MTYoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghKChjdXJyZW50ID49IGpwZWcubG9zc2xlc3MuRGVjb2Rlci5SRVNUQVJUX01BUktFUl9CRUdJTikgJiZcbiAgICAgICAgICAgICAgICAoY3VycmVudCA8PSBqcGVnLmxvc3NsZXNzLkRlY29kZXIuUkVTVEFSVF9NQVJLRVJfRU5EKSkpIHtcbiAgICAgICAgICAgICAgICBicmVhazsgLy9jdXJyZW50PU1BUktFUlxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKChjdXJyZW50ID09PSAweEZGREMpICYmIChzY2FuTnVtID09PSAxKSkgeyAvL0ROTFxuICAgICAgICAgICAgdGhpcy5yZWFkTnVtYmVyKCk7XG4gICAgICAgICAgICBjdXJyZW50ID0gdGhpcy5zdHJlYW0uZ2V0MTYoKTtcbiAgICAgICAgfVxuICAgIH0gd2hpbGUgKChjdXJyZW50ICE9PSAweEZGRDkpICYmICgodGhpcy54TG9jIDwgdGhpcy54RGltKSAmJiAodGhpcy55TG9jIDwgdGhpcy55RGltKSkgJiYgKHNjYW5OdW0gPT09IDApKTtcblxuICAgIHJldHVybiB0aGlzLm91dHB1dERhdGE7XG59O1xuXG5cblxuanBlZy5sb3NzbGVzcy5EZWNvZGVyLnByb3RvdHlwZS5kZWNvZGVVbml0ID0gZnVuY3Rpb24gKHByZXYsIHRlbXAsIGluZGV4KSB7XG4gICAgaWYgKHRoaXMubnVtQ29tcCA9PSAxKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlY29kZVNpbmdsZShwcmV2LCB0ZW1wLCBpbmRleCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLm51bUNvbXAgPT0gMykge1xuICAgICAgICByZXR1cm4gdGhpcy5kZWNvZGVSR0IocHJldiwgdGVtcCwgaW5kZXgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG59O1xuXG5cblxuanBlZy5sb3NzbGVzcy5EZWNvZGVyLnByb3RvdHlwZS5zZWxlY3QxID0gZnVuY3Rpb24gKGNvbXBPZmZzZXQpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRQcmV2aW91c1goY29tcE9mZnNldCk7XG59O1xuXG5cblxuanBlZy5sb3NzbGVzcy5EZWNvZGVyLnByb3RvdHlwZS5zZWxlY3QyID0gZnVuY3Rpb24gKGNvbXBPZmZzZXQpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRQcmV2aW91c1koY29tcE9mZnNldCk7XG59O1xuXG5cblxuanBlZy5sb3NzbGVzcy5EZWNvZGVyLnByb3RvdHlwZS5zZWxlY3QzID0gZnVuY3Rpb24gKGNvbXBPZmZzZXQpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRQcmV2aW91c1hZKGNvbXBPZmZzZXQpO1xufTtcblxuXG5cbmpwZWcubG9zc2xlc3MuRGVjb2Rlci5wcm90b3R5cGUuc2VsZWN0NCA9IGZ1bmN0aW9uIChjb21wT2Zmc2V0KSB7XG4gICAgcmV0dXJuICh0aGlzLmdldFByZXZpb3VzWChjb21wT2Zmc2V0KSArIHRoaXMuZ2V0UHJldmlvdXNZKGNvbXBPZmZzZXQpKSAtIHRoaXMuZ2V0UHJldmlvdXNYWShjb21wT2Zmc2V0KTtcbn07XG5cblxuXG5qcGVnLmxvc3NsZXNzLkRlY29kZXIucHJvdG90eXBlLnNlbGVjdDUgPSBmdW5jdGlvbiAoY29tcE9mZnNldCkge1xuICAgIHJldHVybiB0aGlzLmdldFByZXZpb3VzWChjb21wT2Zmc2V0KSArICgodGhpcy5nZXRQcmV2aW91c1koY29tcE9mZnNldCkgLSB0aGlzLmdldFByZXZpb3VzWFkoY29tcE9mZnNldCkpID4+IDEpO1xufTtcblxuXG5cbmpwZWcubG9zc2xlc3MuRGVjb2Rlci5wcm90b3R5cGUuc2VsZWN0NiA9IGZ1bmN0aW9uIChjb21wT2Zmc2V0KSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0UHJldmlvdXNZKGNvbXBPZmZzZXQpICsgKCh0aGlzLmdldFByZXZpb3VzWChjb21wT2Zmc2V0KSAtIHRoaXMuZ2V0UHJldmlvdXNYWShjb21wT2Zmc2V0KSkgPj4gMSk7XG59O1xuXG5cblxuanBlZy5sb3NzbGVzcy5EZWNvZGVyLnByb3RvdHlwZS5zZWxlY3Q3ID0gZnVuY3Rpb24gKGNvbXBPZmZzZXQpIHtcbiAgICByZXR1cm4gKCh0aGlzLmdldFByZXZpb3VzWChjb21wT2Zmc2V0KSArIHRoaXMuZ2V0UHJldmlvdXNZKGNvbXBPZmZzZXQpKSAvIDIpO1xufTtcblxuXG5cbmpwZWcubG9zc2xlc3MuRGVjb2Rlci5wcm90b3R5cGUuZGVjb2RlUkdCID0gZnVuY3Rpb24gKHByZXYsIHRlbXAsIGluZGV4KSB7XG4gICAgLypqc2xpbnQgYml0d2lzZTogdHJ1ZSAqL1xuXG4gICAgdmFyIHZhbHVlLCBhY3RhYiwgZGN0YWIsIHF0YWIsIGN0ckMsIGksIGssIGo7XG5cbiAgICBwcmV2WzBdID0gdGhpcy5zZWxlY3RvcigwKTtcbiAgICBwcmV2WzFdID0gdGhpcy5zZWxlY3RvcigxKTtcbiAgICBwcmV2WzJdID0gdGhpcy5zZWxlY3RvcigyKTtcblxuICAgIGZvciAoY3RyQyA9IDA7IGN0ckMgPCB0aGlzLm51bUNvbXA7IGN0ckMrPTEpIHtcbiAgICAgICAgcXRhYiA9IHRoaXMucVRhYltjdHJDXTtcbiAgICAgICAgYWN0YWIgPSB0aGlzLmFjVGFiW2N0ckNdO1xuICAgICAgICBkY3RhYiA9IHRoaXMuZGNUYWJbY3RyQ107XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLm5CbG9ja1tjdHJDXTsgaSs9MSkge1xuICAgICAgICAgICAgZm9yIChrID0gMDsgayA8IHRoaXMuSURDVF9Tb3VyY2UubGVuZ3RoOyBrKz0xKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5JRENUX1NvdXJjZVtrXSA9IDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhbHVlID0gdGhpcy5nZXRIdWZmbWFuVmFsdWUoZGN0YWIsIHRlbXAsIGluZGV4KTtcblxuICAgICAgICAgICAgaWYgKHZhbHVlID49IDB4RkYwMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcHJldltjdHJDXSA9IHRoaXMuSURDVF9Tb3VyY2VbMF0gPSBwcmV2W2N0ckNdICsgdGhpcy5nZXRuKGluZGV4LCB2YWx1ZSwgdGVtcCwgaW5kZXgpO1xuICAgICAgICAgICAgdGhpcy5JRENUX1NvdXJjZVswXSAqPSBxdGFiWzBdO1xuXG4gICAgICAgICAgICBmb3IgKGogPSAxOyBqIDwgNjQ7IGorPTEpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXMuZ2V0SHVmZm1hblZhbHVlKGFjdGFiLCB0ZW1wLCBpbmRleCk7XG5cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPj0gMHhGRjAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBqICs9ICh2YWx1ZSA+PiA0KTtcblxuICAgICAgICAgICAgICAgIGlmICgodmFsdWUgJiAweDBGKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoKHZhbHVlID4+IDQpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuSURDVF9Tb3VyY2VbanBlZy5sb3NzbGVzcy5EZWNvZGVyLklEQ1RfUFtqXV0gPSB0aGlzLmdldG4oaW5kZXgsIHZhbHVlICYgMHgwRiwgdGVtcCwgaW5kZXgpICogcXRhYltqXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gMDtcbn07XG5cblxuXG5qcGVnLmxvc3NsZXNzLkRlY29kZXIucHJvdG90eXBlLmRlY29kZVNpbmdsZSA9IGZ1bmN0aW9uIChwcmV2LCB0ZW1wLCBpbmRleCkge1xuICAgIC8qanNsaW50IGJpdHdpc2U6IHRydWUgKi9cblxuICAgIHZhciB2YWx1ZSwgaSwgbiwgblJlc3RhcnQ7XG5cbiAgICBpZiAodGhpcy5yZXN0YXJ0aW5nKSB7XG4gICAgICAgIHRoaXMucmVzdGFydGluZyA9IGZhbHNlO1xuICAgICAgICBwcmV2WzBdID0gKDEgPDwgKHRoaXMuZnJhbWUucHJlY2lzaW9uIC0gMSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHByZXZbMF0gPSB0aGlzLnNlbGVjdG9yKCk7XG4gICAgfVxuXG4gICAgZm9yIChpID0gMDsgaSA8IHRoaXMubkJsb2NrWzBdOyBpKz0xKSB7XG4gICAgICAgIHZhbHVlID0gdGhpcy5nZXRIdWZmbWFuVmFsdWUodGhpcy5kY1RhYlswXSwgdGVtcCwgaW5kZXgpO1xuICAgICAgICBpZiAodmFsdWUgPj0gMHhGRjAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICBuID0gdGhpcy5nZXRuKHByZXYsIHZhbHVlLCB0ZW1wLCBpbmRleCk7XG4gICAgICAgIG5SZXN0YXJ0ID0gKG4gPj4gOCk7XG5cbiAgICAgICAgaWYgKChuUmVzdGFydCA+PSBqcGVnLmxvc3NsZXNzLkRlY29kZXIuUkVTVEFSVF9NQVJLRVJfQkVHSU4pICYmIChuUmVzdGFydCA8PSBqcGVnLmxvc3NsZXNzLkRlY29kZXIuUkVTVEFSVF9NQVJLRVJfRU5EKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5SZXN0YXJ0O1xuICAgICAgICB9XG5cbiAgICAgICAgcHJldlswXSArPSBuO1xuICAgIH1cblxuICAgIHJldHVybiAwO1xufTtcblxuXG5cbi8vXHRIdWZmbWFuIHRhYmxlIGZvciBmYXN0IHNlYXJjaDogKEh1ZmZUYWIpIDgtYml0IExvb2sgdXAgdGFibGUgMi1sYXllciBzZWFyY2ggYXJjaGl0ZWN0dXJlLCAxc3QtbGF5ZXIgcmVwcmVzZW50IDI1NiBub2RlICg4IGJpdHMpIGlmIGNvZGV3b3JkLWxlbmd0aCA+IDhcbi8vXHRiaXRzLCB0aGVuIHRoZSBlbnRyeSBvZiAxc3QtbGF5ZXIgPSAoIyBvZiAybmQtbGF5ZXIgdGFibGUpIHwgTVNCIGFuZCBpdCBpcyBzdG9yZWQgaW4gdGhlIDJuZC1sYXllciBTaXplIG9mIHRhYmxlcyBpbiBlYWNoIGxheWVyIGFyZSAyNTYuXG4vL1x0SHVmZlRhYlsqXVsqXVswLTI1Nl0gaXMgYWx3YXlzIHRoZSBvbmx5IDFzdC1sYXllciB0YWJsZS5cbi8vXG4vL1x0QW4gZW50cnkgY2FuIGJlOiAoMSkgKCMgb2YgMm5kLWxheWVyIHRhYmxlKSB8IE1TQiAsIGZvciBjb2RlIGxlbmd0aCA+IDggaW4gMXN0LWxheWVyICgyKSAoQ29kZSBsZW5ndGgpIDw8IDggfCBIdWZmVmFsXG4vL1xuLy9cdEh1ZmZtYW5WYWx1ZSh0YWJsZSAgIEh1ZmZUYWJbeF1beV0gKGV4KSBIdWZmbWFuVmFsdWUoSHVmZlRhYlsxXVswXSwuLi4pXG4vL1x0ICAgICAgICAgICAgICAgICk6XG4vL1x0ICAgIHJldHVybjogSHVmZm1hbiBWYWx1ZSBvZiB0YWJsZVxuLy9cdCAgICAgICAgICAgIDB4RkY/PyBpZiBpdCByZWNlaXZlcyBhIE1BUktFUlxuLy9cdCAgICBQYXJhbWV0ZXI6ICB0YWJsZSAgIEh1ZmZUYWJbeF1beV0gKGV4KSBIdWZmbWFuVmFsdWUoSHVmZlRhYlsxXVswXSwuLi4pXG4vL1x0ICAgICAgICAgICAgICAgIHRlbXAgICAgdGVtcCBzdG9yYWdlIGZvciByZW1haW5kZWQgYml0c1xuLy9cdCAgICAgICAgICAgICAgICBpbmRleCAgIGluZGV4IHRvIGJpdCBvZiB0ZW1wXG4vL1x0ICAgICAgICAgICAgICAgIGluICAgICAgRklMRSBwb2ludGVyXG4vL1x0ICAgIEVmZmVjdDpcbi8vXHQgICAgICAgIHRlbXAgIHN0b3JlIG5ldyByZW1haW5kZWQgYml0c1xuLy9cdCAgICAgICAgaW5kZXggY2hhbmdlIHRvIG5ldyBpbmRleFxuLy9cdCAgICAgICAgaW4gICAgY2hhbmdlIHRvIG5ldyBwb3NpdGlvblxuLy9cdCAgICBOT1RFOlxuLy9cdCAgICAgIEluaXRpYWwgYnkgICB0ZW1wPTA7IGluZGV4PTA7XG4vL1x0ICAgIE5PVEU6IChleHBsYWluIHRlbXAgYW5kIGluZGV4KVxuLy9cdCAgICAgIHRlbXA6IGlzIGFsd2F5cyBpbiB0aGUgZm9ybSBhdCBjYWxsaW5nIHRpbWUgb3IgcmV0dXJuaW5nIHRpbWVcbi8vXHQgICAgICAgfCAgYnl0ZSA0ICB8ICBieXRlIDMgIHwgIGJ5dGUgMiAgfCAgYnl0ZSAxICB8XG4vL1x0ICAgICAgIHwgICAgIDAgICAgfCAgICAgMCAgICB8IDAwMDAwMDAwIHwgMDAwMDA/Pz8gfCAgaWYgbm90IGEgTUFSS0VSXG4vL1x0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBeaW5kZXg9MyAoZnJvbSAwIHRvIDE1KVxuLy9cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMzIxXG4vL1x0ICAgIE5PVEUgKG1hcmtlciBhbmQgbWFya2VyX2luZGV4KTpcbi8vXHQgICAgICBJZiBnZXQgYSBNQVJLRVIgZnJvbSAnaW4nLCBtYXJrZXI9dGhlIGxvdy1ieXRlIG9mIHRoZSBNQVJLRVJcbi8vXHQgICAgICAgIGFuZCBtYXJrZXJfaW5kZXg9OVxuLy9cdCAgICAgIElmIG1hcmtlcl9pbmRleD05IHRoZW4gaW5kZXggaXMgYWx3YXlzID4gOCwgb3IgSHVmZm1hblZhbHVlKClcbi8vXHQgICAgICAgIHdpbGwgbm90IGJlIGNhbGxlZFxuanBlZy5sb3NzbGVzcy5EZWNvZGVyLnByb3RvdHlwZS5nZXRIdWZmbWFuVmFsdWUgPSBmdW5jdGlvbiAodGFibGUsIHRlbXAsIGluZGV4KSB7XG4gICAgLypqc2xpbnQgYml0d2lzZTogdHJ1ZSAqL1xuXG4gICAgdmFyIGNvZGUsIGlucHV0LCBtYXNrO1xuICAgIG1hc2sgPSAweEZGRkY7XG5cbiAgICBpZiAoaW5kZXhbMF0gPCA4KSB7XG4gICAgICAgIHRlbXBbMF0gPDw9IDg7XG4gICAgICAgIGlucHV0ID0gdGhpcy5zdHJlYW0uZ2V0OCgpO1xuICAgICAgICBpZiAoaW5wdXQgPT09IDB4RkYpIHtcbiAgICAgICAgICAgIHRoaXMubWFya2VyID0gdGhpcy5zdHJlYW0uZ2V0OCgpO1xuICAgICAgICAgICAgaWYgKHRoaXMubWFya2VyICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tYXJrZXJJbmRleCA9IDk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGVtcFswXSB8PSBpbnB1dDtcbiAgICB9IGVsc2Uge1xuICAgICAgICBpbmRleFswXSAtPSA4O1xuICAgIH1cblxuICAgIGNvZGUgPSB0YWJsZVt0ZW1wWzBdID4+IGluZGV4WzBdXTtcblxuICAgIGlmICgoY29kZSAmIGpwZWcubG9zc2xlc3MuRGVjb2Rlci5NU0IpICE9PSAwKSB7XG4gICAgICAgIGlmICh0aGlzLm1hcmtlckluZGV4ICE9PSAwKSB7XG4gICAgICAgICAgICB0aGlzLm1hcmtlckluZGV4ID0gMDtcbiAgICAgICAgICAgIHJldHVybiAweEZGMDAgfCB0aGlzLm1hcmtlcjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRlbXBbMF0gJj0gKG1hc2sgPj4gKDE2IC0gaW5kZXhbMF0pKTtcbiAgICAgICAgdGVtcFswXSA8PD0gODtcbiAgICAgICAgaW5wdXQgPSB0aGlzLnN0cmVhbS5nZXQ4KCk7XG5cbiAgICAgICAgaWYgKGlucHV0ID09PSAweEZGKSB7XG4gICAgICAgICAgICB0aGlzLm1hcmtlciA9IHRoaXMuc3RyZWFtLmdldDgoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLm1hcmtlciAhPT0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMubWFya2VySW5kZXggPSA5O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGVtcFswXSB8PSBpbnB1dDtcbiAgICAgICAgY29kZSA9IHRhYmxlWygoY29kZSAmIDB4RkYpICogMjU2KSArICh0ZW1wWzBdID4+IGluZGV4WzBdKV07XG4gICAgICAgIGluZGV4WzBdICs9IDg7XG4gICAgfVxuXG4gICAgaW5kZXhbMF0gKz0gOCAtIChjb2RlID4+IDgpO1xuXG4gICAgaWYgKGluZGV4WzBdIDwgMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbmRleD1cIiArIGluZGV4WzBdICsgXCIgdGVtcD1cIiArIHRlbXBbMF0gKyBcIiBjb2RlPVwiICsgY29kZSArIFwiIGluIEh1ZmZtYW5WYWx1ZSgpXCIpO1xuICAgIH1cblxuICAgIGlmIChpbmRleFswXSA8IHRoaXMubWFya2VySW5kZXgpIHtcbiAgICAgICAgdGhpcy5tYXJrZXJJbmRleCA9IDA7XG4gICAgICAgIHJldHVybiAweEZGMDAgfCB0aGlzLm1hcmtlcjtcbiAgICB9XG5cbiAgICB0ZW1wWzBdICY9IChtYXNrID4+ICgxNiAtIGluZGV4WzBdKSk7XG4gICAgcmV0dXJuIGNvZGUgJiAweEZGO1xufTtcblxuXG5cbmpwZWcubG9zc2xlc3MuRGVjb2Rlci5wcm90b3R5cGUuZ2V0biA9IGZ1bmN0aW9uIChQUkVELCBuLCB0ZW1wLCBpbmRleCkge1xuICAgIC8qanNsaW50IGJpdHdpc2U6IHRydWUgKi9cblxuICAgIHZhciByZXN1bHQsIG9uZSwgbl9vbmUsIG1hc2ssIGlucHV0O1xuICAgIG9uZSA9IDE7XG4gICAgbl9vbmUgPSAtMTtcbiAgICBtYXNrID0gMHhGRkZGO1xuXG4gICAgaWYgKG4gPT09IDApIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgaWYgKG4gPT09IDE2KSB7XG4gICAgICAgIGlmIChQUkVEWzBdID49IDApIHtcbiAgICAgICAgICAgIHJldHVybiAtMzI3Njg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gMzI3Njg7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpbmRleFswXSAtPSBuO1xuXG4gICAgaWYgKGluZGV4WzBdID49IDApIHtcbiAgICAgICAgaWYgKChpbmRleFswXSA8IHRoaXMubWFya2VySW5kZXgpICYmICF0aGlzLmlzTGFzdFBpeGVsKCkpIHsgLy8gdGhpcyB3YXMgY29ycnVwdGluZyB0aGUgbGFzdCBwaXhlbCBpbiBzb21lIGNhc2VzXG4gICAgICAgICAgICB0aGlzLm1hcmtlckluZGV4ID0gMDtcbiAgICAgICAgICAgIHJldHVybiAoMHhGRjAwIHwgdGhpcy5tYXJrZXIpIDw8IDg7XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHQgPSB0ZW1wWzBdID4+IGluZGV4WzBdO1xuICAgICAgICB0ZW1wWzBdICY9IChtYXNrID4+ICgxNiAtIGluZGV4WzBdKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGVtcFswXSA8PD0gODtcbiAgICAgICAgaW5wdXQgPSB0aGlzLnN0cmVhbS5nZXQ4KCk7XG5cbiAgICAgICAgaWYgKGlucHV0ID09PSAweEZGKSB7XG4gICAgICAgICAgICB0aGlzLm1hcmtlciA9IHRoaXMuc3RyZWFtLmdldDgoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLm1hcmtlciAhPT0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMubWFya2VySW5kZXggPSA5O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGVtcFswXSB8PSBpbnB1dDtcbiAgICAgICAgaW5kZXhbMF0gKz0gODtcblxuICAgICAgICBpZiAoaW5kZXhbMF0gPCAwKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5tYXJrZXJJbmRleCAhPT0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMubWFya2VySW5kZXggPSAwO1xuICAgICAgICAgICAgICAgIHJldHVybiAoMHhGRjAwIHwgdGhpcy5tYXJrZXIpIDw8IDg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRlbXBbMF0gPDw9IDg7XG4gICAgICAgICAgICBpbnB1dCA9IHRoaXMuc3RyZWFtLmdldDgoKTtcblxuICAgICAgICAgICAgaWYgKGlucHV0ID09PSAweEZGKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tYXJrZXIgPSB0aGlzLnN0cmVhbS5nZXQ4KCk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubWFya2VyICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWFya2VySW5kZXggPSA5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGVtcFswXSB8PSBpbnB1dDtcbiAgICAgICAgICAgIGluZGV4WzBdICs9IDg7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaW5kZXhbMF0gPCAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbmRleD1cIiArIGluZGV4WzBdICsgXCIgaW4gZ2V0bigpXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGluZGV4WzBdIDwgdGhpcy5tYXJrZXJJbmRleCkge1xuICAgICAgICAgICAgdGhpcy5tYXJrZXJJbmRleCA9IDA7XG4gICAgICAgICAgICByZXR1cm4gKDB4RkYwMCB8IHRoaXMubWFya2VyKSA8PCA4O1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0ID0gdGVtcFswXSA+PiBpbmRleFswXTtcbiAgICAgICAgdGVtcFswXSAmPSAobWFzayA+PiAoMTYgLSBpbmRleFswXSkpO1xuICAgIH1cblxuICAgIGlmIChyZXN1bHQgPCAob25lIDw8IChuIC0gMSkpKSB7XG4gICAgICAgIHJlc3VsdCArPSAobl9vbmUgPDwgbikgKyAxO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG5cblxuanBlZy5sb3NzbGVzcy5EZWNvZGVyLnByb3RvdHlwZS5nZXRQcmV2aW91c1ggPSBmdW5jdGlvbiAoY29tcE9mZnNldCkge1xuICAgIC8qanNsaW50IGJpdHdpc2U6IHRydWUgKi9cblxuICAgIGlmICh0aGlzLnhMb2MgPiAwKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldHRlcigoKCh0aGlzLnlMb2MgKiB0aGlzLnhEaW0pICsgdGhpcy54TG9jKSAtIDEpLCBjb21wT2Zmc2V0KTtcbiAgICB9IGVsc2UgaWYgKHRoaXMueUxvYyA+IDApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UHJldmlvdXNZKGNvbXBPZmZzZXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAoMSA8PCAodGhpcy5mcmFtZS5wcmVjaXNpb24gLSAxKSk7XG4gICAgfVxufTtcblxuXG5cbmpwZWcubG9zc2xlc3MuRGVjb2Rlci5wcm90b3R5cGUuZ2V0UHJldmlvdXNYWSA9IGZ1bmN0aW9uIChjb21wT2Zmc2V0KSB7XG4gICAgLypqc2xpbnQgYml0d2lzZTogdHJ1ZSAqL1xuXG4gICAgaWYgKCh0aGlzLnhMb2MgPiAwKSAmJiAodGhpcy55TG9jID4gMCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0dGVyKCgoKCh0aGlzLnlMb2MgLSAxKSAqIHRoaXMueERpbSkgKyB0aGlzLnhMb2MpIC0gMSksIGNvbXBPZmZzZXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFByZXZpb3VzWShjb21wT2Zmc2V0KTtcbiAgICB9XG59O1xuXG5cblxuanBlZy5sb3NzbGVzcy5EZWNvZGVyLnByb3RvdHlwZS5nZXRQcmV2aW91c1kgPSBmdW5jdGlvbiAoY29tcE9mZnNldCkge1xuICAgIC8qanNsaW50IGJpdHdpc2U6IHRydWUgKi9cblxuICAgIGlmICh0aGlzLnlMb2MgPiAwKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldHRlcigoKCh0aGlzLnlMb2MgLSAxKSAqIHRoaXMueERpbSkgKyB0aGlzLnhMb2MpLCBjb21wT2Zmc2V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRQcmV2aW91c1goY29tcE9mZnNldCk7XG4gICAgfVxufTtcblxuXG5cbmpwZWcubG9zc2xlc3MuRGVjb2Rlci5wcm90b3R5cGUuaXNMYXN0UGl4ZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICh0aGlzLnhMb2MgPT09ICh0aGlzLnhEaW0gLSAxKSkgJiYgKHRoaXMueUxvYyA9PT0gKHRoaXMueURpbSAtIDEpKTtcbn07XG5cblxuXG5qcGVnLmxvc3NsZXNzLkRlY29kZXIucHJvdG90eXBlLm91dHB1dFNpbmdsZSA9IGZ1bmN0aW9uIChQUkVEKSB7XG4gICAgaWYgKCh0aGlzLnhMb2MgPCB0aGlzLnhEaW0pICYmICh0aGlzLnlMb2MgPCB0aGlzLnlEaW0pKSB7XG4gICAgICAgIHRoaXMuc2V0dGVyKCgoKHRoaXMueUxvYyAqIHRoaXMueERpbSkgKyB0aGlzLnhMb2MpKSwgdGhpcy5tYXNrICYgUFJFRFswXSk7XG5cbiAgICAgICAgdGhpcy54TG9jKz0xO1xuXG4gICAgICAgIGlmICh0aGlzLnhMb2MgPj0gdGhpcy54RGltKSB7XG4gICAgICAgICAgICB0aGlzLnlMb2MrPTE7XG4gICAgICAgICAgICB0aGlzLnhMb2MgPSAwO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuXG5cbmpwZWcubG9zc2xlc3MuRGVjb2Rlci5wcm90b3R5cGUub3V0cHV0UkdCID0gZnVuY3Rpb24gKFBSRUQpIHtcbiAgICB2YXIgb2Zmc2V0ID0gKCh0aGlzLnlMb2MgKiB0aGlzLnhEaW0pICsgdGhpcy54TG9jKTtcblxuICAgIGlmICgodGhpcy54TG9jIDwgdGhpcy54RGltKSAmJiAodGhpcy55TG9jIDwgdGhpcy55RGltKSkge1xuICAgICAgICB0aGlzLnNldHRlcihvZmZzZXQsIFBSRURbMF0sIDApO1xuICAgICAgICB0aGlzLnNldHRlcihvZmZzZXQsIFBSRURbMV0sIDEpO1xuICAgICAgICB0aGlzLnNldHRlcihvZmZzZXQsIFBSRURbMl0sIDIpO1xuXG4gICAgICAgIHRoaXMueExvYys9MTtcblxuICAgICAgICBpZiAodGhpcy54TG9jID49IHRoaXMueERpbSkge1xuICAgICAgICAgICAgdGhpcy55TG9jKz0xO1xuICAgICAgICAgICAgdGhpcy54TG9jID0gMDtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cblxuXG5qcGVnLmxvc3NsZXNzLkRlY29kZXIucHJvdG90eXBlLnNldFZhbHVlMTYgPSBmdW5jdGlvbiAoaW5kZXgsIHZhbCkge1xuICAgIHRoaXMub3V0cHV0RGF0YS5zZXRJbnQxNihpbmRleCAqIDIsIHZhbCwgdHJ1ZSk7XG59O1xuXG5cblxuanBlZy5sb3NzbGVzcy5EZWNvZGVyLnByb3RvdHlwZS5nZXRWYWx1ZTE2ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMub3V0cHV0RGF0YS5nZXRJbnQxNihpbmRleCAqIDIsIHRydWUpO1xufTtcblxuXG5cbmpwZWcubG9zc2xlc3MuRGVjb2Rlci5wcm90b3R5cGUuc2V0VmFsdWU4ID0gZnVuY3Rpb24gKGluZGV4LCB2YWwpIHtcbiAgICB0aGlzLm91dHB1dERhdGEuc2V0SW50OChpbmRleCwgdmFsKTtcbn07XG5cblxuXG5qcGVnLmxvc3NsZXNzLkRlY29kZXIucHJvdG90eXBlLmdldFZhbHVlOCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgIHJldHVybiB0aGlzLm91dHB1dERhdGEuZ2V0SW50OChpbmRleCk7XG59O1xuXG5cblxuanBlZy5sb3NzbGVzcy5EZWNvZGVyLnByb3RvdHlwZS5zZXRWYWx1ZVJHQiA9IGZ1bmN0aW9uIChpbmRleCwgdmFsLCBjb21wT2Zmc2V0KSB7XG4gICAgdGhpcy5vdXRwdXREYXRhLnNldFVpbnQ4KGluZGV4ICogMyArIGNvbXBPZmZzZXQsIHZhbCk7XG59O1xuXG5cblxuanBlZy5sb3NzbGVzcy5EZWNvZGVyLnByb3RvdHlwZS5nZXRWYWx1ZVJHQiA9IGZ1bmN0aW9uIChpbmRleCwgY29tcE9mZnNldCkge1xuICAgIHJldHVybiB0aGlzLm91dHB1dERhdGEuZ2V0VWludDgoaW5kZXggKiAzICsgY29tcE9mZnNldCk7XG59O1xuXG5cblxuanBlZy5sb3NzbGVzcy5EZWNvZGVyLnByb3RvdHlwZS5yZWFkQXBwID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGNvdW50ID0gMCwgbGVuZ3RoID0gdGhpcy5zdHJlYW0uZ2V0MTYoKTtcbiAgICBjb3VudCArPSAyO1xuXG4gICAgd2hpbGUgKGNvdW50IDwgbGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuc3RyZWFtLmdldDgoKTtcbiAgICAgICAgY291bnQrPTE7XG4gICAgfVxuXG4gICAgcmV0dXJuIGxlbmd0aDtcbn07XG5cblxuXG5qcGVnLmxvc3NsZXNzLkRlY29kZXIucHJvdG90eXBlLnJlYWRDb21tZW50ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzYiA9IFwiXCIsIGNvdW50ID0gMCwgbGVuZ3RoO1xuXG4gICAgbGVuZ3RoID0gdGhpcy5zdHJlYW0uZ2V0MTYoKTtcbiAgICBjb3VudCArPSAyO1xuXG4gICAgd2hpbGUgKGNvdW50IDwgbGVuZ3RoKSB7XG4gICAgICAgIHNiICs9IHRoaXMuc3RyZWFtLmdldDgoKTtcbiAgICAgICAgY291bnQrPTE7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNiO1xufTtcblxuXG5cbmpwZWcubG9zc2xlc3MuRGVjb2Rlci5wcm90b3R5cGUucmVhZE51bWJlciA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBMZCA9IHRoaXMuc3RyZWFtLmdldDE2KCk7XG5cbiAgICBpZiAoTGQgIT09IDQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRVJST1I6IERlZmluZSBudW1iZXIgZm9ybWF0IHRocm93IG5ldyBJT0V4Y2VwdGlvbiBbTGQhPTRdXCIpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnN0cmVhbS5nZXQxNigpO1xufTtcblxuXG5cbi8qKiogRXhwb3J0cyAqKiovXG5cbnZhciBtb2R1bGVUeXBlID0gdHlwZW9mIG1vZHVsZTtcbmlmICgobW9kdWxlVHlwZSAhPT0gJ3VuZGVmaW5lZCcpICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBqcGVnLmxvc3NsZXNzLkRlY29kZXI7XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChDKSAyMDE1IE1pY2hhZWwgTWFydGluZXpcbiAqIENoYW5nZXM6IEFkZGVkIHN1cHBvcnQgZm9yIHNlbGVjdGlvbiB2YWx1ZXMgMi03LCBmaXhlZCBtaW5vciBidWdzICZcbiAqIHdhcm5pbmdzLCBzcGxpdCBpbnRvIG11bHRpcGxlIGNsYXNzIGZpbGVzLCBhbmQgZ2VuZXJhbCBjbGVhbiB1cC5cbiAqXG4gKiAwOC0yNS0yMDE1OiBIZWxtdXQgRGVyc2NoIGFncmVlZCB0byBhIGxpY2Vuc2UgY2hhbmdlIGZyb20gTEdQTCB0byBNSVQuXG4gKi9cblxuLypcbiAqIENvcHlyaWdodCAoQykgSGVsbXV0IERlcnNjaFxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG4vKmpzbGludCBicm93c2VyOiB0cnVlLCBub2RlOiB0cnVlICovXG4vKmdsb2JhbCByZXF1aXJlLCBtb2R1bGUgKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKiogSW1wb3J0cyAqKiovXG52YXIganBlZyA9IGpwZWcgfHwge307XG5qcGVnLmxvc3NsZXNzID0ganBlZy5sb3NzbGVzcyB8fCB7fTtcbmpwZWcubG9zc2xlc3MuQ29tcG9uZW50U3BlYyA9IGpwZWcubG9zc2xlc3MuQ29tcG9uZW50U3BlYyB8fCAoKHR5cGVvZiByZXF1aXJlICE9PSAndW5kZWZpbmVkJykgPyByZXF1aXJlKCcuL2NvbXBvbmVudC1zcGVjLmpzJykgOiBudWxsKTtcbmpwZWcubG9zc2xlc3MuRGF0YVN0cmVhbSA9IGpwZWcubG9zc2xlc3MuRGF0YVN0cmVhbSB8fCAoKHR5cGVvZiByZXF1aXJlICE9PSAndW5kZWZpbmVkJykgPyByZXF1aXJlKCcuL2RhdGEtc3RyZWFtLmpzJykgOiBudWxsKTtcblxuXG4vKioqIENvbnN0cnVjdG9yICoqKi9cbmpwZWcubG9zc2xlc3MuRnJhbWVIZWFkZXIgPSBqcGVnLmxvc3NsZXNzLkZyYW1lSGVhZGVyIHx8IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmNvbXBvbmVudHMgPSBbXTsgLy8gQ29tcG9uZW50c1xuICAgIHRoaXMuZGltWCA9IDA7IC8vIE51bWJlciBvZiBzYW1wbGVzIHBlciBsaW5lXG4gICAgdGhpcy5kaW1ZID0gMDsgLy8gTnVtYmVyIG9mIGxpbmVzXG4gICAgdGhpcy5udW1Db21wID0gMDsgLy8gTnVtYmVyIG9mIGNvbXBvbmVudCBpbiB0aGUgZnJhbWVcbiAgICB0aGlzLnByZWNpc2lvbiA9IDA7IC8vIFNhbXBsZSBQcmVjaXNpb24gKGZyb20gdGhlIG9yaWdpbmFsIGltYWdlKVxufTtcblxuXG5cbi8qKiogUHJvdG90eXBlIE1ldGhvZHMgKioqL1xuXG5qcGVnLmxvc3NsZXNzLkZyYW1lSGVhZGVyLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAvKmpzbGludCBiaXR3aXNlOiB0cnVlICovXG5cbiAgICB2YXIgY291bnQgPSAwLCBsZW5ndGgsIGksIGMsIHRlbXA7XG5cbiAgICBsZW5ndGggPSBkYXRhLmdldDE2KCk7XG4gICAgY291bnQgKz0gMjtcblxuICAgIHRoaXMucHJlY2lzaW9uID0gZGF0YS5nZXQ4KCk7XG4gICAgY291bnQrPTE7XG5cbiAgICB0aGlzLmRpbVkgPSBkYXRhLmdldDE2KCk7XG4gICAgY291bnQgKz0gMjtcblxuICAgIHRoaXMuZGltWCA9IGRhdGEuZ2V0MTYoKTtcbiAgICBjb3VudCArPSAyO1xuXG4gICAgdGhpcy5udW1Db21wID0gZGF0YS5nZXQ4KCk7XG4gICAgY291bnQrPTE7XG4gICAgZm9yIChpID0gMTsgaSA8PSB0aGlzLm51bUNvbXA7IGkrPTEpIHtcbiAgICAgICAgaWYgKGNvdW50ID4gbGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFUlJPUjogZnJhbWUgZm9ybWF0IGVycm9yXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgYyA9IGRhdGEuZ2V0OCgpO1xuICAgICAgICBjb3VudCs9MTtcblxuICAgICAgICBpZiAoY291bnQgPj0gbGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFUlJPUjogZnJhbWUgZm9ybWF0IGVycm9yIFtjPj1MZl1cIik7XG4gICAgICAgIH1cblxuICAgICAgICB0ZW1wID0gZGF0YS5nZXQ4KCk7XG4gICAgICAgIGNvdW50Kz0xO1xuXG4gICAgICAgIGlmICghdGhpcy5jb21wb25lbnRzW2NdKSB7XG4gICAgICAgICAgICB0aGlzLmNvbXBvbmVudHNbY10gPSBuZXcganBlZy5sb3NzbGVzcy5Db21wb25lbnRTcGVjKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNvbXBvbmVudHNbY10uaFNhbXAgPSB0ZW1wID4+IDQ7XG4gICAgICAgIHRoaXMuY29tcG9uZW50c1tjXS52U2FtcCA9IHRlbXAgJiAweDBGO1xuICAgICAgICB0aGlzLmNvbXBvbmVudHNbY10ucXVhbnRUYWJsZVNlbCA9IGRhdGEuZ2V0OCgpO1xuICAgICAgICBjb3VudCs9MTtcbiAgICB9XG5cbiAgICBpZiAoY291bnQgIT09IGxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFUlJPUjogZnJhbWUgZm9ybWF0IGVycm9yIFtMZiE9Y291bnRdXCIpO1xuICAgIH1cblxuICAgIHJldHVybiAxO1xufTtcblxuXG4vKioqIEV4cG9ydHMgKioqL1xuXG52YXIgbW9kdWxlVHlwZSA9IHR5cGVvZiBtb2R1bGU7XG5pZiAoKG1vZHVsZVR5cGUgIT09ICd1bmRlZmluZWQnKSAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgIG1vZHVsZS5leHBvcnRzID0ganBlZy5sb3NzbGVzcy5GcmFtZUhlYWRlcjtcbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTUgTWljaGFlbCBNYXJ0aW5lelxuICogQ2hhbmdlczogQWRkZWQgc3VwcG9ydCBmb3Igc2VsZWN0aW9uIHZhbHVlcyAyLTcsIGZpeGVkIG1pbm9yIGJ1Z3MgJlxuICogd2FybmluZ3MsIHNwbGl0IGludG8gbXVsdGlwbGUgY2xhc3MgZmlsZXMsIGFuZCBnZW5lcmFsIGNsZWFuIHVwLlxuICpcbiAqIDA4LTI1LTIwMTU6IEhlbG11dCBEZXJzY2ggYWdyZWVkIHRvIGEgbGljZW5zZSBjaGFuZ2UgZnJvbSBMR1BMIHRvIE1JVC5cbiAqL1xuXG4vKlxuICogQ29weXJpZ2h0IChDKSBIZWxtdXQgRGVyc2NoXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbi8qanNsaW50IGJyb3dzZXI6IHRydWUsIG5vZGU6IHRydWUgKi9cbi8qZ2xvYmFsIHJlcXVpcmUsIG1vZHVsZSAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyoqKiBJbXBvcnRzICoqKi9cbnZhciBqcGVnID0ganBlZyB8fCB7fTtcbmpwZWcubG9zc2xlc3MgPSBqcGVnLmxvc3NsZXNzIHx8IHt9O1xuanBlZy5sb3NzbGVzcy5EYXRhU3RyZWFtID0ganBlZy5sb3NzbGVzcy5EYXRhU3RyZWFtIHx8ICgodHlwZW9mIHJlcXVpcmUgIT09ICd1bmRlZmluZWQnKSA/IHJlcXVpcmUoJy4vZGF0YS1zdHJlYW0uanMnKSA6IG51bGwpO1xuanBlZy5sb3NzbGVzcy5VdGlscyA9IGpwZWcubG9zc2xlc3MuVXRpbHMgfHwgKCh0eXBlb2YgcmVxdWlyZSAhPT0gJ3VuZGVmaW5lZCcpID8gcmVxdWlyZSgnLi91dGlscy5qcycpIDogbnVsbCk7XG5cblxuLyoqKiBDb25zdHJ1Y3RvciAqKiovXG5qcGVnLmxvc3NsZXNzLkh1ZmZtYW5UYWJsZSA9IGpwZWcubG9zc2xlc3MuSHVmZm1hblRhYmxlIHx8IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmwgPSBqcGVnLmxvc3NsZXNzLlV0aWxzLmNyZWF0ZUFycmF5KDQsIDIsIDE2KTtcbiAgICB0aGlzLnRoID0gW107XG4gICAgdGhpcy52ID0ganBlZy5sb3NzbGVzcy5VdGlscy5jcmVhdGVBcnJheSg0LCAyLCAxNiwgMjAwKTtcbiAgICB0aGlzLnRjID0ganBlZy5sb3NzbGVzcy5VdGlscy5jcmVhdGVBcnJheSg0LCAyKTtcblxuICAgIHRoaXMudGNbMF1bMF0gPSAwO1xuICAgIHRoaXMudGNbMV1bMF0gPSAwO1xuICAgIHRoaXMudGNbMl1bMF0gPSAwO1xuICAgIHRoaXMudGNbM11bMF0gPSAwO1xuICAgIHRoaXMudGNbMF1bMV0gPSAwO1xuICAgIHRoaXMudGNbMV1bMV0gPSAwO1xuICAgIHRoaXMudGNbMl1bMV0gPSAwO1xuICAgIHRoaXMudGNbM11bMV0gPSAwO1xuICAgIHRoaXMudGhbMF0gPSAwO1xuICAgIHRoaXMudGhbMV0gPSAwO1xuICAgIHRoaXMudGhbMl0gPSAwO1xuICAgIHRoaXMudGhbM10gPSAwO1xufTtcblxuXG5cbi8qKiogU3RhdGljIFBzZXVkby1jb25zdGFudHMgKioqL1xuXG5qcGVnLmxvc3NsZXNzLkh1ZmZtYW5UYWJsZS5NU0IgPSAweDgwMDAwMDAwO1xuXG5cbi8qKiogUHJvdG90eXBlIE1ldGhvZHMgKioqL1xuXG5qcGVnLmxvc3NsZXNzLkh1ZmZtYW5UYWJsZS5wcm90b3R5cGUucmVhZCA9IGZ1bmN0aW9uKGRhdGEsIEh1ZmZUYWIpIHtcbiAgICAvKmpzbGludCBiaXR3aXNlOiB0cnVlICovXG5cbiAgICB2YXIgY291bnQgPSAwLCBsZW5ndGgsIHRlbXAsIHQsIGMsIGksIGo7XG5cbiAgICBsZW5ndGggPSBkYXRhLmdldDE2KCk7XG4gICAgY291bnQgKz0gMjtcblxuICAgIHdoaWxlIChjb3VudCA8IGxlbmd0aCkge1xuICAgICAgICB0ZW1wID0gZGF0YS5nZXQ4KCk7XG4gICAgICAgIGNvdW50Kz0xO1xuICAgICAgICB0ID0gdGVtcCAmIDB4MEY7XG4gICAgICAgIGlmICh0ID4gMykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRVJST1I6IEh1ZmZtYW4gdGFibGUgSUQgPiAzXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgYyA9IHRlbXAgPj4gNDtcbiAgICAgICAgaWYgKGMgPiAyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFUlJPUjogSHVmZm1hbiB0YWJsZSBbVGFibGUgY2xhc3MgPiAyIF1cIik7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnRoW3RdID0gMTtcbiAgICAgICAgdGhpcy50Y1t0XVtjXSA9IDE7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDE2OyBpKz0xKSB7XG4gICAgICAgICAgICB0aGlzLmxbdF1bY11baV0gPSBkYXRhLmdldDgoKTtcbiAgICAgICAgICAgIGNvdW50Kz0xO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDE2OyBpKz0xKSB7XG4gICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgdGhpcy5sW3RdW2NdW2ldOyBqKz0xKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvdW50ID4gbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkVSUk9SOiBIdWZmbWFuIHRhYmxlIGZvcm1hdCBlcnJvciBbY291bnQ+TGhdXCIpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMudlt0XVtjXVtpXVtqXSA9IGRhdGEuZ2V0OCgpO1xuICAgICAgICAgICAgICAgIGNvdW50Kz0xO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNvdW50ICE9PSBsZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRVJST1I6IEh1ZmZtYW4gdGFibGUgZm9ybWF0IGVycm9yIFtjb3VudCE9TGZdXCIpO1xuICAgIH1cblxuICAgIGZvciAoaSA9IDA7IGkgPCA0OyBpKz0xKSB7XG4gICAgICAgIGZvciAoaiA9IDA7IGogPCAyOyBqKz0xKSB7XG4gICAgICAgICAgICBpZiAodGhpcy50Y1tpXVtqXSAhPT0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYnVpbGRIdWZmVGFibGUoSHVmZlRhYltpXVtqXSwgdGhpcy5sW2ldW2pdLCB0aGlzLnZbaV1bal0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIDE7XG59O1xuXG5cblxuLy9cdEJ1aWxkX0h1ZmZUYWIoKVxuLy9cdFBhcmFtZXRlcjogIHQgICAgICAgdGFibGUgSURcbi8vXHQgICAgICAgICAgICBjICAgICAgIHRhYmxlIGNsYXNzICggMCBmb3IgREMsIDEgZm9yIEFDIClcbi8vXHQgICAgICAgICAgICBMW2ldICAgICMgb2YgY29kZXdvcmRzIHdoaWNoIGxlbmd0aCBpcyBpXG4vL1x0ICAgICAgICAgICAgVltpXVtqXSBIdWZmbWFuIFZhbHVlIChsZW5ndGg9aSlcbi8vXHRFZmZlY3Q6XG4vL1x0ICAgIGJ1aWxkIHVwIEh1ZmZUYWJbdF1bY10gdXNpbmcgTCBhbmQgVi5cbmpwZWcubG9zc2xlc3MuSHVmZm1hblRhYmxlLnByb3RvdHlwZS5idWlsZEh1ZmZUYWJsZSA9IGZ1bmN0aW9uKHRhYiwgTCwgVikge1xuICAgIC8qanNsaW50IGJpdHdpc2U6IHRydWUgKi9cblxuICAgIHZhciBjdXJyZW50VGFibGUsIHRlbXAsIGssIGksIGosIG47XG4gICAgdGVtcCA9IDI1NjtcbiAgICBrID0gMDtcblxuICAgIGZvciAoaSA9IDA7IGkgPCA4OyBpKz0xKSB7IC8vIGkrMSBpcyBDb2RlIGxlbmd0aFxuICAgICAgICBmb3IgKGogPSAwOyBqIDwgTFtpXTsgais9MSkge1xuICAgICAgICAgICAgZm9yIChuID0gMDsgbiA8ICh0ZW1wID4+IChpICsgMSkpOyBuKz0xKSB7XG4gICAgICAgICAgICAgICAgdGFiW2tdID0gVltpXVtqXSB8ICgoaSArIDEpIDw8IDgpO1xuICAgICAgICAgICAgICAgIGsrPTE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKGkgPSAxOyBrIDwgMjU2OyBpKz0xLCBrKz0xKSB7XG4gICAgICAgIHRhYltrXSA9IGkgfCBqcGVnLmxvc3NsZXNzLkh1ZmZtYW5UYWJsZS5NU0I7XG4gICAgfVxuXG4gICAgY3VycmVudFRhYmxlID0gMTtcbiAgICBrID0gMDtcblxuICAgIGZvciAoaSA9IDg7IGkgPCAxNjsgaSs9MSkgeyAvLyBpKzEgaXMgQ29kZSBsZW5ndGhcbiAgICAgICAgZm9yIChqID0gMDsgaiA8IExbaV07IGorPTEpIHtcbiAgICAgICAgICAgIGZvciAobiA9IDA7IG4gPCAodGVtcCA+PiAoaSAtIDcpKTsgbis9MSkge1xuICAgICAgICAgICAgICAgIHRhYlsoY3VycmVudFRhYmxlICogMjU2KSArIGtdID0gVltpXVtqXSB8ICgoaSArIDEpIDw8IDgpO1xuICAgICAgICAgICAgICAgIGsrPTE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChrID49IDI1Nikge1xuICAgICAgICAgICAgICAgIGlmIChrID4gMjU2KSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkVSUk9SOiBIdWZmbWFuIHRhYmxlIGVycm9yKDEpIVwiKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBrID0gMDtcbiAgICAgICAgICAgICAgICBjdXJyZW50VGFibGUrPTE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5cbi8qKiogRXhwb3J0cyAqKiovXG5cbnZhciBtb2R1bGVUeXBlID0gdHlwZW9mIG1vZHVsZTtcbmlmICgobW9kdWxlVHlwZSAhPT0gJ3VuZGVmaW5lZCcpICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBqcGVnLmxvc3NsZXNzLkh1ZmZtYW5UYWJsZTtcbn1cbiIsIi8qanNsaW50IGJyb3dzZXI6IHRydWUsIG5vZGU6IHRydWUgKi9cbi8qZ2xvYmFsIHJlcXVpcmUsIG1vZHVsZSAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyoqKiBJbXBvcnRzICoqKi9cbnZhciBqcGVnID0ganBlZyB8fCB7fTtcbmpwZWcubG9zc2xlc3MgPSBqcGVnLmxvc3NsZXNzIHx8IHt9O1xuanBlZy5sb3NzbGVzcy5Db21wb25lbnRTcGVjID0ganBlZy5sb3NzbGVzcy5Db21wb25lbnRTcGVjIHx8ICgodHlwZW9mIHJlcXVpcmUgIT09ICd1bmRlZmluZWQnKSA/IHJlcXVpcmUoJy4vY29tcG9uZW50LXNwZWMuanMnKSA6IG51bGwpO1xuanBlZy5sb3NzbGVzcy5EYXRhU3RyZWFtID0ganBlZy5sb3NzbGVzcy5EYXRhU3RyZWFtIHx8ICgodHlwZW9mIHJlcXVpcmUgIT09ICd1bmRlZmluZWQnKSA/IHJlcXVpcmUoJy4vZGF0YS1zdHJlYW0uanMnKSA6IG51bGwpO1xuanBlZy5sb3NzbGVzcy5EZWNvZGVyID0ganBlZy5sb3NzbGVzcy5EZWNvZGVyIHx8ICgodHlwZW9mIHJlcXVpcmUgIT09ICd1bmRlZmluZWQnKSA/IHJlcXVpcmUoJy4vZGVjb2Rlci5qcycpIDogbnVsbCk7XG5qcGVnLmxvc3NsZXNzLkZyYW1lSGVhZGVyID0ganBlZy5sb3NzbGVzcy5GcmFtZUhlYWRlciB8fCAoKHR5cGVvZiByZXF1aXJlICE9PSAndW5kZWZpbmVkJykgPyByZXF1aXJlKCcuL2ZyYW1lLWhlYWRlci5qcycpIDogbnVsbCk7XG5qcGVnLmxvc3NsZXNzLkh1ZmZtYW5UYWJsZSA9IGpwZWcubG9zc2xlc3MuSHVmZm1hblRhYmxlIHx8ICgodHlwZW9mIHJlcXVpcmUgIT09ICd1bmRlZmluZWQnKSA/IHJlcXVpcmUoJy4vaHVmZm1hbi10YWJsZS5qcycpIDogbnVsbCk7XG5qcGVnLmxvc3NsZXNzLlF1YW50aXphdGlvblRhYmxlID0ganBlZy5sb3NzbGVzcy5RdWFudGl6YXRpb25UYWJsZSB8fCAoKHR5cGVvZiByZXF1aXJlICE9PSAndW5kZWZpbmVkJykgPyByZXF1aXJlKCcuL3F1YW50aXphdGlvbi10YWJsZS5qcycpIDogbnVsbCk7XG5qcGVnLmxvc3NsZXNzLlNjYW5Db21wb25lbnQgPSBqcGVnLmxvc3NsZXNzLlNjYW5Db21wb25lbnQgfHwgKCh0eXBlb2YgcmVxdWlyZSAhPT0gJ3VuZGVmaW5lZCcpID8gcmVxdWlyZSgnLi9zY2FuLWNvbXBvbmVudC5qcycpIDogbnVsbCk7XG5qcGVnLmxvc3NsZXNzLlNjYW5IZWFkZXIgPSBqcGVnLmxvc3NsZXNzLlNjYW5IZWFkZXIgfHwgKCh0eXBlb2YgcmVxdWlyZSAhPT0gJ3VuZGVmaW5lZCcpID8gcmVxdWlyZSgnLi9zY2FuLWhlYWRlci5qcycpIDogbnVsbCk7XG5qcGVnLmxvc3NsZXNzLlV0aWxzID0ganBlZy5sb3NzbGVzcy5VdGlscyB8fCAoKHR5cGVvZiByZXF1aXJlICE9PSAndW5kZWZpbmVkJykgPyByZXF1aXJlKCcuL3V0aWxzLmpzJykgOiBudWxsKTtcblxuXG4vKioqIEV4cG9ydHMgKioqL1xudmFyIG1vZHVsZVR5cGUgPSB0eXBlb2YgbW9kdWxlO1xuaWYgKChtb2R1bGVUeXBlICE9PSAndW5kZWZpbmVkJykgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGpwZWc7XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChDKSAyMDE1IE1pY2hhZWwgTWFydGluZXpcbiAqIENoYW5nZXM6IEFkZGVkIHN1cHBvcnQgZm9yIHNlbGVjdGlvbiB2YWx1ZXMgMi03LCBmaXhlZCBtaW5vciBidWdzICZcbiAqIHdhcm5pbmdzLCBzcGxpdCBpbnRvIG11bHRpcGxlIGNsYXNzIGZpbGVzLCBhbmQgZ2VuZXJhbCBjbGVhbiB1cC5cbiAqXG4gKiAwOC0yNS0yMDE1OiBIZWxtdXQgRGVyc2NoIGFncmVlZCB0byBhIGxpY2Vuc2UgY2hhbmdlIGZyb20gTEdQTCB0byBNSVQuXG4gKi9cblxuLypcbiAqIENvcHlyaWdodCAoQykgSGVsbXV0IERlcnNjaFxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG4vKmpzbGludCBicm93c2VyOiB0cnVlLCBub2RlOiB0cnVlICovXG4vKmdsb2JhbCByZXF1aXJlLCBtb2R1bGUgKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKiogSW1wb3J0cyAqKiovXG52YXIganBlZyA9IGpwZWcgfHwge307XG5qcGVnLmxvc3NsZXNzID0ganBlZy5sb3NzbGVzcyB8fCB7fTtcbmpwZWcubG9zc2xlc3MuRGF0YVN0cmVhbSA9IGpwZWcubG9zc2xlc3MuRGF0YVN0cmVhbSB8fCAoKHR5cGVvZiByZXF1aXJlICE9PSAndW5kZWZpbmVkJykgPyByZXF1aXJlKCcuL2RhdGEtc3RyZWFtLmpzJykgOiBudWxsKTtcbmpwZWcubG9zc2xlc3MuVXRpbHMgPSBqcGVnLmxvc3NsZXNzLlV0aWxzIHx8ICgodHlwZW9mIHJlcXVpcmUgIT09ICd1bmRlZmluZWQnKSA/IHJlcXVpcmUoJy4vdXRpbHMuanMnKSA6IG51bGwpO1xuXG5cbi8qKiogQ29uc3RydWN0b3IgKioqL1xuanBlZy5sb3NzbGVzcy5RdWFudGl6YXRpb25UYWJsZSA9IGpwZWcubG9zc2xlc3MuUXVhbnRpemF0aW9uVGFibGUgfHwgZnVuY3Rpb24gKCkge1xuICAgIHRoaXMucHJlY2lzaW9uID0gW107IC8vIFF1YW50aXphdGlvbiBwcmVjaXNpb24gOCBvciAxNlxuICAgIHRoaXMudHEgPSBbXTsgLy8gMTogdGhpcyB0YWJsZSBpcyBwcmVzZW50ZWRcbiAgICB0aGlzLnF1YW50VGFibGVzID0ganBlZy5sb3NzbGVzcy5VdGlscy5jcmVhdGVBcnJheSg0LCA2NCk7IC8vIFRhYmxlc1xuXG4gICAgdGhpcy50cVswXSA9IDA7XG4gICAgdGhpcy50cVsxXSA9IDA7XG4gICAgdGhpcy50cVsyXSA9IDA7XG4gICAgdGhpcy50cVszXSA9IDA7XG59O1xuXG5cblxuLyoqKiBTdGF0aWMgTWV0aG9kcyAqKiovXG5cbmpwZWcubG9zc2xlc3MuUXVhbnRpemF0aW9uVGFibGUuZW5oYW5jZVF1YW50aXphdGlvblRhYmxlID0gZnVuY3Rpb24ocXRhYiwgdGFibGUpIHtcbiAgICAvKmpzbGludCBiaXR3aXNlOiB0cnVlICovXG5cbiAgICB2YXIgaTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCA4OyBpKz0xKSB7XG4gICAgICAgIHF0YWJbdGFibGVbKDAgKiA4KSArIGldXSAqPSA5MDtcbiAgICAgICAgcXRhYlt0YWJsZVsoNCAqIDgpICsgaV1dICo9IDkwO1xuICAgICAgICBxdGFiW3RhYmxlWygyICogOCkgKyBpXV0gKj0gMTE4O1xuICAgICAgICBxdGFiW3RhYmxlWyg2ICogOCkgKyBpXV0gKj0gNDk7XG4gICAgICAgIHF0YWJbdGFibGVbKDUgKiA4KSArIGldXSAqPSA3MTtcbiAgICAgICAgcXRhYlt0YWJsZVsoMSAqIDgpICsgaV1dICo9IDEyNjtcbiAgICAgICAgcXRhYlt0YWJsZVsoNyAqIDgpICsgaV1dICo9IDI1O1xuICAgICAgICBxdGFiW3RhYmxlWygzICogOCkgKyBpXV0gKj0gMTA2O1xuICAgIH1cblxuICAgIGZvciAoaSA9IDA7IGkgPCA4OyBpKz0xKSB7XG4gICAgICAgIHF0YWJbdGFibGVbMCArICg4ICogaSldXSAqPSA5MDtcbiAgICAgICAgcXRhYlt0YWJsZVs0ICsgKDggKiBpKV1dICo9IDkwO1xuICAgICAgICBxdGFiW3RhYmxlWzIgKyAoOCAqIGkpXV0gKj0gMTE4O1xuICAgICAgICBxdGFiW3RhYmxlWzYgKyAoOCAqIGkpXV0gKj0gNDk7XG4gICAgICAgIHF0YWJbdGFibGVbNSArICg4ICogaSldXSAqPSA3MTtcbiAgICAgICAgcXRhYlt0YWJsZVsxICsgKDggKiBpKV1dICo9IDEyNjtcbiAgICAgICAgcXRhYlt0YWJsZVs3ICsgKDggKiBpKV1dICo9IDI1O1xuICAgICAgICBxdGFiW3RhYmxlWzMgKyAoOCAqIGkpXV0gKj0gMTA2O1xuICAgIH1cblxuICAgIGZvciAoaSA9IDA7IGkgPCA2NDsgaSs9MSkge1xuICAgICAgICBxdGFiW2ldID4+PSA2O1xuICAgIH1cbn07XG5cblxuLyoqKiBQcm90b3R5cGUgTWV0aG9kcyAqKiovXG5cbmpwZWcubG9zc2xlc3MuUXVhbnRpemF0aW9uVGFibGUucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbiAoZGF0YSwgdGFibGUpIHtcbiAgICAvKmpzbGludCBiaXR3aXNlOiB0cnVlICovXG5cbiAgICB2YXIgY291bnQgPSAwLCBsZW5ndGgsIHRlbXAsIHQsIGk7XG5cbiAgICBsZW5ndGggPSBkYXRhLmdldDE2KCk7XG4gICAgY291bnQgKz0gMjtcblxuICAgIHdoaWxlIChjb3VudCA8IGxlbmd0aCkge1xuICAgICAgICB0ZW1wID0gZGF0YS5nZXQ4KCk7XG4gICAgICAgIGNvdW50Kz0xO1xuICAgICAgICB0ID0gdGVtcCAmIDB4MEY7XG5cbiAgICAgICAgaWYgKHQgPiAzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFUlJPUjogUXVhbnRpemF0aW9uIHRhYmxlIElEID4gM1wiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucHJlY2lzaW9uW3RdID0gdGVtcCA+PiA0O1xuXG4gICAgICAgIGlmICh0aGlzLnByZWNpc2lvblt0XSA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5wcmVjaXNpb25bdF0gPSA4O1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMucHJlY2lzaW9uW3RdID09PSAxKSB7XG4gICAgICAgICAgICB0aGlzLnByZWNpc2lvblt0XSA9IDE2O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRVJST1I6IFF1YW50aXphdGlvbiB0YWJsZSBwcmVjaXNpb24gZXJyb3JcIik7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnRxW3RdID0gMTtcblxuICAgICAgICBpZiAodGhpcy5wcmVjaXNpb25bdF0gPT09IDgpIHtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCA2NDsgaSs9MSkge1xuICAgICAgICAgICAgICAgIGlmIChjb3VudCA+IGxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFUlJPUjogUXVhbnRpemF0aW9uIHRhYmxlIGZvcm1hdCBlcnJvclwiKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLnF1YW50VGFibGVzW3RdW2ldID0gZGF0YS5nZXQ4KCk7XG4gICAgICAgICAgICAgICAgY291bnQrPTE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGpwZWcubG9zc2xlc3MuUXVhbnRpemF0aW9uVGFibGUuZW5oYW5jZVF1YW50aXphdGlvblRhYmxlKHRoaXMucXVhbnRUYWJsZXNbdF0sIHRhYmxlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCA2NDsgaSs9MSkge1xuICAgICAgICAgICAgICAgIGlmIChjb3VudCA+IGxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFUlJPUjogUXVhbnRpemF0aW9uIHRhYmxlIGZvcm1hdCBlcnJvclwiKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLnF1YW50VGFibGVzW3RdW2ldID0gZGF0YS5nZXQxNigpO1xuICAgICAgICAgICAgICAgIGNvdW50ICs9IDI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGpwZWcubG9zc2xlc3MuUXVhbnRpemF0aW9uVGFibGUuZW5oYW5jZVF1YW50aXphdGlvblRhYmxlKHRoaXMucXVhbnRUYWJsZXNbdF0sIHRhYmxlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjb3VudCAhPT0gbGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkVSUk9SOiBRdWFudGl6YXRpb24gdGFibGUgZXJyb3IgW2NvdW50IT1McV1cIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIDE7XG59O1xuXG5cblxuLyoqKiBFeHBvcnRzICoqKi9cblxudmFyIG1vZHVsZVR5cGUgPSB0eXBlb2YgbW9kdWxlO1xuaWYgKChtb2R1bGVUeXBlICE9PSAndW5kZWZpbmVkJykgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGpwZWcubG9zc2xlc3MuUXVhbnRpemF0aW9uVGFibGU7XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChDKSAyMDE1IE1pY2hhZWwgTWFydGluZXpcbiAqIENoYW5nZXM6IEFkZGVkIHN1cHBvcnQgZm9yIHNlbGVjdGlvbiB2YWx1ZXMgMi03LCBmaXhlZCBtaW5vciBidWdzICZcbiAqIHdhcm5pbmdzLCBzcGxpdCBpbnRvIG11bHRpcGxlIGNsYXNzIGZpbGVzLCBhbmQgZ2VuZXJhbCBjbGVhbiB1cC5cbiAqXG4gKiAwOC0yNS0yMDE1OiBIZWxtdXQgRGVyc2NoIGFncmVlZCB0byBhIGxpY2Vuc2UgY2hhbmdlIGZyb20gTEdQTCB0byBNSVQuXG4gKi9cblxuLypcbiAqIENvcHlyaWdodCAoQykgSGVsbXV0IERlcnNjaFxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG4vKmpzbGludCBicm93c2VyOiB0cnVlLCBub2RlOiB0cnVlICovXG4vKmdsb2JhbCByZXF1aXJlLCBtb2R1bGUgKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKiogSW1wb3J0cyAqKiovXG52YXIganBlZyA9IGpwZWcgfHwge307XG5qcGVnLmxvc3NsZXNzID0ganBlZy5sb3NzbGVzcyB8fCB7fTtcblxuXG4vKioqIENvbnN0cnVjdG9yICoqKi9cbmpwZWcubG9zc2xlc3MuU2NhbkNvbXBvbmVudCA9IGpwZWcubG9zc2xlc3MuU2NhbkNvbXBvbmVudCB8fCBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5hY1RhYlNlbCA9IDA7IC8vIEFDIHRhYmxlIHNlbGVjdG9yXG4gICAgdGhpcy5kY1RhYlNlbCA9IDA7IC8vIERDIHRhYmxlIHNlbGVjdG9yXG4gICAgdGhpcy5zY2FuQ29tcFNlbCA9IDA7IC8vIFNjYW4gY29tcG9uZW50IHNlbGVjdG9yXG59O1xuXG5cblxuLyoqKiBFeHBvcnRzICoqKi9cblxudmFyIG1vZHVsZVR5cGUgPSB0eXBlb2YgbW9kdWxlO1xuaWYgKChtb2R1bGVUeXBlICE9PSAndW5kZWZpbmVkJykgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGpwZWcubG9zc2xlc3MuU2NhbkNvbXBvbmVudDtcbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTUgTWljaGFlbCBNYXJ0aW5lelxuICogQ2hhbmdlczogQWRkZWQgc3VwcG9ydCBmb3Igc2VsZWN0aW9uIHZhbHVlcyAyLTcsIGZpeGVkIG1pbm9yIGJ1Z3MgJlxuICogd2FybmluZ3MsIHNwbGl0IGludG8gbXVsdGlwbGUgY2xhc3MgZmlsZXMsIGFuZCBnZW5lcmFsIGNsZWFuIHVwLlxuICpcbiAqIDA4LTI1LTIwMTU6IEhlbG11dCBEZXJzY2ggYWdyZWVkIHRvIGEgbGljZW5zZSBjaGFuZ2UgZnJvbSBMR1BMIHRvIE1JVC5cbiAqL1xuXG4vKlxuICogQ29weXJpZ2h0IChDKSBIZWxtdXQgRGVyc2NoXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbi8qanNsaW50IGJyb3dzZXI6IHRydWUsIG5vZGU6IHRydWUgKi9cbi8qZ2xvYmFsIHJlcXVpcmUsIG1vZHVsZSAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyoqKiBJbXBvcnRzICoqKi9cbnZhciBqcGVnID0ganBlZyB8fCB7fTtcbmpwZWcubG9zc2xlc3MgPSBqcGVnLmxvc3NsZXNzIHx8IHt9O1xuanBlZy5sb3NzbGVzcy5EYXRhU3RyZWFtID0ganBlZy5sb3NzbGVzcy5EYXRhU3RyZWFtIHx8ICgodHlwZW9mIHJlcXVpcmUgIT09ICd1bmRlZmluZWQnKSA/IHJlcXVpcmUoJy4vZGF0YS1zdHJlYW0uanMnKSA6IG51bGwpO1xuanBlZy5sb3NzbGVzcy5TY2FuQ29tcG9uZW50ID0ganBlZy5sb3NzbGVzcy5TY2FuQ29tcG9uZW50IHx8ICgodHlwZW9mIHJlcXVpcmUgIT09ICd1bmRlZmluZWQnKSA/IHJlcXVpcmUoJy4vc2Nhbi1jb21wb25lbnQuanMnKSA6IG51bGwpO1xuXG5cbi8qKiogQ29uc3RydWN0b3IgKioqL1xuanBlZy5sb3NzbGVzcy5TY2FuSGVhZGVyID0ganBlZy5sb3NzbGVzcy5TY2FuSGVhZGVyIHx8IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmFoID0gMDtcbiAgICB0aGlzLmFsID0gMDtcbiAgICB0aGlzLm51bUNvbXAgPSAwOyAvLyBOdW1iZXIgb2YgY29tcG9uZW50cyBpbiB0aGUgc2NhblxuICAgIHRoaXMuc2VsZWN0aW9uID0gMDsgLy8gU3RhcnQgb2Ygc3BlY3RyYWwgb3IgcHJlZGljdG9yIHNlbGVjdGlvblxuICAgIHRoaXMuc3BlY3RyYWxFbmQgPSAwOyAvLyBFbmQgb2Ygc3BlY3RyYWwgc2VsZWN0aW9uXG4gICAgdGhpcy5jb21wb25lbnRzID0gW107XG59O1xuXG5cbi8qKiogUHJvdG90eXBlIE1ldGhvZHMgKioqL1xuXG5qcGVnLmxvc3NsZXNzLlNjYW5IZWFkZXIucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgLypqc2xpbnQgYml0d2lzZTogdHJ1ZSAqL1xuXG4gICAgdmFyIGNvdW50ID0gMCwgbGVuZ3RoLCBpLCB0ZW1wO1xuXG4gICAgbGVuZ3RoID0gZGF0YS5nZXQxNigpO1xuICAgIGNvdW50ICs9IDI7XG5cbiAgICB0aGlzLm51bUNvbXAgPSBkYXRhLmdldDgoKTtcbiAgICBjb3VudCs9MTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLm51bUNvbXA7IGkrPTEpIHtcbiAgICAgICAgdGhpcy5jb21wb25lbnRzW2ldID0gbmV3IGpwZWcubG9zc2xlc3MuU2NhbkNvbXBvbmVudCgpO1xuXG4gICAgICAgIGlmIChjb3VudCA+IGxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRVJST1I6IHNjYW4gaGVhZGVyIGZvcm1hdCBlcnJvclwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY29tcG9uZW50c1tpXS5zY2FuQ29tcFNlbCA9IGRhdGEuZ2V0OCgpO1xuICAgICAgICBjb3VudCs9MTtcblxuICAgICAgICB0ZW1wID0gZGF0YS5nZXQ4KCk7XG4gICAgICAgIGNvdW50Kz0xO1xuXG4gICAgICAgIHRoaXMuY29tcG9uZW50c1tpXS5kY1RhYlNlbCA9ICh0ZW1wID4+IDQpO1xuICAgICAgICB0aGlzLmNvbXBvbmVudHNbaV0uYWNUYWJTZWwgPSAodGVtcCAmIDB4MEYpO1xuICAgIH1cblxuICAgIHRoaXMuc2VsZWN0aW9uID0gZGF0YS5nZXQ4KCk7XG4gICAgY291bnQrPTE7XG5cbiAgICB0aGlzLnNwZWN0cmFsRW5kID0gZGF0YS5nZXQ4KCk7XG4gICAgY291bnQrPTE7XG5cbiAgICB0ZW1wID0gZGF0YS5nZXQ4KCk7XG4gICAgdGhpcy5haCA9ICh0ZW1wID4+IDQpO1xuICAgIHRoaXMuYWwgPSAodGVtcCAmIDB4MEYpO1xuICAgIGNvdW50Kz0xO1xuXG4gICAgaWYgKGNvdW50ICE9PSBsZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRVJST1I6IHNjYW4gaGVhZGVyIGZvcm1hdCBlcnJvciBbY291bnQhPU5zXVwiKTtcbiAgICB9XG5cbiAgICByZXR1cm4gMTtcbn07XG5cblxuXG4vKioqIEV4cG9ydHMgKioqL1xuXG52YXIgbW9kdWxlVHlwZSA9IHR5cGVvZiBtb2R1bGU7XG5pZiAoKG1vZHVsZVR5cGUgIT09ICd1bmRlZmluZWQnKSAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgIG1vZHVsZS5leHBvcnRzID0ganBlZy5sb3NzbGVzcy5TY2FuSGVhZGVyO1xufVxuIiwiLypcbiAqIENvcHlyaWdodCAoQykgMjAxNSBNaWNoYWVsIE1hcnRpbmV6XG4gKiBDaGFuZ2VzOiBBZGRlZCBzdXBwb3J0IGZvciBzZWxlY3Rpb24gdmFsdWVzIDItNywgZml4ZWQgbWlub3IgYnVncyAmXG4gKiB3YXJuaW5ncywgc3BsaXQgaW50byBtdWx0aXBsZSBjbGFzcyBmaWxlcywgYW5kIGdlbmVyYWwgY2xlYW4gdXAuXG4gKlxuICogMDgtMjUtMjAxNTogSGVsbXV0IERlcnNjaCBhZ3JlZWQgdG8gYSBsaWNlbnNlIGNoYW5nZSBmcm9tIExHUEwgdG8gTUlULlxuICovXG5cbi8qXG4gKiBDb3B5cmlnaHQgKEMpIEhlbG11dCBEZXJzY2hcbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxuLypqc2xpbnQgYnJvd3NlcjogdHJ1ZSwgbm9kZTogdHJ1ZSAqL1xuLypnbG9iYWwgcmVxdWlyZSwgbW9kdWxlICovXG5cblwidXNlIHN0cmljdFwiO1xuXG4vKioqIEltcG9ydHMgKioqL1xudmFyIGpwZWcgPSBqcGVnIHx8IHt9O1xuanBlZy5sb3NzbGVzcyA9IGpwZWcubG9zc2xlc3MgfHwge307XG5cblxuLyoqKiBDb25zdHJ1Y3RvciAqKiovXG5qcGVnLmxvc3NsZXNzLlV0aWxzID0ganBlZy5sb3NzbGVzcy5VdGlscyB8fCB7fTtcblxuXG4vKioqIFN0YXRpYyBtZXRob2RzICoqKi9cblxuLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy85NjYyMjUvaG93LWNhbi1pLWNyZWF0ZS1hLXR3by1kaW1lbnNpb25hbC1hcnJheS1pbi1qYXZhc2NyaXB0XG5qcGVnLmxvc3NsZXNzLlV0aWxzLmNyZWF0ZUFycmF5ID0gZnVuY3Rpb24gKGxlbmd0aCkge1xuICAgIHZhciBhcnIgPSBuZXcgQXJyYXkobGVuZ3RoIHx8IDApLFxuICAgICAgICBpID0gbGVuZ3RoO1xuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgd2hpbGUoaS0tKSBhcnJbbGVuZ3RoLTEgLSBpXSA9IGpwZWcubG9zc2xlc3MuVXRpbHMuY3JlYXRlQXJyYXkuYXBwbHkodGhpcywgYXJncyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFycjtcbn07XG5cblxuLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xODYzODkwMC9qYXZhc2NyaXB0LWNyYzMyXG5qcGVnLmxvc3NsZXNzLlV0aWxzLm1ha2VDUkNUYWJsZSA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIGM7XG4gICAgdmFyIGNyY1RhYmxlID0gW107XG4gICAgZm9yKHZhciBuID0wOyBuIDwgMjU2OyBuKyspe1xuICAgICAgICBjID0gbjtcbiAgICAgICAgZm9yKHZhciBrID0wOyBrIDwgODsgaysrKXtcbiAgICAgICAgICAgIGMgPSAoKGMmMSkgPyAoMHhFREI4ODMyMCBeIChjID4+PiAxKSkgOiAoYyA+Pj4gMSkpO1xuICAgICAgICB9XG4gICAgICAgIGNyY1RhYmxlW25dID0gYztcbiAgICB9XG4gICAgcmV0dXJuIGNyY1RhYmxlO1xufTtcblxuanBlZy5sb3NzbGVzcy5VdGlscy5jcmMzMiA9IGZ1bmN0aW9uKGRhdGFWaWV3KSB7XG4gICAgdmFyIGNyY1RhYmxlID0ganBlZy5sb3NzbGVzcy5VdGlscy5jcmNUYWJsZSB8fCAoanBlZy5sb3NzbGVzcy5VdGlscy5jcmNUYWJsZSA9IGpwZWcubG9zc2xlc3MuVXRpbHMubWFrZUNSQ1RhYmxlKCkpO1xuICAgIHZhciBjcmMgPSAwIF4gKC0xKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YVZpZXcuYnl0ZUxlbmd0aDsgaSsrICkge1xuICAgICAgICBjcmMgPSAoY3JjID4+PiA4KSBeIGNyY1RhYmxlWyhjcmMgXiBkYXRhVmlldy5nZXRVaW50OChpKSkgJiAweEZGXTtcbiAgICB9XG5cbiAgICByZXR1cm4gKGNyYyBeICgtMSkpID4+PiAwO1xufTtcblxuXG4vKioqIEV4cG9ydHMgKioqL1xuXG52YXIgbW9kdWxlVHlwZSA9IHR5cGVvZiBtb2R1bGU7XG5pZiAoKG1vZHVsZVR5cGUgIT09ICd1bmRlZmluZWQnKSAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgIG1vZHVsZS5leHBvcnRzID0ganBlZy5sb3NzbGVzcy5VdGlscztcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4qIEZVTkNUSU9OOiBhYnMoIHggKVxuKlx0Q29tcHV0ZXMgdGhlIGFic29sdXRlIHZhbHVlIG9mIGB4YC5cbipcbiogQHBhcmFtIHtOdW1iZXJ9IHggLSBpbnB1dCB2YWx1ZVxuKiBAcmV0dXJucyB7TnVtYmVyfSBhYnNvbHV0ZSB2YWx1ZVxuKi9cbmZ1bmN0aW9uIGFicyggeCApIHtcblx0aWYgKCB4IDwgMCApIHtcblx0XHRyZXR1cm4gLXg7XG5cdH1cblx0aWYgKCB4ID09PSAwICkge1xuXHRcdHJldHVybiAwOyAvLyBoYW5kbGUgbmVnYXRpdmUgemVyb1xuXHR9XG5cdHJldHVybiB4O1xufSAvLyBlbmQgRlVOQ1RJT04gYWJzKClcblxuXG4vLyBFWFBPUlRTIC8vXG5cbm1vZHVsZS5leHBvcnRzID0gYWJzO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyBFWFBPUlRTIC8vXG5cbm1vZHVsZS5leHBvcnRzID0gTWF0aC5jZWlsO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyBNT0RVTEVTIC8vXG5cbnZhciBmbG9vciA9IHJlcXVpcmUoICdtYXRoLWZsb29yJyApO1xuXG5cbi8vIERJVjIgLy9cblxuLyoqXG4qIEZVTkNUSU9OOiBkaXYyKCB4IClcbipcdENvbnZlcnRzIGEgbm9ubmVnYXRpdmUgaW50ZWdlciB0byBhIGxpdGVyYWwgYml0IHJlcHJlc2VudGF0aW9uIHVzaW5nIHRoZSBkaXZpZGUtYnktMiBhbGdvcml0aG0uXG4qXG4qIEBwYXJhbSB7TnVtYmVyfSB4IC0gbm9ubmVnYXRpdmUgaW50ZWdlclxuKiBAcmV0dXJucyB7U3RyaW5nfSBiaXQgcmVwcmVzZW50YXRpb25cbiovXG5mdW5jdGlvbiBkaXYyKCB4ICkge1xuXHR2YXIgc3RyID0gJyc7XG5cdHZhciB5O1xuXG5cdC8vIFdlIHJlcGVhdGVkbHkgZGl2aWRlIGJ5IDIgYW5kIGNoZWNrIGZvciBhIHJlbWFpbmRlci4gSWYgYSByZW1haW5kZXIgZXhpc3RzLCB0aGUgbnVtYmVyIGlzIG9kZCBhbmQgd2UgYWRkIGEgJzEnIGJpdC4uLlxuXHR3aGlsZSAoIHggPiAwICkge1xuXHRcdHkgPSB4IC8gMjtcblx0XHR4ID0gZmxvb3IoIHkgKTtcblx0XHRpZiAoIHkgPT09IHggKSB7XG5cdFx0XHRzdHIgPSAnMCcgKyBzdHI7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHN0ciA9ICcxJyArIHN0cjtcblx0XHR9XG5cdH1cblx0cmV0dXJuIHN0cjtcbn0gLy8gZW5kIEZVTkNUSU9OIGRpdjIoKVxuXG5cbi8vIEVYUE9SVFMgLy9cblxubW9kdWxlLmV4cG9ydHMgPSBkaXYyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyBNT0RVTEVTIC8vXG5cbnZhciBwaW5mID0gcmVxdWlyZSggJ2NvbnN0LXBpbmYtZmxvYXQzMicgKTtcbnZhciBuaW5mID0gcmVxdWlyZSggJ2NvbnN0LW5pbmYtZmxvYXQzMicgKTtcbnZhciBhYnMgPSByZXF1aXJlKCAnbWF0aC1hYnMnICk7XG52YXIgZmxvb3IgPSByZXF1aXJlKCAnbWF0aC1mbG9vcicgKTtcbnZhciBycGFkID0gcmVxdWlyZSggJ3V0aWxzLXJpZ2h0LXBhZC1zdHJpbmcnICk7XG52YXIgbHBhZCA9IHJlcXVpcmUoICd1dGlscy1sZWZ0LXBhZC1zdHJpbmcnICk7XG52YXIgcmVwZWF0ID0gcmVxdWlyZSggJ3V0aWxzLXJlcGVhdC1zdHJpbmcnICk7XG52YXIgZGl2MiA9IHJlcXVpcmUoICcuL2RpdjIuanMnICk7XG52YXIgbXVsdDIgPSByZXF1aXJlKCAnLi9tdWx0Mi5qcycgKTtcblxuXG4vLyBDT05TVEFOVFMgLy9cblxudmFyIEJJQVMgPSAxMjc7IC8vIGV4cG9uZW50IGJpYXMgPT4gKDIqKjgpLzIgLSAxXG5cblxuLy8gQklOQVJZIFNUUklORyAvL1xuXG4vKipcbiogRlVOQ1RJT046IGJpbmFyeVN0cmluZyggeCApXG4qXHRSZXR1cm5zIGEgc3RyaW5nIGdpdmluZyB0aGUgbGl0ZXJhbCBiaXQgcmVwcmVzZW50YXRpb24gb2YgYSBzaW5nbGUtcHJlY2lzaW9uIGZsb2F0aW5nLXBvaW50IG51bWJlci5cbipcbiogQHBhcmFtIHtOdW1iZXJ9IHggLSBpbnB1dCB2YWx1ZVxuKiBAcmV0dXJucyB7U3RyaW5nfSBiaXQgcmVwcmVzZW50YXRpb25cbiovXG5mdW5jdGlvbiBiaW5hcnlTdHJpbmcoIHggKSB7XG5cdHZhciBuYml0cztcblx0dmFyIHNpZ247XG5cdHZhciBzdHI7XG5cdHZhciBleHA7XG5cdHZhciBuO1xuXHR2YXIgZjtcblx0dmFyIGk7XG5cblx0Ly8gQ2hlY2sgZm9yIGEgbmVnYXRpdmUgdmFsdWUgb3IgbmVnYXRpdmUgemVyby4uLlxuXHRpZiAoIHggPCAwIHx8IDEveCA9PT0gbmluZiApIHtcblx0XHRzaWduID0gJzEnO1xuXHR9IGVsc2Uge1xuXHRcdHNpZ24gPSAnMCc7XG5cdH1cblx0Ly8gU3BlY2lhbCBjYXNlOiArLWluZmluaXR5XG5cdGlmICggeCA9PT0gcGluZiB8fCB4ID09PSBuaW5mICkge1xuXHRcdC8vIEJhc2VkIG9uIElFRUUgNzU0LTIwMDguLi5cblx0XHRleHAgPSByZXBlYXQoICcxJywgOCApOyAvLyBhbGwgMXNcblx0XHRzdHIgPSByZXBlYXQoICcwJywgMjMgKTsgLy8gYWxsIDBzXG5cdFx0cmV0dXJuIHNpZ24gKyBleHAgKyBzdHI7XG5cdH1cblx0Ly8gU3BlY2lhbCBjYXNlOiBOYU5cblx0aWYgKCB4ICE9PSB4ICkge1xuXHRcdC8vIEJhc2VkIG9uIElFRUUgNzU0LTIwMDguLi5cblx0XHRleHAgPSByZXBlYXQoICcxJywgOCApOyAvLyBhbGwgMXNcblx0XHRzdHIgPSAnMScgKyByZXBlYXQoICcwJywgMjIgKTsgLy8gY2FuJ3QgYmUgYWxsIDBzXG5cdFx0cmV0dXJuIHNpZ24gKyBleHAgKyBzdHI7XG5cdH1cblx0Ly8gU3BlY2lhbCBjYXNlOiArLTBcblx0aWYgKCB4ID09PSAwICkge1xuXHRcdC8vIEJhc2VkIG9uIElFRUUgNzU0LTIwMDguLi5cblx0XHRleHAgPSByZXBlYXQoICcwJywgOCApOyAvLyBhbGwgMHNcblx0XHRzdHIgPSByZXBlYXQoICcwJywgMjMgKTsgLy8gYWxsIDBzXG5cdFx0cmV0dXJuIHNpZ24gKyBleHAgKyBzdHI7XG5cdH1cblx0eCA9IGFicyggeCApO1xuXG5cdC8vIElzb2xhdGUgdGhlIGludGVnZXIgcGFydCAoZGlnaXRzIGJlZm9yZSB0aGUgZGVjaW1hbCk6XG5cdG4gPSBmbG9vciggeCApO1xuXG5cdC8vIElzb2xhdGUgdGhlIGZyYWN0aW9uYWwgcGFydCAoZGlnaXRzIGFmdGVyIHRoZSBkZWNpbWFsKTpcblx0ZiA9IHggLSBuO1xuXG5cdC8vIENvbnZlcnQgdGhlIGludGVnZXIgYW5kIGZyYWN0aW9uYWwgcGFydHMgdG8gYml0IHN0cmluZ3M6XG5cdG4gPSBkaXYyKCBuICk7XG5cdGYgPSBtdWx0MiggZiApO1xuXG5cdC8vIERldGVybWluZSB0aGUgZXhwb25lbnQgbmVlZGVkIHRvIG5vcm1hbGl6ZSB0aGUgaW50ZWdlcitmcmFjdGlvbmFsIHBhcnRzLi4uXG5cdGlmICggbiApIHtcblx0XHQvLyBNb3ZlIHRoZSBkZWNpbWFsIGBkYCBkaWdpdHMgdG8gdGhlIGxlZnQ6XG5cdFx0ZXhwID0gbi5sZW5ndGggLSAxO1xuXHR9IGVsc2Uge1xuXHRcdC8vIEZpbmQgdGhlIGZpcnN0ICcxJyBiaXQuLi5cblx0XHRmb3IgKCBpID0gMDsgaSA8IGYubGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRpZiAoIGZbIGkgXSA9PT0gJzEnICkge1xuXHRcdFx0XHRuYml0cyA9IGkgKyAxO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cdFx0Ly8gTW92ZSB0aGUgZGVjaW1hbCBgZGAgZGlnaXRzIHRvIHRoZSByaWdodDpcblx0XHRleHAgPSAtbmJpdHM7XG5cdH1cblx0Ly8gTm9ybWFsaXplIHRoZSBjb21iaW5lZCBpbnRlZ2VyK2ZyYWN0aW9uYWwgc3RyaW5nLi4uXG5cdHN0ciA9IG4gKyBmO1xuXHRpZiAoIGV4cCA8IDAgKSB7XG5cdFx0Ly8gSGFuZGxlIHN1Ym5vcm1hbHMuLi5cblx0XHRpZiAoIGV4cCA8PSAtQklBUyApIHtcblx0XHRcdC8vIENhcCB0aGUgbnVtYmVyIG9mIGJpdHMgcmVtb3ZlZDpcblx0XHRcdG5iaXRzID0gQklBUyAtIDE7XG5cdFx0fVxuXHRcdC8vIFJlbW92ZSBhbGwgbGVhZGluZyB6ZXJvcyBhbmQgdGhlIGZpcnN0ICcxJyBmb3Igbm9ybWFsIHZhbHVlcywgYW5kLCBmb3Igc3Vibm9ybWFscywgcmVtb3ZlIGF0IG1vc3QgQklBUy0xIGxlYWRpbmcgYml0czpcblx0XHRzdHIgPSBzdHIuc3Vic3RyaW5nKCBuYml0cyApO1xuXHR9IGVsc2Uge1xuXHRcdC8vIFJlbW92ZSB0aGUgbGVhZGluZyAnMScgKGltcGxpY2l0L2hpZGRlbiBiaXQpOlxuXHRcdHN0ciA9IHN0ci5zdWJzdHJpbmcoIDEgKTtcblx0fVxuXHQvLyBDb252ZXJ0IHRoZSBleHBvbmVudCB0byBhIGJpdCBzdHJpbmc6XG5cdGV4cCA9IGRpdjIoIGV4cCArIEJJQVMgKTtcblx0ZXhwID0gbHBhZCggZXhwLCA4LCAnMCcgKTtcblxuXHQvLyBGaWxsIGluIGFueSB0cmFpbGluZyB6ZXJvcyBhbmQgZW5zdXJlIHdlIGhhdmUgb25seSAyMyBmcmFjdGlvbiBiaXRzOlxuXHRzdHIgPSBycGFkKCBzdHIsIDIzLCAnMCcgKS5zdWJzdHJpbmcoIDAsIDIzICk7XG5cblx0Ly8gUmV0dXJuIGEgYml0IHJlcHJlc2VudGF0aW9uOlxuXHRyZXR1cm4gc2lnbiArIGV4cCArIHN0cjtcbn0gLy8gZW5kIEZVTkNUSU9OIGJpbmFyeVN0cmluZygpXG5cblxuLy8gRVhQT1JUUyAvL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGJpbmFyeVN0cmluZztcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gVkFSSUFCTEVTIC8vXG5cbnZhciBNQVhfSVRFUiA9IDE0OTsgLy8gMTI3KzIyIChzdWJub3JtYWxzKVxudmFyIE1BWF9CSVRTID0gMjQ7IC8vIG9ubHkgMjMgYml0cyBmb3IgZnJhY3Rpb25cblxuXG4vLyBNVUxUMiAvL1xuXG4vKipcbiogRlVOQ1RJT046IG11bHQyKCB4IClcbipcdENvbnZlcnRzIGEgZnJhY3Rpb24gdG8gYSBsaXRlcmFsIGJpdCByZXByZXNlbnRhdGlvbiB1c2luZyB0aGUgbXVsdGlwbHktYnktMiBhbGdvcml0aG0uXG4qXG4qIEBwYXJhbSB7TnVtYmVyfSB4IC0gbnVtYmVyIGxlc3MgdGhhbiAxXG4qIEByZXR1cm5zIHtTdHJpbmd9IGJpdCByZXByZXNlbnRhdGlvblxuKi9cbmZ1bmN0aW9uIG11bHQyKCB4ICkge1xuXHR2YXIgc3RyO1xuXHR2YXIgeTtcblx0dmFyIGk7XG5cdHZhciBqO1xuXG5cdHN0ciA9ICcnO1xuXHRpZiAoIHggPT09IDAgKSB7XG5cdFx0cmV0dXJuIHN0cjtcblx0fVxuXHRqID0gTUFYX0lURVI7XG5cblx0Ly8gRWFjaCB0aW1lIHdlIG11bHRpcGx5IGJ5IDIgYW5kIGZpbmQgYSBvbmVzIGRpZ2l0LCBhZGQgYSAnMSc7IG90aGVyd2lzZSwgYWRkIGEgJzAnLi5cblx0Zm9yICggaSA9IDA7IGkgPCBNQVhfSVRFUjsgaSsrICkge1xuXHRcdHkgPSB4ICogMjtcblx0XHRpZiAoIHkgPj0gMSApIHtcblx0XHRcdHggPSB5IC0gMTtcblx0XHRcdHN0ciArPSAnMSc7XG5cdFx0XHRpZiAoIGogPT09IE1BWF9JVEVSICkge1xuXHRcdFx0XHRqID0gaTsgLy8gZmlyc3QgJzEnXG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHggPSB5O1xuXHRcdFx0c3RyICs9ICcwJztcblx0XHR9XG5cdFx0Ly8gU3RvcCB3aGVuIHdlIGhhdmUgbm8gbW9yZSBkZWNpbWFscyB0byBwcm9jZXNzIG9yIGluIHRoZSBldmVudCB3ZSBmb3VuZCBhIGZyYWN0aW9uIHdoaWNoIGNhbm5vdCBiZSByZXByZXNlbnRlZCBpbiBhIGZpbml0ZSBudW1iZXIgb2YgYml0cy4uLlxuXHRcdGlmICggeSA9PT0gMSB8fCBpLWogPiBNQVhfQklUUyApIHtcblx0XHRcdGJyZWFrO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gc3RyO1xufSAvLyBlbmQgRlVOQ1RJT04gbXVsdDIoKVxuXG5cbi8vIEVYUE9SVFMgLy9cblxubW9kdWxlLmV4cG9ydHMgPSBtdWx0MjtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gRVhQT1JUUyAvL1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1hdGguZmxvb3I7XG4iLCJcbi8qanNsaW50IGJyb3dzZXI6IHRydWUsIG5vZGU6IHRydWUgKi9cbi8qZ2xvYmFsIHJlcXVpcmUsIG1vZHVsZSAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyoqKiBJbXBvcnRzICoqKi9cblxuLyoqXG4gKiBuaWZ0aVxuICogQHR5cGUgeyp8e319XG4gKi9cbnZhciBuaWZ0aSA9IG5pZnRpIHx8IHt9O1xubmlmdGkuTklGVEkxID0gbmlmdGkuTklGVEkxIHx8ICgodHlwZW9mIHJlcXVpcmUgIT09ICd1bmRlZmluZWQnKSA/IHJlcXVpcmUoJy4vbmlmdGkxLmpzJykgOiBudWxsKTtcbm5pZnRpLk5JRlRJMiA9IG5pZnRpLk5JRlRJMiB8fCAoKHR5cGVvZiByZXF1aXJlICE9PSAndW5kZWZpbmVkJykgPyByZXF1aXJlKCcuL25pZnRpMi5qcycpIDogbnVsbCk7XG5uaWZ0aS5VdGlscyA9IG5pZnRpLlV0aWxzIHx8ICgodHlwZW9mIHJlcXVpcmUgIT09ICd1bmRlZmluZWQnKSA/IHJlcXVpcmUoJy4vdXRpbGl0aWVzLmpzJykgOiBudWxsKTtcblxudmFyIHBha28gPSBwYWtvIHx8ICgodHlwZW9mIHJlcXVpcmUgIT09ICd1bmRlZmluZWQnKSA/IHJlcXVpcmUoJ3Bha28nKSA6IG51bGwpO1xuXG5cblxuLyoqKiBTdGF0aWMgTWV0aG9kcyAqKiovXG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoaXMgZGF0YSByZXByZXNlbnRzIGEgTklGVEktMSBoZWFkZXIuXG4gKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBkYXRhXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xubmlmdGkuaXNOSUZUSTEgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHZhciBidWYsIG1hZzEsIG1hZzIsIG1hZzM7XG5cbiAgICBidWYgPSBuZXcgRGF0YVZpZXcoZGF0YSk7XG4gICAgbWFnMSA9IGJ1Zi5nZXRVaW50OChuaWZ0aS5OSUZUSTEuTUFHSUNfTlVNQkVSX0xPQ0FUSU9OKTtcbiAgICBtYWcyID0gYnVmLmdldFVpbnQ4KG5pZnRpLk5JRlRJMS5NQUdJQ19OVU1CRVJfTE9DQVRJT04gKyAxKTtcbiAgICBtYWczID0gYnVmLmdldFVpbnQ4KG5pZnRpLk5JRlRJMS5NQUdJQ19OVU1CRVJfTE9DQVRJT04gKyAyKTtcblxuICAgIHJldHVybiAhISgobWFnMSA9PT0gbmlmdGkuTklGVEkxLk1BR0lDX05VTUJFUlswXSkgJiYgKG1hZzIgPT09IG5pZnRpLk5JRlRJMS5NQUdJQ19OVU1CRVJbMV0pICYmXG4gICAgICAgIChtYWczID09PSBuaWZ0aS5OSUZUSTEuTUFHSUNfTlVNQkVSWzJdKSk7XG59O1xuXG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoaXMgZGF0YSByZXByZXNlbnRzIGEgTklGVEktMiBoZWFkZXIuXG4gKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBkYXRhXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xubmlmdGkuaXNOSUZUSTIgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHZhciBidWYsIG1hZzEsIG1hZzIsIG1hZzM7XG5cbiAgICBidWYgPSBuZXcgRGF0YVZpZXcoZGF0YSk7XG4gICAgbWFnMSA9IGJ1Zi5nZXRVaW50OChuaWZ0aS5OSUZUSTIuTUFHSUNfTlVNQkVSX0xPQ0FUSU9OKTtcbiAgICBtYWcyID0gYnVmLmdldFVpbnQ4KG5pZnRpLk5JRlRJMi5NQUdJQ19OVU1CRVJfTE9DQVRJT04gKyAxKTtcbiAgICBtYWczID0gYnVmLmdldFVpbnQ4KG5pZnRpLk5JRlRJMi5NQUdJQ19OVU1CRVJfTE9DQVRJT04gKyAyKTtcblxuICAgIHJldHVybiAhISgobWFnMSA9PT0gbmlmdGkuTklGVEkyLk1BR0lDX05VTUJFUlswXSkgJiYgKG1hZzIgPT09IG5pZnRpLk5JRlRJMi5NQUdJQ19OVU1CRVJbMV0pICYmXG4gICAgKG1hZzMgPT09IG5pZnRpLk5JRlRJMi5NQUdJQ19OVU1CRVJbMl0pKTtcbn07XG5cblxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIGRhdGEgcmVwcmVzZW50cyBhIE5JRlRJIGhlYWRlci5cbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGRhdGFcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5uaWZ0aS5pc05JRlRJID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICByZXR1cm4gKG5pZnRpLmlzTklGVEkxKGRhdGEpIHx8IG5pZnRpLmlzTklGVEkyKGRhdGEpKTtcbn07XG5cblxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIGRhdGEgaXMgR1pJUCBjb21wcmVzc2VkLlxuICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gZGF0YVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbm5pZnRpLmlzQ29tcHJlc3NlZCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgdmFyIGJ1ZiwgbWFnaWNDb29raWUxLCBtYWdpY0Nvb2tpZTI7XG5cbiAgICBpZiAoZGF0YSkge1xuICAgICAgICBidWYgPSBuZXcgRGF0YVZpZXcoZGF0YSk7XG5cbiAgICAgICAgbWFnaWNDb29raWUxID0gYnVmLmdldFVpbnQ4KDApO1xuICAgICAgICBtYWdpY0Nvb2tpZTIgPSBidWYuZ2V0VWludDgoMSk7XG5cbiAgICAgICAgaWYgKG1hZ2ljQ29va2llMSA9PT0gbmlmdGkuVXRpbHMuR1VOWklQX01BR0lDX0NPT0tJRTEpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1hZ2ljQ29va2llMiA9PT0gbmlmdGkuVXRpbHMuR1VOWklQX01BR0lDX0NPT0tJRTIpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuXG5cbi8qKlxuICogUmV0dXJucyBkZWNvbXByZXNzZWQgZGF0YS5cbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGRhdGFcbiAqIEByZXR1cm5zIHtBcnJheUJ1ZmZlcn1cbiAqL1xubmlmdGkuZGVjb21wcmVzcyA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgcmV0dXJuIHBha28uaW5mbGF0ZShkYXRhKS5idWZmZXI7XG59O1xuXG5cblxuLyoqXG4gKiBSZWFkcyBhbmQgcmV0dXJucyB0aGUgaGVhZGVyIG9iamVjdC5cbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGRhdGFcbiAqIEByZXR1cm5zIHtuaWZ0aS5OSUZUSTF8bmlmdGkuTklGVEkyfG51bGx9XG4gKi9cbm5pZnRpLnJlYWRIZWFkZXIgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHZhciBoZWFkZXIgPSBudWxsO1xuXG4gICAgaWYgKG5pZnRpLmlzQ29tcHJlc3NlZChkYXRhKSkge1xuICAgICAgICBkYXRhID0gbmlmdGkuZGVjb21wcmVzcyhkYXRhKTtcbiAgICB9XG5cbiAgICBpZiAobmlmdGkuaXNOSUZUSTEoZGF0YSkpIHtcbiAgICAgICAgaGVhZGVyID0gbmV3IG5pZnRpLk5JRlRJMSgpO1xuICAgIH0gZWxzZSBpZiAobmlmdGkuaXNOSUZUSTIoZGF0YSkpIHtcbiAgICAgICAgaGVhZGVyID0gbmV3IG5pZnRpLk5JRlRJMigpO1xuICAgIH1cblxuICAgIGlmIChoZWFkZXIpIHtcbiAgICAgICAgaGVhZGVyLnJlYWRIZWFkZXIoZGF0YSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIlRoYXQgZmlsZSBkb2VzIG5vdCBhcHBlYXIgdG8gYmUgTklGVEkhXCIpO1xuICAgIH1cblxuICAgIHJldHVybiBoZWFkZXI7XG59O1xuXG5cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBoZWFkZXIgY29udGFpbnMgYW4gZXh0ZW5zaW9uLlxuICogQHBhcmFtIHtuaWZ0aS5OSUZUSTF8bmlmdGkuTklGVEkyfSBoZWFkZXJcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5uaWZ0aS5oYXNFeHRlbnNpb24gPSBmdW5jdGlvbiAoaGVhZGVyKSB7XG4gICAgcmV0dXJuIChoZWFkZXIuZXh0ZW5zaW9uRmxhZ1swXSAhPSAwKTtcbn07XG5cblxuXG4vKipcbiAqIFJldHVybnMgdGhlIGltYWdlIGRhdGEuXG4gKiBAcGFyYW0ge25pZnRpLk5JRlRJMXxuaWZ0aS5OSUZUSTJ9IGhlYWRlclxuICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gZGF0YVxuICogQHJldHVybnMge0FycmF5QnVmZmVyfVxuICovXG5uaWZ0aS5yZWFkSW1hZ2UgPSBmdW5jdGlvbiAoaGVhZGVyLCBkYXRhKSB7XG4gICAgdmFyIGltYWdlT2Zmc2V0ID0gaGVhZGVyLnZveF9vZmZzZXQsXG4gICAgICAgIHRpbWVEaW0gPSAxLFxuICAgICAgICBzdGF0RGltID0gMTtcblxuICAgIGlmIChoZWFkZXIuZGltc1s0XSkge1xuICAgICAgICB0aW1lRGltID0gaGVhZGVyLmRpbXNbNF07XG4gICAgfVxuXG4gICAgaWYgKGhlYWRlci5kaW1zWzVdKSB7XG4gICAgICAgIHN0YXREaW0gPSBoZWFkZXIuZGltc1s1XTtcbiAgICB9XG5cbiAgICB2YXIgaW1hZ2VTaXplID0gaGVhZGVyLmRpbXNbMV0gKiBoZWFkZXIuZGltc1syXSAqIGhlYWRlci5kaW1zWzNdICogdGltZURpbSAqIHN0YXREaW0gKiAoaGVhZGVyLm51bUJpdHNQZXJWb3hlbCAvIDgpO1xuICAgIHJldHVybiBkYXRhLnNsaWNlKGltYWdlT2Zmc2V0LCBpbWFnZU9mZnNldCArIGltYWdlU2l6ZSk7XG59O1xuXG5cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBleHRlbnNpb24gZGF0YSAoaW5jbHVkaW5nIGV4dGVuc2lvbiBoZWFkZXIpLlxuICogQHBhcmFtIHtuaWZ0aS5OSUZUSTF8bmlmdGkuTklGVEkyfSBoZWFkZXJcbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGRhdGFcbiAqIEByZXR1cm5zIHtBcnJheUJ1ZmZlcn1cbiAqL1xubmlmdGkucmVhZEV4dGVuc2lvbiA9IGZ1bmN0aW9uIChoZWFkZXIsIGRhdGEpIHtcbiAgICB2YXIgbG9jID0gaGVhZGVyLmdldEV4dGVuc2lvbkxvY2F0aW9uKCksXG4gICAgICAgIHNpemUgPSBoZWFkZXIuZXh0ZW5zaW9uU2l6ZTtcblxuICAgIHJldHVybiBkYXRhLnNsaWNlKGxvYywgbG9jICsgc2l6ZSk7XG59O1xuXG5cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBleHRlbnNpb24gZGF0YS5cbiAqIEBwYXJhbSB7bmlmdGkuTklGVEkxfG5pZnRpLk5JRlRJMn0gaGVhZGVyXG4gKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBkYXRhXG4gKiBAcmV0dXJucyB7QXJyYXlCdWZmZXJ9XG4gKi9cbm5pZnRpLnJlYWRFeHRlbnNpb25EYXRhID0gZnVuY3Rpb24gKGhlYWRlciwgZGF0YSkge1xuICAgIHZhciBsb2MgPSBoZWFkZXIuZ2V0RXh0ZW5zaW9uTG9jYXRpb24oKSxcbiAgICAgICAgc2l6ZSA9IGhlYWRlci5leHRlbnNpb25TaXplO1xuXG4gICAgcmV0dXJuIGRhdGEuc2xpY2UobG9jICsgOCwgbG9jICsgc2l6ZSAtIDgpO1xufTtcblxuXG4vKioqIEV4cG9ydHMgKioqL1xuXG52YXIgbW9kdWxlVHlwZSA9IHR5cGVvZiBtb2R1bGU7XG5pZiAoKG1vZHVsZVR5cGUgIT09ICd1bmRlZmluZWQnKSAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gbmlmdGk7XG59XG4iLCJcbi8qanNsaW50IGJyb3dzZXI6IHRydWUsIG5vZGU6IHRydWUgKi9cbi8qZ2xvYmFsICovXG5cblwidXNlIHN0cmljdFwiO1xuXG4vKioqIEltcG9ydHMgKioqL1xuXG52YXIgbmlmdGkgPSBuaWZ0aSB8fCB7fTtcbm5pZnRpLlV0aWxzID0gbmlmdGkuVXRpbHMgfHwgKCh0eXBlb2YgcmVxdWlyZSAhPT0gJ3VuZGVmaW5lZCcpID8gcmVxdWlyZSgnLi91dGlsaXRpZXMuanMnKSA6IG51bGwpO1xuXG5cblxuLyoqKiBDb25zdHJ1Y3RvciAqKiovXG5cbi8qKlxuICogVGhlIE5JRlRJMSBjb25zdHJ1Y3Rvci5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHByb3BlcnR5IHtib29sZWFufSBsaXR0bGVFbmRpYW5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBkaW1faW5mb1xuICogQHByb3BlcnR5IHtudW1iZXJbXX0gZGltcyAtIGltYWdlIGRpbWVuc2lvbnNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBpbnRlbnRfcDFcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBpbnRlbnRfcDJcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBpbnRlbnRfcDNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBpbnRlbnRfY29kZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IGRhdGF0eXBlQ29kZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IG51bUJpdHNQZXJWb3hlbFxuICogQHByb3BlcnR5IHtudW1iZXJ9IHNsaWNlX3N0YXJ0XG4gKiBAcHJvcGVydHkge251bWJlcn0gc2xpY2VfZW5kXG4gKiBAcHJvcGVydHkge251bWJlcn0gc2xpY2VfY29kZVxuICogQHByb3BlcnR5IHtudW1iZXJbXX0gcGl4RGltcyAtIHZveGVsIGRpbWVuc2lvbnNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB2b3hfb2Zmc2V0XG4gKiBAcHJvcGVydHkge251bWJlcn0gc2NsX3Nsb3BlXG4gKiBAcHJvcGVydHkge251bWJlcn0gc2NsX2ludGVyXG4gKiBAcHJvcGVydHkge251bWJlcn0geHl6dF91bml0c1xuICogQHByb3BlcnR5IHtudW1iZXJ9IGNhbF9tYXhcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBjYWxfbWluXG4gKiBAcHJvcGVydHkge251bWJlcn0gc2xpY2VfZHVyYXRpb25cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB0b2Zmc2V0XG4gKiBAcHJvcGVydHkge3N0cmluZ30gZGVzY3JpcHRpb25cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBhdXhfZmlsZVxuICogQHByb3BlcnR5IHtzdHJpbmd9IGludGVudF9uYW1lXG4gKiBAcHJvcGVydHkge251bWJlcn0gcWZvcm1fY29kZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IHNmb3JtX2NvZGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBxdWF0ZXJuX2JcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBxdWF0ZXJuX2NcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBxdWF0ZXJuX2RcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBxdWF0ZXJuX3hcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBxdWF0ZXJuX3lcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBxdWF0ZXJuX3pcbiAqIEBwcm9wZXJ0eSB7QXJyYXkuPEFycmF5LjxudW1iZXI+Pn0gYWZmaW5lXG4gKiBAcHJvcGVydHkge3N0cmluZ30gbWFnaWNcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gaXNIRFIgLSBpZiBoZHIvaW1nIGZvcm1hdFxuICogQHByb3BlcnR5IHtudW1iZXJbXX0gZXh0ZW5zaW9uRmxhZ1xuICogQHByb3BlcnR5IHtudW1iZXJ9IGV4dGVuc2lvblNpemVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBleHRlbnNpb25Db2RlXG4gKiBAdHlwZSB7RnVuY3Rpb259XG4gKi9cbm5pZnRpLk5JRlRJMSA9IG5pZnRpLk5JRlRJMSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5saXR0bGVFbmRpYW4gPSBmYWxzZTtcbiAgICB0aGlzLmRpbV9pbmZvID0gMDtcbiAgICB0aGlzLmRpbXMgPSBbXTtcbiAgICB0aGlzLmludGVudF9wMSA9IDA7XG4gICAgdGhpcy5pbnRlbnRfcDIgPSAwO1xuICAgIHRoaXMuaW50ZW50X3AzID0gMDtcbiAgICB0aGlzLmludGVudF9jb2RlID0gMDtcbiAgICB0aGlzLmRhdGF0eXBlQ29kZSA9IDA7XG4gICAgdGhpcy5udW1CaXRzUGVyVm94ZWwgPSAwO1xuICAgIHRoaXMuc2xpY2Vfc3RhcnQgPSAwO1xuICAgIHRoaXMuc2xpY2VfZW5kID0gMDtcbiAgICB0aGlzLnNsaWNlX2NvZGUgPSAwO1xuICAgIHRoaXMucGl4RGltcyA9IFtdO1xuICAgIHRoaXMudm94X29mZnNldCA9IDA7XG4gICAgdGhpcy5zY2xfc2xvcGUgPSAxO1xuICAgIHRoaXMuc2NsX2ludGVyID0gMDtcbiAgICB0aGlzLnh5enRfdW5pdHMgPSAwO1xuICAgIHRoaXMuY2FsX21heCA9IDA7XG4gICAgdGhpcy5jYWxfbWluID0gMDtcbiAgICB0aGlzLnNsaWNlX2R1cmF0aW9uID0gMDtcbiAgICB0aGlzLnRvZmZzZXQgPSAwO1xuICAgIHRoaXMuZGVzY3JpcHRpb24gPSBcIlwiO1xuICAgIHRoaXMuYXV4X2ZpbGUgPSBcIlwiO1xuICAgIHRoaXMuaW50ZW50X25hbWUgPSBcIlwiO1xuICAgIHRoaXMucWZvcm1fY29kZSA9IDA7XG4gICAgdGhpcy5zZm9ybV9jb2RlID0gMDtcbiAgICB0aGlzLnF1YXRlcm5fYiA9IDA7XG4gICAgdGhpcy5xdWF0ZXJuX2MgPSAwO1xuICAgIHRoaXMucXVhdGVybl9kID0gMDtcbiAgICB0aGlzLnFvZmZzZXRfeCA9IDA7XG4gICAgdGhpcy5xb2Zmc2V0X3kgPSAwO1xuICAgIHRoaXMucW9mZnNldF96ID0gMDtcbiAgICB0aGlzLmFmZmluZSA9IFtbMSwgMCwgMCwgMF0sIFswLCAxLCAwLCAwXSwgWzAsIDAsIDEsIDBdLCBbMCwgMCwgMCwgMV1dO1xuICAgIHRoaXMubWFnaWMgPSAwO1xuICAgIHRoaXMuaXNIRFIgPSBmYWxzZTtcbiAgICB0aGlzLmV4dGVuc2lvbkZsYWcgPSBbMCwgMCwgMCwgMF07XG4gICAgdGhpcy5leHRlbnNpb25TaXplID0gMDtcbiAgICB0aGlzLmV4dGVuc2lvbkNvZGUgPSAwO1xufTtcblxuXG5cbi8qKiogU3RhdGljIFBzZXVkby1jb25zdGFudHMgKioqL1xuXG4vLyBkYXRhdHlwZSBjb2Rlc1xubmlmdGkuTklGVEkxLlRZUEVfTk9ORSAgICAgICAgICAgID0gMDtcbm5pZnRpLk5JRlRJMS5UWVBFX0JJTkFSWSAgICAgICAgICA9IDE7XG5uaWZ0aS5OSUZUSTEuVFlQRV9VSU5UOCAgICAgICAgICAgPSAyO1xubmlmdGkuTklGVEkxLlRZUEVfSU5UMTYgICAgICAgICAgID0gNDtcbm5pZnRpLk5JRlRJMS5UWVBFX0lOVDMyICAgICAgICAgICA9IDg7XG5uaWZ0aS5OSUZUSTEuVFlQRV9GTE9BVDMyICAgICAgICA9IDE2O1xubmlmdGkuTklGVEkxLlRZUEVfQ09NUExFWDY0ICAgICAgPSAzMjtcbm5pZnRpLk5JRlRJMS5UWVBFX0ZMT0FUNjQgICAgICAgID0gNjQ7XG5uaWZ0aS5OSUZUSTEuVFlQRV9SR0IyNCAgICAgICAgID0gMTI4O1xubmlmdGkuTklGVEkxLlRZUEVfSU5UOCAgICAgICAgICA9IDI1Njtcbm5pZnRpLk5JRlRJMS5UWVBFX1VJTlQxNiAgICAgICAgPSA1MTI7XG5uaWZ0aS5OSUZUSTEuVFlQRV9VSU5UMzIgICAgICAgID0gNzY4O1xubmlmdGkuTklGVEkxLlRZUEVfSU5UNjQgICAgICAgID0gMTAyNDtcbm5pZnRpLk5JRlRJMS5UWVBFX1VJTlQ2NCAgICAgICA9IDEyODA7XG5uaWZ0aS5OSUZUSTEuVFlQRV9GTE9BVDEyOCAgICAgPSAxNTM2O1xubmlmdGkuTklGVEkxLlRZUEVfQ09NUExFWDEyOCAgID0gMTc5Mjtcbm5pZnRpLk5JRlRJMS5UWVBFX0NPTVBMRVgyNTYgICA9IDIwNDg7XG5cbi8vIHRyYW5zZm9ybSBjb2Rlc1xubmlmdGkuTklGVEkxLlhGT1JNX1VOS05PV04gICAgICAgID0gMDtcbm5pZnRpLk5JRlRJMS5YRk9STV9TQ0FOTkVSX0FOQVQgICA9IDE7XG5uaWZ0aS5OSUZUSTEuWEZPUk1fQUxJR05FRF9BTkFUICAgPSAyO1xubmlmdGkuTklGVEkxLlhGT1JNX1RBTEFJUkFDSCAgICAgID0gMztcbm5pZnRpLk5JRlRJMS5YRk9STV9NTklfMTUyICAgICAgICA9IDQ7XG5cbi8vIHVuaXQgY29kZXNcbm5pZnRpLk5JRlRJMS5TUEFUSUFMX1VOSVRTX01BU0sgPSAweDA3O1xubmlmdGkuTklGVEkxLlRFTVBPUkFMX1VOSVRTX01BU0sgPSAweDM4O1xubmlmdGkuTklGVEkxLlVOSVRTX1VOS05PV04gICAgICAgID0gMDtcbm5pZnRpLk5JRlRJMS5VTklUU19NRVRFUiAgICAgICAgICA9IDE7XG5uaWZ0aS5OSUZUSTEuVU5JVFNfTU0gICAgICAgICAgICAgPSAyO1xubmlmdGkuTklGVEkxLlVOSVRTX01JQ1JPTiAgICAgICAgID0gMztcbm5pZnRpLk5JRlRJMS5VTklUU19TRUMgICAgICAgICAgICA9IDg7XG5uaWZ0aS5OSUZUSTEuVU5JVFNfTVNFQyAgICAgICAgICA9IDE2O1xubmlmdGkuTklGVEkxLlVOSVRTX1VTRUMgICAgICAgICAgPSAyNDtcbm5pZnRpLk5JRlRJMS5VTklUU19IWiAgICAgICAgICAgID0gMzI7XG5uaWZ0aS5OSUZUSTEuVU5JVFNfUFBNICAgICAgICAgICA9IDQwO1xubmlmdGkuTklGVEkxLlVOSVRTX1JBRFMgICAgICAgICAgPSA0ODtcblxuLy8gbmlmdGkxIGNvZGVzXG5uaWZ0aS5OSUZUSTEuTUFHSUNfQ09PS0lFID0gMzQ4O1xubmlmdGkuTklGVEkxLk1BR0lDX05VTUJFUl9MT0NBVElPTiA9IDM0NDtcbm5pZnRpLk5JRlRJMS5NQUdJQ19OVU1CRVIgPSBbMHg2RSwgMHgyQiwgMHgzMV07ICAvLyBuKzEgKC5uaWkpXG5uaWZ0aS5OSUZUSTEuTUFHSUNfTlVNQkVSMiA9IFsweDZFLCAweDY5LCAweDMxXTsgIC8vIG5pMSAoLmhkci8uaW1nKVxubmlmdGkuTklGVEkxLkVYVEVOU0lPTl9IRUFERVJfU0laRSA9IDg7XG5cblxuLyoqKiBQcm90b3R5cGUgTWV0aG9kcyAqKiovXG5cbi8qKlxuICogUmVhZHMgdGhlIGhlYWRlciBkYXRhLlxuICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gZGF0YVxuICovXG5uaWZ0aS5OSUZUSTEucHJvdG90eXBlLnJlYWRIZWFkZXIgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHZhciByYXdEYXRhID0gbmV3IERhdGFWaWV3KGRhdGEpLFxuICAgICAgICBtYWdpY0Nvb2tpZVZhbCA9IG5pZnRpLlV0aWxzLmdldEludEF0KHJhd0RhdGEsIDAsIHRoaXMubGl0dGxlRW5kaWFuKSxcbiAgICAgICAgY3RyLFxuICAgICAgICBjdHJPdXQsXG4gICAgICAgIGN0ckluLFxuICAgICAgICBpbmRleDtcblxuICAgIGlmIChtYWdpY0Nvb2tpZVZhbCAhPT0gbmlmdGkuTklGVEkxLk1BR0lDX0NPT0tJRSkgeyAgLy8gdHJ5IGFzIGxpdHRsZSBlbmRpYW5cbiAgICAgICAgdGhpcy5saXR0bGVFbmRpYW4gPSB0cnVlO1xuICAgICAgICBtYWdpY0Nvb2tpZVZhbCA9IG5pZnRpLlV0aWxzLmdldEludEF0KHJhd0RhdGEsIDAsIHRoaXMubGl0dGxlRW5kaWFuKTtcbiAgICB9XG5cbiAgICBpZiAobWFnaWNDb29raWVWYWwgIT09IG5pZnRpLk5JRlRJMS5NQUdJQ19DT09LSUUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhpcyBkb2VzIG5vdCBhcHBlYXIgdG8gYmUgYSBOSUZUSSBmaWxlIVwiKTtcbiAgICB9XG5cbiAgICB0aGlzLmRpbV9pbmZvID0gbmlmdGkuVXRpbHMuZ2V0Qnl0ZUF0KHJhd0RhdGEsIDM5KTtcblxuICAgIGZvciAoY3RyID0gMDsgY3RyIDwgODsgY3RyICs9IDEpIHtcbiAgICAgICAgaW5kZXggPSA0MCArIChjdHIgKiAyKTtcbiAgICAgICAgdGhpcy5kaW1zW2N0cl0gPSBuaWZ0aS5VdGlscy5nZXRTaG9ydEF0KHJhd0RhdGEsIGluZGV4LCB0aGlzLmxpdHRsZUVuZGlhbik7XG4gICAgfVxuXG4gICAgdGhpcy5pbnRlbnRfcDEgPSBuaWZ0aS5VdGlscy5nZXRGbG9hdEF0KHJhd0RhdGEsIDU2LCB0aGlzLmxpdHRsZUVuZGlhbik7XG4gICAgdGhpcy5pbnRlbnRfcDIgPSBuaWZ0aS5VdGlscy5nZXRGbG9hdEF0KHJhd0RhdGEsIDYwLCB0aGlzLmxpdHRsZUVuZGlhbik7XG4gICAgdGhpcy5pbnRlbnRfcDMgPSBuaWZ0aS5VdGlscy5nZXRGbG9hdEF0KHJhd0RhdGEsIDY0LCB0aGlzLmxpdHRsZUVuZGlhbik7XG4gICAgdGhpcy5pbnRlbnRfY29kZSA9IG5pZnRpLlV0aWxzLmdldFNob3J0QXQocmF3RGF0YSwgNjgsIHRoaXMubGl0dGxlRW5kaWFuKTtcblxuICAgIHRoaXMuZGF0YXR5cGVDb2RlID0gbmlmdGkuVXRpbHMuZ2V0U2hvcnRBdChyYXdEYXRhLCA3MCwgdGhpcy5saXR0bGVFbmRpYW4pO1xuICAgIHRoaXMubnVtQml0c1BlclZveGVsID0gbmlmdGkuVXRpbHMuZ2V0U2hvcnRBdChyYXdEYXRhLCA3MiwgdGhpcy5saXR0bGVFbmRpYW4pO1xuXG4gICAgdGhpcy5zbGljZV9zdGFydCA9IG5pZnRpLlV0aWxzLmdldFNob3J0QXQocmF3RGF0YSwgNzQsIHRoaXMubGl0dGxlRW5kaWFuKTtcblxuICAgIGZvciAoY3RyID0gMDsgY3RyIDwgODsgY3RyICs9IDEpIHtcbiAgICAgICAgaW5kZXggPSA3NiArIChjdHIgKiA0KTtcbiAgICAgICAgdGhpcy5waXhEaW1zW2N0cl0gPSBuaWZ0aS5VdGlscy5nZXRGbG9hdEF0KHJhd0RhdGEsIGluZGV4LCB0aGlzLmxpdHRsZUVuZGlhbik7XG4gICAgfVxuXG4gICAgdGhpcy52b3hfb2Zmc2V0ID0gbmlmdGkuVXRpbHMuZ2V0RmxvYXRBdChyYXdEYXRhLCAxMDgsIHRoaXMubGl0dGxlRW5kaWFuKTtcblxuICAgIHRoaXMuc2NsX3Nsb3BlID0gbmlmdGkuVXRpbHMuZ2V0RmxvYXRBdChyYXdEYXRhLCAxMTIsIHRoaXMubGl0dGxlRW5kaWFuKTtcbiAgICB0aGlzLnNjbF9pbnRlciA9IG5pZnRpLlV0aWxzLmdldEZsb2F0QXQocmF3RGF0YSwgMTE2LCB0aGlzLmxpdHRsZUVuZGlhbik7XG5cbiAgICB0aGlzLnNsaWNlX2VuZCA9IG5pZnRpLlV0aWxzLmdldFNob3J0QXQocmF3RGF0YSwgMTIwLCB0aGlzLmxpdHRsZUVuZGlhbik7XG4gICAgdGhpcy5zbGljZV9jb2RlID0gbmlmdGkuVXRpbHMuZ2V0Qnl0ZUF0KHJhd0RhdGEsIDEyMik7XG5cbiAgICB0aGlzLnh5enRfdW5pdHMgPSBuaWZ0aS5VdGlscy5nZXRCeXRlQXQocmF3RGF0YSwgMTIzKTtcblxuICAgIHRoaXMuY2FsX21heCA9IG5pZnRpLlV0aWxzLmdldEZsb2F0QXQocmF3RGF0YSwgMTI0LCB0aGlzLmxpdHRsZUVuZGlhbik7XG4gICAgdGhpcy5jYWxfbWluID0gbmlmdGkuVXRpbHMuZ2V0RmxvYXRBdChyYXdEYXRhLCAxMjgsIHRoaXMubGl0dGxlRW5kaWFuKTtcblxuICAgIHRoaXMuc2xpY2VfZHVyYXRpb24gPSBuaWZ0aS5VdGlscy5nZXRGbG9hdEF0KHJhd0RhdGEsIDEzMiwgdGhpcy5saXR0bGVFbmRpYW4pO1xuICAgIHRoaXMudG9mZnNldCA9IG5pZnRpLlV0aWxzLmdldEZsb2F0QXQocmF3RGF0YSwgMTM2LCB0aGlzLmxpdHRsZUVuZGlhbik7XG5cbiAgICB0aGlzLmRlc2NyaXB0aW9uID0gbmlmdGkuVXRpbHMuZ2V0U3RyaW5nQXQocmF3RGF0YSwgMTQ4LCAyMjgpO1xuICAgIHRoaXMuYXV4X2ZpbGUgPSBuaWZ0aS5VdGlscy5nZXRTdHJpbmdBdChyYXdEYXRhLCAyMjgsIDI1Mik7XG5cbiAgICB0aGlzLnFmb3JtX2NvZGUgPSBuaWZ0aS5VdGlscy5nZXRTaG9ydEF0KHJhd0RhdGEsIDI1MiwgdGhpcy5saXR0bGVFbmRpYW4pO1xuICAgIHRoaXMuc2Zvcm1fY29kZSA9IG5pZnRpLlV0aWxzLmdldFNob3J0QXQocmF3RGF0YSwgMjU0LCB0aGlzLmxpdHRsZUVuZGlhbik7XG5cbiAgICB0aGlzLnF1YXRlcm5fYiA9IG5pZnRpLlV0aWxzLmdldEZsb2F0QXQocmF3RGF0YSwgMjU2LCB0aGlzLmxpdHRsZUVuZGlhbik7XG4gICAgdGhpcy5xdWF0ZXJuX2MgPSBuaWZ0aS5VdGlscy5nZXRGbG9hdEF0KHJhd0RhdGEsIDI2MCwgdGhpcy5saXR0bGVFbmRpYW4pO1xuICAgIHRoaXMucXVhdGVybl9kID0gbmlmdGkuVXRpbHMuZ2V0RmxvYXRBdChyYXdEYXRhLCAyNjQsIHRoaXMubGl0dGxlRW5kaWFuKTtcbiAgICB0aGlzLnFvZmZzZXRfeCA9IG5pZnRpLlV0aWxzLmdldEZsb2F0QXQocmF3RGF0YSwgMjY4LCB0aGlzLmxpdHRsZUVuZGlhbik7XG4gICAgdGhpcy5xb2Zmc2V0X3kgPSBuaWZ0aS5VdGlscy5nZXRGbG9hdEF0KHJhd0RhdGEsIDI3MiwgdGhpcy5saXR0bGVFbmRpYW4pO1xuICAgIHRoaXMucW9mZnNldF96ID0gbmlmdGkuVXRpbHMuZ2V0RmxvYXRBdChyYXdEYXRhLCAyNzYsIHRoaXMubGl0dGxlRW5kaWFuKTtcblxuICAgIGZvciAoY3RyT3V0ID0gMDsgY3RyT3V0IDwgMzsgY3RyT3V0ICs9IDEpIHtcbiAgICAgICAgZm9yIChjdHJJbiA9IDA7IGN0ckluIDwgNDsgY3RySW4gKz0gMSkge1xuICAgICAgICAgICAgaW5kZXggPSAyODAgKyAoKChjdHJPdXQgKiA0KSArIGN0ckluKSAqIDQpO1xuICAgICAgICAgICAgdGhpcy5hZmZpbmVbY3RyT3V0XVtjdHJJbl0gPSBuaWZ0aS5VdGlscy5nZXRGbG9hdEF0KHJhd0RhdGEsIGluZGV4LCB0aGlzLmxpdHRsZUVuZGlhbik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmFmZmluZVszXVswXSA9IDA7XG4gICAgdGhpcy5hZmZpbmVbM11bMV0gPSAwO1xuICAgIHRoaXMuYWZmaW5lWzNdWzJdID0gMDtcbiAgICB0aGlzLmFmZmluZVszXVszXSA9IDE7XG5cbiAgICB0aGlzLmludGVudF9uYW1lID0gbmlmdGkuVXRpbHMuZ2V0U3RyaW5nQXQocmF3RGF0YSwgMzI4LCAzNDQpO1xuICAgIHRoaXMubWFnaWMgPSBuaWZ0aS5VdGlscy5nZXRTdHJpbmdBdChyYXdEYXRhLCAzNDQsIDM0OCk7XG5cbiAgICB0aGlzLmlzSERSID0gKHRoaXMubWFnaWMgPT09IG5pZnRpLk5JRlRJMS5NQUdJQ19OVU1CRVIyKTtcblxuICAgIGlmIChyYXdEYXRhLmJ5dGVMZW5ndGggPiBuaWZ0aS5OSUZUSTEuTUFHSUNfQ09PS0lFKSB7XG4gICAgICAgIHRoaXMuZXh0ZW5zaW9uRmxhZ1swXSA9IG5pZnRpLlV0aWxzLmdldEJ5dGVBdChyYXdEYXRhLCAzNDgpO1xuICAgICAgICB0aGlzLmV4dGVuc2lvbkZsYWdbMV0gPSBuaWZ0aS5VdGlscy5nZXRCeXRlQXQocmF3RGF0YSwgMzQ4ICsgMSk7XG4gICAgICAgIHRoaXMuZXh0ZW5zaW9uRmxhZ1syXSA9IG5pZnRpLlV0aWxzLmdldEJ5dGVBdChyYXdEYXRhLCAzNDggKyAyKTtcbiAgICAgICAgdGhpcy5leHRlbnNpb25GbGFnWzNdID0gbmlmdGkuVXRpbHMuZ2V0Qnl0ZUF0KHJhd0RhdGEsIDM0OCArIDMpO1xuXG4gICAgICAgIGlmICh0aGlzLmV4dGVuc2lvbkZsYWdbMF0pIHtcbiAgICAgICAgICAgIHRoaXMuZXh0ZW5zaW9uU2l6ZSA9IHRoaXMuZ2V0RXh0ZW5zaW9uU2l6ZShyYXdEYXRhKTtcbiAgICAgICAgICAgIHRoaXMuZXh0ZW5zaW9uQ29kZSA9IHRoaXMuZ2V0RXh0ZW5zaW9uQ29kZShyYXdEYXRhKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cblxuLyoqXG4gKiBSZXR1cm5zIGEgZm9ybWF0dGVkIHN0cmluZyBvZiBoZWFkZXIgZmllbGRzLlxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xubmlmdGkuTklGVEkxLnByb3RvdHlwZS50b0Zvcm1hdHRlZFN0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZm10ID0gbmlmdGkuVXRpbHMuZm9ybWF0TnVtYmVyLFxuICAgICAgICBzdHJpbmcgPSBcIlwiO1xuXG4gICAgc3RyaW5nICs9IChcIkRpbSBJbmZvID0gXCIgKyB0aGlzLmRpbV9pbmZvICsgXCJcXG5cIik7XG5cbiAgICBzdHJpbmcgKz0gKFwiSW1hZ2UgRGltZW5zaW9ucyAoMS04KTogXCIgK1xuICAgICAgICB0aGlzLmRpbXNbMF0gKyBcIiwgXCIgK1xuICAgICAgICB0aGlzLmRpbXNbMV0gKyBcIiwgXCIgK1xuICAgICAgICB0aGlzLmRpbXNbMl0gKyBcIiwgXCIgK1xuICAgICAgICB0aGlzLmRpbXNbM10gKyBcIiwgXCIgK1xuICAgICAgICB0aGlzLmRpbXNbNF0gKyBcIiwgXCIgK1xuICAgICAgICB0aGlzLmRpbXNbNV0gKyBcIiwgXCIgK1xuICAgICAgICB0aGlzLmRpbXNbNl0gKyBcIiwgXCIgK1xuICAgICAgICB0aGlzLmRpbXNbN10gKyBcIlxcblwiKTtcblxuICAgIHN0cmluZyArPSAoXCJJbnRlbnQgUGFyYW1ldGVycyAoMS0zKTogXCIgK1xuICAgICAgICB0aGlzLmludGVudF9wMSArIFwiLCBcIiArXG4gICAgICAgIHRoaXMuaW50ZW50X3AyICsgXCIsIFwiICtcbiAgICAgICAgdGhpcy5pbnRlbnRfcDMpICsgXCJcXG5cIjtcblxuICAgIHN0cmluZyArPSAoXCJJbnRlbnQgQ29kZSA9IFwiICsgdGhpcy5pbnRlbnRfY29kZSArIFwiXFxuXCIpO1xuICAgIHN0cmluZyArPSAoXCJEYXRhdHlwZSA9IFwiICsgdGhpcy5kYXRhdHlwZUNvZGUgKyAgXCIgKFwiICsgdGhpcy5nZXREYXRhdHlwZUNvZGVTdHJpbmcodGhpcy5kYXRhdHlwZUNvZGUpICsgXCIpXFxuXCIpO1xuICAgIHN0cmluZyArPSAoXCJCaXRzIFBlciBWb3hlbCA9IFwiICsgdGhpcy5udW1CaXRzUGVyVm94ZWwgKyBcIlxcblwiKTtcbiAgICBzdHJpbmcgKz0gKFwiU2xpY2UgU3RhcnQgPSBcIiArIHRoaXMuc2xpY2Vfc3RhcnQgKyBcIlxcblwiKTtcbiAgICBzdHJpbmcgKz0gKFwiVm94ZWwgRGltZW5zaW9ucyAoMS04KTogXCIgK1xuICAgICAgICBmbXQodGhpcy5waXhEaW1zWzBdKSArIFwiLCBcIiArXG4gICAgICAgIGZtdCh0aGlzLnBpeERpbXNbMV0pICsgXCIsIFwiICtcbiAgICAgICAgZm10KHRoaXMucGl4RGltc1syXSkgKyBcIiwgXCIgK1xuICAgICAgICBmbXQodGhpcy5waXhEaW1zWzNdKSArIFwiLCBcIiArXG4gICAgICAgIGZtdCh0aGlzLnBpeERpbXNbNF0pICsgXCIsIFwiICtcbiAgICAgICAgZm10KHRoaXMucGl4RGltc1s1XSkgKyBcIiwgXCIgK1xuICAgICAgICBmbXQodGhpcy5waXhEaW1zWzZdKSArIFwiLCBcIiArXG4gICAgICAgIGZtdCh0aGlzLnBpeERpbXNbN10pICsgXCJcXG5cIik7XG5cbiAgICBzdHJpbmcgKz0gKFwiSW1hZ2UgT2Zmc2V0ID0gXCIgKyB0aGlzLnZveF9vZmZzZXQgKyBcIlxcblwiKTtcbiAgICBzdHJpbmcgKz0gKFwiRGF0YSBTY2FsZTogIFNsb3BlID0gXCIgKyBmbXQodGhpcy5zY2xfc2xvcGUpICsgXCIgIEludGVyY2VwdCA9IFwiICsgZm10KHRoaXMuc2NsX2ludGVyKSArIFwiXFxuXCIpO1xuICAgIHN0cmluZyArPSAoXCJTbGljZSBFbmQgPSBcIiArIHRoaXMuc2xpY2VfZW5kICsgXCJcXG5cIik7XG4gICAgc3RyaW5nICs9IChcIlNsaWNlIENvZGUgPSBcIiArIHRoaXMuc2xpY2VfY29kZSArIFwiXFxuXCIpO1xuICAgIHN0cmluZyArPSAoXCJVbml0cyBDb2RlID0gXCIgKyB0aGlzLnh5enRfdW5pdHMgKyBcIiAoXCIgKyB0aGlzLmdldFVuaXRzQ29kZVN0cmluZyhuaWZ0aS5OSUZUSTEuU1BBVElBTF9VTklUU19NQVNLICYgdGhpcy54eXp0X3VuaXRzKSArIFwiLCBcIiArIHRoaXMuZ2V0VW5pdHNDb2RlU3RyaW5nKG5pZnRpLk5JRlRJMS5URU1QT1JBTF9VTklUU19NQVNLICYgdGhpcy54eXp0X3VuaXRzKSArIFwiKVxcblwiKTtcbiAgICBzdHJpbmcgKz0gKFwiRGlzcGxheSBSYW5nZTogIE1heCA9IFwiICsgZm10KHRoaXMuY2FsX21heCkgKyBcIiAgTWluID0gXCIgKyBmbXQodGhpcy5jYWxfbWluKSArIFwiXFxuXCIpO1xuICAgIHN0cmluZyArPSAoXCJTbGljZSBEdXJhdGlvbiA9IFwiICsgdGhpcy5zbGljZV9kdXJhdGlvbiArIFwiXFxuXCIpO1xuICAgIHN0cmluZyArPSAoXCJUaW1lIEF4aXMgU2hpZnQgPSBcIiArIHRoaXMudG9mZnNldCArIFwiXFxuXCIpO1xuICAgIHN0cmluZyArPSAoXCJEZXNjcmlwdGlvbjogXFxcIlwiICsgdGhpcy5kZXNjcmlwdGlvbiArIFwiXFxcIlxcblwiKTtcbiAgICBzdHJpbmcgKz0gKFwiQXV4aWxpYXJ5IEZpbGU6IFxcXCJcIiArIHRoaXMuYXV4X2ZpbGUgKyBcIlxcXCJcXG5cIik7XG4gICAgc3RyaW5nICs9IChcIlEtRm9ybSBDb2RlID0gXCIgKyB0aGlzLnFmb3JtX2NvZGUgKyBcIiAoXCIgKyB0aGlzLmdldFRyYW5zZm9ybUNvZGVTdHJpbmcodGhpcy5xZm9ybV9jb2RlKSArIFwiKVxcblwiKTtcbiAgICBzdHJpbmcgKz0gKFwiUy1Gb3JtIENvZGUgPSBcIiArIHRoaXMuc2Zvcm1fY29kZSArIFwiIChcIiArIHRoaXMuZ2V0VHJhbnNmb3JtQ29kZVN0cmluZyh0aGlzLnNmb3JtX2NvZGUpICsgXCIpXFxuXCIpO1xuICAgIHN0cmluZyArPSAoXCJRdWF0ZXJuaW9uIFBhcmFtZXRlcnM6ICBcIiArXG4gICAgICAgIFwiYiA9IFwiICsgZm10KHRoaXMucXVhdGVybl9iKSArIFwiICBcIiArXG4gICAgICAgIFwiYyA9IFwiICsgZm10KHRoaXMucXVhdGVybl9jKSArIFwiICBcIiArXG4gICAgICAgIFwiZCA9IFwiICsgZm10KHRoaXMucXVhdGVybl9kKSArIFwiXFxuXCIpO1xuXG4gICAgc3RyaW5nICs9IChcIlF1YXRlcm5pb24gT2Zmc2V0czogIFwiICtcbiAgICAgICAgXCJ4ID0gXCIgKyB0aGlzLnFvZmZzZXRfeCArIFwiICBcIiArXG4gICAgICAgIFwieSA9IFwiICsgdGhpcy5xb2Zmc2V0X3kgKyBcIiAgXCIgK1xuICAgICAgICBcInogPSBcIiArIHRoaXMucW9mZnNldF96ICsgXCJcXG5cIik7XG5cbiAgICBzdHJpbmcgKz0gKFwiUy1Gb3JtIFBhcmFtZXRlcnMgWDogXCIgK1xuICAgICAgICBmbXQodGhpcy5hZmZpbmVbMF1bMF0pICsgXCIsIFwiICtcbiAgICAgICAgZm10KHRoaXMuYWZmaW5lWzBdWzFdKSArIFwiLCBcIiArXG4gICAgICAgIGZtdCh0aGlzLmFmZmluZVswXVsyXSkgKyBcIiwgXCIgK1xuICAgICAgICBmbXQodGhpcy5hZmZpbmVbMF1bM10pICsgXCJcXG5cIik7XG5cbiAgICBzdHJpbmcgKz0gKFwiUy1Gb3JtIFBhcmFtZXRlcnMgWTogXCIgK1xuICAgICAgICBmbXQodGhpcy5hZmZpbmVbMV1bMF0pICsgXCIsIFwiICtcbiAgICAgICAgZm10KHRoaXMuYWZmaW5lWzFdWzFdKSArIFwiLCBcIiArXG4gICAgICAgIGZtdCh0aGlzLmFmZmluZVsxXVsyXSkgKyBcIiwgXCIgK1xuICAgICAgICBmbXQodGhpcy5hZmZpbmVbMV1bM10pICsgXCJcXG5cIik7XG5cbiAgICBzdHJpbmcgKz0gKFwiUy1Gb3JtIFBhcmFtZXRlcnMgWjogXCIgK1xuICAgICAgICBmbXQodGhpcy5hZmZpbmVbMl1bMF0pICsgXCIsIFwiICtcbiAgICAgICAgZm10KHRoaXMuYWZmaW5lWzJdWzFdKSArIFwiLCBcIiArXG4gICAgICAgIGZtdCh0aGlzLmFmZmluZVsyXVsyXSkgKyBcIiwgXCIgK1xuICAgICAgICBmbXQodGhpcy5hZmZpbmVbMl1bM10pICsgXCJcXG5cIik7XG5cbiAgICBzdHJpbmcgKz0gKFwiSW50ZW50IE5hbWU6IFxcXCJcIiArIHRoaXMuaW50ZW50X25hbWUgKyBcIlxcXCJcXG5cIik7XG5cbiAgICBpZiAodGhpcy5leHRlbnNpb25GbGFnWzBdKSB7XG4gICAgICAgIHN0cmluZyArPSAoXCJFeHRlbnNpb246IFNpemUgPSBcIiArIHRoaXMuZXh0ZW5zaW9uU2l6ZSArIFwiICBDb2RlID0gXCIgKyB0aGlzLmV4dGVuc2lvbkNvZGUgKyBcIlxcblwiKTtcblxuICAgIH1cblxuICAgIHJldHVybiBzdHJpbmc7XG59O1xuXG5cbi8qKlxuICogUmV0dXJucyBhIGh1bWFuLXJlYWRhYmxlIHN0cmluZyBvZiBkYXRhdHlwZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBjb2RlXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5uaWZ0aS5OSUZUSTEucHJvdG90eXBlLmdldERhdGF0eXBlQ29kZVN0cmluZyA9IGZ1bmN0aW9uIChjb2RlKSB7XG4gICAgaWYgKGNvZGUgPT09IG5pZnRpLk5JRlRJMS5UWVBFX1VJTlQ4KSB7XG4gICAgICAgIHJldHVybiBcIjEtQnl0ZSBVbnNpZ25lZCBJbnRlZ2VyXCI7XG4gICAgfSBlbHNlIGlmIChjb2RlID09PSBuaWZ0aS5OSUZUSTEuVFlQRV9JTlQxNikge1xuICAgICAgICByZXR1cm4gXCIyLUJ5dGUgU2lnbmVkIEludGVnZXJcIjtcbiAgICB9IGVsc2UgaWYgKGNvZGUgPT09IG5pZnRpLk5JRlRJMS5UWVBFX0lOVDMyKSB7XG4gICAgICAgIHJldHVybiBcIjQtQnl0ZSBTaWduZWQgSW50ZWdlclwiO1xuICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gbmlmdGkuTklGVEkxLlRZUEVfRkxPQVQzMikge1xuICAgICAgICByZXR1cm4gXCI0LUJ5dGUgRmxvYXRcIjtcbiAgICB9IGVsc2UgaWYgKGNvZGUgPT09IG5pZnRpLk5JRlRJMS5UWVBFX0ZMT0FUNjQpIHtcbiAgICAgICAgcmV0dXJuIFwiOC1CeXRlIEZsb2F0XCI7XG4gICAgfSBlbHNlIGlmIChjb2RlID09PSBuaWZ0aS5OSUZUSTEuVFlQRV9SR0IyNCkge1xuICAgICAgICByZXR1cm4gXCJSR0JcIjtcbiAgICB9IGVsc2UgaWYgKGNvZGUgPT09IG5pZnRpLk5JRlRJMS5UWVBFX0lOVDgpIHtcbiAgICAgICAgcmV0dXJuIFwiMS1CeXRlIFNpZ25lZCBJbnRlZ2VyXCI7XG4gICAgfSBlbHNlIGlmIChjb2RlID09PSBuaWZ0aS5OSUZUSTEuVFlQRV9VSU5UMTYpIHtcbiAgICAgICAgcmV0dXJuIFwiMi1CeXRlIFVuc2lnbmVkIEludGVnZXJcIjtcbiAgICB9IGVsc2UgaWYgKGNvZGUgPT09IG5pZnRpLk5JRlRJMS5UWVBFX1VJTlQzMikge1xuICAgICAgICByZXR1cm4gXCI0LUJ5dGUgVW5zaWduZWQgSW50ZWdlclwiO1xuICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gbmlmdGkuTklGVEkxLlRZUEVfSU5UNjQpIHtcbiAgICAgICAgcmV0dXJuIFwiOC1CeXRlIFNpZ25lZCBJbnRlZ2VyXCI7XG4gICAgfSBlbHNlIGlmIChjb2RlID09PSBuaWZ0aS5OSUZUSTEuVFlQRV9VSU5UNjQpIHtcbiAgICAgICAgcmV0dXJuIFwiOC1CeXRlIFVuc2lnbmVkIEludGVnZXJcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gXCJVbmtub3duXCI7XG4gICAgfVxufTtcblxuXG4vKipcbiAqIFJldHVybnMgYSBodW1hbi1yZWFkYWJsZSBzdHJpbmcgb2YgdHJhbnNmb3JtIHR5cGUuXG4gKiBAcGFyYW0ge251bWJlcn0gY29kZVxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xubmlmdGkuTklGVEkxLnByb3RvdHlwZS5nZXRUcmFuc2Zvcm1Db2RlU3RyaW5nID0gZnVuY3Rpb24gKGNvZGUpIHtcbiAgICBpZiAoY29kZSA9PT0gbmlmdGkuTklGVEkxLlhGT1JNX1NDQU5ORVJfQU5BVCkge1xuICAgICAgICByZXR1cm4gXCJTY2FubmVyXCI7XG4gICAgfSBlbHNlIGlmIChjb2RlID09PSBuaWZ0aS5OSUZUSTEuWEZPUk1fQUxJR05FRF9BTkFUKSB7XG4gICAgICAgIHJldHVybiBcIkFsaWduZWRcIjtcbiAgICB9IGVsc2UgaWYgKGNvZGUgPT09IG5pZnRpLk5JRlRJMS5YRk9STV9UQUxBSVJBQ0gpIHtcbiAgICAgICAgcmV0dXJuIFwiVGFsYWlyYWNoXCI7XG4gICAgfSBlbHNlIGlmIChjb2RlID09PSBuaWZ0aS5OSUZUSTEuWEZPUk1fTU5JXzE1Mikge1xuICAgICAgICByZXR1cm4gXCJNTklcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gXCJVbmtub3duXCI7XG4gICAgfVxufTtcblxuXG4vKipcbiAqIFJldHVybnMgYSBodW1hbi1yZWFkYWJsZSBzdHJpbmcgb2Ygc3BhdGlhbCBhbmQgdGVtcG9yYWwgdW5pdHMuXG4gKiBAcGFyYW0ge251bWJlcn0gY29kZVxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xubmlmdGkuTklGVEkxLnByb3RvdHlwZS5nZXRVbml0c0NvZGVTdHJpbmcgPSBmdW5jdGlvbiAoY29kZSkge1xuICAgIGlmIChjb2RlID09PSBuaWZ0aS5OSUZUSTEuVU5JVFNfTUVURVIpIHtcbiAgICAgICAgcmV0dXJuIFwiTWV0ZXJzXCI7XG4gICAgfSBlbHNlIGlmIChjb2RlID09PSBuaWZ0aS5OSUZUSTEuVU5JVFNfTU0pIHtcbiAgICAgICAgcmV0dXJuIFwiTWlsbGltZXRlcnNcIjtcbiAgICB9IGVsc2UgaWYgKGNvZGUgPT09IG5pZnRpLk5JRlRJMS5VTklUU19NSUNST04pIHtcbiAgICAgICAgcmV0dXJuIFwiTWljcm9uc1wiO1xuICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gbmlmdGkuTklGVEkxLlVOSVRTX1NFQykge1xuICAgICAgICByZXR1cm4gXCJTZWNvbmRzXCI7XG4gICAgfSBlbHNlIGlmIChjb2RlID09PSBuaWZ0aS5OSUZUSTEuVU5JVFNfTVNFQykge1xuICAgICAgICByZXR1cm4gXCJNaWxsaXNlY29uZHNcIjtcbiAgICB9IGVsc2UgaWYgKGNvZGUgPT09IG5pZnRpLk5JRlRJMS5VTklUU19VU0VDKSB7XG4gICAgICAgIHJldHVybiBcIk1pY3Jvc2Vjb25kc1wiO1xuICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gbmlmdGkuTklGVEkxLlVOSVRTX0haKSB7XG4gICAgICAgIHJldHVybiBcIkh6XCI7XG4gICAgfSBlbHNlIGlmIChjb2RlID09PSBuaWZ0aS5OSUZUSTEuVU5JVFNfUFBNKSB7XG4gICAgICAgIHJldHVybiBcIlBQTVwiO1xuICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gbmlmdGkuTklGVEkxLlVOSVRTX1JBRFMpIHtcbiAgICAgICAgcmV0dXJuIFwiUmFkc1wiO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBcIlVua25vd25cIjtcbiAgICB9XG59O1xuXG5cbi8qKlxuICogUmV0dXJucyB0aGUgcWZvcm0gbWF0cml4LlxuICogQHJldHVybnMge0FycmF5LjxBcnJheS48bnVtYmVyPj59XG4gKi9cbm5pZnRpLk5JRlRJMS5wcm90b3R5cGUuZ2V0UWZvcm1NYXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udmVydE5pZnRpUUZvcm1Ub05pZnRpU0Zvcm0odGhpcy5xdWF0ZXJuX2IsIHRoaXMucXVhdGVybl9jLCB0aGlzLnF1YXRlcm5fZCwgdGhpcy5xb2Zmc2V0X3gsXG4gICAgICAgIHRoaXMucW9mZnNldF95LCB0aGlzLnFvZmZzZXRfeiwgdGhpcy5waXhEaW1zWzFdLCB0aGlzLnBpeERpbXNbMl0sIHRoaXMucGl4RGltc1szXSwgdGhpcy5waXhEaW1zWzBdKTtcbn07XG5cblxuXG4vKipcbiAqIENvbnZlcnRzIHFmb3JtIHRvIGFuIGFmZmluZS4gIChTZWUgaHR0cDovL25pZnRpLm5pbWgubmloLmdvdi9wdWIvZGlzdC9zcmMvbmlmdGlsaWIvbmlmdGkxX2lvLmMpXG4gKiBAcGFyYW0ge251bWJlcn0gcWJcbiAqIEBwYXJhbSB7bnVtYmVyfSBxY1xuICogQHBhcmFtIHtudW1iZXJ9IHFkXG4gKiBAcGFyYW0ge251bWJlcn0gcXhcbiAqIEBwYXJhbSB7bnVtYmVyfSBxeVxuICogQHBhcmFtIHtudW1iZXJ9IHF6XG4gKiBAcGFyYW0ge251bWJlcn0gZHhcbiAqIEBwYXJhbSB7bnVtYmVyfSBkeVxuICogQHBhcmFtIHtudW1iZXJ9IGR6XG4gKiBAcGFyYW0ge251bWJlcn0gcWZhY1xuICogQHJldHVybnMge0FycmF5LjxBcnJheS48bnVtYmVyPj59XG4gKi9cbm5pZnRpLk5JRlRJMS5wcm90b3R5cGUuY29udmVydE5pZnRpUUZvcm1Ub05pZnRpU0Zvcm0gPSBmdW5jdGlvbiAocWIsIHFjLCBxZCwgcXgsIHF5LCBxeiwgZHgsIGR5LCBkeixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHFmYWMpIHtcbiAgICB2YXIgUiA9IFtbMCwgMCwgMCwgMF0sIFswLCAwLCAwLCAwXSwgWzAsIDAsIDAsIDBdLCBbMCwgMCwgMCwgMF1dLFxuICAgICAgICBhLFxuICAgICAgICBiID0gcWIsXG4gICAgICAgIGMgPSBxYyxcbiAgICAgICAgZCA9IHFkLFxuICAgICAgICB4ZCxcbiAgICAgICAgeWQsXG4gICAgICAgIHpkO1xuXG4gICAgLy8gbGFzdCByb3cgaXMgYWx3YXlzIFsgMCAwIDAgMSBdXG4gICAgUlszXVswXSA9IFJbM11bMV0gPSBSWzNdWzJdID0gMC4wO1xuICAgIFJbM11bM10gPSAxLjA7XG5cbiAgICAvLyBjb21wdXRlIGEgcGFyYW1ldGVyIGZyb20gYixjLGRcbiAgICBhID0gMS4wIC0gKGIgKiBiICsgYyAqIGMgKyBkICogZCk7XG4gICAgaWYgKGEgPCAwLjAwMDAwMDEpIHsgICAgICAgICAgICAgICAgICAgLyogc3BlY2lhbCBjYXNlICovXG5cbiAgICAgICAgYSA9IDEuMCAvIE1hdGguc3FydChiICogYiArIGMgKiBjICsgZCAqIGQpO1xuICAgICAgICBiICo9IGE7XG4gICAgICAgIGMgKj0gYTtcbiAgICAgICAgZCAqPSBhOyAgICAgICAgLyogbm9ybWFsaXplIChiLGMsZCkgdmVjdG9yICovXG4gICAgICAgIGEgPSAwLjA7ICAgICAgICAgICAgICAgICAgICAgICAgLyogYSA9IDAgPT0+IDE4MCBkZWdyZWUgcm90YXRpb24gKi9cbiAgICB9IGVsc2Uge1xuXG4gICAgICAgIGEgPSBNYXRoLnNxcnQoYSk7ICAgICAgICAgICAgICAgICAgICAgLyogYW5nbGUgPSAyKmFyY2NvcyhhKSAqL1xuICAgIH1cblxuICAgIC8vIGxvYWQgcm90YXRpb24gbWF0cml4LCBpbmNsdWRpbmcgc2NhbGluZyBmYWN0b3JzIGZvciB2b3hlbCBzaXplc1xuICAgIHhkID0gKGR4ID4gMC4wKSA/IGR4IDogMS4wOyAgICAgICAvKiBtYWtlIHN1cmUgYXJlIHBvc2l0aXZlICovXG4gICAgeWQgPSAoZHkgPiAwLjApID8gZHkgOiAxLjA7XG4gICAgemQgPSAoZHogPiAwLjApID8gZHogOiAxLjA7XG5cbiAgICBpZiAocWZhYyA8IDAuMCkge1xuICAgICAgICB6ZCA9IC16ZDsgICAgICAgICAvKiBsZWZ0IGhhbmRlZG5lc3M/ICovXG4gICAgfVxuXG4gICAgUlswXVswXSA9ICAgICAgIChhICogYSArIGIgKiBiIC0gYyAqIGMgLSBkICogZCkgKiB4ZDtcbiAgICBSWzBdWzFdID0gMi4wICogKGIgKiBjIC0gYSAqIGQpICogeWQ7XG4gICAgUlswXVsyXSA9IDIuMCAqIChiICogZCArIGEgKiBjKSAqIHpkO1xuICAgIFJbMV1bMF0gPSAyLjAgKiAoYiAqIGMgKyBhICogZCkgKiB4ZDtcbiAgICBSWzFdWzFdID0gICAgICAgKGEgKiBhICsgYyAqIGMgLSBiICogYiAtIGQgKiBkKSAqIHlkO1xuICAgIFJbMV1bMl0gPSAyLjAgKiAoYyAqIGQgLSBhICogYikgKiB6ZDtcbiAgICBSWzJdWzBdID0gMi4wICogKGIgKiBkIC0gYSAqIGMpICogeGQ7XG4gICAgUlsyXVsxXSA9IDIuMCAqIChjICogZCArIGEgKiBiKSAqIHlkO1xuICAgIFJbMl1bMl0gPSAgICAgICAoYSAqIGEgKyBkICogZCAtIGMgKiBjIC0gYiAqIGIpICogemQ7XG5cbiAgICAvLyBsb2FkIG9mZnNldHNcbiAgICBSWzBdWzNdID0gcXg7XG4gICAgUlsxXVszXSA9IHF5O1xuICAgIFJbMl1bM10gPSBxejtcblxuICAgIHJldHVybiBSO1xufTtcblxuXG5cbi8qKlxuICogQ29udmVydHMgc2Zvcm0gdG8gYW4gb3JpZW50YXRpb24gc3RyaW5nIChlLmcuLCBYWVorLS0pLiAgKFNlZSBodHRwOi8vbmlmdGkubmltaC5uaWguZ292L3B1Yi9kaXN0L3NyYy9uaWZ0aWxpYi9uaWZ0aTFfaW8uYylcbiAqIEBwYXJhbSB7QXJyYXkuPEFycmF5LjxudW1iZXI+Pn0gUlxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xubmlmdGkuTklGVEkxLnByb3RvdHlwZS5jb252ZXJ0TmlmdGlTRm9ybVRvTkVNQSA9IGZ1bmN0aW9uIChSKSB7XG4gICAgdmFyIHhpLCB4aiwgeGssIHlpLCB5aiwgeWssIHppLCB6aiwgemssIHZhbCwgZGV0USwgZGV0UCwgaSwgaiwgaywgcCwgcSwgciwgaWJlc3QsIGpiZXN0LCBrYmVzdCwgcGJlc3QsIHFiZXN0LCByYmVzdCxcbiAgICAgICAgTSwgdmJlc3QsIFEsIFAsIGlDaGFyLCBqQ2hhciwga0NoYXIsIGlTZW5zZSwgalNlbnNlLCBrU2Vuc2U7XG4gICAgayA9IDA7XG5cbiAgICBRID0gW1swLCAwLCAwXSwgWzAsIDAsIDBdLCBbMCwgMCwgMF1dO1xuICAgIFAgPSBbWzAsIDAsIDBdLCBbMCwgMCwgMF0sIFswLCAwLCAwXV07XG5cbiAgICAvL2lmKCBpY29kID09IE5VTEwgfHwgamNvZCA9PSBOVUxMIHx8IGtjb2QgPT0gTlVMTCApIHJldHVybiA7IC8qIGJhZCAqL1xuXG4gICAgLy8qaWNvZCA9ICpqY29kID0gKmtjb2QgPSAwIDsgLyogdGhpcy5lcnJvck1lc3NhZ2UgcmV0dXJucywgaWYgc2gqdCBoYXBwZW5zICovXG5cbiAgICAvKiBsb2FkIGNvbHVtbiB2ZWN0b3JzIGZvciBlYWNoIChpLGosaykgZGlyZWN0aW9uIGZyb20gbWF0cml4ICovXG5cbiAgICAvKi0tIGkgYXhpcyAtLSovIC8qLS0gaiBheGlzIC0tKi8gLyotLSBrIGF4aXMgLS0qL1xuXG4gICAgeGkgPSBSWzBdWzBdO1xuICAgIHhqID0gUlswXVsxXTtcbiAgICB4ayA9IFJbMF1bMl07XG5cbiAgICB5aSA9IFJbMV1bMF07XG4gICAgeWogPSBSWzFdWzFdO1xuICAgIHlrID0gUlsxXVsyXTtcblxuICAgIHppID0gUlsyXVswXTtcbiAgICB6aiA9IFJbMl1bMV07XG4gICAgemsgPSBSWzJdWzJdO1xuXG4gICAgLyogbm9ybWFsaXplIGNvbHVtbiB2ZWN0b3JzIHRvIGdldCB1bml0IHZlY3RvcnMgYWxvbmcgZWFjaCBpamstYXhpcyAqL1xuXG4gICAgLyogbm9ybWFsaXplIGkgYXhpcyAqL1xuICAgIHZhbCA9IE1hdGguc3FydCh4aSAqIHhpICsgeWkgKiB5aSArIHppICogemkpO1xuICAgIGlmICh2YWwgPT09IDAuMCkgeyAgLyogc3R1cGlkIGlucHV0ICovXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHhpIC89IHZhbDtcbiAgICB5aSAvPSB2YWw7XG4gICAgemkgLz0gdmFsO1xuXG4gICAgLyogbm9ybWFsaXplIGogYXhpcyAqL1xuICAgIHZhbCA9IE1hdGguc3FydCh4aiAqIHhqICsgeWogKiB5aiArIHpqICogemopO1xuICAgIGlmICh2YWwgPT09IDAuMCkgeyAgLyogc3R1cGlkIGlucHV0ICovXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHhqIC89IHZhbDtcbiAgICB5aiAvPSB2YWw7XG4gICAgemogLz0gdmFsO1xuXG4gICAgLyogb3J0aG9nb25hbGl6ZSBqIGF4aXMgdG8gaSBheGlzLCBpZiBuZWVkZWQgKi9cbiAgICB2YWwgPSB4aSAqIHhqICsgeWkgKiB5aiArIHppICogemo7ICAgIC8qIGRvdCBwcm9kdWN0IGJldHdlZW4gaSBhbmQgaiAqL1xuICAgIGlmIChNYXRoLmFicyh2YWwpID4gMS5FLTQpIHtcbiAgICAgICAgeGogLT0gdmFsICogeGk7XG4gICAgICAgIHlqIC09IHZhbCAqIHlpO1xuICAgICAgICB6aiAtPSB2YWwgKiB6aTtcbiAgICAgICAgdmFsID0gTWF0aC5zcXJ0KHhqICogeGogKyB5aiAqIHlqICsgemogKiB6aik7ICAvKiBtdXN0IHJlbm9ybWFsaXplICovXG4gICAgICAgIGlmICh2YWwgPT09IDAuMCkgeyAgICAgICAgICAgICAgLyogaiB3YXMgcGFyYWxsZWwgdG8gaT8gKi9cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHhqIC89IHZhbDtcbiAgICAgICAgeWogLz0gdmFsO1xuICAgICAgICB6aiAvPSB2YWw7XG4gICAgfVxuXG4gICAgLyogbm9ybWFsaXplIGsgYXhpczsgaWYgaXQgaXMgemVybywgbWFrZSBpdCB0aGUgY3Jvc3MgcHJvZHVjdCBpIHggaiAqL1xuICAgIHZhbCA9IE1hdGguc3FydCh4ayAqIHhrICsgeWsgKiB5ayArIHprICogemspO1xuICAgIGlmICh2YWwgPT09IDAuMCkge1xuICAgICAgICB4ayA9IHlpICogemogLSB6aSAqIHlqO1xuICAgICAgICB5ayA9IHppICogeGogLSB6aiAqIHhpO1xuICAgICAgICB6ayA9IHhpICogeWogLSB5aSAqIHhqO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHhrIC89IHZhbDtcbiAgICAgICAgeWsgLz0gdmFsO1xuICAgICAgICB6ayAvPSB2YWw7XG4gICAgfVxuXG4gICAgLyogb3J0aG9nb25hbGl6ZSBrIHRvIGkgKi9cbiAgICB2YWwgPSB4aSAqIHhrICsgeWkgKiB5ayArIHppICogems7ICAgIC8qIGRvdCBwcm9kdWN0IGJldHdlZW4gaSBhbmQgayAqL1xuICAgIGlmIChNYXRoLmFicyh2YWwpID4gMS5FLTQpIHtcbiAgICAgICAgeGsgLT0gdmFsICogeGk7XG4gICAgICAgIHlrIC09IHZhbCAqIHlpO1xuICAgICAgICB6ayAtPSB2YWwgKiB6aTtcbiAgICAgICAgdmFsID0gTWF0aC5zcXJ0KHhrICogeGsgKyB5ayAqIHlrICsgemsgKiB6ayk7XG4gICAgICAgIGlmICh2YWwgPT09IDAuMCkgeyAgICAvKiBiYWQgKi9cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHhrIC89IHZhbDtcbiAgICAgICAgeWsgLz0gdmFsO1xuICAgICAgICB6ayAvPSB2YWw7XG4gICAgfVxuXG4gICAgLyogb3J0aG9nb25hbGl6ZSBrIHRvIGogKi9cbiAgICB2YWwgPSB4aiAqIHhrICsgeWogKiB5ayArIHpqICogems7ICAgIC8qIGRvdCBwcm9kdWN0IGJldHdlZW4gaiBhbmQgayAqL1xuICAgIGlmIChNYXRoLmFicyh2YWwpID4gMS5lLTQpIHtcbiAgICAgICAgeGsgLT0gdmFsICogeGo7XG4gICAgICAgIHlrIC09IHZhbCAqIHlqO1xuICAgICAgICB6ayAtPSB2YWwgKiB6ajtcbiAgICAgICAgdmFsID0gTWF0aC5zcXJ0KHhrICogeGsgKyB5ayAqIHlrICsgemsgKiB6ayk7XG4gICAgICAgIGlmICh2YWwgPT09IDAuMCkgeyAgICAgLyogYmFkICovXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB4ayAvPSB2YWw7XG4gICAgICAgIHlrIC89IHZhbDtcbiAgICAgICAgemsgLz0gdmFsO1xuICAgIH1cblxuICAgIFFbMF1bMF0gPSB4aTtcbiAgICBRWzBdWzFdID0geGo7XG4gICAgUVswXVsyXSA9IHhrO1xuICAgIFFbMV1bMF0gPSB5aTtcbiAgICBRWzFdWzFdID0geWo7XG4gICAgUVsxXVsyXSA9IHlrO1xuICAgIFFbMl1bMF0gPSB6aTtcbiAgICBRWzJdWzFdID0gemo7XG4gICAgUVsyXVsyXSA9IHprO1xuXG4gICAgLyogYXQgdGhpcyBwb2ludCwgUSBpcyB0aGUgcm90YXRpb24gbWF0cml4IGZyb20gdGhlIChpLGosaykgdG8gKHgseSx6KSBheGVzICovXG5cbiAgICBkZXRRID0gdGhpcy5uaWZ0aV9tYXQzM19kZXRlcm0oUSk7XG4gICAgaWYgKGRldFEgPT09IDAuMCkgeyAvKiBzaG91bGRuJ3QgaGFwcGVuIHVubGVzcyB1c2VyIGlzIGEgRFVGSVMgKi9cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLyogQnVpbGQgYW5kIHRlc3QgYWxsIHBvc3NpYmxlICsxLy0xIGNvb3JkaW5hdGUgcGVybXV0YXRpb24gbWF0cmljZXMgUDtcbiAgICAgdGhlbiBmaW5kIHRoZSBQIHN1Y2ggdGhhdCB0aGUgcm90YXRpb24gbWF0cml4IE09UFEgaXMgY2xvc2VzdCB0byB0aGVcbiAgICAgaWRlbnRpdHksIGluIHRoZSBzZW5zZSBvZiBNIGhhdmluZyB0aGUgc21hbGxlc3QgdG90YWwgcm90YXRpb24gYW5nbGUuICovXG5cbiAgICAvKiBEZXNwaXRlIHRoZSBmb3JtaWRhYmxlIGxvb2tpbmcgNiBuZXN0ZWQgbG9vcHMsIHRoZXJlIGFyZVxuICAgICBvbmx5IDMqMyozKjIqMioyID0gMjE2IHBhc3Nlcywgd2hpY2ggd2lsbCBydW4gdmVyeSBxdWlja2x5LiAqL1xuXG4gICAgdmJlc3QgPSAtNjY2LjA7XG4gICAgaWJlc3QgPSBwYmVzdCA9IHFiZXN0ID0gcmJlc3QgPSAxO1xuICAgIGpiZXN0ID0gMjtcbiAgICBrYmVzdCA9IDM7XG5cbiAgICBmb3IgKGkgPSAxOyBpIDw9IDM7IGkgKz0gMSkgeyAgICAgLyogaSA9IGNvbHVtbiBudW1iZXIgdG8gdXNlIGZvciByb3cgIzEgKi9cbiAgICAgICAgZm9yIChqID0gMTsgaiA8PSAzOyBqICs9IDEpIHsgICAgLyogaiA9IGNvbHVtbiBudW1iZXIgdG8gdXNlIGZvciByb3cgIzIgKi9cbiAgICAgICAgICAgIGlmIChpICE9PSBqKSB7XG4gICAgICAgICAgICAgICAgZm9yIChrID0gMTsgayA8PSAzOyBrICs9IDEpIHsgIC8qIGsgPSBjb2x1bW4gbnVtYmVyIHRvIHVzZSBmb3Igcm93ICMzICovXG4gICAgICAgICAgICAgICAgICAgIGlmICghKGkgPT09IGsgfHwgaiA9PT0gaykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFBbMF1bMF0gPSBQWzBdWzFdID0gUFswXVsyXSA9IFBbMV1bMF0gPSBQWzFdWzFdID0gUFsxXVsyXSA9IFBbMl1bMF0gPSBQWzJdWzFdID0gUFsyXVsyXSA9IDAuMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAocCA9IC0xOyBwIDw9IDE7IHAgKz0gMikgeyAgICAvKiBwLHEsciBhcmUgLTEgb3IgKzEgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAocSA9IC0xOyBxIDw9IDE7IHEgKz0gMikgeyAgIC8qIGFuZCBnbyBpbnRvIHJvd3MgIzEsMiwzICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAociA9IC0xOyByIDw9IDE7IHIgKz0gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUFswXVtpIC0gMV0gPSBwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUFsxXVtqIC0gMV0gPSBxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUFsyXVtrIC0gMV0gPSByO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGV0UCA9IHRoaXMubmlmdGlfbWF0MzNfZGV0ZXJtKFApOyAgICAgICAgICAgLyogc2lnbiBvZiBwZXJtdXRhdGlvbiAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChkZXRQICogZGV0USkgPiAwLjApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNID0gdGhpcy5uaWZ0aV9tYXQzM19tdWwoUCwgUSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBhbmdsZSBvZiBNIHJvdGF0aW9uID0gMi4wKmFjb3MoMC41KnNxcnQoMS4wK3RyYWNlKE0pKSkgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiB3ZSB3YW50IGxhcmdlc3QgdHJhY2UoTSkgPT0gc21hbGxlc3QgYW5nbGUgPT0gTSBuZWFyZXN0IHRvIEkgKi9cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbCA9IE1bMF1bMF0gKyBNWzFdWzFdICsgTVsyXVsyXTsgLyogdHJhY2UgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsID4gdmJlc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmJlc3QgPSB2YWw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGliZXN0ID0gaTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgamJlc3QgPSBqO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBrYmVzdCA9IGs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBiZXN0ID0gcDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcWJlc3QgPSBxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByYmVzdCA9IHI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSAgLyogZG9lc24ndCBtYXRjaCBzaWduIG9mIFEgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qIEF0IHRoaXMgcG9pbnQgaWJlc3QgaXMgMSBvciAyIG9yIDM7IHBiZXN0IGlzIC0xIG9yICsxOyBldGMuXG5cbiAgICAgVGhlIG1hdHJpeCBQIHRoYXQgY29ycmVzcG9uZHMgaXMgdGhlIGJlc3QgcGVybXV0YXRpb24gYXBwcm94aW1hdGlvblxuICAgICB0byBRLWludmVyc2U7IHRoYXQgaXMsIFAgKGFwcHJveGltYXRlbHkpIHRha2VzICh4LHkseikgY29vcmRpbmF0ZXNcbiAgICAgdG8gdGhlIChpLGosaykgYXhlcy5cblxuICAgICBGb3IgZXhhbXBsZSwgdGhlIGZpcnN0IHJvdyBvZiBQICh3aGljaCBjb250YWlucyBwYmVzdCBpbiBjb2x1bW4gaWJlc3QpXG4gICAgIGRldGVybWluZXMgdGhlIHdheSB0aGUgaSBheGlzIHBvaW50cyByZWxhdGl2ZSB0byB0aGUgYW5hdG9taWNhbFxuICAgICAoeCx5LHopIGF4ZXMuICBJZiBpYmVzdCBpcyAyLCB0aGVuIHRoZSBpIGF4aXMgaXMgYWxvbmcgdGhlIHkgYXhpcyxcbiAgICAgd2hpY2ggaXMgZGlyZWN0aW9uIFAyQSAoaWYgcGJlc3QgPiAwKSBvciBBMlAgKGlmIHBiZXN0IDwgMCkuXG5cbiAgICAgU28sIHVzaW5nIGliZXN0IGFuZCBwYmVzdCwgd2UgY2FuIGFzc2lnbiB0aGUgb3V0cHV0IGNvZGUgZm9yXG4gICAgIHRoZSBpIGF4aXMuICBNdXRhdGlzIG11dGFuZGlzIGZvciB0aGUgaiBhbmQgayBheGVzLCBvZiBjb3Vyc2UuICovXG5cbiAgICBpQ2hhciA9IGpDaGFyID0ga0NoYXIgPSBpU2Vuc2UgPSBqU2Vuc2UgPSBrU2Vuc2UgPSAwO1xuXG4gICAgc3dpdGNoIChpYmVzdCAqIHBiZXN0KSB7XG4gICAgICAgIGNhc2UgMTogLyppID0gTklGVElfTDJSKi9cbiAgICAgICAgICAgIGlDaGFyID0gJ1gnO1xuICAgICAgICAgICAgaVNlbnNlID0gJysnO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgLTE6IC8qaSA9IE5JRlRJX1IyTCovXG4gICAgICAgICAgICBpQ2hhciA9ICdYJztcbiAgICAgICAgICAgIGlTZW5zZSA9ICctJztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI6IC8qaSA9IE5JRlRJX1AyQSovXG4gICAgICAgICAgICBpQ2hhciA9ICdZJztcbiAgICAgICAgICAgIGlTZW5zZSA9ICcrJztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIC0yOiAvKmkgPSBOSUZUSV9BMlAqL1xuICAgICAgICAgICAgaUNoYXIgPSAnWSc7XG4gICAgICAgICAgICBpU2Vuc2UgPSAnLSc7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOiAvKmkgPSBOSUZUSV9JMlMqL1xuICAgICAgICAgICAgaUNoYXIgPSAnWic7XG4gICAgICAgICAgICBpU2Vuc2UgPSAnKyc7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAtMzogLyppID0gTklGVElfUzJJKi9cbiAgICAgICAgICAgIGlDaGFyID0gJ1onO1xuICAgICAgICAgICAgaVNlbnNlID0gJy0nO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgc3dpdGNoIChqYmVzdCAqIHFiZXN0KSB7XG4gICAgICAgIGNhc2UgMTogLypqID0gTklGVElfTDJSKi9cbiAgICAgICAgICAgIGpDaGFyID0gJ1gnO1xuICAgICAgICAgICAgalNlbnNlID0gJysnO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgLTE6IC8qaiA9IE5JRlRJX1IyTCovXG4gICAgICAgICAgICBqQ2hhciA9ICdYJztcbiAgICAgICAgICAgIGpTZW5zZSA9ICctJztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI6IC8qaiA9IE5JRlRJX1AyQSovXG4gICAgICAgICAgICBqQ2hhciA9ICdZJztcbiAgICAgICAgICAgIGpTZW5zZSA9ICcrJztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIC0yOiAvKmogPSBOSUZUSV9BMlAqL1xuICAgICAgICAgICAgakNoYXIgPSAnWSc7XG4gICAgICAgICAgICBqU2Vuc2UgPSAnLSc7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOiAvKmogPSBOSUZUSV9JMlMqL1xuICAgICAgICAgICAgakNoYXIgPSAnWic7XG4gICAgICAgICAgICBqU2Vuc2UgPSAnKyc7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAtMzogLypqID0gTklGVElfUzJJKi9cbiAgICAgICAgICAgIGpDaGFyID0gJ1onO1xuICAgICAgICAgICAgalNlbnNlID0gJy0nO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgc3dpdGNoIChrYmVzdCAqIHJiZXN0KSB7XG4gICAgICAgIGNhc2UgMTogLyprID0gTklGVElfTDJSKi9cbiAgICAgICAgICAgIGtDaGFyID0gJ1gnO1xuICAgICAgICAgICAga1NlbnNlID0gJysnO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgLTE6IC8qayA9IE5JRlRJX1IyTCovXG4gICAgICAgICAgICBrQ2hhciA9ICdYJztcbiAgICAgICAgICAgIGtTZW5zZSA9ICctJztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI6IC8qayA9IE5JRlRJX1AyQSovXG4gICAgICAgICAgICBrQ2hhciA9ICdZJztcbiAgICAgICAgICAgIGtTZW5zZSA9ICcrJztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIC0yOiAvKmsgPSBOSUZUSV9BMlAqL1xuICAgICAgICAgICAga0NoYXIgPSAnWSc7XG4gICAgICAgICAgICBrU2Vuc2UgPSAnLSc7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOiAvKmsgPSBOSUZUSV9JMlMqL1xuICAgICAgICAgICAga0NoYXIgPSAnWic7XG4gICAgICAgICAgICBrU2Vuc2UgPSAnKyc7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAtMzogLyprID0gTklGVElfUzJJKi9cbiAgICAgICAgICAgIGtDaGFyID0gJ1onO1xuICAgICAgICAgICAga1NlbnNlID0gJy0nO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgcmV0dXJuIChpQ2hhciArIGpDaGFyICsga0NoYXIgKyBpU2Vuc2UgKyBqU2Vuc2UgKyBrU2Vuc2UpO1xufTtcblxuXG5cbm5pZnRpLk5JRlRJMS5wcm90b3R5cGUubmlmdGlfbWF0MzNfbXVsID0gZnVuY3Rpb24gKEEsIEIpIHtcbiAgICB2YXIgQyA9IFtbMCwgMCwgMF0sIFswLCAwLCAwXSwgWzAsIDAsIDBdXSxcbiAgICAgICAgaSxcbiAgICAgICAgajtcblxuICAgIGZvciAoaSA9IDA7IGkgPCAzOyBpICs9IDEpIHtcbiAgICAgICAgZm9yIChqID0gMDsgaiA8IDM7IGogKz0gMSkge1xuICAgICAgICAgICAgQ1tpXVtqXSA9ICBBW2ldWzBdICogQlswXVtqXSAgKyBBW2ldWzFdICogQlsxXVtqXSArIEFbaV1bMl0gKiBCWzJdW2pdO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIEM7XG59O1xuXG5cblxubmlmdGkuTklGVEkxLnByb3RvdHlwZS5uaWZ0aV9tYXQzM19kZXRlcm0gPSBmdW5jdGlvbiAoUikge1xuICAgIHZhciByMTEsIHIxMiwgcjEzLCByMjEsIHIyMiwgcjIzLCByMzEsIHIzMiwgcjMzO1xuICAgIC8qICBJTlBVVCBNQVRSSVg6ICAqL1xuICAgIHIxMSA9IFJbMF1bMF07XG4gICAgcjEyID0gUlswXVsxXTtcbiAgICByMTMgPSBSWzBdWzJdO1xuICAgIHIyMSA9IFJbMV1bMF07XG4gICAgcjIyID0gUlsxXVsxXTtcbiAgICByMjMgPSBSWzFdWzJdO1xuICAgIHIzMSA9IFJbMl1bMF07XG4gICAgcjMyID0gUlsyXVsxXTtcbiAgICByMzMgPSBSWzJdWzJdO1xuXG4gICAgcmV0dXJuIChyMTEgKiByMjIgKiByMzMgLSByMTEgKiByMzIgKiByMjMgLSByMjEgKiByMTIgKiByMzMgKyByMjEgKiByMzIgKiByMTMgKyByMzEgKiByMTIgKiByMjMgLSByMzEgKiByMjIgKiByMTMpO1xufTtcblxuXG4vKipcbiAqIFJldHVybnMgdGhlIGJ5dGUgaW5kZXggb2YgdGhlIGV4dGVuc2lvbi5cbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbm5pZnRpLk5JRlRJMS5wcm90b3R5cGUuZ2V0RXh0ZW5zaW9uTG9jYXRpb24gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbmlmdGkuTklGVEkxLk1BR0lDX0NPT0tJRSArIDQ7XG59O1xuXG5cbi8qKlxuICogUmV0dXJucyB0aGUgZXh0ZW5zaW9uIHNpemUuXG4gKiBAcGFyYW0ge0RhdGFWaWV3fSBkYXRhXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5uaWZ0aS5OSUZUSTEucHJvdG90eXBlLmdldEV4dGVuc2lvblNpemUgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgcmV0dXJuIG5pZnRpLlV0aWxzLmdldEludEF0KGRhdGEsIHRoaXMuZ2V0RXh0ZW5zaW9uTG9jYXRpb24oKSwgdGhpcy5saXR0bGVFbmRpYW4pO1xufTtcblxuXG5cbi8qKlxuICogUmV0dXJucyB0aGUgZXh0ZW5zaW9uIGNvZGUuXG4gKiBAcGFyYW0ge0RhdGFWaWV3fSBkYXRhXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5uaWZ0aS5OSUZUSTEucHJvdG90eXBlLmdldEV4dGVuc2lvbkNvZGUgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgcmV0dXJuIG5pZnRpLlV0aWxzLmdldEludEF0KGRhdGEsIHRoaXMuZ2V0RXh0ZW5zaW9uTG9jYXRpb24oKSArIDQsIHRoaXMubGl0dGxlRW5kaWFuKTtcbn07XG5cblxuXG4vKioqIEV4cG9ydHMgKioqL1xuXG52YXIgbW9kdWxlVHlwZSA9IHR5cGVvZiBtb2R1bGU7XG5pZiAoKG1vZHVsZVR5cGUgIT09ICd1bmRlZmluZWQnKSAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gbmlmdGkuTklGVEkxO1xufVxuIiwiXG4vKmpzbGludCBicm93c2VyOiB0cnVlLCBub2RlOiB0cnVlICovXG4vKmdsb2JhbCAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyoqKiBJbXBvcnRzICoqKi9cblxudmFyIG5pZnRpID0gbmlmdGkgfHwge307XG5uaWZ0aS5VdGlscyA9IG5pZnRpLlV0aWxzIHx8ICgodHlwZW9mIHJlcXVpcmUgIT09ICd1bmRlZmluZWQnKSA/IHJlcXVpcmUoJy4vdXRpbGl0aWVzLmpzJykgOiBudWxsKTtcbm5pZnRpLk5JRlRJMSA9IG5pZnRpLk5JRlRJMSB8fCAoKHR5cGVvZiByZXF1aXJlICE9PSAndW5kZWZpbmVkJykgPyByZXF1aXJlKCcuL25pZnRpMS5qcycpIDogbnVsbCk7XG5cblxuLyoqKiBDb25zdHJ1Y3RvciAqKiovXG5cbi8qKlxuICogVGhlIE5JRlRJMiBjb25zdHJ1Y3Rvci5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHByb3BlcnR5IHtib29sZWFufSBsaXR0bGVFbmRpYW5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBkaW1faW5mb1xuICogQHByb3BlcnR5IHtudW1iZXJbXX0gZGltcyAtIGltYWdlIGRpbWVuc2lvbnNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBpbnRlbnRfcDFcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBpbnRlbnRfcDJcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBpbnRlbnRfcDNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBpbnRlbnRfY29kZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IGRhdGF0eXBlQ29kZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IG51bUJpdHNQZXJWb3hlbFxuICogQHByb3BlcnR5IHtudW1iZXJ9IHNsaWNlX3N0YXJ0XG4gKiBAcHJvcGVydHkge251bWJlcn0gc2xpY2VfZW5kXG4gKiBAcHJvcGVydHkge251bWJlcn0gc2xpY2VfY29kZVxuICogQHByb3BlcnR5IHtudW1iZXJbXX0gcGl4RGltcyAtIHZveGVsIGRpbWVuc2lvbnNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB2b3hfb2Zmc2V0XG4gKiBAcHJvcGVydHkge251bWJlcn0gc2NsX3Nsb3BlXG4gKiBAcHJvcGVydHkge251bWJlcn0gc2NsX2ludGVyXG4gKiBAcHJvcGVydHkge251bWJlcn0geHl6dF91bml0c1xuICogQHByb3BlcnR5IHtudW1iZXJ9IGNhbF9tYXhcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBjYWxfbWluXG4gKiBAcHJvcGVydHkge251bWJlcn0gc2xpY2VfZHVyYXRpb25cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB0b2Zmc2V0XG4gKiBAcHJvcGVydHkge3N0cmluZ30gZGVzY3JpcHRpb25cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBhdXhfZmlsZVxuICogQHByb3BlcnR5IHtzdHJpbmd9IGludGVudF9uYW1lXG4gKiBAcHJvcGVydHkge251bWJlcn0gcWZvcm1fY29kZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IHNmb3JtX2NvZGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBxdWF0ZXJuX2JcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBxdWF0ZXJuX2NcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBxdWF0ZXJuX2RcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBxdWF0ZXJuX3hcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBxdWF0ZXJuX3lcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBxdWF0ZXJuX3pcbiAqIEBwcm9wZXJ0eSB7QXJyYXkuPEFycmF5LjxudW1iZXI+Pn0gYWZmaW5lXG4gKiBAcHJvcGVydHkge3N0cmluZ30gbWFnaWNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyW119IGV4dGVuc2lvbkZsYWdcbiAqIEB0eXBlIHtGdW5jdGlvbn1cbiAqL1xubmlmdGkuTklGVEkyID0gbmlmdGkuTklGVEkyIHx8IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmxpdHRsZUVuZGlhbiA9IGZhbHNlO1xuICAgIHRoaXMuZGltX2luZm8gPSAwO1xuICAgIHRoaXMuZGltcyA9IFtdO1xuICAgIHRoaXMuaW50ZW50X3AxID0gMDtcbiAgICB0aGlzLmludGVudF9wMiA9IDA7XG4gICAgdGhpcy5pbnRlbnRfcDMgPSAwO1xuICAgIHRoaXMuaW50ZW50X2NvZGUgPSAwO1xuICAgIHRoaXMuZGF0YXR5cGVDb2RlID0gMDtcbiAgICB0aGlzLm51bUJpdHNQZXJWb3hlbCA9IDA7XG4gICAgdGhpcy5zbGljZV9zdGFydCA9IDA7XG4gICAgdGhpcy5zbGljZV9lbmQgPSAwO1xuICAgIHRoaXMuc2xpY2VfY29kZSA9IDA7XG4gICAgdGhpcy5waXhEaW1zID0gW107XG4gICAgdGhpcy52b3hfb2Zmc2V0ID0gMDtcbiAgICB0aGlzLnNjbF9zbG9wZSA9IDE7XG4gICAgdGhpcy5zY2xfaW50ZXIgPSAwO1xuICAgIHRoaXMueHl6dF91bml0cyA9IDA7XG4gICAgdGhpcy5jYWxfbWF4ID0gMDtcbiAgICB0aGlzLmNhbF9taW4gPSAwO1xuICAgIHRoaXMuc2xpY2VfZHVyYXRpb24gPSAwO1xuICAgIHRoaXMudG9mZnNldCA9IDA7XG4gICAgdGhpcy5kZXNjcmlwdGlvbiA9IFwiXCI7XG4gICAgdGhpcy5hdXhfZmlsZSA9IFwiXCI7XG4gICAgdGhpcy5pbnRlbnRfbmFtZSA9IFwiXCI7XG4gICAgdGhpcy5xZm9ybV9jb2RlID0gMDtcbiAgICB0aGlzLnNmb3JtX2NvZGUgPSAwO1xuICAgIHRoaXMucXVhdGVybl9iID0gMDtcbiAgICB0aGlzLnF1YXRlcm5fYyA9IDA7XG4gICAgdGhpcy5xdWF0ZXJuX2QgPSAwO1xuICAgIHRoaXMucW9mZnNldF94ID0gMDtcbiAgICB0aGlzLnFvZmZzZXRfeSA9IDA7XG4gICAgdGhpcy5xb2Zmc2V0X3ogPSAwO1xuICAgIHRoaXMuYWZmaW5lID0gW1sxLCAwLCAwLCAwXSwgWzAsIDEsIDAsIDBdLCBbMCwgMCwgMSwgMF0sIFswLCAwLCAwLCAxXV07XG4gICAgdGhpcy5tYWdpYyA9IDA7XG4gICAgdGhpcy5leHRlbnNpb25GbGFnID0gWzAsIDAsIDAsIDBdO1xufTtcblxuXG5cbi8qKiogU3RhdGljIFBzZXVkby1jb25zdGFudHMgKioqL1xuXG5uaWZ0aS5OSUZUSTIuTUFHSUNfQ09PS0lFID0gNTQwO1xubmlmdGkuTklGVEkyLk1BR0lDX05VTUJFUl9MT0NBVElPTiA9IDQ7XG5uaWZ0aS5OSUZUSTIuTUFHSUNfTlVNQkVSID0gWzB4NkUsIDB4MkIsIDB4MzIsIDAsIDB4MEQsIDB4MEEsIDB4MUEsIDB4MEFdOyAgLy8gbisyXFwwXG5cblxuXG4vKioqIFByb3RvdHlwZSBNZXRob2RzICoqKi9cblxuLyoqXG4gKiBSZWFkcyB0aGUgaGVhZGVyIGRhdGEuXG4gKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBkYXRhXG4gKi9cbm5pZnRpLk5JRlRJMi5wcm90b3R5cGUucmVhZEhlYWRlciA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgdmFyIHJhd0RhdGEgPSBuZXcgRGF0YVZpZXcoZGF0YSksXG4gICAgICAgIG1hZ2ljQ29va2llVmFsID0gbmlmdGkuVXRpbHMuZ2V0SW50QXQocmF3RGF0YSwgMCwgdGhpcy5saXR0bGVFbmRpYW4pLFxuICAgICAgICBjdHIsXG4gICAgICAgIGN0ck91dCxcbiAgICAgICAgY3RySW4sXG4gICAgICAgIGluZGV4LFxuICAgICAgICBhcnJheTtcblxuICAgIGlmIChtYWdpY0Nvb2tpZVZhbCAhPT0gbmlmdGkuTklGVEkyLk1BR0lDX0NPT0tJRSkgeyAgLy8gdHJ5IGFzIGxpdHRsZSBlbmRpYW5cbiAgICAgICAgdGhpcy5saXR0bGVFbmRpYW4gPSB0cnVlO1xuICAgICAgICBtYWdpY0Nvb2tpZVZhbCA9IG5pZnRpLlV0aWxzLmdldEludEF0KHJhd0RhdGEsIDAsIHRoaXMubGl0dGxlRW5kaWFuKTtcbiAgICB9XG5cbiAgICBpZiAobWFnaWNDb29raWVWYWwgIT09IG5pZnRpLk5JRlRJMi5NQUdJQ19DT09LSUUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhpcyBkb2VzIG5vdCBhcHBlYXIgdG8gYmUgYSBOSUZUSSBmaWxlIVwiKTtcbiAgICB9XG5cbiAgICB0aGlzLmRhdGF0eXBlQ29kZSA9IG5pZnRpLlV0aWxzLmdldFNob3J0QXQocmF3RGF0YSwgMTIsIHRoaXMubGl0dGxlRW5kaWFuKTtcbiAgICB0aGlzLm51bUJpdHNQZXJWb3hlbCA9IG5pZnRpLlV0aWxzLmdldFNob3J0QXQocmF3RGF0YSwgMTQsIHRoaXMubGl0dGxlRW5kaWFuKTtcblxuICAgIGZvciAoY3RyID0gMDsgY3RyIDwgODsgY3RyICs9IDEpIHtcbiAgICAgICAgaW5kZXggPSAxNiArIChjdHIgKiA4KTtcbiAgICAgICAgdGhpcy5kaW1zW2N0cl0gPSBuaWZ0aS5VdGlscy5nZXRMb25nQXQocmF3RGF0YSwgaW5kZXgsIHRoaXMubGl0dGxlRW5kaWFuKTtcbiAgICB9XG5cbiAgICB0aGlzLmludGVudF9wMSA9IG5pZnRpLlV0aWxzLmdldERvdWJsZUF0KHJhd0RhdGEsIDgwLCB0aGlzLmxpdHRsZUVuZGlhbik7XG4gICAgdGhpcy5pbnRlbnRfcDIgPSBuaWZ0aS5VdGlscy5nZXREb3VibGVBdChyYXdEYXRhLCA4OCwgdGhpcy5saXR0bGVFbmRpYW4pO1xuICAgIHRoaXMuaW50ZW50X3AzID0gbmlmdGkuVXRpbHMuZ2V0RG91YmxlQXQocmF3RGF0YSwgOTYsIHRoaXMubGl0dGxlRW5kaWFuKTtcblxuICAgIGZvciAoY3RyID0gMDsgY3RyIDwgODsgY3RyICs9IDEpIHtcbiAgICAgICAgaW5kZXggPSAxMDQgKyAoY3RyICogOCk7XG4gICAgICAgIHRoaXMucGl4RGltc1tjdHJdID0gbmlmdGkuVXRpbHMuZ2V0RG91YmxlQXQocmF3RGF0YSwgaW5kZXgsIHRoaXMubGl0dGxlRW5kaWFuKTtcbiAgICB9XG5cbiAgICB0aGlzLnZveF9vZmZzZXQgPSBuaWZ0aS5VdGlscy5nZXRMb25nQXQocmF3RGF0YSwgMTY4LCB0aGlzLmxpdHRsZUVuZGlhbik7XG5cbiAgICB0aGlzLnNjbF9zbG9wZSA9IG5pZnRpLlV0aWxzLmdldERvdWJsZUF0KHJhd0RhdGEsIDE3NiwgdGhpcy5saXR0bGVFbmRpYW4pO1xuICAgIHRoaXMuc2NsX2ludGVyID0gbmlmdGkuVXRpbHMuZ2V0RG91YmxlQXQocmF3RGF0YSwgMTg0LCB0aGlzLmxpdHRsZUVuZGlhbik7XG5cbiAgICB0aGlzLmNhbF9tYXggPSBuaWZ0aS5VdGlscy5nZXREb3VibGVBdChyYXdEYXRhLCAxOTIsIHRoaXMubGl0dGxlRW5kaWFuKTtcbiAgICB0aGlzLmNhbF9taW4gPSBuaWZ0aS5VdGlscy5nZXREb3VibGVBdChyYXdEYXRhLCAyMDAsIHRoaXMubGl0dGxlRW5kaWFuKTtcblxuICAgIHRoaXMuc2xpY2VfZHVyYXRpb24gPSBuaWZ0aS5VdGlscy5nZXREb3VibGVBdChyYXdEYXRhLCAyMDgsIHRoaXMubGl0dGxlRW5kaWFuKTtcblxuICAgIHRoaXMudG9mZnNldCA9IG5pZnRpLlV0aWxzLmdldERvdWJsZUF0KHJhd0RhdGEsIDIxNiwgdGhpcy5saXR0bGVFbmRpYW4pO1xuXG4gICAgdGhpcy5zbGljZV9zdGFydCA9IG5pZnRpLlV0aWxzLmdldExvbmdBdChyYXdEYXRhLCAyMjQsIHRoaXMubGl0dGxlRW5kaWFuKTtcbiAgICB0aGlzLnNsaWNlX2VuZCA9IG5pZnRpLlV0aWxzLmdldExvbmdBdChyYXdEYXRhLCAyMzIsIHRoaXMubGl0dGxlRW5kaWFuKTtcblxuICAgIHRoaXMuZGVzY3JpcHRpb24gPSBuaWZ0aS5VdGlscy5nZXRTdHJpbmdBdChyYXdEYXRhLCAyNDAsIDI0MCArIDgwKTtcbiAgICB0aGlzLmF1eF9maWxlID0gbmlmdGkuVXRpbHMuZ2V0U3RyaW5nQXQocmF3RGF0YSwgMzIwLCAzMjAgKyAyNCk7XG5cbiAgICB0aGlzLnFmb3JtX2NvZGUgPSBuaWZ0aS5VdGlscy5nZXRJbnRBdChyYXdEYXRhLCAzNDQsIHRoaXMubGl0dGxlRW5kaWFuKTtcbiAgICB0aGlzLnNmb3JtX2NvZGUgPSBuaWZ0aS5VdGlscy5nZXRJbnRBdChyYXdEYXRhLCAzNDgsIHRoaXMubGl0dGxlRW5kaWFuKTtcblxuICAgIHRoaXMucXVhdGVybl9iID0gbmlmdGkuVXRpbHMuZ2V0RG91YmxlQXQocmF3RGF0YSwgMzUyLCB0aGlzLmxpdHRsZUVuZGlhbik7XG4gICAgdGhpcy5xdWF0ZXJuX2MgPSBuaWZ0aS5VdGlscy5nZXREb3VibGVBdChyYXdEYXRhLCAzNjAsIHRoaXMubGl0dGxlRW5kaWFuKTtcbiAgICB0aGlzLnF1YXRlcm5fZCA9IG5pZnRpLlV0aWxzLmdldERvdWJsZUF0KHJhd0RhdGEsIDM2OCwgdGhpcy5saXR0bGVFbmRpYW4pO1xuICAgIHRoaXMucW9mZnNldF94ID0gbmlmdGkuVXRpbHMuZ2V0RG91YmxlQXQocmF3RGF0YSwgMzc2LCB0aGlzLmxpdHRsZUVuZGlhbik7XG4gICAgdGhpcy5xb2Zmc2V0X3kgPSBuaWZ0aS5VdGlscy5nZXREb3VibGVBdChyYXdEYXRhLCAzODQsIHRoaXMubGl0dGxlRW5kaWFuKTtcbiAgICB0aGlzLnFvZmZzZXRfeiA9IG5pZnRpLlV0aWxzLmdldERvdWJsZUF0KHJhd0RhdGEsIDM5MiwgdGhpcy5saXR0bGVFbmRpYW4pO1xuXG4gICAgZm9yIChjdHJPdXQgPSAwOyBjdHJPdXQgPCAzOyBjdHJPdXQgKz0gMSkge1xuICAgICAgICBmb3IgKGN0ckluID0gMDsgY3RySW4gPCA0OyBjdHJJbiArPSAxKSB7XG4gICAgICAgICAgICBpbmRleCA9IDQwMCArICgoKGN0ck91dCAqIDQpICsgY3RySW4pICogOCk7XG4gICAgICAgICAgICB0aGlzLmFmZmluZVtjdHJPdXRdW2N0ckluXSA9IG5pZnRpLlV0aWxzLmdldERvdWJsZUF0KHJhd0RhdGEsIGluZGV4LCB0aGlzLmxpdHRsZUVuZGlhbik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmFmZmluZVszXVswXSA9IDA7XG4gICAgdGhpcy5hZmZpbmVbM11bMV0gPSAwO1xuICAgIHRoaXMuYWZmaW5lWzNdWzJdID0gMDtcbiAgICB0aGlzLmFmZmluZVszXVszXSA9IDE7XG5cbiAgICB0aGlzLnNsaWNlX2NvZGUgPSBuaWZ0aS5VdGlscy5nZXRJbnRBdChyYXdEYXRhLCA0OTYsIHRoaXMubGl0dGxlRW5kaWFuKTtcbiAgICB0aGlzLnh5enRfdW5pdHMgPSBuaWZ0aS5VdGlscy5nZXRJbnRBdChyYXdEYXRhLCA1MDAsIHRoaXMubGl0dGxlRW5kaWFuKTtcbiAgICB0aGlzLmludGVudF9jb2RlID0gbmlmdGkuVXRpbHMuZ2V0SW50QXQocmF3RGF0YSwgNTA0LCB0aGlzLmxpdHRsZUVuZGlhbik7XG4gICAgdGhpcy5pbnRlbnRfbmFtZSA9IG5pZnRpLlV0aWxzLmdldFN0cmluZ0F0KHJhd0RhdGEsIDUwOCwgNTA4ICsgMTYpO1xuXG4gICAgdGhpcy5kaW1faW5mbyA9IG5pZnRpLlV0aWxzLmdldEJ5dGVBdChyYXdEYXRhLCA1MjQpO1xuXG4gICAgaWYgKHJhd0RhdGEuYnl0ZUxlbmd0aCA+IG5pZnRpLk5JRlRJMi5NQUdJQ19DT09LSUUpIHtcbiAgICAgICAgdGhpcy5leHRlbnNpb25GbGFnWzBdID0gbmlmdGkuVXRpbHMuZ2V0Qnl0ZUF0KHJhd0RhdGEsIDU0MCk7XG4gICAgICAgIHRoaXMuZXh0ZW5zaW9uRmxhZ1sxXSA9IG5pZnRpLlV0aWxzLmdldEJ5dGVBdChyYXdEYXRhLCA1NDAgKyAxKTtcbiAgICAgICAgdGhpcy5leHRlbnNpb25GbGFnWzJdID0gbmlmdGkuVXRpbHMuZ2V0Qnl0ZUF0KHJhd0RhdGEsIDU0MCArIDIpO1xuICAgICAgICB0aGlzLmV4dGVuc2lvbkZsYWdbM10gPSBuaWZ0aS5VdGlscy5nZXRCeXRlQXQocmF3RGF0YSwgNTQwICsgMyk7XG5cbiAgICAgICAgaWYgKHRoaXMuZXh0ZW5zaW9uRmxhZ1swXSkge1xuICAgICAgICAgICAgdGhpcy5leHRlbnNpb25TaXplID0gdGhpcy5nZXRFeHRlbnNpb25TaXplKHJhd0RhdGEpO1xuICAgICAgICAgICAgdGhpcy5leHRlbnNpb25Db2RlID0gdGhpcy5nZXRFeHRlbnNpb25Db2RlKHJhd0RhdGEpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuXG5cbi8qKlxuICogUmV0dXJucyBhIGZvcm1hdHRlZCBzdHJpbmcgb2YgaGVhZGVyIGZpZWxkcy5cbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbm5pZnRpLk5JRlRJMi5wcm90b3R5cGUudG9Gb3JtYXR0ZWRTdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGZtdCA9IG5pZnRpLlV0aWxzLmZvcm1hdE51bWJlcixcbiAgICAgICAgc3RyaW5nID0gXCJcIjtcblxuICAgIHN0cmluZyArPSAoXCJEYXRhdHlwZSA9IFwiICsgICsgdGhpcy5kYXRhdHlwZUNvZGUgKyBcIiAoXCIgKyB0aGlzLmdldERhdGF0eXBlQ29kZVN0cmluZyh0aGlzLmRhdGF0eXBlQ29kZSkgKyBcIilcXG5cIik7XG4gICAgc3RyaW5nICs9IChcIkJpdHMgUGVyIFZveGVsID0gXCIgKyBcIiA9IFwiICsgdGhpcy5udW1CaXRzUGVyVm94ZWwgKyBcIlxcblwiKTtcbiAgICBzdHJpbmcgKz0gKFwiSW1hZ2UgRGltZW5zaW9uc1wiICsgXCIgKDEtOCk6IFwiICtcbiAgICAgICAgdGhpcy5kaW1zWzBdICsgXCIsIFwiICtcbiAgICAgICAgdGhpcy5kaW1zWzFdICsgXCIsIFwiICtcbiAgICAgICAgdGhpcy5kaW1zWzJdICsgXCIsIFwiICtcbiAgICAgICAgdGhpcy5kaW1zWzNdICsgXCIsIFwiICtcbiAgICAgICAgdGhpcy5kaW1zWzRdICsgXCIsIFwiICtcbiAgICAgICAgdGhpcy5kaW1zWzVdICsgXCIsIFwiICtcbiAgICAgICAgdGhpcy5kaW1zWzZdICsgXCIsIFwiICtcbiAgICAgICAgdGhpcy5kaW1zWzddICsgXCJcXG5cIik7XG5cbiAgICBzdHJpbmcgKz0gKFwiSW50ZW50IFBhcmFtZXRlcnMgKDEtMyk6IFwiICtcbiAgICAgICAgdGhpcy5pbnRlbnRfcDEgKyBcIiwgXCIgK1xuICAgICAgICB0aGlzLmludGVudF9wMiArIFwiLCBcIiArXG4gICAgICAgIHRoaXMuaW50ZW50X3AzKSArIFwiXFxuXCI7XG5cbiAgICBzdHJpbmcgKz0gKFwiVm94ZWwgRGltZW5zaW9ucyAoMS04KTogXCIgK1xuICAgICAgICBmbXQodGhpcy5waXhEaW1zWzBdKSArIFwiLCBcIiArXG4gICAgICAgIGZtdCh0aGlzLnBpeERpbXNbMV0pICsgXCIsIFwiICtcbiAgICAgICAgZm10KHRoaXMucGl4RGltc1syXSkgKyBcIiwgXCIgK1xuICAgICAgICBmbXQodGhpcy5waXhEaW1zWzNdKSArIFwiLCBcIiArXG4gICAgICAgIGZtdCh0aGlzLnBpeERpbXNbNF0pICsgXCIsIFwiICtcbiAgICAgICAgZm10KHRoaXMucGl4RGltc1s1XSkgKyBcIiwgXCIgK1xuICAgICAgICBmbXQodGhpcy5waXhEaW1zWzZdKSArIFwiLCBcIiArXG4gICAgICAgIGZtdCh0aGlzLnBpeERpbXNbN10pICsgXCJcXG5cIik7XG5cbiAgICBzdHJpbmcgKz0gKFwiSW1hZ2UgT2Zmc2V0ID0gXCIgKyB0aGlzLnZveF9vZmZzZXQgKyBcIlxcblwiKTtcbiAgICBzdHJpbmcgKz0gKFwiRGF0YSBTY2FsZTogIFNsb3BlID0gXCIgKyBmbXQodGhpcy5zY2xfc2xvcGUpICsgXCIgIEludGVyY2VwdCA9IFwiICsgZm10KHRoaXMuc2NsX2ludGVyKSArIFwiXFxuXCIpO1xuICAgIHN0cmluZyArPSAoXCJEaXNwbGF5IFJhbmdlOiAgTWF4ID0gXCIgKyBmbXQodGhpcy5jYWxfbWF4KSArIFwiICBNaW4gPSBcIiArIGZtdCh0aGlzLmNhbF9taW4pICsgXCJcXG5cIik7XG4gICAgc3RyaW5nICs9IChcIlNsaWNlIER1cmF0aW9uID0gXCIgKyB0aGlzLnNsaWNlX2R1cmF0aW9uICsgXCJcXG5cIik7XG4gICAgc3RyaW5nICs9IChcIlRpbWUgQXhpcyBTaGlmdCA9IFwiICsgdGhpcy50b2Zmc2V0ICsgXCJcXG5cIik7XG4gICAgc3RyaW5nICs9IChcIlNsaWNlIFN0YXJ0ID0gXCIgKyB0aGlzLnNsaWNlX3N0YXJ0ICsgXCJcXG5cIik7XG4gICAgc3RyaW5nICs9IChcIlNsaWNlIEVuZCA9IFwiICsgdGhpcy5zbGljZV9lbmQgKyBcIlxcblwiKTtcbiAgICBzdHJpbmcgKz0gKFwiRGVzY3JpcHRpb246IFxcXCJcIiArIHRoaXMuZGVzY3JpcHRpb24gKyBcIlxcXCJcXG5cIik7XG4gICAgc3RyaW5nICs9IChcIkF1eGlsaWFyeSBGaWxlOiBcXFwiXCIgKyB0aGlzLmF1eF9maWxlICsgXCJcXFwiXFxuXCIpO1xuICAgIHN0cmluZyArPSAoXCJRLUZvcm0gQ29kZSA9IFwiICsgdGhpcy5xZm9ybV9jb2RlICsgXCIgKFwiICsgdGhpcy5nZXRUcmFuc2Zvcm1Db2RlU3RyaW5nKHRoaXMucWZvcm1fY29kZSkgKyBcIilcXG5cIik7XG4gICAgc3RyaW5nICs9IChcIlMtRm9ybSBDb2RlID0gXCIgKyB0aGlzLnNmb3JtX2NvZGUgKyBcIiAoXCIgKyB0aGlzLmdldFRyYW5zZm9ybUNvZGVTdHJpbmcodGhpcy5zZm9ybV9jb2RlKSArIFwiKVxcblwiKTtcbiAgICBzdHJpbmcgKz0gKFwiUXVhdGVybmlvbiBQYXJhbWV0ZXJzOiAgXCIgK1xuICAgIFwiYiA9IFwiICsgZm10KHRoaXMucXVhdGVybl9iKSArIFwiICBcIiArXG4gICAgXCJjID0gXCIgKyBmbXQodGhpcy5xdWF0ZXJuX2MpICsgXCIgIFwiICtcbiAgICBcImQgPSBcIiArIGZtdCh0aGlzLnF1YXRlcm5fZCkgKyBcIlxcblwiKTtcblxuICAgIHN0cmluZyArPSAoXCJRdWF0ZXJuaW9uIE9mZnNldHM6ICBcIiArXG4gICAgXCJ4ID0gXCIgKyB0aGlzLnFvZmZzZXRfeCArIFwiICBcIiArXG4gICAgXCJ5ID0gXCIgKyB0aGlzLnFvZmZzZXRfeSArIFwiICBcIiArXG4gICAgXCJ6ID0gXCIgKyB0aGlzLnFvZmZzZXRfeiArIFwiXFxuXCIpO1xuXG4gICAgc3RyaW5nICs9IChcIlMtRm9ybSBQYXJhbWV0ZXJzIFg6IFwiICtcbiAgICBmbXQodGhpcy5hZmZpbmVbMF1bMF0pICsgXCIsIFwiICtcbiAgICBmbXQodGhpcy5hZmZpbmVbMF1bMV0pICsgXCIsIFwiICtcbiAgICBmbXQodGhpcy5hZmZpbmVbMF1bMl0pICsgXCIsIFwiICtcbiAgICBmbXQodGhpcy5hZmZpbmVbMF1bM10pICsgXCJcXG5cIik7XG5cbiAgICBzdHJpbmcgKz0gKFwiUy1Gb3JtIFBhcmFtZXRlcnMgWTogXCIgK1xuICAgIGZtdCh0aGlzLmFmZmluZVsxXVswXSkgKyBcIiwgXCIgK1xuICAgIGZtdCh0aGlzLmFmZmluZVsxXVsxXSkgKyBcIiwgXCIgK1xuICAgIGZtdCh0aGlzLmFmZmluZVsxXVsyXSkgKyBcIiwgXCIgK1xuICAgIGZtdCh0aGlzLmFmZmluZVsxXVszXSkgKyBcIlxcblwiKTtcblxuICAgIHN0cmluZyArPSAoXCJTLUZvcm0gUGFyYW1ldGVycyBaOiBcIiArXG4gICAgZm10KHRoaXMuYWZmaW5lWzJdWzBdKSArIFwiLCBcIiArXG4gICAgZm10KHRoaXMuYWZmaW5lWzJdWzFdKSArIFwiLCBcIiArXG4gICAgZm10KHRoaXMuYWZmaW5lWzJdWzJdKSArIFwiLCBcIiArXG4gICAgZm10KHRoaXMuYWZmaW5lWzJdWzNdKSArIFwiXFxuXCIpO1xuXG4gICAgc3RyaW5nICs9IChcIlNsaWNlIENvZGUgPSBcIiArIHRoaXMuc2xpY2VfY29kZSArIFwiXFxuXCIpO1xuICAgIHN0cmluZyArPSAoXCJVbml0cyBDb2RlID0gXCIgKyB0aGlzLnh5enRfdW5pdHMgKyBcIiAoXCIgKyB0aGlzLmdldFVuaXRzQ29kZVN0cmluZyhuaWZ0aS5OSUZUSTEuU1BBVElBTF9VTklUU19NQVNLICYgdGhpcy54eXp0X3VuaXRzKSArIFwiLCBcIiArIHRoaXMuZ2V0VW5pdHNDb2RlU3RyaW5nKG5pZnRpLk5JRlRJMS5URU1QT1JBTF9VTklUU19NQVNLICYgdGhpcy54eXp0X3VuaXRzKSArIFwiKVxcblwiKTtcbiAgICBzdHJpbmcgKz0gKFwiSW50ZW50IENvZGUgPSBcIiArIHRoaXMuaW50ZW50X2NvZGUgKyBcIlxcblwiKTtcbiAgICBzdHJpbmcgKz0gKFwiSW50ZW50IE5hbWU6IFxcXCJcIiArIHRoaXMuaW50ZW50X25hbWUgKyBcIlxcXCJcXG5cIik7XG5cbiAgICBzdHJpbmcgKz0gKFwiRGltIEluZm8gPSBcIiArIHRoaXMuZGltX2luZm8gKyBcIlxcblwiKTtcblxuICAgIHJldHVybiBzdHJpbmc7XG59O1xuXG5cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBieXRlIGluZGV4IG9mIHRoZSBleHRlbnNpb24uXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5uaWZ0aS5OSUZUSTIucHJvdG90eXBlLmdldEV4dGVuc2lvbkxvY2F0aW9uID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG5pZnRpLk5JRlRJMi5NQUdJQ19DT09LSUUgKyA0O1xufTtcblxuXG5cbi8qKlxuICogUmV0dXJucyB0aGUgZXh0ZW5zaW9uIHNpemUuXG4gKiBAcGFyYW0ge0RhdGFWaWV3fSBkYXRhXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5uaWZ0aS5OSUZUSTIucHJvdG90eXBlLmdldEV4dGVuc2lvblNpemUgPSBuaWZ0aS5OSUZUSTEucHJvdG90eXBlLmdldEV4dGVuc2lvblNpemU7XG5cblxuXG4vKipcbiAqIFJldHVybnMgdGhlIGV4dGVuc2lvbiBjb2RlLlxuICogQHBhcmFtIHtEYXRhVmlld30gZGF0YVxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xubmlmdGkuTklGVEkyLnByb3RvdHlwZS5nZXRFeHRlbnNpb25Db2RlID0gbmlmdGkuTklGVEkxLnByb3RvdHlwZS5nZXRFeHRlbnNpb25Db2RlO1xuXG5cblxuLyoqXG4gKiBSZXR1cm5zIGEgaHVtYW4tcmVhZGFibGUgc3RyaW5nIG9mIGRhdGF0eXBlLlxuICogQHBhcmFtIHtudW1iZXJ9IGNvZGVcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbm5pZnRpLk5JRlRJMi5wcm90b3R5cGUuZ2V0RGF0YXR5cGVDb2RlU3RyaW5nID0gbmlmdGkuTklGVEkxLnByb3RvdHlwZS5nZXREYXRhdHlwZUNvZGVTdHJpbmc7XG5cblxuXG4vKipcbiAqIFJldHVybnMgYSBodW1hbi1yZWFkYWJsZSBzdHJpbmcgb2YgdHJhbnNmb3JtIHR5cGUuXG4gKiBAcGFyYW0ge251bWJlcn0gY29kZVxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xubmlmdGkuTklGVEkyLnByb3RvdHlwZS5nZXRUcmFuc2Zvcm1Db2RlU3RyaW5nID0gbmlmdGkuTklGVEkxLnByb3RvdHlwZS5nZXRUcmFuc2Zvcm1Db2RlU3RyaW5nO1xuXG5cblxuLyoqXG4gKiBSZXR1cm5zIGEgaHVtYW4tcmVhZGFibGUgc3RyaW5nIG9mIHNwYXRpYWwgYW5kIHRlbXBvcmFsIHVuaXRzLlxuICogQHBhcmFtIHtudW1iZXJ9IGNvZGVcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbm5pZnRpLk5JRlRJMi5wcm90b3R5cGUuZ2V0VW5pdHNDb2RlU3RyaW5nID0gbmlmdGkuTklGVEkxLnByb3RvdHlwZS5nZXRVbml0c0NvZGVTdHJpbmc7XG5cblxuXG4vKipcbiAqIFJldHVybnMgdGhlIHFmb3JtIG1hdHJpeC5cbiAqIEByZXR1cm5zIHtBcnJheS48QXJyYXkuPG51bWJlcj4+fVxuICovXG5uaWZ0aS5OSUZUSTIucHJvdG90eXBlLmdldFFmb3JtTWF0ID0gbmlmdGkuTklGVEkxLnByb3RvdHlwZS5nZXRRZm9ybU1hdDtcblxuXG5cbi8qKlxuICogQ29udmVydHMgcWZvcm0gdG8gYW4gYWZmaW5lLiAgKFNlZSBodHRwOi8vbmlmdGkubmltaC5uaWguZ292L3B1Yi9kaXN0L3NyYy9uaWZ0aWxpYi9uaWZ0aTFfaW8uYylcbiAqIEBwYXJhbSB7bnVtYmVyfSBxYlxuICogQHBhcmFtIHtudW1iZXJ9IHFjXG4gKiBAcGFyYW0ge251bWJlcn0gcWRcbiAqIEBwYXJhbSB7bnVtYmVyfSBxeFxuICogQHBhcmFtIHtudW1iZXJ9IHF5XG4gKiBAcGFyYW0ge251bWJlcn0gcXpcbiAqIEBwYXJhbSB7bnVtYmVyfSBkeFxuICogQHBhcmFtIHtudW1iZXJ9IGR5XG4gKiBAcGFyYW0ge251bWJlcn0gZHpcbiAqIEBwYXJhbSB7bnVtYmVyfSBxZmFjXG4gKiBAcmV0dXJucyB7QXJyYXkuPEFycmF5LjxudW1iZXI+Pn1cbiAqL1xubmlmdGkuTklGVEkyLnByb3RvdHlwZS5jb252ZXJ0TmlmdGlRRm9ybVRvTmlmdGlTRm9ybSA9IG5pZnRpLk5JRlRJMS5wcm90b3R5cGUuY29udmVydE5pZnRpUUZvcm1Ub05pZnRpU0Zvcm07XG5cblxuXG4vKipcbiAqIENvbnZlcnRzIHNmb3JtIHRvIGFuIG9yaWVudGF0aW9uIHN0cmluZyAoZS5nLiwgWFlaKy0tKS4gIChTZWUgaHR0cDovL25pZnRpLm5pbWgubmloLmdvdi9wdWIvZGlzdC9zcmMvbmlmdGlsaWIvbmlmdGkxX2lvLmMpXG4gKiBAcGFyYW0ge0FycmF5LjxBcnJheS48bnVtYmVyPj59IFJcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbm5pZnRpLk5JRlRJMi5wcm90b3R5cGUuY29udmVydE5pZnRpU0Zvcm1Ub05FTUEgPSBuaWZ0aS5OSUZUSTEucHJvdG90eXBlLmNvbnZlcnROaWZ0aVNGb3JtVG9ORU1BO1xuXG5cblxubmlmdGkuTklGVEkyLnByb3RvdHlwZS5uaWZ0aV9tYXQzM19tdWwgPSBuaWZ0aS5OSUZUSTEucHJvdG90eXBlLm5pZnRpX21hdDMzX211bDtcblxuXG5cbm5pZnRpLk5JRlRJMi5wcm90b3R5cGUubmlmdGlfbWF0MzNfZGV0ZXJtID0gbmlmdGkuTklGVEkxLnByb3RvdHlwZS5uaWZ0aV9tYXQzM19kZXRlcm07XG5cblxuXG4vKioqIEV4cG9ydHMgKioqL1xuXG52YXIgbW9kdWxlVHlwZSA9IHR5cGVvZiBtb2R1bGU7XG5pZiAoKG1vZHVsZVR5cGUgIT09ICd1bmRlZmluZWQnKSAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gbmlmdGkuTklGVEkyO1xufVxuIiwiXG4vKmpzbGludCBicm93c2VyOiB0cnVlLCBub2RlOiB0cnVlICovXG4vKmdsb2JhbCByZXF1aXJlLCBtb2R1bGUgKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKiogSW1wb3J0cyAqKiovXG5cbnZhciBuaWZ0aSA9IG5pZnRpIHx8IHt9O1xubmlmdGkuVXRpbHMgPSBuaWZ0aS5VdGlscyB8fCB7fTtcblxuXG5cbi8qKiogU3RhdGljIFBzZXVkby1jb25zdGFudHMgKioqL1xuXG5uaWZ0aS5VdGlscy5jcmNUYWJsZSA9IG51bGw7XG5uaWZ0aS5VdGlscy5HVU5aSVBfTUFHSUNfQ09PS0lFMSA9IDMxO1xubmlmdGkuVXRpbHMuR1VOWklQX01BR0lDX0NPT0tJRTIgPSAxMzk7XG5cblxuXG4vKioqIFN0YXRpYyBtZXRob2RzICoqKi9cblxubmlmdGkuVXRpbHMuZ2V0U3RyaW5nQXQgPSBmdW5jdGlvbiAoZGF0YSwgc3RhcnQsIGVuZCkge1xuICAgIHZhciBzdHIgPSBcIlwiLCBjdHIsIGNoO1xuXG4gICAgZm9yIChjdHIgPSBzdGFydDsgY3RyIDwgZW5kOyBjdHIgKz0gMSkge1xuICAgICAgICBjaCA9IGRhdGEuZ2V0VWludDgoY3RyKTtcblxuICAgICAgICBpZiAoY2ggIT09IDApIHtcbiAgICAgICAgICAgIHN0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzdHI7XG59O1xuXG5cblxubmlmdGkuVXRpbHMuZ2V0Qnl0ZUF0ID0gZnVuY3Rpb24gKGRhdGEsIHN0YXJ0KSB7XG4gICAgcmV0dXJuIGRhdGEuZ2V0SW50OChzdGFydCk7XG59O1xuXG5cblxubmlmdGkuVXRpbHMuZ2V0U2hvcnRBdCA9IGZ1bmN0aW9uIChkYXRhLCBzdGFydCwgbGl0dGxlRW5kaWFuKSB7XG4gICAgcmV0dXJuIGRhdGEuZ2V0SW50MTYoc3RhcnQsIGxpdHRsZUVuZGlhbik7XG59O1xuXG5cblxubmlmdGkuVXRpbHMuZ2V0SW50QXQgPSBmdW5jdGlvbiAoZGF0YSwgc3RhcnQsIGxpdHRsZUVuZGlhbikge1xuICAgIHJldHVybiBkYXRhLmdldEludDMyKHN0YXJ0LCBsaXR0bGVFbmRpYW4pO1xufTtcblxuXG5cbm5pZnRpLlV0aWxzLmdldEZsb2F0QXQgPSBmdW5jdGlvbiAoZGF0YSwgc3RhcnQsIGxpdHRsZUVuZGlhbikge1xuICAgIHJldHVybiBkYXRhLmdldEZsb2F0MzIoc3RhcnQsIGxpdHRsZUVuZGlhbik7XG59O1xuXG5cblxubmlmdGkuVXRpbHMuZ2V0RG91YmxlQXQgPSBmdW5jdGlvbiAoZGF0YSwgc3RhcnQsIGxpdHRsZUVuZGlhbikge1xuICAgIHJldHVybiBkYXRhLmdldEZsb2F0NjQoc3RhcnQsIGxpdHRsZUVuZGlhbik7XG59O1xuXG5cblxubmlmdGkuVXRpbHMuZ2V0TG9uZ0F0ID0gZnVuY3Rpb24gKGRhdGEsIHN0YXJ0LCBsaXR0bGVFbmRpYW4pIHtcbiAgICB2YXIgY3RyLCBhcnJheSA9IFtdLCB2YWx1ZSA9IDA7XG5cbiAgICBmb3IgKGN0ciA9IDA7IGN0ciA8IDg7IGN0ciArPSAxKSB7XG4gICAgICAgIGFycmF5W2N0cl0gPSBuaWZ0aS5VdGlscy5nZXRCeXRlQXQoZGF0YSwgc3RhcnQgKyBjdHIsIGxpdHRsZUVuZGlhbik7XG4gICAgfVxuXG4gICAgZm9yIChjdHIgPSBhcnJheS5sZW5ndGggLSAxOyBjdHIgPj0gMDsgY3RyLS0pIHtcbiAgICAgICAgdmFsdWUgPSAodmFsdWUgKiAyNTYpICsgYXJyYXlbY3RyXTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWU7XG59O1xuXG5cblxubmlmdGkuVXRpbHMudG9BcnJheUJ1ZmZlciA9IGZ1bmN0aW9uIChidWZmZXIpIHtcbiAgICB2YXIgYWIsIHZpZXcsIGk7XG5cbiAgICBhYiA9IG5ldyBBcnJheUJ1ZmZlcihidWZmZXIubGVuZ3RoKTtcbiAgICB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkoYWIpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBidWZmZXIubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmlld1tpXSA9IGJ1ZmZlcltpXTtcbiAgICB9XG4gICAgcmV0dXJuIGFiO1xufTtcblxuXG5cbm5pZnRpLlV0aWxzLmlzU3RyaW5nID0gZnVuY3Rpb24gKG9iaikge1xuICAgIHJldHVybiAodHlwZW9mIG9iaiA9PT0gXCJzdHJpbmdcIiB8fCBvYmogaW5zdGFuY2VvZiBTdHJpbmcpO1xufTtcblxuXG5uaWZ0aS5VdGlscy5mb3JtYXROdW1iZXIgPSBmdW5jdGlvbiAobnVtLCBzaG9ydEZvcm1hdCkge1xuICAgIHZhciB2YWwgPSAwO1xuXG4gICAgaWYgKG5pZnRpLlV0aWxzLmlzU3RyaW5nKG51bSkpIHtcbiAgICAgICAgdmFsID0gTnVtYmVyKG51bSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFsID0gbnVtO1xuICAgIH1cblxuICAgIGlmIChzaG9ydEZvcm1hdCkge1xuICAgICAgICB2YWwgPSB2YWwudG9QcmVjaXNpb24oNSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFsID0gdmFsLnRvUHJlY2lzaW9uKDcpO1xuICAgIH1cblxuICAgIHJldHVybiBwYXJzZUZsb2F0KHZhbCk7XG59O1xuXG5cblxuLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xODYzODkwMC9qYXZhc2NyaXB0LWNyYzMyXG5uaWZ0aS5VdGlscy5tYWtlQ1JDVGFibGUgPSBmdW5jdGlvbigpe1xuICAgIHZhciBjO1xuICAgIHZhciBjcmNUYWJsZSA9IFtdO1xuICAgIGZvcih2YXIgbiA9MDsgbiA8IDI1NjsgbisrKXtcbiAgICAgICAgYyA9IG47XG4gICAgICAgIGZvcih2YXIgayA9MDsgayA8IDg7IGsrKyl7XG4gICAgICAgICAgICBjID0gKChjJjEpID8gKDB4RURCODgzMjAgXiAoYyA+Pj4gMSkpIDogKGMgPj4+IDEpKTtcbiAgICAgICAgfVxuICAgICAgICBjcmNUYWJsZVtuXSA9IGM7XG4gICAgfVxuICAgIHJldHVybiBjcmNUYWJsZTtcbn07XG5cblxuXG5uaWZ0aS5VdGlscy5jcmMzMiA9IGZ1bmN0aW9uKGRhdGFWaWV3KSB7XG4gICAgdmFyIGNyY1RhYmxlID0gbmlmdGkuVXRpbHMuY3JjVGFibGUgfHwgKG5pZnRpLlV0aWxzLmNyY1RhYmxlID0gbmlmdGkuVXRpbHMubWFrZUNSQ1RhYmxlKCkpO1xuICAgIHZhciBjcmMgPSAwIF4gKC0xKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YVZpZXcuYnl0ZUxlbmd0aDsgaSsrICkge1xuICAgICAgICBjcmMgPSAoY3JjID4+PiA4KSBeIGNyY1RhYmxlWyhjcmMgXiBkYXRhVmlldy5nZXRVaW50OChpKSkgJiAweEZGXTtcbiAgICB9XG5cbiAgICByZXR1cm4gKGNyYyBeICgtMSkpID4+PiAwO1xufTtcblxuXG5cbi8qKiogRXhwb3J0cyAqKiovXG5cbnZhciBtb2R1bGVUeXBlID0gdHlwZW9mIG1vZHVsZTtcbmlmICgobW9kdWxlVHlwZSAhPT0gJ3VuZGVmaW5lZCcpICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBuaWZ0aS5VdGlscztcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpO1xuXG52YXIgbGluZVNlcGFyYXRvclJFID0gL1sgXFxmXFx0XFx2XSpcXHI/XFxuLztcbnZhciBOUlJETWFnaWNSRSA9IC9eTlJSRFxcZHs0fSQvO1xudmFyIGxpbmVSRSA9IC9eKFteOl0qKSg6WyA9XSkoLiopJC87XG52YXIgZGF0YUZpbGVMaXN0UkUgPSAvXkxJU1QoPzogKFxcZCspKT8kLztcblxuLy8gVGhlIG1pbmltYWwgb2JqZWN0IHRoaXMgYWNjZXB0cyBpcyBmb3JtZWQgbGlrZSB0aGlzOlxuLy8gICB7ZGF0YTogU29tZVR5cGVkQXJyYXksIHNpemVzOiBbLi4uXX1cbi8vIE9uIHRoZSBvdGhlciBoYW5kLCBpZiBkYXRhIGlzIG5vdCBnaXZlbiBpdCBtdXN0IGhhdmUgYSBmb3JtIGxpa2UgdGhpczpcbi8vICAge2J1ZmZlcjogU29tZUFycmF5QnVmZmVyLCB0eXBlOiAuLi4sIGVuZGlhbjogLi4uLCBzaXplczogWy4uLl19XG4vLyBPZiBjb3Vyc2UsIGlmICd0eXBlJyBpcyBhbiA4LWJpdCB0eXBlLCBlbmRpYW4gaXMgbm90IG5lZWRlZCwgYW5kIGlmICd0eXBlJyBlcXVhbHMgJ2Jsb2NrJywgJ2Jsb2NrU2l6ZScgc2hvdWxkIGJlIHNldCBpbnN0ZWFkIG9mICdlbmRpYW4nLiBJbiB0aGlzIGNhc2UsIG5vIGludGVycHJldGF0aW9uIG9mIGJ1ZmZlciBpcyBkb25lIChhdCBhbGwsIGl0IGlzIHdyaXR0ZW4gc2VyaWFsaXplZCBkaXJlY3RseSB0byB0aGUgYnVmZmVyKS5cbi8vIFRPRE86IEZvciBub3cgdGhpcyBvbmx5IHN1cHBvcnRzIHNlcmlhbGl6aW5nIFwiaW5saW5lXCIgZmlsZXMsIG9yIGZpbGVzIGZvciB3aGljaCB5b3UgaGF2ZSBhbHJlYWR5IHByZXBhcmVkIHRoZSBkYXRhLlxubW9kdWxlLmV4cG9ydHMuc2VyaWFsaXplID0gZnVuY3Rpb24gKG5ycmRPcmcpIHtcbiAgICB2YXIgaSwgYnVmZmVyLCBhcnIsIHRvdGFsTGVuID0gMSwgbnJyZCA9IHt9LCBwcm9wLCBuYXRpdmVUeXBlLCBuYXRpdmVTaXplLCBidWZmZXJEYXRhLCBhcnJEYXRhLCBsaW5lLCBsaW5lcyA9IFtdLCBoZWFkZXI7XG4gICAgXG4gICAgLy8gQ29weSBucnJkT3JnIHRvIG5ycmQgdG8gYWxsb3cgbW9kaWZpY2F0aW9ucyB3aXRob3V0IGFsdGVyaW5nIHRoZSBvcmlnaW5hbFxuICAgIGZvcihwcm9wIGluIG5ycmRPcmcpIHtcbiAgICAgICAgbnJyZFtwcm9wXSA9IG5ycmRPcmdbcHJvcF07XG4gICAgfVxuICAgIFxuICAgIC8vIEZvciBzYXZpbmcgZmlsZXMgd2UgYWxsb3cgaW5mZXJyaW5nIGNlcnRhaW4gaW5mb3JtYXRpb24gaWYgaXQgaXMgbm90IGV4cGxpY2l0bHkgZ2l2ZW4uXG4gICAgLy8gQWxzbyB3ZSBub3JtYWxpemUgc29tZSBmaWVsZHMgdG8gbWFrZSBvdXIgb3duIGxpdmVzIGVhc2llci5cbiAgICBpZiAobnJyZC5zaXplcz09PXVuZGVmaW5lZCkgeyAvLyAnc2l6ZXMnIHNob3VsZCBBTFdBWVMgYmUgZ2l2ZW5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2l6ZXMgbWlzc2luZyBmcm9tIE5SUkQgZmlsZSFcIik7XG4gICAgfSBlbHNlIGlmIChucnJkLmRpbWVuc2lvbj09PXVuZGVmaW5lZCkge1xuICAgICAgICBucnJkLmRpbWVuc2lvbiA9IG5ycmQuc2l6ZXMubGVuZ3RoO1xuICAgIH1cbiAgICBpZiAobnJyZC5kYXRhIGluc3RhbmNlb2YgSW50OEFycmF5KSB7XG4gICAgICAgIG5hdGl2ZVR5cGUgPSBcImludDhcIjtcbiAgICB9IGVsc2UgaWYgKG5ycmQuZGF0YSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgbmF0aXZlVHlwZSA9IFwidWludDhcIjtcbiAgICB9IGVsc2UgaWYgKG5ycmQuZGF0YSBpbnN0YW5jZW9mIEludDE2QXJyYXkpIHtcbiAgICAgICAgbmF0aXZlVHlwZSA9IFwiaW50MTZcIjtcbiAgICB9IGVsc2UgaWYgKG5ycmQuZGF0YSBpbnN0YW5jZW9mIFVpbnQxNkFycmF5KSB7XG4gICAgICAgIG5hdGl2ZVR5cGUgPSBcInVpbnQxNlwiO1xuICAgIH0gZWxzZSBpZiAobnJyZC5kYXRhIGluc3RhbmNlb2YgSW50MzJBcnJheSkge1xuICAgICAgICBuYXRpdmVUeXBlID0gXCJpbnQzMlwiO1xuICAgIH0gZWxzZSBpZiAobnJyZC5kYXRhIGluc3RhbmNlb2YgVWludDMyQXJyYXkpIHtcbiAgICAgICAgbmF0aXZlVHlwZSA9IFwidWludDMyXCI7XG4gICAgLy99IGVsc2UgaWYgKG5ycmQuZGF0YSBpbnN0YW5jZW9mIEludDY0QXJyYXkpIHtcbiAgICAvLyAgICBuYXRpdmVUeXBlID0gXCJpbnQ2NFwiO1xuICAgIC8vfSBlbHNlIGlmIChucnJkLmRhdGEgaW5zdGFuY2VvZiBVaW50NjRBcnJheSkge1xuICAgIC8vICAgIG5hdGl2ZVR5cGUgPSBcInVpbnQ2NFwiO1xuICAgIH0gZWxzZSBpZiAobnJyZC5kYXRhIGluc3RhbmNlb2YgRmxvYXQzMkFycmF5KSB7XG4gICAgICAgIG5hdGl2ZVR5cGUgPSBcImZsb2F0XCI7XG4gICAgfSBlbHNlIGlmIChucnJkLmRhdGEgaW5zdGFuY2VvZiBGbG9hdDY0QXJyYXkpIHtcbiAgICAgICAgbmF0aXZlVHlwZSA9IFwiZG91YmxlXCI7XG4gICAgfVxuICAgIGlmIChucnJkLnR5cGU9PT11bmRlZmluZWQgJiYgbmF0aXZlVHlwZSE9PXVuZGVmaW5lZCkge1xuICAgICAgICBucnJkLnR5cGUgPSBuYXRpdmVUeXBlO1xuICAgIH0gZWxzZSBpZiAobnJyZC50eXBlPT09dW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlR5cGUgb2YgZGF0YSBpcyBub3QgZ2l2ZW4gYW5kIGNhbm5vdCBiZSBpbmZlcnJlZCFcIik7XG4gICAgfSBlbHNlIGlmICgodHlwZW9mIG5ycmQudHlwZSkgPT0gXCJzdHJpbmdcIiB8fCBucnJkLnR5cGUgaW5zdGFuY2VvZiBTdHJpbmcpIHtcbiAgICAgICAgbnJyZC50eXBlID0gcGFyc2VOUlJEVHlwZShucnJkLnR5cGUpO1xuICAgIH1cbiAgICBpZiAobnJyZC5lbmNvZGluZz09PXVuZGVmaW5lZCkge1xuICAgICAgICBucnJkLmVuY29kaW5nID0gXCJyYXdcIjtcbiAgICB9IGVsc2UgaWYgKCh0eXBlb2YgbnJyZC5lbmNvZGluZykgPT0gXCJzdHJpbmdcIiB8fCBucnJkLmVuY29kaW5nIGluc3RhbmNlb2YgU3RyaW5nKSB7XG4gICAgICAgIG5ycmQuZW5jb2RpbmcgPSBwYXJzZU5SUkRFbmNvZGluZyhucnJkLmVuY29kaW5nKTtcbiAgICB9XG4gICAgaWYgKG5ycmQuZGF0YSAmJiBucnJkLnR5cGUgIT0gJ2Jsb2NrJyAmJiBucnJkLnR5cGUgIT0gJ2ludDgnICYmIG5ycmQudHlwZSAhPSAndWludDgnICYmIG5ycmQuZW5jb2RpbmcgIT0gJ2FzY2lpJykge1xuICAgICAgICBucnJkLmVuZGlhbiA9IHN5c3RlbUVuZGlhbm5lc3M7XG4gICAgfSBlbHNlIGlmIChucnJkLnR5cGUgPT0gJ2Jsb2NrJyB8fCBucnJkLnR5cGUgPT0gJ2ludDgnIHx8IG5ycmQudHlwZSA9PSAndWludDgnIHx8IG5ycmQuZW5jb2RpbmcgPT0gJ2FzY2lpJykge1xuICAgICAgICBucnJkLmVuZGlhbiA9IHVuZGVmaW5lZDtcbiAgICB9IGVsc2UgaWYgKCh0eXBlb2YgbnJyZC5lbmRpYW4pID09IFwic3RyaW5nXCIgfHwgbnJyZC5lbmRpYW4gaW5zdGFuY2VvZiBTdHJpbmcpIHtcbiAgICAgICAgbnJyZC5lbmRpYW4gPSBwYXJzZU5SUkRFbmRpYW4obnJyZC5lbmRpYW4pO1xuICAgIH1cbiAgICBcbiAgICAvLyBUcnkgdG8gaW5mZXIgc3BhdGlhbCBkaW1lbnNpb25cbiAgICB2YXIgc3BhY2VEaW1lbnNpb24gPSB1bmRlZmluZWQ7XG4gICAgaWYgKG5ycmQuc3BhY2VEaW1lbnNpb24hPT11bmRlZmluZWQpIHtcbiAgICAgICAgc3BhY2VEaW1lbnNpb24gPSBucnJkLnNwYWNlRGltZW5zaW9uO1xuICAgIH0gZWxzZSBpZiAobnJyZC5zcGFjZSE9PXVuZGVmaW5lZCkge1xuICAgICAgICBzd2l0Y2gobnJyZC5zcGFjZSkge1xuICAgICAgICBjYXNlIFwicmlnaHQtYW50ZXJpb3Itc3VwZXJpb3JcIjpcbiAgICAgICAgY2FzZSBcIlJBU1wiOlxuICAgICAgICAgICAgc3BhY2VEaW1lbnNpb24gPSAzO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJsZWZ0LWFudGVyaW9yLXN1cGVyaW9yXCI6XG4gICAgICAgIGNhc2UgXCJMQVNcIjpcbiAgICAgICAgICAgIHNwYWNlRGltZW5zaW9uID0gMztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwibGVmdC1wb3N0ZXJpb3Itc3VwZXJpb3JcIjpcbiAgICAgICAgY2FzZSBcIkxQU1wiOlxuICAgICAgICAgICAgc3BhY2VEaW1lbnNpb24gPSAzO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgIFx0ICBjYXNlIFwicmlnaHQtYW50ZXJpb3Itc3VwZXJpb3ItdGltZVwiOlxuICAgICBcdCAgY2FzZSBcIlJBU1RcIjpcbiAgICAgXHQgICAgICBzcGFjZURpbWVuc2lvbiA9IDQ7XG4gICAgIFx0ICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJsZWZ0LWFudGVyaW9yLXN1cGVyaW9yLXRpbWVcIjpcbiAgICAgICAgY2FzZSBcIkxBU1RcIjpcbiAgICAgICAgICAgIHNwYWNlRGltZW5zaW9uID0gNDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwibGVmdC1wb3N0ZXJpb3Itc3VwZXJpb3ItdGltZVwiOlxuICAgICAgICBjYXNlIFwiTFBTVFwiOlxuICAgICAgICAgICAgc3BhY2VEaW1lbnNpb24gPSA0O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJzY2FubmVyLXh5elwiOlxuICAgICAgICAgICAgc3BhY2VEaW1lbnNpb24gPSAzO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJzY2FubmVyLXh5ei10aW1lXCI6XG4gICAgICAgICAgICBzcGFjZURpbWVuc2lvbiA9IDQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIjNELXJpZ2h0LWhhbmRlZFwiOlxuICAgICAgICAgICAgc3BhY2VEaW1lbnNpb24gPSAzO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCIzRC1sZWZ0LWhhbmRlZFwiOlxuICAgICAgICAgICAgc3BhY2VEaW1lbnNpb24gPSAzO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCIzRC1yaWdodC1oYW5kZWQtdGltZVwiOlxuICAgICAgICAgICAgc3BhY2VEaW1lbnNpb24gPSA0O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCIzRC1sZWZ0LWhhbmRlZC10aW1lXCI6XG4gICAgICAgICAgICBzcGFjZURpbWVuc2lvbiA9IDQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlVucmVjb2duaXplZCBzcGFjZTogXCIgKyBucnJkLnNwYWNlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBcbiAgICAvLyBOb3cgY2hlY2sgdGhhdCB3ZSBoYXZlIGEgdmFsaWQgbnJyZCBzdHJ1Y3R1cmUuXG4gICAgY2hlY2tOUlJEKG5ycmQpO1xuXG4gICAgLy8gRGV0ZXJtaW5lIG51bWJlciBvZiBlbGVtZW50cyBhbmQgY2hlY2sgdGhhdCB3ZSBoYXZlIGVub3VnaCBkYXRhIChpZiBwb3NzaWJsZSlcbiAgICBmb3IoaT0wOyBpPG5ycmQuc2l6ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKG5ycmQuc2l6ZXNbaV08PTApIHRocm93IG5ldyBFcnJvcihcIlNpemVzIHNob3VsZCBiZSBhIGxpc3Qgb2YgcG9zaXRpdmUgKD4wKSBpbnRlZ2VycyFcIik7XG4gICAgICAgIHRvdGFsTGVuICo9IG5ycmQuc2l6ZXNbaV07XG4gICAgfVxuICAgIGlmIChucnJkLmRhdGEpIHtcbiAgICAgICAgaWYgKG5ycmQuZGF0YS5sZW5ndGggPCB0b3RhbExlbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyBkYXRhIHRvIHNlcmlhbGl6ZSFcIik7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG5ycmQuYnVmZmVyKSB7XG4gICAgICAgIGlmIChucnJkLmVuY29kaW5nID09IFwicmF3XCIpIHtcbiAgICAgICAgICAgIGlmIChucnJkLnR5cGU9PVwiYmxvY2tcIiAmJiBucnJkLmJsb2NrU2l6ZSE9PXVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIG5hdGl2ZVNpemUgPSBucnJkLmJsb2NrU2l6ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbmF0aXZlU2l6ZSA9IGdldE5SUkRUeXBlU2l6ZShucnJkLnR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5ycmQuYnVmZmVyLmJ5dGVMZW5ndGggPCB0b3RhbExlbipuYXRpdmVTaXplKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyBkYXRhIHRvIHNlcmlhbGl6ZSFcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG5ycmQuZGF0YUZpbGUpIHtcbiAgICAgICAgLy8gT2theSwgaWYgeW91IGhhdmUgeW91ciBkYXRhIHJlYWR5LCB3ZSdsbCBqdXN0IHdyaXRlIGEgaGVhZGVyLlxuICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIldpbGwgbm90IHNlcmlhbGl6ZSBhbiBlbXB0eSBOUlJEIGZpbGUhXCIpO1xuICAgIH1cbiAgICBcbiAgICAvLyBNYWtlIHN1cmUgd2UgaGF2ZSB0aGUgY29ycmVjdCBidWZmZXIgaW4gYnVmZmVyRGF0YS5cbiAgICBpZiAobnJyZC5kYXRhKSB7XG4gICAgICAgIHN3aXRjaChucnJkLmVuY29kaW5nKSB7XG4gICAgICAgIGNhc2UgJ3Jhdyc6XG4gICAgICAgICAgICBpZiAobnJyZC50eXBlID09IG5hdGl2ZVR5cGUgJiYgbnJyZC5lbmRpYW4gPT0gc3lzdGVtRW5kaWFubmVzcykge1xuICAgICAgICAgICAgICAgIGJ1ZmZlckRhdGEgPSBucnJkLmRhdGEuYnVmZmVyLnNsaWNlKG5ycmQuZGF0YS5ieXRlT2Zmc2V0LCBucnJkLmRhdGEuYnl0ZU9mZnNldCtucnJkLmRhdGEuYnl0ZUxlbmd0aCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG5ycmQuZW5kaWFuID09IHN5c3RlbUVuZGlhbm5lc3MpIHtcbiAgICAgICAgICAgICAgICBidWZmZXJEYXRhID0gY2FzdFR5cGVkQXJyYXkobnJyZC5kYXRhLCBucnJkLnR5cGUpO1xuICAgICAgICAgICAgICAgIGJ1ZmZlckRhdGEgPSBidWZmZXJEYXRhLmJ1ZmZlci5zbGljZShidWZmZXJEYXRhLmJ5dGVPZmZzZXQsIGJ1ZmZlckRhdGEuYnl0ZU9mZnNldCtidWZmZXJEYXRhLmJ5dGVMZW5ndGgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBidWZmZXJEYXRhID0gc2VyaWFsaXplVG9CdWZmZXIobnJyZC5kYXRhLCBucnJkLnR5cGUsIG5ycmQuZW5kaWFuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgICAgICBpZiAobnJyZC50eXBlID09IG5hdGl2ZVR5cGUpIHtcbiAgICAgICAgICAgICAgICBidWZmZXJEYXRhID0gc2VyaWFsaXplVG9UZXh0QnVmZmVyKG5ycmQuZGF0YSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGJ1ZmZlckRhdGEgPSBzZXJpYWxpemVUb1RleHRCdWZmZXIoY2FzdFR5cGVkQXJyYXkobnJyZC5kYXRhLCBucnJkLnR5cGUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5zdXBwb3J0ZWQgTlJSRCBlbmNvZGluZzogXCIgKyBucnJkLmVuY29kaW5nKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAobnJyZC5idWZmZXIpIHtcbiAgICAgICAgYnVmZmVyRGF0YSA9IG5ycmQuYnVmZmVyO1xuICAgIH1cbiAgICBcbiAgICAvLyBTdGFydCBoZWFkZXJcbiAgICBsaW5lcy5wdXNoKFwiTlJSRDAwMDVcIik7IC8vIFRPRE86IEFkanVzdCB2ZXJzaW9uIGJhc2VkIG9uIGZlYXR1cmVzIHRoYXQgYXJlIGFjdHVhbGx5IHVzZWQgYW5kL29yIHRoZSB2ZXJzaW9uIHNwZWNpZmllZCBieSB0aGUgdXNlciAoaWYgYW55KS5cbiAgICBsaW5lcy5wdXNoKFwiIyBHZW5lcmF0ZWQgYnkgbnJyZC1qc1wiKTtcbiAgICBcbiAgICAvLyBQdXQgaW4gZGltZW5zaW9uIGFuZCBzcGFjZSBkaW1lbnNpb24gKHRoZSBOUlJEIHNwZWMgcmVxdWlyZXMgdGhhdCB0aGVzZSBhcmUgcHJlc2VudCBiZWZvcmUgYW55IGxpc3RzIHdob3NlIGxlbmd0aCBkZXBlbmRzIG9uIHRoZW0pXG4gICAgdmFyIGZpcnN0UHJvcHMgPSBbJ2RpbWVuc2lvbicsICdzcGFjZURpbWVuc2lvbicsICdzcGFjZSddO1xuICAgIGZvcihpPTA7IGk8Zmlyc3RQcm9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBwcm9wID0gZmlyc3RQcm9wc1tpXTtcbiAgICAgICAgaWYgKG5ycmRbcHJvcF0gPT09IHVuZGVmaW5lZCkgY29udGludWU7IC8vIFNraXAgdGhpbmdzIHdlIGV4cGxpY2l0bHkgc2V0IHRvIHVuZGVmaW5lZC5cbiAgICAgICAgbGluZSA9IHNlcmlhbGl6ZUZpZWxkKHByb3AsIG5ycmRbcHJvcF0sIG5ycmQuZGltZW5zaW9uLCBzcGFjZURpbWVuc2lvbik7XG4gICAgICAgIGlmIChsaW5lIT09dW5kZWZpbmVkKSBsaW5lcy5wdXNoKGxpbmUpO1xuICAgIH1cbiAgICBcbiAgICAvLyBQdXQgaW4gZmllbGQgc3BlY2lmaWNhdGlvbnNcbiAgICBmb3IocHJvcCBpbiBucnJkKSB7XG4gICAgICAgIGlmIChucnJkW3Byb3BdID09PSB1bmRlZmluZWQpIGNvbnRpbnVlOyAvLyBTa2lwIHRoaW5ncyB3ZSBleHBsaWNpdGx5IHNldCB0byB1bmRlZmluZWQuXG4gICAgICAgIGlmIChmaXJzdFByb3BzLmluZGV4T2YocHJvcCk+PTApIGNvbnRpbnVlOyAvLyBTa2lwIHRoZSBmaWVsZHMgd2UgYWxyZWFkeSBvdXRwdXQuXG4gICAgICAgIGxpbmUgPSBzZXJpYWxpemVGaWVsZChwcm9wLCBucnJkW3Byb3BdLCBucnJkLmRpbWVuc2lvbiwgc3BhY2VEaW1lbnNpb24pO1xuICAgICAgICBpZiAobGluZSE9PXVuZGVmaW5lZCkgbGluZXMucHVzaChsaW5lKTtcbiAgICB9XG4gICAgXG4gICAgLy8gUHV0IGluIGtleXMgKGlmIGFueSlcbiAgICBpZiAobnJyZC5rZXlzKSBmb3IocHJvcCBpbiBucnJkLmtleXMpIHtcbiAgICAgICAgaWYgKHByb3AuaW5kZXhPZihcIjo9XCIpPj0wKSB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgY29tYmluYXRpb24gJzo9JyBpcyBub3QgYWxsb3dlZCBpbiBhbiBOUlJEIGtleSFcIik7XG4gICAgICAgIGxpbmVzLnB1c2gocHJvcCArIFwiOj1cIiArIGVzY2FwZVZhbHVlKG5ycmRbcHJvcF0pKTtcbiAgICB9XG4gICAgXG4gICAgLy8gUHV0IGluIGRhdGEgZmlsZSBsaXN0IChpZiBhbnkpXG4gICAgaWYgKG5ycmQuZGF0YUZpbGUgJiYgbnJyZC5kYXRhRmlsZS5sZW5ndGgpIHtcbiAgICAgICAgbGluZXMucHVzaChcImRhdGEgZmlsZTogTElTVFwiKTtcbiAgICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkobGluZXMsIG5ycmQuZGF0YUZpbGUpO1xuICAgIH0gZWxzZSBpZiAobnJyZC5kYXRhRmlsZSAmJiBucnJkLmRhdGFGaWxlLmZpbGVzICYmICdzdWJkaW0nIGluIG5ycmQuZGF0YUZpbGUpIHtcbiAgICAgICAgbGluZXMucHVzaChcImRhdGEgZmlsZTogTElTVCBcIiArIG5ycmQuZGF0YUZpbGUuc3ViZGltKTtcbiAgICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkobGluZXMsIG5ycmQuZGF0YUZpbGUuZmlsZXMpO1xuICAgIH1cbiAgICBcbiAgICAvLyBQdXQgaW4gZW1wdHkgbGluZSBhbmQgaW5saW5lIGRhdGEgKGlmIHdlIGhhdmUgaW5saW5lIGRhdGEpIGFuZCBjb252ZXJ0IGxpbmVzIHRvIGJ1ZmZlclxuICAgIGlmIChidWZmZXJEYXRhICYmICEoJ2RhdGFGaWxlJyBpbiBucnJkKSkge1xuICAgICAgICBsaW5lcy5wdXNoKFwiXCIpO1xuICAgICAgICBsaW5lcy5wdXNoKFwiXCIpOyAvLyBXZSBhY3R1YWxseSBuZWVkIGFuIGV4dHJhIGJsYW5rIGxpbmUgdG8gbWFrZSBzdXJlIHRoZSBwcmV2aW91cyBpcyB0ZXJtaW5hdGVkLlxuICAgICAgICBoZWFkZXIgPSBsaW5lcy5qb2luKFwiXFxuXCIpO1xuICAgICAgICBidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoaGVhZGVyLmxlbmd0aCArIGJ1ZmZlckRhdGEuYnl0ZUxlbmd0aCk7XG4gICAgICAgIGFyciA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlcik7XG4gICAgICAgIGZvcihpPTA7IGk8aGVhZGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcnJbaV0gPSBoZWFkZXIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgfVxuICAgICAgICBhcnJEYXRhID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyRGF0YSk7XG4gICAgICAgIGFyci5zZXQoYXJyRGF0YSwgaGVhZGVyLmxlbmd0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgbGluZXMucHVzaChcIlwiKTsgLy8gQmxhbmsgbGluZSB0byBhdCBsZWFzdCB0ZXJtaW5hdGUgdGhlIGxhc3QgbGluZS5cbiAgICAgICAgaGVhZGVyID0gbGluZXMuam9pbihcIlxcblwiKTtcbiAgICAgICAgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKGhlYWRlci5sZW5ndGgpO1xuICAgICAgICBhcnIgPSBuZXcgVWludDhBcnJheShidWZmZXIpO1xuICAgICAgICBmb3IoaT0wOyBpPGhlYWRlci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJyW2ldID0gaGVhZGVyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIGJ1ZmZlcjtcbn07XG5cbi8vIFRoaXMgZXhwZWN0cyBhbiBBcnJheUJ1ZmZlci5cbm1vZHVsZS5leHBvcnRzLnBhcnNlID0gZnVuY3Rpb24gKGJ1ZmZlcikge1xuICAgIHZhciBpLCBoZWFkZXIsIGRhdGFTdGFydCwgcmV0ID0ge2RhdGE6IHVuZGVmaW5lZC8qIHBhcnNlZCBkYXRhICovLCBidWZmZXI6IHVuZGVmaW5lZC8qIHJhdyBidWZmZXIgaG9sZGluZyBkYXRhICovLCBrZXlzOiB7fSwgdmVyc2lvbjogdW5kZWZpbmVkfSxcbiAgICAgICAgbGluZXMsIG1hdGNoLCBtYXRjaDIsXG4gICAgICAgIGJ1ZjggPSBuZXcgVWludDhBcnJheShidWZmZXIpO1xuXG4gICAgLy8gQSB3b3JrLWFyb3VuZCBmb3IgaW5jb21wYXRpYmlsaXRpZXMgYmV0d2VlbiBOb2RlJ3MgQnVmZmVyIGFuZCBBcnJheUJ1ZmZlci5cbiAgICBpZiAoYnVmOC5idWZmZXIgIT09IGJ1ZmZlcikgYnVmZmVyID0gYnVmOC5idWZmZXI7XG5cbiAgICAvLyBGaXJzdCBmaW5kIHRoZSBzZXBhcmF0aW9uIGJldHdlZW4gdGhlIGhlYWRlciBhbmQgdGhlIGRhdGEgKGlmIHRoZXJlIGlzIG9uZSlcbiAgICAvLyBOb3RlIHRoYXQgd2UgbmVlZCB0byBkZWFsIHdpdGggd2l0aCBMRiBhbmQgQ1JMRiBhcyBwb3NzaWJsZSBsaW5lIGVuZGluZ3MuXG4gICAgLy8gTHVja2lseSB0aGlzIG1lYW5zIHRoZSBsaW5lIGFsd2F5cyBlbmRzIHdpdGggTEYsIHNvIHdlIG9ubHkgbmVlZCB0byBjb25zaWRlclxuICAgIC8vIExGTEYgYW5kIExGQ1JMRiBhcyBwYXR0ZXJucyBmb3IgdGhlIHNlcGFyYXRpbmcgZW1wdHkgbGluZS5cbiAgICBpPTI7IC8vIEl0IGlzIHNhZmUgdG8gc3RhcnQgYXQgcG9zaXRpb24gMiAoaW4gZmFjdCwgd2UgY291bGQgc3RhcnQgZXZlbiBsYXRlciksIGFzIHRoZSBmaWxlIEhBUyB0byBzdGFydCB3aXRoIGEgbWFnaWMgd29yZC5cbiAgICB3aGlsZShpPGJ1ZjgubGVuZ3RoKSB7XG4gICAgICAgIGlmIChidWY4W2ldID09IDEwKSB7IC8vIFdlIGhpdCBhbiBMRlxuICAgICAgICAgICAgaWYgKGJ1ZjhbaS0xXSA9PSAxMCB8fCAoYnVmOFtpLTFdID09IDEzICYmIGJ1ZjhbaS0yXSA9PSAxMCkpIHsgLy8gU2FmZSBiZWNhdXNlIHdlIHN0YXJ0IGF0IHBvc2l0aW9uIDIgYW5kIG5ldmVyIG1vdmUgYmFja3dhcmRzXG4gICAgICAgICAgICAgICAgZGF0YVN0YXJ0ID0gaSsxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpKys7IC8vIE1vdmUgZm9yd2FyZCBqdXN0IG9uY2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChidWY4W2ldID09IDEzKSB7IC8vIFdlIGhpdCBhIENSXG4gICAgICAgICAgICBpKys7IC8vIE1vdmUgZm9yd2FyZCBqdXN0IG9uY2VcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGkgKz0gMjsgLy8gTW92ZSBmb3J3YXJkIHR3byBwbGFjZXMsIFxuICAgICAgICB9XG4gICAgfVxuICAgIFxuICAgIC8vIE5vdyBzcGxpdCB1cCB0aGUgaGVhZGVyIGFuZCBkYXRhXG4gICAgaWYgKGRhdGFTdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGhlYWRlciA9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgYnVmOCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaGVhZGVyID0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBidWY4LnN1YmFycmF5KDAsZGF0YVN0YXJ0KSk7XG4gICAgICAgIHJldC5idWZmZXIgPSBidWZmZXIuc2xpY2UoZGF0YVN0YXJ0KTtcbiAgICB9XG4gICAgXG4gICAgLy8gU3BsaXQgaGVhZGVyIGludG8gbGluZXMsIHJlbW92ZSBjb21tZW50cyAoYW5kIGJsYW5rIGxpbmVzKSBhbmQgY2hlY2sgbWFnaWMuXG4gICAgLy8gQWxsIHJlbWFpbmluZyBsaW5lcyBleGNlcHQgdGhlIGZpcnN0IHNob3VsZCBiZSBmaWVsZCBzcGVjaWZpY2F0aW9ucyBvciBrZXkvdmFsdWUgcGFpcnMuXG4gICAgLy8gVE9ETzogVGhpcyBleHBsaWNpdGx5IHJlbW92ZXMgYW55IHdoaXRlc3BhY2UgYXQgdGhlIGVuZCBvZiBsaW5lcywgaG93ZXZlciwgSSBhbSBub3Qgc3VyZSB0aGF0IHRoaXMgaXMgYWN0dWFsbHkgZGVzaXJlZCBiZWhhdmlvdXIgZm9yIGFsbCBraW5kcyBvZiBsaW5lcy5cbiAgICBsaW5lcyA9IGhlYWRlci5zcGxpdChsaW5lU2VwYXJhdG9yUkUpO1xuICAgIGxpbmVzID0gbGluZXMuZmlsdGVyKGZ1bmN0aW9uIChsKSB7IHJldHVybiBsLmxlbmd0aD4wICYmIGxbMF0gIT0gJyMnOyB9KTsgLy8gUmVtb3ZlIGNvbW1lbnQgbGluZXNcbiAgICBpZiAoIU5SUkRNYWdpY1JFLnRlc3QobGluZXNbMF0pKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZpbGUgaXMgbm90IGFuIE5SUkQgZmlsZSFcIik7XG4gICAgfVxuICAgIHJldC52ZXJzaW9uID0gcGFyc2VJbnQobGluZXNbMF0uc3Vic3RyaW5nKDQsIDgpLCAxMCk7XG4gICAgaWYgKHJldC52ZXJzaW9uPjUpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiUmVhZGluZyBhbiB1bnN1cHBvcnRlZCB2ZXJzaW9uIG9mIHRoZSBOUlJEIGZvcm1hdDsgdGhpbmdzIG1heSBnbyBoYXl3aXJlLlwiKTtcbiAgICB9XG5cbiAgICAvLyBQYXJzZSBsaW5lc1xuICAgIGZvcihpPTE7IGk8bGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbWF0Y2ggPSBsaW5lUkUuZXhlYyhsaW5lc1tpXSk7XG4gICAgICAgIGlmICghbWF0Y2gpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlVucmVjb2duaXplZCBsaW5lIGluIE5SUkQgaGVhZGVyOiBcIiArIGxpbmVzW2ldKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXRjaFsyXSA9PSAnOiAnKSB7IC8vIEZpZWxkIHNwZWNpZmljYXRpb25cbiAgICAgICAgICAgIG1hdGNoWzFdID0gbWFwTlJSRFRvSmF2YXNjcmlwdChtYXRjaFsxXSk7XG4gICAgICAgICAgICBpZiAoIG1hdGNoWzFdID09ICdkYXRhRmlsZScgJiZcbiAgICAgICAgICAgICAgICAgKG1hdGNoMiA9IGRhdGFGaWxlTGlzdFJFLmV4ZWMobWF0Y2hbM10pKSkge1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgc2hvdWxkIGJlIHRoZSBsYXN0IGZpZWxkIHNwZWNpZmljYXRpb24sXG4gICAgICAgICAgICAgICAgLy8gYW5kIHRoZSByZXN0IG9mIHRoZSBsaW5lcyBzaG91bGQgY29udGFpbiBmaWxlIG5hbWVzLlxuICAgICAgICAgICAgICAgIGlmIChtYXRjaDIubGVuZ3RoID09IDIgJiYgbWF0Y2gyWzFdKSB7IC8vIHN1YmRpbSBzcGVjaWZpY2F0aW9uXG4gICAgICAgICAgICAgICAgICAgIHJldFttYXRjaFsxXV0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxlczogbGluZXMuc2xpY2UoaSsxKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1YmRpbTogcGFyc2VOUlJESW50ZWdlcihtYXRjaDJbMV0pXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0W21hdGNoWzFdXSA9IGxpbmVzLnNsaWNlKGkrMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxpbmVzLmxlbmd0aCA9IGk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldFttYXRjaFsxXV0gPSBwYXJzZUZpZWxkKG1hdGNoWzFdLCBtYXRjaFszXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAobWF0Y2hbMl0gPT0gJzo9JykgeyAvLyBLZXkvdmFsdWUgcGFpclxuICAgICAgICAgICAgcmV0LmtleXNbbWF0Y2hbMV1dID0gdW5lc2NhcGVWYWx1ZShtYXRjaFszXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJMb2dpYyBlcnJvciBpbiBOUlJEIHBhcnNlci5cIik7IC8vIFRoaXMgc2hvdWxkIG5ldmVyIGhhcHBlbiAodW5sZXNzIHRoZSBOUlJEIHN5bnRheCBpcyBleHRlbmRlZCBhbmQgdGhlIHJlZ2V4cCBpcyB1cGRhdGVkLCBidXQgdGhpcyBzZWN0aW9uIGlzIG5vdCwgb3Igc29tZSBvdGhlciBwcm9ncmFtbWVyIGVycm9yKS5cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIE1ha2Ugc3VyZSB0aGUgZmlsZSBzYXRpc2ZpZXMgdGhlIHJlcXVpcmVtZW50cyBvZiB0aGUgTlJSRCBmb3JtYXRcbiAgICBjaGVja05SUkQocmV0KTtcbiAgICBcbiAgICAvLyBcIlBhcnNlXCIgZGF0YVxuICAgIGlmICgnZGF0YUZpbGUnIGluIHJldCkge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJObyBzdXBwb3J0IGZvciBleHRlcm5hbCBkYXRhIHlldCFcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgc3dpdGNoKHJldC5lbmNvZGluZykge1xuICAgICAgICBjYXNlICdyYXcnOlxuICAgICAgICAgICAgcmV0LmRhdGEgPSBwYXJzZU5SUkRSYXdEYXRhKHJldC5idWZmZXIsIHJldC50eXBlLCByZXQuc2l6ZXMsIHtcbiAgICAgICAgICAgICAgICBlbmRpYW46IHJldC5lbmRpYW4sIGJsb2NrU2l6ZTogcmV0LmJsb2NrU2l6ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICAgICAgcmV0LmRhdGEgPSBwYXJzZU5SUkRUZXh0RGF0YShyZXQuYnVmZmVyLCByZXQudHlwZSwgcmV0LnNpemVzKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiVW5zdXBwb3J0ZWQgTlJSRCBlbmNvZGluZzogXCIgKyByZXQuZW5jb2RpbmcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIFxuICAgIHJldHVybiByZXQ7XG59O1xuXG5mdW5jdGlvbiBlc2NhcGVWYWx1ZSh2YWwpIHtcbiAgICByZXR1cm4gdmFsLnJlcGxhY2UoJ1xcXFwnLCAnXFxcXFxcXFwnKS5yZXBsYWNlKCdcXG4nLCAnXFxcXG4nKTtcbn1cblxuZnVuY3Rpb24gdW5lc2NhcGVWYWx1ZSh2YWwpIHtcbiAgICByZXR1cm4gdmFsLnNwbGl0KCdcXFxcXFxcXCcpLm1hcChcbiAgICAgICAgZnVuY3Rpb24ocykgeyByZXR1cm4gcy5yZXBsYWNlKCdcXFxcbicsICdcXG4nKTsgfVxuICAgICAgICApLmpvaW4oJ1xcXFwnKTtcbn1cblxuLy8gU2VyaWFsaXplcyBOUlJEIGZpZWxkc1xuZnVuY3Rpb24gc2VyaWFsaXplRmllbGQocHJvcCwgdmFsdWUsIGRpbWVuc2lvbiwgc3BhY2VEaW1lbnNpb24pIHtcbiAgICB2YXIgbGluZTtcbiAgICB2YXIgcHJvcE5SUkQgPSBtYXBKYXZhc2NyaXB0VG9OUlJEKHByb3ApO1xuICAgIHN3aXRjaChwcm9wKSB7XG4gICAgLy8gbnJyZC1qcyBzdHVmZjogc2tpcFxuICAgIGNhc2UgJ2RhdGEnOlxuICAgIGNhc2UgJ2J1ZmZlcic6XG4gICAgY2FzZSAna2V5cyc6XG4gICAgY2FzZSAndmVyc2lvbic6XG4gICAgICAgIGJyZWFrO1xuICAgIC8vIExpdGVyYWwgKHVuaW50ZXJwcmV0ZWQpIGZpZWxkc1xuICAgIGNhc2UgJ2NvbnRlbnQnOlxuICAgIGNhc2UgJ251bWJlcic6XG4gICAgY2FzZSAnc2FtcGxlVW5pdHMnOlxuICAgIGNhc2UgJ3NwYWNlJzpcbiAgICAgICAgbGluZSA9IHByb3BOUlJEICsgXCI6IFwiICsgdmFsdWU7XG4gICAgICAgIGJyZWFrO1xuICAgIC8vIEludGVnZXJzIChubyBpbmZpbml0eSBvciB3aGF0ZXZlciwganVzdCBhIHBsYWluIGludGVnZXIsIHNvIHRoZSBkZWZhdWx0IHNlcmlhbGl6YXRpb24gaXMgZ29vZCBlbm91Z2gpXG4gICAgY2FzZSAnYmxvY2tTaXplJzpcbiAgICBjYXNlICdsaW5lU2tpcCc6XG4gICAgY2FzZSAnYnl0ZVNraXAnOlxuICAgIGNhc2UgJ2RpbWVuc2lvbic6XG4gICAgY2FzZSAnc3BhY2VEaW1lbnNpb24nOlxuICAgICAgICBhc3NlcnQoKHR5cGVvZiB2YWx1ZSkgPT0gXCJudW1iZXJcIiB8fCB2YWx1ZSBpbnN0YW5jZW9mIE51bWJlciwgXCJGaWVsZCBcIiArIHByb3AgKyBcIiBzaG91bGQgYXQgbGVhc3QgY29udGFpbiBhIG51bWJlciFcIik7XG4gICAgICAgIGxpbmUgPSBwcm9wTlJSRCArIFwiOiBcIiArIHZhbHVlO1xuICAgICAgICBicmVhaztcbiAgICAvLyBGbG9hdHMgKGRlZmF1bHQgc2VyaWFsaXphdGlvbiBpcyBnb29kIGVub3VnaCwgYXMgTmFOIGNvbnRhaW5zIG5hbiwgaWdub3JpbmcgY2FzZSwgYW5kIHNpbWlsYXJseSBmb3IgSW5maW5pdHkgaW5mKVxuICAgIGNhc2UgJ21pbic6XG4gICAgY2FzZSAnbWF4JzpcbiAgICBjYXNlICdvbGRNaW4nOlxuICAgIGNhc2UgJ29sZE1heCc6XG4gICAgICAgIGFzc2VydCgodHlwZW9mIHZhbHVlKSA9PSBcIm51bWJlclwiIHx8IHZhbHVlIGluc3RhbmNlb2YgTnVtYmVyLCBcIkZpZWxkIFwiICsgcHJvcCArIFwiIHNob3VsZCBjb250YWluIGEgbnVtYmVyIVwiKTtcbiAgICAgICAgbGluZSA9IHByb3BOUlJEICsgXCI6IFwiICsgdmFsdWU7XG4gICAgICAgIGJyZWFrO1xuICAgIC8vIFZlY3RvcnNcbiAgICBjYXNlICdzcGFjZU9yaWdpbic6XG4gICAgICAgIGFzc2VydCh2YWx1ZS5sZW5ndGggPT09IHNwYWNlRGltZW5zaW9uLCBcIkZpZWxkIFwiICsgcHJvcCArIFwiIHNob3VsZCBiZSBhIGxpc3Qgd2l0aCBsZW5ndGggZXF1YWwgdG8gdGhlIHNwYWNlIGRpbWVuc2lvbiFcIik7XG4gICAgICAgIHZhbHVlLmZvckVhY2goZnVuY3Rpb24gKHZhbCkgeyBhc3NlcnQoKHR5cGVvZiB2YWwpID09IFwibnVtYmVyXCIgfHwgdmFsIGluc3RhbmNlb2YgTnVtYmVyLCBcIkZpZWxkIFwiICsgcHJvcCArIFwiIHNob3VsZCBiZSBhIGxpc3Qgb2YgbnVtYmVycyFcIik7IH0pO1xuICAgICAgICBsaW5lID0gcHJvcE5SUkQgKyBcIjogKFwiICsgdmFsdWUuam9pbihcIixcIikgKyBcIilcIjtcbiAgICAgICAgYnJlYWs7XG4gICAgLy8gTGlzdHMgb2Ygc3RyaW5nc1xuICAgIGNhc2UgJ2xhYmVscyc6XG4gICAgY2FzZSAndW5pdHMnOlxuICAgIGNhc2UgJ3NwYWNlVW5pdHMnOlxuICAgICAgICBhc3NlcnQodmFsdWUubGVuZ3RoICE9PSB1bmRlZmluZWQgJiYgdmFsdWUubGVuZ3RoID09IGRpbWVuc2lvbiwgXCJGaWVsZCBcIiArIHByb3AgKyBcIiBzaG91bGQgYmUgYSBsaXN0IHdpdGggbGVuZ3RoIGVxdWFsIHRvIHRoZSBkaW1lbnNpb24hXCIpO1xuICAgICAgICB2YWx1ZS5mb3JFYWNoKGZ1bmN0aW9uICh2YWwpIHsgYXNzZXJ0KCh0eXBlb2YgdmFsKSA9PSBcInN0cmluZ1wiIHx8IHZhbCBpbnN0YW5jZW9mIFN0cmluZywgXCJGaWVsZCBcIiArIHByb3AgKyBcIiBzaG91bGQgYmUgYSBsaXN0IG9mIG51bWJlcnMhXCIpOyB9KTtcbiAgICAgICAgbGluZSA9IHByb3BOUlJEICsgXCI6IFwiICsgdmFsdWUubWFwKHNlcmlhbGl6ZU5SUkRRdW90ZWRTdHJpbmcpLmpvaW4oXCIgXCIpO1xuICAgICAgICBicmVhaztcbiAgICAvLyBMaXN0cyBvZiBpbnRlZ2Vyc1xuICAgIGNhc2UgJ3NpemVzJzpcbiAgICAgICAgYXNzZXJ0KHZhbHVlLmxlbmd0aCAhPT0gdW5kZWZpbmVkICYmIHZhbHVlLmxlbmd0aCA9PSBkaW1lbnNpb24sIFwiRmllbGQgXCIgKyBwcm9wICsgXCIgc2hvdWxkIGJlIGEgbGlzdCB3aXRoIGxlbmd0aCBlcXVhbCB0byB0aGUgZGltZW5zaW9uIVwiKTtcbiAgICAgICAgdmFsdWUuZm9yRWFjaChmdW5jdGlvbiAodmFsKSB7IGFzc2VydCgodHlwZW9mIHZhbCkgPT0gXCJudW1iZXJcIiB8fCB2YWwgaW5zdGFuY2VvZiBOdW1iZXIsIFwiRmllbGQgXCIgKyBwcm9wICsgXCIgc2hvdWxkIGJlIGEgbGlzdCBvZiBudW1iZXJzIVwiKTsgfSk7XG4gICAgICAgIGxpbmUgPSBwcm9wTlJSRCArIFwiOiBcIiArIHZhbHVlLmpvaW4oXCIgXCIpO1xuICAgICAgICBicmVhaztcbiAgICAvLyBMaXN0cyBvZiBmbG9hdHNcbiAgICBjYXNlICdzcGFjaW5ncyc6XG4gICAgY2FzZSAndGhpY2tuZXNzZXMnOlxuICAgIGNhc2UgJ2F4aXNNaW5zJzpcbiAgICBjYXNlICdheGlzTWF4cyc6XG4gICAgICAgIGFzc2VydCh2YWx1ZS5sZW5ndGggIT09IHVuZGVmaW5lZCAmJiB2YWx1ZS5sZW5ndGggPT0gZGltZW5zaW9uLCBcIkZpZWxkIFwiICsgcHJvcCArIFwiIHNob3VsZCBiZSBhIGxpc3Qgd2l0aCBsZW5ndGggZXF1YWwgdG8gdGhlIGRpbWVuc2lvbiFcIik7XG4gICAgICAgIHZhbHVlLmZvckVhY2goZnVuY3Rpb24gKHZhbCkgeyBhc3NlcnQoKHR5cGVvZiB2YWwpID09IFwibnVtYmVyXCIgfHwgdmFsIGluc3RhbmNlb2YgTnVtYmVyLCBcIkZpZWxkIFwiICsgcHJvcCArIFwiIHNob3VsZCBiZSBhIGxpc3Qgb2YgbnVtYmVycyFcIik7IH0pO1xuICAgICAgICBsaW5lID0gcHJvcE5SUkQgKyBcIjogXCIgKyB2YWx1ZS5qb2luKFwiIFwiKTtcbiAgICAgICAgYnJlYWs7XG4gICAgLy8gTGlzdHMgb2YgdmVjdG9ycyAoZGltZW5zaW9uIHNpemVkKVxuICAgIGNhc2UgJ3NwYWNlRGlyZWN0aW9ucyc6XG4gICAgICAgIGFzc2VydCh2YWx1ZS5sZW5ndGggIT09IHVuZGVmaW5lZCAmJiB2YWx1ZS5sZW5ndGggPT09IGRpbWVuc2lvbiwgXCJGaWVsZCBcIiArIHByb3AgKyBcIiBzaG91bGQgYmUgYSBsaXN0IHdpdGggbGVuZ3RoIGVxdWFsIHRvIHRoZSBkaW1lbnNpb24hXCIpO1xuICAgICAgICB2YWx1ZS5mb3JFYWNoKGZ1bmN0aW9uICh2ZWMpIHtcbiAgICAgICAgICBhc3NlcnQodmVjID09PSBudWxsIHx8ICh2ZWMubGVuZ3RoICE9PSB1bmRlZmluZWQgJiYgdmVjLmxlbmd0aCA9PT0gc3BhY2VEaW1lbnNpb24pLCBcIlRoZSBlbGVtZW50cyBvZiBmaWVsZCBcIiArIHByb3AgKyBcIiBzaG91bGQgYmUgbGlzdHMgd2l0aCBsZW5ndGggZXF1YWwgdG8gdGhlIHNwYWNlIGRpbWVuc2lvbiFcIik7XG4gICAgICAgICAgaWYgKHZlYyAhPT0gbnVsbCkgdmVjLmZvckVhY2goZnVuY3Rpb24gKHZhbCkgeyBhc3NlcnQoKHR5cGVvZiB2YWwpID09IFwibnVtYmVyXCIgfHwgdmFsIGluc3RhbmNlb2YgTnVtYmVyLCBcIlRoZSBlbGVtZW50cyBvZiBmaWVsZCBcIiArIHByb3AgKyBcIiBzaG91bGQgYmUgbGlzdHMgb2YgbnVtYmVycyFcIik7IH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgbGluZSA9IHByb3BOUlJEICsgXCI6IFwiICsgdmFsdWUubWFwKGZ1bmN0aW9uKHZlYykgeyByZXR1cm4gdmVjID09PSBudWxsID8gXCJub25lXCIgOiAoXCIoXCIgKyB2ZWMuam9pbihcIixcIikgKyBcIilcIik7IH0pLmpvaW4oXCIgXCIpO1xuICAgICAgICBicmVhaztcbiAgICAvLyBMaXN0cyBvZiB2ZWN0b3JzIChzcGFjZSBkaW1lbnNpb24gc2l6ZWQpXG4gICAgY2FzZSAnbWVhc3VyZW1lbnRGcmFtZSc6XG4gICAgICAgIGFzc2VydCh2YWx1ZS5sZW5ndGggIT09IHVuZGVmaW5lZCAmJiB2YWx1ZS5sZW5ndGggPT09IHNwYWNlRGltZW5zaW9uLCBcIkZpZWxkIFwiICsgcHJvcCArIFwiIHNob3VsZCBiZSBhIGxpc3Qgd2l0aCBsZW5ndGggZXF1YWwgdG8gdGhlIHNwYWNlIGRpbWVuc2lvbiFcIik7XG4gICAgICAgIHZhbHVlLmZvckVhY2goZnVuY3Rpb24gKHZlYykge1xuICAgICAgICAgIGFzc2VydCh2ZWMgPT09IG51bGwgfHwgKHZlYy5sZW5ndGggIT09IHVuZGVmaW5lZCAmJiB2ZWMubGVuZ3RoID09PSBzcGFjZURpbWVuc2lvbiksIFwiVGhlIGVsZW1lbnRzIG9mIGZpZWxkIFwiICsgcHJvcCArIFwiIHNob3VsZCBiZSBsaXN0cyB3aXRoIGxlbmd0aCBlcXVhbCB0byB0aGUgc3BhY2UgZGltZW5zaW9uIVwiKTtcbiAgICAgICAgICBpZiAodmVjICE9PSBudWxsKSB2ZWMuZm9yRWFjaChmdW5jdGlvbiAodmFsKSB7IGFzc2VydCgodHlwZW9mIHZhbCkgPT0gXCJudW1iZXJcIiB8fCB2YWwgaW5zdGFuY2VvZiBOdW1iZXIsIFwiVGhlIGVsZW1lbnRzIG9mIGZpZWxkIFwiICsgcHJvcCArIFwiIHNob3VsZCBiZSBsaXN0cyBvZiBudW1iZXJzIVwiKTsgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBsaW5lID0gcHJvcE5SUkQgKyBcIjogXCIgKyB2YWx1ZS5tYXAoZnVuY3Rpb24odmVjKSB7IHJldHVybiB2ZWMgPT09IG51bGwgPyBcIm5vbmVcIiA6IChcIihcIiArIHZlYy5qb2luKFwiLFwiKSArIFwiKVwiKTsgfSkuam9pbihcIiBcIik7XG4gICAgICAgIGJyZWFrO1xuICAgIC8vIE9uZS1vZi1hLWtpbmQgZmllbGRzXG4gICAgY2FzZSAndHlwZSc6XG4gICAgICAgIGFzc2VydCgodHlwZW9mIHZhbHVlKSA9PSBcInN0cmluZ1wiIHx8IHZhbHVlIGluc3RhbmNlb2YgU3RyaW5nLCBcIkZpZWxkIFwiICsgcHJvcCArIFwiIHNob3VsZCBjb250YWluIGEgc3RyaW5nIVwiKTtcbiAgICAgICAgbGluZSA9IHByb3BOUlJEICsgXCI6IFwiICsgdmFsdWU7XG4gICAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2VuY29kaW5nJzpcbiAgICAgICAgYXNzZXJ0KCh0eXBlb2YgdmFsdWUpID09IFwic3RyaW5nXCIgfHwgdmFsdWUgaW5zdGFuY2VvZiBTdHJpbmcsIFwiRmllbGQgXCIgKyBwcm9wICsgXCIgc2hvdWxkIGNvbnRhaW4gYSBzdHJpbmchXCIpO1xuICAgICAgICBsaW5lID0gcHJvcE5SUkQgKyBcIjogXCIgKyB2YWx1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgY2FzZSAnZW5kaWFuJzpcbiAgICAgICAgYXNzZXJ0KCh0eXBlb2YgdmFsdWUpID09IFwic3RyaW5nXCIgfHwgdmFsdWUgaW5zdGFuY2VvZiBTdHJpbmcsIFwiRmllbGQgXCIgKyBwcm9wICsgXCIgc2hvdWxkIGNvbnRhaW4gYSBzdHJpbmchXCIpO1xuICAgICAgICBsaW5lID0gcHJvcE5SUkQgKyBcIjogXCIgKyB2YWx1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgY2FzZSAnZGF0YUZpbGUnOlxuICAgICAgICBpZiAodmFsdWUubGVuZ3RoIHx8ICh2YWx1ZS5maWxlcyAmJiAnc3ViZGltJyBpbiB2YWx1ZSkpIHtcbiAgICAgICAgICAgIC8vIExpc3Qgb2YgZGF0YSBmaWxlczogc2tpcCBmb3Igbm93XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsaW5lID0gcHJvcE5SUkQgKyBcIjogXCIgKyBzZXJpYWxpemVOUlJERGF0YUZpbGUodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2NlbnRlcnMnOlxuICAgICAgICBhc3NlcnQodmFsdWUubGVuZ3RoICE9PSB1bmRlZmluZWQgJiYgdmFsdWUubGVuZ3RoID09IGRpbWVuc2lvbiwgXCJGaWVsZCBcIiArIHByb3AgKyBcIiBzaG91bGQgYmUgYSBsaXN0IHdpdGggbGVuZ3RoIGVxdWFsIHRvIHRoZSBkaW1lbnNpb24hXCIpO1xuICAgICAgICBsaW5lID0gcHJvcE5SUkQgKyBcIjogXCIgKyB2YWx1ZS5tYXAoc2VyaWFsaXplTlJSRE9wdGlvbmFsKS5qb2luKFwiIFwiKTtcbiAgICAgICAgYnJlYWs7XG4gICAgY2FzZSAna2luZHMnOlxuICAgICAgICBhc3NlcnQodmFsdWUubGVuZ3RoICE9PSB1bmRlZmluZWQgJiYgdmFsdWUubGVuZ3RoID09IGRpbWVuc2lvbiwgXCJGaWVsZCBcIiArIHByb3AgKyBcIiBzaG91bGQgYmUgYSBsaXN0IHdpdGggbGVuZ3RoIGVxdWFsIHRvIHRoZSBkaW1lbnNpb24hXCIpO1xuICAgICAgICBsaW5lID0gcHJvcE5SUkQgKyBcIjogXCIgKyB2YWx1ZS5tYXAoc2VyaWFsaXplTlJSRE9wdGlvbmFsKS5qb2luKFwiIFwiKTtcbiAgICAgICAgYnJlYWs7XG4gICAgLy8gU29tZXRoaW5nIHVua25vd25cbiAgICBkZWZhdWx0OlxuICAgICAgICBjb25zb2xlLndhcm4oXCJVbnJlY29nbml6ZWQgTlJSRCBmaWVsZDogXCIgKyBwcm9wICsgXCIsIHNraXBwaW5nLlwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGxpbmU7XG59XG5cbi8vIFBhcnNlcyBhbmQgbm9ybWFsaXplcyBOUlJEIGZpZWxkcywgYXNzdW1lcyB0aGUgZmllbGQgbmFtZXMgYXJlIGFscmVhZHkgbG93ZXIgY2FzZS5cbmZ1bmN0aW9uIHBhcnNlRmllbGQoaWRlbnRpZmllciwgZGVzY3JpcHRvcikge1xuICAgIHN3aXRjaChpZGVudGlmaWVyKSB7XG4gICAgLy8gTGl0ZXJhbCAodW5pbnRlcnByZXRlZCkgZmllbGRzXG4gICAgY2FzZSAnY29udGVudCc6XG4gICAgY2FzZSAnbnVtYmVyJzpcbiAgICBjYXNlICdzYW1wbGVVbml0cyc6XG4gICAgICAgIGJyZWFrO1xuICAgIC8vIEludGVnZXJzXG4gICAgY2FzZSAnZGltZW5zaW9uJzpcbiAgICBjYXNlICdibG9ja1NpemUnOlxuICAgIGNhc2UgJ2xpbmVTa2lwJzpcbiAgICBjYXNlICdieXRlU2tpcCc6XG4gICAgY2FzZSAnc3BhY2VEaW1lbnNpb24nOlxuICAgICAgICBkZXNjcmlwdG9yID0gcGFyc2VOUlJESW50ZWdlcihkZXNjcmlwdG9yKTtcbiAgICAgICAgYnJlYWs7XG4gICAgLy8gRmxvYXRzXG4gICAgY2FzZSAnbWluJzpcbiAgICBjYXNlICdtYXgnOlxuICAgIGNhc2UgJ29sZE1pbic6XG4gICAgY2FzZSAnb2xkTWF4JzpcbiAgICAgICAgZGVzY3JpcHRvciA9IHBhcnNlTlJSREZsb2F0KGRlc2NyaXB0b3IpO1xuICAgICAgICBicmVhaztcbiAgICAvLyBWZWN0b3JzXG4gICAgY2FzZSAnc3BhY2VPcmlnaW4nOlxuICAgICAgICBkZXNjcmlwdG9yID0gcGFyc2VOUlJEVmVjdG9yKGRlc2NyaXB0b3IpO1xuICAgICAgICBicmVhaztcbiAgICAvLyBMaXN0cyBvZiBzdHJpbmdzXG4gICAgY2FzZSAnbGFiZWxzJzpcbiAgICBjYXNlICd1bml0cyc6XG4gICAgY2FzZSAnc3BhY2VVbml0cyc6XG4gICAgICAgIGRlc2NyaXB0b3IgPSBwYXJzZU5SUkRXaGl0ZXNwYWNlU2VwYXJhdGVkTGlzdChkZXNjcmlwdG9yLCBwYXJzZU5SUkRRdW90ZWRTdHJpbmcpO1xuICAgICAgICBicmVhaztcbiAgICAvLyBMaXN0cyBvZiBpbnRlZ2Vyc1xuICAgIGNhc2UgJ3NpemVzJzpcbiAgICAgICAgZGVzY3JpcHRvciA9IHBhcnNlTlJSRFdoaXRlc3BhY2VTZXBhcmF0ZWRMaXN0KGRlc2NyaXB0b3IsIHBhcnNlTlJSREludGVnZXIpO1xuICAgICAgICBicmVhaztcbiAgICAvLyBMaXN0cyBvZiBmbG9hdHNcbiAgICBjYXNlICdzcGFjaW5ncyc6XG4gICAgY2FzZSAndGhpY2tuZXNzZXMnOlxuICAgIGNhc2UgJ2F4aXNNaW5zJzpcbiAgICBjYXNlICdheGlzTWF4cyc6XG4gICAgICAgIGRlc2NyaXB0b3IgPSBwYXJzZU5SUkRXaGl0ZXNwYWNlU2VwYXJhdGVkTGlzdChkZXNjcmlwdG9yLCBwYXJzZU5SUkRGbG9hdCk7XG4gICAgICAgIGJyZWFrO1xuICAgIC8vIExpc3RzIG9mIHZlY3RvcnNcbiAgICBjYXNlICdzcGFjZURpcmVjdGlvbnMnOlxuICAgIGNhc2UgJ21lYXN1cmVtZW50RnJhbWUnOlxuICAgICAgICBkZXNjcmlwdG9yID0gcGFyc2VOUlJEV2hpdGVzcGFjZVNlcGFyYXRlZExpc3QoZGVzY3JpcHRvciwgcGFyc2VOUlJEVmVjdG9yKTtcbiAgICAgICAgYnJlYWs7XG4gICAgLy8gT25lLW9mLWEta2luZCBmaWVsZHNcbiAgICBjYXNlICd0eXBlJzpcbiAgICAgICAgZGVzY3JpcHRvciA9IHBhcnNlTlJSRFR5cGUoZGVzY3JpcHRvcik7XG4gICAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2VuY29kaW5nJzpcbiAgICAgICAgZGVzY3JpcHRvciA9IHBhcnNlTlJSREVuY29kaW5nKGRlc2NyaXB0b3IpO1xuICAgICAgICBicmVhaztcbiAgICBjYXNlICdlbmRpYW4nOlxuICAgICAgICBkZXNjcmlwdG9yID0gcGFyc2VOUlJERW5kaWFuKGRlc2NyaXB0b3IpO1xuICAgICAgICBicmVhaztcbiAgICBjYXNlICdkYXRhRmlsZSc6XG4gICAgICAgIGRlc2NyaXB0b3IgPSBwYXJzZU5SUkREYXRhRmlsZShkZXNjcmlwdG9yKTtcbiAgICAgICAgYnJlYWs7XG4gICAgY2FzZSAnY2VudGVycyc6XG4gICAgICAgIGRlc2NyaXB0b3IgPSBwYXJzZU5SUkRXaGl0ZXNwYWNlU2VwYXJhdGVkTGlzdChkZXNjcmlwdG9yLCBwYXJzZU5SUkRDZW50ZXIpO1xuICAgICAgICBicmVhaztcbiAgICBjYXNlICdraW5kcyc6XG4gICAgICAgIGRlc2NyaXB0b3IgPSBwYXJzZU5SUkRXaGl0ZXNwYWNlU2VwYXJhdGVkTGlzdChkZXNjcmlwdG9yLCBwYXJzZU5SUkRLaW5kKTtcbiAgICAgICAgYnJlYWs7XG4gICAgY2FzZSAnc3BhY2UnOlxuICAgICAgICBkZXNjcmlwdG9yID0gcGFyc2VOUlJEU3BhY2UoZGVzY3JpcHRvcik7XG4gICAgICAgIGJyZWFrO1xuICAgIC8vIFNvbWV0aGluZyB1bmtub3duXG4gICAgZGVmYXVsdDpcbiAgICAgICAgY29uc29sZS53YXJuKFwiVW5yZWNvZ25pemVkIE5SUkQgZmllbGQ6IFwiICsgaWRlbnRpZmllcik7XG4gICAgfVxuICAgIHJldHVybiBkZXNjcmlwdG9yO1xufVxuXG4vLyBUaGlzIG9ubHkgaW5jbHVkZXMgbmFtZXMgd2hvc2UgbG93ZXIgY2FzZSBmb3JtIGlzIGRpZmZlcmVudCBmcm9tIHRoZSBKYXZhc2NyaXB0IGZvcm0uXG52YXIgbWFwTlJSRFRvSmF2YXNjcmlwdFN0YXRpYyA9IHtcbiAgICAnYmxvY2sgc2l6ZSc6ICdibG9ja1NpemUnLFxuICAgICdibG9ja3NpemUnOiAnYmxvY2tTaXplJyxcbiAgICAnb2xkIG1pbic6ICdvbGRNaW4nLFxuICAgICdvbGRtaW4nOiAnb2xkTWluJyxcbiAgICAnb2xkIG1heCc6ICdvbGRNYXgnLFxuICAgICdvbGRtYXgnOiAnb2xkTWF4JyxcbiAgICAnZGF0YSBmaWxlJzogJ2RhdGFGaWxlJyxcbiAgICAnZGF0YWZpbGUnOiAnZGF0YUZpbGUnLFxuICAgICdsaW5lIHNraXAnOiAnbGluZVNraXAnLFxuICAgICdsaW5lc2tpcCc6ICdsaW5lU2tpcCcsXG4gICAgJ2J5dGUgc2tpcCc6ICdieXRlU2tpcCcsXG4gICAgJ2J5dGVza2lwJzogJ2J5dGVTa2lwJyxcbiAgICAnc2FtcGxlIHVuaXRzJzogJ3NhbXBsZVVuaXRzJyxcbiAgICAnc2FtcGxldW5pdHMnOiAnc2FtcGxlVW5pdHMnLFxuICAgICdheGlzIG1pbnMnOiAnYXhpc01pbnMnLFxuICAgICdheGlzIG1heHMnOiAnYXhpc01heHMnLFxuICAgICdjZW50ZXJzJzogJ2NlbnRlcnMnLCAvLyBOb3QgZGlmZmVyZW50LCBqdXN0IGluY2x1ZGVkIHNvIGl0IGlzIGNsZWFyIHdoeSBjZW50ZXJpbmdzIG1hcHMgdG8gY2VudGVyc1xuICAgICdjZW50ZXJpbmdzJzogJ2NlbnRlcnMnLFxuICAgICdzcGFjZSBkaW1lbnNpb24nOiAnc3BhY2VEaW1lbnNpb24nLFxuICAgICdzcGFjZSB1bml0cyc6ICdzcGFjZVVuaXRzJyxcbiAgICAnc3BhY2Ugb3JpZ2luJzogJ3NwYWNlT3JpZ2luJyxcbiAgICAnc3BhY2UgZGlyZWN0aW9ucyc6ICdzcGFjZURpcmVjdGlvbnMnLFxuICAgICdtZWFzdXJlbWVudCBmcmFtZSc6ICdtZWFzdXJlbWVudEZyYW1lJ1xufTtcbnZhciBtYXBKYXZhc2NyaXB0VG9OUlJEU3RhdGljID0gZnVuY3Rpb24oKSB7XG4gIHZhciBpZCwgbSA9IHt9O1xuICBmb3IoaWQgaW4gbWFwTlJSRFRvSmF2YXNjcmlwdFN0YXRpYykge1xuICAgIG1bbWFwTlJSRFRvSmF2YXNjcmlwdFN0YXRpY1tpZF1dID0gaWQ7XG4gIH1cbiAgcmV0dXJuIG07XG59KCk7XG5mdW5jdGlvbiBtYXBOUlJEVG9KYXZhc2NyaXB0KGlkKSB7XG4gICAgLy8gSW4gYW55IGNhc2UsIHVzZSB0aGUgbG93ZXIgY2FzZSB2ZXJzaW9uIG9mIHRoZSBpZFxuICAgIGlkID0gaWQudG9Mb3dlckNhc2UoKTtcbiAgICAvLyBGaWx0ZXIgb3V0IGFueSBmaWVsZHMgZm9yIHdoaWNoIHdlIGhhdmUgYW4gZXhwbGljaXQgSmF2YXNjcmlwdCBuYW1lXG4gICAgaWYgKGlkIGluIG1hcE5SUkRUb0phdmFzY3JpcHRTdGF0aWMpIHJldHVybiBtYXBOUlJEVG9KYXZhc2NyaXB0U3RhdGljW2lkXTtcbiAgICAvLyBPdGhlcndpc2UsIGp1c3QgcmV0dXJuIHRoZSAobG93ZXIgY2FzZSkgaWRcbiAgICByZXR1cm4gaWQ7XG59XG5mdW5jdGlvbiBtYXBKYXZhc2NyaXB0VG9OUlJEKGlkKSB7XG4gICAgLy8gRmlsdGVyIG91dCBhbnkgZmllbGRzIGZvciB3aGljaCB3ZSBoYXZlIGFuIGV4cGxpY2l0IE5SUkQgbmFtZVxuICAgIGlmIChpZCBpbiBtYXBKYXZhc2NyaXB0VG9OUlJEU3RhdGljKSByZXR1cm4gbWFwSmF2YXNjcmlwdFRvTlJSRFN0YXRpY1tpZF07XG4gICAgLy8gT3RoZXJ3aXNlLCBqdXN0IHJldHVybiB0aGUgaWRcbiAgICByZXR1cm4gaWQ7XG59XG5cbmZ1bmN0aW9uIHBhcnNlTlJSREludGVnZXIoc3RyKSB7XG4gICAgdmFyIHZhbCA9IHBhcnNlSW50KHN0ciwgMTApO1xuICAgIGlmIChOdW1iZXIuaXNOYU4odmFsKSkgdGhyb3cgbmV3IEVycm9yKFwiTWFsZm9ybWVkIE5SUkQgaW50ZWdlcjogXCIgKyBzdHIpO1xuICAgIHJldHVybiB2YWw7XG59XG5cbmZ1bmN0aW9uIHBhcnNlTlJSREZsb2F0KHN0cikge1xuICAgIHN0ciA9IHN0ci50b0xvd2VyQ2FzZSgpO1xuICAgIGlmIChzdHIuaW5kZXhPZignbmFuJyk+PTApIHJldHVybiBOYU47XG4gICAgaWYgKHN0ci5pbmRleE9mKCctaW5mJyk+PTApIHJldHVybiAtSW5maW5pdHk7XG4gICAgaWYgKHN0ci5pbmRleE9mKCdpbmYnKT49MCkgcmV0dXJuIEluZmluaXR5O1xuICAgIHZhciB2YWwgPSBwYXJzZUZsb2F0KHN0cik7XG4gICAgaWYgKE51bWJlci5pc05hTih2YWwpKSB0aHJvdyBuZXcgRXJyb3IoXCJNYWxmb3JtZWQgTlJSRCBmbG9hdDogXCIgKyBzdHIpO1xuICAgIHJldHVybiB2YWw7XG59XG5cbmZ1bmN0aW9uIHBhcnNlTlJSRFZlY3RvcihzdHIpIHtcbiAgICBpZiAoc3RyID09IFwibm9uZVwiKSByZXR1cm4gbnVsbDtcbiAgICBpZiAoc3RyLmxlbmd0aDwyIHx8IHN0clswXSE9PVwiKFwiIHx8IHN0cltzdHIubGVuZ3RoLTFdIT09XCIpXCIpIHRocm93IG5ldyBFcnJvcihcIk1hbGZvcm1lZCBOUlJEIHZlY3RvcjogXCIgKyBzdHIpO1xuICAgIHJldHVybiBzdHIuc2xpY2UoMSwgLTEpLnNwbGl0KFwiLFwiKS5tYXAocGFyc2VOUlJERmxvYXQpO1xufVxuXG5mdW5jdGlvbiBwYXJzZU5SUkRRdW90ZWRTdHJpbmcoc3RyKSB7XG4gICAgaWYgKGxlbmd0aDwyIHx8IHN0clswXSE9J1wiJyB8fCBzdHJbc3RyLmxlbmd0aC0xXSE9J1wiJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIE5SUkQgcXVvdGVkIHN0cmluZzogXCIgKyBzdHIpO1xuICAgIH1cbiAgICByZXR1cm4gc3RyLnNsaWNlKDEsIC0xKS5yZXBsYWNlKCdcXFxcXCInLCAnXCInKTtcbn1cblxuZnVuY3Rpb24gc2VyaWFsaXplTlJSRFF1b3RlZFN0cmluZyhzdHIpIHtcbiAgICByZXR1cm4gJ1wiJyArIHN0ci5yZXBsYWNlKCdcIicsICdcXFxcXCInKSArICdcIic7XG59XG5cbnZhciB3aGl0ZXNwYWNlTGlzdFNlcGFyYXRvciA9IC9bIFxcdF0rLzsgLy8gTm90ZSB0aGF0IHRoaXMgZXhjbHVkZXMgb3RoZXIgdHlwZXMgb2Ygd2hpdGVzcGFjZSBvbiBwdXJwb3NlIVxuZnVuY3Rpb24gcGFyc2VOUlJEV2hpdGVzcGFjZVNlcGFyYXRlZExpc3Qoc3RyLCBwYXJzZUVsZW1lbnQpIHtcbiAgICByZXR1cm4gc3RyLnNwbGl0KHdoaXRlc3BhY2VMaXN0U2VwYXJhdG9yKS5tYXAocGFyc2VFbGVtZW50KTtcbn1cblxuZnVuY3Rpb24gcGFyc2VOUlJEVHlwZShkZXNjcmlwdG9yKSB7XG4gICAgc3dpdGNoKGRlc2NyaXB0b3IudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgXCJzaWduZWQgY2hhclwiOlxuICAgIGNhc2UgXCJpbnQ4XCI6XG4gICAgY2FzZSBcImludDhfdFwiOlxuICAgICAgICByZXR1cm4gJ2ludDgnO1xuICAgIGNhc2UgXCJ1Y2hhclwiOlxuICAgIGNhc2UgXCJ1bnNpZ25lZCBjaGFyXCI6XG4gICAgY2FzZSBcInVpbnQ4XCI6XG4gICAgY2FzZSBcInVpbnQ4X3RcIjpcbiAgICAgICAgcmV0dXJuICd1aW50OCc7XG4gICAgY2FzZSBcInNob3J0XCI6XG4gICAgY2FzZSBcInNob3J0IGludFwiOlxuICAgIGNhc2UgXCJzaWduZWQgc2hvcnRcIjpcbiAgICBjYXNlIFwic2lnbmVkIHNob3J0IGludFwiOlxuICAgIGNhc2UgXCJpbnQxNlwiOlxuICAgIGNhc2UgXCJpbnQxNl90XCI6XG4gICAgICAgIHJldHVybiAnaW50MTYnO1xuICAgIGNhc2UgXCJ1c2hvcnRcIjpcbiAgICBjYXNlIFwidW5zaWduZWQgc2hvcnRcIjpcbiAgICBjYXNlIFwidW5zaWduZWQgc2hvcnQgaW50XCI6XG4gICAgY2FzZSBcInVpbnQxNlwiOlxuICAgIGNhc2UgXCJ1aW50MTZfdFwiOlxuICAgICAgICByZXR1cm4gJ3VpbnQxNic7XG4gICAgY2FzZSBcImludFwiOlxuICAgIGNhc2UgXCJzaWduZWQgaW50XCI6XG4gICAgY2FzZSBcImludDMyXCI6XG4gICAgY2FzZSBcImludDMyX3RcIjpcbiAgICAgICAgcmV0dXJuICdpbnQzMic7XG4gICAgY2FzZSBcInVpbnRcIjpcbiAgICBjYXNlIFwidW5zaWduZWQgaW50XCI6XG4gICAgY2FzZSBcInVpbnQzMlwiOlxuICAgIGNhc2UgXCJ1aW50MzJfdFwiOlxuICAgICAgICByZXR1cm4gJ3VpbnQzMic7XG4gICAgY2FzZSBcImxvbmdsb25nXCI6XG4gICAgY2FzZSBcImxvbmcgbG9uZ1wiOlxuICAgIGNhc2UgXCJsb25nIGxvbmcgaW50XCI6XG4gICAgY2FzZSBcInNpZ25lZCBsb25nIGxvbmdcIjpcbiAgICBjYXNlIFwic2lnbmVkIGxvbmcgbG9uZyBpbnRcIjpcbiAgICBjYXNlIFwiaW50NjRcIjpcbiAgICBjYXNlIFwiaW50NjRfdFwiOlxuICAgICAgICByZXR1cm4gJ2ludDY0JztcbiAgICBjYXNlIFwidWxvbmdsb25nXCI6XG4gICAgY2FzZSBcInVuc2lnbmVkIGxvbmcgbG9uZ1wiOlxuICAgIGNhc2UgXCJ1bnNpZ25lZCBsb25nIGxvbmcgaW50XCI6XG4gICAgY2FzZSBcInVpbnQ2NFwiOlxuICAgIGNhc2UgXCJ1aW50NjRfdFwiOlxuICAgICAgICByZXR1cm4gJ3VpbnQ2NCc7XG4gICAgY2FzZSBcImZsb2F0XCI6XG4gICAgICAgIHJldHVybiAnZmxvYXQnO1xuICAgIGNhc2UgXCJkb3VibGVcIjpcbiAgICAgICAgcmV0dXJuICdkb3VibGUnO1xuICAgIGNhc2UgXCJibG9ja1wiOlxuICAgICAgICByZXR1cm4gJ2Jsb2NrJztcbiAgICBkZWZhdWx0OlxuICAgICAgICBjb25zb2xlLndhcm4oXCJVbnJlY29nbml6ZWQgTlJSRCB0eXBlOiBcIiArIGRlc2NyaXB0b3IpO1xuICAgICAgICByZXR1cm4gZGVzY3JpcHRvcjtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHBhcnNlTlJSREVuY29kaW5nKGVuY29kaW5nKSB7XG4gICAgc3dpdGNoKGVuY29kaW5nLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlIFwicmF3XCI6XG4gICAgICAgIHJldHVybiBcInJhd1wiO1xuICAgIGNhc2UgXCJ0eHRcIjpcbiAgICBjYXNlIFwidGV4dFwiOlxuICAgIGNhc2UgXCJhc2NpaVwiOlxuICAgICAgICByZXR1cm4gXCJhc2NpaVwiO1xuICAgIGNhc2UgXCJoZXhcIjpcbiAgICAgICAgcmV0dXJuIFwiaGV4XCI7XG4gICAgY2FzZSBcImd6XCI6XG4gICAgY2FzZSBcImd6aXBcIjpcbiAgICAgICAgcmV0dXJuIFwiZ3ppcFwiO1xuICAgIGNhc2UgXCJiejJcIjpcbiAgICBjYXNlIFwiYnppcDJcIjpcbiAgICAgICAgcmV0dXJuIFwiYnppcDJcIjtcbiAgICBkZWZhdWx0OlxuICAgICAgICBjb25zb2xlLndhcm4oXCJVbnJlY29nbml6ZWQgTlJSRCBlbmNvZGluZzogXCIgKyBlbmNvZGluZyk7XG4gICAgICAgIHJldHVybiBlbmNvZGluZztcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHBhcnNlTlJSRFNwYWNlKHNwYWNlKSB7XG4gICAgc3dpdGNoKHNwYWNlLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlIFwicmlnaHQtYW50ZXJpb3Itc3VwZXJpb3JcIjpcbiAgICBjYXNlIFwicmFzXCI6XG4gICAgICAgIHJldHVybiBcInJpZ2h0LWFudGVyaW9yLXN1cGVyaW9yXCI7XG4gICAgY2FzZSBcImxlZnQtYW50ZXJpb3Itc3VwZXJpb3JcIjpcbiAgICBjYXNlIFwibGFzXCI6XG4gICAgICAgIHJldHVybiBcImxlZnQtYW50ZXJpb3Itc3VwZXJpb3JcIjtcbiAgICBjYXNlIFwibGVmdC1wb3N0ZXJpb3Itc3VwZXJpb3JcIjpcbiAgICBjYXNlIFwibHBzXCI6XG4gICAgICAgIHJldHVybiBcImxlZnQtcG9zdGVyaW9yLXN1cGVyaW9yXCI7XG4gXHQgIGNhc2UgXCJyaWdodC1hbnRlcmlvci1zdXBlcmlvci10aW1lXCI6XG4gXHQgIGNhc2UgXCJyYXN0XCI6XG4gICAgICAgIHJldHVybiBcInJpZ2h0LWFudGVyaW9yLXN1cGVyaW9yLXRpbWVcIjtcbiAgICBjYXNlIFwibGVmdC1hbnRlcmlvci1zdXBlcmlvci10aW1lXCI6XG4gICAgY2FzZSBcImxhc3RcIjpcbiAgICAgICAgcmV0dXJuIFwibGVmdC1hbnRlcmlvci1zdXBlcmlvci10aW1lXCI7XG4gICAgY2FzZSBcImxlZnQtcG9zdGVyaW9yLXN1cGVyaW9yLXRpbWVcIjpcbiAgICBjYXNlIFwibHBzdFwiOlxuICAgICAgICByZXR1cm4gXCJsZWZ0LXBvc3Rlcmlvci1zdXBlcmlvci10aW1lXCI7XG4gICAgY2FzZSBcInNjYW5uZXIteHl6XCI6XG4gICAgICAgIHJldHVybiBcInNjYW5uZXIteHl6XCI7XG4gICAgY2FzZSBcInNjYW5uZXIteHl6LXRpbWVcIjpcbiAgICAgICAgcmV0dXJuIFwic2Nhbm5lci14eXotdGltZVwiO1xuICAgIGNhc2UgXCIzZC1yaWdodC1oYW5kZWRcIjpcbiAgICAgICAgcmV0dXJuIFwiM0QtcmlnaHQtaGFuZGVkXCI7XG4gICAgY2FzZSBcIjNkLWxlZnQtaGFuZGVkXCI6XG4gICAgICAgIHJldHVybiBcIjNELWxlZnQtaGFuZGVkXCI7XG4gICAgY2FzZSBcIjNkLXJpZ2h0LWhhbmRlZC10aW1lXCI6XG4gICAgICAgIHJldHVybiBcIjNELXJpZ2h0LWhhbmRlZC10aW1lXCI7XG4gICAgY2FzZSBcIjNkLWxlZnQtaGFuZGVkLXRpbWVcIjpcbiAgICAgICAgcmV0dXJuIFwiM0QtbGVmdC1oYW5kZWQtdGltZVwiO1xuICAgIGRlZmF1bHQ6XG4gICAgICAgIGNvbnNvbGUud2FybihcIlVucmVjb2duaXplZCBzcGFjZTogXCIgKyBzcGFjZSk7XG4gICAgICAgIHJldHVybiBzcGFjZTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHBhcnNlTlJSREVuZGlhbihlbmRpYW4pIHtcbiAgICBzd2l0Y2goZW5kaWFuLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICdsaXR0bGUnOlxuICAgICAgICByZXR1cm4gJ2xpdHRsZSc7XG4gICAgY2FzZSAnYmlnJzpcbiAgICAgICAgcmV0dXJuICdiaWcnO1xuICAgIGRlZmF1bHQ6XG4gICAgICAgIGNvbnNvbGUud2FybihcIlVucmVjb2duaXplZCBOUlJEIGVuZGlhbm5lc3M6IFwiICsgZW5kaWFuKTtcbiAgICAgICAgcmV0dXJuIGVuZGlhbjtcbiAgICB9XG59XG5cbi8vIE5vdGUgdGhhdCB0aGlzIGZ1bmN0aW9uIHdpbGwgbmV2ZXIgZW5jb3VudGVyIHRoZSBMSVNUIGRhdGEgZmlsZSBzcGVjaWZpY2F0aW9uIGZvcm1hdCwgYXMgdGhpcyBpcyBoYW5kbGVkIGVsc2V3aGVyZS5cbnZhciBkYXRhRmlsZUZvcm1hdFJFID0gLyAoLT9cXGQrKSAoLT9cXGQrKSAoLT9cXGQrKSg/OiAoXFxkKykpPyQvO1xuZnVuY3Rpb24gcGFyc2VOUlJERGF0YUZpbGUoZGF0YUZpbGUpIHtcbiAgICB2YXIgbWF0Y2ggPSBkYXRhRmlsZUZvcm1hdFJFLmV4ZWMoZGF0YUZpbGUpO1xuICAgIGlmIChtYXRjaCkgeyAvLyBXZSBoYXZlIGEgZm9ybWF0IHNwZWNpZmljYXRpb25cbiAgICAgICAgaWYgKG1hdGNoLmxlbmd0aCA9PSA1ICYmIG1hdGNoWzRdKSB7IC8vIHN1YmRpbSBzcGVjaWZpY2F0aW9uXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGZvcm1hdDogZGF0YUZpbGUuc3Vic3RyaW5nKDAsIG1hdGNoLmluZGV4KSxcbiAgICAgICAgICAgICAgICBtaW46IHBhcnNlTlJSREludGVnZXIobWF0Y2hbMV0pLFxuICAgICAgICAgICAgICAgIG1heDogcGFyc2VOUlJESW50ZWdlcihtYXRjaFsyXSksXG4gICAgICAgICAgICAgICAgc3RlcDogcGFyc2VOUlJESW50ZWdlcihtYXRjaFszXSksXG4gICAgICAgICAgICAgICAgc3ViZGltOiBwYXJzZU5SUkRJbnRlZ2VyKG1hdGNoWzRdKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZm9ybWF0OiBkYXRhRmlsZS5zdWJzdHJpbmcoMCwgbWF0Y2guaW5kZXgpLFxuICAgICAgICAgICAgICAgIG1pbjogcGFyc2VOUlJESW50ZWdlcihtYXRjaFsxXSksXG4gICAgICAgICAgICAgICAgbWF4OiBwYXJzZU5SUkRJbnRlZ2VyKG1hdGNoWzJdKSxcbiAgICAgICAgICAgICAgICBzdGVwOiBwYXJzZU5SUkRJbnRlZ2VyKG1hdGNoWzNdKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7IC8vIEp1c3QgYSBmaWxlXG4gICAgICAgIHJldHVybiBkYXRhRmlsZTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHNlcmlhbGl6ZU5SUkREYXRhRmlsZShkYXRhRmlsZSkge1xuICAgIGlmICgodHlwZW9mIGRhdGFGaWxlKSA9PSBcInN0cmluZ1wiIHx8IGRhdGFGaWxlIGluc3RhbmNlb2YgU3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBkYXRhRmlsZTtcbiAgICB9IGVsc2UgaWYgKCdmb3JtYXQnIGluIGRhdGFGaWxlICYmICdtaW4nIGluIGRhdGFGaWxlICYmICdtYXgnIGluIGRhdGFGaWxlICYmICdzdGVwJyBpbiBkYXRhRmlsZSkge1xuICAgICAgICBpZiAoJ3N1YmRpbScgaW4gZGF0YUZpbGUpIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRhRmlsZS5mb3JtYXQgKyBcIiBcIiArIGRhdGFGaWxlLm1pbiArIFwiIFwiICsgZGF0YUZpbGUubWF4ICsgXCIgXCIgKyBkYXRhRmlsZS5zdGVwICsgXCIgXCIgKyBkYXRhRmlsZS5zdWJkaW07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZGF0YUZpbGUuZm9ybWF0ICsgXCIgXCIgKyBkYXRhRmlsZS5taW4gKyBcIiBcIiArIGRhdGFGaWxlLm1heCArIFwiIFwiICsgZGF0YUZpbGUuc3RlcDtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVucmVjb2duaXplZCBkYXRhIGZpbGUgZm9ybWF0IVwiKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHBhcnNlTlJSRENlbnRlcihjZW50ZXIpIHtcbiAgICBzd2l0Y2goY2VudGVyLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlIFwiY2VsbFwiOlxuICAgICAgICByZXR1cm4gXCJjZWxsXCI7XG4gICAgY2FzZSBcIm5vZGVcIjpcbiAgICAgICAgcmV0dXJuIFwibm9kZVwiO1xuICAgIGNhc2UgXCI/Pz9cIjpcbiAgICBjYXNlIFwibm9uZVwiOlxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBkZWZhdWx0OlxuICAgICAgICBjb25zb2xlLndhcm4oXCJVbnJlY29nbml6ZWQgTlJSRCBjZW50ZXI6IFwiICsgY2VudGVyKTtcbiAgICAgICAgcmV0dXJuIGNlbnRlcjtcbiAgICB9XG59XG5cbnZhciBOUlJES2luZHMgPSB7XG4gICAgXCJkb21haW5cIjogXCJkb21haW5cIixcbiAgICBcInNwYWNlXCI6IFwic3BhY2VcIixcbiAgICBcInRpbWVcIjogXCJ0aW1lXCIsXG4gICAgXCJsaXN0XCI6IFwibGlzdFwiLFxuICAgIFwicG9pbnRcIjogXCJwb2ludFwiLFxuICAgIFwidmVjdG9yXCI6IFwidmVjdG9yXCIsXG4gICAgXCJjb3ZhcmlhbnQtdmVjdG9yXCI6IFwiY292YXJpYW50LXZlY3RvclwiLFxuICAgIFwibm9ybWFsXCI6IFwibm9ybWFsXCIsXG4gICAgXCJzdHViXCI6IFwic3R1YlwiLFxuICAgIFwic2NhbGFyXCI6IFwic2NhbGFyXCIsXG4gICAgXCJjb21wbGV4XCI6IFwiY29tcGxleFwiLFxuICAgIFwiMi12ZWN0b3JcIjogXCIyLXZlY3RvclwiLFxuICAgIFwiMy1jb2xvclwiOiBcIjMtY29sb3JcIixcbiAgICBcInJnYi1jb2xvclwiOiBcIlJHQi1jb2xvclwiLFxuICAgIFwiaHN2LWNvbG9yXCI6IFwiSFNWLWNvbG9yXCIsXG4gICAgXCJ4eXotY29sb3JcIjogXCJYWVotY29sb3JcIixcbiAgICBcIjQtY29sb3JcIjogXCI0LWNvbG9yXCIsXG4gICAgXCJyZ2JhLWNvbG9yXCI6IFwiUkdCQS1jb2xvclwiLFxuICAgIFwiMy12ZWN0b3JcIjogXCIzLXZlY3RvclwiLFxuICAgIFwiMy1ncmFkaWVudFwiOiBcIjMtZ3JhZGllbnRcIixcbiAgICBcIjMtbm9ybWFsXCI6IFwiMy1ub3JtYWxcIixcbiAgICBcIjQtdmVjdG9yXCI6IFwiNC12ZWN0b3JcIixcbiAgICBcInF1YXRlcm5pb25cIjogXCJxdWF0ZXJuaW9uXCIsXG4gICAgXCIyZC1zeW1tZXRyaWMtbWF0cml4XCI6IFwiMkQtc3ltbWV0cmljLW1hdHJpeFwiLFxuICAgIFwiMmQtbWFza2VkLXN5bW1ldHJpYy1tYXRyaXhcIjogXCIyRC1tYXNrZWQtc3ltbWV0cmljLW1hdHJpeFwiLFxuICAgIFwiMmQtbWF0cml4XCI6IFwiMkQtbWF0cml4XCIsXG4gICAgXCIyZC1tYXNrZWQtbWF0cml4XCI6IFwiMkQtbWFza2VkLW1hdHJpeFwiLFxuICAgIFwiM2Qtc3ltbWV0cmljLW1hdHJpeFwiOiBcIjNELXN5bW1ldHJpYy1tYXRyaXhcIixcbiAgICBcIjNkLW1hc2tlZC1zeW1tZXRyaWMtbWF0cml4XCI6IFwiM0QtbWFza2VkLXN5bW1ldHJpYy1tYXRyaXhcIixcbiAgICBcIjNkLW1hdHJpeFwiOiBcIjNELW1hdHJpeFwiLFxuICAgIFwiM2QtbWFza2VkLW1hdHJpeFwiOiBcIjNELW1hc2tlZC1tYXRyaXhcIixcbiAgICBcIj8/P1wiOiBudWxsLFxuICAgIFwibm9uZVwiOiBudWxsXG59O1xuZnVuY3Rpb24gcGFyc2VOUlJES2luZChraW5kKSB7XG4gICAgdmFyIGtpbmRMQyA9IGtpbmQudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAoa2luZExDIGluIE5SUkRLaW5kcykgcmV0dXJuIE5SUkRLaW5kc1traW5kTENdO1xuICAgIGNvbnNvbGUud2FybihcIlVucmVjb2duaXplZCBOUlJEIGtpbmQ6IFwiICsga2luZCk7XG4gICAgcmV0dXJuIGtpbmQ7XG59XG5cbmZ1bmN0aW9uIHNlcmlhbGl6ZU5SUkRPcHRpb25hbChhKSB7XG4gICAgcmV0dXJuIGE9PT1udWxsID8gXCI/Pz9cIiA6IGE7XG59XG5cbnZhciBzeXN0ZW1FbmRpYW5uZXNzID0gKGZ1bmN0aW9uKCkge1xuICAgIHZhciBidWYgPSBuZXcgQXJyYXlCdWZmZXIoNCksXG4gICAgICAgIGludEFyciA9IG5ldyBVaW50MzJBcnJheShidWYpLFxuICAgICAgICBieXRlQXJyID0gbmV3IFVpbnQ4QXJyYXkoYnVmKTtcbiAgICBpbnRBcnJbMF0gPSAweDAxMDIwMzA0O1xuICAgIGlmIChieXRlQXJyWzBdPT0xICYmIGJ5dGVBcnJbMV09PTIgJiYgYnl0ZUFyclsyXT09MyAmJiBieXRlQXJyWzNdPT00KSB7XG4gICAgICAgIHJldHVybiAnYmlnJztcbiAgICB9IGVsc2UgaWYgKGJ5dGVBcnJbMF09PTQgJiYgYnl0ZUFyclsxXT09MyAmJiBieXRlQXJyWzJdPT0yICYmIGJ5dGVBcnJbM109PTEpIHtcbiAgICAgICAgcmV0dXJuICdsaXR0bGUnO1xuICAgIH1cbiAgICBjb25zb2xlLndhcm4oXCJVbnJlY29nbml6ZWQgc3lzdGVtIGVuZGlhbm5lc3MhXCIpO1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG59KSgpO1xuXG5mdW5jdGlvbiBwYXJzZU5SUkRSYXdEYXRhKGJ1ZmZlciwgdHlwZSwgc2l6ZXMsIG9wdGlvbnMpIHtcbiAgICB2YXIgaSwgYXJyLCB2aWV3LCB0b3RhbExlbiA9IDEsIGVuZGlhbkZsYWc7XG4gICAgZm9yKGk9MDsgaTxzaXplcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoc2l6ZXNbaV08PTApIHRocm93IG5ldyBFcnJvcihcIlNpemVzIHNob3VsZCBiZSBhIGxpc3Qgb2YgcG9zaXRpdmUgKD4wKSBpbnRlZ2VycyFcIik7XG4gICAgICAgIHRvdGFsTGVuICo9IHNpemVzW2ldO1xuICAgIH1cbiAgICBpZiAodHlwZSA9PSAnYmxvY2snKSB7XG4gICAgICAgIC8vIERvbid0IGRvIGFueXRoaW5nIHNwZWNpYWwsIGp1c3QgcmV0dXJuIHRoZSBzbGljZSBjb250YWluaW5nIGFsbCBibG9ja3MuXG4gICAgICAgIHJldHVybiBidWZmZXIuc2xpY2UoMCx0b3RhbExlbipvcHRpb25zLmJsb2NrU2l6ZSk7XG4gICAgfSBlbHNlIGlmICh0eXBlID09ICdpbnQ4JyB8fCB0eXBlID09ICd1aW50OCcgfHwgb3B0aW9ucy5lbmRpYW4gPT0gc3lzdGVtRW5kaWFubmVzcykge1xuICAgICAgICBzd2l0Y2godHlwZSkge1xuICAgICAgICBjYXNlIFwiaW50OFwiOlxuICAgICAgICAgICAgY2hlY2tTaXplKDEpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBJbnQ4QXJyYXkoYnVmZmVyLnNsaWNlKDAsdG90YWxMZW4pKTtcbiAgICAgICAgY2FzZSBcInVpbnQ4XCI6XG4gICAgICAgICAgICBjaGVja1NpemUoMSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyLnNsaWNlKDAsdG90YWxMZW4pKTtcbiAgICAgICAgY2FzZSBcImludDE2XCI6XG4gICAgICAgICAgICBjaGVja1NpemUoMik7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEludDE2QXJyYXkoYnVmZmVyLnNsaWNlKDAsdG90YWxMZW4qMikpO1xuICAgICAgICBjYXNlIFwidWludDE2XCI6XG4gICAgICAgICAgICBjaGVja1NpemUoMik7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFVpbnQxNkFycmF5KGJ1ZmZlci5zbGljZSgwLHRvdGFsTGVuKjIpKTtcbiAgICAgICAgY2FzZSBcImludDMyXCI6XG4gICAgICAgICAgICBjaGVja1NpemUoNCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEludDMyQXJyYXkoYnVmZmVyLnNsaWNlKDAsdG90YWxMZW4qNCkpO1xuICAgICAgICBjYXNlIFwidWludDMyXCI6XG4gICAgICAgICAgICBjaGVja1NpemUoNCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFVpbnQzMkFycmF5KGJ1ZmZlci5zbGljZSgwLHRvdGFsTGVuKjQpKTtcbiAgICAgICAgLy9jYXNlIFwiaW50NjRcIjpcbiAgICAgICAgLy8gICAgY2hlY2tTaXplKDgpO1xuICAgICAgICAvLyAgICByZXR1cm4gbmV3IEludDY0QXJyYXkoYnVmZmVyLnNsaWNlKDAsdG90YWxMZW4qOCkpO1xuICAgICAgICAvL2Nhc2UgXCJ1aW50NjRcIjpcbiAgICAgICAgLy8gICAgY2hlY2tTaXplKDgpO1xuICAgICAgICAvLyAgICByZXR1cm4gbmV3IFVpbnQ2NEFycmF5KGJ1ZmZlci5zbGljZSgwLHRvdGFsTGVuKjgpKTtcbiAgICAgICAgY2FzZSBcImZsb2F0XCI6XG4gICAgICAgICAgICBjaGVja1NpemUoNCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEZsb2F0MzJBcnJheShidWZmZXIuc2xpY2UoMCx0b3RhbExlbio0KSk7XG4gICAgICAgIGNhc2UgXCJkb3VibGVcIjpcbiAgICAgICAgICAgIGNoZWNrU2l6ZSg4KTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRmxvYXQ2NEFycmF5KGJ1ZmZlci5zbGljZSgwLHRvdGFsTGVuKjgpKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlVuc3VwcG9ydGVkIE5SUkQgdHlwZTogXCIgKyB0eXBlICsgXCIsIHJldHVybmluZyByYXcgYnVmZmVyLlwiKTtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBzd2l0Y2gob3B0aW9ucy5lbmRpYW4pIHtcbiAgICAgICAgY2FzZSAnYmlnJzpcbiAgICAgICAgICAgIGVuZGlhbkZsYWcgPSBmYWxzZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdsaXR0bGUnOlxuICAgICAgICAgICAgZW5kaWFuRmxhZyA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlVuc3VwcG9ydGVkIGVuZGlhbm5lc3MgaW4gTlJSRCBmaWxlOiBcIiArIG9wdGlvbnMuZW5kaWFuKTtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgdmlldyA9IG5ldyBEYXRhVmlldyhidWZmZXIpO1xuICAgICAgICBzd2l0Y2godHlwZSkge1xuICAgICAgICBjYXNlIFwiaW50OFwiOiAvLyBOb3RlIHRoYXQgaGVyZSB3ZSBkbyBub3QgbmVlZCB0byBjaGVjayB0aGUgc2l6ZSBvZiB0aGUgYnVmZmVyLCBhcyB0aGUgRGF0YVZpZXcuZ2V0IG1ldGhvZHMgc2hvdWxkIHRocm93IGFuIGV4Y2VwdGlvbiBpZiB3ZSByZWFkIGJleW9uZCB0aGUgYnVmZmVyLlxuICAgICAgICAgICAgYXJyID0gbmV3IEludDhBcnJheSh0b3RhbExlbik7XG4gICAgICAgICAgICBmb3IoaT0wOyBpPHRvdGFsTGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBhcnJbaV0gPSB2aWV3LmdldEludDgoaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYXJyO1xuICAgICAgICBjYXNlIFwidWludDhcIjpcbiAgICAgICAgICAgIGFyciA9IG5ldyBVaW50OEFycmF5KHRvdGFsTGVuKTtcbiAgICAgICAgICAgIGZvcihpPTA7IGk8dG90YWxMZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGFycltpXSA9IHZpZXcuZ2V0VWludDgoaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYXJyO1xuICAgICAgICBjYXNlIFwiaW50MTZcIjpcbiAgICAgICAgICAgIGFyciA9IG5ldyBJbnQxNkFycmF5KHRvdGFsTGVuKTtcbiAgICAgICAgICAgIGZvcihpPTA7IGk8dG90YWxMZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGFycltpXSA9IHZpZXcuZ2V0SW50MTYoaSoyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhcnI7XG4gICAgICAgIGNhc2UgXCJ1aW50MTZcIjpcbiAgICAgICAgICAgIGFyciA9IG5ldyBVaW50MTZBcnJheSh0b3RhbExlbik7XG4gICAgICAgICAgICBmb3IoaT0wOyBpPHRvdGFsTGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBhcnJbaV0gPSB2aWV3LmdldFVpbnQxNihpKjIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFycjtcbiAgICAgICAgY2FzZSBcImludDMyXCI6XG4gICAgICAgICAgICBhcnIgPSBuZXcgSW50MzJBcnJheSh0b3RhbExlbik7XG4gICAgICAgICAgICBmb3IoaT0wOyBpPHRvdGFsTGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBhcnJbaV0gPSB2aWV3LmdldEludDMyKGkqNCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYXJyO1xuICAgICAgICBjYXNlIFwidWludDMyXCI6XG4gICAgICAgICAgICBhcnIgPSBuZXcgVWludDMyQXJyYXkodG90YWxMZW4pO1xuICAgICAgICAgICAgZm9yKGk9MDsgaTx0b3RhbExlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYXJyW2ldID0gdmlldy5nZXRVaW50MzIoaSo0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhcnI7XG4gICAgICAgIC8vY2FzZSBcImludDY0XCI6XG4gICAgICAgIC8vICAgIGFyciA9IG5ldyBJbnQ2NEFycmF5KHRvdGFsTGVuKTtcbiAgICAgICAgLy8gICAgZm9yKGk9MDsgaTx0b3RhbExlbjsgaSsrKSB7XG4gICAgICAgIC8vICAgICAgICBhcnJbaV0gPSB2aWV3LmdldEludDY0KGkqOCk7XG4gICAgICAgIC8vICAgIH1cbiAgICAgICAgLy8gICAgcmV0dXJuIGFycjtcbiAgICAgICAgLy9jYXNlIFwidWludDY0XCI6XG4gICAgICAgIC8vICAgIGFyciA9IG5ldyBVaW50NjRBcnJheSh0b3RhbExlbik7XG4gICAgICAgIC8vICAgIGZvcihpPTA7IGk8dG90YWxMZW47IGkrKykge1xuICAgICAgICAvLyAgICAgICAgYXJyW2ldID0gdmlldy5nZXRVaW50NjQoaSo4KTtcbiAgICAgICAgLy8gICAgfVxuICAgICAgICAvLyAgICByZXR1cm4gYXJyO1xuICAgICAgICBjYXNlIFwiZmxvYXRcIjpcbiAgICAgICAgICAgIGFyciA9IG5ldyBGbG9hdDMyQXJyYXkodG90YWxMZW4pO1xuICAgICAgICAgICAgZm9yKGk9MDsgaTx0b3RhbExlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYXJyW2ldID0gdmlldy5nZXRGbG9hdDMyKGkqNCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYXJyO1xuICAgICAgICBjYXNlIFwiZG91YmxlXCI6XG4gICAgICAgICAgICBhcnIgPSBuZXcgRmxvYXQ2NEFycmF5KHRvdGFsTGVuKTtcbiAgICAgICAgICAgIGZvcihpPTA7IGk8dG90YWxMZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGFycltpXSA9IHZpZXcuZ2V0RmxvYXQ2NChpKjgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFycjtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlVuc3VwcG9ydGVkIE5SUkQgdHlwZTogXCIgKyB0eXBlICsgXCIsIHJldHVybmluZyByYXcgYnVmZmVyLlwiKTtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gY2hlY2tTaXplKHNpemVPZlR5cGUpIHtcbiAgICAgICAgaWYgKGJ1ZmZlci5ieXRlTGVuZ3RoPHRvdGFsTGVuKnNpemVPZlR5cGUpIHRocm93IG5ldyBFcnJvcihcIk5SUkQgZmlsZSBkb2VzIG5vdCBjb250YWluIGVub3VnaCBkYXRhIVwiKTtcbiAgICB9XG59XG5cbnZhciB3aGl0ZXNwYWNlRGF0YVZhbHVlTGlzdFNlcGFyYXRvclJFID0gL1sgXFx0XFxuXFxyXFx2XFxmXSsvO1xuZnVuY3Rpb24gcGFyc2VOUlJEVGV4dERhdGEoYnVmZmVyLCB0eXBlLCBzaXplcykge1xuICAgIHZhciBpLCBidWY4LCBzdHIsIHN0ckxpc3QsIHRvdGFsTGVuID0gMTtcbiAgICBmb3IoaT0wOyBpPHNpemVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChzaXplc1tpXTw9MCkgdGhyb3cgbmV3IEVycm9yKFwiU2l6ZXMgc2hvdWxkIGJlIGEgbGlzdCBvZiBwb3NpdGl2ZSAoPjApIGludGVnZXJzIVwiKTtcbiAgICAgICAgdG90YWxMZW4gKj0gc2l6ZXNbaV07XG4gICAgfVxuICAgIGJ1ZjggPSBuZXcgVWludDhBcnJheShidWZmZXIpO1xuICAgIHN0ciA9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgYnVmOCk7XG4gICAgc3RyTGlzdCA9IHN0ci5zcGxpdCh3aGl0ZXNwYWNlRGF0YVZhbHVlTGlzdFNlcGFyYXRvclJFKTtcbiAgICBpZiAoc3RyTGlzdC5sZW5ndGg8dG90YWxMZW4pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IGVub3VnaCBkYXRhIGluIE5SUkQgZmlsZSFcIik7XG4gICAgfSBlbHNlIGlmIChzdHJMaXN0Lmxlbmd0aD50b3RhbExlbikge1xuICAgICAgICBpZiAoc3RyTGlzdFswXSA9PT0gJycpIHN0ckxpc3QgPSBzdHJMaXN0LnNsaWNlKDEpOyAvLyBTdHJpY3RseSBzcGVha2luZyB0aGUgc3BlYyBkb2Vzbid0IChleHBsaWNpdGx5KSBhbGxvdyB3aGl0ZXNwYWNlIGluIGZyb250IG9mIHRoZSBmaXJzdCBudW1iZXIsIGJ1dCBsZXQncyBiZSBsZW5pZW50LlxuICAgICAgICBzdHJMaXN0ID0gc3RyTGlzdC5zbGljZSgwLCB0b3RhbExlbik7XG4gICAgfVxuICAgIHN3aXRjaCh0eXBlKSB7XG4gICAgY2FzZSBcImludDhcIjpcbiAgICAgICAgcmV0dXJuIG5ldyBJbnQ4QXJyYXkoc3RyTGlzdC5tYXAocGFyc2VOUlJESW50ZWdlcikpO1xuICAgIGNhc2UgXCJ1aW50OFwiOlxuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoc3RyTGlzdC5tYXAocGFyc2VOUlJESW50ZWdlcikpO1xuICAgIGNhc2UgXCJpbnQxNlwiOlxuICAgICAgICByZXR1cm4gbmV3IEludDE2QXJyYXkoc3RyTGlzdC5tYXAocGFyc2VOUlJESW50ZWdlcikpO1xuICAgIGNhc2UgXCJ1aW50MTZcIjpcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50MTZBcnJheShzdHJMaXN0Lm1hcChwYXJzZU5SUkRJbnRlZ2VyKSk7XG4gICAgY2FzZSBcImludDMyXCI6XG4gICAgICAgIHJldHVybiBuZXcgSW50MzJBcnJheShzdHJMaXN0Lm1hcChwYXJzZU5SUkRJbnRlZ2VyKSk7XG4gICAgY2FzZSBcInVpbnQzMlwiOlxuICAgICAgICByZXR1cm4gbmV3IFVpbnQzMkFycmF5KHN0ckxpc3QubWFwKHBhcnNlTlJSREludGVnZXIpKTtcbiAgICAvL2Nhc2UgXCJpbnQ2NFwiOlxuICAgIC8vICAgIHJldHVybiBuZXcgSW50NjRBcnJheShzdHJMaXN0Lm1hcChwYXJzZU5SUkRJbnRlZ2VyKSk7XG4gICAgLy9jYXNlIFwidWludDY0XCI6XG4gICAgLy8gICAgcmV0dXJuIG5ldyBVaW50NjRBcnJheShzdHJMaXN0Lm1hcChwYXJzZU5SUkRJbnRlZ2VyKSk7XG4gICAgY2FzZSBcImZsb2F0XCI6XG4gICAgICAgIHJldHVybiBuZXcgRmxvYXQzMkFycmF5KHN0ckxpc3QubWFwKHBhcnNlTlJSREZsb2F0KSk7XG4gICAgY2FzZSBcImRvdWJsZVwiOlxuICAgICAgICByZXR1cm4gbmV3IEZsb2F0NjRBcnJheShzdHJMaXN0Lm1hcChwYXJzZU5SUkRGbG9hdCkpO1xuICAgIGRlZmF1bHQ6XG4gICAgICAgIGNvbnNvbGUud2FybihcIlVuc3VwcG9ydGVkIE5SUkQgdHlwZTogXCIgKyB0eXBlICsgXCIuXCIpO1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbn1cblxuLy8gVGhpcyBBTFdBWVMgcmV0dXJucyBhbiBpbnRlZ2VyLCBvciB0aHJvd3MgYW4gZXhjZXB0aW9uLlxuZnVuY3Rpb24gZ2V0TlJSRFR5cGVTaXplKHR5cGUpIHtcbiAgICBzd2l0Y2godHlwZSkge1xuICAgIGNhc2UgXCJpbnQ4XCI6XG4gICAgICAgIHJldHVybiAxO1xuICAgIGNhc2UgXCJ1aW50OFwiOlxuICAgICAgICByZXR1cm4gMTtcbiAgICBjYXNlIFwiaW50MTZcIjpcbiAgICAgICAgcmV0dXJuIDI7XG4gICAgY2FzZSBcInVpbnQxNlwiOlxuICAgICAgICByZXR1cm4gMjtcbiAgICBjYXNlIFwiaW50MzJcIjpcbiAgICAgICAgcmV0dXJuIDQ7XG4gICAgY2FzZSBcInVpbnQzMlwiOlxuICAgICAgICByZXR1cm4gNDtcbiAgICBjYXNlIFwiaW50NjRcIjpcbiAgICAgICAgcmV0dXJuIDg7XG4gICAgY2FzZSBcInVpbnQ2NFwiOlxuICAgICAgICByZXR1cm4gODtcbiAgICBjYXNlIFwiZmxvYXRcIjpcbiAgICAgICAgcmV0dXJuIDQ7XG4gICAgY2FzZSBcImRvdWJsZVwiOlxuICAgICAgICByZXR1cm4gODtcbiAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEbyBub3Qga25vdyB0aGUgc2l6ZSBvZiBOUlJEIHR5cGU6IFwiICsgdHlwZSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBjaGVja05SUkQocmV0KSB7XG4gICAgLy8gQWx3YXlzIG5lY2Vzc2FyeSBmaWVsZHNcbiAgICBpZiAocmV0LmRpbWVuc2lvbj09PXVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEaW1lbnNpb24gbWlzc2luZyBmcm9tIE5SUkQgZmlsZSFcIik7XG4gICAgfSBlbHNlIGlmIChyZXQudHlwZT09PXVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUeXBlIG1pc3NpbmcgZnJvbSBOUlJEIGZpbGUhXCIpO1xuICAgIH0gZWxzZSBpZiAocmV0LmVuY29kaW5nPT09dW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkVuY29kaW5nIG1pc3NpbmcgZnJvbSBOUlJEIGZpbGUhXCIpO1xuICAgIH0gZWxzZSBpZiAocmV0LnNpemVzPT09dW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNpemVzIG1pc3NpbmcgZnJvbSBOUlJEIGZpbGUhXCIpO1xuICAgIH1cbiAgICBcbiAgICAvLyBTb21ldGltZXMgbmVjZXNzYXJ5IGZpZWxkc1xuICAgIGlmIChyZXQudHlwZSAhPSAnYmxvY2snICYmIHJldC50eXBlICE9ICdpbnQ4JyAmJiByZXQudHlwZSAhPSAndWludDgnICYmXG4gICAgICAgICAgcmV0LmVuY29kaW5nICE9ICdhc2NpaScgJiYgcmV0LmVuZGlhbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkVuZGlhbm5lc3MgbWlzc2luZyBmcm9tIE5SUkQgZmlsZSFcIik7XG4gICAgfSBlbHNlIGlmIChyZXQudHlwZSA9PSAnYmxvY2snICYmIHJldC5ibG9ja1NpemUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIGJsb2NrIHNpemUgaW4gTlJSRCBmaWxlIVwiKTtcbiAgICB9XG4gICAgXG4gICAgLy8gQ2hlY2sgZGltZW5zaW9uIGFuZCBwZXItYXhpcyBmaWVsZCBsZW5ndGhzXG4gICAgaWYgKHJldC5kaW1lbnNpb24gPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiWmVyby1kaW1lbnNpb25hbCBOUlJEIGZpbGU/XCIpO1xuICAgIH0gZWxzZSBpZiAocmV0LmRpbWVuc2lvbiAhPSByZXQuc2l6ZXMubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkxlbmd0aCBvZiAnc2l6ZXMnIGlzIGRpZmZlcmVudCBmcm9tICdkaW1lbnNpb24nIGluIGFuIE5SUkQgZmlsZSFcIik7XG4gICAgfSBlbHNlIGlmIChyZXQuc3BhY2luZ3MgJiYgcmV0LmRpbWVuc2lvbiAhPSByZXQuc3BhY2luZ3MubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkxlbmd0aCBvZiAnc3BhY2luZ3MnIGlzIGRpZmZlcmVudCBmcm9tICdkaW1lbnNpb24nIGluIGFuIE5SUkQgZmlsZSFcIik7XG4gICAgfSBlbHNlIGlmIChyZXQudGhpY2tuZXNzZXMgJiYgcmV0LmRpbWVuc2lvbiAhPSByZXQudGhpY2tuZXNzZXMubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkxlbmd0aCBvZiAndGhpY2tuZXNzZXMnIGlzIGRpZmZlcmVudCBmcm9tICdkaW1lbnNpb24nIGluIGFuIE5SUkQgZmlsZSFcIik7XG4gICAgfSBlbHNlIGlmIChyZXQuYXhpc01pbnMgJiYgcmV0LmRpbWVuc2lvbiAhPSByZXQuYXhpc01pbnMubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkxlbmd0aCBvZiAnYXhpcyBtaW5zJyBpcyBkaWZmZXJlbnQgZnJvbSAnZGltZW5zaW9uJyBpbiBhbiBOUlJEIGZpbGUhXCIpO1xuICAgIH0gZWxzZSBpZiAocmV0LmF4aXNNYXhzICYmIHJldC5kaW1lbnNpb24gIT0gcmV0LmF4aXNNYXhzLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJMZW5ndGggb2YgJ2F4aXMgbWF4cycgaXMgZGlmZmVyZW50IGZyb20gJ2RpbWVuc2lvbicgaW4gYW4gTlJSRCBmaWxlIVwiKTtcbiAgICB9IGVsc2UgaWYgKHJldC5jZW50ZXJzICYmIHJldC5kaW1lbnNpb24gIT0gcmV0LmNlbnRlcnMubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkxlbmd0aCBvZiAnY2VudGVycycgaXMgZGlmZmVyZW50IGZyb20gJ2RpbWVuc2lvbicgaW4gYW4gTlJSRCBmaWxlIVwiKTtcbiAgICB9IGVsc2UgaWYgKHJldC5sYWJlbHMgJiYgcmV0LmRpbWVuc2lvbiAhPSByZXQubGFiZWxzLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJMZW5ndGggb2YgJ2xhYmVscycgaXMgZGlmZmVyZW50IGZyb20gJ2RpbWVuc2lvbicgaW4gYW4gTlJSRCBmaWxlIVwiKTtcbiAgICB9IGVsc2UgaWYgKHJldC51bml0cyAmJiByZXQuZGltZW5zaW9uICE9IHJldC51bml0cy5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTGVuZ3RoIG9mICd1bml0cycgaXMgZGlmZmVyZW50IGZyb20gJ2RpbWVuc2lvbicgaW4gYW4gTlJSRCBmaWxlIVwiKTtcbiAgICB9IGVsc2UgaWYgKHJldC5raW5kcyAmJiByZXQuZGltZW5zaW9uICE9IHJldC5raW5kcy5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTGVuZ3RoIG9mICdraW5kcycgaXMgZGlmZmVyZW50IGZyb20gJ2RpbWVuc2lvbicgaW4gYW4gTlJSRCBmaWxlIVwiKTtcbiAgICB9XG4gICAgXG4gICAgLy8gVE9ETzogQ2hlY2sgc3BhY2Uvb3JpZW50YXRpb24gZmllbGRzLlxuICAgIFxuICAgIC8vIFdlIHNob3VsZCBlaXRoZXIgaGF2ZSBpbmxpbmUgZGF0YSBvciBleHRlcm5hbCBkYXRhXG4gICAgaWYgKChyZXQuZGF0YSA9PT0gdW5kZWZpbmVkIHx8IHJldC5kYXRhLmxlbmd0aCA9PT0gMCkgJiYgKHJldC5idWZmZXIgPT09IHVuZGVmaW5lZCB8fCByZXQuYnVmZmVyLmJ5dGVMZW5ndGggPT09IDApICYmIHJldC5kYXRhRmlsZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5SUkQgZmlsZSBoYXMgbmVpdGhlciBpbmxpbmUgb3IgZXh0ZXJuYWwgZGF0YSFcIik7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBjYXN0VHlwZWRBcnJheShkYXRhLCB0eXBlKSB7XG4gICAgc3dpdGNoKHR5cGUpIHtcbiAgICBjYXNlIFwiaW50OFwiOlxuICAgICAgICByZXR1cm4gbmV3IEludDhBcnJheShkYXRhKTtcbiAgICBjYXNlIFwidWludDhcIjpcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGRhdGEpO1xuICAgIGNhc2UgXCJpbnQxNlwiOlxuICAgICAgICByZXR1cm4gbmV3IEludDE2QXJyYXkoZGF0YSk7XG4gICAgY2FzZSBcInVpbnQxNlwiOlxuICAgICAgICByZXR1cm4gbmV3IFVpbnQxNkFycmF5KGRhdGEpO1xuICAgIGNhc2UgXCJpbnQzMlwiOlxuICAgICAgICByZXR1cm4gbmV3IEludDMyQXJyYXkoZGF0YSk7XG4gICAgY2FzZSBcInVpbnQzMlwiOlxuICAgICAgICByZXR1cm4gbmV3IFVpbnQzMkFycmF5KGRhdGEpO1xuICAgIC8vY2FzZSBcImludDY0XCI6XG4gICAgLy8gICAgcmV0dXJuIG5ldyBJbnQ2NEFycmF5KGRhdGEpO1xuICAgIC8vY2FzZSBcInVpbnQ2NFwiOlxuICAgIC8vICAgIHJldHVybiBuZXcgVWludDY0QXJyYXkoZGF0YSk7XG4gICAgY2FzZSBcImZsb2F0XCI6XG4gICAgICAgIHJldHVybiBuZXcgRmxvYXQzMkFycmF5KGRhdGEpO1xuICAgIGNhc2UgXCJkb3VibGVcIjpcbiAgICAgICAgcmV0dXJuIG5ldyBGbG9hdDY0QXJyYXkoZGF0YSk7XG4gICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNhc3QgdG8gTlJSRCB0eXBlOiBcIiArIHR5cGUpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gc2VyaWFsaXplVG9CdWZmZXIoZGF0YSwgdHlwZSwgZW5kaWFuKSB7XG4gICAgdmFyIGksIGVuZGlhbkZsYWcsIHZpZXcsIG5hdGl2ZVNpemUgPSBnZXROUlJEVHlwZVNpemUodHlwZSksIGJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcihkYXRhLmxlbmd0aCpuYXRpdmVTaXplKTtcbiAgICBzd2l0Y2goZW5kaWFuKSB7XG4gICAgY2FzZSAnYmlnJzpcbiAgICAgICAgZW5kaWFuRmxhZyA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICBjYXNlICdsaXR0bGUnOlxuICAgICAgICBlbmRpYW5GbGFnID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgICAgY29uc29sZS53YXJuKFwiVW5zdXBwb3J0ZWQgZW5kaWFubmVzcyBpbiBOUlJEIGZpbGU6IFwiICsgZW5kaWFuKTtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgdmlldyA9IG5ldyBEYXRhVmlldyhidWZmZXIpO1xuICAgIHN3aXRjaCh0eXBlKSB7XG4gICAgY2FzZSBcImludDhcIjogLy8gTm90ZSB0aGF0IGhlcmUgd2UgZG8gbm90IG5lZWQgdG8gY2hlY2sgdGhlIHNpemUgb2YgdGhlIGJ1ZmZlciwgYXMgdGhlIERhdGFWaWV3LmdldCBtZXRob2RzIHNob3VsZCB0aHJvdyBhbiBleGNlcHRpb24gaWYgd2UgcmVhZCBiZXlvbmQgdGhlIGJ1ZmZlci5cbiAgICAgICAgZm9yKGk9MDsgaTxkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2aWV3LnNldEludDgoaSwgZGF0YVtpXSwgZW5kaWFuRmxhZyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJ1ZmZlcjtcbiAgICBjYXNlIFwidWludDhcIjpcbiAgICAgICAgZm9yKGk9MDsgaTxkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2aWV3LnNldFVpbnQ4KGksIGRhdGFbaV0sIGVuZGlhbkZsYWcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBidWZmZXI7XG4gICAgY2FzZSBcImludDE2XCI6XG4gICAgICAgIGZvcihpPTA7IGk8ZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmlldy5zZXRJbnQxNihpKjIsIGRhdGFbaV0sIGVuZGlhbkZsYWcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBidWZmZXI7XG4gICAgY2FzZSBcInVpbnQxNlwiOlxuICAgICAgICBmb3IoaT0wOyBpPGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZpZXcuc2V0VWludDE2KGkqMiwgZGF0YVtpXSwgZW5kaWFuRmxhZyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJ1ZmZlcjtcbiAgICBjYXNlIFwiaW50MzJcIjpcbiAgICAgICAgZm9yKGk9MDsgaTxkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2aWV3LnNldEludDMyKGkqNCwgZGF0YVtpXSwgZW5kaWFuRmxhZyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJ1ZmZlcjtcbiAgICBjYXNlIFwidWludDMyXCI6XG4gICAgICAgIGZvcihpPTA7IGk8ZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmlldy5zZXRVaW50MzIoaSo0LCBkYXRhW2ldLCBlbmRpYW5GbGFnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYnVmZmVyO1xuICAgIC8vY2FzZSBcImludDY0XCI6XG4gICAgLy8gICAgZm9yKGk9MDsgaTxkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgLy8gICAgICAgIHZpZXcuc2V0SW50NjQoaSo4LCBkYXRhW2ldLCBlbmRpYW5GbGFnKTtcbiAgICAvLyAgICB9XG4gICAgLy8gICAgcmV0dXJuIGJ1ZmZlcjtcbiAgICAvL2Nhc2UgXCJ1aW50NjRcIjpcbiAgICAvLyAgICBmb3IoaT0wOyBpPGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAvLyAgICAgICAgdmlldy5zZXRVaW50NjQoaSo4LCBkYXRhW2ldLCBlbmRpYW5GbGFnKTtcbiAgICAvLyAgICB9XG4gICAgLy8gICAgcmV0dXJuIGJ1ZmZlcjtcbiAgICBjYXNlIFwiZmxvYXRcIjpcbiAgICAgICAgZm9yKGk9MDsgaTxkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2aWV3LnNldEZsb2F0MzIoaSo0LCBkYXRhW2ldLCBlbmRpYW5GbGFnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYnVmZmVyO1xuICAgIGNhc2UgXCJkb3VibGVcIjpcbiAgICAgICAgZm9yKGk9MDsgaTxkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2aWV3LnNldEZsb2F0NjQoaSo4LCBkYXRhW2ldLCBlbmRpYW5GbGFnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYnVmZmVyO1xuICAgIGRlZmF1bHQ6XG4gICAgICAgIGNvbnNvbGUud2FybihcIkNhbm5vdCBzZXJpYWxpemUgTlJSRCB0eXBlOiBcIiArIHR5cGUgKyBcIi5cIik7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBzZXJpYWxpemVUb1RleHRCdWZmZXIoZGF0YSkge1xuICAgIHZhciBpLCBzdHJzID0gbmV3IEFycmF5KGRhdGEubGVuZ3RoKSwgc3RyLCBidWZmZXIsIGFycjtcbiAgICBmb3IoaT0wOyBpPGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgc3Ryc1tpXSA9ICcnICsgZGF0YVtpXTtcbiAgICB9XG4gICAgc3RyID0gc3Rycy5qb2luKFwiIFwiKTtcbiAgICBidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoc3RyLmxlbmd0aCk7XG4gICAgYXJyID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKTtcbiAgICBmb3IoaT0wOyBpPGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgICBhcnJbaV0gPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICB9XG4gICAgcmV0dXJuIGJ1ZmZlcjtcbn1cbiIsIi8vIFRvcCBsZXZlbCBmaWxlIGlzIGp1c3QgYSBtaXhpbiBvZiBzdWJtb2R1bGVzICYgY29uc3RhbnRzXG4ndXNlIHN0cmljdCc7XG5cbnZhciBhc3NpZ24gICAgPSByZXF1aXJlKCcuL2xpYi91dGlscy9jb21tb24nKS5hc3NpZ247XG5cbnZhciBkZWZsYXRlICAgPSByZXF1aXJlKCcuL2xpYi9kZWZsYXRlJyk7XG52YXIgaW5mbGF0ZSAgID0gcmVxdWlyZSgnLi9saWIvaW5mbGF0ZScpO1xudmFyIGNvbnN0YW50cyA9IHJlcXVpcmUoJy4vbGliL3psaWIvY29uc3RhbnRzJyk7XG5cbnZhciBwYWtvID0ge307XG5cbmFzc2lnbihwYWtvLCBkZWZsYXRlLCBpbmZsYXRlLCBjb25zdGFudHMpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBha287XG4iLCIndXNlIHN0cmljdCc7XG5cblxudmFyIHpsaWJfZGVmbGF0ZSA9IHJlcXVpcmUoJy4vemxpYi9kZWZsYXRlJyk7XG52YXIgdXRpbHMgICAgICAgID0gcmVxdWlyZSgnLi91dGlscy9jb21tb24nKTtcbnZhciBzdHJpbmdzICAgICAgPSByZXF1aXJlKCcuL3V0aWxzL3N0cmluZ3MnKTtcbnZhciBtc2cgICAgICAgICAgPSByZXF1aXJlKCcuL3psaWIvbWVzc2FnZXMnKTtcbnZhciBaU3RyZWFtICAgICAgPSByZXF1aXJlKCcuL3psaWIvenN0cmVhbScpO1xuXG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG4vKiBQdWJsaWMgY29uc3RhbnRzID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxudmFyIFpfTk9fRkxVU0ggICAgICA9IDA7XG52YXIgWl9GSU5JU0ggICAgICAgID0gNDtcblxudmFyIFpfT0sgICAgICAgICAgICA9IDA7XG52YXIgWl9TVFJFQU1fRU5EICAgID0gMTtcbnZhciBaX1NZTkNfRkxVU0ggICAgPSAyO1xuXG52YXIgWl9ERUZBVUxUX0NPTVBSRVNTSU9OID0gLTE7XG5cbnZhciBaX0RFRkFVTFRfU1RSQVRFR1kgICAgPSAwO1xuXG52YXIgWl9ERUZMQVRFRCAgPSA4O1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5cbi8qKlxuICogY2xhc3MgRGVmbGF0ZVxuICpcbiAqIEdlbmVyaWMgSlMtc3R5bGUgd3JhcHBlciBmb3IgemxpYiBjYWxscy4gSWYgeW91IGRvbid0IG5lZWRcbiAqIHN0cmVhbWluZyBiZWhhdmlvdXIgLSB1c2UgbW9yZSBzaW1wbGUgZnVuY3Rpb25zOiBbW2RlZmxhdGVdXSxcbiAqIFtbZGVmbGF0ZVJhd11dIGFuZCBbW2d6aXBdXS5cbiAqKi9cblxuLyogaW50ZXJuYWxcbiAqIERlZmxhdGUuY2h1bmtzIC0+IEFycmF5XG4gKlxuICogQ2h1bmtzIG9mIG91dHB1dCBkYXRhLCBpZiBbW0RlZmxhdGUjb25EYXRhXV0gbm90IG92ZXJyaWRlbi5cbiAqKi9cblxuLyoqXG4gKiBEZWZsYXRlLnJlc3VsdCAtPiBVaW50OEFycmF5fEFycmF5XG4gKlxuICogQ29tcHJlc3NlZCByZXN1bHQsIGdlbmVyYXRlZCBieSBkZWZhdWx0IFtbRGVmbGF0ZSNvbkRhdGFdXVxuICogYW5kIFtbRGVmbGF0ZSNvbkVuZF1dIGhhbmRsZXJzLiBGaWxsZWQgYWZ0ZXIgeW91IHB1c2ggbGFzdCBjaHVua1xuICogKGNhbGwgW1tEZWZsYXRlI3B1c2hdXSB3aXRoIGBaX0ZJTklTSGAgLyBgdHJ1ZWAgcGFyYW0pICBvciBpZiB5b3VcbiAqIHB1c2ggYSBjaHVuayB3aXRoIGV4cGxpY2l0IGZsdXNoIChjYWxsIFtbRGVmbGF0ZSNwdXNoXV0gd2l0aFxuICogYFpfU1lOQ19GTFVTSGAgcGFyYW0pLlxuICoqL1xuXG4vKipcbiAqIERlZmxhdGUuZXJyIC0+IE51bWJlclxuICpcbiAqIEVycm9yIGNvZGUgYWZ0ZXIgZGVmbGF0ZSBmaW5pc2hlZC4gMCAoWl9PSykgb24gc3VjY2Vzcy5cbiAqIFlvdSB3aWxsIG5vdCBuZWVkIGl0IGluIHJlYWwgbGlmZSwgYmVjYXVzZSBkZWZsYXRlIGVycm9yc1xuICogYXJlIHBvc3NpYmxlIG9ubHkgb24gd3Jvbmcgb3B0aW9ucyBvciBiYWQgYG9uRGF0YWAgLyBgb25FbmRgXG4gKiBjdXN0b20gaGFuZGxlcnMuXG4gKiovXG5cbi8qKlxuICogRGVmbGF0ZS5tc2cgLT4gU3RyaW5nXG4gKlxuICogRXJyb3IgbWVzc2FnZSwgaWYgW1tEZWZsYXRlLmVycl1dICE9IDBcbiAqKi9cblxuXG4vKipcbiAqIG5ldyBEZWZsYXRlKG9wdGlvbnMpXG4gKiAtIG9wdGlvbnMgKE9iamVjdCk6IHpsaWIgZGVmbGF0ZSBvcHRpb25zLlxuICpcbiAqIENyZWF0ZXMgbmV3IGRlZmxhdG9yIGluc3RhbmNlIHdpdGggc3BlY2lmaWVkIHBhcmFtcy4gVGhyb3dzIGV4Y2VwdGlvblxuICogb24gYmFkIHBhcmFtcy4gU3VwcG9ydGVkIG9wdGlvbnM6XG4gKlxuICogLSBgbGV2ZWxgXG4gKiAtIGB3aW5kb3dCaXRzYFxuICogLSBgbWVtTGV2ZWxgXG4gKiAtIGBzdHJhdGVneWBcbiAqIC0gYGRpY3Rpb25hcnlgXG4gKlxuICogW2h0dHA6Ly96bGliLm5ldC9tYW51YWwuaHRtbCNBZHZhbmNlZF0oaHR0cDovL3psaWIubmV0L21hbnVhbC5odG1sI0FkdmFuY2VkKVxuICogZm9yIG1vcmUgaW5mb3JtYXRpb24gb24gdGhlc2UuXG4gKlxuICogQWRkaXRpb25hbCBvcHRpb25zLCBmb3IgaW50ZXJuYWwgbmVlZHM6XG4gKlxuICogLSBgY2h1bmtTaXplYCAtIHNpemUgb2YgZ2VuZXJhdGVkIGRhdGEgY2h1bmtzICgxNksgYnkgZGVmYXVsdClcbiAqIC0gYHJhd2AgKEJvb2xlYW4pIC0gZG8gcmF3IGRlZmxhdGVcbiAqIC0gYGd6aXBgIChCb29sZWFuKSAtIGNyZWF0ZSBnemlwIHdyYXBwZXJcbiAqIC0gYHRvYCAoU3RyaW5nKSAtIGlmIGVxdWFsIHRvICdzdHJpbmcnLCB0aGVuIHJlc3VsdCB3aWxsIGJlIFwiYmluYXJ5IHN0cmluZ1wiXG4gKiAgICAoZWFjaCBjaGFyIGNvZGUgWzAuLjI1NV0pXG4gKiAtIGBoZWFkZXJgIChPYmplY3QpIC0gY3VzdG9tIGhlYWRlciBmb3IgZ3ppcFxuICogICAtIGB0ZXh0YCAoQm9vbGVhbikgLSB0cnVlIGlmIGNvbXByZXNzZWQgZGF0YSBiZWxpZXZlZCB0byBiZSB0ZXh0XG4gKiAgIC0gYHRpbWVgIChOdW1iZXIpIC0gbW9kaWZpY2F0aW9uIHRpbWUsIHVuaXggdGltZXN0YW1wXG4gKiAgIC0gYG9zYCAoTnVtYmVyKSAtIG9wZXJhdGlvbiBzeXN0ZW0gY29kZVxuICogICAtIGBleHRyYWAgKEFycmF5KSAtIGFycmF5IG9mIGJ5dGVzIHdpdGggZXh0cmEgZGF0YSAobWF4IDY1NTM2KVxuICogICAtIGBuYW1lYCAoU3RyaW5nKSAtIGZpbGUgbmFtZSAoYmluYXJ5IHN0cmluZylcbiAqICAgLSBgY29tbWVudGAgKFN0cmluZykgLSBjb21tZW50IChiaW5hcnkgc3RyaW5nKVxuICogICAtIGBoY3JjYCAoQm9vbGVhbikgLSB0cnVlIGlmIGhlYWRlciBjcmMgc2hvdWxkIGJlIGFkZGVkXG4gKlxuICogIyMjIyMgRXhhbXBsZTpcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiB2YXIgcGFrbyA9IHJlcXVpcmUoJ3Bha28nKVxuICogICAsIGNodW5rMSA9IFVpbnQ4QXJyYXkoWzEsMiwzLDQsNSw2LDcsOCw5XSlcbiAqICAgLCBjaHVuazIgPSBVaW50OEFycmF5KFsxMCwxMSwxMiwxMywxNCwxNSwxNiwxNywxOCwxOV0pO1xuICpcbiAqIHZhciBkZWZsYXRlID0gbmV3IHBha28uRGVmbGF0ZSh7IGxldmVsOiAzfSk7XG4gKlxuICogZGVmbGF0ZS5wdXNoKGNodW5rMSwgZmFsc2UpO1xuICogZGVmbGF0ZS5wdXNoKGNodW5rMiwgdHJ1ZSk7ICAvLyB0cnVlIC0+IGxhc3QgY2h1bmtcbiAqXG4gKiBpZiAoZGVmbGF0ZS5lcnIpIHsgdGhyb3cgbmV3IEVycm9yKGRlZmxhdGUuZXJyKTsgfVxuICpcbiAqIGNvbnNvbGUubG9nKGRlZmxhdGUucmVzdWx0KTtcbiAqIGBgYFxuICoqL1xuZnVuY3Rpb24gRGVmbGF0ZShvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBEZWZsYXRlKSkgcmV0dXJuIG5ldyBEZWZsYXRlKG9wdGlvbnMpO1xuXG4gIHRoaXMub3B0aW9ucyA9IHV0aWxzLmFzc2lnbih7XG4gICAgbGV2ZWw6IFpfREVGQVVMVF9DT01QUkVTU0lPTixcbiAgICBtZXRob2Q6IFpfREVGTEFURUQsXG4gICAgY2h1bmtTaXplOiAxNjM4NCxcbiAgICB3aW5kb3dCaXRzOiAxNSxcbiAgICBtZW1MZXZlbDogOCxcbiAgICBzdHJhdGVneTogWl9ERUZBVUxUX1NUUkFURUdZLFxuICAgIHRvOiAnJ1xuICB9LCBvcHRpb25zIHx8IHt9KTtcblxuICB2YXIgb3B0ID0gdGhpcy5vcHRpb25zO1xuXG4gIGlmIChvcHQucmF3ICYmIChvcHQud2luZG93Qml0cyA+IDApKSB7XG4gICAgb3B0LndpbmRvd0JpdHMgPSAtb3B0LndpbmRvd0JpdHM7XG4gIH1cblxuICBlbHNlIGlmIChvcHQuZ3ppcCAmJiAob3B0LndpbmRvd0JpdHMgPiAwKSAmJiAob3B0LndpbmRvd0JpdHMgPCAxNikpIHtcbiAgICBvcHQud2luZG93Qml0cyArPSAxNjtcbiAgfVxuXG4gIHRoaXMuZXJyICAgID0gMDsgICAgICAvLyBlcnJvciBjb2RlLCBpZiBoYXBwZW5zICgwID0gWl9PSylcbiAgdGhpcy5tc2cgICAgPSAnJzsgICAgIC8vIGVycm9yIG1lc3NhZ2VcbiAgdGhpcy5lbmRlZCAgPSBmYWxzZTsgIC8vIHVzZWQgdG8gYXZvaWQgbXVsdGlwbGUgb25FbmQoKSBjYWxsc1xuICB0aGlzLmNodW5rcyA9IFtdOyAgICAgLy8gY2h1bmtzIG9mIGNvbXByZXNzZWQgZGF0YVxuXG4gIHRoaXMuc3RybSA9IG5ldyBaU3RyZWFtKCk7XG4gIHRoaXMuc3RybS5hdmFpbF9vdXQgPSAwO1xuXG4gIHZhciBzdGF0dXMgPSB6bGliX2RlZmxhdGUuZGVmbGF0ZUluaXQyKFxuICAgIHRoaXMuc3RybSxcbiAgICBvcHQubGV2ZWwsXG4gICAgb3B0Lm1ldGhvZCxcbiAgICBvcHQud2luZG93Qml0cyxcbiAgICBvcHQubWVtTGV2ZWwsXG4gICAgb3B0LnN0cmF0ZWd5XG4gICk7XG5cbiAgaWYgKHN0YXR1cyAhPT0gWl9PSykge1xuICAgIHRocm93IG5ldyBFcnJvcihtc2dbc3RhdHVzXSk7XG4gIH1cblxuICBpZiAob3B0LmhlYWRlcikge1xuICAgIHpsaWJfZGVmbGF0ZS5kZWZsYXRlU2V0SGVhZGVyKHRoaXMuc3RybSwgb3B0LmhlYWRlcik7XG4gIH1cblxuICBpZiAob3B0LmRpY3Rpb25hcnkpIHtcbiAgICB2YXIgZGljdDtcbiAgICAvLyBDb252ZXJ0IGRhdGEgaWYgbmVlZGVkXG4gICAgaWYgKHR5cGVvZiBvcHQuZGljdGlvbmFyeSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIC8vIElmIHdlIG5lZWQgdG8gY29tcHJlc3MgdGV4dCwgY2hhbmdlIGVuY29kaW5nIHRvIHV0ZjguXG4gICAgICBkaWN0ID0gc3RyaW5ncy5zdHJpbmcyYnVmKG9wdC5kaWN0aW9uYXJ5KTtcbiAgICB9IGVsc2UgaWYgKHRvU3RyaW5nLmNhbGwob3B0LmRpY3Rpb25hcnkpID09PSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nKSB7XG4gICAgICBkaWN0ID0gbmV3IFVpbnQ4QXJyYXkob3B0LmRpY3Rpb25hcnkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkaWN0ID0gb3B0LmRpY3Rpb25hcnk7XG4gICAgfVxuXG4gICAgc3RhdHVzID0gemxpYl9kZWZsYXRlLmRlZmxhdGVTZXREaWN0aW9uYXJ5KHRoaXMuc3RybSwgZGljdCk7XG5cbiAgICBpZiAoc3RhdHVzICE9PSBaX09LKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IobXNnW3N0YXR1c10pO1xuICAgIH1cblxuICAgIHRoaXMuX2RpY3Rfc2V0ID0gdHJ1ZTtcbiAgfVxufVxuXG4vKipcbiAqIERlZmxhdGUjcHVzaChkYXRhWywgbW9kZV0pIC0+IEJvb2xlYW5cbiAqIC0gZGF0YSAoVWludDhBcnJheXxBcnJheXxBcnJheUJ1ZmZlcnxTdHJpbmcpOiBpbnB1dCBkYXRhLiBTdHJpbmdzIHdpbGwgYmVcbiAqICAgY29udmVydGVkIHRvIHV0ZjggYnl0ZSBzZXF1ZW5jZS5cbiAqIC0gbW9kZSAoTnVtYmVyfEJvb2xlYW4pOiAwLi42IGZvciBjb3JyZXNwb25kaW5nIFpfTk9fRkxVU0guLlpfVFJFRSBtb2Rlcy5cbiAqICAgU2VlIGNvbnN0YW50cy4gU2tpcHBlZCBvciBgZmFsc2VgIG1lYW5zIFpfTk9fRkxVU0gsIGB0cnVlYCBtZWFuc2ggWl9GSU5JU0guXG4gKlxuICogU2VuZHMgaW5wdXQgZGF0YSB0byBkZWZsYXRlIHBpcGUsIGdlbmVyYXRpbmcgW1tEZWZsYXRlI29uRGF0YV1dIGNhbGxzIHdpdGhcbiAqIG5ldyBjb21wcmVzc2VkIGNodW5rcy4gUmV0dXJucyBgdHJ1ZWAgb24gc3VjY2Vzcy4gVGhlIGxhc3QgZGF0YSBibG9jayBtdXN0IGhhdmVcbiAqIG1vZGUgWl9GSU5JU0ggKG9yIGB0cnVlYCkuIFRoYXQgd2lsbCBmbHVzaCBpbnRlcm5hbCBwZW5kaW5nIGJ1ZmZlcnMgYW5kIGNhbGxcbiAqIFtbRGVmbGF0ZSNvbkVuZF1dLiBGb3IgaW50ZXJpbSBleHBsaWNpdCBmbHVzaGVzICh3aXRob3V0IGVuZGluZyB0aGUgc3RyZWFtKSB5b3VcbiAqIGNhbiB1c2UgbW9kZSBaX1NZTkNfRkxVU0gsIGtlZXBpbmcgdGhlIGNvbXByZXNzaW9uIGNvbnRleHQuXG4gKlxuICogT24gZmFpbCBjYWxsIFtbRGVmbGF0ZSNvbkVuZF1dIHdpdGggZXJyb3IgY29kZSBhbmQgcmV0dXJuIGZhbHNlLlxuICpcbiAqIFdlIHN0cm9uZ2x5IHJlY29tbWVuZCB0byB1c2UgYFVpbnQ4QXJyYXlgIG9uIGlucHV0IGZvciBiZXN0IHNwZWVkIChvdXRwdXRcbiAqIGFycmF5IGZvcm1hdCBpcyBkZXRlY3RlZCBhdXRvbWF0aWNhbGx5KS4gQWxzbywgZG9uJ3Qgc2tpcCBsYXN0IHBhcmFtIGFuZCBhbHdheXNcbiAqIHVzZSB0aGUgc2FtZSB0eXBlIGluIHlvdXIgY29kZSAoYm9vbGVhbiBvciBudW1iZXIpLiBUaGF0IHdpbGwgaW1wcm92ZSBKUyBzcGVlZC5cbiAqXG4gKiBGb3IgcmVndWxhciBgQXJyYXlgLXMgbWFrZSBzdXJlIGFsbCBlbGVtZW50cyBhcmUgWzAuLjI1NV0uXG4gKlxuICogIyMjIyMgRXhhbXBsZVxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIHB1c2goY2h1bmssIGZhbHNlKTsgLy8gcHVzaCBvbmUgb2YgZGF0YSBjaHVua3NcbiAqIC4uLlxuICogcHVzaChjaHVuaywgdHJ1ZSk7ICAvLyBwdXNoIGxhc3QgY2h1bmtcbiAqIGBgYFxuICoqL1xuRGVmbGF0ZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChkYXRhLCBtb2RlKSB7XG4gIHZhciBzdHJtID0gdGhpcy5zdHJtO1xuICB2YXIgY2h1bmtTaXplID0gdGhpcy5vcHRpb25zLmNodW5rU2l6ZTtcbiAgdmFyIHN0YXR1cywgX21vZGU7XG5cbiAgaWYgKHRoaXMuZW5kZWQpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgX21vZGUgPSAobW9kZSA9PT0gfn5tb2RlKSA/IG1vZGUgOiAoKG1vZGUgPT09IHRydWUpID8gWl9GSU5JU0ggOiBaX05PX0ZMVVNIKTtcblxuICAvLyBDb252ZXJ0IGRhdGEgaWYgbmVlZGVkXG4gIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAvLyBJZiB3ZSBuZWVkIHRvIGNvbXByZXNzIHRleHQsIGNoYW5nZSBlbmNvZGluZyB0byB1dGY4LlxuICAgIHN0cm0uaW5wdXQgPSBzdHJpbmdzLnN0cmluZzJidWYoZGF0YSk7XG4gIH0gZWxzZSBpZiAodG9TdHJpbmcuY2FsbChkYXRhKSA9PT0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJykge1xuICAgIHN0cm0uaW5wdXQgPSBuZXcgVWludDhBcnJheShkYXRhKTtcbiAgfSBlbHNlIHtcbiAgICBzdHJtLmlucHV0ID0gZGF0YTtcbiAgfVxuXG4gIHN0cm0ubmV4dF9pbiA9IDA7XG4gIHN0cm0uYXZhaWxfaW4gPSBzdHJtLmlucHV0Lmxlbmd0aDtcblxuICBkbyB7XG4gICAgaWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICBzdHJtLm91dHB1dCA9IG5ldyB1dGlscy5CdWY4KGNodW5rU2l6ZSk7XG4gICAgICBzdHJtLm5leHRfb3V0ID0gMDtcbiAgICAgIHN0cm0uYXZhaWxfb3V0ID0gY2h1bmtTaXplO1xuICAgIH1cbiAgICBzdGF0dXMgPSB6bGliX2RlZmxhdGUuZGVmbGF0ZShzdHJtLCBfbW9kZSk7ICAgIC8qIG5vIGJhZCByZXR1cm4gdmFsdWUgKi9cblxuICAgIGlmIChzdGF0dXMgIT09IFpfU1RSRUFNX0VORCAmJiBzdGF0dXMgIT09IFpfT0spIHtcbiAgICAgIHRoaXMub25FbmQoc3RhdHVzKTtcbiAgICAgIHRoaXMuZW5kZWQgPSB0cnVlO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoc3RybS5hdmFpbF9vdXQgPT09IDAgfHwgKHN0cm0uYXZhaWxfaW4gPT09IDAgJiYgKF9tb2RlID09PSBaX0ZJTklTSCB8fCBfbW9kZSA9PT0gWl9TWU5DX0ZMVVNIKSkpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMudG8gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRoaXMub25EYXRhKHN0cmluZ3MuYnVmMmJpbnN0cmluZyh1dGlscy5zaHJpbmtCdWYoc3RybS5vdXRwdXQsIHN0cm0ubmV4dF9vdXQpKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm9uRGF0YSh1dGlscy5zaHJpbmtCdWYoc3RybS5vdXRwdXQsIHN0cm0ubmV4dF9vdXQpKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gd2hpbGUgKChzdHJtLmF2YWlsX2luID4gMCB8fCBzdHJtLmF2YWlsX291dCA9PT0gMCkgJiYgc3RhdHVzICE9PSBaX1NUUkVBTV9FTkQpO1xuXG4gIC8vIEZpbmFsaXplIG9uIHRoZSBsYXN0IGNodW5rLlxuICBpZiAoX21vZGUgPT09IFpfRklOSVNIKSB7XG4gICAgc3RhdHVzID0gemxpYl9kZWZsYXRlLmRlZmxhdGVFbmQodGhpcy5zdHJtKTtcbiAgICB0aGlzLm9uRW5kKHN0YXR1cyk7XG4gICAgdGhpcy5lbmRlZCA9IHRydWU7XG4gICAgcmV0dXJuIHN0YXR1cyA9PT0gWl9PSztcbiAgfVxuXG4gIC8vIGNhbGxiYWNrIGludGVyaW0gcmVzdWx0cyBpZiBaX1NZTkNfRkxVU0guXG4gIGlmIChfbW9kZSA9PT0gWl9TWU5DX0ZMVVNIKSB7XG4gICAgdGhpcy5vbkVuZChaX09LKTtcbiAgICBzdHJtLmF2YWlsX291dCA9IDA7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cblxuLyoqXG4gKiBEZWZsYXRlI29uRGF0YShjaHVuaykgLT4gVm9pZFxuICogLSBjaHVuayAoVWludDhBcnJheXxBcnJheXxTdHJpbmcpOiBvdXB1dCBkYXRhLiBUeXBlIG9mIGFycmF5IGRlcGVuZHNcbiAqICAgb24ganMgZW5naW5lIHN1cHBvcnQuIFdoZW4gc3RyaW5nIG91dHB1dCByZXF1ZXN0ZWQsIGVhY2ggY2h1bmtcbiAqICAgd2lsbCBiZSBzdHJpbmcuXG4gKlxuICogQnkgZGVmYXVsdCwgc3RvcmVzIGRhdGEgYmxvY2tzIGluIGBjaHVua3NbXWAgcHJvcGVydHkgYW5kIGdsdWVcbiAqIHRob3NlIGluIGBvbkVuZGAuIE92ZXJyaWRlIHRoaXMgaGFuZGxlciwgaWYgeW91IG5lZWQgYW5vdGhlciBiZWhhdmlvdXIuXG4gKiovXG5EZWZsYXRlLnByb3RvdHlwZS5vbkRhdGEgPSBmdW5jdGlvbiAoY2h1bmspIHtcbiAgdGhpcy5jaHVua3MucHVzaChjaHVuayk7XG59O1xuXG5cbi8qKlxuICogRGVmbGF0ZSNvbkVuZChzdGF0dXMpIC0+IFZvaWRcbiAqIC0gc3RhdHVzIChOdW1iZXIpOiBkZWZsYXRlIHN0YXR1cy4gMCAoWl9PSykgb24gc3VjY2VzcyxcbiAqICAgb3RoZXIgaWYgbm90LlxuICpcbiAqIENhbGxlZCBvbmNlIGFmdGVyIHlvdSB0ZWxsIGRlZmxhdGUgdGhhdCB0aGUgaW5wdXQgc3RyZWFtIGlzXG4gKiBjb21wbGV0ZSAoWl9GSU5JU0gpIG9yIHNob3VsZCBiZSBmbHVzaGVkIChaX1NZTkNfRkxVU0gpXG4gKiBvciBpZiBhbiBlcnJvciBoYXBwZW5lZC4gQnkgZGVmYXVsdCAtIGpvaW4gY29sbGVjdGVkIGNodW5rcyxcbiAqIGZyZWUgbWVtb3J5IGFuZCBmaWxsIGByZXN1bHRzYCAvIGBlcnJgIHByb3BlcnRpZXMuXG4gKiovXG5EZWZsYXRlLnByb3RvdHlwZS5vbkVuZCA9IGZ1bmN0aW9uIChzdGF0dXMpIHtcbiAgLy8gT24gc3VjY2VzcyAtIGpvaW5cbiAgaWYgKHN0YXR1cyA9PT0gWl9PSykge1xuICAgIGlmICh0aGlzLm9wdGlvbnMudG8gPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aGlzLnJlc3VsdCA9IHRoaXMuY2h1bmtzLmpvaW4oJycpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJlc3VsdCA9IHV0aWxzLmZsYXR0ZW5DaHVua3ModGhpcy5jaHVua3MpO1xuICAgIH1cbiAgfVxuICB0aGlzLmNodW5rcyA9IFtdO1xuICB0aGlzLmVyciA9IHN0YXR1cztcbiAgdGhpcy5tc2cgPSB0aGlzLnN0cm0ubXNnO1xufTtcblxuXG4vKipcbiAqIGRlZmxhdGUoZGF0YVssIG9wdGlvbnNdKSAtPiBVaW50OEFycmF5fEFycmF5fFN0cmluZ1xuICogLSBkYXRhIChVaW50OEFycmF5fEFycmF5fFN0cmluZyk6IGlucHV0IGRhdGEgdG8gY29tcHJlc3MuXG4gKiAtIG9wdGlvbnMgKE9iamVjdCk6IHpsaWIgZGVmbGF0ZSBvcHRpb25zLlxuICpcbiAqIENvbXByZXNzIGBkYXRhYCB3aXRoIGRlZmxhdGUgYWxnb3JpdGhtIGFuZCBgb3B0aW9uc2AuXG4gKlxuICogU3VwcG9ydGVkIG9wdGlvbnMgYXJlOlxuICpcbiAqIC0gbGV2ZWxcbiAqIC0gd2luZG93Qml0c1xuICogLSBtZW1MZXZlbFxuICogLSBzdHJhdGVneVxuICogLSBkaWN0aW9uYXJ5XG4gKlxuICogW2h0dHA6Ly96bGliLm5ldC9tYW51YWwuaHRtbCNBZHZhbmNlZF0oaHR0cDovL3psaWIubmV0L21hbnVhbC5odG1sI0FkdmFuY2VkKVxuICogZm9yIG1vcmUgaW5mb3JtYXRpb24gb24gdGhlc2UuXG4gKlxuICogU3VnYXIgKG9wdGlvbnMpOlxuICpcbiAqIC0gYHJhd2AgKEJvb2xlYW4pIC0gc2F5IHRoYXQgd2Ugd29yayB3aXRoIHJhdyBzdHJlYW0sIGlmIHlvdSBkb24ndCB3aXNoIHRvIHNwZWNpZnlcbiAqICAgbmVnYXRpdmUgd2luZG93Qml0cyBpbXBsaWNpdGx5LlxuICogLSBgdG9gIChTdHJpbmcpIC0gaWYgZXF1YWwgdG8gJ3N0cmluZycsIHRoZW4gcmVzdWx0IHdpbGwgYmUgXCJiaW5hcnkgc3RyaW5nXCJcbiAqICAgIChlYWNoIGNoYXIgY29kZSBbMC4uMjU1XSlcbiAqXG4gKiAjIyMjIyBFeGFtcGxlOlxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIHZhciBwYWtvID0gcmVxdWlyZSgncGFrbycpXG4gKiAgICwgZGF0YSA9IFVpbnQ4QXJyYXkoWzEsMiwzLDQsNSw2LDcsOCw5XSk7XG4gKlxuICogY29uc29sZS5sb2cocGFrby5kZWZsYXRlKGRhdGEpKTtcbiAqIGBgYFxuICoqL1xuZnVuY3Rpb24gZGVmbGF0ZShpbnB1dCwgb3B0aW9ucykge1xuICB2YXIgZGVmbGF0b3IgPSBuZXcgRGVmbGF0ZShvcHRpb25zKTtcblxuICBkZWZsYXRvci5wdXNoKGlucHV0LCB0cnVlKTtcblxuICAvLyBUaGF0IHdpbGwgbmV2ZXIgaGFwcGVucywgaWYgeW91IGRvbid0IGNoZWF0IHdpdGggb3B0aW9ucyA6KVxuICBpZiAoZGVmbGF0b3IuZXJyKSB7IHRocm93IGRlZmxhdG9yLm1zZzsgfVxuXG4gIHJldHVybiBkZWZsYXRvci5yZXN1bHQ7XG59XG5cblxuLyoqXG4gKiBkZWZsYXRlUmF3KGRhdGFbLCBvcHRpb25zXSkgLT4gVWludDhBcnJheXxBcnJheXxTdHJpbmdcbiAqIC0gZGF0YSAoVWludDhBcnJheXxBcnJheXxTdHJpbmcpOiBpbnB1dCBkYXRhIHRvIGNvbXByZXNzLlxuICogLSBvcHRpb25zIChPYmplY3QpOiB6bGliIGRlZmxhdGUgb3B0aW9ucy5cbiAqXG4gKiBUaGUgc2FtZSBhcyBbW2RlZmxhdGVdXSwgYnV0IGNyZWF0ZXMgcmF3IGRhdGEsIHdpdGhvdXQgd3JhcHBlclxuICogKGhlYWRlciBhbmQgYWRsZXIzMiBjcmMpLlxuICoqL1xuZnVuY3Rpb24gZGVmbGF0ZVJhdyhpbnB1dCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgb3B0aW9ucy5yYXcgPSB0cnVlO1xuICByZXR1cm4gZGVmbGF0ZShpbnB1dCwgb3B0aW9ucyk7XG59XG5cblxuLyoqXG4gKiBnemlwKGRhdGFbLCBvcHRpb25zXSkgLT4gVWludDhBcnJheXxBcnJheXxTdHJpbmdcbiAqIC0gZGF0YSAoVWludDhBcnJheXxBcnJheXxTdHJpbmcpOiBpbnB1dCBkYXRhIHRvIGNvbXByZXNzLlxuICogLSBvcHRpb25zIChPYmplY3QpOiB6bGliIGRlZmxhdGUgb3B0aW9ucy5cbiAqXG4gKiBUaGUgc2FtZSBhcyBbW2RlZmxhdGVdXSwgYnV0IGNyZWF0ZSBnemlwIHdyYXBwZXIgaW5zdGVhZCBvZlxuICogZGVmbGF0ZSBvbmUuXG4gKiovXG5mdW5jdGlvbiBnemlwKGlucHV0LCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBvcHRpb25zLmd6aXAgPSB0cnVlO1xuICByZXR1cm4gZGVmbGF0ZShpbnB1dCwgb3B0aW9ucyk7XG59XG5cblxuZXhwb3J0cy5EZWZsYXRlID0gRGVmbGF0ZTtcbmV4cG9ydHMuZGVmbGF0ZSA9IGRlZmxhdGU7XG5leHBvcnRzLmRlZmxhdGVSYXcgPSBkZWZsYXRlUmF3O1xuZXhwb3J0cy5nemlwID0gZ3ppcDtcbiIsIid1c2Ugc3RyaWN0JztcblxuXG52YXIgemxpYl9pbmZsYXRlID0gcmVxdWlyZSgnLi96bGliL2luZmxhdGUnKTtcbnZhciB1dGlscyAgICAgICAgPSByZXF1aXJlKCcuL3V0aWxzL2NvbW1vbicpO1xudmFyIHN0cmluZ3MgICAgICA9IHJlcXVpcmUoJy4vdXRpbHMvc3RyaW5ncycpO1xudmFyIGMgICAgICAgICAgICA9IHJlcXVpcmUoJy4vemxpYi9jb25zdGFudHMnKTtcbnZhciBtc2cgICAgICAgICAgPSByZXF1aXJlKCcuL3psaWIvbWVzc2FnZXMnKTtcbnZhciBaU3RyZWFtICAgICAgPSByZXF1aXJlKCcuL3psaWIvenN0cmVhbScpO1xudmFyIEdaaGVhZGVyICAgICA9IHJlcXVpcmUoJy4vemxpYi9nemhlYWRlcicpO1xuXG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG4vKipcbiAqIGNsYXNzIEluZmxhdGVcbiAqXG4gKiBHZW5lcmljIEpTLXN0eWxlIHdyYXBwZXIgZm9yIHpsaWIgY2FsbHMuIElmIHlvdSBkb24ndCBuZWVkXG4gKiBzdHJlYW1pbmcgYmVoYXZpb3VyIC0gdXNlIG1vcmUgc2ltcGxlIGZ1bmN0aW9uczogW1tpbmZsYXRlXV1cbiAqIGFuZCBbW2luZmxhdGVSYXddXS5cbiAqKi9cblxuLyogaW50ZXJuYWxcbiAqIGluZmxhdGUuY2h1bmtzIC0+IEFycmF5XG4gKlxuICogQ2h1bmtzIG9mIG91dHB1dCBkYXRhLCBpZiBbW0luZmxhdGUjb25EYXRhXV0gbm90IG92ZXJyaWRlbi5cbiAqKi9cblxuLyoqXG4gKiBJbmZsYXRlLnJlc3VsdCAtPiBVaW50OEFycmF5fEFycmF5fFN0cmluZ1xuICpcbiAqIFVuY29tcHJlc3NlZCByZXN1bHQsIGdlbmVyYXRlZCBieSBkZWZhdWx0IFtbSW5mbGF0ZSNvbkRhdGFdXVxuICogYW5kIFtbSW5mbGF0ZSNvbkVuZF1dIGhhbmRsZXJzLiBGaWxsZWQgYWZ0ZXIgeW91IHB1c2ggbGFzdCBjaHVua1xuICogKGNhbGwgW1tJbmZsYXRlI3B1c2hdXSB3aXRoIGBaX0ZJTklTSGAgLyBgdHJ1ZWAgcGFyYW0pIG9yIGlmIHlvdVxuICogcHVzaCBhIGNodW5rIHdpdGggZXhwbGljaXQgZmx1c2ggKGNhbGwgW1tJbmZsYXRlI3B1c2hdXSB3aXRoXG4gKiBgWl9TWU5DX0ZMVVNIYCBwYXJhbSkuXG4gKiovXG5cbi8qKlxuICogSW5mbGF0ZS5lcnIgLT4gTnVtYmVyXG4gKlxuICogRXJyb3IgY29kZSBhZnRlciBpbmZsYXRlIGZpbmlzaGVkLiAwIChaX09LKSBvbiBzdWNjZXNzLlxuICogU2hvdWxkIGJlIGNoZWNrZWQgaWYgYnJva2VuIGRhdGEgcG9zc2libGUuXG4gKiovXG5cbi8qKlxuICogSW5mbGF0ZS5tc2cgLT4gU3RyaW5nXG4gKlxuICogRXJyb3IgbWVzc2FnZSwgaWYgW1tJbmZsYXRlLmVycl1dICE9IDBcbiAqKi9cblxuXG4vKipcbiAqIG5ldyBJbmZsYXRlKG9wdGlvbnMpXG4gKiAtIG9wdGlvbnMgKE9iamVjdCk6IHpsaWIgaW5mbGF0ZSBvcHRpb25zLlxuICpcbiAqIENyZWF0ZXMgbmV3IGluZmxhdG9yIGluc3RhbmNlIHdpdGggc3BlY2lmaWVkIHBhcmFtcy4gVGhyb3dzIGV4Y2VwdGlvblxuICogb24gYmFkIHBhcmFtcy4gU3VwcG9ydGVkIG9wdGlvbnM6XG4gKlxuICogLSBgd2luZG93Qml0c2BcbiAqIC0gYGRpY3Rpb25hcnlgXG4gKlxuICogW2h0dHA6Ly96bGliLm5ldC9tYW51YWwuaHRtbCNBZHZhbmNlZF0oaHR0cDovL3psaWIubmV0L21hbnVhbC5odG1sI0FkdmFuY2VkKVxuICogZm9yIG1vcmUgaW5mb3JtYXRpb24gb24gdGhlc2UuXG4gKlxuICogQWRkaXRpb25hbCBvcHRpb25zLCBmb3IgaW50ZXJuYWwgbmVlZHM6XG4gKlxuICogLSBgY2h1bmtTaXplYCAtIHNpemUgb2YgZ2VuZXJhdGVkIGRhdGEgY2h1bmtzICgxNksgYnkgZGVmYXVsdClcbiAqIC0gYHJhd2AgKEJvb2xlYW4pIC0gZG8gcmF3IGluZmxhdGVcbiAqIC0gYHRvYCAoU3RyaW5nKSAtIGlmIGVxdWFsIHRvICdzdHJpbmcnLCB0aGVuIHJlc3VsdCB3aWxsIGJlIGNvbnZlcnRlZFxuICogICBmcm9tIHV0ZjggdG8gdXRmMTYgKGphdmFzY3JpcHQpIHN0cmluZy4gV2hlbiBzdHJpbmcgb3V0cHV0IHJlcXVlc3RlZCxcbiAqICAgY2h1bmsgbGVuZ3RoIGNhbiBkaWZmZXIgZnJvbSBgY2h1bmtTaXplYCwgZGVwZW5kaW5nIG9uIGNvbnRlbnQuXG4gKlxuICogQnkgZGVmYXVsdCwgd2hlbiBubyBvcHRpb25zIHNldCwgYXV0b2RldGVjdCBkZWZsYXRlL2d6aXAgZGF0YSBmb3JtYXQgdmlhXG4gKiB3cmFwcGVyIGhlYWRlci5cbiAqXG4gKiAjIyMjIyBFeGFtcGxlOlxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIHZhciBwYWtvID0gcmVxdWlyZSgncGFrbycpXG4gKiAgICwgY2h1bmsxID0gVWludDhBcnJheShbMSwyLDMsNCw1LDYsNyw4LDldKVxuICogICAsIGNodW5rMiA9IFVpbnQ4QXJyYXkoWzEwLDExLDEyLDEzLDE0LDE1LDE2LDE3LDE4LDE5XSk7XG4gKlxuICogdmFyIGluZmxhdGUgPSBuZXcgcGFrby5JbmZsYXRlKHsgbGV2ZWw6IDN9KTtcbiAqXG4gKiBpbmZsYXRlLnB1c2goY2h1bmsxLCBmYWxzZSk7XG4gKiBpbmZsYXRlLnB1c2goY2h1bmsyLCB0cnVlKTsgIC8vIHRydWUgLT4gbGFzdCBjaHVua1xuICpcbiAqIGlmIChpbmZsYXRlLmVycikgeyB0aHJvdyBuZXcgRXJyb3IoaW5mbGF0ZS5lcnIpOyB9XG4gKlxuICogY29uc29sZS5sb2coaW5mbGF0ZS5yZXN1bHQpO1xuICogYGBgXG4gKiovXG5mdW5jdGlvbiBJbmZsYXRlKG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEluZmxhdGUpKSByZXR1cm4gbmV3IEluZmxhdGUob3B0aW9ucyk7XG5cbiAgdGhpcy5vcHRpb25zID0gdXRpbHMuYXNzaWduKHtcbiAgICBjaHVua1NpemU6IDE2Mzg0LFxuICAgIHdpbmRvd0JpdHM6IDAsXG4gICAgdG86ICcnXG4gIH0sIG9wdGlvbnMgfHwge30pO1xuXG4gIHZhciBvcHQgPSB0aGlzLm9wdGlvbnM7XG5cbiAgLy8gRm9yY2Ugd2luZG93IHNpemUgZm9yIGByYXdgIGRhdGEsIGlmIG5vdCBzZXQgZGlyZWN0bHksXG4gIC8vIGJlY2F1c2Ugd2UgaGF2ZSBubyBoZWFkZXIgZm9yIGF1dG9kZXRlY3QuXG4gIGlmIChvcHQucmF3ICYmIChvcHQud2luZG93Qml0cyA+PSAwKSAmJiAob3B0LndpbmRvd0JpdHMgPCAxNikpIHtcbiAgICBvcHQud2luZG93Qml0cyA9IC1vcHQud2luZG93Qml0cztcbiAgICBpZiAob3B0LndpbmRvd0JpdHMgPT09IDApIHsgb3B0LndpbmRvd0JpdHMgPSAtMTU7IH1cbiAgfVxuXG4gIC8vIElmIGB3aW5kb3dCaXRzYCBub3QgZGVmaW5lZCAoYW5kIG1vZGUgbm90IHJhdykgLSBzZXQgYXV0b2RldGVjdCBmbGFnIGZvciBnemlwL2RlZmxhdGVcbiAgaWYgKChvcHQud2luZG93Qml0cyA+PSAwKSAmJiAob3B0LndpbmRvd0JpdHMgPCAxNikgJiZcbiAgICAgICEob3B0aW9ucyAmJiBvcHRpb25zLndpbmRvd0JpdHMpKSB7XG4gICAgb3B0LndpbmRvd0JpdHMgKz0gMzI7XG4gIH1cblxuICAvLyBHemlwIGhlYWRlciBoYXMgbm8gaW5mbyBhYm91dCB3aW5kb3dzIHNpemUsIHdlIGNhbiBkbyBhdXRvZGV0ZWN0IG9ubHlcbiAgLy8gZm9yIGRlZmxhdGUuIFNvLCBpZiB3aW5kb3cgc2l6ZSBub3Qgc2V0LCBmb3JjZSBpdCB0byBtYXggd2hlbiBnemlwIHBvc3NpYmxlXG4gIGlmICgob3B0LndpbmRvd0JpdHMgPiAxNSkgJiYgKG9wdC53aW5kb3dCaXRzIDwgNDgpKSB7XG4gICAgLy8gYml0IDMgKDE2KSAtPiBnemlwcGVkIGRhdGFcbiAgICAvLyBiaXQgNCAoMzIpIC0+IGF1dG9kZXRlY3QgZ3ppcC9kZWZsYXRlXG4gICAgaWYgKChvcHQud2luZG93Qml0cyAmIDE1KSA9PT0gMCkge1xuICAgICAgb3B0LndpbmRvd0JpdHMgfD0gMTU7XG4gICAgfVxuICB9XG5cbiAgdGhpcy5lcnIgICAgPSAwOyAgICAgIC8vIGVycm9yIGNvZGUsIGlmIGhhcHBlbnMgKDAgPSBaX09LKVxuICB0aGlzLm1zZyAgICA9ICcnOyAgICAgLy8gZXJyb3IgbWVzc2FnZVxuICB0aGlzLmVuZGVkICA9IGZhbHNlOyAgLy8gdXNlZCB0byBhdm9pZCBtdWx0aXBsZSBvbkVuZCgpIGNhbGxzXG4gIHRoaXMuY2h1bmtzID0gW107ICAgICAvLyBjaHVua3Mgb2YgY29tcHJlc3NlZCBkYXRhXG5cbiAgdGhpcy5zdHJtICAgPSBuZXcgWlN0cmVhbSgpO1xuICB0aGlzLnN0cm0uYXZhaWxfb3V0ID0gMDtcblxuICB2YXIgc3RhdHVzICA9IHpsaWJfaW5mbGF0ZS5pbmZsYXRlSW5pdDIoXG4gICAgdGhpcy5zdHJtLFxuICAgIG9wdC53aW5kb3dCaXRzXG4gICk7XG5cbiAgaWYgKHN0YXR1cyAhPT0gYy5aX09LKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKG1zZ1tzdGF0dXNdKTtcbiAgfVxuXG4gIHRoaXMuaGVhZGVyID0gbmV3IEdaaGVhZGVyKCk7XG5cbiAgemxpYl9pbmZsYXRlLmluZmxhdGVHZXRIZWFkZXIodGhpcy5zdHJtLCB0aGlzLmhlYWRlcik7XG59XG5cbi8qKlxuICogSW5mbGF0ZSNwdXNoKGRhdGFbLCBtb2RlXSkgLT4gQm9vbGVhblxuICogLSBkYXRhIChVaW50OEFycmF5fEFycmF5fEFycmF5QnVmZmVyfFN0cmluZyk6IGlucHV0IGRhdGFcbiAqIC0gbW9kZSAoTnVtYmVyfEJvb2xlYW4pOiAwLi42IGZvciBjb3JyZXNwb25kaW5nIFpfTk9fRkxVU0guLlpfVFJFRSBtb2Rlcy5cbiAqICAgU2VlIGNvbnN0YW50cy4gU2tpcHBlZCBvciBgZmFsc2VgIG1lYW5zIFpfTk9fRkxVU0gsIGB0cnVlYCBtZWFuc2ggWl9GSU5JU0guXG4gKlxuICogU2VuZHMgaW5wdXQgZGF0YSB0byBpbmZsYXRlIHBpcGUsIGdlbmVyYXRpbmcgW1tJbmZsYXRlI29uRGF0YV1dIGNhbGxzIHdpdGhcbiAqIG5ldyBvdXRwdXQgY2h1bmtzLiBSZXR1cm5zIGB0cnVlYCBvbiBzdWNjZXNzLiBUaGUgbGFzdCBkYXRhIGJsb2NrIG11c3QgaGF2ZVxuICogbW9kZSBaX0ZJTklTSCAob3IgYHRydWVgKS4gVGhhdCB3aWxsIGZsdXNoIGludGVybmFsIHBlbmRpbmcgYnVmZmVycyBhbmQgY2FsbFxuICogW1tJbmZsYXRlI29uRW5kXV0uIEZvciBpbnRlcmltIGV4cGxpY2l0IGZsdXNoZXMgKHdpdGhvdXQgZW5kaW5nIHRoZSBzdHJlYW0pIHlvdVxuICogY2FuIHVzZSBtb2RlIFpfU1lOQ19GTFVTSCwga2VlcGluZyB0aGUgZGVjb21wcmVzc2lvbiBjb250ZXh0LlxuICpcbiAqIE9uIGZhaWwgY2FsbCBbW0luZmxhdGUjb25FbmRdXSB3aXRoIGVycm9yIGNvZGUgYW5kIHJldHVybiBmYWxzZS5cbiAqXG4gKiBXZSBzdHJvbmdseSByZWNvbW1lbmQgdG8gdXNlIGBVaW50OEFycmF5YCBvbiBpbnB1dCBmb3IgYmVzdCBzcGVlZCAob3V0cHV0XG4gKiBmb3JtYXQgaXMgZGV0ZWN0ZWQgYXV0b21hdGljYWxseSkuIEFsc28sIGRvbid0IHNraXAgbGFzdCBwYXJhbSBhbmQgYWx3YXlzXG4gKiB1c2UgdGhlIHNhbWUgdHlwZSBpbiB5b3VyIGNvZGUgKGJvb2xlYW4gb3IgbnVtYmVyKS4gVGhhdCB3aWxsIGltcHJvdmUgSlMgc3BlZWQuXG4gKlxuICogRm9yIHJlZ3VsYXIgYEFycmF5YC1zIG1ha2Ugc3VyZSBhbGwgZWxlbWVudHMgYXJlIFswLi4yNTVdLlxuICpcbiAqICMjIyMjIEV4YW1wbGVcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBwdXNoKGNodW5rLCBmYWxzZSk7IC8vIHB1c2ggb25lIG9mIGRhdGEgY2h1bmtzXG4gKiAuLi5cbiAqIHB1c2goY2h1bmssIHRydWUpOyAgLy8gcHVzaCBsYXN0IGNodW5rXG4gKiBgYGBcbiAqKi9cbkluZmxhdGUucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoZGF0YSwgbW9kZSkge1xuICB2YXIgc3RybSA9IHRoaXMuc3RybTtcbiAgdmFyIGNodW5rU2l6ZSA9IHRoaXMub3B0aW9ucy5jaHVua1NpemU7XG4gIHZhciBkaWN0aW9uYXJ5ID0gdGhpcy5vcHRpb25zLmRpY3Rpb25hcnk7XG4gIHZhciBzdGF0dXMsIF9tb2RlO1xuICB2YXIgbmV4dF9vdXRfdXRmOCwgdGFpbCwgdXRmOHN0cjtcbiAgdmFyIGRpY3Q7XG5cbiAgLy8gRmxhZyB0byBwcm9wZXJseSBwcm9jZXNzIFpfQlVGX0VSUk9SIG9uIHRlc3RpbmcgaW5mbGF0ZSBjYWxsXG4gIC8vIHdoZW4gd2UgY2hlY2sgdGhhdCBhbGwgb3V0cHV0IGRhdGEgd2FzIGZsdXNoZWQuXG4gIHZhciBhbGxvd0J1ZkVycm9yID0gZmFsc2U7XG5cbiAgaWYgKHRoaXMuZW5kZWQpIHsgcmV0dXJuIGZhbHNlOyB9XG4gIF9tb2RlID0gKG1vZGUgPT09IH5+bW9kZSkgPyBtb2RlIDogKChtb2RlID09PSB0cnVlKSA/IGMuWl9GSU5JU0ggOiBjLlpfTk9fRkxVU0gpO1xuXG4gIC8vIENvbnZlcnQgZGF0YSBpZiBuZWVkZWRcbiAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgIC8vIE9ubHkgYmluYXJ5IHN0cmluZ3MgY2FuIGJlIGRlY29tcHJlc3NlZCBvbiBwcmFjdGljZVxuICAgIHN0cm0uaW5wdXQgPSBzdHJpbmdzLmJpbnN0cmluZzJidWYoZGF0YSk7XG4gIH0gZWxzZSBpZiAodG9TdHJpbmcuY2FsbChkYXRhKSA9PT0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJykge1xuICAgIHN0cm0uaW5wdXQgPSBuZXcgVWludDhBcnJheShkYXRhKTtcbiAgfSBlbHNlIHtcbiAgICBzdHJtLmlucHV0ID0gZGF0YTtcbiAgfVxuXG4gIHN0cm0ubmV4dF9pbiA9IDA7XG4gIHN0cm0uYXZhaWxfaW4gPSBzdHJtLmlucHV0Lmxlbmd0aDtcblxuICBkbyB7XG4gICAgaWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICBzdHJtLm91dHB1dCA9IG5ldyB1dGlscy5CdWY4KGNodW5rU2l6ZSk7XG4gICAgICBzdHJtLm5leHRfb3V0ID0gMDtcbiAgICAgIHN0cm0uYXZhaWxfb3V0ID0gY2h1bmtTaXplO1xuICAgIH1cblxuICAgIHN0YXR1cyA9IHpsaWJfaW5mbGF0ZS5pbmZsYXRlKHN0cm0sIGMuWl9OT19GTFVTSCk7ICAgIC8qIG5vIGJhZCByZXR1cm4gdmFsdWUgKi9cblxuICAgIGlmIChzdGF0dXMgPT09IGMuWl9ORUVEX0RJQ1QgJiYgZGljdGlvbmFyeSkge1xuICAgICAgLy8gQ29udmVydCBkYXRhIGlmIG5lZWRlZFxuICAgICAgaWYgKHR5cGVvZiBkaWN0aW9uYXJ5ID09PSAnc3RyaW5nJykge1xuICAgICAgICBkaWN0ID0gc3RyaW5ncy5zdHJpbmcyYnVmKGRpY3Rpb25hcnkpO1xuICAgICAgfSBlbHNlIGlmICh0b1N0cmluZy5jYWxsKGRpY3Rpb25hcnkpID09PSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nKSB7XG4gICAgICAgIGRpY3QgPSBuZXcgVWludDhBcnJheShkaWN0aW9uYXJ5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRpY3QgPSBkaWN0aW9uYXJ5O1xuICAgICAgfVxuXG4gICAgICBzdGF0dXMgPSB6bGliX2luZmxhdGUuaW5mbGF0ZVNldERpY3Rpb25hcnkodGhpcy5zdHJtLCBkaWN0KTtcblxuICAgIH1cblxuICAgIGlmIChzdGF0dXMgPT09IGMuWl9CVUZfRVJST1IgJiYgYWxsb3dCdWZFcnJvciA9PT0gdHJ1ZSkge1xuICAgICAgc3RhdHVzID0gYy5aX09LO1xuICAgICAgYWxsb3dCdWZFcnJvciA9IGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChzdGF0dXMgIT09IGMuWl9TVFJFQU1fRU5EICYmIHN0YXR1cyAhPT0gYy5aX09LKSB7XG4gICAgICB0aGlzLm9uRW5kKHN0YXR1cyk7XG4gICAgICB0aGlzLmVuZGVkID0gdHJ1ZTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoc3RybS5uZXh0X291dCkge1xuICAgICAgaWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwIHx8IHN0YXR1cyA9PT0gYy5aX1NUUkVBTV9FTkQgfHwgKHN0cm0uYXZhaWxfaW4gPT09IDAgJiYgKF9tb2RlID09PSBjLlpfRklOSVNIIHx8IF9tb2RlID09PSBjLlpfU1lOQ19GTFVTSCkpKSB7XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy50byA9PT0gJ3N0cmluZycpIHtcblxuICAgICAgICAgIG5leHRfb3V0X3V0ZjggPSBzdHJpbmdzLnV0Zjhib3JkZXIoc3RybS5vdXRwdXQsIHN0cm0ubmV4dF9vdXQpO1xuXG4gICAgICAgICAgdGFpbCA9IHN0cm0ubmV4dF9vdXQgLSBuZXh0X291dF91dGY4O1xuICAgICAgICAgIHV0ZjhzdHIgPSBzdHJpbmdzLmJ1ZjJzdHJpbmcoc3RybS5vdXRwdXQsIG5leHRfb3V0X3V0ZjgpO1xuXG4gICAgICAgICAgLy8gbW92ZSB0YWlsXG4gICAgICAgICAgc3RybS5uZXh0X291dCA9IHRhaWw7XG4gICAgICAgICAgc3RybS5hdmFpbF9vdXQgPSBjaHVua1NpemUgLSB0YWlsO1xuICAgICAgICAgIGlmICh0YWlsKSB7IHV0aWxzLmFycmF5U2V0KHN0cm0ub3V0cHV0LCBzdHJtLm91dHB1dCwgbmV4dF9vdXRfdXRmOCwgdGFpbCwgMCk7IH1cblxuICAgICAgICAgIHRoaXMub25EYXRhKHV0ZjhzdHIpO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5vbkRhdGEodXRpbHMuc2hyaW5rQnVmKHN0cm0ub3V0cHV0LCBzdHJtLm5leHRfb3V0KSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBXaGVuIG5vIG1vcmUgaW5wdXQgZGF0YSwgd2Ugc2hvdWxkIGNoZWNrIHRoYXQgaW50ZXJuYWwgaW5mbGF0ZSBidWZmZXJzXG4gICAgLy8gYXJlIGZsdXNoZWQuIFRoZSBvbmx5IHdheSB0byBkbyBpdCB3aGVuIGF2YWlsX291dCA9IDAgLSBydW4gb25lIG1vcmVcbiAgICAvLyBpbmZsYXRlIHBhc3MuIEJ1dCBpZiBvdXRwdXQgZGF0YSBub3QgZXhpc3RzLCBpbmZsYXRlIHJldHVybiBaX0JVRl9FUlJPUi5cbiAgICAvLyBIZXJlIHdlIHNldCBmbGFnIHRvIHByb2Nlc3MgdGhpcyBlcnJvciBwcm9wZXJseS5cbiAgICAvL1xuICAgIC8vIE5PVEUuIERlZmxhdGUgZG9lcyBub3QgcmV0dXJuIGVycm9yIGluIHRoaXMgY2FzZSBhbmQgZG9lcyBub3QgbmVlZHMgc3VjaFxuICAgIC8vIGxvZ2ljLlxuICAgIGlmIChzdHJtLmF2YWlsX2luID09PSAwICYmIHN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICBhbGxvd0J1ZkVycm9yID0gdHJ1ZTtcbiAgICB9XG5cbiAgfSB3aGlsZSAoKHN0cm0uYXZhaWxfaW4gPiAwIHx8IHN0cm0uYXZhaWxfb3V0ID09PSAwKSAmJiBzdGF0dXMgIT09IGMuWl9TVFJFQU1fRU5EKTtcblxuICBpZiAoc3RhdHVzID09PSBjLlpfU1RSRUFNX0VORCkge1xuICAgIF9tb2RlID0gYy5aX0ZJTklTSDtcbiAgfVxuXG4gIC8vIEZpbmFsaXplIG9uIHRoZSBsYXN0IGNodW5rLlxuICBpZiAoX21vZGUgPT09IGMuWl9GSU5JU0gpIHtcbiAgICBzdGF0dXMgPSB6bGliX2luZmxhdGUuaW5mbGF0ZUVuZCh0aGlzLnN0cm0pO1xuICAgIHRoaXMub25FbmQoc3RhdHVzKTtcbiAgICB0aGlzLmVuZGVkID0gdHJ1ZTtcbiAgICByZXR1cm4gc3RhdHVzID09PSBjLlpfT0s7XG4gIH1cblxuICAvLyBjYWxsYmFjayBpbnRlcmltIHJlc3VsdHMgaWYgWl9TWU5DX0ZMVVNILlxuICBpZiAoX21vZGUgPT09IGMuWl9TWU5DX0ZMVVNIKSB7XG4gICAgdGhpcy5vbkVuZChjLlpfT0spO1xuICAgIHN0cm0uYXZhaWxfb3V0ID0gMDtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuXG4vKipcbiAqIEluZmxhdGUjb25EYXRhKGNodW5rKSAtPiBWb2lkXG4gKiAtIGNodW5rIChVaW50OEFycmF5fEFycmF5fFN0cmluZyk6IG91cHV0IGRhdGEuIFR5cGUgb2YgYXJyYXkgZGVwZW5kc1xuICogICBvbiBqcyBlbmdpbmUgc3VwcG9ydC4gV2hlbiBzdHJpbmcgb3V0cHV0IHJlcXVlc3RlZCwgZWFjaCBjaHVua1xuICogICB3aWxsIGJlIHN0cmluZy5cbiAqXG4gKiBCeSBkZWZhdWx0LCBzdG9yZXMgZGF0YSBibG9ja3MgaW4gYGNodW5rc1tdYCBwcm9wZXJ0eSBhbmQgZ2x1ZVxuICogdGhvc2UgaW4gYG9uRW5kYC4gT3ZlcnJpZGUgdGhpcyBoYW5kbGVyLCBpZiB5b3UgbmVlZCBhbm90aGVyIGJlaGF2aW91ci5cbiAqKi9cbkluZmxhdGUucHJvdG90eXBlLm9uRGF0YSA9IGZ1bmN0aW9uIChjaHVuaykge1xuICB0aGlzLmNodW5rcy5wdXNoKGNodW5rKTtcbn07XG5cblxuLyoqXG4gKiBJbmZsYXRlI29uRW5kKHN0YXR1cykgLT4gVm9pZFxuICogLSBzdGF0dXMgKE51bWJlcik6IGluZmxhdGUgc3RhdHVzLiAwIChaX09LKSBvbiBzdWNjZXNzLFxuICogICBvdGhlciBpZiBub3QuXG4gKlxuICogQ2FsbGVkIGVpdGhlciBhZnRlciB5b3UgdGVsbCBpbmZsYXRlIHRoYXQgdGhlIGlucHV0IHN0cmVhbSBpc1xuICogY29tcGxldGUgKFpfRklOSVNIKSBvciBzaG91bGQgYmUgZmx1c2hlZCAoWl9TWU5DX0ZMVVNIKVxuICogb3IgaWYgYW4gZXJyb3IgaGFwcGVuZWQuIEJ5IGRlZmF1bHQgLSBqb2luIGNvbGxlY3RlZCBjaHVua3MsXG4gKiBmcmVlIG1lbW9yeSBhbmQgZmlsbCBgcmVzdWx0c2AgLyBgZXJyYCBwcm9wZXJ0aWVzLlxuICoqL1xuSW5mbGF0ZS5wcm90b3R5cGUub25FbmQgPSBmdW5jdGlvbiAoc3RhdHVzKSB7XG4gIC8vIE9uIHN1Y2Nlc3MgLSBqb2luXG4gIGlmIChzdGF0dXMgPT09IGMuWl9PSykge1xuICAgIGlmICh0aGlzLm9wdGlvbnMudG8gPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBHbHVlICYgY29udmVydCBoZXJlLCB1bnRpbCB3ZSB0ZWFjaCBwYWtvIHRvIHNlbmRcbiAgICAgIC8vIHV0ZjggYWxsaWduZWQgc3RyaW5ncyB0byBvbkRhdGFcbiAgICAgIHRoaXMucmVzdWx0ID0gdGhpcy5jaHVua3Muam9pbignJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVzdWx0ID0gdXRpbHMuZmxhdHRlbkNodW5rcyh0aGlzLmNodW5rcyk7XG4gICAgfVxuICB9XG4gIHRoaXMuY2h1bmtzID0gW107XG4gIHRoaXMuZXJyID0gc3RhdHVzO1xuICB0aGlzLm1zZyA9IHRoaXMuc3RybS5tc2c7XG59O1xuXG5cbi8qKlxuICogaW5mbGF0ZShkYXRhWywgb3B0aW9uc10pIC0+IFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nXG4gKiAtIGRhdGEgKFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nKTogaW5wdXQgZGF0YSB0byBkZWNvbXByZXNzLlxuICogLSBvcHRpb25zIChPYmplY3QpOiB6bGliIGluZmxhdGUgb3B0aW9ucy5cbiAqXG4gKiBEZWNvbXByZXNzIGBkYXRhYCB3aXRoIGluZmxhdGUvdW5nemlwIGFuZCBgb3B0aW9uc2AuIEF1dG9kZXRlY3RcbiAqIGZvcm1hdCB2aWEgd3JhcHBlciBoZWFkZXIgYnkgZGVmYXVsdC4gVGhhdCdzIHdoeSB3ZSBkb24ndCBwcm92aWRlXG4gKiBzZXBhcmF0ZSBgdW5nemlwYCBtZXRob2QuXG4gKlxuICogU3VwcG9ydGVkIG9wdGlvbnMgYXJlOlxuICpcbiAqIC0gd2luZG93Qml0c1xuICpcbiAqIFtodHRwOi8vemxpYi5uZXQvbWFudWFsLmh0bWwjQWR2YW5jZWRdKGh0dHA6Ly96bGliLm5ldC9tYW51YWwuaHRtbCNBZHZhbmNlZClcbiAqIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICpcbiAqIFN1Z2FyIChvcHRpb25zKTpcbiAqXG4gKiAtIGByYXdgIChCb29sZWFuKSAtIHNheSB0aGF0IHdlIHdvcmsgd2l0aCByYXcgc3RyZWFtLCBpZiB5b3UgZG9uJ3Qgd2lzaCB0byBzcGVjaWZ5XG4gKiAgIG5lZ2F0aXZlIHdpbmRvd0JpdHMgaW1wbGljaXRseS5cbiAqIC0gYHRvYCAoU3RyaW5nKSAtIGlmIGVxdWFsIHRvICdzdHJpbmcnLCB0aGVuIHJlc3VsdCB3aWxsIGJlIGNvbnZlcnRlZFxuICogICBmcm9tIHV0ZjggdG8gdXRmMTYgKGphdmFzY3JpcHQpIHN0cmluZy4gV2hlbiBzdHJpbmcgb3V0cHV0IHJlcXVlc3RlZCxcbiAqICAgY2h1bmsgbGVuZ3RoIGNhbiBkaWZmZXIgZnJvbSBgY2h1bmtTaXplYCwgZGVwZW5kaW5nIG9uIGNvbnRlbnQuXG4gKlxuICpcbiAqICMjIyMjIEV4YW1wbGU6XG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogdmFyIHBha28gPSByZXF1aXJlKCdwYWtvJylcbiAqICAgLCBpbnB1dCA9IHBha28uZGVmbGF0ZShbMSwyLDMsNCw1LDYsNyw4LDldKVxuICogICAsIG91dHB1dDtcbiAqXG4gKiB0cnkge1xuICogICBvdXRwdXQgPSBwYWtvLmluZmxhdGUoaW5wdXQpO1xuICogfSBjYXRjaCAoZXJyKVxuICogICBjb25zb2xlLmxvZyhlcnIpO1xuICogfVxuICogYGBgXG4gKiovXG5mdW5jdGlvbiBpbmZsYXRlKGlucHV0LCBvcHRpb25zKSB7XG4gIHZhciBpbmZsYXRvciA9IG5ldyBJbmZsYXRlKG9wdGlvbnMpO1xuXG4gIGluZmxhdG9yLnB1c2goaW5wdXQsIHRydWUpO1xuXG4gIC8vIFRoYXQgd2lsbCBuZXZlciBoYXBwZW5zLCBpZiB5b3UgZG9uJ3QgY2hlYXQgd2l0aCBvcHRpb25zIDopXG4gIGlmIChpbmZsYXRvci5lcnIpIHsgdGhyb3cgaW5mbGF0b3IubXNnOyB9XG5cbiAgcmV0dXJuIGluZmxhdG9yLnJlc3VsdDtcbn1cblxuXG4vKipcbiAqIGluZmxhdGVSYXcoZGF0YVssIG9wdGlvbnNdKSAtPiBVaW50OEFycmF5fEFycmF5fFN0cmluZ1xuICogLSBkYXRhIChVaW50OEFycmF5fEFycmF5fFN0cmluZyk6IGlucHV0IGRhdGEgdG8gZGVjb21wcmVzcy5cbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogemxpYiBpbmZsYXRlIG9wdGlvbnMuXG4gKlxuICogVGhlIHNhbWUgYXMgW1tpbmZsYXRlXV0sIGJ1dCBjcmVhdGVzIHJhdyBkYXRhLCB3aXRob3V0IHdyYXBwZXJcbiAqIChoZWFkZXIgYW5kIGFkbGVyMzIgY3JjKS5cbiAqKi9cbmZ1bmN0aW9uIGluZmxhdGVSYXcoaW5wdXQsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIG9wdGlvbnMucmF3ID0gdHJ1ZTtcbiAgcmV0dXJuIGluZmxhdGUoaW5wdXQsIG9wdGlvbnMpO1xufVxuXG5cbi8qKlxuICogdW5nemlwKGRhdGFbLCBvcHRpb25zXSkgLT4gVWludDhBcnJheXxBcnJheXxTdHJpbmdcbiAqIC0gZGF0YSAoVWludDhBcnJheXxBcnJheXxTdHJpbmcpOiBpbnB1dCBkYXRhIHRvIGRlY29tcHJlc3MuXG4gKiAtIG9wdGlvbnMgKE9iamVjdCk6IHpsaWIgaW5mbGF0ZSBvcHRpb25zLlxuICpcbiAqIEp1c3Qgc2hvcnRjdXQgdG8gW1tpbmZsYXRlXV0sIGJlY2F1c2UgaXQgYXV0b2RldGVjdHMgZm9ybWF0XG4gKiBieSBoZWFkZXIuY29udGVudC4gRG9uZSBmb3IgY29udmVuaWVuY2UuXG4gKiovXG5cblxuZXhwb3J0cy5JbmZsYXRlID0gSW5mbGF0ZTtcbmV4cG9ydHMuaW5mbGF0ZSA9IGluZmxhdGU7XG5leHBvcnRzLmluZmxhdGVSYXcgPSBpbmZsYXRlUmF3O1xuZXhwb3J0cy51bmd6aXAgID0gaW5mbGF0ZTtcbiIsIi8vIFN0cmluZyBlbmNvZGUvZGVjb2RlIGhlbHBlcnNcbid1c2Ugc3RyaWN0JztcblxuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL2NvbW1vbicpO1xuXG5cbi8vIFF1aWNrIGNoZWNrIGlmIHdlIGNhbiB1c2UgZmFzdCBhcnJheSB0byBiaW4gc3RyaW5nIGNvbnZlcnNpb25cbi8vXG4vLyAtIGFwcGx5KEFycmF5KSBjYW4gZmFpbCBvbiBBbmRyb2lkIDIuMlxuLy8gLSBhcHBseShVaW50OEFycmF5KSBjYW4gZmFpbCBvbiBpT1MgNS4xIFNhZmFyeVxuLy9cbnZhciBTVFJfQVBQTFlfT0sgPSB0cnVlO1xudmFyIFNUUl9BUFBMWV9VSUFfT0sgPSB0cnVlO1xuXG50cnkgeyBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIFsgMCBdKTsgfSBjYXRjaCAoX18pIHsgU1RSX0FQUExZX09LID0gZmFsc2U7IH1cbnRyeSB7IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgbmV3IFVpbnQ4QXJyYXkoMSkpOyB9IGNhdGNoIChfXykgeyBTVFJfQVBQTFlfVUlBX09LID0gZmFsc2U7IH1cblxuXG4vLyBUYWJsZSB3aXRoIHV0ZjggbGVuZ3RocyAoY2FsY3VsYXRlZCBieSBmaXJzdCBieXRlIG9mIHNlcXVlbmNlKVxuLy8gTm90ZSwgdGhhdCA1ICYgNi1ieXRlIHZhbHVlcyBhbmQgc29tZSA0LWJ5dGUgdmFsdWVzIGNhbiBub3QgYmUgcmVwcmVzZW50ZWQgaW4gSlMsXG4vLyBiZWNhdXNlIG1heCBwb3NzaWJsZSBjb2RlcG9pbnQgaXMgMHgxMGZmZmZcbnZhciBfdXRmOGxlbiA9IG5ldyB1dGlscy5CdWY4KDI1Nik7XG5mb3IgKHZhciBxID0gMDsgcSA8IDI1NjsgcSsrKSB7XG4gIF91dGY4bGVuW3FdID0gKHEgPj0gMjUyID8gNiA6IHEgPj0gMjQ4ID8gNSA6IHEgPj0gMjQwID8gNCA6IHEgPj0gMjI0ID8gMyA6IHEgPj0gMTkyID8gMiA6IDEpO1xufVxuX3V0ZjhsZW5bMjU0XSA9IF91dGY4bGVuWzI1NF0gPSAxOyAvLyBJbnZhbGlkIHNlcXVlbmNlIHN0YXJ0XG5cblxuLy8gY29udmVydCBzdHJpbmcgdG8gYXJyYXkgKHR5cGVkLCB3aGVuIHBvc3NpYmxlKVxuZXhwb3J0cy5zdHJpbmcyYnVmID0gZnVuY3Rpb24gKHN0cikge1xuICB2YXIgYnVmLCBjLCBjMiwgbV9wb3MsIGksIHN0cl9sZW4gPSBzdHIubGVuZ3RoLCBidWZfbGVuID0gMDtcblxuICAvLyBjb3VudCBiaW5hcnkgc2l6ZVxuICBmb3IgKG1fcG9zID0gMDsgbV9wb3MgPCBzdHJfbGVuOyBtX3BvcysrKSB7XG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KG1fcG9zKTtcbiAgICBpZiAoKGMgJiAweGZjMDApID09PSAweGQ4MDAgJiYgKG1fcG9zICsgMSA8IHN0cl9sZW4pKSB7XG4gICAgICBjMiA9IHN0ci5jaGFyQ29kZUF0KG1fcG9zICsgMSk7XG4gICAgICBpZiAoKGMyICYgMHhmYzAwKSA9PT0gMHhkYzAwKSB7XG4gICAgICAgIGMgPSAweDEwMDAwICsgKChjIC0gMHhkODAwKSA8PCAxMCkgKyAoYzIgLSAweGRjMDApO1xuICAgICAgICBtX3BvcysrO1xuICAgICAgfVxuICAgIH1cbiAgICBidWZfbGVuICs9IGMgPCAweDgwID8gMSA6IGMgPCAweDgwMCA/IDIgOiBjIDwgMHgxMDAwMCA/IDMgOiA0O1xuICB9XG5cbiAgLy8gYWxsb2NhdGUgYnVmZmVyXG4gIGJ1ZiA9IG5ldyB1dGlscy5CdWY4KGJ1Zl9sZW4pO1xuXG4gIC8vIGNvbnZlcnRcbiAgZm9yIChpID0gMCwgbV9wb3MgPSAwOyBpIDwgYnVmX2xlbjsgbV9wb3MrKykge1xuICAgIGMgPSBzdHIuY2hhckNvZGVBdChtX3Bvcyk7XG4gICAgaWYgKChjICYgMHhmYzAwKSA9PT0gMHhkODAwICYmIChtX3BvcyArIDEgPCBzdHJfbGVuKSkge1xuICAgICAgYzIgPSBzdHIuY2hhckNvZGVBdChtX3BvcyArIDEpO1xuICAgICAgaWYgKChjMiAmIDB4ZmMwMCkgPT09IDB4ZGMwMCkge1xuICAgICAgICBjID0gMHgxMDAwMCArICgoYyAtIDB4ZDgwMCkgPDwgMTApICsgKGMyIC0gMHhkYzAwKTtcbiAgICAgICAgbV9wb3MrKztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGMgPCAweDgwKSB7XG4gICAgICAvKiBvbmUgYnl0ZSAqL1xuICAgICAgYnVmW2krK10gPSBjO1xuICAgIH0gZWxzZSBpZiAoYyA8IDB4ODAwKSB7XG4gICAgICAvKiB0d28gYnl0ZXMgKi9cbiAgICAgIGJ1ZltpKytdID0gMHhDMCB8IChjID4+PiA2KTtcbiAgICAgIGJ1ZltpKytdID0gMHg4MCB8IChjICYgMHgzZik7XG4gICAgfSBlbHNlIGlmIChjIDwgMHgxMDAwMCkge1xuICAgICAgLyogdGhyZWUgYnl0ZXMgKi9cbiAgICAgIGJ1ZltpKytdID0gMHhFMCB8IChjID4+PiAxMik7XG4gICAgICBidWZbaSsrXSA9IDB4ODAgfCAoYyA+Pj4gNiAmIDB4M2YpO1xuICAgICAgYnVmW2krK10gPSAweDgwIHwgKGMgJiAweDNmKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLyogZm91ciBieXRlcyAqL1xuICAgICAgYnVmW2krK10gPSAweGYwIHwgKGMgPj4+IDE4KTtcbiAgICAgIGJ1ZltpKytdID0gMHg4MCB8IChjID4+PiAxMiAmIDB4M2YpO1xuICAgICAgYnVmW2krK10gPSAweDgwIHwgKGMgPj4+IDYgJiAweDNmKTtcbiAgICAgIGJ1ZltpKytdID0gMHg4MCB8IChjICYgMHgzZik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ1Zjtcbn07XG5cbi8vIEhlbHBlciAodXNlZCBpbiAyIHBsYWNlcylcbmZ1bmN0aW9uIGJ1ZjJiaW5zdHJpbmcoYnVmLCBsZW4pIHtcbiAgLy8gdXNlIGZhbGxiYWNrIGZvciBiaWcgYXJyYXlzIHRvIGF2b2lkIHN0YWNrIG92ZXJmbG93XG4gIGlmIChsZW4gPCA2NTUzNykge1xuICAgIGlmICgoYnVmLnN1YmFycmF5ICYmIFNUUl9BUFBMWV9VSUFfT0spIHx8ICghYnVmLnN1YmFycmF5ICYmIFNUUl9BUFBMWV9PSykpIHtcbiAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIHV0aWxzLnNocmlua0J1ZihidWYsIGxlbikpO1xuICAgIH1cbiAgfVxuXG4gIHZhciByZXN1bHQgPSAnJztcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIHJlc3VsdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuXG4vLyBDb252ZXJ0IGJ5dGUgYXJyYXkgdG8gYmluYXJ5IHN0cmluZ1xuZXhwb3J0cy5idWYyYmluc3RyaW5nID0gZnVuY3Rpb24gKGJ1Zikge1xuICByZXR1cm4gYnVmMmJpbnN0cmluZyhidWYsIGJ1Zi5sZW5ndGgpO1xufTtcblxuXG4vLyBDb252ZXJ0IGJpbmFyeSBzdHJpbmcgKHR5cGVkLCB3aGVuIHBvc3NpYmxlKVxuZXhwb3J0cy5iaW5zdHJpbmcyYnVmID0gZnVuY3Rpb24gKHN0cikge1xuICB2YXIgYnVmID0gbmV3IHV0aWxzLkJ1Zjgoc3RyLmxlbmd0aCk7XG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBidWYubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBidWZbaV0gPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgfVxuICByZXR1cm4gYnVmO1xufTtcblxuXG4vLyBjb252ZXJ0IGFycmF5IHRvIHN0cmluZ1xuZXhwb3J0cy5idWYyc3RyaW5nID0gZnVuY3Rpb24gKGJ1ZiwgbWF4KSB7XG4gIHZhciBpLCBvdXQsIGMsIGNfbGVuO1xuICB2YXIgbGVuID0gbWF4IHx8IGJ1Zi5sZW5ndGg7XG5cbiAgLy8gUmVzZXJ2ZSBtYXggcG9zc2libGUgbGVuZ3RoICgyIHdvcmRzIHBlciBjaGFyKVxuICAvLyBOQjogYnkgdW5rbm93biByZWFzb25zLCBBcnJheSBpcyBzaWduaWZpY2FudGx5IGZhc3RlciBmb3JcbiAgLy8gICAgIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkgdGhhbiBVaW50MTZBcnJheS5cbiAgdmFyIHV0ZjE2YnVmID0gbmV3IEFycmF5KGxlbiAqIDIpO1xuXG4gIGZvciAob3V0ID0gMCwgaSA9IDA7IGkgPCBsZW47KSB7XG4gICAgYyA9IGJ1ZltpKytdO1xuICAgIC8vIHF1aWNrIHByb2Nlc3MgYXNjaWlcbiAgICBpZiAoYyA8IDB4ODApIHsgdXRmMTZidWZbb3V0KytdID0gYzsgY29udGludWU7IH1cblxuICAgIGNfbGVuID0gX3V0ZjhsZW5bY107XG4gICAgLy8gc2tpcCA1ICYgNiBieXRlIGNvZGVzXG4gICAgaWYgKGNfbGVuID4gNCkgeyB1dGYxNmJ1ZltvdXQrK10gPSAweGZmZmQ7IGkgKz0gY19sZW4gLSAxOyBjb250aW51ZTsgfVxuXG4gICAgLy8gYXBwbHkgbWFzayBvbiBmaXJzdCBieXRlXG4gICAgYyAmPSBjX2xlbiA9PT0gMiA/IDB4MWYgOiBjX2xlbiA9PT0gMyA/IDB4MGYgOiAweDA3O1xuICAgIC8vIGpvaW4gdGhlIHJlc3RcbiAgICB3aGlsZSAoY19sZW4gPiAxICYmIGkgPCBsZW4pIHtcbiAgICAgIGMgPSAoYyA8PCA2KSB8IChidWZbaSsrXSAmIDB4M2YpO1xuICAgICAgY19sZW4tLTtcbiAgICB9XG5cbiAgICAvLyB0ZXJtaW5hdGVkIGJ5IGVuZCBvZiBzdHJpbmc/XG4gICAgaWYgKGNfbGVuID4gMSkgeyB1dGYxNmJ1ZltvdXQrK10gPSAweGZmZmQ7IGNvbnRpbnVlOyB9XG5cbiAgICBpZiAoYyA8IDB4MTAwMDApIHtcbiAgICAgIHV0ZjE2YnVmW291dCsrXSA9IGM7XG4gICAgfSBlbHNlIHtcbiAgICAgIGMgLT0gMHgxMDAwMDtcbiAgICAgIHV0ZjE2YnVmW291dCsrXSA9IDB4ZDgwMCB8ICgoYyA+PiAxMCkgJiAweDNmZik7XG4gICAgICB1dGYxNmJ1ZltvdXQrK10gPSAweGRjMDAgfCAoYyAmIDB4M2ZmKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnVmMmJpbnN0cmluZyh1dGYxNmJ1Ziwgb3V0KTtcbn07XG5cblxuLy8gQ2FsY3VsYXRlIG1heCBwb3NzaWJsZSBwb3NpdGlvbiBpbiB1dGY4IGJ1ZmZlcixcbi8vIHRoYXQgd2lsbCBub3QgYnJlYWsgc2VxdWVuY2UuIElmIHRoYXQncyBub3QgcG9zc2libGVcbi8vIC0gKHZlcnkgc21hbGwgbGltaXRzKSByZXR1cm4gbWF4IHNpemUgYXMgaXMuXG4vL1xuLy8gYnVmW10gLSB1dGY4IGJ5dGVzIGFycmF5XG4vLyBtYXggICAtIGxlbmd0aCBsaW1pdCAobWFuZGF0b3J5KTtcbmV4cG9ydHMudXRmOGJvcmRlciA9IGZ1bmN0aW9uIChidWYsIG1heCkge1xuICB2YXIgcG9zO1xuXG4gIG1heCA9IG1heCB8fCBidWYubGVuZ3RoO1xuICBpZiAobWF4ID4gYnVmLmxlbmd0aCkgeyBtYXggPSBidWYubGVuZ3RoOyB9XG5cbiAgLy8gZ28gYmFjayBmcm9tIGxhc3QgcG9zaXRpb24sIHVudGlsIHN0YXJ0IG9mIHNlcXVlbmNlIGZvdW5kXG4gIHBvcyA9IG1heCAtIDE7XG4gIHdoaWxlIChwb3MgPj0gMCAmJiAoYnVmW3Bvc10gJiAweEMwKSA9PT0gMHg4MCkgeyBwb3MtLTsgfVxuXG4gIC8vIEZ1Y2t1cCAtIHZlcnkgc21hbGwgYW5kIGJyb2tlbiBzZXF1ZW5jZSxcbiAgLy8gcmV0dXJuIG1heCwgYmVjYXVzZSB3ZSBzaG91bGQgcmV0dXJuIHNvbWV0aGluZyBhbnl3YXkuXG4gIGlmIChwb3MgPCAwKSB7IHJldHVybiBtYXg7IH1cblxuICAvLyBJZiB3ZSBjYW1lIHRvIHN0YXJ0IG9mIGJ1ZmZlciAtIHRoYXQgbWVhbnMgdnVmZmVyIGlzIHRvbyBzbWFsbCxcbiAgLy8gcmV0dXJuIG1heCB0b28uXG4gIGlmIChwb3MgPT09IDApIHsgcmV0dXJuIG1heDsgfVxuXG4gIHJldHVybiAocG9zICsgX3V0ZjhsZW5bYnVmW3Bvc11dID4gbWF4KSA/IHBvcyA6IG1heDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyAgID0gcmVxdWlyZSgnLi4vdXRpbHMvY29tbW9uJyk7XG52YXIgdHJlZXMgICA9IHJlcXVpcmUoJy4vdHJlZXMnKTtcbnZhciBhZGxlcjMyID0gcmVxdWlyZSgnLi9hZGxlcjMyJyk7XG52YXIgY3JjMzIgICA9IHJlcXVpcmUoJy4vY3JjMzInKTtcbnZhciBtc2cgICAgID0gcmVxdWlyZSgnLi9tZXNzYWdlcycpO1xuXG4vKiBQdWJsaWMgY29uc3RhbnRzID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuXG4vKiBBbGxvd2VkIGZsdXNoIHZhbHVlczsgc2VlIGRlZmxhdGUoKSBhbmQgaW5mbGF0ZSgpIGJlbG93IGZvciBkZXRhaWxzICovXG52YXIgWl9OT19GTFVTSCAgICAgID0gMDtcbnZhciBaX1BBUlRJQUxfRkxVU0ggPSAxO1xuLy92YXIgWl9TWU5DX0ZMVVNIICAgID0gMjtcbnZhciBaX0ZVTExfRkxVU0ggICAgPSAzO1xudmFyIFpfRklOSVNIICAgICAgICA9IDQ7XG52YXIgWl9CTE9DSyAgICAgICAgID0gNTtcbi8vdmFyIFpfVFJFRVMgICAgICAgICA9IDY7XG5cblxuLyogUmV0dXJuIGNvZGVzIGZvciB0aGUgY29tcHJlc3Npb24vZGVjb21wcmVzc2lvbiBmdW5jdGlvbnMuIE5lZ2F0aXZlIHZhbHVlc1xuICogYXJlIGVycm9ycywgcG9zaXRpdmUgdmFsdWVzIGFyZSB1c2VkIGZvciBzcGVjaWFsIGJ1dCBub3JtYWwgZXZlbnRzLlxuICovXG52YXIgWl9PSyAgICAgICAgICAgID0gMDtcbnZhciBaX1NUUkVBTV9FTkQgICAgPSAxO1xuLy92YXIgWl9ORUVEX0RJQ1QgICAgID0gMjtcbi8vdmFyIFpfRVJSTk8gICAgICAgICA9IC0xO1xudmFyIFpfU1RSRUFNX0VSUk9SICA9IC0yO1xudmFyIFpfREFUQV9FUlJPUiAgICA9IC0zO1xuLy92YXIgWl9NRU1fRVJST1IgICAgID0gLTQ7XG52YXIgWl9CVUZfRVJST1IgICAgID0gLTU7XG4vL3ZhciBaX1ZFUlNJT05fRVJST1IgPSAtNjtcblxuXG4vKiBjb21wcmVzc2lvbiBsZXZlbHMgKi9cbi8vdmFyIFpfTk9fQ09NUFJFU1NJT04gICAgICA9IDA7XG4vL3ZhciBaX0JFU1RfU1BFRUQgICAgICAgICAgPSAxO1xuLy92YXIgWl9CRVNUX0NPTVBSRVNTSU9OICAgID0gOTtcbnZhciBaX0RFRkFVTFRfQ09NUFJFU1NJT04gPSAtMTtcblxuXG52YXIgWl9GSUxURVJFRCAgICAgICAgICAgID0gMTtcbnZhciBaX0hVRkZNQU5fT05MWSAgICAgICAgPSAyO1xudmFyIFpfUkxFICAgICAgICAgICAgICAgICA9IDM7XG52YXIgWl9GSVhFRCAgICAgICAgICAgICAgID0gNDtcbnZhciBaX0RFRkFVTFRfU1RSQVRFR1kgICAgPSAwO1xuXG4vKiBQb3NzaWJsZSB2YWx1ZXMgb2YgdGhlIGRhdGFfdHlwZSBmaWVsZCAodGhvdWdoIHNlZSBpbmZsYXRlKCkpICovXG4vL3ZhciBaX0JJTkFSWSAgICAgICAgICAgICAgPSAwO1xuLy92YXIgWl9URVhUICAgICAgICAgICAgICAgID0gMTtcbi8vdmFyIFpfQVNDSUkgICAgICAgICAgICAgICA9IDE7IC8vID0gWl9URVhUXG52YXIgWl9VTktOT1dOICAgICAgICAgICAgID0gMjtcblxuXG4vKiBUaGUgZGVmbGF0ZSBjb21wcmVzc2lvbiBtZXRob2QgKi9cbnZhciBaX0RFRkxBVEVEICA9IDg7XG5cbi8qPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cblxudmFyIE1BWF9NRU1fTEVWRUwgPSA5O1xuLyogTWF4aW11bSB2YWx1ZSBmb3IgbWVtTGV2ZWwgaW4gZGVmbGF0ZUluaXQyICovXG52YXIgTUFYX1dCSVRTID0gMTU7XG4vKiAzMksgTFo3NyB3aW5kb3cgKi9cbnZhciBERUZfTUVNX0xFVkVMID0gODtcblxuXG52YXIgTEVOR1RIX0NPREVTICA9IDI5O1xuLyogbnVtYmVyIG9mIGxlbmd0aCBjb2Rlcywgbm90IGNvdW50aW5nIHRoZSBzcGVjaWFsIEVORF9CTE9DSyBjb2RlICovXG52YXIgTElURVJBTFMgICAgICA9IDI1Njtcbi8qIG51bWJlciBvZiBsaXRlcmFsIGJ5dGVzIDAuLjI1NSAqL1xudmFyIExfQ09ERVMgICAgICAgPSBMSVRFUkFMUyArIDEgKyBMRU5HVEhfQ09ERVM7XG4vKiBudW1iZXIgb2YgTGl0ZXJhbCBvciBMZW5ndGggY29kZXMsIGluY2x1ZGluZyB0aGUgRU5EX0JMT0NLIGNvZGUgKi9cbnZhciBEX0NPREVTICAgICAgID0gMzA7XG4vKiBudW1iZXIgb2YgZGlzdGFuY2UgY29kZXMgKi9cbnZhciBCTF9DT0RFUyAgICAgID0gMTk7XG4vKiBudW1iZXIgb2YgY29kZXMgdXNlZCB0byB0cmFuc2ZlciB0aGUgYml0IGxlbmd0aHMgKi9cbnZhciBIRUFQX1NJWkUgICAgID0gMiAqIExfQ09ERVMgKyAxO1xuLyogbWF4aW11bSBoZWFwIHNpemUgKi9cbnZhciBNQVhfQklUUyAgPSAxNTtcbi8qIEFsbCBjb2RlcyBtdXN0IG5vdCBleGNlZWQgTUFYX0JJVFMgYml0cyAqL1xuXG52YXIgTUlOX01BVENIID0gMztcbnZhciBNQVhfTUFUQ0ggPSAyNTg7XG52YXIgTUlOX0xPT0tBSEVBRCA9IChNQVhfTUFUQ0ggKyBNSU5fTUFUQ0ggKyAxKTtcblxudmFyIFBSRVNFVF9ESUNUID0gMHgyMDtcblxudmFyIElOSVRfU1RBVEUgPSA0MjtcbnZhciBFWFRSQV9TVEFURSA9IDY5O1xudmFyIE5BTUVfU1RBVEUgPSA3MztcbnZhciBDT01NRU5UX1NUQVRFID0gOTE7XG52YXIgSENSQ19TVEFURSA9IDEwMztcbnZhciBCVVNZX1NUQVRFID0gMTEzO1xudmFyIEZJTklTSF9TVEFURSA9IDY2NjtcblxudmFyIEJTX05FRURfTU9SRSAgICAgID0gMTsgLyogYmxvY2sgbm90IGNvbXBsZXRlZCwgbmVlZCBtb3JlIGlucHV0IG9yIG1vcmUgb3V0cHV0ICovXG52YXIgQlNfQkxPQ0tfRE9ORSAgICAgPSAyOyAvKiBibG9jayBmbHVzaCBwZXJmb3JtZWQgKi9cbnZhciBCU19GSU5JU0hfU1RBUlRFRCA9IDM7IC8qIGZpbmlzaCBzdGFydGVkLCBuZWVkIG9ubHkgbW9yZSBvdXRwdXQgYXQgbmV4dCBkZWZsYXRlICovXG52YXIgQlNfRklOSVNIX0RPTkUgICAgPSA0OyAvKiBmaW5pc2ggZG9uZSwgYWNjZXB0IG5vIG1vcmUgaW5wdXQgb3Igb3V0cHV0ICovXG5cbnZhciBPU19DT0RFID0gMHgwMzsgLy8gVW5peCA6KSAuIERvbid0IGRldGVjdCwgdXNlIHRoaXMgZGVmYXVsdC5cblxuZnVuY3Rpb24gZXJyKHN0cm0sIGVycm9yQ29kZSkge1xuICBzdHJtLm1zZyA9IG1zZ1tlcnJvckNvZGVdO1xuICByZXR1cm4gZXJyb3JDb2RlO1xufVxuXG5mdW5jdGlvbiByYW5rKGYpIHtcbiAgcmV0dXJuICgoZikgPDwgMSkgLSAoKGYpID4gNCA/IDkgOiAwKTtcbn1cblxuZnVuY3Rpb24gemVybyhidWYpIHsgdmFyIGxlbiA9IGJ1Zi5sZW5ndGg7IHdoaWxlICgtLWxlbiA+PSAwKSB7IGJ1ZltsZW5dID0gMDsgfSB9XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogRmx1c2ggYXMgbXVjaCBwZW5kaW5nIG91dHB1dCBhcyBwb3NzaWJsZS4gQWxsIGRlZmxhdGUoKSBvdXRwdXQgZ29lc1xuICogdGhyb3VnaCB0aGlzIGZ1bmN0aW9uIHNvIHNvbWUgYXBwbGljYXRpb25zIG1heSB3aXNoIHRvIG1vZGlmeSBpdFxuICogdG8gYXZvaWQgYWxsb2NhdGluZyBhIGxhcmdlIHN0cm0tPm91dHB1dCBidWZmZXIgYW5kIGNvcHlpbmcgaW50byBpdC5cbiAqIChTZWUgYWxzbyByZWFkX2J1ZigpKS5cbiAqL1xuZnVuY3Rpb24gZmx1c2hfcGVuZGluZyhzdHJtKSB7XG4gIHZhciBzID0gc3RybS5zdGF0ZTtcblxuICAvL190cl9mbHVzaF9iaXRzKHMpO1xuICB2YXIgbGVuID0gcy5wZW5kaW5nO1xuICBpZiAobGVuID4gc3RybS5hdmFpbF9vdXQpIHtcbiAgICBsZW4gPSBzdHJtLmF2YWlsX291dDtcbiAgfVxuICBpZiAobGVuID09PSAwKSB7IHJldHVybjsgfVxuXG4gIHV0aWxzLmFycmF5U2V0KHN0cm0ub3V0cHV0LCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmdfb3V0LCBsZW4sIHN0cm0ubmV4dF9vdXQpO1xuICBzdHJtLm5leHRfb3V0ICs9IGxlbjtcbiAgcy5wZW5kaW5nX291dCArPSBsZW47XG4gIHN0cm0udG90YWxfb3V0ICs9IGxlbjtcbiAgc3RybS5hdmFpbF9vdXQgLT0gbGVuO1xuICBzLnBlbmRpbmcgLT0gbGVuO1xuICBpZiAocy5wZW5kaW5nID09PSAwKSB7XG4gICAgcy5wZW5kaW5nX291dCA9IDA7XG4gIH1cbn1cblxuXG5mdW5jdGlvbiBmbHVzaF9ibG9ja19vbmx5KHMsIGxhc3QpIHtcbiAgdHJlZXMuX3RyX2ZsdXNoX2Jsb2NrKHMsIChzLmJsb2NrX3N0YXJ0ID49IDAgPyBzLmJsb2NrX3N0YXJ0IDogLTEpLCBzLnN0cnN0YXJ0IC0gcy5ibG9ja19zdGFydCwgbGFzdCk7XG4gIHMuYmxvY2tfc3RhcnQgPSBzLnN0cnN0YXJ0O1xuICBmbHVzaF9wZW5kaW5nKHMuc3RybSk7XG59XG5cblxuZnVuY3Rpb24gcHV0X2J5dGUocywgYikge1xuICBzLnBlbmRpbmdfYnVmW3MucGVuZGluZysrXSA9IGI7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogUHV0IGEgc2hvcnQgaW4gdGhlIHBlbmRpbmcgYnVmZmVyLiBUaGUgMTYtYml0IHZhbHVlIGlzIHB1dCBpbiBNU0Igb3JkZXIuXG4gKiBJTiBhc3NlcnRpb246IHRoZSBzdHJlYW0gc3RhdGUgaXMgY29ycmVjdCBhbmQgdGhlcmUgaXMgZW5vdWdoIHJvb20gaW5cbiAqIHBlbmRpbmdfYnVmLlxuICovXG5mdW5jdGlvbiBwdXRTaG9ydE1TQihzLCBiKSB7XG4vLyAgcHV0X2J5dGUocywgKEJ5dGUpKGIgPj4gOCkpO1xuLy8gIHB1dF9ieXRlKHMsIChCeXRlKShiICYgMHhmZikpO1xuICBzLnBlbmRpbmdfYnVmW3MucGVuZGluZysrXSA9IChiID4+PiA4KSAmIDB4ZmY7XG4gIHMucGVuZGluZ19idWZbcy5wZW5kaW5nKytdID0gYiAmIDB4ZmY7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBSZWFkIGEgbmV3IGJ1ZmZlciBmcm9tIHRoZSBjdXJyZW50IGlucHV0IHN0cmVhbSwgdXBkYXRlIHRoZSBhZGxlcjMyXG4gKiBhbmQgdG90YWwgbnVtYmVyIG9mIGJ5dGVzIHJlYWQuICBBbGwgZGVmbGF0ZSgpIGlucHV0IGdvZXMgdGhyb3VnaFxuICogdGhpcyBmdW5jdGlvbiBzbyBzb21lIGFwcGxpY2F0aW9ucyBtYXkgd2lzaCB0byBtb2RpZnkgaXQgdG8gYXZvaWRcbiAqIGFsbG9jYXRpbmcgYSBsYXJnZSBzdHJtLT5pbnB1dCBidWZmZXIgYW5kIGNvcHlpbmcgZnJvbSBpdC5cbiAqIChTZWUgYWxzbyBmbHVzaF9wZW5kaW5nKCkpLlxuICovXG5mdW5jdGlvbiByZWFkX2J1ZihzdHJtLCBidWYsIHN0YXJ0LCBzaXplKSB7XG4gIHZhciBsZW4gPSBzdHJtLmF2YWlsX2luO1xuXG4gIGlmIChsZW4gPiBzaXplKSB7IGxlbiA9IHNpemU7IH1cbiAgaWYgKGxlbiA9PT0gMCkgeyByZXR1cm4gMDsgfVxuXG4gIHN0cm0uYXZhaWxfaW4gLT0gbGVuO1xuXG4gIC8vIHptZW1jcHkoYnVmLCBzdHJtLT5uZXh0X2luLCBsZW4pO1xuICB1dGlscy5hcnJheVNldChidWYsIHN0cm0uaW5wdXQsIHN0cm0ubmV4dF9pbiwgbGVuLCBzdGFydCk7XG4gIGlmIChzdHJtLnN0YXRlLndyYXAgPT09IDEpIHtcbiAgICBzdHJtLmFkbGVyID0gYWRsZXIzMihzdHJtLmFkbGVyLCBidWYsIGxlbiwgc3RhcnQpO1xuICB9XG5cbiAgZWxzZSBpZiAoc3RybS5zdGF0ZS53cmFwID09PSAyKSB7XG4gICAgc3RybS5hZGxlciA9IGNyYzMyKHN0cm0uYWRsZXIsIGJ1ZiwgbGVuLCBzdGFydCk7XG4gIH1cblxuICBzdHJtLm5leHRfaW4gKz0gbGVuO1xuICBzdHJtLnRvdGFsX2luICs9IGxlbjtcblxuICByZXR1cm4gbGVuO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2V0IG1hdGNoX3N0YXJ0IHRvIHRoZSBsb25nZXN0IG1hdGNoIHN0YXJ0aW5nIGF0IHRoZSBnaXZlbiBzdHJpbmcgYW5kXG4gKiByZXR1cm4gaXRzIGxlbmd0aC4gTWF0Y2hlcyBzaG9ydGVyIG9yIGVxdWFsIHRvIHByZXZfbGVuZ3RoIGFyZSBkaXNjYXJkZWQsXG4gKiBpbiB3aGljaCBjYXNlIHRoZSByZXN1bHQgaXMgZXF1YWwgdG8gcHJldl9sZW5ndGggYW5kIG1hdGNoX3N0YXJ0IGlzXG4gKiBnYXJiYWdlLlxuICogSU4gYXNzZXJ0aW9uczogY3VyX21hdGNoIGlzIHRoZSBoZWFkIG9mIHRoZSBoYXNoIGNoYWluIGZvciB0aGUgY3VycmVudFxuICogICBzdHJpbmcgKHN0cnN0YXJ0KSBhbmQgaXRzIGRpc3RhbmNlIGlzIDw9IE1BWF9ESVNULCBhbmQgcHJldl9sZW5ndGggPj0gMVxuICogT1VUIGFzc2VydGlvbjogdGhlIG1hdGNoIGxlbmd0aCBpcyBub3QgZ3JlYXRlciB0aGFuIHMtPmxvb2thaGVhZC5cbiAqL1xuZnVuY3Rpb24gbG9uZ2VzdF9tYXRjaChzLCBjdXJfbWF0Y2gpIHtcbiAgdmFyIGNoYWluX2xlbmd0aCA9IHMubWF4X2NoYWluX2xlbmd0aDsgICAgICAvKiBtYXggaGFzaCBjaGFpbiBsZW5ndGggKi9cbiAgdmFyIHNjYW4gPSBzLnN0cnN0YXJ0OyAvKiBjdXJyZW50IHN0cmluZyAqL1xuICB2YXIgbWF0Y2g7ICAgICAgICAgICAgICAgICAgICAgICAvKiBtYXRjaGVkIHN0cmluZyAqL1xuICB2YXIgbGVuOyAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIGxlbmd0aCBvZiBjdXJyZW50IG1hdGNoICovXG4gIHZhciBiZXN0X2xlbiA9IHMucHJldl9sZW5ndGg7ICAgICAgICAgICAgICAvKiBiZXN0IG1hdGNoIGxlbmd0aCBzbyBmYXIgKi9cbiAgdmFyIG5pY2VfbWF0Y2ggPSBzLm5pY2VfbWF0Y2g7ICAgICAgICAgICAgIC8qIHN0b3AgaWYgbWF0Y2ggbG9uZyBlbm91Z2ggKi9cbiAgdmFyIGxpbWl0ID0gKHMuc3Ryc3RhcnQgPiAocy53X3NpemUgLSBNSU5fTE9PS0FIRUFEKSkgP1xuICAgICAgcy5zdHJzdGFydCAtIChzLndfc2l6ZSAtIE1JTl9MT09LQUhFQUQpIDogMC8qTklMKi87XG5cbiAgdmFyIF93aW4gPSBzLndpbmRvdzsgLy8gc2hvcnRjdXRcblxuICB2YXIgd21hc2sgPSBzLndfbWFzaztcbiAgdmFyIHByZXYgID0gcy5wcmV2O1xuXG4gIC8qIFN0b3Agd2hlbiBjdXJfbWF0Y2ggYmVjb21lcyA8PSBsaW1pdC4gVG8gc2ltcGxpZnkgdGhlIGNvZGUsXG4gICAqIHdlIHByZXZlbnQgbWF0Y2hlcyB3aXRoIHRoZSBzdHJpbmcgb2Ygd2luZG93IGluZGV4IDAuXG4gICAqL1xuXG4gIHZhciBzdHJlbmQgPSBzLnN0cnN0YXJ0ICsgTUFYX01BVENIO1xuICB2YXIgc2Nhbl9lbmQxICA9IF93aW5bc2NhbiArIGJlc3RfbGVuIC0gMV07XG4gIHZhciBzY2FuX2VuZCAgID0gX3dpbltzY2FuICsgYmVzdF9sZW5dO1xuXG4gIC8qIFRoZSBjb2RlIGlzIG9wdGltaXplZCBmb3IgSEFTSF9CSVRTID49IDggYW5kIE1BWF9NQVRDSC0yIG11bHRpcGxlIG9mIDE2LlxuICAgKiBJdCBpcyBlYXN5IHRvIGdldCByaWQgb2YgdGhpcyBvcHRpbWl6YXRpb24gaWYgbmVjZXNzYXJ5LlxuICAgKi9cbiAgLy8gQXNzZXJ0KHMtPmhhc2hfYml0cyA+PSA4ICYmIE1BWF9NQVRDSCA9PSAyNTgsIFwiQ29kZSB0b28gY2xldmVyXCIpO1xuXG4gIC8qIERvIG5vdCB3YXN0ZSB0b28gbXVjaCB0aW1lIGlmIHdlIGFscmVhZHkgaGF2ZSBhIGdvb2QgbWF0Y2g6ICovXG4gIGlmIChzLnByZXZfbGVuZ3RoID49IHMuZ29vZF9tYXRjaCkge1xuICAgIGNoYWluX2xlbmd0aCA+Pj0gMjtcbiAgfVxuICAvKiBEbyBub3QgbG9vayBmb3IgbWF0Y2hlcyBiZXlvbmQgdGhlIGVuZCBvZiB0aGUgaW5wdXQuIFRoaXMgaXMgbmVjZXNzYXJ5XG4gICAqIHRvIG1ha2UgZGVmbGF0ZSBkZXRlcm1pbmlzdGljLlxuICAgKi9cbiAgaWYgKG5pY2VfbWF0Y2ggPiBzLmxvb2thaGVhZCkgeyBuaWNlX21hdGNoID0gcy5sb29rYWhlYWQ7IH1cblxuICAvLyBBc3NlcnQoKHVsZylzLT5zdHJzdGFydCA8PSBzLT53aW5kb3dfc2l6ZS1NSU5fTE9PS0FIRUFELCBcIm5lZWQgbG9va2FoZWFkXCIpO1xuXG4gIGRvIHtcbiAgICAvLyBBc3NlcnQoY3VyX21hdGNoIDwgcy0+c3Ryc3RhcnQsIFwibm8gZnV0dXJlXCIpO1xuICAgIG1hdGNoID0gY3VyX21hdGNoO1xuXG4gICAgLyogU2tpcCB0byBuZXh0IG1hdGNoIGlmIHRoZSBtYXRjaCBsZW5ndGggY2Fubm90IGluY3JlYXNlXG4gICAgICogb3IgaWYgdGhlIG1hdGNoIGxlbmd0aCBpcyBsZXNzIHRoYW4gMi4gIE5vdGUgdGhhdCB0aGUgY2hlY2tzIGJlbG93XG4gICAgICogZm9yIGluc3VmZmljaWVudCBsb29rYWhlYWQgb25seSBvY2N1ciBvY2Nhc2lvbmFsbHkgZm9yIHBlcmZvcm1hbmNlXG4gICAgICogcmVhc29ucy4gIFRoZXJlZm9yZSB1bmluaXRpYWxpemVkIG1lbW9yeSB3aWxsIGJlIGFjY2Vzc2VkLCBhbmRcbiAgICAgKiBjb25kaXRpb25hbCBqdW1wcyB3aWxsIGJlIG1hZGUgdGhhdCBkZXBlbmQgb24gdGhvc2UgdmFsdWVzLlxuICAgICAqIEhvd2V2ZXIgdGhlIGxlbmd0aCBvZiB0aGUgbWF0Y2ggaXMgbGltaXRlZCB0byB0aGUgbG9va2FoZWFkLCBzb1xuICAgICAqIHRoZSBvdXRwdXQgb2YgZGVmbGF0ZSBpcyBub3QgYWZmZWN0ZWQgYnkgdGhlIHVuaW5pdGlhbGl6ZWQgdmFsdWVzLlxuICAgICAqL1xuXG4gICAgaWYgKF93aW5bbWF0Y2ggKyBiZXN0X2xlbl0gICAgICE9PSBzY2FuX2VuZCAgfHxcbiAgICAgICAgX3dpblttYXRjaCArIGJlc3RfbGVuIC0gMV0gIT09IHNjYW5fZW5kMSB8fFxuICAgICAgICBfd2luW21hdGNoXSAgICAgICAgICAgICAgICAhPT0gX3dpbltzY2FuXSB8fFxuICAgICAgICBfd2luWysrbWF0Y2hdICAgICAgICAgICAgICAhPT0gX3dpbltzY2FuICsgMV0pIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8qIFRoZSBjaGVjayBhdCBiZXN0X2xlbi0xIGNhbiBiZSByZW1vdmVkIGJlY2F1c2UgaXQgd2lsbCBiZSBtYWRlXG4gICAgICogYWdhaW4gbGF0ZXIuIChUaGlzIGhldXJpc3RpYyBpcyBub3QgYWx3YXlzIGEgd2luLilcbiAgICAgKiBJdCBpcyBub3QgbmVjZXNzYXJ5IHRvIGNvbXBhcmUgc2NhblsyXSBhbmQgbWF0Y2hbMl0gc2luY2UgdGhleVxuICAgICAqIGFyZSBhbHdheXMgZXF1YWwgd2hlbiB0aGUgb3RoZXIgYnl0ZXMgbWF0Y2gsIGdpdmVuIHRoYXRcbiAgICAgKiB0aGUgaGFzaCBrZXlzIGFyZSBlcXVhbCBhbmQgdGhhdCBIQVNIX0JJVFMgPj0gOC5cbiAgICAgKi9cbiAgICBzY2FuICs9IDI7XG4gICAgbWF0Y2grKztcbiAgICAvLyBBc3NlcnQoKnNjYW4gPT0gKm1hdGNoLCBcIm1hdGNoWzJdP1wiKTtcblxuICAgIC8qIFdlIGNoZWNrIGZvciBpbnN1ZmZpY2llbnQgbG9va2FoZWFkIG9ubHkgZXZlcnkgOHRoIGNvbXBhcmlzb247XG4gICAgICogdGhlIDI1NnRoIGNoZWNrIHdpbGwgYmUgbWFkZSBhdCBzdHJzdGFydCsyNTguXG4gICAgICovXG4gICAgZG8ge1xuICAgICAgLypqc2hpbnQgbm9lbXB0eTpmYWxzZSovXG4gICAgfSB3aGlsZSAoX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmIF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJlxuICAgICAgICAgICAgIF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJiBfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiZcbiAgICAgICAgICAgICBfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiYgX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmXG4gICAgICAgICAgICAgX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmIF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJlxuICAgICAgICAgICAgIHNjYW4gPCBzdHJlbmQpO1xuXG4gICAgLy8gQXNzZXJ0KHNjYW4gPD0gcy0+d2luZG93Kyh1bnNpZ25lZCkocy0+d2luZG93X3NpemUtMSksIFwid2lsZCBzY2FuXCIpO1xuXG4gICAgbGVuID0gTUFYX01BVENIIC0gKHN0cmVuZCAtIHNjYW4pO1xuICAgIHNjYW4gPSBzdHJlbmQgLSBNQVhfTUFUQ0g7XG5cbiAgICBpZiAobGVuID4gYmVzdF9sZW4pIHtcbiAgICAgIHMubWF0Y2hfc3RhcnQgPSBjdXJfbWF0Y2g7XG4gICAgICBiZXN0X2xlbiA9IGxlbjtcbiAgICAgIGlmIChsZW4gPj0gbmljZV9tYXRjaCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHNjYW5fZW5kMSAgPSBfd2luW3NjYW4gKyBiZXN0X2xlbiAtIDFdO1xuICAgICAgc2Nhbl9lbmQgICA9IF93aW5bc2NhbiArIGJlc3RfbGVuXTtcbiAgICB9XG4gIH0gd2hpbGUgKChjdXJfbWF0Y2ggPSBwcmV2W2N1cl9tYXRjaCAmIHdtYXNrXSkgPiBsaW1pdCAmJiAtLWNoYWluX2xlbmd0aCAhPT0gMCk7XG5cbiAgaWYgKGJlc3RfbGVuIDw9IHMubG9va2FoZWFkKSB7XG4gICAgcmV0dXJuIGJlc3RfbGVuO1xuICB9XG4gIHJldHVybiBzLmxvb2thaGVhZDtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEZpbGwgdGhlIHdpbmRvdyB3aGVuIHRoZSBsb29rYWhlYWQgYmVjb21lcyBpbnN1ZmZpY2llbnQuXG4gKiBVcGRhdGVzIHN0cnN0YXJ0IGFuZCBsb29rYWhlYWQuXG4gKlxuICogSU4gYXNzZXJ0aW9uOiBsb29rYWhlYWQgPCBNSU5fTE9PS0FIRUFEXG4gKiBPVVQgYXNzZXJ0aW9uczogc3Ryc3RhcnQgPD0gd2luZG93X3NpemUtTUlOX0xPT0tBSEVBRFxuICogICAgQXQgbGVhc3Qgb25lIGJ5dGUgaGFzIGJlZW4gcmVhZCwgb3IgYXZhaWxfaW4gPT0gMDsgcmVhZHMgYXJlXG4gKiAgICBwZXJmb3JtZWQgZm9yIGF0IGxlYXN0IHR3byBieXRlcyAocmVxdWlyZWQgZm9yIHRoZSB6aXAgdHJhbnNsYXRlX2VvbFxuICogICAgb3B0aW9uIC0tIG5vdCBzdXBwb3J0ZWQgaGVyZSkuXG4gKi9cbmZ1bmN0aW9uIGZpbGxfd2luZG93KHMpIHtcbiAgdmFyIF93X3NpemUgPSBzLndfc2l6ZTtcbiAgdmFyIHAsIG4sIG0sIG1vcmUsIHN0cjtcblxuICAvL0Fzc2VydChzLT5sb29rYWhlYWQgPCBNSU5fTE9PS0FIRUFELCBcImFscmVhZHkgZW5vdWdoIGxvb2thaGVhZFwiKTtcblxuICBkbyB7XG4gICAgbW9yZSA9IHMud2luZG93X3NpemUgLSBzLmxvb2thaGVhZCAtIHMuc3Ryc3RhcnQ7XG5cbiAgICAvLyBKUyBpbnRzIGhhdmUgMzIgYml0LCBibG9jayBiZWxvdyBub3QgbmVlZGVkXG4gICAgLyogRGVhbCB3aXRoICFAIyQlIDY0SyBsaW1pdDogKi9cbiAgICAvL2lmIChzaXplb2YoaW50KSA8PSAyKSB7XG4gICAgLy8gICAgaWYgKG1vcmUgPT0gMCAmJiBzLT5zdHJzdGFydCA9PSAwICYmIHMtPmxvb2thaGVhZCA9PSAwKSB7XG4gICAgLy8gICAgICAgIG1vcmUgPSB3c2l6ZTtcbiAgICAvL1xuICAgIC8vICB9IGVsc2UgaWYgKG1vcmUgPT0gKHVuc2lnbmVkKSgtMSkpIHtcbiAgICAvLyAgICAgICAgLyogVmVyeSB1bmxpa2VseSwgYnV0IHBvc3NpYmxlIG9uIDE2IGJpdCBtYWNoaW5lIGlmXG4gICAgLy8gICAgICAgICAqIHN0cnN0YXJ0ID09IDAgJiYgbG9va2FoZWFkID09IDEgKGlucHV0IGRvbmUgYSBieXRlIGF0IHRpbWUpXG4gICAgLy8gICAgICAgICAqL1xuICAgIC8vICAgICAgICBtb3JlLS07XG4gICAgLy8gICAgfVxuICAgIC8vfVxuXG5cbiAgICAvKiBJZiB0aGUgd2luZG93IGlzIGFsbW9zdCBmdWxsIGFuZCB0aGVyZSBpcyBpbnN1ZmZpY2llbnQgbG9va2FoZWFkLFxuICAgICAqIG1vdmUgdGhlIHVwcGVyIGhhbGYgdG8gdGhlIGxvd2VyIG9uZSB0byBtYWtlIHJvb20gaW4gdGhlIHVwcGVyIGhhbGYuXG4gICAgICovXG4gICAgaWYgKHMuc3Ryc3RhcnQgPj0gX3dfc2l6ZSArIChfd19zaXplIC0gTUlOX0xPT0tBSEVBRCkpIHtcblxuICAgICAgdXRpbHMuYXJyYXlTZXQocy53aW5kb3csIHMud2luZG93LCBfd19zaXplLCBfd19zaXplLCAwKTtcbiAgICAgIHMubWF0Y2hfc3RhcnQgLT0gX3dfc2l6ZTtcbiAgICAgIHMuc3Ryc3RhcnQgLT0gX3dfc2l6ZTtcbiAgICAgIC8qIHdlIG5vdyBoYXZlIHN0cnN0YXJ0ID49IE1BWF9ESVNUICovXG4gICAgICBzLmJsb2NrX3N0YXJ0IC09IF93X3NpemU7XG5cbiAgICAgIC8qIFNsaWRlIHRoZSBoYXNoIHRhYmxlIChjb3VsZCBiZSBhdm9pZGVkIHdpdGggMzIgYml0IHZhbHVlc1xuICAgICAgIGF0IHRoZSBleHBlbnNlIG9mIG1lbW9yeSB1c2FnZSkuIFdlIHNsaWRlIGV2ZW4gd2hlbiBsZXZlbCA9PSAwXG4gICAgICAgdG8ga2VlcCB0aGUgaGFzaCB0YWJsZSBjb25zaXN0ZW50IGlmIHdlIHN3aXRjaCBiYWNrIHRvIGxldmVsID4gMFxuICAgICAgIGxhdGVyLiAoVXNpbmcgbGV2ZWwgMCBwZXJtYW5lbnRseSBpcyBub3QgYW4gb3B0aW1hbCB1c2FnZSBvZlxuICAgICAgIHpsaWIsIHNvIHdlIGRvbid0IGNhcmUgYWJvdXQgdGhpcyBwYXRob2xvZ2ljYWwgY2FzZS4pXG4gICAgICAgKi9cblxuICAgICAgbiA9IHMuaGFzaF9zaXplO1xuICAgICAgcCA9IG47XG4gICAgICBkbyB7XG4gICAgICAgIG0gPSBzLmhlYWRbLS1wXTtcbiAgICAgICAgcy5oZWFkW3BdID0gKG0gPj0gX3dfc2l6ZSA/IG0gLSBfd19zaXplIDogMCk7XG4gICAgICB9IHdoaWxlICgtLW4pO1xuXG4gICAgICBuID0gX3dfc2l6ZTtcbiAgICAgIHAgPSBuO1xuICAgICAgZG8ge1xuICAgICAgICBtID0gcy5wcmV2Wy0tcF07XG4gICAgICAgIHMucHJldltwXSA9IChtID49IF93X3NpemUgPyBtIC0gX3dfc2l6ZSA6IDApO1xuICAgICAgICAvKiBJZiBuIGlzIG5vdCBvbiBhbnkgaGFzaCBjaGFpbiwgcHJldltuXSBpcyBnYXJiYWdlIGJ1dFxuICAgICAgICAgKiBpdHMgdmFsdWUgd2lsbCBuZXZlciBiZSB1c2VkLlxuICAgICAgICAgKi9cbiAgICAgIH0gd2hpbGUgKC0tbik7XG5cbiAgICAgIG1vcmUgKz0gX3dfc2l6ZTtcbiAgICB9XG4gICAgaWYgKHMuc3RybS5hdmFpbF9pbiA9PT0gMCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLyogSWYgdGhlcmUgd2FzIG5vIHNsaWRpbmc6XG4gICAgICogICAgc3Ryc3RhcnQgPD0gV1NJWkUrTUFYX0RJU1QtMSAmJiBsb29rYWhlYWQgPD0gTUlOX0xPT0tBSEVBRCAtIDEgJiZcbiAgICAgKiAgICBtb3JlID09IHdpbmRvd19zaXplIC0gbG9va2FoZWFkIC0gc3Ryc3RhcnRcbiAgICAgKiA9PiBtb3JlID49IHdpbmRvd19zaXplIC0gKE1JTl9MT09LQUhFQUQtMSArIFdTSVpFICsgTUFYX0RJU1QtMSlcbiAgICAgKiA9PiBtb3JlID49IHdpbmRvd19zaXplIC0gMipXU0laRSArIDJcbiAgICAgKiBJbiB0aGUgQklHX01FTSBvciBNTUFQIGNhc2UgKG5vdCB5ZXQgc3VwcG9ydGVkKSxcbiAgICAgKiAgIHdpbmRvd19zaXplID09IGlucHV0X3NpemUgKyBNSU5fTE9PS0FIRUFEICAmJlxuICAgICAqICAgc3Ryc3RhcnQgKyBzLT5sb29rYWhlYWQgPD0gaW5wdXRfc2l6ZSA9PiBtb3JlID49IE1JTl9MT09LQUhFQUQuXG4gICAgICogT3RoZXJ3aXNlLCB3aW5kb3dfc2l6ZSA9PSAyKldTSVpFIHNvIG1vcmUgPj0gMi5cbiAgICAgKiBJZiB0aGVyZSB3YXMgc2xpZGluZywgbW9yZSA+PSBXU0laRS4gU28gaW4gYWxsIGNhc2VzLCBtb3JlID49IDIuXG4gICAgICovXG4gICAgLy9Bc3NlcnQobW9yZSA+PSAyLCBcIm1vcmUgPCAyXCIpO1xuICAgIG4gPSByZWFkX2J1ZihzLnN0cm0sIHMud2luZG93LCBzLnN0cnN0YXJ0ICsgcy5sb29rYWhlYWQsIG1vcmUpO1xuICAgIHMubG9va2FoZWFkICs9IG47XG5cbiAgICAvKiBJbml0aWFsaXplIHRoZSBoYXNoIHZhbHVlIG5vdyB0aGF0IHdlIGhhdmUgc29tZSBpbnB1dDogKi9cbiAgICBpZiAocy5sb29rYWhlYWQgKyBzLmluc2VydCA+PSBNSU5fTUFUQ0gpIHtcbiAgICAgIHN0ciA9IHMuc3Ryc3RhcnQgLSBzLmluc2VydDtcbiAgICAgIHMuaW5zX2ggPSBzLndpbmRvd1tzdHJdO1xuXG4gICAgICAvKiBVUERBVEVfSEFTSChzLCBzLT5pbnNfaCwgcy0+d2luZG93W3N0ciArIDFdKTsgKi9cbiAgICAgIHMuaW5zX2ggPSAoKHMuaW5zX2ggPDwgcy5oYXNoX3NoaWZ0KSBeIHMud2luZG93W3N0ciArIDFdKSAmIHMuaGFzaF9tYXNrO1xuLy8jaWYgTUlOX01BVENIICE9IDNcbi8vICAgICAgICBDYWxsIHVwZGF0ZV9oYXNoKCkgTUlOX01BVENILTMgbW9yZSB0aW1lc1xuLy8jZW5kaWZcbiAgICAgIHdoaWxlIChzLmluc2VydCkge1xuICAgICAgICAvKiBVUERBVEVfSEFTSChzLCBzLT5pbnNfaCwgcy0+d2luZG93W3N0ciArIE1JTl9NQVRDSC0xXSk7ICovXG4gICAgICAgIHMuaW5zX2ggPSAoKHMuaW5zX2ggPDwgcy5oYXNoX3NoaWZ0KSBeIHMud2luZG93W3N0ciArIE1JTl9NQVRDSCAtIDFdKSAmIHMuaGFzaF9tYXNrO1xuXG4gICAgICAgIHMucHJldltzdHIgJiBzLndfbWFza10gPSBzLmhlYWRbcy5pbnNfaF07XG4gICAgICAgIHMuaGVhZFtzLmluc19oXSA9IHN0cjtcbiAgICAgICAgc3RyKys7XG4gICAgICAgIHMuaW5zZXJ0LS07XG4gICAgICAgIGlmIChzLmxvb2thaGVhZCArIHMuaW5zZXJ0IDwgTUlOX01BVENIKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLyogSWYgdGhlIHdob2xlIGlucHV0IGhhcyBsZXNzIHRoYW4gTUlOX01BVENIIGJ5dGVzLCBpbnNfaCBpcyBnYXJiYWdlLFxuICAgICAqIGJ1dCB0aGlzIGlzIG5vdCBpbXBvcnRhbnQgc2luY2Ugb25seSBsaXRlcmFsIGJ5dGVzIHdpbGwgYmUgZW1pdHRlZC5cbiAgICAgKi9cblxuICB9IHdoaWxlIChzLmxvb2thaGVhZCA8IE1JTl9MT09LQUhFQUQgJiYgcy5zdHJtLmF2YWlsX2luICE9PSAwKTtcblxuICAvKiBJZiB0aGUgV0lOX0lOSVQgYnl0ZXMgYWZ0ZXIgdGhlIGVuZCBvZiB0aGUgY3VycmVudCBkYXRhIGhhdmUgbmV2ZXIgYmVlblxuICAgKiB3cml0dGVuLCB0aGVuIHplcm8gdGhvc2UgYnl0ZXMgaW4gb3JkZXIgdG8gYXZvaWQgbWVtb3J5IGNoZWNrIHJlcG9ydHMgb2ZcbiAgICogdGhlIHVzZSBvZiB1bmluaXRpYWxpemVkIChvciB1bmluaXRpYWxpc2VkIGFzIEp1bGlhbiB3cml0ZXMpIGJ5dGVzIGJ5XG4gICAqIHRoZSBsb25nZXN0IG1hdGNoIHJvdXRpbmVzLiAgVXBkYXRlIHRoZSBoaWdoIHdhdGVyIG1hcmsgZm9yIHRoZSBuZXh0XG4gICAqIHRpbWUgdGhyb3VnaCBoZXJlLiAgV0lOX0lOSVQgaXMgc2V0IHRvIE1BWF9NQVRDSCBzaW5jZSB0aGUgbG9uZ2VzdCBtYXRjaFxuICAgKiByb3V0aW5lcyBhbGxvdyBzY2FubmluZyB0byBzdHJzdGFydCArIE1BWF9NQVRDSCwgaWdub3JpbmcgbG9va2FoZWFkLlxuICAgKi9cbi8vICBpZiAocy5oaWdoX3dhdGVyIDwgcy53aW5kb3dfc2l6ZSkge1xuLy8gICAgdmFyIGN1cnIgPSBzLnN0cnN0YXJ0ICsgcy5sb29rYWhlYWQ7XG4vLyAgICB2YXIgaW5pdCA9IDA7XG4vL1xuLy8gICAgaWYgKHMuaGlnaF93YXRlciA8IGN1cnIpIHtcbi8vICAgICAgLyogUHJldmlvdXMgaGlnaCB3YXRlciBtYXJrIGJlbG93IGN1cnJlbnQgZGF0YSAtLSB6ZXJvIFdJTl9JTklUXG4vLyAgICAgICAqIGJ5dGVzIG9yIHVwIHRvIGVuZCBvZiB3aW5kb3csIHdoaWNoZXZlciBpcyBsZXNzLlxuLy8gICAgICAgKi9cbi8vICAgICAgaW5pdCA9IHMud2luZG93X3NpemUgLSBjdXJyO1xuLy8gICAgICBpZiAoaW5pdCA+IFdJTl9JTklUKVxuLy8gICAgICAgIGluaXQgPSBXSU5fSU5JVDtcbi8vICAgICAgem1lbXplcm8ocy0+d2luZG93ICsgY3VyciwgKHVuc2lnbmVkKWluaXQpO1xuLy8gICAgICBzLT5oaWdoX3dhdGVyID0gY3VyciArIGluaXQ7XG4vLyAgICB9XG4vLyAgICBlbHNlIGlmIChzLT5oaWdoX3dhdGVyIDwgKHVsZyljdXJyICsgV0lOX0lOSVQpIHtcbi8vICAgICAgLyogSGlnaCB3YXRlciBtYXJrIGF0IG9yIGFib3ZlIGN1cnJlbnQgZGF0YSwgYnV0IGJlbG93IGN1cnJlbnQgZGF0YVxuLy8gICAgICAgKiBwbHVzIFdJTl9JTklUIC0tIHplcm8gb3V0IHRvIGN1cnJlbnQgZGF0YSBwbHVzIFdJTl9JTklULCBvciB1cFxuLy8gICAgICAgKiB0byBlbmQgb2Ygd2luZG93LCB3aGljaGV2ZXIgaXMgbGVzcy5cbi8vICAgICAgICovXG4vLyAgICAgIGluaXQgPSAodWxnKWN1cnIgKyBXSU5fSU5JVCAtIHMtPmhpZ2hfd2F0ZXI7XG4vLyAgICAgIGlmIChpbml0ID4gcy0+d2luZG93X3NpemUgLSBzLT5oaWdoX3dhdGVyKVxuLy8gICAgICAgIGluaXQgPSBzLT53aW5kb3dfc2l6ZSAtIHMtPmhpZ2hfd2F0ZXI7XG4vLyAgICAgIHptZW16ZXJvKHMtPndpbmRvdyArIHMtPmhpZ2hfd2F0ZXIsICh1bnNpZ25lZClpbml0KTtcbi8vICAgICAgcy0+aGlnaF93YXRlciArPSBpbml0O1xuLy8gICAgfVxuLy8gIH1cbi8vXG4vLyAgQXNzZXJ0KCh1bGcpcy0+c3Ryc3RhcnQgPD0gcy0+d2luZG93X3NpemUgLSBNSU5fTE9PS0FIRUFELFxuLy8gICAgXCJub3QgZW5vdWdoIHJvb20gZm9yIHNlYXJjaFwiKTtcbn1cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb3B5IHdpdGhvdXQgY29tcHJlc3Npb24gYXMgbXVjaCBhcyBwb3NzaWJsZSBmcm9tIHRoZSBpbnB1dCBzdHJlYW0sIHJldHVyblxuICogdGhlIGN1cnJlbnQgYmxvY2sgc3RhdGUuXG4gKiBUaGlzIGZ1bmN0aW9uIGRvZXMgbm90IGluc2VydCBuZXcgc3RyaW5ncyBpbiB0aGUgZGljdGlvbmFyeSBzaW5jZVxuICogdW5jb21wcmVzc2libGUgZGF0YSBpcyBwcm9iYWJseSBub3QgdXNlZnVsLiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWRcbiAqIG9ubHkgZm9yIHRoZSBsZXZlbD0wIGNvbXByZXNzaW9uIG9wdGlvbi5cbiAqIE5PVEU6IHRoaXMgZnVuY3Rpb24gc2hvdWxkIGJlIG9wdGltaXplZCB0byBhdm9pZCBleHRyYSBjb3B5aW5nIGZyb21cbiAqIHdpbmRvdyB0byBwZW5kaW5nX2J1Zi5cbiAqL1xuZnVuY3Rpb24gZGVmbGF0ZV9zdG9yZWQocywgZmx1c2gpIHtcbiAgLyogU3RvcmVkIGJsb2NrcyBhcmUgbGltaXRlZCB0byAweGZmZmYgYnl0ZXMsIHBlbmRpbmdfYnVmIGlzIGxpbWl0ZWRcbiAgICogdG8gcGVuZGluZ19idWZfc2l6ZSwgYW5kIGVhY2ggc3RvcmVkIGJsb2NrIGhhcyBhIDUgYnl0ZSBoZWFkZXI6XG4gICAqL1xuICB2YXIgbWF4X2Jsb2NrX3NpemUgPSAweGZmZmY7XG5cbiAgaWYgKG1heF9ibG9ja19zaXplID4gcy5wZW5kaW5nX2J1Zl9zaXplIC0gNSkge1xuICAgIG1heF9ibG9ja19zaXplID0gcy5wZW5kaW5nX2J1Zl9zaXplIC0gNTtcbiAgfVxuXG4gIC8qIENvcHkgYXMgbXVjaCBhcyBwb3NzaWJsZSBmcm9tIGlucHV0IHRvIG91dHB1dDogKi9cbiAgZm9yICg7Oykge1xuICAgIC8qIEZpbGwgdGhlIHdpbmRvdyBhcyBtdWNoIGFzIHBvc3NpYmxlOiAqL1xuICAgIGlmIChzLmxvb2thaGVhZCA8PSAxKSB7XG5cbiAgICAgIC8vQXNzZXJ0KHMtPnN0cnN0YXJ0IDwgcy0+d19zaXplK01BWF9ESVNUKHMpIHx8XG4gICAgICAvLyAgcy0+YmxvY2tfc3RhcnQgPj0gKGxvbmcpcy0+d19zaXplLCBcInNsaWRlIHRvbyBsYXRlXCIpO1xuLy8gICAgICBpZiAoIShzLnN0cnN0YXJ0IDwgcy53X3NpemUgKyAocy53X3NpemUgLSBNSU5fTE9PS0FIRUFEKSB8fFxuLy8gICAgICAgIHMuYmxvY2tfc3RhcnQgPj0gcy53X3NpemUpKSB7XG4vLyAgICAgICAgdGhyb3cgIG5ldyBFcnJvcihcInNsaWRlIHRvbyBsYXRlXCIpO1xuLy8gICAgICB9XG5cbiAgICAgIGZpbGxfd2luZG93KHMpO1xuICAgICAgaWYgKHMubG9va2FoZWFkID09PSAwICYmIGZsdXNoID09PSBaX05PX0ZMVVNIKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG5cbiAgICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIC8qIGZsdXNoIHRoZSBjdXJyZW50IGJsb2NrICovXG4gICAgfVxuICAgIC8vQXNzZXJ0KHMtPmJsb2NrX3N0YXJ0ID49IDBMLCBcImJsb2NrIGdvbmVcIik7XG4vLyAgICBpZiAocy5ibG9ja19zdGFydCA8IDApIHRocm93IG5ldyBFcnJvcihcImJsb2NrIGdvbmVcIik7XG5cbiAgICBzLnN0cnN0YXJ0ICs9IHMubG9va2FoZWFkO1xuICAgIHMubG9va2FoZWFkID0gMDtcblxuICAgIC8qIEVtaXQgYSBzdG9yZWQgYmxvY2sgaWYgcGVuZGluZ19idWYgd2lsbCBiZSBmdWxsOiAqL1xuICAgIHZhciBtYXhfc3RhcnQgPSBzLmJsb2NrX3N0YXJ0ICsgbWF4X2Jsb2NrX3NpemU7XG5cbiAgICBpZiAocy5zdHJzdGFydCA9PT0gMCB8fCBzLnN0cnN0YXJ0ID49IG1heF9zdGFydCkge1xuICAgICAgLyogc3Ryc3RhcnQgPT0gMCBpcyBwb3NzaWJsZSB3aGVuIHdyYXBhcm91bmQgb24gMTYtYml0IG1hY2hpbmUgKi9cbiAgICAgIHMubG9va2FoZWFkID0gcy5zdHJzdGFydCAtIG1heF9zdGFydDtcbiAgICAgIHMuc3Ryc3RhcnQgPSBtYXhfc3RhcnQ7XG4gICAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG4gICAgICAvKioqL1xuXG5cbiAgICB9XG4gICAgLyogRmx1c2ggaWYgd2UgbWF5IGhhdmUgdG8gc2xpZGUsIG90aGVyd2lzZSBibG9ja19zdGFydCBtYXkgYmVjb21lXG4gICAgICogbmVnYXRpdmUgYW5kIHRoZSBkYXRhIHdpbGwgYmUgZ29uZTpcbiAgICAgKi9cbiAgICBpZiAocy5zdHJzdGFydCAtIHMuYmxvY2tfc3RhcnQgPj0gKHMud19zaXplIC0gTUlOX0xPT0tBSEVBRCkpIHtcbiAgICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICAgIC8qKiovXG4gICAgfVxuICB9XG5cbiAgcy5pbnNlcnQgPSAwO1xuXG4gIGlmIChmbHVzaCA9PT0gWl9GSU5JU0gpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDEpOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCB0cnVlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX0ZJTklTSF9TVEFSVEVEO1xuICAgIH1cbiAgICAvKioqL1xuICAgIHJldHVybiBCU19GSU5JU0hfRE9ORTtcbiAgfVxuXG4gIGlmIChzLnN0cnN0YXJ0ID4gcy5ibG9ja19zdGFydCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICB9XG4gICAgLyoqKi9cbiAgfVxuXG4gIHJldHVybiBCU19ORUVEX01PUkU7XG59XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29tcHJlc3MgYXMgbXVjaCBhcyBwb3NzaWJsZSBmcm9tIHRoZSBpbnB1dCBzdHJlYW0sIHJldHVybiB0aGUgY3VycmVudFxuICogYmxvY2sgc3RhdGUuXG4gKiBUaGlzIGZ1bmN0aW9uIGRvZXMgbm90IHBlcmZvcm0gbGF6eSBldmFsdWF0aW9uIG9mIG1hdGNoZXMgYW5kIGluc2VydHNcbiAqIG5ldyBzdHJpbmdzIGluIHRoZSBkaWN0aW9uYXJ5IG9ubHkgZm9yIHVubWF0Y2hlZCBzdHJpbmdzIG9yIGZvciBzaG9ydFxuICogbWF0Y2hlcy4gSXQgaXMgdXNlZCBvbmx5IGZvciB0aGUgZmFzdCBjb21wcmVzc2lvbiBvcHRpb25zLlxuICovXG5mdW5jdGlvbiBkZWZsYXRlX2Zhc3QocywgZmx1c2gpIHtcbiAgdmFyIGhhc2hfaGVhZDsgICAgICAgIC8qIGhlYWQgb2YgdGhlIGhhc2ggY2hhaW4gKi9cbiAgdmFyIGJmbHVzaDsgICAgICAgICAgIC8qIHNldCBpZiBjdXJyZW50IGJsb2NrIG11c3QgYmUgZmx1c2hlZCAqL1xuXG4gIGZvciAoOzspIHtcbiAgICAvKiBNYWtlIHN1cmUgdGhhdCB3ZSBhbHdheXMgaGF2ZSBlbm91Z2ggbG9va2FoZWFkLCBleGNlcHRcbiAgICAgKiBhdCB0aGUgZW5kIG9mIHRoZSBpbnB1dCBmaWxlLiBXZSBuZWVkIE1BWF9NQVRDSCBieXRlc1xuICAgICAqIGZvciB0aGUgbmV4dCBtYXRjaCwgcGx1cyBNSU5fTUFUQ0ggYnl0ZXMgdG8gaW5zZXJ0IHRoZVxuICAgICAqIHN0cmluZyBmb2xsb3dpbmcgdGhlIG5leHQgbWF0Y2guXG4gICAgICovXG4gICAgaWYgKHMubG9va2FoZWFkIDwgTUlOX0xPT0tBSEVBRCkge1xuICAgICAgZmlsbF93aW5kb3cocyk7XG4gICAgICBpZiAocy5sb29rYWhlYWQgPCBNSU5fTE9PS0FIRUFEICYmIGZsdXNoID09PSBaX05PX0ZMVVNIKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG4gICAgICBpZiAocy5sb29rYWhlYWQgPT09IDApIHtcbiAgICAgICAgYnJlYWs7IC8qIGZsdXNoIHRoZSBjdXJyZW50IGJsb2NrICovXG4gICAgICB9XG4gICAgfVxuXG4gICAgLyogSW5zZXJ0IHRoZSBzdHJpbmcgd2luZG93W3N0cnN0YXJ0IC4uIHN0cnN0YXJ0KzJdIGluIHRoZVxuICAgICAqIGRpY3Rpb25hcnksIGFuZCBzZXQgaGFzaF9oZWFkIHRvIHRoZSBoZWFkIG9mIHRoZSBoYXNoIGNoYWluOlxuICAgICAqL1xuICAgIGhhc2hfaGVhZCA9IDAvKk5JTCovO1xuICAgIGlmIChzLmxvb2thaGVhZCA+PSBNSU5fTUFUQ0gpIHtcbiAgICAgIC8qKiogSU5TRVJUX1NUUklORyhzLCBzLnN0cnN0YXJ0LCBoYXNoX2hlYWQpOyAqKiovXG4gICAgICBzLmluc19oID0gKChzLmluc19oIDw8IHMuaGFzaF9zaGlmdCkgXiBzLndpbmRvd1tzLnN0cnN0YXJ0ICsgTUlOX01BVENIIC0gMV0pICYgcy5oYXNoX21hc2s7XG4gICAgICBoYXNoX2hlYWQgPSBzLnByZXZbcy5zdHJzdGFydCAmIHMud19tYXNrXSA9IHMuaGVhZFtzLmluc19oXTtcbiAgICAgIHMuaGVhZFtzLmluc19oXSA9IHMuc3Ryc3RhcnQ7XG4gICAgICAvKioqL1xuICAgIH1cblxuICAgIC8qIEZpbmQgdGhlIGxvbmdlc3QgbWF0Y2gsIGRpc2NhcmRpbmcgdGhvc2UgPD0gcHJldl9sZW5ndGguXG4gICAgICogQXQgdGhpcyBwb2ludCB3ZSBoYXZlIGFsd2F5cyBtYXRjaF9sZW5ndGggPCBNSU5fTUFUQ0hcbiAgICAgKi9cbiAgICBpZiAoaGFzaF9oZWFkICE9PSAwLypOSUwqLyAmJiAoKHMuc3Ryc3RhcnQgLSBoYXNoX2hlYWQpIDw9IChzLndfc2l6ZSAtIE1JTl9MT09LQUhFQUQpKSkge1xuICAgICAgLyogVG8gc2ltcGxpZnkgdGhlIGNvZGUsIHdlIHByZXZlbnQgbWF0Y2hlcyB3aXRoIHRoZSBzdHJpbmdcbiAgICAgICAqIG9mIHdpbmRvdyBpbmRleCAwIChpbiBwYXJ0aWN1bGFyIHdlIGhhdmUgdG8gYXZvaWQgYSBtYXRjaFxuICAgICAgICogb2YgdGhlIHN0cmluZyB3aXRoIGl0c2VsZiBhdCB0aGUgc3RhcnQgb2YgdGhlIGlucHV0IGZpbGUpLlxuICAgICAgICovXG4gICAgICBzLm1hdGNoX2xlbmd0aCA9IGxvbmdlc3RfbWF0Y2gocywgaGFzaF9oZWFkKTtcbiAgICAgIC8qIGxvbmdlc3RfbWF0Y2goKSBzZXRzIG1hdGNoX3N0YXJ0ICovXG4gICAgfVxuICAgIGlmIChzLm1hdGNoX2xlbmd0aCA+PSBNSU5fTUFUQ0gpIHtcbiAgICAgIC8vIGNoZWNrX21hdGNoKHMsIHMuc3Ryc3RhcnQsIHMubWF0Y2hfc3RhcnQsIHMubWF0Y2hfbGVuZ3RoKTsgLy8gZm9yIGRlYnVnIG9ubHlcblxuICAgICAgLyoqKiBfdHJfdGFsbHlfZGlzdChzLCBzLnN0cnN0YXJ0IC0gcy5tYXRjaF9zdGFydCxcbiAgICAgICAgICAgICAgICAgICAgIHMubWF0Y2hfbGVuZ3RoIC0gTUlOX01BVENILCBiZmx1c2gpOyAqKiovXG4gICAgICBiZmx1c2ggPSB0cmVlcy5fdHJfdGFsbHkocywgcy5zdHJzdGFydCAtIHMubWF0Y2hfc3RhcnQsIHMubWF0Y2hfbGVuZ3RoIC0gTUlOX01BVENIKTtcblxuICAgICAgcy5sb29rYWhlYWQgLT0gcy5tYXRjaF9sZW5ndGg7XG5cbiAgICAgIC8qIEluc2VydCBuZXcgc3RyaW5ncyBpbiB0aGUgaGFzaCB0YWJsZSBvbmx5IGlmIHRoZSBtYXRjaCBsZW5ndGhcbiAgICAgICAqIGlzIG5vdCB0b28gbGFyZ2UuIFRoaXMgc2F2ZXMgdGltZSBidXQgZGVncmFkZXMgY29tcHJlc3Npb24uXG4gICAgICAgKi9cbiAgICAgIGlmIChzLm1hdGNoX2xlbmd0aCA8PSBzLm1heF9sYXp5X21hdGNoLyptYXhfaW5zZXJ0X2xlbmd0aCovICYmIHMubG9va2FoZWFkID49IE1JTl9NQVRDSCkge1xuICAgICAgICBzLm1hdGNoX2xlbmd0aC0tOyAvKiBzdHJpbmcgYXQgc3Ryc3RhcnQgYWxyZWFkeSBpbiB0YWJsZSAqL1xuICAgICAgICBkbyB7XG4gICAgICAgICAgcy5zdHJzdGFydCsrO1xuICAgICAgICAgIC8qKiogSU5TRVJUX1NUUklORyhzLCBzLnN0cnN0YXJ0LCBoYXNoX2hlYWQpOyAqKiovXG4gICAgICAgICAgcy5pbnNfaCA9ICgocy5pbnNfaCA8PCBzLmhhc2hfc2hpZnQpIF4gcy53aW5kb3dbcy5zdHJzdGFydCArIE1JTl9NQVRDSCAtIDFdKSAmIHMuaGFzaF9tYXNrO1xuICAgICAgICAgIGhhc2hfaGVhZCA9IHMucHJldltzLnN0cnN0YXJ0ICYgcy53X21hc2tdID0gcy5oZWFkW3MuaW5zX2hdO1xuICAgICAgICAgIHMuaGVhZFtzLmluc19oXSA9IHMuc3Ryc3RhcnQ7XG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgICAvKiBzdHJzdGFydCBuZXZlciBleGNlZWRzIFdTSVpFLU1BWF9NQVRDSCwgc28gdGhlcmUgYXJlXG4gICAgICAgICAgICogYWx3YXlzIE1JTl9NQVRDSCBieXRlcyBhaGVhZC5cbiAgICAgICAgICAgKi9cbiAgICAgICAgfSB3aGlsZSAoLS1zLm1hdGNoX2xlbmd0aCAhPT0gMCk7XG4gICAgICAgIHMuc3Ryc3RhcnQrKztcbiAgICAgIH0gZWxzZVxuICAgICAge1xuICAgICAgICBzLnN0cnN0YXJ0ICs9IHMubWF0Y2hfbGVuZ3RoO1xuICAgICAgICBzLm1hdGNoX2xlbmd0aCA9IDA7XG4gICAgICAgIHMuaW5zX2ggPSBzLndpbmRvd1tzLnN0cnN0YXJ0XTtcbiAgICAgICAgLyogVVBEQVRFX0hBU0gocywgcy5pbnNfaCwgcy53aW5kb3dbcy5zdHJzdGFydCsxXSk7ICovXG4gICAgICAgIHMuaW5zX2ggPSAoKHMuaW5zX2ggPDwgcy5oYXNoX3NoaWZ0KSBeIHMud2luZG93W3Muc3Ryc3RhcnQgKyAxXSkgJiBzLmhhc2hfbWFzaztcblxuLy8jaWYgTUlOX01BVENIICE9IDNcbi8vICAgICAgICAgICAgICAgIENhbGwgVVBEQVRFX0hBU0goKSBNSU5fTUFUQ0gtMyBtb3JlIHRpbWVzXG4vLyNlbmRpZlxuICAgICAgICAvKiBJZiBsb29rYWhlYWQgPCBNSU5fTUFUQ0gsIGluc19oIGlzIGdhcmJhZ2UsIGJ1dCBpdCBkb2VzIG5vdFxuICAgICAgICAgKiBtYXR0ZXIgc2luY2UgaXQgd2lsbCBiZSByZWNvbXB1dGVkIGF0IG5leHQgZGVmbGF0ZSBjYWxsLlxuICAgICAgICAgKi9cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLyogTm8gbWF0Y2gsIG91dHB1dCBhIGxpdGVyYWwgYnl0ZSAqL1xuICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsXCIlY1wiLCBzLndpbmRvd1tzLnN0cnN0YXJ0XSkpO1xuICAgICAgLyoqKiBfdHJfdGFsbHlfbGl0KHMsIHMud2luZG93W3Muc3Ryc3RhcnRdLCBiZmx1c2gpOyAqKiovXG4gICAgICBiZmx1c2ggPSB0cmVlcy5fdHJfdGFsbHkocywgMCwgcy53aW5kb3dbcy5zdHJzdGFydF0pO1xuXG4gICAgICBzLmxvb2thaGVhZC0tO1xuICAgICAgcy5zdHJzdGFydCsrO1xuICAgIH1cbiAgICBpZiAoYmZsdXNoKSB7XG4gICAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG4gICAgICAvKioqL1xuICAgIH1cbiAgfVxuICBzLmluc2VydCA9ICgocy5zdHJzdGFydCA8IChNSU5fTUFUQ0ggLSAxKSkgPyBzLnN0cnN0YXJ0IDogTUlOX01BVENIIC0gMSk7XG4gIGlmIChmbHVzaCA9PT0gWl9GSU5JU0gpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDEpOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCB0cnVlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX0ZJTklTSF9TVEFSVEVEO1xuICAgIH1cbiAgICAvKioqL1xuICAgIHJldHVybiBCU19GSU5JU0hfRE9ORTtcbiAgfVxuICBpZiAocy5sYXN0X2xpdCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICB9XG4gICAgLyoqKi9cbiAgfVxuICByZXR1cm4gQlNfQkxPQ0tfRE9ORTtcbn1cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTYW1lIGFzIGFib3ZlLCBidXQgYWNoaWV2ZXMgYmV0dGVyIGNvbXByZXNzaW9uLiBXZSB1c2UgYSBsYXp5XG4gKiBldmFsdWF0aW9uIGZvciBtYXRjaGVzOiBhIG1hdGNoIGlzIGZpbmFsbHkgYWRvcHRlZCBvbmx5IGlmIHRoZXJlIGlzXG4gKiBubyBiZXR0ZXIgbWF0Y2ggYXQgdGhlIG5leHQgd2luZG93IHBvc2l0aW9uLlxuICovXG5mdW5jdGlvbiBkZWZsYXRlX3Nsb3cocywgZmx1c2gpIHtcbiAgdmFyIGhhc2hfaGVhZDsgICAgICAgICAgLyogaGVhZCBvZiBoYXNoIGNoYWluICovXG4gIHZhciBiZmx1c2g7ICAgICAgICAgICAgICAvKiBzZXQgaWYgY3VycmVudCBibG9jayBtdXN0IGJlIGZsdXNoZWQgKi9cblxuICB2YXIgbWF4X2luc2VydDtcblxuICAvKiBQcm9jZXNzIHRoZSBpbnB1dCBibG9jay4gKi9cbiAgZm9yICg7Oykge1xuICAgIC8qIE1ha2Ugc3VyZSB0aGF0IHdlIGFsd2F5cyBoYXZlIGVub3VnaCBsb29rYWhlYWQsIGV4Y2VwdFxuICAgICAqIGF0IHRoZSBlbmQgb2YgdGhlIGlucHV0IGZpbGUuIFdlIG5lZWQgTUFYX01BVENIIGJ5dGVzXG4gICAgICogZm9yIHRoZSBuZXh0IG1hdGNoLCBwbHVzIE1JTl9NQVRDSCBieXRlcyB0byBpbnNlcnQgdGhlXG4gICAgICogc3RyaW5nIGZvbGxvd2luZyB0aGUgbmV4dCBtYXRjaC5cbiAgICAgKi9cbiAgICBpZiAocy5sb29rYWhlYWQgPCBNSU5fTE9PS0FIRUFEKSB7XG4gICAgICBmaWxsX3dpbmRvdyhzKTtcbiAgICAgIGlmIChzLmxvb2thaGVhZCA8IE1JTl9MT09LQUhFQUQgJiYgZmx1c2ggPT09IFpfTk9fRkxVU0gpIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkgeyBicmVhazsgfSAvKiBmbHVzaCB0aGUgY3VycmVudCBibG9jayAqL1xuICAgIH1cblxuICAgIC8qIEluc2VydCB0aGUgc3RyaW5nIHdpbmRvd1tzdHJzdGFydCAuLiBzdHJzdGFydCsyXSBpbiB0aGVcbiAgICAgKiBkaWN0aW9uYXJ5LCBhbmQgc2V0IGhhc2hfaGVhZCB0byB0aGUgaGVhZCBvZiB0aGUgaGFzaCBjaGFpbjpcbiAgICAgKi9cbiAgICBoYXNoX2hlYWQgPSAwLypOSUwqLztcbiAgICBpZiAocy5sb29rYWhlYWQgPj0gTUlOX01BVENIKSB7XG4gICAgICAvKioqIElOU0VSVF9TVFJJTkcocywgcy5zdHJzdGFydCwgaGFzaF9oZWFkKTsgKioqL1xuICAgICAgcy5pbnNfaCA9ICgocy5pbnNfaCA8PCBzLmhhc2hfc2hpZnQpIF4gcy53aW5kb3dbcy5zdHJzdGFydCArIE1JTl9NQVRDSCAtIDFdKSAmIHMuaGFzaF9tYXNrO1xuICAgICAgaGFzaF9oZWFkID0gcy5wcmV2W3Muc3Ryc3RhcnQgJiBzLndfbWFza10gPSBzLmhlYWRbcy5pbnNfaF07XG4gICAgICBzLmhlYWRbcy5pbnNfaF0gPSBzLnN0cnN0YXJ0O1xuICAgICAgLyoqKi9cbiAgICB9XG5cbiAgICAvKiBGaW5kIHRoZSBsb25nZXN0IG1hdGNoLCBkaXNjYXJkaW5nIHRob3NlIDw9IHByZXZfbGVuZ3RoLlxuICAgICAqL1xuICAgIHMucHJldl9sZW5ndGggPSBzLm1hdGNoX2xlbmd0aDtcbiAgICBzLnByZXZfbWF0Y2ggPSBzLm1hdGNoX3N0YXJ0O1xuICAgIHMubWF0Y2hfbGVuZ3RoID0gTUlOX01BVENIIC0gMTtcblxuICAgIGlmIChoYXNoX2hlYWQgIT09IDAvKk5JTCovICYmIHMucHJldl9sZW5ndGggPCBzLm1heF9sYXp5X21hdGNoICYmXG4gICAgICAgIHMuc3Ryc3RhcnQgLSBoYXNoX2hlYWQgPD0gKHMud19zaXplIC0gTUlOX0xPT0tBSEVBRCkvKk1BWF9ESVNUKHMpKi8pIHtcbiAgICAgIC8qIFRvIHNpbXBsaWZ5IHRoZSBjb2RlLCB3ZSBwcmV2ZW50IG1hdGNoZXMgd2l0aCB0aGUgc3RyaW5nXG4gICAgICAgKiBvZiB3aW5kb3cgaW5kZXggMCAoaW4gcGFydGljdWxhciB3ZSBoYXZlIHRvIGF2b2lkIGEgbWF0Y2hcbiAgICAgICAqIG9mIHRoZSBzdHJpbmcgd2l0aCBpdHNlbGYgYXQgdGhlIHN0YXJ0IG9mIHRoZSBpbnB1dCBmaWxlKS5cbiAgICAgICAqL1xuICAgICAgcy5tYXRjaF9sZW5ndGggPSBsb25nZXN0X21hdGNoKHMsIGhhc2hfaGVhZCk7XG4gICAgICAvKiBsb25nZXN0X21hdGNoKCkgc2V0cyBtYXRjaF9zdGFydCAqL1xuXG4gICAgICBpZiAocy5tYXRjaF9sZW5ndGggPD0gNSAmJlxuICAgICAgICAgKHMuc3RyYXRlZ3kgPT09IFpfRklMVEVSRUQgfHwgKHMubWF0Y2hfbGVuZ3RoID09PSBNSU5fTUFUQ0ggJiYgcy5zdHJzdGFydCAtIHMubWF0Y2hfc3RhcnQgPiA0MDk2LypUT09fRkFSKi8pKSkge1xuXG4gICAgICAgIC8qIElmIHByZXZfbWF0Y2ggaXMgYWxzbyBNSU5fTUFUQ0gsIG1hdGNoX3N0YXJ0IGlzIGdhcmJhZ2VcbiAgICAgICAgICogYnV0IHdlIHdpbGwgaWdub3JlIHRoZSBjdXJyZW50IG1hdGNoIGFueXdheS5cbiAgICAgICAgICovXG4gICAgICAgIHMubWF0Y2hfbGVuZ3RoID0gTUlOX01BVENIIC0gMTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyogSWYgdGhlcmUgd2FzIGEgbWF0Y2ggYXQgdGhlIHByZXZpb3VzIHN0ZXAgYW5kIHRoZSBjdXJyZW50XG4gICAgICogbWF0Y2ggaXMgbm90IGJldHRlciwgb3V0cHV0IHRoZSBwcmV2aW91cyBtYXRjaDpcbiAgICAgKi9cbiAgICBpZiAocy5wcmV2X2xlbmd0aCA+PSBNSU5fTUFUQ0ggJiYgcy5tYXRjaF9sZW5ndGggPD0gcy5wcmV2X2xlbmd0aCkge1xuICAgICAgbWF4X2luc2VydCA9IHMuc3Ryc3RhcnQgKyBzLmxvb2thaGVhZCAtIE1JTl9NQVRDSDtcbiAgICAgIC8qIERvIG5vdCBpbnNlcnQgc3RyaW5ncyBpbiBoYXNoIHRhYmxlIGJleW9uZCB0aGlzLiAqL1xuXG4gICAgICAvL2NoZWNrX21hdGNoKHMsIHMuc3Ryc3RhcnQtMSwgcy5wcmV2X21hdGNoLCBzLnByZXZfbGVuZ3RoKTtcblxuICAgICAgLyoqKl90cl90YWxseV9kaXN0KHMsIHMuc3Ryc3RhcnQgLSAxIC0gcy5wcmV2X21hdGNoLFxuICAgICAgICAgICAgICAgICAgICAgcy5wcmV2X2xlbmd0aCAtIE1JTl9NQVRDSCwgYmZsdXNoKTsqKiovXG4gICAgICBiZmx1c2ggPSB0cmVlcy5fdHJfdGFsbHkocywgcy5zdHJzdGFydCAtIDEgLSBzLnByZXZfbWF0Y2gsIHMucHJldl9sZW5ndGggLSBNSU5fTUFUQ0gpO1xuICAgICAgLyogSW5zZXJ0IGluIGhhc2ggdGFibGUgYWxsIHN0cmluZ3MgdXAgdG8gdGhlIGVuZCBvZiB0aGUgbWF0Y2guXG4gICAgICAgKiBzdHJzdGFydC0xIGFuZCBzdHJzdGFydCBhcmUgYWxyZWFkeSBpbnNlcnRlZC4gSWYgdGhlcmUgaXMgbm90XG4gICAgICAgKiBlbm91Z2ggbG9va2FoZWFkLCB0aGUgbGFzdCB0d28gc3RyaW5ncyBhcmUgbm90IGluc2VydGVkIGluXG4gICAgICAgKiB0aGUgaGFzaCB0YWJsZS5cbiAgICAgICAqL1xuICAgICAgcy5sb29rYWhlYWQgLT0gcy5wcmV2X2xlbmd0aCAtIDE7XG4gICAgICBzLnByZXZfbGVuZ3RoIC09IDI7XG4gICAgICBkbyB7XG4gICAgICAgIGlmICgrK3Muc3Ryc3RhcnQgPD0gbWF4X2luc2VydCkge1xuICAgICAgICAgIC8qKiogSU5TRVJUX1NUUklORyhzLCBzLnN0cnN0YXJ0LCBoYXNoX2hlYWQpOyAqKiovXG4gICAgICAgICAgcy5pbnNfaCA9ICgocy5pbnNfaCA8PCBzLmhhc2hfc2hpZnQpIF4gcy53aW5kb3dbcy5zdHJzdGFydCArIE1JTl9NQVRDSCAtIDFdKSAmIHMuaGFzaF9tYXNrO1xuICAgICAgICAgIGhhc2hfaGVhZCA9IHMucHJldltzLnN0cnN0YXJ0ICYgcy53X21hc2tdID0gcy5oZWFkW3MuaW5zX2hdO1xuICAgICAgICAgIHMuaGVhZFtzLmluc19oXSA9IHMuc3Ryc3RhcnQ7XG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfVxuICAgICAgfSB3aGlsZSAoLS1zLnByZXZfbGVuZ3RoICE9PSAwKTtcbiAgICAgIHMubWF0Y2hfYXZhaWxhYmxlID0gMDtcbiAgICAgIHMubWF0Y2hfbGVuZ3RoID0gTUlOX01BVENIIC0gMTtcbiAgICAgIHMuc3Ryc3RhcnQrKztcblxuICAgICAgaWYgKGJmbHVzaCkge1xuICAgICAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICAgIH1cbiAgICAgICAgLyoqKi9cbiAgICAgIH1cblxuICAgIH0gZWxzZSBpZiAocy5tYXRjaF9hdmFpbGFibGUpIHtcbiAgICAgIC8qIElmIHRoZXJlIHdhcyBubyBtYXRjaCBhdCB0aGUgcHJldmlvdXMgcG9zaXRpb24sIG91dHB1dCBhXG4gICAgICAgKiBzaW5nbGUgbGl0ZXJhbC4gSWYgdGhlcmUgd2FzIGEgbWF0Y2ggYnV0IHRoZSBjdXJyZW50IG1hdGNoXG4gICAgICAgKiBpcyBsb25nZXIsIHRydW5jYXRlIHRoZSBwcmV2aW91cyBtYXRjaCB0byBhIHNpbmdsZSBsaXRlcmFsLlxuICAgICAgICovXG4gICAgICAvL1RyYWNldnYoKHN0ZGVycixcIiVjXCIsIHMtPndpbmRvd1tzLT5zdHJzdGFydC0xXSkpO1xuICAgICAgLyoqKiBfdHJfdGFsbHlfbGl0KHMsIHMud2luZG93W3Muc3Ryc3RhcnQtMV0sIGJmbHVzaCk7ICoqKi9cbiAgICAgIGJmbHVzaCA9IHRyZWVzLl90cl90YWxseShzLCAwLCBzLndpbmRvd1tzLnN0cnN0YXJ0IC0gMV0pO1xuXG4gICAgICBpZiAoYmZsdXNoKSB7XG4gICAgICAgIC8qKiogRkxVU0hfQkxPQ0tfT05MWShzLCAwKSAqKiovXG4gICAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgICAgICAvKioqL1xuICAgICAgfVxuICAgICAgcy5zdHJzdGFydCsrO1xuICAgICAgcy5sb29rYWhlYWQtLTtcbiAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8qIFRoZXJlIGlzIG5vIHByZXZpb3VzIG1hdGNoIHRvIGNvbXBhcmUgd2l0aCwgd2FpdCBmb3JcbiAgICAgICAqIHRoZSBuZXh0IHN0ZXAgdG8gZGVjaWRlLlxuICAgICAgICovXG4gICAgICBzLm1hdGNoX2F2YWlsYWJsZSA9IDE7XG4gICAgICBzLnN0cnN0YXJ0Kys7XG4gICAgICBzLmxvb2thaGVhZC0tO1xuICAgIH1cbiAgfVxuICAvL0Fzc2VydCAoZmx1c2ggIT0gWl9OT19GTFVTSCwgXCJubyBmbHVzaD9cIik7XG4gIGlmIChzLm1hdGNoX2F2YWlsYWJsZSkge1xuICAgIC8vVHJhY2V2digoc3RkZXJyLFwiJWNcIiwgcy0+d2luZG93W3MtPnN0cnN0YXJ0LTFdKSk7XG4gICAgLyoqKiBfdHJfdGFsbHlfbGl0KHMsIHMud2luZG93W3Muc3Ryc3RhcnQtMV0sIGJmbHVzaCk7ICoqKi9cbiAgICBiZmx1c2ggPSB0cmVlcy5fdHJfdGFsbHkocywgMCwgcy53aW5kb3dbcy5zdHJzdGFydCAtIDFdKTtcblxuICAgIHMubWF0Y2hfYXZhaWxhYmxlID0gMDtcbiAgfVxuICBzLmluc2VydCA9IHMuc3Ryc3RhcnQgPCBNSU5fTUFUQ0ggLSAxID8gcy5zdHJzdGFydCA6IE1JTl9NQVRDSCAtIDE7XG4gIGlmIChmbHVzaCA9PT0gWl9GSU5JU0gpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDEpOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCB0cnVlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX0ZJTklTSF9TVEFSVEVEO1xuICAgIH1cbiAgICAvKioqL1xuICAgIHJldHVybiBCU19GSU5JU0hfRE9ORTtcbiAgfVxuICBpZiAocy5sYXN0X2xpdCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICB9XG4gICAgLyoqKi9cbiAgfVxuXG4gIHJldHVybiBCU19CTE9DS19ET05FO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogRm9yIFpfUkxFLCBzaW1wbHkgbG9vayBmb3IgcnVucyBvZiBieXRlcywgZ2VuZXJhdGUgbWF0Y2hlcyBvbmx5IG9mIGRpc3RhbmNlXG4gKiBvbmUuICBEbyBub3QgbWFpbnRhaW4gYSBoYXNoIHRhYmxlLiAgKEl0IHdpbGwgYmUgcmVnZW5lcmF0ZWQgaWYgdGhpcyBydW4gb2ZcbiAqIGRlZmxhdGUgc3dpdGNoZXMgYXdheSBmcm9tIFpfUkxFLilcbiAqL1xuZnVuY3Rpb24gZGVmbGF0ZV9ybGUocywgZmx1c2gpIHtcbiAgdmFyIGJmbHVzaDsgICAgICAgICAgICAvKiBzZXQgaWYgY3VycmVudCBibG9jayBtdXN0IGJlIGZsdXNoZWQgKi9cbiAgdmFyIHByZXY7ICAgICAgICAgICAgICAvKiBieXRlIGF0IGRpc3RhbmNlIG9uZSB0byBtYXRjaCAqL1xuICB2YXIgc2Nhbiwgc3RyZW5kOyAgICAgIC8qIHNjYW4gZ29lcyB1cCB0byBzdHJlbmQgZm9yIGxlbmd0aCBvZiBydW4gKi9cblxuICB2YXIgX3dpbiA9IHMud2luZG93O1xuXG4gIGZvciAoOzspIHtcbiAgICAvKiBNYWtlIHN1cmUgdGhhdCB3ZSBhbHdheXMgaGF2ZSBlbm91Z2ggbG9va2FoZWFkLCBleGNlcHRcbiAgICAgKiBhdCB0aGUgZW5kIG9mIHRoZSBpbnB1dCBmaWxlLiBXZSBuZWVkIE1BWF9NQVRDSCBieXRlc1xuICAgICAqIGZvciB0aGUgbG9uZ2VzdCBydW4sIHBsdXMgb25lIGZvciB0aGUgdW5yb2xsZWQgbG9vcC5cbiAgICAgKi9cbiAgICBpZiAocy5sb29rYWhlYWQgPD0gTUFYX01BVENIKSB7XG4gICAgICBmaWxsX3dpbmRvdyhzKTtcbiAgICAgIGlmIChzLmxvb2thaGVhZCA8PSBNQVhfTUFUQ0ggJiYgZmx1c2ggPT09IFpfTk9fRkxVU0gpIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkgeyBicmVhazsgfSAvKiBmbHVzaCB0aGUgY3VycmVudCBibG9jayAqL1xuICAgIH1cblxuICAgIC8qIFNlZSBob3cgbWFueSB0aW1lcyB0aGUgcHJldmlvdXMgYnl0ZSByZXBlYXRzICovXG4gICAgcy5tYXRjaF9sZW5ndGggPSAwO1xuICAgIGlmIChzLmxvb2thaGVhZCA+PSBNSU5fTUFUQ0ggJiYgcy5zdHJzdGFydCA+IDApIHtcbiAgICAgIHNjYW4gPSBzLnN0cnN0YXJ0IC0gMTtcbiAgICAgIHByZXYgPSBfd2luW3NjYW5dO1xuICAgICAgaWYgKHByZXYgPT09IF93aW5bKytzY2FuXSAmJiBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiYgcHJldiA9PT0gX3dpblsrK3NjYW5dKSB7XG4gICAgICAgIHN0cmVuZCA9IHMuc3Ryc3RhcnQgKyBNQVhfTUFUQ0g7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAvKmpzaGludCBub2VtcHR5OmZhbHNlKi9cbiAgICAgICAgfSB3aGlsZSAocHJldiA9PT0gX3dpblsrK3NjYW5dICYmIHByZXYgPT09IF93aW5bKytzY2FuXSAmJlxuICAgICAgICAgICAgICAgICBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiYgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmXG4gICAgICAgICAgICAgICAgIHByZXYgPT09IF93aW5bKytzY2FuXSAmJiBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiZcbiAgICAgICAgICAgICAgICAgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmIHByZXYgPT09IF93aW5bKytzY2FuXSAmJlxuICAgICAgICAgICAgICAgICBzY2FuIDwgc3RyZW5kKTtcbiAgICAgICAgcy5tYXRjaF9sZW5ndGggPSBNQVhfTUFUQ0ggLSAoc3RyZW5kIC0gc2Nhbik7XG4gICAgICAgIGlmIChzLm1hdGNoX2xlbmd0aCA+IHMubG9va2FoZWFkKSB7XG4gICAgICAgICAgcy5tYXRjaF9sZW5ndGggPSBzLmxvb2thaGVhZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy9Bc3NlcnQoc2NhbiA8PSBzLT53aW5kb3crKHVJbnQpKHMtPndpbmRvd19zaXplLTEpLCBcIndpbGQgc2NhblwiKTtcbiAgICB9XG5cbiAgICAvKiBFbWl0IG1hdGNoIGlmIGhhdmUgcnVuIG9mIE1JTl9NQVRDSCBvciBsb25nZXIsIGVsc2UgZW1pdCBsaXRlcmFsICovXG4gICAgaWYgKHMubWF0Y2hfbGVuZ3RoID49IE1JTl9NQVRDSCkge1xuICAgICAgLy9jaGVja19tYXRjaChzLCBzLnN0cnN0YXJ0LCBzLnN0cnN0YXJ0IC0gMSwgcy5tYXRjaF9sZW5ndGgpO1xuXG4gICAgICAvKioqIF90cl90YWxseV9kaXN0KHMsIDEsIHMubWF0Y2hfbGVuZ3RoIC0gTUlOX01BVENILCBiZmx1c2gpOyAqKiovXG4gICAgICBiZmx1c2ggPSB0cmVlcy5fdHJfdGFsbHkocywgMSwgcy5tYXRjaF9sZW5ndGggLSBNSU5fTUFUQ0gpO1xuXG4gICAgICBzLmxvb2thaGVhZCAtPSBzLm1hdGNoX2xlbmd0aDtcbiAgICAgIHMuc3Ryc3RhcnQgKz0gcy5tYXRjaF9sZW5ndGg7XG4gICAgICBzLm1hdGNoX2xlbmd0aCA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8qIE5vIG1hdGNoLCBvdXRwdXQgYSBsaXRlcmFsIGJ5dGUgKi9cbiAgICAgIC8vVHJhY2V2digoc3RkZXJyLFwiJWNcIiwgcy0+d2luZG93W3MtPnN0cnN0YXJ0XSkpO1xuICAgICAgLyoqKiBfdHJfdGFsbHlfbGl0KHMsIHMud2luZG93W3Muc3Ryc3RhcnRdLCBiZmx1c2gpOyAqKiovXG4gICAgICBiZmx1c2ggPSB0cmVlcy5fdHJfdGFsbHkocywgMCwgcy53aW5kb3dbcy5zdHJzdGFydF0pO1xuXG4gICAgICBzLmxvb2thaGVhZC0tO1xuICAgICAgcy5zdHJzdGFydCsrO1xuICAgIH1cbiAgICBpZiAoYmZsdXNoKSB7XG4gICAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG4gICAgICAvKioqL1xuICAgIH1cbiAgfVxuICBzLmluc2VydCA9IDA7XG4gIGlmIChmbHVzaCA9PT0gWl9GSU5JU0gpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDEpOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCB0cnVlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX0ZJTklTSF9TVEFSVEVEO1xuICAgIH1cbiAgICAvKioqL1xuICAgIHJldHVybiBCU19GSU5JU0hfRE9ORTtcbiAgfVxuICBpZiAocy5sYXN0X2xpdCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICB9XG4gICAgLyoqKi9cbiAgfVxuICByZXR1cm4gQlNfQkxPQ0tfRE9ORTtcbn1cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBGb3IgWl9IVUZGTUFOX09OTFksIGRvIG5vdCBsb29rIGZvciBtYXRjaGVzLiAgRG8gbm90IG1haW50YWluIGEgaGFzaCB0YWJsZS5cbiAqIChJdCB3aWxsIGJlIHJlZ2VuZXJhdGVkIGlmIHRoaXMgcnVuIG9mIGRlZmxhdGUgc3dpdGNoZXMgYXdheSBmcm9tIEh1ZmZtYW4uKVxuICovXG5mdW5jdGlvbiBkZWZsYXRlX2h1ZmYocywgZmx1c2gpIHtcbiAgdmFyIGJmbHVzaDsgICAgICAgICAgICAgLyogc2V0IGlmIGN1cnJlbnQgYmxvY2sgbXVzdCBiZSBmbHVzaGVkICovXG5cbiAgZm9yICg7Oykge1xuICAgIC8qIE1ha2Ugc3VyZSB0aGF0IHdlIGhhdmUgYSBsaXRlcmFsIHRvIHdyaXRlLiAqL1xuICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkge1xuICAgICAgZmlsbF93aW5kb3cocyk7XG4gICAgICBpZiAocy5sb29rYWhlYWQgPT09IDApIHtcbiAgICAgICAgaWYgKGZsdXNoID09PSBaX05PX0ZMVVNIKSB7XG4gICAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgICAgfVxuICAgICAgICBicmVhazsgICAgICAvKiBmbHVzaCB0aGUgY3VycmVudCBibG9jayAqL1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qIE91dHB1dCBhIGxpdGVyYWwgYnl0ZSAqL1xuICAgIHMubWF0Y2hfbGVuZ3RoID0gMDtcbiAgICAvL1RyYWNldnYoKHN0ZGVycixcIiVjXCIsIHMtPndpbmRvd1tzLT5zdHJzdGFydF0pKTtcbiAgICAvKioqIF90cl90YWxseV9saXQocywgcy53aW5kb3dbcy5zdHJzdGFydF0sIGJmbHVzaCk7ICoqKi9cbiAgICBiZmx1c2ggPSB0cmVlcy5fdHJfdGFsbHkocywgMCwgcy53aW5kb3dbcy5zdHJzdGFydF0pO1xuICAgIHMubG9va2FoZWFkLS07XG4gICAgcy5zdHJzdGFydCsrO1xuICAgIGlmIChiZmx1c2gpIHtcbiAgICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICAgIC8qKiovXG4gICAgfVxuICB9XG4gIHMuaW5zZXJ0ID0gMDtcbiAgaWYgKGZsdXNoID09PSBaX0ZJTklTSCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMSk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIHRydWUpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfRklOSVNIX1NUQVJURUQ7XG4gICAgfVxuICAgIC8qKiovXG4gICAgcmV0dXJuIEJTX0ZJTklTSF9ET05FO1xuICB9XG4gIGlmIChzLmxhc3RfbGl0KSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgIH1cbiAgICAvKioqL1xuICB9XG4gIHJldHVybiBCU19CTE9DS19ET05FO1xufVxuXG4vKiBWYWx1ZXMgZm9yIG1heF9sYXp5X21hdGNoLCBnb29kX21hdGNoIGFuZCBtYXhfY2hhaW5fbGVuZ3RoLCBkZXBlbmRpbmcgb25cbiAqIHRoZSBkZXNpcmVkIHBhY2sgbGV2ZWwgKDAuLjkpLiBUaGUgdmFsdWVzIGdpdmVuIGJlbG93IGhhdmUgYmVlbiB0dW5lZCB0b1xuICogZXhjbHVkZSB3b3JzdCBjYXNlIHBlcmZvcm1hbmNlIGZvciBwYXRob2xvZ2ljYWwgZmlsZXMuIEJldHRlciB2YWx1ZXMgbWF5IGJlXG4gKiBmb3VuZCBmb3Igc3BlY2lmaWMgZmlsZXMuXG4gKi9cbmZ1bmN0aW9uIENvbmZpZyhnb29kX2xlbmd0aCwgbWF4X2xhenksIG5pY2VfbGVuZ3RoLCBtYXhfY2hhaW4sIGZ1bmMpIHtcbiAgdGhpcy5nb29kX2xlbmd0aCA9IGdvb2RfbGVuZ3RoO1xuICB0aGlzLm1heF9sYXp5ID0gbWF4X2xhenk7XG4gIHRoaXMubmljZV9sZW5ndGggPSBuaWNlX2xlbmd0aDtcbiAgdGhpcy5tYXhfY2hhaW4gPSBtYXhfY2hhaW47XG4gIHRoaXMuZnVuYyA9IGZ1bmM7XG59XG5cbnZhciBjb25maWd1cmF0aW9uX3RhYmxlO1xuXG5jb25maWd1cmF0aW9uX3RhYmxlID0gW1xuICAvKiAgICAgIGdvb2QgbGF6eSBuaWNlIGNoYWluICovXG4gIG5ldyBDb25maWcoMCwgMCwgMCwgMCwgZGVmbGF0ZV9zdG9yZWQpLCAgICAgICAgICAvKiAwIHN0b3JlIG9ubHkgKi9cbiAgbmV3IENvbmZpZyg0LCA0LCA4LCA0LCBkZWZsYXRlX2Zhc3QpLCAgICAgICAgICAgIC8qIDEgbWF4IHNwZWVkLCBubyBsYXp5IG1hdGNoZXMgKi9cbiAgbmV3IENvbmZpZyg0LCA1LCAxNiwgOCwgZGVmbGF0ZV9mYXN0KSwgICAgICAgICAgIC8qIDIgKi9cbiAgbmV3IENvbmZpZyg0LCA2LCAzMiwgMzIsIGRlZmxhdGVfZmFzdCksICAgICAgICAgIC8qIDMgKi9cblxuICBuZXcgQ29uZmlnKDQsIDQsIDE2LCAxNiwgZGVmbGF0ZV9zbG93KSwgICAgICAgICAgLyogNCBsYXp5IG1hdGNoZXMgKi9cbiAgbmV3IENvbmZpZyg4LCAxNiwgMzIsIDMyLCBkZWZsYXRlX3Nsb3cpLCAgICAgICAgIC8qIDUgKi9cbiAgbmV3IENvbmZpZyg4LCAxNiwgMTI4LCAxMjgsIGRlZmxhdGVfc2xvdyksICAgICAgIC8qIDYgKi9cbiAgbmV3IENvbmZpZyg4LCAzMiwgMTI4LCAyNTYsIGRlZmxhdGVfc2xvdyksICAgICAgIC8qIDcgKi9cbiAgbmV3IENvbmZpZygzMiwgMTI4LCAyNTgsIDEwMjQsIGRlZmxhdGVfc2xvdyksICAgIC8qIDggKi9cbiAgbmV3IENvbmZpZygzMiwgMjU4LCAyNTgsIDQwOTYsIGRlZmxhdGVfc2xvdykgICAgIC8qIDkgbWF4IGNvbXByZXNzaW9uICovXG5dO1xuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogSW5pdGlhbGl6ZSB0aGUgXCJsb25nZXN0IG1hdGNoXCIgcm91dGluZXMgZm9yIGEgbmV3IHpsaWIgc3RyZWFtXG4gKi9cbmZ1bmN0aW9uIGxtX2luaXQocykge1xuICBzLndpbmRvd19zaXplID0gMiAqIHMud19zaXplO1xuXG4gIC8qKiogQ0xFQVJfSEFTSChzKTsgKioqL1xuICB6ZXJvKHMuaGVhZCk7IC8vIEZpbGwgd2l0aCBOSUwgKD0gMCk7XG5cbiAgLyogU2V0IHRoZSBkZWZhdWx0IGNvbmZpZ3VyYXRpb24gcGFyYW1ldGVyczpcbiAgICovXG4gIHMubWF4X2xhenlfbWF0Y2ggPSBjb25maWd1cmF0aW9uX3RhYmxlW3MubGV2ZWxdLm1heF9sYXp5O1xuICBzLmdvb2RfbWF0Y2ggPSBjb25maWd1cmF0aW9uX3RhYmxlW3MubGV2ZWxdLmdvb2RfbGVuZ3RoO1xuICBzLm5pY2VfbWF0Y2ggPSBjb25maWd1cmF0aW9uX3RhYmxlW3MubGV2ZWxdLm5pY2VfbGVuZ3RoO1xuICBzLm1heF9jaGFpbl9sZW5ndGggPSBjb25maWd1cmF0aW9uX3RhYmxlW3MubGV2ZWxdLm1heF9jaGFpbjtcblxuICBzLnN0cnN0YXJ0ID0gMDtcbiAgcy5ibG9ja19zdGFydCA9IDA7XG4gIHMubG9va2FoZWFkID0gMDtcbiAgcy5pbnNlcnQgPSAwO1xuICBzLm1hdGNoX2xlbmd0aCA9IHMucHJldl9sZW5ndGggPSBNSU5fTUFUQ0ggLSAxO1xuICBzLm1hdGNoX2F2YWlsYWJsZSA9IDA7XG4gIHMuaW5zX2ggPSAwO1xufVxuXG5cbmZ1bmN0aW9uIERlZmxhdGVTdGF0ZSgpIHtcbiAgdGhpcy5zdHJtID0gbnVsbDsgICAgICAgICAgICAvKiBwb2ludGVyIGJhY2sgdG8gdGhpcyB6bGliIHN0cmVhbSAqL1xuICB0aGlzLnN0YXR1cyA9IDA7ICAgICAgICAgICAgLyogYXMgdGhlIG5hbWUgaW1wbGllcyAqL1xuICB0aGlzLnBlbmRpbmdfYnVmID0gbnVsbDsgICAgICAvKiBvdXRwdXQgc3RpbGwgcGVuZGluZyAqL1xuICB0aGlzLnBlbmRpbmdfYnVmX3NpemUgPSAwOyAgLyogc2l6ZSBvZiBwZW5kaW5nX2J1ZiAqL1xuICB0aGlzLnBlbmRpbmdfb3V0ID0gMDsgICAgICAgLyogbmV4dCBwZW5kaW5nIGJ5dGUgdG8gb3V0cHV0IHRvIHRoZSBzdHJlYW0gKi9cbiAgdGhpcy5wZW5kaW5nID0gMDsgICAgICAgICAgIC8qIG5iIG9mIGJ5dGVzIGluIHRoZSBwZW5kaW5nIGJ1ZmZlciAqL1xuICB0aGlzLndyYXAgPSAwOyAgICAgICAgICAgICAgLyogYml0IDAgdHJ1ZSBmb3IgemxpYiwgYml0IDEgdHJ1ZSBmb3IgZ3ppcCAqL1xuICB0aGlzLmd6aGVhZCA9IG51bGw7ICAgICAgICAgLyogZ3ppcCBoZWFkZXIgaW5mb3JtYXRpb24gdG8gd3JpdGUgKi9cbiAgdGhpcy5nemluZGV4ID0gMDsgICAgICAgICAgIC8qIHdoZXJlIGluIGV4dHJhLCBuYW1lLCBvciBjb21tZW50ICovXG4gIHRoaXMubWV0aG9kID0gWl9ERUZMQVRFRDsgLyogY2FuIG9ubHkgYmUgREVGTEFURUQgKi9cbiAgdGhpcy5sYXN0X2ZsdXNoID0gLTE7ICAgLyogdmFsdWUgb2YgZmx1c2ggcGFyYW0gZm9yIHByZXZpb3VzIGRlZmxhdGUgY2FsbCAqL1xuXG4gIHRoaXMud19zaXplID0gMDsgIC8qIExaNzcgd2luZG93IHNpemUgKDMySyBieSBkZWZhdWx0KSAqL1xuICB0aGlzLndfYml0cyA9IDA7ICAvKiBsb2cyKHdfc2l6ZSkgICg4Li4xNikgKi9cbiAgdGhpcy53X21hc2sgPSAwOyAgLyogd19zaXplIC0gMSAqL1xuXG4gIHRoaXMud2luZG93ID0gbnVsbDtcbiAgLyogU2xpZGluZyB3aW5kb3cuIElucHV0IGJ5dGVzIGFyZSByZWFkIGludG8gdGhlIHNlY29uZCBoYWxmIG9mIHRoZSB3aW5kb3csXG4gICAqIGFuZCBtb3ZlIHRvIHRoZSBmaXJzdCBoYWxmIGxhdGVyIHRvIGtlZXAgYSBkaWN0aW9uYXJ5IG9mIGF0IGxlYXN0IHdTaXplXG4gICAqIGJ5dGVzLiBXaXRoIHRoaXMgb3JnYW5pemF0aW9uLCBtYXRjaGVzIGFyZSBsaW1pdGVkIHRvIGEgZGlzdGFuY2Ugb2ZcbiAgICogd1NpemUtTUFYX01BVENIIGJ5dGVzLCBidXQgdGhpcyBlbnN1cmVzIHRoYXQgSU8gaXMgYWx3YXlzXG4gICAqIHBlcmZvcm1lZCB3aXRoIGEgbGVuZ3RoIG11bHRpcGxlIG9mIHRoZSBibG9jayBzaXplLlxuICAgKi9cblxuICB0aGlzLndpbmRvd19zaXplID0gMDtcbiAgLyogQWN0dWFsIHNpemUgb2Ygd2luZG93OiAyKndTaXplLCBleGNlcHQgd2hlbiB0aGUgdXNlciBpbnB1dCBidWZmZXJcbiAgICogaXMgZGlyZWN0bHkgdXNlZCBhcyBzbGlkaW5nIHdpbmRvdy5cbiAgICovXG5cbiAgdGhpcy5wcmV2ID0gbnVsbDtcbiAgLyogTGluayB0byBvbGRlciBzdHJpbmcgd2l0aCBzYW1lIGhhc2ggaW5kZXguIFRvIGxpbWl0IHRoZSBzaXplIG9mIHRoaXNcbiAgICogYXJyYXkgdG8gNjRLLCB0aGlzIGxpbmsgaXMgbWFpbnRhaW5lZCBvbmx5IGZvciB0aGUgbGFzdCAzMksgc3RyaW5ncy5cbiAgICogQW4gaW5kZXggaW4gdGhpcyBhcnJheSBpcyB0aHVzIGEgd2luZG93IGluZGV4IG1vZHVsbyAzMksuXG4gICAqL1xuXG4gIHRoaXMuaGVhZCA9IG51bGw7ICAgLyogSGVhZHMgb2YgdGhlIGhhc2ggY2hhaW5zIG9yIE5JTC4gKi9cblxuICB0aGlzLmluc19oID0gMDsgICAgICAgLyogaGFzaCBpbmRleCBvZiBzdHJpbmcgdG8gYmUgaW5zZXJ0ZWQgKi9cbiAgdGhpcy5oYXNoX3NpemUgPSAwOyAgIC8qIG51bWJlciBvZiBlbGVtZW50cyBpbiBoYXNoIHRhYmxlICovXG4gIHRoaXMuaGFzaF9iaXRzID0gMDsgICAvKiBsb2cyKGhhc2hfc2l6ZSkgKi9cbiAgdGhpcy5oYXNoX21hc2sgPSAwOyAgIC8qIGhhc2hfc2l6ZS0xICovXG5cbiAgdGhpcy5oYXNoX3NoaWZ0ID0gMDtcbiAgLyogTnVtYmVyIG9mIGJpdHMgYnkgd2hpY2ggaW5zX2ggbXVzdCBiZSBzaGlmdGVkIGF0IGVhY2ggaW5wdXRcbiAgICogc3RlcC4gSXQgbXVzdCBiZSBzdWNoIHRoYXQgYWZ0ZXIgTUlOX01BVENIIHN0ZXBzLCB0aGUgb2xkZXN0XG4gICAqIGJ5dGUgbm8gbG9uZ2VyIHRha2VzIHBhcnQgaW4gdGhlIGhhc2gga2V5LCB0aGF0IGlzOlxuICAgKiAgIGhhc2hfc2hpZnQgKiBNSU5fTUFUQ0ggPj0gaGFzaF9iaXRzXG4gICAqL1xuXG4gIHRoaXMuYmxvY2tfc3RhcnQgPSAwO1xuICAvKiBXaW5kb3cgcG9zaXRpb24gYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgY3VycmVudCBvdXRwdXQgYmxvY2suIEdldHNcbiAgICogbmVnYXRpdmUgd2hlbiB0aGUgd2luZG93IGlzIG1vdmVkIGJhY2t3YXJkcy5cbiAgICovXG5cbiAgdGhpcy5tYXRjaF9sZW5ndGggPSAwOyAgICAgIC8qIGxlbmd0aCBvZiBiZXN0IG1hdGNoICovXG4gIHRoaXMucHJldl9tYXRjaCA9IDA7ICAgICAgICAvKiBwcmV2aW91cyBtYXRjaCAqL1xuICB0aGlzLm1hdGNoX2F2YWlsYWJsZSA9IDA7ICAgLyogc2V0IGlmIHByZXZpb3VzIG1hdGNoIGV4aXN0cyAqL1xuICB0aGlzLnN0cnN0YXJ0ID0gMDsgICAgICAgICAgLyogc3RhcnQgb2Ygc3RyaW5nIHRvIGluc2VydCAqL1xuICB0aGlzLm1hdGNoX3N0YXJ0ID0gMDsgICAgICAgLyogc3RhcnQgb2YgbWF0Y2hpbmcgc3RyaW5nICovXG4gIHRoaXMubG9va2FoZWFkID0gMDsgICAgICAgICAvKiBudW1iZXIgb2YgdmFsaWQgYnl0ZXMgYWhlYWQgaW4gd2luZG93ICovXG5cbiAgdGhpcy5wcmV2X2xlbmd0aCA9IDA7XG4gIC8qIExlbmd0aCBvZiB0aGUgYmVzdCBtYXRjaCBhdCBwcmV2aW91cyBzdGVwLiBNYXRjaGVzIG5vdCBncmVhdGVyIHRoYW4gdGhpc1xuICAgKiBhcmUgZGlzY2FyZGVkLiBUaGlzIGlzIHVzZWQgaW4gdGhlIGxhenkgbWF0Y2ggZXZhbHVhdGlvbi5cbiAgICovXG5cbiAgdGhpcy5tYXhfY2hhaW5fbGVuZ3RoID0gMDtcbiAgLyogVG8gc3BlZWQgdXAgZGVmbGF0aW9uLCBoYXNoIGNoYWlucyBhcmUgbmV2ZXIgc2VhcmNoZWQgYmV5b25kIHRoaXNcbiAgICogbGVuZ3RoLiAgQSBoaWdoZXIgbGltaXQgaW1wcm92ZXMgY29tcHJlc3Npb24gcmF0aW8gYnV0IGRlZ3JhZGVzIHRoZVxuICAgKiBzcGVlZC5cbiAgICovXG5cbiAgdGhpcy5tYXhfbGF6eV9tYXRjaCA9IDA7XG4gIC8qIEF0dGVtcHQgdG8gZmluZCBhIGJldHRlciBtYXRjaCBvbmx5IHdoZW4gdGhlIGN1cnJlbnQgbWF0Y2ggaXMgc3RyaWN0bHlcbiAgICogc21hbGxlciB0aGFuIHRoaXMgdmFsdWUuIFRoaXMgbWVjaGFuaXNtIGlzIHVzZWQgb25seSBmb3IgY29tcHJlc3Npb25cbiAgICogbGV2ZWxzID49IDQuXG4gICAqL1xuICAvLyBUaGF0J3MgYWxpYXMgdG8gbWF4X2xhenlfbWF0Y2gsIGRvbid0IHVzZSBkaXJlY3RseVxuICAvL3RoaXMubWF4X2luc2VydF9sZW5ndGggPSAwO1xuICAvKiBJbnNlcnQgbmV3IHN0cmluZ3MgaW4gdGhlIGhhc2ggdGFibGUgb25seSBpZiB0aGUgbWF0Y2ggbGVuZ3RoIGlzIG5vdFxuICAgKiBncmVhdGVyIHRoYW4gdGhpcyBsZW5ndGguIFRoaXMgc2F2ZXMgdGltZSBidXQgZGVncmFkZXMgY29tcHJlc3Npb24uXG4gICAqIG1heF9pbnNlcnRfbGVuZ3RoIGlzIHVzZWQgb25seSBmb3IgY29tcHJlc3Npb24gbGV2ZWxzIDw9IDMuXG4gICAqL1xuXG4gIHRoaXMubGV2ZWwgPSAwOyAgICAgLyogY29tcHJlc3Npb24gbGV2ZWwgKDEuLjkpICovXG4gIHRoaXMuc3RyYXRlZ3kgPSAwOyAgLyogZmF2b3Igb3IgZm9yY2UgSHVmZm1hbiBjb2RpbmcqL1xuXG4gIHRoaXMuZ29vZF9tYXRjaCA9IDA7XG4gIC8qIFVzZSBhIGZhc3RlciBzZWFyY2ggd2hlbiB0aGUgcHJldmlvdXMgbWF0Y2ggaXMgbG9uZ2VyIHRoYW4gdGhpcyAqL1xuXG4gIHRoaXMubmljZV9tYXRjaCA9IDA7IC8qIFN0b3Agc2VhcmNoaW5nIHdoZW4gY3VycmVudCBtYXRjaCBleGNlZWRzIHRoaXMgKi9cblxuICAgICAgICAgICAgICAvKiB1c2VkIGJ5IHRyZWVzLmM6ICovXG5cbiAgLyogRGlkbid0IHVzZSBjdF9kYXRhIHR5cGVkZWYgYmVsb3cgdG8gc3VwcHJlc3MgY29tcGlsZXIgd2FybmluZyAqL1xuXG4gIC8vIHN0cnVjdCBjdF9kYXRhX3MgZHluX2x0cmVlW0hFQVBfU0laRV07ICAgLyogbGl0ZXJhbCBhbmQgbGVuZ3RoIHRyZWUgKi9cbiAgLy8gc3RydWN0IGN0X2RhdGFfcyBkeW5fZHRyZWVbMipEX0NPREVTKzFdOyAvKiBkaXN0YW5jZSB0cmVlICovXG4gIC8vIHN0cnVjdCBjdF9kYXRhX3MgYmxfdHJlZVsyKkJMX0NPREVTKzFdOyAgLyogSHVmZm1hbiB0cmVlIGZvciBiaXQgbGVuZ3RocyAqL1xuXG4gIC8vIFVzZSBmbGF0IGFycmF5IG9mIERPVUJMRSBzaXplLCB3aXRoIGludGVybGVhdmVkIGZhdGEsXG4gIC8vIGJlY2F1c2UgSlMgZG9lcyBub3Qgc3VwcG9ydCBlZmZlY3RpdmVcbiAgdGhpcy5keW5fbHRyZWUgID0gbmV3IHV0aWxzLkJ1ZjE2KEhFQVBfU0laRSAqIDIpO1xuICB0aGlzLmR5bl9kdHJlZSAgPSBuZXcgdXRpbHMuQnVmMTYoKDIgKiBEX0NPREVTICsgMSkgKiAyKTtcbiAgdGhpcy5ibF90cmVlICAgID0gbmV3IHV0aWxzLkJ1ZjE2KCgyICogQkxfQ09ERVMgKyAxKSAqIDIpO1xuICB6ZXJvKHRoaXMuZHluX2x0cmVlKTtcbiAgemVybyh0aGlzLmR5bl9kdHJlZSk7XG4gIHplcm8odGhpcy5ibF90cmVlKTtcblxuICB0aGlzLmxfZGVzYyAgID0gbnVsbDsgICAgICAgICAvKiBkZXNjLiBmb3IgbGl0ZXJhbCB0cmVlICovXG4gIHRoaXMuZF9kZXNjICAgPSBudWxsOyAgICAgICAgIC8qIGRlc2MuIGZvciBkaXN0YW5jZSB0cmVlICovXG4gIHRoaXMuYmxfZGVzYyAgPSBudWxsOyAgICAgICAgIC8qIGRlc2MuIGZvciBiaXQgbGVuZ3RoIHRyZWUgKi9cblxuICAvL3VzaCBibF9jb3VudFtNQVhfQklUUysxXTtcbiAgdGhpcy5ibF9jb3VudCA9IG5ldyB1dGlscy5CdWYxNihNQVhfQklUUyArIDEpO1xuICAvKiBudW1iZXIgb2YgY29kZXMgYXQgZWFjaCBiaXQgbGVuZ3RoIGZvciBhbiBvcHRpbWFsIHRyZWUgKi9cblxuICAvL2ludCBoZWFwWzIqTF9DT0RFUysxXTsgICAgICAvKiBoZWFwIHVzZWQgdG8gYnVpbGQgdGhlIEh1ZmZtYW4gdHJlZXMgKi9cbiAgdGhpcy5oZWFwID0gbmV3IHV0aWxzLkJ1ZjE2KDIgKiBMX0NPREVTICsgMSk7ICAvKiBoZWFwIHVzZWQgdG8gYnVpbGQgdGhlIEh1ZmZtYW4gdHJlZXMgKi9cbiAgemVybyh0aGlzLmhlYXApO1xuXG4gIHRoaXMuaGVhcF9sZW4gPSAwOyAgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBlbGVtZW50cyBpbiB0aGUgaGVhcCAqL1xuICB0aGlzLmhlYXBfbWF4ID0gMDsgICAgICAgICAgICAgICAvKiBlbGVtZW50IG9mIGxhcmdlc3QgZnJlcXVlbmN5ICovXG4gIC8qIFRoZSBzb25zIG9mIGhlYXBbbl0gYXJlIGhlYXBbMipuXSBhbmQgaGVhcFsyKm4rMV0uIGhlYXBbMF0gaXMgbm90IHVzZWQuXG4gICAqIFRoZSBzYW1lIGhlYXAgYXJyYXkgaXMgdXNlZCB0byBidWlsZCBhbGwgdHJlZXMuXG4gICAqL1xuXG4gIHRoaXMuZGVwdGggPSBuZXcgdXRpbHMuQnVmMTYoMiAqIExfQ09ERVMgKyAxKTsgLy91Y2ggZGVwdGhbMipMX0NPREVTKzFdO1xuICB6ZXJvKHRoaXMuZGVwdGgpO1xuICAvKiBEZXB0aCBvZiBlYWNoIHN1YnRyZWUgdXNlZCBhcyB0aWUgYnJlYWtlciBmb3IgdHJlZXMgb2YgZXF1YWwgZnJlcXVlbmN5XG4gICAqL1xuXG4gIHRoaXMubF9idWYgPSAwOyAgICAgICAgICAvKiBidWZmZXIgaW5kZXggZm9yIGxpdGVyYWxzIG9yIGxlbmd0aHMgKi9cblxuICB0aGlzLmxpdF9idWZzaXplID0gMDtcbiAgLyogU2l6ZSBvZiBtYXRjaCBidWZmZXIgZm9yIGxpdGVyYWxzL2xlbmd0aHMuICBUaGVyZSBhcmUgNCByZWFzb25zIGZvclxuICAgKiBsaW1pdGluZyBsaXRfYnVmc2l6ZSB0byA2NEs6XG4gICAqICAgLSBmcmVxdWVuY2llcyBjYW4gYmUga2VwdCBpbiAxNiBiaXQgY291bnRlcnNcbiAgICogICAtIGlmIGNvbXByZXNzaW9uIGlzIG5vdCBzdWNjZXNzZnVsIGZvciB0aGUgZmlyc3QgYmxvY2ssIGFsbCBpbnB1dFxuICAgKiAgICAgZGF0YSBpcyBzdGlsbCBpbiB0aGUgd2luZG93IHNvIHdlIGNhbiBzdGlsbCBlbWl0IGEgc3RvcmVkIGJsb2NrIGV2ZW5cbiAgICogICAgIHdoZW4gaW5wdXQgY29tZXMgZnJvbSBzdGFuZGFyZCBpbnB1dC4gIChUaGlzIGNhbiBhbHNvIGJlIGRvbmUgZm9yXG4gICAqICAgICBhbGwgYmxvY2tzIGlmIGxpdF9idWZzaXplIGlzIG5vdCBncmVhdGVyIHRoYW4gMzJLLilcbiAgICogICAtIGlmIGNvbXByZXNzaW9uIGlzIG5vdCBzdWNjZXNzZnVsIGZvciBhIGZpbGUgc21hbGxlciB0aGFuIDY0Sywgd2UgY2FuXG4gICAqICAgICBldmVuIGVtaXQgYSBzdG9yZWQgZmlsZSBpbnN0ZWFkIG9mIGEgc3RvcmVkIGJsb2NrIChzYXZpbmcgNSBieXRlcykuXG4gICAqICAgICBUaGlzIGlzIGFwcGxpY2FibGUgb25seSBmb3IgemlwIChub3QgZ3ppcCBvciB6bGliKS5cbiAgICogICAtIGNyZWF0aW5nIG5ldyBIdWZmbWFuIHRyZWVzIGxlc3MgZnJlcXVlbnRseSBtYXkgbm90IHByb3ZpZGUgZmFzdFxuICAgKiAgICAgYWRhcHRhdGlvbiB0byBjaGFuZ2VzIGluIHRoZSBpbnB1dCBkYXRhIHN0YXRpc3RpY3MuIChUYWtlIGZvclxuICAgKiAgICAgZXhhbXBsZSBhIGJpbmFyeSBmaWxlIHdpdGggcG9vcmx5IGNvbXByZXNzaWJsZSBjb2RlIGZvbGxvd2VkIGJ5XG4gICAqICAgICBhIGhpZ2hseSBjb21wcmVzc2libGUgc3RyaW5nIHRhYmxlLikgU21hbGxlciBidWZmZXIgc2l6ZXMgZ2l2ZVxuICAgKiAgICAgZmFzdCBhZGFwdGF0aW9uIGJ1dCBoYXZlIG9mIGNvdXJzZSB0aGUgb3ZlcmhlYWQgb2YgdHJhbnNtaXR0aW5nXG4gICAqICAgICB0cmVlcyBtb3JlIGZyZXF1ZW50bHkuXG4gICAqICAgLSBJIGNhbid0IGNvdW50IGFib3ZlIDRcbiAgICovXG5cbiAgdGhpcy5sYXN0X2xpdCA9IDA7ICAgICAgLyogcnVubmluZyBpbmRleCBpbiBsX2J1ZiAqL1xuXG4gIHRoaXMuZF9idWYgPSAwO1xuICAvKiBCdWZmZXIgaW5kZXggZm9yIGRpc3RhbmNlcy4gVG8gc2ltcGxpZnkgdGhlIGNvZGUsIGRfYnVmIGFuZCBsX2J1ZiBoYXZlXG4gICAqIHRoZSBzYW1lIG51bWJlciBvZiBlbGVtZW50cy4gVG8gdXNlIGRpZmZlcmVudCBsZW5ndGhzLCBhbiBleHRyYSBmbGFnXG4gICAqIGFycmF5IHdvdWxkIGJlIG5lY2Vzc2FyeS5cbiAgICovXG5cbiAgdGhpcy5vcHRfbGVuID0gMDsgICAgICAgLyogYml0IGxlbmd0aCBvZiBjdXJyZW50IGJsb2NrIHdpdGggb3B0aW1hbCB0cmVlcyAqL1xuICB0aGlzLnN0YXRpY19sZW4gPSAwOyAgICAvKiBiaXQgbGVuZ3RoIG9mIGN1cnJlbnQgYmxvY2sgd2l0aCBzdGF0aWMgdHJlZXMgKi9cbiAgdGhpcy5tYXRjaGVzID0gMDsgICAgICAgLyogbnVtYmVyIG9mIHN0cmluZyBtYXRjaGVzIGluIGN1cnJlbnQgYmxvY2sgKi9cbiAgdGhpcy5pbnNlcnQgPSAwOyAgICAgICAgLyogYnl0ZXMgYXQgZW5kIG9mIHdpbmRvdyBsZWZ0IHRvIGluc2VydCAqL1xuXG5cbiAgdGhpcy5iaV9idWYgPSAwO1xuICAvKiBPdXRwdXQgYnVmZmVyLiBiaXRzIGFyZSBpbnNlcnRlZCBzdGFydGluZyBhdCB0aGUgYm90dG9tIChsZWFzdFxuICAgKiBzaWduaWZpY2FudCBiaXRzKS5cbiAgICovXG4gIHRoaXMuYmlfdmFsaWQgPSAwO1xuICAvKiBOdW1iZXIgb2YgdmFsaWQgYml0cyBpbiBiaV9idWYuICBBbGwgYml0cyBhYm92ZSB0aGUgbGFzdCB2YWxpZCBiaXRcbiAgICogYXJlIGFsd2F5cyB6ZXJvLlxuICAgKi9cblxuICAvLyBVc2VkIGZvciB3aW5kb3cgbWVtb3J5IGluaXQuIFdlIHNhZmVseSBpZ25vcmUgaXQgZm9yIEpTLiBUaGF0IG1ha2VzXG4gIC8vIHNlbnNlIG9ubHkgZm9yIHBvaW50ZXJzIGFuZCBtZW1vcnkgY2hlY2sgdG9vbHMuXG4gIC8vdGhpcy5oaWdoX3dhdGVyID0gMDtcbiAgLyogSGlnaCB3YXRlciBtYXJrIG9mZnNldCBpbiB3aW5kb3cgZm9yIGluaXRpYWxpemVkIGJ5dGVzIC0tIGJ5dGVzIGFib3ZlXG4gICAqIHRoaXMgYXJlIHNldCB0byB6ZXJvIGluIG9yZGVyIHRvIGF2b2lkIG1lbW9yeSBjaGVjayB3YXJuaW5ncyB3aGVuXG4gICAqIGxvbmdlc3QgbWF0Y2ggcm91dGluZXMgYWNjZXNzIGJ5dGVzIHBhc3QgdGhlIGlucHV0LiAgVGhpcyBpcyB0aGVuXG4gICAqIHVwZGF0ZWQgdG8gdGhlIG5ldyBoaWdoIHdhdGVyIG1hcmsuXG4gICAqL1xufVxuXG5cbmZ1bmN0aW9uIGRlZmxhdGVSZXNldEtlZXAoc3RybSkge1xuICB2YXIgcztcblxuICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUpIHtcbiAgICByZXR1cm4gZXJyKHN0cm0sIFpfU1RSRUFNX0VSUk9SKTtcbiAgfVxuXG4gIHN0cm0udG90YWxfaW4gPSBzdHJtLnRvdGFsX291dCA9IDA7XG4gIHN0cm0uZGF0YV90eXBlID0gWl9VTktOT1dOO1xuXG4gIHMgPSBzdHJtLnN0YXRlO1xuICBzLnBlbmRpbmcgPSAwO1xuICBzLnBlbmRpbmdfb3V0ID0gMDtcblxuICBpZiAocy53cmFwIDwgMCkge1xuICAgIHMud3JhcCA9IC1zLndyYXA7XG4gICAgLyogd2FzIG1hZGUgbmVnYXRpdmUgYnkgZGVmbGF0ZSguLi4sIFpfRklOSVNIKTsgKi9cbiAgfVxuICBzLnN0YXR1cyA9IChzLndyYXAgPyBJTklUX1NUQVRFIDogQlVTWV9TVEFURSk7XG4gIHN0cm0uYWRsZXIgPSAocy53cmFwID09PSAyKSA/XG4gICAgMCAgLy8gY3JjMzIoMCwgWl9OVUxMLCAwKVxuICA6XG4gICAgMTsgLy8gYWRsZXIzMigwLCBaX05VTEwsIDApXG4gIHMubGFzdF9mbHVzaCA9IFpfTk9fRkxVU0g7XG4gIHRyZWVzLl90cl9pbml0KHMpO1xuICByZXR1cm4gWl9PSztcbn1cblxuXG5mdW5jdGlvbiBkZWZsYXRlUmVzZXQoc3RybSkge1xuICB2YXIgcmV0ID0gZGVmbGF0ZVJlc2V0S2VlcChzdHJtKTtcbiAgaWYgKHJldCA9PT0gWl9PSykge1xuICAgIGxtX2luaXQoc3RybS5zdGF0ZSk7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuXG5mdW5jdGlvbiBkZWZsYXRlU2V0SGVhZGVyKHN0cm0sIGhlYWQpIHtcbiAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUjsgfVxuICBpZiAoc3RybS5zdGF0ZS53cmFwICE9PSAyKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUjsgfVxuICBzdHJtLnN0YXRlLmd6aGVhZCA9IGhlYWQ7XG4gIHJldHVybiBaX09LO1xufVxuXG5cbmZ1bmN0aW9uIGRlZmxhdGVJbml0MihzdHJtLCBsZXZlbCwgbWV0aG9kLCB3aW5kb3dCaXRzLCBtZW1MZXZlbCwgc3RyYXRlZ3kpIHtcbiAgaWYgKCFzdHJtKSB7IC8vID09PSBaX05VTExcbiAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gIH1cbiAgdmFyIHdyYXAgPSAxO1xuXG4gIGlmIChsZXZlbCA9PT0gWl9ERUZBVUxUX0NPTVBSRVNTSU9OKSB7XG4gICAgbGV2ZWwgPSA2O1xuICB9XG5cbiAgaWYgKHdpbmRvd0JpdHMgPCAwKSB7IC8qIHN1cHByZXNzIHpsaWIgd3JhcHBlciAqL1xuICAgIHdyYXAgPSAwO1xuICAgIHdpbmRvd0JpdHMgPSAtd2luZG93Qml0cztcbiAgfVxuXG4gIGVsc2UgaWYgKHdpbmRvd0JpdHMgPiAxNSkge1xuICAgIHdyYXAgPSAyOyAgICAgICAgICAgLyogd3JpdGUgZ3ppcCB3cmFwcGVyIGluc3RlYWQgKi9cbiAgICB3aW5kb3dCaXRzIC09IDE2O1xuICB9XG5cblxuICBpZiAobWVtTGV2ZWwgPCAxIHx8IG1lbUxldmVsID4gTUFYX01FTV9MRVZFTCB8fCBtZXRob2QgIT09IFpfREVGTEFURUQgfHxcbiAgICB3aW5kb3dCaXRzIDwgOCB8fCB3aW5kb3dCaXRzID4gMTUgfHwgbGV2ZWwgPCAwIHx8IGxldmVsID4gOSB8fFxuICAgIHN0cmF0ZWd5IDwgMCB8fCBzdHJhdGVneSA+IFpfRklYRUQpIHtcbiAgICByZXR1cm4gZXJyKHN0cm0sIFpfU1RSRUFNX0VSUk9SKTtcbiAgfVxuXG5cbiAgaWYgKHdpbmRvd0JpdHMgPT09IDgpIHtcbiAgICB3aW5kb3dCaXRzID0gOTtcbiAgfVxuICAvKiB1bnRpbCAyNTYtYnl0ZSB3aW5kb3cgYnVnIGZpeGVkICovXG5cbiAgdmFyIHMgPSBuZXcgRGVmbGF0ZVN0YXRlKCk7XG5cbiAgc3RybS5zdGF0ZSA9IHM7XG4gIHMuc3RybSA9IHN0cm07XG5cbiAgcy53cmFwID0gd3JhcDtcbiAgcy5nemhlYWQgPSBudWxsO1xuICBzLndfYml0cyA9IHdpbmRvd0JpdHM7XG4gIHMud19zaXplID0gMSA8PCBzLndfYml0cztcbiAgcy53X21hc2sgPSBzLndfc2l6ZSAtIDE7XG5cbiAgcy5oYXNoX2JpdHMgPSBtZW1MZXZlbCArIDc7XG4gIHMuaGFzaF9zaXplID0gMSA8PCBzLmhhc2hfYml0cztcbiAgcy5oYXNoX21hc2sgPSBzLmhhc2hfc2l6ZSAtIDE7XG4gIHMuaGFzaF9zaGlmdCA9IH5+KChzLmhhc2hfYml0cyArIE1JTl9NQVRDSCAtIDEpIC8gTUlOX01BVENIKTtcblxuICBzLndpbmRvdyA9IG5ldyB1dGlscy5CdWY4KHMud19zaXplICogMik7XG4gIHMuaGVhZCA9IG5ldyB1dGlscy5CdWYxNihzLmhhc2hfc2l6ZSk7XG4gIHMucHJldiA9IG5ldyB1dGlscy5CdWYxNihzLndfc2l6ZSk7XG5cbiAgLy8gRG9uJ3QgbmVlZCBtZW0gaW5pdCBtYWdpYyBmb3IgSlMuXG4gIC8vcy5oaWdoX3dhdGVyID0gMDsgIC8qIG5vdGhpbmcgd3JpdHRlbiB0byBzLT53aW5kb3cgeWV0ICovXG5cbiAgcy5saXRfYnVmc2l6ZSA9IDEgPDwgKG1lbUxldmVsICsgNik7IC8qIDE2SyBlbGVtZW50cyBieSBkZWZhdWx0ICovXG5cbiAgcy5wZW5kaW5nX2J1Zl9zaXplID0gcy5saXRfYnVmc2l6ZSAqIDQ7XG4gIHMucGVuZGluZ19idWYgPSBuZXcgdXRpbHMuQnVmOChzLnBlbmRpbmdfYnVmX3NpemUpO1xuXG4gIHMuZF9idWYgPSBzLmxpdF9idWZzaXplID4+IDE7XG4gIHMubF9idWYgPSAoMSArIDIpICogcy5saXRfYnVmc2l6ZTtcblxuICBzLmxldmVsID0gbGV2ZWw7XG4gIHMuc3RyYXRlZ3kgPSBzdHJhdGVneTtcbiAgcy5tZXRob2QgPSBtZXRob2Q7XG5cbiAgcmV0dXJuIGRlZmxhdGVSZXNldChzdHJtKTtcbn1cblxuZnVuY3Rpb24gZGVmbGF0ZUluaXQoc3RybSwgbGV2ZWwpIHtcbiAgcmV0dXJuIGRlZmxhdGVJbml0MihzdHJtLCBsZXZlbCwgWl9ERUZMQVRFRCwgTUFYX1dCSVRTLCBERUZfTUVNX0xFVkVMLCBaX0RFRkFVTFRfU1RSQVRFR1kpO1xufVxuXG5cbmZ1bmN0aW9uIGRlZmxhdGUoc3RybSwgZmx1c2gpIHtcbiAgdmFyIG9sZF9mbHVzaCwgcztcbiAgdmFyIGJlZywgdmFsOyAvLyBmb3IgZ3ppcCBoZWFkZXIgd3JpdGUgb25seVxuXG4gIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSB8fFxuICAgIGZsdXNoID4gWl9CTE9DSyB8fCBmbHVzaCA8IDApIHtcbiAgICByZXR1cm4gc3RybSA/IGVycihzdHJtLCBaX1NUUkVBTV9FUlJPUikgOiBaX1NUUkVBTV9FUlJPUjtcbiAgfVxuXG4gIHMgPSBzdHJtLnN0YXRlO1xuXG4gIGlmICghc3RybS5vdXRwdXQgfHxcbiAgICAgICghc3RybS5pbnB1dCAmJiBzdHJtLmF2YWlsX2luICE9PSAwKSB8fFxuICAgICAgKHMuc3RhdHVzID09PSBGSU5JU0hfU1RBVEUgJiYgZmx1c2ggIT09IFpfRklOSVNIKSkge1xuICAgIHJldHVybiBlcnIoc3RybSwgKHN0cm0uYXZhaWxfb3V0ID09PSAwKSA/IFpfQlVGX0VSUk9SIDogWl9TVFJFQU1fRVJST1IpO1xuICB9XG5cbiAgcy5zdHJtID0gc3RybTsgLyoganVzdCBpbiBjYXNlICovXG4gIG9sZF9mbHVzaCA9IHMubGFzdF9mbHVzaDtcbiAgcy5sYXN0X2ZsdXNoID0gZmx1c2g7XG5cbiAgLyogV3JpdGUgdGhlIGhlYWRlciAqL1xuICBpZiAocy5zdGF0dXMgPT09IElOSVRfU1RBVEUpIHtcblxuICAgIGlmIChzLndyYXAgPT09IDIpIHsgLy8gR1pJUCBoZWFkZXJcbiAgICAgIHN0cm0uYWRsZXIgPSAwOyAgLy9jcmMzMigwTCwgWl9OVUxMLCAwKTtcbiAgICAgIHB1dF9ieXRlKHMsIDMxKTtcbiAgICAgIHB1dF9ieXRlKHMsIDEzOSk7XG4gICAgICBwdXRfYnl0ZShzLCA4KTtcbiAgICAgIGlmICghcy5nemhlYWQpIHsgLy8gcy0+Z3poZWFkID09IFpfTlVMTFxuICAgICAgICBwdXRfYnl0ZShzLCAwKTtcbiAgICAgICAgcHV0X2J5dGUocywgMCk7XG4gICAgICAgIHB1dF9ieXRlKHMsIDApO1xuICAgICAgICBwdXRfYnl0ZShzLCAwKTtcbiAgICAgICAgcHV0X2J5dGUocywgMCk7XG4gICAgICAgIHB1dF9ieXRlKHMsIHMubGV2ZWwgPT09IDkgPyAyIDpcbiAgICAgICAgICAgICAgICAgICAgKHMuc3RyYXRlZ3kgPj0gWl9IVUZGTUFOX09OTFkgfHwgcy5sZXZlbCA8IDIgP1xuICAgICAgICAgICAgICAgICAgICAgNCA6IDApKTtcbiAgICAgICAgcHV0X2J5dGUocywgT1NfQ09ERSk7XG4gICAgICAgIHMuc3RhdHVzID0gQlVTWV9TVEFURTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBwdXRfYnl0ZShzLCAocy5nemhlYWQudGV4dCA/IDEgOiAwKSArXG4gICAgICAgICAgICAgICAgICAgIChzLmd6aGVhZC5oY3JjID8gMiA6IDApICtcbiAgICAgICAgICAgICAgICAgICAgKCFzLmd6aGVhZC5leHRyYSA/IDAgOiA0KSArXG4gICAgICAgICAgICAgICAgICAgICghcy5nemhlYWQubmFtZSA/IDAgOiA4KSArXG4gICAgICAgICAgICAgICAgICAgICghcy5nemhlYWQuY29tbWVudCA/IDAgOiAxNilcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICBwdXRfYnl0ZShzLCBzLmd6aGVhZC50aW1lICYgMHhmZik7XG4gICAgICAgIHB1dF9ieXRlKHMsIChzLmd6aGVhZC50aW1lID4+IDgpICYgMHhmZik7XG4gICAgICAgIHB1dF9ieXRlKHMsIChzLmd6aGVhZC50aW1lID4+IDE2KSAmIDB4ZmYpO1xuICAgICAgICBwdXRfYnl0ZShzLCAocy5nemhlYWQudGltZSA+PiAyNCkgJiAweGZmKTtcbiAgICAgICAgcHV0X2J5dGUocywgcy5sZXZlbCA9PT0gOSA/IDIgOlxuICAgICAgICAgICAgICAgICAgICAocy5zdHJhdGVneSA+PSBaX0hVRkZNQU5fT05MWSB8fCBzLmxldmVsIDwgMiA/XG4gICAgICAgICAgICAgICAgICAgICA0IDogMCkpO1xuICAgICAgICBwdXRfYnl0ZShzLCBzLmd6aGVhZC5vcyAmIDB4ZmYpO1xuICAgICAgICBpZiAocy5nemhlYWQuZXh0cmEgJiYgcy5nemhlYWQuZXh0cmEubGVuZ3RoKSB7XG4gICAgICAgICAgcHV0X2J5dGUocywgcy5nemhlYWQuZXh0cmEubGVuZ3RoICYgMHhmZik7XG4gICAgICAgICAgcHV0X2J5dGUocywgKHMuZ3poZWFkLmV4dHJhLmxlbmd0aCA+PiA4KSAmIDB4ZmYpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzLmd6aGVhZC5oY3JjKSB7XG4gICAgICAgICAgc3RybS5hZGxlciA9IGNyYzMyKHN0cm0uYWRsZXIsIHMucGVuZGluZ19idWYsIHMucGVuZGluZywgMCk7XG4gICAgICAgIH1cbiAgICAgICAgcy5nemluZGV4ID0gMDtcbiAgICAgICAgcy5zdGF0dXMgPSBFWFRSQV9TVEFURTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSAvLyBERUZMQVRFIGhlYWRlclxuICAgIHtcbiAgICAgIHZhciBoZWFkZXIgPSAoWl9ERUZMQVRFRCArICgocy53X2JpdHMgLSA4KSA8PCA0KSkgPDwgODtcbiAgICAgIHZhciBsZXZlbF9mbGFncyA9IC0xO1xuXG4gICAgICBpZiAocy5zdHJhdGVneSA+PSBaX0hVRkZNQU5fT05MWSB8fCBzLmxldmVsIDwgMikge1xuICAgICAgICBsZXZlbF9mbGFncyA9IDA7XG4gICAgICB9IGVsc2UgaWYgKHMubGV2ZWwgPCA2KSB7XG4gICAgICAgIGxldmVsX2ZsYWdzID0gMTtcbiAgICAgIH0gZWxzZSBpZiAocy5sZXZlbCA9PT0gNikge1xuICAgICAgICBsZXZlbF9mbGFncyA9IDI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXZlbF9mbGFncyA9IDM7XG4gICAgICB9XG4gICAgICBoZWFkZXIgfD0gKGxldmVsX2ZsYWdzIDw8IDYpO1xuICAgICAgaWYgKHMuc3Ryc3RhcnQgIT09IDApIHsgaGVhZGVyIHw9IFBSRVNFVF9ESUNUOyB9XG4gICAgICBoZWFkZXIgKz0gMzEgLSAoaGVhZGVyICUgMzEpO1xuXG4gICAgICBzLnN0YXR1cyA9IEJVU1lfU1RBVEU7XG4gICAgICBwdXRTaG9ydE1TQihzLCBoZWFkZXIpO1xuXG4gICAgICAvKiBTYXZlIHRoZSBhZGxlcjMyIG9mIHRoZSBwcmVzZXQgZGljdGlvbmFyeTogKi9cbiAgICAgIGlmIChzLnN0cnN0YXJ0ICE9PSAwKSB7XG4gICAgICAgIHB1dFNob3J0TVNCKHMsIHN0cm0uYWRsZXIgPj4+IDE2KTtcbiAgICAgICAgcHV0U2hvcnRNU0Iocywgc3RybS5hZGxlciAmIDB4ZmZmZik7XG4gICAgICB9XG4gICAgICBzdHJtLmFkbGVyID0gMTsgLy8gYWRsZXIzMigwTCwgWl9OVUxMLCAwKTtcbiAgICB9XG4gIH1cblxuLy8jaWZkZWYgR1pJUFxuICBpZiAocy5zdGF0dXMgPT09IEVYVFJBX1NUQVRFKSB7XG4gICAgaWYgKHMuZ3poZWFkLmV4dHJhLyogIT0gWl9OVUxMKi8pIHtcbiAgICAgIGJlZyA9IHMucGVuZGluZzsgIC8qIHN0YXJ0IG9mIGJ5dGVzIHRvIHVwZGF0ZSBjcmMgKi9cblxuICAgICAgd2hpbGUgKHMuZ3ppbmRleCA8IChzLmd6aGVhZC5leHRyYS5sZW5ndGggJiAweGZmZmYpKSB7XG4gICAgICAgIGlmIChzLnBlbmRpbmcgPT09IHMucGVuZGluZ19idWZfc2l6ZSkge1xuICAgICAgICAgIGlmIChzLmd6aGVhZC5oY3JjICYmIHMucGVuZGluZyA+IGJlZykge1xuICAgICAgICAgICAgc3RybS5hZGxlciA9IGNyYzMyKHN0cm0uYWRsZXIsIHMucGVuZGluZ19idWYsIHMucGVuZGluZyAtIGJlZywgYmVnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZmx1c2hfcGVuZGluZyhzdHJtKTtcbiAgICAgICAgICBiZWcgPSBzLnBlbmRpbmc7XG4gICAgICAgICAgaWYgKHMucGVuZGluZyA9PT0gcy5wZW5kaW5nX2J1Zl9zaXplKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcHV0X2J5dGUocywgcy5nemhlYWQuZXh0cmFbcy5nemluZGV4XSAmIDB4ZmYpO1xuICAgICAgICBzLmd6aW5kZXgrKztcbiAgICAgIH1cbiAgICAgIGlmIChzLmd6aGVhZC5oY3JjICYmIHMucGVuZGluZyA+IGJlZykge1xuICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzIoc3RybS5hZGxlciwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nIC0gYmVnLCBiZWcpO1xuICAgICAgfVxuICAgICAgaWYgKHMuZ3ppbmRleCA9PT0gcy5nemhlYWQuZXh0cmEubGVuZ3RoKSB7XG4gICAgICAgIHMuZ3ppbmRleCA9IDA7XG4gICAgICAgIHMuc3RhdHVzID0gTkFNRV9TVEFURTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBzLnN0YXR1cyA9IE5BTUVfU1RBVEU7XG4gICAgfVxuICB9XG4gIGlmIChzLnN0YXR1cyA9PT0gTkFNRV9TVEFURSkge1xuICAgIGlmIChzLmd6aGVhZC5uYW1lLyogIT0gWl9OVUxMKi8pIHtcbiAgICAgIGJlZyA9IHMucGVuZGluZzsgIC8qIHN0YXJ0IG9mIGJ5dGVzIHRvIHVwZGF0ZSBjcmMgKi9cbiAgICAgIC8vaW50IHZhbDtcblxuICAgICAgZG8ge1xuICAgICAgICBpZiAocy5wZW5kaW5nID09PSBzLnBlbmRpbmdfYnVmX3NpemUpIHtcbiAgICAgICAgICBpZiAocy5nemhlYWQuaGNyYyAmJiBzLnBlbmRpbmcgPiBiZWcpIHtcbiAgICAgICAgICAgIHN0cm0uYWRsZXIgPSBjcmMzMihzdHJtLmFkbGVyLCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmcgLSBiZWcsIGJlZyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZsdXNoX3BlbmRpbmcoc3RybSk7XG4gICAgICAgICAgYmVnID0gcy5wZW5kaW5nO1xuICAgICAgICAgIGlmIChzLnBlbmRpbmcgPT09IHMucGVuZGluZ19idWZfc2l6ZSkge1xuICAgICAgICAgICAgdmFsID0gMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBKUyBzcGVjaWZpYzogbGl0dGxlIG1hZ2ljIHRvIGFkZCB6ZXJvIHRlcm1pbmF0b3IgdG8gZW5kIG9mIHN0cmluZ1xuICAgICAgICBpZiAocy5nemluZGV4IDwgcy5nemhlYWQubmFtZS5sZW5ndGgpIHtcbiAgICAgICAgICB2YWwgPSBzLmd6aGVhZC5uYW1lLmNoYXJDb2RlQXQocy5nemluZGV4KyspICYgMHhmZjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWwgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHB1dF9ieXRlKHMsIHZhbCk7XG4gICAgICB9IHdoaWxlICh2YWwgIT09IDApO1xuXG4gICAgICBpZiAocy5nemhlYWQuaGNyYyAmJiBzLnBlbmRpbmcgPiBiZWcpIHtcbiAgICAgICAgc3RybS5hZGxlciA9IGNyYzMyKHN0cm0uYWRsZXIsIHMucGVuZGluZ19idWYsIHMucGVuZGluZyAtIGJlZywgYmVnKTtcbiAgICAgIH1cbiAgICAgIGlmICh2YWwgPT09IDApIHtcbiAgICAgICAgcy5nemluZGV4ID0gMDtcbiAgICAgICAgcy5zdGF0dXMgPSBDT01NRU5UX1NUQVRFO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHMuc3RhdHVzID0gQ09NTUVOVF9TVEFURTtcbiAgICB9XG4gIH1cbiAgaWYgKHMuc3RhdHVzID09PSBDT01NRU5UX1NUQVRFKSB7XG4gICAgaWYgKHMuZ3poZWFkLmNvbW1lbnQvKiAhPSBaX05VTEwqLykge1xuICAgICAgYmVnID0gcy5wZW5kaW5nOyAgLyogc3RhcnQgb2YgYnl0ZXMgdG8gdXBkYXRlIGNyYyAqL1xuICAgICAgLy9pbnQgdmFsO1xuXG4gICAgICBkbyB7XG4gICAgICAgIGlmIChzLnBlbmRpbmcgPT09IHMucGVuZGluZ19idWZfc2l6ZSkge1xuICAgICAgICAgIGlmIChzLmd6aGVhZC5oY3JjICYmIHMucGVuZGluZyA+IGJlZykge1xuICAgICAgICAgICAgc3RybS5hZGxlciA9IGNyYzMyKHN0cm0uYWRsZXIsIHMucGVuZGluZ19idWYsIHMucGVuZGluZyAtIGJlZywgYmVnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZmx1c2hfcGVuZGluZyhzdHJtKTtcbiAgICAgICAgICBiZWcgPSBzLnBlbmRpbmc7XG4gICAgICAgICAgaWYgKHMucGVuZGluZyA9PT0gcy5wZW5kaW5nX2J1Zl9zaXplKSB7XG4gICAgICAgICAgICB2YWwgPSAxO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEpTIHNwZWNpZmljOiBsaXR0bGUgbWFnaWMgdG8gYWRkIHplcm8gdGVybWluYXRvciB0byBlbmQgb2Ygc3RyaW5nXG4gICAgICAgIGlmIChzLmd6aW5kZXggPCBzLmd6aGVhZC5jb21tZW50Lmxlbmd0aCkge1xuICAgICAgICAgIHZhbCA9IHMuZ3poZWFkLmNvbW1lbnQuY2hhckNvZGVBdChzLmd6aW5kZXgrKykgJiAweGZmO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcHV0X2J5dGUocywgdmFsKTtcbiAgICAgIH0gd2hpbGUgKHZhbCAhPT0gMCk7XG5cbiAgICAgIGlmIChzLmd6aGVhZC5oY3JjICYmIHMucGVuZGluZyA+IGJlZykge1xuICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzIoc3RybS5hZGxlciwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nIC0gYmVnLCBiZWcpO1xuICAgICAgfVxuICAgICAgaWYgKHZhbCA9PT0gMCkge1xuICAgICAgICBzLnN0YXR1cyA9IEhDUkNfU1RBVEU7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcy5zdGF0dXMgPSBIQ1JDX1NUQVRFO1xuICAgIH1cbiAgfVxuICBpZiAocy5zdGF0dXMgPT09IEhDUkNfU1RBVEUpIHtcbiAgICBpZiAocy5nemhlYWQuaGNyYykge1xuICAgICAgaWYgKHMucGVuZGluZyArIDIgPiBzLnBlbmRpbmdfYnVmX3NpemUpIHtcbiAgICAgICAgZmx1c2hfcGVuZGluZyhzdHJtKTtcbiAgICAgIH1cbiAgICAgIGlmIChzLnBlbmRpbmcgKyAyIDw9IHMucGVuZGluZ19idWZfc2l6ZSkge1xuICAgICAgICBwdXRfYnl0ZShzLCBzdHJtLmFkbGVyICYgMHhmZik7XG4gICAgICAgIHB1dF9ieXRlKHMsIChzdHJtLmFkbGVyID4+IDgpICYgMHhmZik7XG4gICAgICAgIHN0cm0uYWRsZXIgPSAwOyAvL2NyYzMyKDBMLCBaX05VTEwsIDApO1xuICAgICAgICBzLnN0YXR1cyA9IEJVU1lfU1RBVEU7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcy5zdGF0dXMgPSBCVVNZX1NUQVRFO1xuICAgIH1cbiAgfVxuLy8jZW5kaWZcblxuICAvKiBGbHVzaCBhcyBtdWNoIHBlbmRpbmcgb3V0cHV0IGFzIHBvc3NpYmxlICovXG4gIGlmIChzLnBlbmRpbmcgIT09IDApIHtcbiAgICBmbHVzaF9wZW5kaW5nKHN0cm0pO1xuICAgIGlmIChzdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgLyogU2luY2UgYXZhaWxfb3V0IGlzIDAsIGRlZmxhdGUgd2lsbCBiZSBjYWxsZWQgYWdhaW4gd2l0aFxuICAgICAgICogbW9yZSBvdXRwdXQgc3BhY2UsIGJ1dCBwb3NzaWJseSB3aXRoIGJvdGggcGVuZGluZyBhbmRcbiAgICAgICAqIGF2YWlsX2luIGVxdWFsIHRvIHplcm8uIFRoZXJlIHdvbid0IGJlIGFueXRoaW5nIHRvIGRvLFxuICAgICAgICogYnV0IHRoaXMgaXMgbm90IGFuIGVycm9yIHNpdHVhdGlvbiBzbyBtYWtlIHN1cmUgd2VcbiAgICAgICAqIHJldHVybiBPSyBpbnN0ZWFkIG9mIEJVRl9FUlJPUiBhdCBuZXh0IGNhbGwgb2YgZGVmbGF0ZTpcbiAgICAgICAqL1xuICAgICAgcy5sYXN0X2ZsdXNoID0gLTE7XG4gICAgICByZXR1cm4gWl9PSztcbiAgICB9XG5cbiAgICAvKiBNYWtlIHN1cmUgdGhlcmUgaXMgc29tZXRoaW5nIHRvIGRvIGFuZCBhdm9pZCBkdXBsaWNhdGUgY29uc2VjdXRpdmVcbiAgICAgKiBmbHVzaGVzLiBGb3IgcmVwZWF0ZWQgYW5kIHVzZWxlc3MgY2FsbHMgd2l0aCBaX0ZJTklTSCwgd2Uga2VlcFxuICAgICAqIHJldHVybmluZyBaX1NUUkVBTV9FTkQgaW5zdGVhZCBvZiBaX0JVRl9FUlJPUi5cbiAgICAgKi9cbiAgfSBlbHNlIGlmIChzdHJtLmF2YWlsX2luID09PSAwICYmIHJhbmsoZmx1c2gpIDw9IHJhbmsob2xkX2ZsdXNoKSAmJlxuICAgIGZsdXNoICE9PSBaX0ZJTklTSCkge1xuICAgIHJldHVybiBlcnIoc3RybSwgWl9CVUZfRVJST1IpO1xuICB9XG5cbiAgLyogVXNlciBtdXN0IG5vdCBwcm92aWRlIG1vcmUgaW5wdXQgYWZ0ZXIgdGhlIGZpcnN0IEZJTklTSDogKi9cbiAgaWYgKHMuc3RhdHVzID09PSBGSU5JU0hfU1RBVEUgJiYgc3RybS5hdmFpbF9pbiAhPT0gMCkge1xuICAgIHJldHVybiBlcnIoc3RybSwgWl9CVUZfRVJST1IpO1xuICB9XG5cbiAgLyogU3RhcnQgYSBuZXcgYmxvY2sgb3IgY29udGludWUgdGhlIGN1cnJlbnQgb25lLlxuICAgKi9cbiAgaWYgKHN0cm0uYXZhaWxfaW4gIT09IDAgfHwgcy5sb29rYWhlYWQgIT09IDAgfHxcbiAgICAoZmx1c2ggIT09IFpfTk9fRkxVU0ggJiYgcy5zdGF0dXMgIT09IEZJTklTSF9TVEFURSkpIHtcbiAgICB2YXIgYnN0YXRlID0gKHMuc3RyYXRlZ3kgPT09IFpfSFVGRk1BTl9PTkxZKSA/IGRlZmxhdGVfaHVmZihzLCBmbHVzaCkgOlxuICAgICAgKHMuc3RyYXRlZ3kgPT09IFpfUkxFID8gZGVmbGF0ZV9ybGUocywgZmx1c2gpIDpcbiAgICAgICAgY29uZmlndXJhdGlvbl90YWJsZVtzLmxldmVsXS5mdW5jKHMsIGZsdXNoKSk7XG5cbiAgICBpZiAoYnN0YXRlID09PSBCU19GSU5JU0hfU1RBUlRFRCB8fCBic3RhdGUgPT09IEJTX0ZJTklTSF9ET05FKSB7XG4gICAgICBzLnN0YXR1cyA9IEZJTklTSF9TVEFURTtcbiAgICB9XG4gICAgaWYgKGJzdGF0ZSA9PT0gQlNfTkVFRF9NT1JFIHx8IGJzdGF0ZSA9PT0gQlNfRklOSVNIX1NUQVJURUQpIHtcbiAgICAgIGlmIChzdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICBzLmxhc3RfZmx1c2ggPSAtMTtcbiAgICAgICAgLyogYXZvaWQgQlVGX0VSUk9SIG5leHQgY2FsbCwgc2VlIGFib3ZlICovXG4gICAgICB9XG4gICAgICByZXR1cm4gWl9PSztcbiAgICAgIC8qIElmIGZsdXNoICE9IFpfTk9fRkxVU0ggJiYgYXZhaWxfb3V0ID09IDAsIHRoZSBuZXh0IGNhbGxcbiAgICAgICAqIG9mIGRlZmxhdGUgc2hvdWxkIHVzZSB0aGUgc2FtZSBmbHVzaCBwYXJhbWV0ZXIgdG8gbWFrZSBzdXJlXG4gICAgICAgKiB0aGF0IHRoZSBmbHVzaCBpcyBjb21wbGV0ZS4gU28gd2UgZG9uJ3QgaGF2ZSB0byBvdXRwdXQgYW5cbiAgICAgICAqIGVtcHR5IGJsb2NrIGhlcmUsIHRoaXMgd2lsbCBiZSBkb25lIGF0IG5leHQgY2FsbC4gVGhpcyBhbHNvXG4gICAgICAgKiBlbnN1cmVzIHRoYXQgZm9yIGEgdmVyeSBzbWFsbCBvdXRwdXQgYnVmZmVyLCB3ZSBlbWl0IGF0IG1vc3RcbiAgICAgICAqIG9uZSBlbXB0eSBibG9jay5cbiAgICAgICAqL1xuICAgIH1cbiAgICBpZiAoYnN0YXRlID09PSBCU19CTE9DS19ET05FKSB7XG4gICAgICBpZiAoZmx1c2ggPT09IFpfUEFSVElBTF9GTFVTSCkge1xuICAgICAgICB0cmVlcy5fdHJfYWxpZ24ocyk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChmbHVzaCAhPT0gWl9CTE9DSykgeyAvKiBGVUxMX0ZMVVNIIG9yIFNZTkNfRkxVU0ggKi9cblxuICAgICAgICB0cmVlcy5fdHJfc3RvcmVkX2Jsb2NrKHMsIDAsIDAsIGZhbHNlKTtcbiAgICAgICAgLyogRm9yIGEgZnVsbCBmbHVzaCwgdGhpcyBlbXB0eSBibG9jayB3aWxsIGJlIHJlY29nbml6ZWRcbiAgICAgICAgICogYXMgYSBzcGVjaWFsIG1hcmtlciBieSBpbmZsYXRlX3N5bmMoKS5cbiAgICAgICAgICovXG4gICAgICAgIGlmIChmbHVzaCA9PT0gWl9GVUxMX0ZMVVNIKSB7XG4gICAgICAgICAgLyoqKiBDTEVBUl9IQVNIKHMpOyAqKiovICAgICAgICAgICAgIC8qIGZvcmdldCBoaXN0b3J5ICovXG4gICAgICAgICAgemVybyhzLmhlYWQpOyAvLyBGaWxsIHdpdGggTklMICg9IDApO1xuXG4gICAgICAgICAgaWYgKHMubG9va2FoZWFkID09PSAwKSB7XG4gICAgICAgICAgICBzLnN0cnN0YXJ0ID0gMDtcbiAgICAgICAgICAgIHMuYmxvY2tfc3RhcnQgPSAwO1xuICAgICAgICAgICAgcy5pbnNlcnQgPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZmx1c2hfcGVuZGluZyhzdHJtKTtcbiAgICAgIGlmIChzdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICBzLmxhc3RfZmx1c2ggPSAtMTsgLyogYXZvaWQgQlVGX0VSUk9SIGF0IG5leHQgY2FsbCwgc2VlIGFib3ZlICovXG4gICAgICAgIHJldHVybiBaX09LO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvL0Fzc2VydChzdHJtLT5hdmFpbF9vdXQgPiAwLCBcImJ1ZzJcIik7XG4gIC8vaWYgKHN0cm0uYXZhaWxfb3V0IDw9IDApIHsgdGhyb3cgbmV3IEVycm9yKFwiYnVnMlwiKTt9XG5cbiAgaWYgKGZsdXNoICE9PSBaX0ZJTklTSCkgeyByZXR1cm4gWl9PSzsgfVxuICBpZiAocy53cmFwIDw9IDApIHsgcmV0dXJuIFpfU1RSRUFNX0VORDsgfVxuXG4gIC8qIFdyaXRlIHRoZSB0cmFpbGVyICovXG4gIGlmIChzLndyYXAgPT09IDIpIHtcbiAgICBwdXRfYnl0ZShzLCBzdHJtLmFkbGVyICYgMHhmZik7XG4gICAgcHV0X2J5dGUocywgKHN0cm0uYWRsZXIgPj4gOCkgJiAweGZmKTtcbiAgICBwdXRfYnl0ZShzLCAoc3RybS5hZGxlciA+PiAxNikgJiAweGZmKTtcbiAgICBwdXRfYnl0ZShzLCAoc3RybS5hZGxlciA+PiAyNCkgJiAweGZmKTtcbiAgICBwdXRfYnl0ZShzLCBzdHJtLnRvdGFsX2luICYgMHhmZik7XG4gICAgcHV0X2J5dGUocywgKHN0cm0udG90YWxfaW4gPj4gOCkgJiAweGZmKTtcbiAgICBwdXRfYnl0ZShzLCAoc3RybS50b3RhbF9pbiA+PiAxNikgJiAweGZmKTtcbiAgICBwdXRfYnl0ZShzLCAoc3RybS50b3RhbF9pbiA+PiAyNCkgJiAweGZmKTtcbiAgfVxuICBlbHNlXG4gIHtcbiAgICBwdXRTaG9ydE1TQihzLCBzdHJtLmFkbGVyID4+PiAxNik7XG4gICAgcHV0U2hvcnRNU0Iocywgc3RybS5hZGxlciAmIDB4ZmZmZik7XG4gIH1cblxuICBmbHVzaF9wZW5kaW5nKHN0cm0pO1xuICAvKiBJZiBhdmFpbF9vdXQgaXMgemVybywgdGhlIGFwcGxpY2F0aW9uIHdpbGwgY2FsbCBkZWZsYXRlIGFnYWluXG4gICAqIHRvIGZsdXNoIHRoZSByZXN0LlxuICAgKi9cbiAgaWYgKHMud3JhcCA+IDApIHsgcy53cmFwID0gLXMud3JhcDsgfVxuICAvKiB3cml0ZSB0aGUgdHJhaWxlciBvbmx5IG9uY2UhICovXG4gIHJldHVybiBzLnBlbmRpbmcgIT09IDAgPyBaX09LIDogWl9TVFJFQU1fRU5EO1xufVxuXG5mdW5jdGlvbiBkZWZsYXRlRW5kKHN0cm0pIHtcbiAgdmFyIHN0YXR1cztcblxuICBpZiAoIXN0cm0vKj09IFpfTlVMTCovIHx8ICFzdHJtLnN0YXRlLyo9PSBaX05VTEwqLykge1xuICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgfVxuXG4gIHN0YXR1cyA9IHN0cm0uc3RhdGUuc3RhdHVzO1xuICBpZiAoc3RhdHVzICE9PSBJTklUX1NUQVRFICYmXG4gICAgc3RhdHVzICE9PSBFWFRSQV9TVEFURSAmJlxuICAgIHN0YXR1cyAhPT0gTkFNRV9TVEFURSAmJlxuICAgIHN0YXR1cyAhPT0gQ09NTUVOVF9TVEFURSAmJlxuICAgIHN0YXR1cyAhPT0gSENSQ19TVEFURSAmJlxuICAgIHN0YXR1cyAhPT0gQlVTWV9TVEFURSAmJlxuICAgIHN0YXR1cyAhPT0gRklOSVNIX1NUQVRFXG4gICkge1xuICAgIHJldHVybiBlcnIoc3RybSwgWl9TVFJFQU1fRVJST1IpO1xuICB9XG5cbiAgc3RybS5zdGF0ZSA9IG51bGw7XG5cbiAgcmV0dXJuIHN0YXR1cyA9PT0gQlVTWV9TVEFURSA/IGVycihzdHJtLCBaX0RBVEFfRVJST1IpIDogWl9PSztcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBJbml0aWFsaXplcyB0aGUgY29tcHJlc3Npb24gZGljdGlvbmFyeSBmcm9tIHRoZSBnaXZlbiBieXRlXG4gKiBzZXF1ZW5jZSB3aXRob3V0IHByb2R1Y2luZyBhbnkgY29tcHJlc3NlZCBvdXRwdXQuXG4gKi9cbmZ1bmN0aW9uIGRlZmxhdGVTZXREaWN0aW9uYXJ5KHN0cm0sIGRpY3Rpb25hcnkpIHtcbiAgdmFyIGRpY3RMZW5ndGggPSBkaWN0aW9uYXJ5Lmxlbmd0aDtcblxuICB2YXIgcztcbiAgdmFyIHN0ciwgbjtcbiAgdmFyIHdyYXA7XG4gIHZhciBhdmFpbDtcbiAgdmFyIG5leHQ7XG4gIHZhciBpbnB1dDtcbiAgdmFyIHRtcERpY3Q7XG5cbiAgaWYgKCFzdHJtLyo9PSBaX05VTEwqLyB8fCAhc3RybS5zdGF0ZS8qPT0gWl9OVUxMKi8pIHtcbiAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gIH1cblxuICBzID0gc3RybS5zdGF0ZTtcbiAgd3JhcCA9IHMud3JhcDtcblxuICBpZiAod3JhcCA9PT0gMiB8fCAod3JhcCA9PT0gMSAmJiBzLnN0YXR1cyAhPT0gSU5JVF9TVEFURSkgfHwgcy5sb29rYWhlYWQpIHtcbiAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gIH1cblxuICAvKiB3aGVuIHVzaW5nIHpsaWIgd3JhcHBlcnMsIGNvbXB1dGUgQWRsZXItMzIgZm9yIHByb3ZpZGVkIGRpY3Rpb25hcnkgKi9cbiAgaWYgKHdyYXAgPT09IDEpIHtcbiAgICAvKiBhZGxlcjMyKHN0cm0tPmFkbGVyLCBkaWN0aW9uYXJ5LCBkaWN0TGVuZ3RoKTsgKi9cbiAgICBzdHJtLmFkbGVyID0gYWRsZXIzMihzdHJtLmFkbGVyLCBkaWN0aW9uYXJ5LCBkaWN0TGVuZ3RoLCAwKTtcbiAgfVxuXG4gIHMud3JhcCA9IDA7ICAgLyogYXZvaWQgY29tcHV0aW5nIEFkbGVyLTMyIGluIHJlYWRfYnVmICovXG5cbiAgLyogaWYgZGljdGlvbmFyeSB3b3VsZCBmaWxsIHdpbmRvdywganVzdCByZXBsYWNlIHRoZSBoaXN0b3J5ICovXG4gIGlmIChkaWN0TGVuZ3RoID49IHMud19zaXplKSB7XG4gICAgaWYgKHdyYXAgPT09IDApIHsgICAgICAgICAgICAvKiBhbHJlYWR5IGVtcHR5IG90aGVyd2lzZSAqL1xuICAgICAgLyoqKiBDTEVBUl9IQVNIKHMpOyAqKiovXG4gICAgICB6ZXJvKHMuaGVhZCk7IC8vIEZpbGwgd2l0aCBOSUwgKD0gMCk7XG4gICAgICBzLnN0cnN0YXJ0ID0gMDtcbiAgICAgIHMuYmxvY2tfc3RhcnQgPSAwO1xuICAgICAgcy5pbnNlcnQgPSAwO1xuICAgIH1cbiAgICAvKiB1c2UgdGhlIHRhaWwgKi9cbiAgICAvLyBkaWN0aW9uYXJ5ID0gZGljdGlvbmFyeS5zbGljZShkaWN0TGVuZ3RoIC0gcy53X3NpemUpO1xuICAgIHRtcERpY3QgPSBuZXcgdXRpbHMuQnVmOChzLndfc2l6ZSk7XG4gICAgdXRpbHMuYXJyYXlTZXQodG1wRGljdCwgZGljdGlvbmFyeSwgZGljdExlbmd0aCAtIHMud19zaXplLCBzLndfc2l6ZSwgMCk7XG4gICAgZGljdGlvbmFyeSA9IHRtcERpY3Q7XG4gICAgZGljdExlbmd0aCA9IHMud19zaXplO1xuICB9XG4gIC8qIGluc2VydCBkaWN0aW9uYXJ5IGludG8gd2luZG93IGFuZCBoYXNoICovXG4gIGF2YWlsID0gc3RybS5hdmFpbF9pbjtcbiAgbmV4dCA9IHN0cm0ubmV4dF9pbjtcbiAgaW5wdXQgPSBzdHJtLmlucHV0O1xuICBzdHJtLmF2YWlsX2luID0gZGljdExlbmd0aDtcbiAgc3RybS5uZXh0X2luID0gMDtcbiAgc3RybS5pbnB1dCA9IGRpY3Rpb25hcnk7XG4gIGZpbGxfd2luZG93KHMpO1xuICB3aGlsZSAocy5sb29rYWhlYWQgPj0gTUlOX01BVENIKSB7XG4gICAgc3RyID0gcy5zdHJzdGFydDtcbiAgICBuID0gcy5sb29rYWhlYWQgLSAoTUlOX01BVENIIC0gMSk7XG4gICAgZG8ge1xuICAgICAgLyogVVBEQVRFX0hBU0gocywgcy0+aW5zX2gsIHMtPndpbmRvd1tzdHIgKyBNSU5fTUFUQ0gtMV0pOyAqL1xuICAgICAgcy5pbnNfaCA9ICgocy5pbnNfaCA8PCBzLmhhc2hfc2hpZnQpIF4gcy53aW5kb3dbc3RyICsgTUlOX01BVENIIC0gMV0pICYgcy5oYXNoX21hc2s7XG5cbiAgICAgIHMucHJldltzdHIgJiBzLndfbWFza10gPSBzLmhlYWRbcy5pbnNfaF07XG5cbiAgICAgIHMuaGVhZFtzLmluc19oXSA9IHN0cjtcbiAgICAgIHN0cisrO1xuICAgIH0gd2hpbGUgKC0tbik7XG4gICAgcy5zdHJzdGFydCA9IHN0cjtcbiAgICBzLmxvb2thaGVhZCA9IE1JTl9NQVRDSCAtIDE7XG4gICAgZmlsbF93aW5kb3cocyk7XG4gIH1cbiAgcy5zdHJzdGFydCArPSBzLmxvb2thaGVhZDtcbiAgcy5ibG9ja19zdGFydCA9IHMuc3Ryc3RhcnQ7XG4gIHMuaW5zZXJ0ID0gcy5sb29rYWhlYWQ7XG4gIHMubG9va2FoZWFkID0gMDtcbiAgcy5tYXRjaF9sZW5ndGggPSBzLnByZXZfbGVuZ3RoID0gTUlOX01BVENIIC0gMTtcbiAgcy5tYXRjaF9hdmFpbGFibGUgPSAwO1xuICBzdHJtLm5leHRfaW4gPSBuZXh0O1xuICBzdHJtLmlucHV0ID0gaW5wdXQ7XG4gIHN0cm0uYXZhaWxfaW4gPSBhdmFpbDtcbiAgcy53cmFwID0gd3JhcDtcbiAgcmV0dXJuIFpfT0s7XG59XG5cblxuZXhwb3J0cy5kZWZsYXRlSW5pdCA9IGRlZmxhdGVJbml0O1xuZXhwb3J0cy5kZWZsYXRlSW5pdDIgPSBkZWZsYXRlSW5pdDI7XG5leHBvcnRzLmRlZmxhdGVSZXNldCA9IGRlZmxhdGVSZXNldDtcbmV4cG9ydHMuZGVmbGF0ZVJlc2V0S2VlcCA9IGRlZmxhdGVSZXNldEtlZXA7XG5leHBvcnRzLmRlZmxhdGVTZXRIZWFkZXIgPSBkZWZsYXRlU2V0SGVhZGVyO1xuZXhwb3J0cy5kZWZsYXRlID0gZGVmbGF0ZTtcbmV4cG9ydHMuZGVmbGF0ZUVuZCA9IGRlZmxhdGVFbmQ7XG5leHBvcnRzLmRlZmxhdGVTZXREaWN0aW9uYXJ5ID0gZGVmbGF0ZVNldERpY3Rpb25hcnk7XG5leHBvcnRzLmRlZmxhdGVJbmZvID0gJ3Bha28gZGVmbGF0ZSAoZnJvbSBOb2RlY2EgcHJvamVjdCknO1xuXG4vKiBOb3QgaW1wbGVtZW50ZWRcbmV4cG9ydHMuZGVmbGF0ZUJvdW5kID0gZGVmbGF0ZUJvdW5kO1xuZXhwb3J0cy5kZWZsYXRlQ29weSA9IGRlZmxhdGVDb3B5O1xuZXhwb3J0cy5kZWZsYXRlUGFyYW1zID0gZGVmbGF0ZVBhcmFtcztcbmV4cG9ydHMuZGVmbGF0ZVBlbmRpbmcgPSBkZWZsYXRlUGVuZGluZztcbmV4cG9ydHMuZGVmbGF0ZVByaW1lID0gZGVmbGF0ZVByaW1lO1xuZXhwb3J0cy5kZWZsYXRlVHVuZSA9IGRlZmxhdGVUdW5lO1xuKi9cbiIsIid1c2Ugc3RyaWN0JztcblxuXG5mdW5jdGlvbiBHWmhlYWRlcigpIHtcbiAgLyogdHJ1ZSBpZiBjb21wcmVzc2VkIGRhdGEgYmVsaWV2ZWQgdG8gYmUgdGV4dCAqL1xuICB0aGlzLnRleHQgICAgICAgPSAwO1xuICAvKiBtb2RpZmljYXRpb24gdGltZSAqL1xuICB0aGlzLnRpbWUgICAgICAgPSAwO1xuICAvKiBleHRyYSBmbGFncyAobm90IHVzZWQgd2hlbiB3cml0aW5nIGEgZ3ppcCBmaWxlKSAqL1xuICB0aGlzLnhmbGFncyAgICAgPSAwO1xuICAvKiBvcGVyYXRpbmcgc3lzdGVtICovXG4gIHRoaXMub3MgICAgICAgICA9IDA7XG4gIC8qIHBvaW50ZXIgdG8gZXh0cmEgZmllbGQgb3IgWl9OVUxMIGlmIG5vbmUgKi9cbiAgdGhpcy5leHRyYSAgICAgID0gbnVsbDtcbiAgLyogZXh0cmEgZmllbGQgbGVuZ3RoICh2YWxpZCBpZiBleHRyYSAhPSBaX05VTEwpICovXG4gIHRoaXMuZXh0cmFfbGVuICA9IDA7IC8vIEFjdHVhbGx5LCB3ZSBkb24ndCBuZWVkIGl0IGluIEpTLFxuICAgICAgICAgICAgICAgICAgICAgICAvLyBidXQgbGVhdmUgZm9yIGZldyBjb2RlIG1vZGlmaWNhdGlvbnNcblxuICAvL1xuICAvLyBTZXR1cCBsaW1pdHMgaXMgbm90IG5lY2Vzc2FyeSBiZWNhdXNlIGluIGpzIHdlIHNob3VsZCBub3QgcHJlYWxsb2NhdGUgbWVtb3J5XG4gIC8vIGZvciBpbmZsYXRlIHVzZSBjb25zdGFudCBsaW1pdCBpbiA2NTUzNiBieXRlc1xuICAvL1xuXG4gIC8qIHNwYWNlIGF0IGV4dHJhIChvbmx5IHdoZW4gcmVhZGluZyBoZWFkZXIpICovXG4gIC8vIHRoaXMuZXh0cmFfbWF4ICA9IDA7XG4gIC8qIHBvaW50ZXIgdG8gemVyby10ZXJtaW5hdGVkIGZpbGUgbmFtZSBvciBaX05VTEwgKi9cbiAgdGhpcy5uYW1lICAgICAgID0gJyc7XG4gIC8qIHNwYWNlIGF0IG5hbWUgKG9ubHkgd2hlbiByZWFkaW5nIGhlYWRlcikgKi9cbiAgLy8gdGhpcy5uYW1lX21heCAgID0gMDtcbiAgLyogcG9pbnRlciB0byB6ZXJvLXRlcm1pbmF0ZWQgY29tbWVudCBvciBaX05VTEwgKi9cbiAgdGhpcy5jb21tZW50ICAgID0gJyc7XG4gIC8qIHNwYWNlIGF0IGNvbW1lbnQgKG9ubHkgd2hlbiByZWFkaW5nIGhlYWRlcikgKi9cbiAgLy8gdGhpcy5jb21tX21heCAgID0gMDtcbiAgLyogdHJ1ZSBpZiB0aGVyZSB3YXMgb3Igd2lsbCBiZSBhIGhlYWRlciBjcmMgKi9cbiAgdGhpcy5oY3JjICAgICAgID0gMDtcbiAgLyogdHJ1ZSB3aGVuIGRvbmUgcmVhZGluZyBnemlwIGhlYWRlciAobm90IHVzZWQgd2hlbiB3cml0aW5nIGEgZ3ppcCBmaWxlKSAqL1xuICB0aGlzLmRvbmUgICAgICAgPSBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBHWmhlYWRlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxuaWYgKCFwcm9jZXNzLnZlcnNpb24gfHxcbiAgICBwcm9jZXNzLnZlcnNpb24uaW5kZXhPZigndjAuJykgPT09IDAgfHxcbiAgICBwcm9jZXNzLnZlcnNpb24uaW5kZXhPZigndjEuJykgPT09IDAgJiYgcHJvY2Vzcy52ZXJzaW9uLmluZGV4T2YoJ3YxLjguJykgIT09IDApIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBuZXh0VGljaztcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcHJvY2Vzcy5uZXh0VGljaztcbn1cblxuZnVuY3Rpb24gbmV4dFRpY2soZm4sIGFyZzEsIGFyZzIsIGFyZzMpIHtcbiAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiY2FsbGJhY2tcIiBhcmd1bWVudCBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgfVxuICB2YXIgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgdmFyIGFyZ3MsIGk7XG4gIHN3aXRjaCAobGVuKSB7XG4gIGNhc2UgMDpcbiAgY2FzZSAxOlxuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZuKTtcbiAgY2FzZSAyOlxuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uIGFmdGVyVGlja09uZSgpIHtcbiAgICAgIGZuLmNhbGwobnVsbCwgYXJnMSk7XG4gICAgfSk7XG4gIGNhc2UgMzpcbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiBhZnRlclRpY2tUd28oKSB7XG4gICAgICBmbi5jYWxsKG51bGwsIGFyZzEsIGFyZzIpO1xuICAgIH0pO1xuICBjYXNlIDQ6XG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gYWZ0ZXJUaWNrVGhyZWUoKSB7XG4gICAgICBmbi5jYWxsKG51bGwsIGFyZzEsIGFyZzIsIGFyZzMpO1xuICAgIH0pO1xuICBkZWZhdWx0OlxuICAgIGFyZ3MgPSBuZXcgQXJyYXkobGVuIC0gMSk7XG4gICAgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBhcmdzLmxlbmd0aCkge1xuICAgICAgYXJnc1tpKytdID0gYXJndW1lbnRzW2ldO1xuICAgIH1cbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiBhZnRlclRpY2soKSB7XG4gICAgICBmbi5hcHBseShudWxsLCBhcmdzKTtcbiAgICB9KTtcbiAgfVxufVxuIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcbiIsIi8qISBodHRwczovL210aHMuYmUvcHVueWNvZGUgdjEuNC4xIGJ5IEBtYXRoaWFzICovXG47KGZ1bmN0aW9uKHJvb3QpIHtcblxuXHQvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGVzICovXG5cdHZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiZcblx0XHQhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXHR2YXIgZnJlZU1vZHVsZSA9IHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmXG5cdFx0IW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cdHZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWw7XG5cdGlmIChcblx0XHRmcmVlR2xvYmFsLmdsb2JhbCA9PT0gZnJlZUdsb2JhbCB8fFxuXHRcdGZyZWVHbG9iYWwud2luZG93ID09PSBmcmVlR2xvYmFsIHx8XG5cdFx0ZnJlZUdsb2JhbC5zZWxmID09PSBmcmVlR2xvYmFsXG5cdCkge1xuXHRcdHJvb3QgPSBmcmVlR2xvYmFsO1xuXHR9XG5cblx0LyoqXG5cdCAqIFRoZSBgcHVueWNvZGVgIG9iamVjdC5cblx0ICogQG5hbWUgcHVueWNvZGVcblx0ICogQHR5cGUgT2JqZWN0XG5cdCAqL1xuXHR2YXIgcHVueWNvZGUsXG5cblx0LyoqIEhpZ2hlc3QgcG9zaXRpdmUgc2lnbmVkIDMyLWJpdCBmbG9hdCB2YWx1ZSAqL1xuXHRtYXhJbnQgPSAyMTQ3NDgzNjQ3LCAvLyBha2EuIDB4N0ZGRkZGRkYgb3IgMl4zMS0xXG5cblx0LyoqIEJvb3RzdHJpbmcgcGFyYW1ldGVycyAqL1xuXHRiYXNlID0gMzYsXG5cdHRNaW4gPSAxLFxuXHR0TWF4ID0gMjYsXG5cdHNrZXcgPSAzOCxcblx0ZGFtcCA9IDcwMCxcblx0aW5pdGlhbEJpYXMgPSA3Mixcblx0aW5pdGlhbE4gPSAxMjgsIC8vIDB4ODBcblx0ZGVsaW1pdGVyID0gJy0nLCAvLyAnXFx4MkQnXG5cblx0LyoqIFJlZ3VsYXIgZXhwcmVzc2lvbnMgKi9cblx0cmVnZXhQdW55Y29kZSA9IC9eeG4tLS8sXG5cdHJlZ2V4Tm9uQVNDSUkgPSAvW15cXHgyMC1cXHg3RV0vLCAvLyB1bnByaW50YWJsZSBBU0NJSSBjaGFycyArIG5vbi1BU0NJSSBjaGFyc1xuXHRyZWdleFNlcGFyYXRvcnMgPSAvW1xceDJFXFx1MzAwMlxcdUZGMEVcXHVGRjYxXS9nLCAvLyBSRkMgMzQ5MCBzZXBhcmF0b3JzXG5cblx0LyoqIEVycm9yIG1lc3NhZ2VzICovXG5cdGVycm9ycyA9IHtcblx0XHQnb3ZlcmZsb3cnOiAnT3ZlcmZsb3c6IGlucHV0IG5lZWRzIHdpZGVyIGludGVnZXJzIHRvIHByb2Nlc3MnLFxuXHRcdCdub3QtYmFzaWMnOiAnSWxsZWdhbCBpbnB1dCA+PSAweDgwIChub3QgYSBiYXNpYyBjb2RlIHBvaW50KScsXG5cdFx0J2ludmFsaWQtaW5wdXQnOiAnSW52YWxpZCBpbnB1dCdcblx0fSxcblxuXHQvKiogQ29udmVuaWVuY2Ugc2hvcnRjdXRzICovXG5cdGJhc2VNaW51c1RNaW4gPSBiYXNlIC0gdE1pbixcblx0Zmxvb3IgPSBNYXRoLmZsb29yLFxuXHRzdHJpbmdGcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLFxuXG5cdC8qKiBUZW1wb3JhcnkgdmFyaWFibGUgKi9cblx0a2V5O1xuXG5cdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cdC8qKlxuXHQgKiBBIGdlbmVyaWMgZXJyb3IgdXRpbGl0eSBmdW5jdGlvbi5cblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIGVycm9yIHR5cGUuXG5cdCAqIEByZXR1cm5zIHtFcnJvcn0gVGhyb3dzIGEgYFJhbmdlRXJyb3JgIHdpdGggdGhlIGFwcGxpY2FibGUgZXJyb3IgbWVzc2FnZS5cblx0ICovXG5cdGZ1bmN0aW9uIGVycm9yKHR5cGUpIHtcblx0XHR0aHJvdyBuZXcgUmFuZ2VFcnJvcihlcnJvcnNbdHlwZV0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIEEgZ2VuZXJpYyBgQXJyYXkjbWFwYCB1dGlsaXR5IGZ1bmN0aW9uLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdGhhdCBnZXRzIGNhbGxlZCBmb3IgZXZlcnkgYXJyYXlcblx0ICogaXRlbS5cblx0ICogQHJldHVybnMge0FycmF5fSBBIG5ldyBhcnJheSBvZiB2YWx1ZXMgcmV0dXJuZWQgYnkgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uLlxuXHQgKi9cblx0ZnVuY3Rpb24gbWFwKGFycmF5LCBmbikge1xuXHRcdHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cdFx0dmFyIHJlc3VsdCA9IFtdO1xuXHRcdHdoaWxlIChsZW5ndGgtLSkge1xuXHRcdFx0cmVzdWx0W2xlbmd0aF0gPSBmbihhcnJheVtsZW5ndGhdKTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fVxuXG5cdC8qKlxuXHQgKiBBIHNpbXBsZSBgQXJyYXkjbWFwYC1saWtlIHdyYXBwZXIgdG8gd29yayB3aXRoIGRvbWFpbiBuYW1lIHN0cmluZ3Mgb3IgZW1haWxcblx0ICogYWRkcmVzc2VzLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gZG9tYWluIFRoZSBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdGhhdCBnZXRzIGNhbGxlZCBmb3IgZXZlcnlcblx0ICogY2hhcmFjdGVyLlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IEEgbmV3IHN0cmluZyBvZiBjaGFyYWN0ZXJzIHJldHVybmVkIGJ5IHRoZSBjYWxsYmFja1xuXHQgKiBmdW5jdGlvbi5cblx0ICovXG5cdGZ1bmN0aW9uIG1hcERvbWFpbihzdHJpbmcsIGZuKSB7XG5cdFx0dmFyIHBhcnRzID0gc3RyaW5nLnNwbGl0KCdAJyk7XG5cdFx0dmFyIHJlc3VsdCA9ICcnO1xuXHRcdGlmIChwYXJ0cy5sZW5ndGggPiAxKSB7XG5cdFx0XHQvLyBJbiBlbWFpbCBhZGRyZXNzZXMsIG9ubHkgdGhlIGRvbWFpbiBuYW1lIHNob3VsZCBiZSBwdW55Y29kZWQuIExlYXZlXG5cdFx0XHQvLyB0aGUgbG9jYWwgcGFydCAoaS5lLiBldmVyeXRoaW5nIHVwIHRvIGBAYCkgaW50YWN0LlxuXHRcdFx0cmVzdWx0ID0gcGFydHNbMF0gKyAnQCc7XG5cdFx0XHRzdHJpbmcgPSBwYXJ0c1sxXTtcblx0XHR9XG5cdFx0Ly8gQXZvaWQgYHNwbGl0KHJlZ2V4KWAgZm9yIElFOCBjb21wYXRpYmlsaXR5LiBTZWUgIzE3LlxuXHRcdHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKHJlZ2V4U2VwYXJhdG9ycywgJ1xceDJFJyk7XG5cdFx0dmFyIGxhYmVscyA9IHN0cmluZy5zcGxpdCgnLicpO1xuXHRcdHZhciBlbmNvZGVkID0gbWFwKGxhYmVscywgZm4pLmpvaW4oJy4nKTtcblx0XHRyZXR1cm4gcmVzdWx0ICsgZW5jb2RlZDtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIG51bWVyaWMgY29kZSBwb2ludHMgb2YgZWFjaCBVbmljb2RlXG5cdCAqIGNoYXJhY3RlciBpbiB0aGUgc3RyaW5nLiBXaGlsZSBKYXZhU2NyaXB0IHVzZXMgVUNTLTIgaW50ZXJuYWxseSxcblx0ICogdGhpcyBmdW5jdGlvbiB3aWxsIGNvbnZlcnQgYSBwYWlyIG9mIHN1cnJvZ2F0ZSBoYWx2ZXMgKGVhY2ggb2Ygd2hpY2hcblx0ICogVUNTLTIgZXhwb3NlcyBhcyBzZXBhcmF0ZSBjaGFyYWN0ZXJzKSBpbnRvIGEgc2luZ2xlIGNvZGUgcG9pbnQsXG5cdCAqIG1hdGNoaW5nIFVURi0xNi5cblx0ICogQHNlZSBgcHVueWNvZGUudWNzMi5lbmNvZGVgXG5cdCAqIEBzZWUgPGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nPlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGUudWNzMlxuXHQgKiBAbmFtZSBkZWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZyBUaGUgVW5pY29kZSBpbnB1dCBzdHJpbmcgKFVDUy0yKS5cblx0ICogQHJldHVybnMge0FycmF5fSBUaGUgbmV3IGFycmF5IG9mIGNvZGUgcG9pbnRzLlxuXHQgKi9cblx0ZnVuY3Rpb24gdWNzMmRlY29kZShzdHJpbmcpIHtcblx0XHR2YXIgb3V0cHV0ID0gW10sXG5cdFx0ICAgIGNvdW50ZXIgPSAwLFxuXHRcdCAgICBsZW5ndGggPSBzdHJpbmcubGVuZ3RoLFxuXHRcdCAgICB2YWx1ZSxcblx0XHQgICAgZXh0cmE7XG5cdFx0d2hpbGUgKGNvdW50ZXIgPCBsZW5ndGgpIHtcblx0XHRcdHZhbHVlID0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTtcblx0XHRcdGlmICh2YWx1ZSA+PSAweEQ4MDAgJiYgdmFsdWUgPD0gMHhEQkZGICYmIGNvdW50ZXIgPCBsZW5ndGgpIHtcblx0XHRcdFx0Ly8gaGlnaCBzdXJyb2dhdGUsIGFuZCB0aGVyZSBpcyBhIG5leHQgY2hhcmFjdGVyXG5cdFx0XHRcdGV4dHJhID0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTtcblx0XHRcdFx0aWYgKChleHRyYSAmIDB4RkMwMCkgPT0gMHhEQzAwKSB7IC8vIGxvdyBzdXJyb2dhdGVcblx0XHRcdFx0XHRvdXRwdXQucHVzaCgoKHZhbHVlICYgMHgzRkYpIDw8IDEwKSArIChleHRyYSAmIDB4M0ZGKSArIDB4MTAwMDApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIHVubWF0Y2hlZCBzdXJyb2dhdGU7IG9ubHkgYXBwZW5kIHRoaXMgY29kZSB1bml0LCBpbiBjYXNlIHRoZSBuZXh0XG5cdFx0XHRcdFx0Ly8gY29kZSB1bml0IGlzIHRoZSBoaWdoIHN1cnJvZ2F0ZSBvZiBhIHN1cnJvZ2F0ZSBwYWlyXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2godmFsdWUpO1xuXHRcdFx0XHRcdGNvdW50ZXItLTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0b3V0cHV0LnB1c2godmFsdWUpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gb3V0cHV0O1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYSBzdHJpbmcgYmFzZWQgb24gYW4gYXJyYXkgb2YgbnVtZXJpYyBjb2RlIHBvaW50cy5cblx0ICogQHNlZSBgcHVueWNvZGUudWNzMi5kZWNvZGVgXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZS51Y3MyXG5cdCAqIEBuYW1lIGVuY29kZVxuXHQgKiBAcGFyYW0ge0FycmF5fSBjb2RlUG9pbnRzIFRoZSBhcnJheSBvZiBudW1lcmljIGNvZGUgcG9pbnRzLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgbmV3IFVuaWNvZGUgc3RyaW5nIChVQ1MtMikuXG5cdCAqL1xuXHRmdW5jdGlvbiB1Y3MyZW5jb2RlKGFycmF5KSB7XG5cdFx0cmV0dXJuIG1hcChhcnJheSwgZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdHZhciBvdXRwdXQgPSAnJztcblx0XHRcdGlmICh2YWx1ZSA+IDB4RkZGRikge1xuXHRcdFx0XHR2YWx1ZSAtPSAweDEwMDAwO1xuXHRcdFx0XHRvdXRwdXQgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKHZhbHVlID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKTtcblx0XHRcdFx0dmFsdWUgPSAweERDMDAgfCB2YWx1ZSAmIDB4M0ZGO1xuXHRcdFx0fVxuXHRcdFx0b3V0cHV0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZSh2YWx1ZSk7XG5cdFx0XHRyZXR1cm4gb3V0cHV0O1xuXHRcdH0pLmpvaW4oJycpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgYmFzaWMgY29kZSBwb2ludCBpbnRvIGEgZGlnaXQvaW50ZWdlci5cblx0ICogQHNlZSBgZGlnaXRUb0Jhc2ljKClgXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBjb2RlUG9pbnQgVGhlIGJhc2ljIG51bWVyaWMgY29kZSBwb2ludCB2YWx1ZS5cblx0ICogQHJldHVybnMge051bWJlcn0gVGhlIG51bWVyaWMgdmFsdWUgb2YgYSBiYXNpYyBjb2RlIHBvaW50IChmb3IgdXNlIGluXG5cdCAqIHJlcHJlc2VudGluZyBpbnRlZ2VycykgaW4gdGhlIHJhbmdlIGAwYCB0byBgYmFzZSAtIDFgLCBvciBgYmFzZWAgaWZcblx0ICogdGhlIGNvZGUgcG9pbnQgZG9lcyBub3QgcmVwcmVzZW50IGEgdmFsdWUuXG5cdCAqL1xuXHRmdW5jdGlvbiBiYXNpY1RvRGlnaXQoY29kZVBvaW50KSB7XG5cdFx0aWYgKGNvZGVQb2ludCAtIDQ4IDwgMTApIHtcblx0XHRcdHJldHVybiBjb2RlUG9pbnQgLSAyMjtcblx0XHR9XG5cdFx0aWYgKGNvZGVQb2ludCAtIDY1IDwgMjYpIHtcblx0XHRcdHJldHVybiBjb2RlUG9pbnQgLSA2NTtcblx0XHR9XG5cdFx0aWYgKGNvZGVQb2ludCAtIDk3IDwgMjYpIHtcblx0XHRcdHJldHVybiBjb2RlUG9pbnQgLSA5Nztcblx0XHR9XG5cdFx0cmV0dXJuIGJhc2U7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBkaWdpdC9pbnRlZ2VyIGludG8gYSBiYXNpYyBjb2RlIHBvaW50LlxuXHQgKiBAc2VlIGBiYXNpY1RvRGlnaXQoKWBcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGRpZ2l0IFRoZSBudW1lcmljIHZhbHVlIG9mIGEgYmFzaWMgY29kZSBwb2ludC5cblx0ICogQHJldHVybnMge051bWJlcn0gVGhlIGJhc2ljIGNvZGUgcG9pbnQgd2hvc2UgdmFsdWUgKHdoZW4gdXNlZCBmb3Jcblx0ICogcmVwcmVzZW50aW5nIGludGVnZXJzKSBpcyBgZGlnaXRgLCB3aGljaCBuZWVkcyB0byBiZSBpbiB0aGUgcmFuZ2Vcblx0ICogYDBgIHRvIGBiYXNlIC0gMWAuIElmIGBmbGFnYCBpcyBub24temVybywgdGhlIHVwcGVyY2FzZSBmb3JtIGlzXG5cdCAqIHVzZWQ7IGVsc2UsIHRoZSBsb3dlcmNhc2UgZm9ybSBpcyB1c2VkLiBUaGUgYmVoYXZpb3IgaXMgdW5kZWZpbmVkXG5cdCAqIGlmIGBmbGFnYCBpcyBub24temVybyBhbmQgYGRpZ2l0YCBoYXMgbm8gdXBwZXJjYXNlIGZvcm0uXG5cdCAqL1xuXHRmdW5jdGlvbiBkaWdpdFRvQmFzaWMoZGlnaXQsIGZsYWcpIHtcblx0XHQvLyAgMC4uMjUgbWFwIHRvIEFTQ0lJIGEuLnogb3IgQS4uWlxuXHRcdC8vIDI2Li4zNSBtYXAgdG8gQVNDSUkgMC4uOVxuXHRcdHJldHVybiBkaWdpdCArIDIyICsgNzUgKiAoZGlnaXQgPCAyNikgLSAoKGZsYWcgIT0gMCkgPDwgNSk7XG5cdH1cblxuXHQvKipcblx0ICogQmlhcyBhZGFwdGF0aW9uIGZ1bmN0aW9uIGFzIHBlciBzZWN0aW9uIDMuNCBvZiBSRkMgMzQ5Mi5cblx0ICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM0OTIjc2VjdGlvbi0zLjRcblx0ICogQHByaXZhdGVcblx0ICovXG5cdGZ1bmN0aW9uIGFkYXB0KGRlbHRhLCBudW1Qb2ludHMsIGZpcnN0VGltZSkge1xuXHRcdHZhciBrID0gMDtcblx0XHRkZWx0YSA9IGZpcnN0VGltZSA/IGZsb29yKGRlbHRhIC8gZGFtcCkgOiBkZWx0YSA+PiAxO1xuXHRcdGRlbHRhICs9IGZsb29yKGRlbHRhIC8gbnVtUG9pbnRzKTtcblx0XHRmb3IgKC8qIG5vIGluaXRpYWxpemF0aW9uICovOyBkZWx0YSA+IGJhc2VNaW51c1RNaW4gKiB0TWF4ID4+IDE7IGsgKz0gYmFzZSkge1xuXHRcdFx0ZGVsdGEgPSBmbG9vcihkZWx0YSAvIGJhc2VNaW51c1RNaW4pO1xuXHRcdH1cblx0XHRyZXR1cm4gZmxvb3IoayArIChiYXNlTWludXNUTWluICsgMSkgKiBkZWx0YSAvIChkZWx0YSArIHNrZXcpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMgdG8gYSBzdHJpbmcgb2YgVW5pY29kZVxuXHQgKiBzeW1ib2xzLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgcmVzdWx0aW5nIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMuXG5cdCAqL1xuXHRmdW5jdGlvbiBkZWNvZGUoaW5wdXQpIHtcblx0XHQvLyBEb24ndCB1c2UgVUNTLTJcblx0XHR2YXIgb3V0cHV0ID0gW10sXG5cdFx0ICAgIGlucHV0TGVuZ3RoID0gaW5wdXQubGVuZ3RoLFxuXHRcdCAgICBvdXQsXG5cdFx0ICAgIGkgPSAwLFxuXHRcdCAgICBuID0gaW5pdGlhbE4sXG5cdFx0ICAgIGJpYXMgPSBpbml0aWFsQmlhcyxcblx0XHQgICAgYmFzaWMsXG5cdFx0ICAgIGosXG5cdFx0ICAgIGluZGV4LFxuXHRcdCAgICBvbGRpLFxuXHRcdCAgICB3LFxuXHRcdCAgICBrLFxuXHRcdCAgICBkaWdpdCxcblx0XHQgICAgdCxcblx0XHQgICAgLyoqIENhY2hlZCBjYWxjdWxhdGlvbiByZXN1bHRzICovXG5cdFx0ICAgIGJhc2VNaW51c1Q7XG5cblx0XHQvLyBIYW5kbGUgdGhlIGJhc2ljIGNvZGUgcG9pbnRzOiBsZXQgYGJhc2ljYCBiZSB0aGUgbnVtYmVyIG9mIGlucHV0IGNvZGVcblx0XHQvLyBwb2ludHMgYmVmb3JlIHRoZSBsYXN0IGRlbGltaXRlciwgb3IgYDBgIGlmIHRoZXJlIGlzIG5vbmUsIHRoZW4gY29weVxuXHRcdC8vIHRoZSBmaXJzdCBiYXNpYyBjb2RlIHBvaW50cyB0byB0aGUgb3V0cHV0LlxuXG5cdFx0YmFzaWMgPSBpbnB1dC5sYXN0SW5kZXhPZihkZWxpbWl0ZXIpO1xuXHRcdGlmIChiYXNpYyA8IDApIHtcblx0XHRcdGJhc2ljID0gMDtcblx0XHR9XG5cblx0XHRmb3IgKGogPSAwOyBqIDwgYmFzaWM7ICsraikge1xuXHRcdFx0Ly8gaWYgaXQncyBub3QgYSBiYXNpYyBjb2RlIHBvaW50XG5cdFx0XHRpZiAoaW5wdXQuY2hhckNvZGVBdChqKSA+PSAweDgwKSB7XG5cdFx0XHRcdGVycm9yKCdub3QtYmFzaWMnKTtcblx0XHRcdH1cblx0XHRcdG91dHB1dC5wdXNoKGlucHV0LmNoYXJDb2RlQXQoaikpO1xuXHRcdH1cblxuXHRcdC8vIE1haW4gZGVjb2RpbmcgbG9vcDogc3RhcnQganVzdCBhZnRlciB0aGUgbGFzdCBkZWxpbWl0ZXIgaWYgYW55IGJhc2ljIGNvZGVcblx0XHQvLyBwb2ludHMgd2VyZSBjb3BpZWQ7IHN0YXJ0IGF0IHRoZSBiZWdpbm5pbmcgb3RoZXJ3aXNlLlxuXG5cdFx0Zm9yIChpbmRleCA9IGJhc2ljID4gMCA/IGJhc2ljICsgMSA6IDA7IGluZGV4IDwgaW5wdXRMZW5ndGg7IC8qIG5vIGZpbmFsIGV4cHJlc3Npb24gKi8pIHtcblxuXHRcdFx0Ly8gYGluZGV4YCBpcyB0aGUgaW5kZXggb2YgdGhlIG5leHQgY2hhcmFjdGVyIHRvIGJlIGNvbnN1bWVkLlxuXHRcdFx0Ly8gRGVjb2RlIGEgZ2VuZXJhbGl6ZWQgdmFyaWFibGUtbGVuZ3RoIGludGVnZXIgaW50byBgZGVsdGFgLFxuXHRcdFx0Ly8gd2hpY2ggZ2V0cyBhZGRlZCB0byBgaWAuIFRoZSBvdmVyZmxvdyBjaGVja2luZyBpcyBlYXNpZXJcblx0XHRcdC8vIGlmIHdlIGluY3JlYXNlIGBpYCBhcyB3ZSBnbywgdGhlbiBzdWJ0cmFjdCBvZmYgaXRzIHN0YXJ0aW5nXG5cdFx0XHQvLyB2YWx1ZSBhdCB0aGUgZW5kIHRvIG9idGFpbiBgZGVsdGFgLlxuXHRcdFx0Zm9yIChvbGRpID0gaSwgdyA9IDEsIGsgPSBiYXNlOyAvKiBubyBjb25kaXRpb24gKi87IGsgKz0gYmFzZSkge1xuXG5cdFx0XHRcdGlmIChpbmRleCA+PSBpbnB1dExlbmd0aCkge1xuXHRcdFx0XHRcdGVycm9yKCdpbnZhbGlkLWlucHV0Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRkaWdpdCA9IGJhc2ljVG9EaWdpdChpbnB1dC5jaGFyQ29kZUF0KGluZGV4KyspKTtcblxuXHRcdFx0XHRpZiAoZGlnaXQgPj0gYmFzZSB8fCBkaWdpdCA+IGZsb29yKChtYXhJbnQgLSBpKSAvIHcpKSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpICs9IGRpZ2l0ICogdztcblx0XHRcdFx0dCA9IGsgPD0gYmlhcyA/IHRNaW4gOiAoayA+PSBiaWFzICsgdE1heCA/IHRNYXggOiBrIC0gYmlhcyk7XG5cblx0XHRcdFx0aWYgKGRpZ2l0IDwgdCkge1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0YmFzZU1pbnVzVCA9IGJhc2UgLSB0O1xuXHRcdFx0XHRpZiAodyA+IGZsb29yKG1heEludCAvIGJhc2VNaW51c1QpKSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR3ICo9IGJhc2VNaW51c1Q7XG5cblx0XHRcdH1cblxuXHRcdFx0b3V0ID0gb3V0cHV0Lmxlbmd0aCArIDE7XG5cdFx0XHRiaWFzID0gYWRhcHQoaSAtIG9sZGksIG91dCwgb2xkaSA9PSAwKTtcblxuXHRcdFx0Ly8gYGlgIHdhcyBzdXBwb3NlZCB0byB3cmFwIGFyb3VuZCBmcm9tIGBvdXRgIHRvIGAwYCxcblx0XHRcdC8vIGluY3JlbWVudGluZyBgbmAgZWFjaCB0aW1lLCBzbyB3ZSdsbCBmaXggdGhhdCBub3c6XG5cdFx0XHRpZiAoZmxvb3IoaSAvIG91dCkgPiBtYXhJbnQgLSBuKSB7XG5cdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0fVxuXG5cdFx0XHRuICs9IGZsb29yKGkgLyBvdXQpO1xuXHRcdFx0aSAlPSBvdXQ7XG5cblx0XHRcdC8vIEluc2VydCBgbmAgYXQgcG9zaXRpb24gYGlgIG9mIHRoZSBvdXRwdXRcblx0XHRcdG91dHB1dC5zcGxpY2UoaSsrLCAwLCBuKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB1Y3MyZW5jb2RlKG91dHB1dCk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzIChlLmcuIGEgZG9tYWluIG5hbWUgbGFiZWwpIHRvIGFcblx0ICogUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIHJlc3VsdGluZyBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuXHQgKi9cblx0ZnVuY3Rpb24gZW5jb2RlKGlucHV0KSB7XG5cdFx0dmFyIG4sXG5cdFx0ICAgIGRlbHRhLFxuXHRcdCAgICBoYW5kbGVkQ1BDb3VudCxcblx0XHQgICAgYmFzaWNMZW5ndGgsXG5cdFx0ICAgIGJpYXMsXG5cdFx0ICAgIGosXG5cdFx0ICAgIG0sXG5cdFx0ICAgIHEsXG5cdFx0ICAgIGssXG5cdFx0ICAgIHQsXG5cdFx0ICAgIGN1cnJlbnRWYWx1ZSxcblx0XHQgICAgb3V0cHV0ID0gW10sXG5cdFx0ICAgIC8qKiBgaW5wdXRMZW5ndGhgIHdpbGwgaG9sZCB0aGUgbnVtYmVyIG9mIGNvZGUgcG9pbnRzIGluIGBpbnB1dGAuICovXG5cdFx0ICAgIGlucHV0TGVuZ3RoLFxuXHRcdCAgICAvKiogQ2FjaGVkIGNhbGN1bGF0aW9uIHJlc3VsdHMgKi9cblx0XHQgICAgaGFuZGxlZENQQ291bnRQbHVzT25lLFxuXHRcdCAgICBiYXNlTWludXNULFxuXHRcdCAgICBxTWludXNUO1xuXG5cdFx0Ly8gQ29udmVydCB0aGUgaW5wdXQgaW4gVUNTLTIgdG8gVW5pY29kZVxuXHRcdGlucHV0ID0gdWNzMmRlY29kZShpbnB1dCk7XG5cblx0XHQvLyBDYWNoZSB0aGUgbGVuZ3RoXG5cdFx0aW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGg7XG5cblx0XHQvLyBJbml0aWFsaXplIHRoZSBzdGF0ZVxuXHRcdG4gPSBpbml0aWFsTjtcblx0XHRkZWx0YSA9IDA7XG5cdFx0YmlhcyA9IGluaXRpYWxCaWFzO1xuXG5cdFx0Ly8gSGFuZGxlIHRoZSBiYXNpYyBjb2RlIHBvaW50c1xuXHRcdGZvciAoaiA9IDA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7XG5cdFx0XHRjdXJyZW50VmFsdWUgPSBpbnB1dFtqXTtcblx0XHRcdGlmIChjdXJyZW50VmFsdWUgPCAweDgwKSB7XG5cdFx0XHRcdG91dHB1dC5wdXNoKHN0cmluZ0Zyb21DaGFyQ29kZShjdXJyZW50VmFsdWUpKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRoYW5kbGVkQ1BDb3VudCA9IGJhc2ljTGVuZ3RoID0gb3V0cHV0Lmxlbmd0aDtcblxuXHRcdC8vIGBoYW5kbGVkQ1BDb3VudGAgaXMgdGhlIG51bWJlciBvZiBjb2RlIHBvaW50cyB0aGF0IGhhdmUgYmVlbiBoYW5kbGVkO1xuXHRcdC8vIGBiYXNpY0xlbmd0aGAgaXMgdGhlIG51bWJlciBvZiBiYXNpYyBjb2RlIHBvaW50cy5cblxuXHRcdC8vIEZpbmlzaCB0aGUgYmFzaWMgc3RyaW5nIC0gaWYgaXQgaXMgbm90IGVtcHR5IC0gd2l0aCBhIGRlbGltaXRlclxuXHRcdGlmIChiYXNpY0xlbmd0aCkge1xuXHRcdFx0b3V0cHV0LnB1c2goZGVsaW1pdGVyKTtcblx0XHR9XG5cblx0XHQvLyBNYWluIGVuY29kaW5nIGxvb3A6XG5cdFx0d2hpbGUgKGhhbmRsZWRDUENvdW50IDwgaW5wdXRMZW5ndGgpIHtcblxuXHRcdFx0Ly8gQWxsIG5vbi1iYXNpYyBjb2RlIHBvaW50cyA8IG4gaGF2ZSBiZWVuIGhhbmRsZWQgYWxyZWFkeS4gRmluZCB0aGUgbmV4dFxuXHRcdFx0Ly8gbGFyZ2VyIG9uZTpcblx0XHRcdGZvciAobSA9IG1heEludCwgaiA9IDA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7XG5cdFx0XHRcdGN1cnJlbnRWYWx1ZSA9IGlucHV0W2pdO1xuXHRcdFx0XHRpZiAoY3VycmVudFZhbHVlID49IG4gJiYgY3VycmVudFZhbHVlIDwgbSkge1xuXHRcdFx0XHRcdG0gPSBjdXJyZW50VmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gSW5jcmVhc2UgYGRlbHRhYCBlbm91Z2ggdG8gYWR2YW5jZSB0aGUgZGVjb2RlcidzIDxuLGk+IHN0YXRlIHRvIDxtLDA+LFxuXHRcdFx0Ly8gYnV0IGd1YXJkIGFnYWluc3Qgb3ZlcmZsb3dcblx0XHRcdGhhbmRsZWRDUENvdW50UGx1c09uZSA9IGhhbmRsZWRDUENvdW50ICsgMTtcblx0XHRcdGlmIChtIC0gbiA+IGZsb29yKChtYXhJbnQgLSBkZWx0YSkgLyBoYW5kbGVkQ1BDb3VudFBsdXNPbmUpKSB7XG5cdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0fVxuXG5cdFx0XHRkZWx0YSArPSAobSAtIG4pICogaGFuZGxlZENQQ291bnRQbHVzT25lO1xuXHRcdFx0biA9IG07XG5cblx0XHRcdGZvciAoaiA9IDA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7XG5cdFx0XHRcdGN1cnJlbnRWYWx1ZSA9IGlucHV0W2pdO1xuXG5cdFx0XHRcdGlmIChjdXJyZW50VmFsdWUgPCBuICYmICsrZGVsdGEgPiBtYXhJbnQpIHtcblx0XHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChjdXJyZW50VmFsdWUgPT0gbikge1xuXHRcdFx0XHRcdC8vIFJlcHJlc2VudCBkZWx0YSBhcyBhIGdlbmVyYWxpemVkIHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyXG5cdFx0XHRcdFx0Zm9yIChxID0gZGVsdGEsIGsgPSBiYXNlOyAvKiBubyBjb25kaXRpb24gKi87IGsgKz0gYmFzZSkge1xuXHRcdFx0XHRcdFx0dCA9IGsgPD0gYmlhcyA/IHRNaW4gOiAoayA+PSBiaWFzICsgdE1heCA/IHRNYXggOiBrIC0gYmlhcyk7XG5cdFx0XHRcdFx0XHRpZiAocSA8IHQpIHtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRxTWludXNUID0gcSAtIHQ7XG5cdFx0XHRcdFx0XHRiYXNlTWludXNUID0gYmFzZSAtIHQ7XG5cdFx0XHRcdFx0XHRvdXRwdXQucHVzaChcblx0XHRcdFx0XHRcdFx0c3RyaW5nRnJvbUNoYXJDb2RlKGRpZ2l0VG9CYXNpYyh0ICsgcU1pbnVzVCAlIGJhc2VNaW51c1QsIDApKVxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdHEgPSBmbG9vcihxTWludXNUIC8gYmFzZU1pbnVzVCk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2goc3RyaW5nRnJvbUNoYXJDb2RlKGRpZ2l0VG9CYXNpYyhxLCAwKSkpO1xuXHRcdFx0XHRcdGJpYXMgPSBhZGFwdChkZWx0YSwgaGFuZGxlZENQQ291bnRQbHVzT25lLCBoYW5kbGVkQ1BDb3VudCA9PSBiYXNpY0xlbmd0aCk7XG5cdFx0XHRcdFx0ZGVsdGEgPSAwO1xuXHRcdFx0XHRcdCsraGFuZGxlZENQQ291bnQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0KytkZWx0YTtcblx0XHRcdCsrbjtcblxuXHRcdH1cblx0XHRyZXR1cm4gb3V0cHV0LmpvaW4oJycpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgUHVueWNvZGUgc3RyaW5nIHJlcHJlc2VudGluZyBhIGRvbWFpbiBuYW1lIG9yIGFuIGVtYWlsIGFkZHJlc3Ncblx0ICogdG8gVW5pY29kZS4gT25seSB0aGUgUHVueWNvZGVkIHBhcnRzIG9mIHRoZSBpbnB1dCB3aWxsIGJlIGNvbnZlcnRlZCwgaS5lLlxuXHQgKiBpdCBkb2Vzbid0IG1hdHRlciBpZiB5b3UgY2FsbCBpdCBvbiBhIHN0cmluZyB0aGF0IGhhcyBhbHJlYWR5IGJlZW5cblx0ICogY29udmVydGVkIHRvIFVuaWNvZGUuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIFB1bnljb2RlZCBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzIHRvXG5cdCAqIGNvbnZlcnQgdG8gVW5pY29kZS5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIFVuaWNvZGUgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIFB1bnljb2RlXG5cdCAqIHN0cmluZy5cblx0ICovXG5cdGZ1bmN0aW9uIHRvVW5pY29kZShpbnB1dCkge1xuXHRcdHJldHVybiBtYXBEb21haW4oaW5wdXQsIGZ1bmN0aW9uKHN0cmluZykge1xuXHRcdFx0cmV0dXJuIHJlZ2V4UHVueWNvZGUudGVzdChzdHJpbmcpXG5cdFx0XHRcdD8gZGVjb2RlKHN0cmluZy5zbGljZSg0KS50b0xvd2VyQ2FzZSgpKVxuXHRcdFx0XHQ6IHN0cmluZztcblx0XHR9KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIFVuaWNvZGUgc3RyaW5nIHJlcHJlc2VudGluZyBhIGRvbWFpbiBuYW1lIG9yIGFuIGVtYWlsIGFkZHJlc3MgdG9cblx0ICogUHVueWNvZGUuIE9ubHkgdGhlIG5vbi1BU0NJSSBwYXJ0cyBvZiB0aGUgZG9tYWluIG5hbWUgd2lsbCBiZSBjb252ZXJ0ZWQsXG5cdCAqIGkuZS4gaXQgZG9lc24ndCBtYXR0ZXIgaWYgeW91IGNhbGwgaXQgd2l0aCBhIGRvbWFpbiB0aGF0J3MgYWxyZWFkeSBpblxuXHQgKiBBU0NJSS5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcyB0byBjb252ZXJ0LCBhcyBhXG5cdCAqIFVuaWNvZGUgc3RyaW5nLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgUHVueWNvZGUgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIGRvbWFpbiBuYW1lIG9yXG5cdCAqIGVtYWlsIGFkZHJlc3MuXG5cdCAqL1xuXHRmdW5jdGlvbiB0b0FTQ0lJKGlucHV0KSB7XG5cdFx0cmV0dXJuIG1hcERvbWFpbihpbnB1dCwgZnVuY3Rpb24oc3RyaW5nKSB7XG5cdFx0XHRyZXR1cm4gcmVnZXhOb25BU0NJSS50ZXN0KHN0cmluZylcblx0XHRcdFx0PyAneG4tLScgKyBlbmNvZGUoc3RyaW5nKVxuXHRcdFx0XHQ6IHN0cmluZztcblx0XHR9KTtcblx0fVxuXG5cdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cdC8qKiBEZWZpbmUgdGhlIHB1YmxpYyBBUEkgKi9cblx0cHVueWNvZGUgPSB7XG5cdFx0LyoqXG5cdFx0ICogQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBjdXJyZW50IFB1bnljb2RlLmpzIHZlcnNpb24gbnVtYmVyLlxuXHRcdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHRcdCAqIEB0eXBlIFN0cmluZ1xuXHRcdCAqL1xuXHRcdCd2ZXJzaW9uJzogJzEuNC4xJyxcblx0XHQvKipcblx0XHQgKiBBbiBvYmplY3Qgb2YgbWV0aG9kcyB0byBjb252ZXJ0IGZyb20gSmF2YVNjcmlwdCdzIGludGVybmFsIGNoYXJhY3RlclxuXHRcdCAqIHJlcHJlc2VudGF0aW9uIChVQ1MtMikgdG8gVW5pY29kZSBjb2RlIHBvaW50cywgYW5kIGJhY2suXG5cdFx0ICogQHNlZSA8aHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmc+XG5cdFx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdFx0ICogQHR5cGUgT2JqZWN0XG5cdFx0ICovXG5cdFx0J3VjczInOiB7XG5cdFx0XHQnZGVjb2RlJzogdWNzMmRlY29kZSxcblx0XHRcdCdlbmNvZGUnOiB1Y3MyZW5jb2RlXG5cdFx0fSxcblx0XHQnZGVjb2RlJzogZGVjb2RlLFxuXHRcdCdlbmNvZGUnOiBlbmNvZGUsXG5cdFx0J3RvQVNDSUknOiB0b0FTQ0lJLFxuXHRcdCd0b1VuaWNvZGUnOiB0b1VuaWNvZGVcblx0fTtcblxuXHQvKiogRXhwb3NlIGBwdW55Y29kZWAgKi9cblx0Ly8gU29tZSBBTUQgYnVpbGQgb3B0aW1pemVycywgbGlrZSByLmpzLCBjaGVjayBmb3Igc3BlY2lmaWMgY29uZGl0aW9uIHBhdHRlcm5zXG5cdC8vIGxpa2UgdGhlIGZvbGxvd2luZzpcblx0aWYgKFxuXHRcdHR5cGVvZiBkZWZpbmUgPT0gJ2Z1bmN0aW9uJyAmJlxuXHRcdHR5cGVvZiBkZWZpbmUuYW1kID09ICdvYmplY3QnICYmXG5cdFx0ZGVmaW5lLmFtZFxuXHQpIHtcblx0XHRkZWZpbmUoJ3B1bnljb2RlJywgZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gcHVueWNvZGU7XG5cdFx0fSk7XG5cdH0gZWxzZSBpZiAoZnJlZUV4cG9ydHMgJiYgZnJlZU1vZHVsZSkge1xuXHRcdGlmIChtb2R1bGUuZXhwb3J0cyA9PSBmcmVlRXhwb3J0cykge1xuXHRcdFx0Ly8gaW4gTm9kZS5qcywgaW8uanMsIG9yIFJpbmdvSlMgdjAuOC4wK1xuXHRcdFx0ZnJlZU1vZHVsZS5leHBvcnRzID0gcHVueWNvZGU7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIGluIE5hcndoYWwgb3IgUmluZ29KUyB2MC43LjAtXG5cdFx0XHRmb3IgKGtleSBpbiBwdW55Y29kZSkge1xuXHRcdFx0XHRwdW55Y29kZS5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIChmcmVlRXhwb3J0c1trZXldID0gcHVueWNvZGVba2V5XSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdC8vIGluIFJoaW5vIG9yIGEgd2ViIGJyb3dzZXJcblx0XHRyb290LnB1bnljb2RlID0gcHVueWNvZGU7XG5cdH1cblxufSh0aGlzKSk7XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBJZiBvYmouaGFzT3duUHJvcGVydHkgaGFzIGJlZW4gb3ZlcnJpZGRlbiwgdGhlbiBjYWxsaW5nXG4vLyBvYmouaGFzT3duUHJvcGVydHkocHJvcCkgd2lsbCBicmVhay5cbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2pveWVudC9ub2RlL2lzc3Vlcy8xNzA3XG5mdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShvYmosIHByb3ApIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHFzLCBzZXAsIGVxLCBvcHRpb25zKSB7XG4gIHNlcCA9IHNlcCB8fCAnJic7XG4gIGVxID0gZXEgfHwgJz0nO1xuICB2YXIgb2JqID0ge307XG5cbiAgaWYgKHR5cGVvZiBxcyAhPT0gJ3N0cmluZycgfHwgcXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIHZhciByZWdleHAgPSAvXFwrL2c7XG4gIHFzID0gcXMuc3BsaXQoc2VwKTtcblxuICB2YXIgbWF4S2V5cyA9IDEwMDA7XG4gIGlmIChvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zLm1heEtleXMgPT09ICdudW1iZXInKSB7XG4gICAgbWF4S2V5cyA9IG9wdGlvbnMubWF4S2V5cztcbiAgfVxuXG4gIHZhciBsZW4gPSBxcy5sZW5ndGg7XG4gIC8vIG1heEtleXMgPD0gMCBtZWFucyB0aGF0IHdlIHNob3VsZCBub3QgbGltaXQga2V5cyBjb3VudFxuICBpZiAobWF4S2V5cyA+IDAgJiYgbGVuID4gbWF4S2V5cykge1xuICAgIGxlbiA9IG1heEtleXM7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgdmFyIHggPSBxc1tpXS5yZXBsYWNlKHJlZ2V4cCwgJyUyMCcpLFxuICAgICAgICBpZHggPSB4LmluZGV4T2YoZXEpLFxuICAgICAgICBrc3RyLCB2c3RyLCBrLCB2O1xuXG4gICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICBrc3RyID0geC5zdWJzdHIoMCwgaWR4KTtcbiAgICAgIHZzdHIgPSB4LnN1YnN0cihpZHggKyAxKTtcbiAgICB9IGVsc2Uge1xuICAgICAga3N0ciA9IHg7XG4gICAgICB2c3RyID0gJyc7XG4gICAgfVxuXG4gICAgayA9IGRlY29kZVVSSUNvbXBvbmVudChrc3RyKTtcbiAgICB2ID0gZGVjb2RlVVJJQ29tcG9uZW50KHZzdHIpO1xuXG4gICAgaWYgKCFoYXNPd25Qcm9wZXJ0eShvYmosIGspKSB7XG4gICAgICBvYmpba10gPSB2O1xuICAgIH0gZWxzZSBpZiAoaXNBcnJheShvYmpba10pKSB7XG4gICAgICBvYmpba10ucHVzaCh2KTtcbiAgICB9IGVsc2Uge1xuICAgICAgb2JqW2tdID0gW29ialtrXSwgdl07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9iajtcbn07XG5cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoeHMpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4cykgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHN0cmluZ2lmeVByaW1pdGl2ZSA9IGZ1bmN0aW9uKHYpIHtcbiAgc3dpdGNoICh0eXBlb2Ygdikge1xuICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICByZXR1cm4gdjtcblxuICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgcmV0dXJuIHYgPyAndHJ1ZScgOiAnZmFsc2UnO1xuXG4gICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgIHJldHVybiBpc0Zpbml0ZSh2KSA/IHYgOiAnJztcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gJyc7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob2JqLCBzZXAsIGVxLCBuYW1lKSB7XG4gIHNlcCA9IHNlcCB8fCAnJic7XG4gIGVxID0gZXEgfHwgJz0nO1xuICBpZiAob2JqID09PSBudWxsKSB7XG4gICAgb2JqID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBvYmogPT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIG1hcChvYmplY3RLZXlzKG9iaiksIGZ1bmN0aW9uKGspIHtcbiAgICAgIHZhciBrcyA9IGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUoaykpICsgZXE7XG4gICAgICBpZiAoaXNBcnJheShvYmpba10pKSB7XG4gICAgICAgIHJldHVybiBtYXAob2JqW2tdLCBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgcmV0dXJuIGtzICsgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZSh2KSk7XG4gICAgICAgIH0pLmpvaW4oc2VwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBrcyArIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUob2JqW2tdKSk7XG4gICAgICB9XG4gICAgfSkuam9pbihzZXApO1xuXG4gIH1cblxuICBpZiAoIW5hbWUpIHJldHVybiAnJztcbiAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUobmFtZSkpICsgZXEgK1xuICAgICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShvYmopKTtcbn07XG5cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoeHMpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4cykgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuXG5mdW5jdGlvbiBtYXAgKHhzLCBmKSB7XG4gIGlmICh4cy5tYXApIHJldHVybiB4cy5tYXAoZik7XG4gIHZhciByZXMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB4cy5sZW5ndGg7IGkrKykge1xuICAgIHJlcy5wdXNoKGYoeHNbaV0sIGkpKTtcbiAgfVxuICByZXR1cm4gcmVzO1xufVxuXG52YXIgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIChvYmopIHtcbiAgdmFyIHJlcyA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHJlcy5wdXNoKGtleSk7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuZGVjb2RlID0gZXhwb3J0cy5wYXJzZSA9IHJlcXVpcmUoJy4vZGVjb2RlJyk7XG5leHBvcnRzLmVuY29kZSA9IGV4cG9ydHMuc3RyaW5naWZ5ID0gcmVxdWlyZSgnLi9lbmNvZGUnKTtcbiIsIi8vIGEgZHVwbGV4IHN0cmVhbSBpcyBqdXN0IGEgc3RyZWFtIHRoYXQgaXMgYm90aCByZWFkYWJsZSBhbmQgd3JpdGFibGUuXG4vLyBTaW5jZSBKUyBkb2Vzbid0IGhhdmUgbXVsdGlwbGUgcHJvdG90eXBhbCBpbmhlcml0YW5jZSwgdGhpcyBjbGFzc1xuLy8gcHJvdG90eXBhbGx5IGluaGVyaXRzIGZyb20gUmVhZGFibGUsIGFuZCB0aGVuIHBhcmFzaXRpY2FsbHkgZnJvbVxuLy8gV3JpdGFibGUuXG5cbid1c2Ugc3RyaWN0JztcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIG9iamVjdEtleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiAob2JqKSB7XG4gIHZhciBrZXlzID0gW107XG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICBrZXlzLnB1c2goa2V5KTtcbiAgfXJldHVybiBrZXlzO1xufTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5tb2R1bGUuZXhwb3J0cyA9IER1cGxleDtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBwcm9jZXNzTmV4dFRpY2sgPSByZXF1aXJlKCdwcm9jZXNzLW5leHRpY2stYXJncycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIFJlYWRhYmxlID0gcmVxdWlyZSgnLi9fc3RyZWFtX3JlYWRhYmxlJyk7XG52YXIgV3JpdGFibGUgPSByZXF1aXJlKCcuL19zdHJlYW1fd3JpdGFibGUnKTtcblxudXRpbC5pbmhlcml0cyhEdXBsZXgsIFJlYWRhYmxlKTtcblxudmFyIGtleXMgPSBvYmplY3RLZXlzKFdyaXRhYmxlLnByb3RvdHlwZSk7XG5mb3IgKHZhciB2ID0gMDsgdiA8IGtleXMubGVuZ3RoOyB2KyspIHtcbiAgdmFyIG1ldGhvZCA9IGtleXNbdl07XG4gIGlmICghRHVwbGV4LnByb3RvdHlwZVttZXRob2RdKSBEdXBsZXgucHJvdG90eXBlW21ldGhvZF0gPSBXcml0YWJsZS5wcm90b3R5cGVbbWV0aG9kXTtcbn1cblxuZnVuY3Rpb24gRHVwbGV4KG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIER1cGxleCkpIHJldHVybiBuZXcgRHVwbGV4KG9wdGlvbnMpO1xuXG4gIFJlYWRhYmxlLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gIFdyaXRhYmxlLmNhbGwodGhpcywgb3B0aW9ucyk7XG5cbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5yZWFkYWJsZSA9PT0gZmFsc2UpIHRoaXMucmVhZGFibGUgPSBmYWxzZTtcblxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLndyaXRhYmxlID09PSBmYWxzZSkgdGhpcy53cml0YWJsZSA9IGZhbHNlO1xuXG4gIHRoaXMuYWxsb3dIYWxmT3BlbiA9IHRydWU7XG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMuYWxsb3dIYWxmT3BlbiA9PT0gZmFsc2UpIHRoaXMuYWxsb3dIYWxmT3BlbiA9IGZhbHNlO1xuXG4gIHRoaXMub25jZSgnZW5kJywgb25lbmQpO1xufVxuXG4vLyB0aGUgbm8taGFsZi1vcGVuIGVuZm9yY2VyXG5mdW5jdGlvbiBvbmVuZCgpIHtcbiAgLy8gaWYgd2UgYWxsb3cgaGFsZi1vcGVuIHN0YXRlLCBvciBpZiB0aGUgd3JpdGFibGUgc2lkZSBlbmRlZCxcbiAgLy8gdGhlbiB3ZSdyZSBvay5cbiAgaWYgKHRoaXMuYWxsb3dIYWxmT3BlbiB8fCB0aGlzLl93cml0YWJsZVN0YXRlLmVuZGVkKSByZXR1cm47XG5cbiAgLy8gbm8gbW9yZSBkYXRhIGNhbiBiZSB3cml0dGVuLlxuICAvLyBCdXQgYWxsb3cgbW9yZSB3cml0ZXMgdG8gaGFwcGVuIGluIHRoaXMgdGljay5cbiAgcHJvY2Vzc05leHRUaWNrKG9uRW5kTlQsIHRoaXMpO1xufVxuXG5mdW5jdGlvbiBvbkVuZE5UKHNlbGYpIHtcbiAgc2VsZi5lbmQoKTtcbn1cblxuZnVuY3Rpb24gZm9yRWFjaCh4cywgZikge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHhzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGYoeHNbaV0sIGkpO1xuICB9XG59IiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWRhYmxlO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHByb2Nlc3NOZXh0VGljayA9IHJlcXVpcmUoJ3Byb2Nlc3MtbmV4dGljay1hcmdzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnaXNhcnJheScpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgRHVwbGV4O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cblJlYWRhYmxlLlJlYWRhYmxlU3RhdGUgPSBSZWFkYWJsZVN0YXRlO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIEVFID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xuXG52YXIgRUVsaXN0ZW5lckNvdW50ID0gZnVuY3Rpb24gKGVtaXR0ZXIsIHR5cGUpIHtcbiAgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJzKHR5cGUpLmxlbmd0aDtcbn07XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBTdHJlYW07XG4oZnVuY3Rpb24gKCkge1xuICB0cnkge1xuICAgIFN0cmVhbSA9IHJlcXVpcmUoJ3N0JyArICdyZWFtJyk7XG4gIH0gY2F0Y2ggKF8pIHt9IGZpbmFsbHkge1xuICAgIGlmICghU3RyZWFtKSBTdHJlYW0gPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG4gIH1cbn0pKCk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlcjtcbi8qPHJlcGxhY2VtZW50PiovXG52YXIgYnVmZmVyU2hpbSA9IHJlcXVpcmUoJ2J1ZmZlci1zaGltcycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBkZWJ1Z1V0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG52YXIgZGVidWcgPSB2b2lkIDA7XG5pZiAoZGVidWdVdGlsICYmIGRlYnVnVXRpbC5kZWJ1Z2xvZykge1xuICBkZWJ1ZyA9IGRlYnVnVXRpbC5kZWJ1Z2xvZygnc3RyZWFtJyk7XG59IGVsc2Uge1xuICBkZWJ1ZyA9IGZ1bmN0aW9uICgpIHt9O1xufVxuLyo8L3JlcGxhY2VtZW50PiovXG5cbnZhciBCdWZmZXJMaXN0ID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL0J1ZmZlckxpc3QnKTtcbnZhciBTdHJpbmdEZWNvZGVyO1xuXG51dGlsLmluaGVyaXRzKFJlYWRhYmxlLCBTdHJlYW0pO1xuXG5mdW5jdGlvbiBwcmVwZW5kTGlzdGVuZXIoZW1pdHRlciwgZXZlbnQsIGZuKSB7XG4gIC8vIFNhZGx5IHRoaXMgaXMgbm90IGNhY2hlYWJsZSBhcyBzb21lIGxpYnJhcmllcyBidW5kbGUgdGhlaXIgb3duXG4gIC8vIGV2ZW50IGVtaXR0ZXIgaW1wbGVtZW50YXRpb24gd2l0aCB0aGVtLlxuICBpZiAodHlwZW9mIGVtaXR0ZXIucHJlcGVuZExpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGVtaXR0ZXIucHJlcGVuZExpc3RlbmVyKGV2ZW50LCBmbik7XG4gIH0gZWxzZSB7XG4gICAgLy8gVGhpcyBpcyBhIGhhY2sgdG8gbWFrZSBzdXJlIHRoYXQgb3VyIGVycm9yIGhhbmRsZXIgaXMgYXR0YWNoZWQgYmVmb3JlIGFueVxuICAgIC8vIHVzZXJsYW5kIG9uZXMuICBORVZFUiBETyBUSElTLiBUaGlzIGlzIGhlcmUgb25seSBiZWNhdXNlIHRoaXMgY29kZSBuZWVkc1xuICAgIC8vIHRvIGNvbnRpbnVlIHRvIHdvcmsgd2l0aCBvbGRlciB2ZXJzaW9ucyBvZiBOb2RlLmpzIHRoYXQgZG8gbm90IGluY2x1ZGVcbiAgICAvLyB0aGUgcHJlcGVuZExpc3RlbmVyKCkgbWV0aG9kLiBUaGUgZ29hbCBpcyB0byBldmVudHVhbGx5IHJlbW92ZSB0aGlzIGhhY2suXG4gICAgaWYgKCFlbWl0dGVyLl9ldmVudHMgfHwgIWVtaXR0ZXIuX2V2ZW50c1tldmVudF0pIGVtaXR0ZXIub24oZXZlbnQsIGZuKTtlbHNlIGlmIChpc0FycmF5KGVtaXR0ZXIuX2V2ZW50c1tldmVudF0pKSBlbWl0dGVyLl9ldmVudHNbZXZlbnRdLnVuc2hpZnQoZm4pO2Vsc2UgZW1pdHRlci5fZXZlbnRzW2V2ZW50XSA9IFtmbiwgZW1pdHRlci5fZXZlbnRzW2V2ZW50XV07XG4gIH1cbn1cblxuZnVuY3Rpb24gUmVhZGFibGVTdGF0ZShvcHRpb25zLCBzdHJlYW0pIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAvLyBvYmplY3Qgc3RyZWFtIGZsYWcuIFVzZWQgdG8gbWFrZSByZWFkKG4pIGlnbm9yZSBuIGFuZCB0b1xuICAvLyBtYWtlIGFsbCB0aGUgYnVmZmVyIG1lcmdpbmcgYW5kIGxlbmd0aCBjaGVja3MgZ28gYXdheVxuICB0aGlzLm9iamVjdE1vZGUgPSAhIW9wdGlvbnMub2JqZWN0TW9kZTtcblxuICBpZiAoc3RyZWFtIGluc3RhbmNlb2YgRHVwbGV4KSB0aGlzLm9iamVjdE1vZGUgPSB0aGlzLm9iamVjdE1vZGUgfHwgISFvcHRpb25zLnJlYWRhYmxlT2JqZWN0TW9kZTtcblxuICAvLyB0aGUgcG9pbnQgYXQgd2hpY2ggaXQgc3RvcHMgY2FsbGluZyBfcmVhZCgpIHRvIGZpbGwgdGhlIGJ1ZmZlclxuICAvLyBOb3RlOiAwIGlzIGEgdmFsaWQgdmFsdWUsIG1lYW5zIFwiZG9uJ3QgY2FsbCBfcmVhZCBwcmVlbXB0aXZlbHkgZXZlclwiXG4gIHZhciBod20gPSBvcHRpb25zLmhpZ2hXYXRlck1hcms7XG4gIHZhciBkZWZhdWx0SHdtID0gdGhpcy5vYmplY3RNb2RlID8gMTYgOiAxNiAqIDEwMjQ7XG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IGh3bSB8fCBod20gPT09IDAgPyBod20gOiBkZWZhdWx0SHdtO1xuXG4gIC8vIGNhc3QgdG8gaW50cy5cbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gfn50aGlzLmhpZ2hXYXRlck1hcms7XG5cbiAgLy8gQSBsaW5rZWQgbGlzdCBpcyB1c2VkIHRvIHN0b3JlIGRhdGEgY2h1bmtzIGluc3RlYWQgb2YgYW4gYXJyYXkgYmVjYXVzZSB0aGVcbiAgLy8gbGlua2VkIGxpc3QgY2FuIHJlbW92ZSBlbGVtZW50cyBmcm9tIHRoZSBiZWdpbm5pbmcgZmFzdGVyIHRoYW5cbiAgLy8gYXJyYXkuc2hpZnQoKVxuICB0aGlzLmJ1ZmZlciA9IG5ldyBCdWZmZXJMaXN0KCk7XG4gIHRoaXMubGVuZ3RoID0gMDtcbiAgdGhpcy5waXBlcyA9IG51bGw7XG4gIHRoaXMucGlwZXNDb3VudCA9IDA7XG4gIHRoaXMuZmxvd2luZyA9IG51bGw7XG4gIHRoaXMuZW5kZWQgPSBmYWxzZTtcbiAgdGhpcy5lbmRFbWl0dGVkID0gZmFsc2U7XG4gIHRoaXMucmVhZGluZyA9IGZhbHNlO1xuXG4gIC8vIGEgZmxhZyB0byBiZSBhYmxlIHRvIHRlbGwgaWYgdGhlIG9ud3JpdGUgY2IgaXMgY2FsbGVkIGltbWVkaWF0ZWx5LFxuICAvLyBvciBvbiBhIGxhdGVyIHRpY2suICBXZSBzZXQgdGhpcyB0byB0cnVlIGF0IGZpcnN0LCBiZWNhdXNlIGFueVxuICAvLyBhY3Rpb25zIHRoYXQgc2hvdWxkbid0IGhhcHBlbiB1bnRpbCBcImxhdGVyXCIgc2hvdWxkIGdlbmVyYWxseSBhbHNvXG4gIC8vIG5vdCBoYXBwZW4gYmVmb3JlIHRoZSBmaXJzdCB3cml0ZSBjYWxsLlxuICB0aGlzLnN5bmMgPSB0cnVlO1xuXG4gIC8vIHdoZW5ldmVyIHdlIHJldHVybiBudWxsLCB0aGVuIHdlIHNldCBhIGZsYWcgdG8gc2F5XG4gIC8vIHRoYXQgd2UncmUgYXdhaXRpbmcgYSAncmVhZGFibGUnIGV2ZW50IGVtaXNzaW9uLlxuICB0aGlzLm5lZWRSZWFkYWJsZSA9IGZhbHNlO1xuICB0aGlzLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuICB0aGlzLnJlYWRhYmxlTGlzdGVuaW5nID0gZmFsc2U7XG4gIHRoaXMucmVzdW1lU2NoZWR1bGVkID0gZmFsc2U7XG5cbiAgLy8gQ3J5cHRvIGlzIGtpbmQgb2Ygb2xkIGFuZCBjcnVzdHkuICBIaXN0b3JpY2FsbHksIGl0cyBkZWZhdWx0IHN0cmluZ1xuICAvLyBlbmNvZGluZyBpcyAnYmluYXJ5JyBzbyB3ZSBoYXZlIHRvIG1ha2UgdGhpcyBjb25maWd1cmFibGUuXG4gIC8vIEV2ZXJ5dGhpbmcgZWxzZSBpbiB0aGUgdW5pdmVyc2UgdXNlcyAndXRmOCcsIHRob3VnaC5cbiAgdGhpcy5kZWZhdWx0RW5jb2RpbmcgPSBvcHRpb25zLmRlZmF1bHRFbmNvZGluZyB8fCAndXRmOCc7XG5cbiAgLy8gd2hlbiBwaXBpbmcsIHdlIG9ubHkgY2FyZSBhYm91dCAncmVhZGFibGUnIGV2ZW50cyB0aGF0IGhhcHBlblxuICAvLyBhZnRlciByZWFkKClpbmcgYWxsIHRoZSBieXRlcyBhbmQgbm90IGdldHRpbmcgYW55IHB1c2hiYWNrLlxuICB0aGlzLnJhbk91dCA9IGZhbHNlO1xuXG4gIC8vIHRoZSBudW1iZXIgb2Ygd3JpdGVycyB0aGF0IGFyZSBhd2FpdGluZyBhIGRyYWluIGV2ZW50IGluIC5waXBlKClzXG4gIHRoaXMuYXdhaXREcmFpbiA9IDA7XG5cbiAgLy8gaWYgdHJ1ZSwgYSBtYXliZVJlYWRNb3JlIGhhcyBiZWVuIHNjaGVkdWxlZFxuICB0aGlzLnJlYWRpbmdNb3JlID0gZmFsc2U7XG5cbiAgdGhpcy5kZWNvZGVyID0gbnVsbDtcbiAgdGhpcy5lbmNvZGluZyA9IG51bGw7XG4gIGlmIChvcHRpb25zLmVuY29kaW5nKSB7XG4gICAgaWYgKCFTdHJpbmdEZWNvZGVyKSBTdHJpbmdEZWNvZGVyID0gcmVxdWlyZSgnc3RyaW5nX2RlY29kZXIvJykuU3RyaW5nRGVjb2RlcjtcbiAgICB0aGlzLmRlY29kZXIgPSBuZXcgU3RyaW5nRGVjb2RlcihvcHRpb25zLmVuY29kaW5nKTtcbiAgICB0aGlzLmVuY29kaW5nID0gb3B0aW9ucy5lbmNvZGluZztcbiAgfVxufVxuXG5mdW5jdGlvbiBSZWFkYWJsZShvcHRpb25zKSB7XG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJlYWRhYmxlKSkgcmV0dXJuIG5ldyBSZWFkYWJsZShvcHRpb25zKTtcblxuICB0aGlzLl9yZWFkYWJsZVN0YXRlID0gbmV3IFJlYWRhYmxlU3RhdGUob3B0aW9ucywgdGhpcyk7XG5cbiAgLy8gbGVnYWN5XG4gIHRoaXMucmVhZGFibGUgPSB0cnVlO1xuXG4gIGlmIChvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zLnJlYWQgPT09ICdmdW5jdGlvbicpIHRoaXMuX3JlYWQgPSBvcHRpb25zLnJlYWQ7XG5cbiAgU3RyZWFtLmNhbGwodGhpcyk7XG59XG5cbi8vIE1hbnVhbGx5IHNob3ZlIHNvbWV0aGluZyBpbnRvIHRoZSByZWFkKCkgYnVmZmVyLlxuLy8gVGhpcyByZXR1cm5zIHRydWUgaWYgdGhlIGhpZ2hXYXRlck1hcmsgaGFzIG5vdCBiZWVuIGhpdCB5ZXQsXG4vLyBzaW1pbGFyIHRvIGhvdyBXcml0YWJsZS53cml0ZSgpIHJldHVybnMgdHJ1ZSBpZiB5b3Ugc2hvdWxkXG4vLyB3cml0ZSgpIHNvbWUgbW9yZS5cblJlYWRhYmxlLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZykge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuXG4gIGlmICghc3RhdGUub2JqZWN0TW9kZSAmJiB0eXBlb2YgY2h1bmsgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBlbmNvZGluZyB8fCBzdGF0ZS5kZWZhdWx0RW5jb2Rpbmc7XG4gICAgaWYgKGVuY29kaW5nICE9PSBzdGF0ZS5lbmNvZGluZykge1xuICAgICAgY2h1bmsgPSBidWZmZXJTaGltLmZyb20oY2h1bmssIGVuY29kaW5nKTtcbiAgICAgIGVuY29kaW5nID0gJyc7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlYWRhYmxlQWRkQ2h1bmsodGhpcywgc3RhdGUsIGNodW5rLCBlbmNvZGluZywgZmFsc2UpO1xufTtcblxuLy8gVW5zaGlmdCBzaG91bGQgKmFsd2F5cyogYmUgc29tZXRoaW5nIGRpcmVjdGx5IG91dCBvZiByZWFkKClcblJlYWRhYmxlLnByb3RvdHlwZS51bnNoaWZ0ID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHJldHVybiByZWFkYWJsZUFkZENodW5rKHRoaXMsIHN0YXRlLCBjaHVuaywgJycsIHRydWUpO1xufTtcblxuUmVhZGFibGUucHJvdG90eXBlLmlzUGF1c2VkID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nID09PSBmYWxzZTtcbn07XG5cbmZ1bmN0aW9uIHJlYWRhYmxlQWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGVuY29kaW5nLCBhZGRUb0Zyb250KSB7XG4gIHZhciBlciA9IGNodW5rSW52YWxpZChzdGF0ZSwgY2h1bmspO1xuICBpZiAoZXIpIHtcbiAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gIH0gZWxzZSBpZiAoY2h1bmsgPT09IG51bGwpIHtcbiAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gICAgb25Fb2ZDaHVuayhzdHJlYW0sIHN0YXRlKTtcbiAgfSBlbHNlIGlmIChzdGF0ZS5vYmplY3RNb2RlIHx8IGNodW5rICYmIGNodW5rLmxlbmd0aCA+IDApIHtcbiAgICBpZiAoc3RhdGUuZW5kZWQgJiYgIWFkZFRvRnJvbnQpIHtcbiAgICAgIHZhciBlID0gbmV3IEVycm9yKCdzdHJlYW0ucHVzaCgpIGFmdGVyIEVPRicpO1xuICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZSk7XG4gICAgfSBlbHNlIGlmIChzdGF0ZS5lbmRFbWl0dGVkICYmIGFkZFRvRnJvbnQpIHtcbiAgICAgIHZhciBfZSA9IG5ldyBFcnJvcignc3RyZWFtLnVuc2hpZnQoKSBhZnRlciBlbmQgZXZlbnQnKTtcbiAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIF9lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHNraXBBZGQ7XG4gICAgICBpZiAoc3RhdGUuZGVjb2RlciAmJiAhYWRkVG9Gcm9udCAmJiAhZW5jb2RpbmcpIHtcbiAgICAgICAgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLndyaXRlKGNodW5rKTtcbiAgICAgICAgc2tpcEFkZCA9ICFzdGF0ZS5vYmplY3RNb2RlICYmIGNodW5rLmxlbmd0aCA9PT0gMDtcbiAgICAgIH1cblxuICAgICAgaWYgKCFhZGRUb0Zyb250KSBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG5cbiAgICAgIC8vIERvbid0IGFkZCB0byB0aGUgYnVmZmVyIGlmIHdlJ3ZlIGRlY29kZWQgdG8gYW4gZW1wdHkgc3RyaW5nIGNodW5rIGFuZFxuICAgICAgLy8gd2UncmUgbm90IGluIG9iamVjdCBtb2RlXG4gICAgICBpZiAoIXNraXBBZGQpIHtcbiAgICAgICAgLy8gaWYgd2Ugd2FudCB0aGUgZGF0YSBub3csIGp1c3QgZW1pdCBpdC5cbiAgICAgICAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgc3RhdGUubGVuZ3RoID09PSAwICYmICFzdGF0ZS5zeW5jKSB7XG4gICAgICAgICAgc3RyZWFtLmVtaXQoJ2RhdGEnLCBjaHVuayk7XG4gICAgICAgICAgc3RyZWFtLnJlYWQoMCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gdXBkYXRlIHRoZSBidWZmZXIgaW5mby5cbiAgICAgICAgICBzdGF0ZS5sZW5ndGggKz0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG4gICAgICAgICAgaWYgKGFkZFRvRnJvbnQpIHN0YXRlLmJ1ZmZlci51bnNoaWZ0KGNodW5rKTtlbHNlIHN0YXRlLmJ1ZmZlci5wdXNoKGNodW5rKTtcblxuICAgICAgICAgIGlmIChzdGF0ZS5uZWVkUmVhZGFibGUpIGVtaXRSZWFkYWJsZShzdHJlYW0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKCFhZGRUb0Zyb250KSB7XG4gICAgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIG5lZWRNb3JlRGF0YShzdGF0ZSk7XG59XG5cbi8vIGlmIGl0J3MgcGFzdCB0aGUgaGlnaCB3YXRlciBtYXJrLCB3ZSBjYW4gcHVzaCBpbiBzb21lIG1vcmUuXG4vLyBBbHNvLCBpZiB3ZSBoYXZlIG5vIGRhdGEgeWV0LCB3ZSBjYW4gc3RhbmQgc29tZVxuLy8gbW9yZSBieXRlcy4gIFRoaXMgaXMgdG8gd29yayBhcm91bmQgY2FzZXMgd2hlcmUgaHdtPTAsXG4vLyBzdWNoIGFzIHRoZSByZXBsLiAgQWxzbywgaWYgdGhlIHB1c2goKSB0cmlnZ2VyZWQgYVxuLy8gcmVhZGFibGUgZXZlbnQsIGFuZCB0aGUgdXNlciBjYWxsZWQgcmVhZChsYXJnZU51bWJlcikgc3VjaCB0aGF0XG4vLyBuZWVkUmVhZGFibGUgd2FzIHNldCwgdGhlbiB3ZSBvdWdodCB0byBwdXNoIG1vcmUsIHNvIHRoYXQgYW5vdGhlclxuLy8gJ3JlYWRhYmxlJyBldmVudCB3aWxsIGJlIHRyaWdnZXJlZC5cbmZ1bmN0aW9uIG5lZWRNb3JlRGF0YShzdGF0ZSkge1xuICByZXR1cm4gIXN0YXRlLmVuZGVkICYmIChzdGF0ZS5uZWVkUmVhZGFibGUgfHwgc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyayB8fCBzdGF0ZS5sZW5ndGggPT09IDApO1xufVxuXG4vLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cblJlYWRhYmxlLnByb3RvdHlwZS5zZXRFbmNvZGluZyA9IGZ1bmN0aW9uIChlbmMpIHtcbiAgaWYgKCFTdHJpbmdEZWNvZGVyKSBTdHJpbmdEZWNvZGVyID0gcmVxdWlyZSgnc3RyaW5nX2RlY29kZXIvJykuU3RyaW5nRGVjb2RlcjtcbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZWNvZGVyID0gbmV3IFN0cmluZ0RlY29kZXIoZW5jKTtcbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmNvZGluZyA9IGVuYztcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBEb24ndCByYWlzZSB0aGUgaHdtID4gOE1CXG52YXIgTUFYX0hXTSA9IDB4ODAwMDAwO1xuZnVuY3Rpb24gY29tcHV0ZU5ld0hpZ2hXYXRlck1hcmsobikge1xuICBpZiAobiA+PSBNQVhfSFdNKSB7XG4gICAgbiA9IE1BWF9IV007XG4gIH0gZWxzZSB7XG4gICAgLy8gR2V0IHRoZSBuZXh0IGhpZ2hlc3QgcG93ZXIgb2YgMiB0byBwcmV2ZW50IGluY3JlYXNpbmcgaHdtIGV4Y2Vzc2l2ZWx5IGluXG4gICAgLy8gdGlueSBhbW91bnRzXG4gICAgbi0tO1xuICAgIG4gfD0gbiA+Pj4gMTtcbiAgICBuIHw9IG4gPj4+IDI7XG4gICAgbiB8PSBuID4+PiA0O1xuICAgIG4gfD0gbiA+Pj4gODtcbiAgICBuIHw9IG4gPj4+IDE2O1xuICAgIG4rKztcbiAgfVxuICByZXR1cm4gbjtcbn1cblxuLy8gVGhpcyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBiZSBpbmxpbmFibGUsIHNvIHBsZWFzZSB0YWtlIGNhcmUgd2hlbiBtYWtpbmdcbi8vIGNoYW5nZXMgdG8gdGhlIGZ1bmN0aW9uIGJvZHkuXG5mdW5jdGlvbiBob3dNdWNoVG9SZWFkKG4sIHN0YXRlKSB7XG4gIGlmIChuIDw9IDAgfHwgc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmVuZGVkKSByZXR1cm4gMDtcbiAgaWYgKHN0YXRlLm9iamVjdE1vZGUpIHJldHVybiAxO1xuICBpZiAobiAhPT0gbikge1xuICAgIC8vIE9ubHkgZmxvdyBvbmUgYnVmZmVyIGF0IGEgdGltZVxuICAgIGlmIChzdGF0ZS5mbG93aW5nICYmIHN0YXRlLmxlbmd0aCkgcmV0dXJuIHN0YXRlLmJ1ZmZlci5oZWFkLmRhdGEubGVuZ3RoO2Vsc2UgcmV0dXJuIHN0YXRlLmxlbmd0aDtcbiAgfVxuICAvLyBJZiB3ZSdyZSBhc2tpbmcgZm9yIG1vcmUgdGhhbiB0aGUgY3VycmVudCBod20sIHRoZW4gcmFpc2UgdGhlIGh3bS5cbiAgaWYgKG4gPiBzdGF0ZS5oaWdoV2F0ZXJNYXJrKSBzdGF0ZS5oaWdoV2F0ZXJNYXJrID0gY29tcHV0ZU5ld0hpZ2hXYXRlck1hcmsobik7XG4gIGlmIChuIDw9IHN0YXRlLmxlbmd0aCkgcmV0dXJuIG47XG4gIC8vIERvbid0IGhhdmUgZW5vdWdoXG4gIGlmICghc3RhdGUuZW5kZWQpIHtcbiAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgIHJldHVybiAwO1xuICB9XG4gIHJldHVybiBzdGF0ZS5sZW5ndGg7XG59XG5cbi8vIHlvdSBjYW4gb3ZlcnJpZGUgZWl0aGVyIHRoaXMgbWV0aG9kLCBvciB0aGUgYXN5bmMgX3JlYWQobikgYmVsb3cuXG5SZWFkYWJsZS5wcm90b3R5cGUucmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gIGRlYnVnKCdyZWFkJywgbik7XG4gIG4gPSBwYXJzZUludChuLCAxMCk7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciBuT3JpZyA9IG47XG5cbiAgaWYgKG4gIT09IDApIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuXG4gIC8vIGlmIHdlJ3JlIGRvaW5nIHJlYWQoMCkgdG8gdHJpZ2dlciBhIHJlYWRhYmxlIGV2ZW50LCBidXQgd2VcbiAgLy8gYWxyZWFkeSBoYXZlIGEgYnVuY2ggb2YgZGF0YSBpbiB0aGUgYnVmZmVyLCB0aGVuIGp1c3QgdHJpZ2dlclxuICAvLyB0aGUgJ3JlYWRhYmxlJyBldmVudCBhbmQgbW92ZSBvbi5cbiAgaWYgKG4gPT09IDAgJiYgc3RhdGUubmVlZFJlYWRhYmxlICYmIChzdGF0ZS5sZW5ndGggPj0gc3RhdGUuaGlnaFdhdGVyTWFyayB8fCBzdGF0ZS5lbmRlZCkpIHtcbiAgICBkZWJ1ZygncmVhZDogZW1pdFJlYWRhYmxlJywgc3RhdGUubGVuZ3RoLCBzdGF0ZS5lbmRlZCk7XG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5lbmRlZCkgZW5kUmVhZGFibGUodGhpcyk7ZWxzZSBlbWl0UmVhZGFibGUodGhpcyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBuID0gaG93TXVjaFRvUmVhZChuLCBzdGF0ZSk7XG5cbiAgLy8gaWYgd2UndmUgZW5kZWQsIGFuZCB3ZSdyZSBub3cgY2xlYXIsIHRoZW4gZmluaXNoIGl0IHVwLlxuICBpZiAobiA9PT0gMCAmJiBzdGF0ZS5lbmRlZCkge1xuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIGVuZFJlYWRhYmxlKHRoaXMpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gQWxsIHRoZSBhY3R1YWwgY2h1bmsgZ2VuZXJhdGlvbiBsb2dpYyBuZWVkcyB0byBiZVxuICAvLyAqYmVsb3cqIHRoZSBjYWxsIHRvIF9yZWFkLiAgVGhlIHJlYXNvbiBpcyB0aGF0IGluIGNlcnRhaW5cbiAgLy8gc3ludGhldGljIHN0cmVhbSBjYXNlcywgc3VjaCBhcyBwYXNzdGhyb3VnaCBzdHJlYW1zLCBfcmVhZFxuICAvLyBtYXkgYmUgYSBjb21wbGV0ZWx5IHN5bmNocm9ub3VzIG9wZXJhdGlvbiB3aGljaCBtYXkgY2hhbmdlXG4gIC8vIHRoZSBzdGF0ZSBvZiB0aGUgcmVhZCBidWZmZXIsIHByb3ZpZGluZyBlbm91Z2ggZGF0YSB3aGVuXG4gIC8vIGJlZm9yZSB0aGVyZSB3YXMgKm5vdCogZW5vdWdoLlxuICAvL1xuICAvLyBTbywgdGhlIHN0ZXBzIGFyZTpcbiAgLy8gMS4gRmlndXJlIG91dCB3aGF0IHRoZSBzdGF0ZSBvZiB0aGluZ3Mgd2lsbCBiZSBhZnRlciB3ZSBkb1xuICAvLyBhIHJlYWQgZnJvbSB0aGUgYnVmZmVyLlxuICAvL1xuICAvLyAyLiBJZiB0aGF0IHJlc3VsdGluZyBzdGF0ZSB3aWxsIHRyaWdnZXIgYSBfcmVhZCwgdGhlbiBjYWxsIF9yZWFkLlxuICAvLyBOb3RlIHRoYXQgdGhpcyBtYXkgYmUgYXN5bmNocm9ub3VzLCBvciBzeW5jaHJvbm91cy4gIFllcywgaXQgaXNcbiAgLy8gZGVlcGx5IHVnbHkgdG8gd3JpdGUgQVBJcyB0aGlzIHdheSwgYnV0IHRoYXQgc3RpbGwgZG9lc24ndCBtZWFuXG4gIC8vIHRoYXQgdGhlIFJlYWRhYmxlIGNsYXNzIHNob3VsZCBiZWhhdmUgaW1wcm9wZXJseSwgYXMgc3RyZWFtcyBhcmVcbiAgLy8gZGVzaWduZWQgdG8gYmUgc3luYy9hc3luYyBhZ25vc3RpYy5cbiAgLy8gVGFrZSBub3RlIGlmIHRoZSBfcmVhZCBjYWxsIGlzIHN5bmMgb3IgYXN5bmMgKGllLCBpZiB0aGUgcmVhZCBjYWxsXG4gIC8vIGhhcyByZXR1cm5lZCB5ZXQpLCBzbyB0aGF0IHdlIGtub3cgd2hldGhlciBvciBub3QgaXQncyBzYWZlIHRvIGVtaXRcbiAgLy8gJ3JlYWRhYmxlJyBldGMuXG4gIC8vXG4gIC8vIDMuIEFjdHVhbGx5IHB1bGwgdGhlIHJlcXVlc3RlZCBjaHVua3Mgb3V0IG9mIHRoZSBidWZmZXIgYW5kIHJldHVybi5cblxuICAvLyBpZiB3ZSBuZWVkIGEgcmVhZGFibGUgZXZlbnQsIHRoZW4gd2UgbmVlZCB0byBkbyBzb21lIHJlYWRpbmcuXG4gIHZhciBkb1JlYWQgPSBzdGF0ZS5uZWVkUmVhZGFibGU7XG4gIGRlYnVnKCduZWVkIHJlYWRhYmxlJywgZG9SZWFkKTtcblxuICAvLyBpZiB3ZSBjdXJyZW50bHkgaGF2ZSBsZXNzIHRoYW4gdGhlIGhpZ2hXYXRlck1hcmssIHRoZW4gYWxzbyByZWFkIHNvbWVcbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCB8fCBzdGF0ZS5sZW5ndGggLSBuIDwgc3RhdGUuaGlnaFdhdGVyTWFyaykge1xuICAgIGRvUmVhZCA9IHRydWU7XG4gICAgZGVidWcoJ2xlbmd0aCBsZXNzIHRoYW4gd2F0ZXJtYXJrJywgZG9SZWFkKTtcbiAgfVxuXG4gIC8vIGhvd2V2ZXIsIGlmIHdlJ3ZlIGVuZGVkLCB0aGVuIHRoZXJlJ3Mgbm8gcG9pbnQsIGFuZCBpZiB3ZSdyZSBhbHJlYWR5XG4gIC8vIHJlYWRpbmcsIHRoZW4gaXQncyB1bm5lY2Vzc2FyeS5cbiAgaWYgKHN0YXRlLmVuZGVkIHx8IHN0YXRlLnJlYWRpbmcpIHtcbiAgICBkb1JlYWQgPSBmYWxzZTtcbiAgICBkZWJ1ZygncmVhZGluZyBvciBlbmRlZCcsIGRvUmVhZCk7XG4gIH0gZWxzZSBpZiAoZG9SZWFkKSB7XG4gICAgZGVidWcoJ2RvIHJlYWQnKTtcbiAgICBzdGF0ZS5yZWFkaW5nID0gdHJ1ZTtcbiAgICBzdGF0ZS5zeW5jID0gdHJ1ZTtcbiAgICAvLyBpZiB0aGUgbGVuZ3RoIGlzIGN1cnJlbnRseSB6ZXJvLCB0aGVuIHdlICpuZWVkKiBhIHJlYWRhYmxlIGV2ZW50LlxuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgLy8gY2FsbCBpbnRlcm5hbCByZWFkIG1ldGhvZFxuICAgIHRoaXMuX3JlYWQoc3RhdGUuaGlnaFdhdGVyTWFyayk7XG4gICAgc3RhdGUuc3luYyA9IGZhbHNlO1xuICAgIC8vIElmIF9yZWFkIHB1c2hlZCBkYXRhIHN5bmNocm9ub3VzbHksIHRoZW4gYHJlYWRpbmdgIHdpbGwgYmUgZmFsc2UsXG4gICAgLy8gYW5kIHdlIG5lZWQgdG8gcmUtZXZhbHVhdGUgaG93IG11Y2ggZGF0YSB3ZSBjYW4gcmV0dXJuIHRvIHRoZSB1c2VyLlxuICAgIGlmICghc3RhdGUucmVhZGluZykgbiA9IGhvd011Y2hUb1JlYWQobk9yaWcsIHN0YXRlKTtcbiAgfVxuXG4gIHZhciByZXQ7XG4gIGlmIChuID4gMCkgcmV0ID0gZnJvbUxpc3Qobiwgc3RhdGUpO2Vsc2UgcmV0ID0gbnVsbDtcblxuICBpZiAocmV0ID09PSBudWxsKSB7XG4gICAgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICBuID0gMDtcbiAgfSBlbHNlIHtcbiAgICBzdGF0ZS5sZW5ndGggLT0gbjtcbiAgfVxuXG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHtcbiAgICAvLyBJZiB3ZSBoYXZlIG5vdGhpbmcgaW4gdGhlIGJ1ZmZlciwgdGhlbiB3ZSB3YW50IHRvIGtub3dcbiAgICAvLyBhcyBzb29uIGFzIHdlICpkbyogZ2V0IHNvbWV0aGluZyBpbnRvIHRoZSBidWZmZXIuXG4gICAgaWYgKCFzdGF0ZS5lbmRlZCkgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcblxuICAgIC8vIElmIHdlIHRyaWVkIHRvIHJlYWQoKSBwYXN0IHRoZSBFT0YsIHRoZW4gZW1pdCBlbmQgb24gdGhlIG5leHQgdGljay5cbiAgICBpZiAobk9yaWcgIT09IG4gJiYgc3RhdGUuZW5kZWQpIGVuZFJlYWRhYmxlKHRoaXMpO1xuICB9XG5cbiAgaWYgKHJldCAhPT0gbnVsbCkgdGhpcy5lbWl0KCdkYXRhJywgcmV0KTtcblxuICByZXR1cm4gcmV0O1xufTtcblxuZnVuY3Rpb24gY2h1bmtJbnZhbGlkKHN0YXRlLCBjaHVuaykge1xuICB2YXIgZXIgPSBudWxsO1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihjaHVuaykgJiYgdHlwZW9mIGNodW5rICE9PSAnc3RyaW5nJyAmJiBjaHVuayAhPT0gbnVsbCAmJiBjaHVuayAhPT0gdW5kZWZpbmVkICYmICFzdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgZXIgPSBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIG5vbi1zdHJpbmcvYnVmZmVyIGNodW5rJyk7XG4gIH1cbiAgcmV0dXJuIGVyO1xufVxuXG5mdW5jdGlvbiBvbkVvZkNodW5rKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKHN0YXRlLmVuZGVkKSByZXR1cm47XG4gIGlmIChzdGF0ZS5kZWNvZGVyKSB7XG4gICAgdmFyIGNodW5rID0gc3RhdGUuZGVjb2Rlci5lbmQoKTtcbiAgICBpZiAoY2h1bmsgJiYgY2h1bmsubGVuZ3RoKSB7XG4gICAgICBzdGF0ZS5idWZmZXIucHVzaChjaHVuayk7XG4gICAgICBzdGF0ZS5sZW5ndGggKz0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG4gICAgfVxuICB9XG4gIHN0YXRlLmVuZGVkID0gdHJ1ZTtcblxuICAvLyBlbWl0ICdyZWFkYWJsZScgbm93IHRvIG1ha2Ugc3VyZSBpdCBnZXRzIHBpY2tlZCB1cC5cbiAgZW1pdFJlYWRhYmxlKHN0cmVhbSk7XG59XG5cbi8vIERvbid0IGVtaXQgcmVhZGFibGUgcmlnaHQgYXdheSBpbiBzeW5jIG1vZGUsIGJlY2F1c2UgdGhpcyBjYW4gdHJpZ2dlclxuLy8gYW5vdGhlciByZWFkKCkgY2FsbCA9PiBzdGFjayBvdmVyZmxvdy4gIFRoaXMgd2F5LCBpdCBtaWdodCB0cmlnZ2VyXG4vLyBhIG5leHRUaWNrIHJlY3Vyc2lvbiB3YXJuaW5nLCBidXQgdGhhdCdzIG5vdCBzbyBiYWQuXG5mdW5jdGlvbiBlbWl0UmVhZGFibGUoc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgc3RhdGUubmVlZFJlYWRhYmxlID0gZmFsc2U7XG4gIGlmICghc3RhdGUuZW1pdHRlZFJlYWRhYmxlKSB7XG4gICAgZGVidWcoJ2VtaXRSZWFkYWJsZScsIHN0YXRlLmZsb3dpbmcpO1xuICAgIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgaWYgKHN0YXRlLnN5bmMpIHByb2Nlc3NOZXh0VGljayhlbWl0UmVhZGFibGVfLCBzdHJlYW0pO2Vsc2UgZW1pdFJlYWRhYmxlXyhzdHJlYW0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVtaXRSZWFkYWJsZV8oc3RyZWFtKSB7XG4gIGRlYnVnKCdlbWl0IHJlYWRhYmxlJyk7XG4gIHN0cmVhbS5lbWl0KCdyZWFkYWJsZScpO1xuICBmbG93KHN0cmVhbSk7XG59XG5cbi8vIGF0IHRoaXMgcG9pbnQsIHRoZSB1c2VyIGhhcyBwcmVzdW1hYmx5IHNlZW4gdGhlICdyZWFkYWJsZScgZXZlbnQsXG4vLyBhbmQgY2FsbGVkIHJlYWQoKSB0byBjb25zdW1lIHNvbWUgZGF0YS4gIHRoYXQgbWF5IGhhdmUgdHJpZ2dlcmVkXG4vLyBpbiB0dXJuIGFub3RoZXIgX3JlYWQobikgY2FsbCwgaW4gd2hpY2ggY2FzZSByZWFkaW5nID0gdHJ1ZSBpZlxuLy8gaXQncyBpbiBwcm9ncmVzcy5cbi8vIEhvd2V2ZXIsIGlmIHdlJ3JlIG5vdCBlbmRlZCwgb3IgcmVhZGluZywgYW5kIHRoZSBsZW5ndGggPCBod20sXG4vLyB0aGVuIGdvIGFoZWFkIGFuZCB0cnkgdG8gcmVhZCBzb21lIG1vcmUgcHJlZW1wdGl2ZWx5LlxuZnVuY3Rpb24gbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucmVhZGluZ01vcmUpIHtcbiAgICBzdGF0ZS5yZWFkaW5nTW9yZSA9IHRydWU7XG4gICAgcHJvY2Vzc05leHRUaWNrKG1heWJlUmVhZE1vcmVfLCBzdHJlYW0sIHN0YXRlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXliZVJlYWRNb3JlXyhzdHJlYW0sIHN0YXRlKSB7XG4gIHZhciBsZW4gPSBzdGF0ZS5sZW5ndGg7XG4gIHdoaWxlICghc3RhdGUucmVhZGluZyAmJiAhc3RhdGUuZmxvd2luZyAmJiAhc3RhdGUuZW5kZWQgJiYgc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyaykge1xuICAgIGRlYnVnKCdtYXliZVJlYWRNb3JlIHJlYWQgMCcpO1xuICAgIHN0cmVhbS5yZWFkKDApO1xuICAgIGlmIChsZW4gPT09IHN0YXRlLmxlbmd0aClcbiAgICAgIC8vIGRpZG4ndCBnZXQgYW55IGRhdGEsIHN0b3Agc3Bpbm5pbmcuXG4gICAgICBicmVhaztlbHNlIGxlbiA9IHN0YXRlLmxlbmd0aDtcbiAgfVxuICBzdGF0ZS5yZWFkaW5nTW9yZSA9IGZhbHNlO1xufVxuXG4vLyBhYnN0cmFjdCBtZXRob2QuICB0byBiZSBvdmVycmlkZGVuIGluIHNwZWNpZmljIGltcGxlbWVudGF0aW9uIGNsYXNzZXMuXG4vLyBjYWxsIGNiKGVyLCBkYXRhKSB3aGVyZSBkYXRhIGlzIDw9IG4gaW4gbGVuZ3RoLlxuLy8gZm9yIHZpcnR1YWwgKG5vbi1zdHJpbmcsIG5vbi1idWZmZXIpIHN0cmVhbXMsIFwibGVuZ3RoXCIgaXMgc29tZXdoYXRcbi8vIGFyYml0cmFyeSwgYW5kIHBlcmhhcHMgbm90IHZlcnkgbWVhbmluZ2Z1bC5cblJlYWRhYmxlLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ19yZWFkKCkgaXMgbm90IGltcGxlbWVudGVkJykpO1xufTtcblxuUmVhZGFibGUucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbiAoZGVzdCwgcGlwZU9wdHMpIHtcbiAgdmFyIHNyYyA9IHRoaXM7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG5cbiAgc3dpdGNoIChzdGF0ZS5waXBlc0NvdW50KSB7XG4gICAgY2FzZSAwOlxuICAgICAgc3RhdGUucGlwZXMgPSBkZXN0O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAxOlxuICAgICAgc3RhdGUucGlwZXMgPSBbc3RhdGUucGlwZXMsIGRlc3RdO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHN0YXRlLnBpcGVzLnB1c2goZGVzdCk7XG4gICAgICBicmVhaztcbiAgfVxuICBzdGF0ZS5waXBlc0NvdW50ICs9IDE7XG4gIGRlYnVnKCdwaXBlIGNvdW50PSVkIG9wdHM9JWonLCBzdGF0ZS5waXBlc0NvdW50LCBwaXBlT3B0cyk7XG5cbiAgdmFyIGRvRW5kID0gKCFwaXBlT3B0cyB8fCBwaXBlT3B0cy5lbmQgIT09IGZhbHNlKSAmJiBkZXN0ICE9PSBwcm9jZXNzLnN0ZG91dCAmJiBkZXN0ICE9PSBwcm9jZXNzLnN0ZGVycjtcblxuICB2YXIgZW5kRm4gPSBkb0VuZCA/IG9uZW5kIDogY2xlYW51cDtcbiAgaWYgKHN0YXRlLmVuZEVtaXR0ZWQpIHByb2Nlc3NOZXh0VGljayhlbmRGbik7ZWxzZSBzcmMub25jZSgnZW5kJywgZW5kRm4pO1xuXG4gIGRlc3Qub24oJ3VucGlwZScsIG9udW5waXBlKTtcbiAgZnVuY3Rpb24gb251bnBpcGUocmVhZGFibGUpIHtcbiAgICBkZWJ1Zygnb251bnBpcGUnKTtcbiAgICBpZiAocmVhZGFibGUgPT09IHNyYykge1xuICAgICAgY2xlYW51cCgpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uZW5kKCkge1xuICAgIGRlYnVnKCdvbmVuZCcpO1xuICAgIGRlc3QuZW5kKCk7XG4gIH1cblxuICAvLyB3aGVuIHRoZSBkZXN0IGRyYWlucywgaXQgcmVkdWNlcyB0aGUgYXdhaXREcmFpbiBjb3VudGVyXG4gIC8vIG9uIHRoZSBzb3VyY2UuICBUaGlzIHdvdWxkIGJlIG1vcmUgZWxlZ2FudCB3aXRoIGEgLm9uY2UoKVxuICAvLyBoYW5kbGVyIGluIGZsb3coKSwgYnV0IGFkZGluZyBhbmQgcmVtb3ZpbmcgcmVwZWF0ZWRseSBpc1xuICAvLyB0b28gc2xvdy5cbiAgdmFyIG9uZHJhaW4gPSBwaXBlT25EcmFpbihzcmMpO1xuICBkZXN0Lm9uKCdkcmFpbicsIG9uZHJhaW4pO1xuXG4gIHZhciBjbGVhbmVkVXAgPSBmYWxzZTtcbiAgZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICBkZWJ1ZygnY2xlYW51cCcpO1xuICAgIC8vIGNsZWFudXAgZXZlbnQgaGFuZGxlcnMgb25jZSB0aGUgcGlwZSBpcyBicm9rZW5cbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdkcmFpbicsIG9uZHJhaW4pO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcigndW5waXBlJywgb251bnBpcGUpO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25lbmQpO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZW5kJywgY2xlYW51cCk7XG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgb25kYXRhKTtcblxuICAgIGNsZWFuZWRVcCA9IHRydWU7XG5cbiAgICAvLyBpZiB0aGUgcmVhZGVyIGlzIHdhaXRpbmcgZm9yIGEgZHJhaW4gZXZlbnQgZnJvbSB0aGlzXG4gICAgLy8gc3BlY2lmaWMgd3JpdGVyLCB0aGVuIGl0IHdvdWxkIGNhdXNlIGl0IHRvIG5ldmVyIHN0YXJ0XG4gICAgLy8gZmxvd2luZyBhZ2Fpbi5cbiAgICAvLyBTbywgaWYgdGhpcyBpcyBhd2FpdGluZyBhIGRyYWluLCB0aGVuIHdlIGp1c3QgY2FsbCBpdCBub3cuXG4gICAgLy8gSWYgd2UgZG9uJ3Qga25vdywgdGhlbiBhc3N1bWUgdGhhdCB3ZSBhcmUgd2FpdGluZyBmb3Igb25lLlxuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluICYmICghZGVzdC5fd3JpdGFibGVTdGF0ZSB8fCBkZXN0Ll93cml0YWJsZVN0YXRlLm5lZWREcmFpbikpIG9uZHJhaW4oKTtcbiAgfVxuXG4gIC8vIElmIHRoZSB1c2VyIHB1c2hlcyBtb3JlIGRhdGEgd2hpbGUgd2UncmUgd3JpdGluZyB0byBkZXN0IHRoZW4gd2UnbGwgZW5kIHVwXG4gIC8vIGluIG9uZGF0YSBhZ2Fpbi4gSG93ZXZlciwgd2Ugb25seSB3YW50IHRvIGluY3JlYXNlIGF3YWl0RHJhaW4gb25jZSBiZWNhdXNlXG4gIC8vIGRlc3Qgd2lsbCBvbmx5IGVtaXQgb25lICdkcmFpbicgZXZlbnQgZm9yIHRoZSBtdWx0aXBsZSB3cml0ZXMuXG4gIC8vID0+IEludHJvZHVjZSBhIGd1YXJkIG9uIGluY3JlYXNpbmcgYXdhaXREcmFpbi5cbiAgdmFyIGluY3JlYXNlZEF3YWl0RHJhaW4gPSBmYWxzZTtcbiAgc3JjLm9uKCdkYXRhJywgb25kYXRhKTtcbiAgZnVuY3Rpb24gb25kYXRhKGNodW5rKSB7XG4gICAgZGVidWcoJ29uZGF0YScpO1xuICAgIGluY3JlYXNlZEF3YWl0RHJhaW4gPSBmYWxzZTtcbiAgICB2YXIgcmV0ID0gZGVzdC53cml0ZShjaHVuayk7XG4gICAgaWYgKGZhbHNlID09PSByZXQgJiYgIWluY3JlYXNlZEF3YWl0RHJhaW4pIHtcbiAgICAgIC8vIElmIHRoZSB1c2VyIHVucGlwZWQgZHVyaW5nIGBkZXN0LndyaXRlKClgLCBpdCBpcyBwb3NzaWJsZVxuICAgICAgLy8gdG8gZ2V0IHN0dWNrIGluIGEgcGVybWFuZW50bHkgcGF1c2VkIHN0YXRlIGlmIHRoYXQgd3JpdGVcbiAgICAgIC8vIGFsc28gcmV0dXJuZWQgZmFsc2UuXG4gICAgICAvLyA9PiBDaGVjayB3aGV0aGVyIGBkZXN0YCBpcyBzdGlsbCBhIHBpcGluZyBkZXN0aW5hdGlvbi5cbiAgICAgIGlmICgoc3RhdGUucGlwZXNDb3VudCA9PT0gMSAmJiBzdGF0ZS5waXBlcyA9PT0gZGVzdCB8fCBzdGF0ZS5waXBlc0NvdW50ID4gMSAmJiBpbmRleE9mKHN0YXRlLnBpcGVzLCBkZXN0KSAhPT0gLTEpICYmICFjbGVhbmVkVXApIHtcbiAgICAgICAgZGVidWcoJ2ZhbHNlIHdyaXRlIHJlc3BvbnNlLCBwYXVzZScsIHNyYy5fcmVhZGFibGVTdGF0ZS5hd2FpdERyYWluKTtcbiAgICAgICAgc3JjLl9yZWFkYWJsZVN0YXRlLmF3YWl0RHJhaW4rKztcbiAgICAgICAgaW5jcmVhc2VkQXdhaXREcmFpbiA9IHRydWU7XG4gICAgICB9XG4gICAgICBzcmMucGF1c2UoKTtcbiAgICB9XG4gIH1cblxuICAvLyBpZiB0aGUgZGVzdCBoYXMgYW4gZXJyb3IsIHRoZW4gc3RvcCBwaXBpbmcgaW50byBpdC5cbiAgLy8gaG93ZXZlciwgZG9uJ3Qgc3VwcHJlc3MgdGhlIHRocm93aW5nIGJlaGF2aW9yIGZvciB0aGlzLlxuICBmdW5jdGlvbiBvbmVycm9yKGVyKSB7XG4gICAgZGVidWcoJ29uZXJyb3InLCBlcik7XG4gICAgdW5waXBlKCk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcbiAgICBpZiAoRUVsaXN0ZW5lckNvdW50KGRlc3QsICdlcnJvcicpID09PSAwKSBkZXN0LmVtaXQoJ2Vycm9yJywgZXIpO1xuICB9XG5cbiAgLy8gTWFrZSBzdXJlIG91ciBlcnJvciBoYW5kbGVyIGlzIGF0dGFjaGVkIGJlZm9yZSB1c2VybGFuZCBvbmVzLlxuICBwcmVwZW5kTGlzdGVuZXIoZGVzdCwgJ2Vycm9yJywgb25lcnJvcik7XG5cbiAgLy8gQm90aCBjbG9zZSBhbmQgZmluaXNoIHNob3VsZCB0cmlnZ2VyIHVucGlwZSwgYnV0IG9ubHkgb25jZS5cbiAgZnVuY3Rpb24gb25jbG9zZSgpIHtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG4gICAgdW5waXBlKCk7XG4gIH1cbiAgZGVzdC5vbmNlKCdjbG9zZScsIG9uY2xvc2UpO1xuICBmdW5jdGlvbiBvbmZpbmlzaCgpIHtcbiAgICBkZWJ1Zygnb25maW5pc2gnKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuICAgIHVucGlwZSgpO1xuICB9XG4gIGRlc3Qub25jZSgnZmluaXNoJywgb25maW5pc2gpO1xuXG4gIGZ1bmN0aW9uIHVucGlwZSgpIHtcbiAgICBkZWJ1ZygndW5waXBlJyk7XG4gICAgc3JjLnVucGlwZShkZXN0KTtcbiAgfVxuXG4gIC8vIHRlbGwgdGhlIGRlc3QgdGhhdCBpdCdzIGJlaW5nIHBpcGVkIHRvXG4gIGRlc3QuZW1pdCgncGlwZScsIHNyYyk7XG5cbiAgLy8gc3RhcnQgdGhlIGZsb3cgaWYgaXQgaGFzbid0IGJlZW4gc3RhcnRlZCBhbHJlYWR5LlxuICBpZiAoIXN0YXRlLmZsb3dpbmcpIHtcbiAgICBkZWJ1ZygncGlwZSByZXN1bWUnKTtcbiAgICBzcmMucmVzdW1lKCk7XG4gIH1cblxuICByZXR1cm4gZGVzdDtcbn07XG5cbmZ1bmN0aW9uIHBpcGVPbkRyYWluKHNyYykge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzdGF0ZSA9IHNyYy5fcmVhZGFibGVTdGF0ZTtcbiAgICBkZWJ1ZygncGlwZU9uRHJhaW4nLCBzdGF0ZS5hd2FpdERyYWluKTtcbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbikgc3RhdGUuYXdhaXREcmFpbi0tO1xuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluID09PSAwICYmIEVFbGlzdGVuZXJDb3VudChzcmMsICdkYXRhJykpIHtcbiAgICAgIHN0YXRlLmZsb3dpbmcgPSB0cnVlO1xuICAgICAgZmxvdyhzcmMpO1xuICAgIH1cbiAgfTtcbn1cblxuUmVhZGFibGUucHJvdG90eXBlLnVucGlwZSA9IGZ1bmN0aW9uIChkZXN0KSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG5cbiAgLy8gaWYgd2UncmUgbm90IHBpcGluZyBhbnl3aGVyZSwgdGhlbiBkbyBub3RoaW5nLlxuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMCkgcmV0dXJuIHRoaXM7XG5cbiAgLy8ganVzdCBvbmUgZGVzdGluYXRpb24uICBtb3N0IGNvbW1vbiBjYXNlLlxuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMSkge1xuICAgIC8vIHBhc3NlZCBpbiBvbmUsIGJ1dCBpdCdzIG5vdCB0aGUgcmlnaHQgb25lLlxuICAgIGlmIChkZXN0ICYmIGRlc3QgIT09IHN0YXRlLnBpcGVzKSByZXR1cm4gdGhpcztcblxuICAgIGlmICghZGVzdCkgZGVzdCA9IHN0YXRlLnBpcGVzO1xuXG4gICAgLy8gZ290IGEgbWF0Y2guXG4gICAgc3RhdGUucGlwZXMgPSBudWxsO1xuICAgIHN0YXRlLnBpcGVzQ291bnQgPSAwO1xuICAgIHN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcbiAgICBpZiAoZGVzdCkgZGVzdC5lbWl0KCd1bnBpcGUnLCB0aGlzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHNsb3cgY2FzZS4gbXVsdGlwbGUgcGlwZSBkZXN0aW5hdGlvbnMuXG5cbiAgaWYgKCFkZXN0KSB7XG4gICAgLy8gcmVtb3ZlIGFsbC5cbiAgICB2YXIgZGVzdHMgPSBzdGF0ZS5waXBlcztcbiAgICB2YXIgbGVuID0gc3RhdGUucGlwZXNDb3VudDtcbiAgICBzdGF0ZS5waXBlcyA9IG51bGw7XG4gICAgc3RhdGUucGlwZXNDb3VudCA9IDA7XG4gICAgc3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgZGVzdHNbaV0uZW1pdCgndW5waXBlJywgdGhpcyk7XG4gICAgfXJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gdHJ5IHRvIGZpbmQgdGhlIHJpZ2h0IG9uZS5cbiAgdmFyIGluZGV4ID0gaW5kZXhPZihzdGF0ZS5waXBlcywgZGVzdCk7XG4gIGlmIChpbmRleCA9PT0gLTEpIHJldHVybiB0aGlzO1xuXG4gIHN0YXRlLnBpcGVzLnNwbGljZShpbmRleCwgMSk7XG4gIHN0YXRlLnBpcGVzQ291bnQgLT0gMTtcbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDEpIHN0YXRlLnBpcGVzID0gc3RhdGUucGlwZXNbMF07XG5cbiAgZGVzdC5lbWl0KCd1bnBpcGUnLCB0aGlzKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIHNldCB1cCBkYXRhIGV2ZW50cyBpZiB0aGV5IGFyZSBhc2tlZCBmb3Jcbi8vIEVuc3VyZSByZWFkYWJsZSBsaXN0ZW5lcnMgZXZlbnR1YWxseSBnZXQgc29tZXRoaW5nXG5SZWFkYWJsZS5wcm90b3R5cGUub24gPSBmdW5jdGlvbiAoZXYsIGZuKSB7XG4gIHZhciByZXMgPSBTdHJlYW0ucHJvdG90eXBlLm9uLmNhbGwodGhpcywgZXYsIGZuKTtcblxuICBpZiAoZXYgPT09ICdkYXRhJykge1xuICAgIC8vIFN0YXJ0IGZsb3dpbmcgb24gbmV4dCB0aWNrIGlmIHN0cmVhbSBpc24ndCBleHBsaWNpdGx5IHBhdXNlZFxuICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgIT09IGZhbHNlKSB0aGlzLnJlc3VtZSgpO1xuICB9IGVsc2UgaWYgKGV2ID09PSAncmVhZGFibGUnKSB7XG4gICAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQgJiYgIXN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nKSB7XG4gICAgICBzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZyA9IHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcbiAgICAgIGlmICghc3RhdGUucmVhZGluZykge1xuICAgICAgICBwcm9jZXNzTmV4dFRpY2soblJlYWRpbmdOZXh0VGljaywgdGhpcyk7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlLmxlbmd0aCkge1xuICAgICAgICBlbWl0UmVhZGFibGUodGhpcywgc3RhdGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXM7XG59O1xuUmVhZGFibGUucHJvdG90eXBlLmFkZExpc3RlbmVyID0gUmVhZGFibGUucHJvdG90eXBlLm9uO1xuXG5mdW5jdGlvbiBuUmVhZGluZ05leHRUaWNrKHNlbGYpIHtcbiAgZGVidWcoJ3JlYWRhYmxlIG5leHR0aWNrIHJlYWQgMCcpO1xuICBzZWxmLnJlYWQoMCk7XG59XG5cbi8vIHBhdXNlKCkgYW5kIHJlc3VtZSgpIGFyZSByZW1uYW50cyBvZiB0aGUgbGVnYWN5IHJlYWRhYmxlIHN0cmVhbSBBUElcbi8vIElmIHRoZSB1c2VyIHVzZXMgdGhlbSwgdGhlbiBzd2l0Y2ggaW50byBvbGQgbW9kZS5cblJlYWRhYmxlLnByb3RvdHlwZS5yZXN1bWUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIGlmICghc3RhdGUuZmxvd2luZykge1xuICAgIGRlYnVnKCdyZXN1bWUnKTtcbiAgICBzdGF0ZS5mbG93aW5nID0gdHJ1ZTtcbiAgICByZXN1bWUodGhpcywgc3RhdGUpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gcmVzdW1lKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5yZXN1bWVTY2hlZHVsZWQpIHtcbiAgICBzdGF0ZS5yZXN1bWVTY2hlZHVsZWQgPSB0cnVlO1xuICAgIHByb2Nlc3NOZXh0VGljayhyZXN1bWVfLCBzdHJlYW0sIHN0YXRlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXN1bWVfKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5yZWFkaW5nKSB7XG4gICAgZGVidWcoJ3Jlc3VtZSByZWFkIDAnKTtcbiAgICBzdHJlYW0ucmVhZCgwKTtcbiAgfVxuXG4gIHN0YXRlLnJlc3VtZVNjaGVkdWxlZCA9IGZhbHNlO1xuICBzdGF0ZS5hd2FpdERyYWluID0gMDtcbiAgc3RyZWFtLmVtaXQoJ3Jlc3VtZScpO1xuICBmbG93KHN0cmVhbSk7XG4gIGlmIChzdGF0ZS5mbG93aW5nICYmICFzdGF0ZS5yZWFkaW5nKSBzdHJlYW0ucmVhZCgwKTtcbn1cblxuUmVhZGFibGUucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24gKCkge1xuICBkZWJ1ZygnY2FsbCBwYXVzZSBmbG93aW5nPSVqJywgdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nKTtcbiAgaWYgKGZhbHNlICE9PSB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcpIHtcbiAgICBkZWJ1ZygncGF1c2UnKTtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcbiAgICB0aGlzLmVtaXQoJ3BhdXNlJyk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiBmbG93KHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIGRlYnVnKCdmbG93Jywgc3RhdGUuZmxvd2luZyk7XG4gIHdoaWxlIChzdGF0ZS5mbG93aW5nICYmIHN0cmVhbS5yZWFkKCkgIT09IG51bGwpIHt9XG59XG5cbi8vIHdyYXAgYW4gb2xkLXN0eWxlIHN0cmVhbSBhcyB0aGUgYXN5bmMgZGF0YSBzb3VyY2UuXG4vLyBUaGlzIGlzICpub3QqIHBhcnQgb2YgdGhlIHJlYWRhYmxlIHN0cmVhbSBpbnRlcmZhY2UuXG4vLyBJdCBpcyBhbiB1Z2x5IHVuZm9ydHVuYXRlIG1lc3Mgb2YgaGlzdG9yeS5cblJlYWRhYmxlLnByb3RvdHlwZS53cmFwID0gZnVuY3Rpb24gKHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgcGF1c2VkID0gZmFsc2U7XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBzdHJlYW0ub24oJ2VuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICBkZWJ1Zygnd3JhcHBlZCBlbmQnKTtcbiAgICBpZiAoc3RhdGUuZGVjb2RlciAmJiAhc3RhdGUuZW5kZWQpIHtcbiAgICAgIHZhciBjaHVuayA9IHN0YXRlLmRlY29kZXIuZW5kKCk7XG4gICAgICBpZiAoY2h1bmsgJiYgY2h1bmsubGVuZ3RoKSBzZWxmLnB1c2goY2h1bmspO1xuICAgIH1cblxuICAgIHNlbGYucHVzaChudWxsKTtcbiAgfSk7XG5cbiAgc3RyZWFtLm9uKCdkYXRhJywgZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgZGVidWcoJ3dyYXBwZWQgZGF0YScpO1xuICAgIGlmIChzdGF0ZS5kZWNvZGVyKSBjaHVuayA9IHN0YXRlLmRlY29kZXIud3JpdGUoY2h1bmspO1xuXG4gICAgLy8gZG9uJ3Qgc2tpcCBvdmVyIGZhbHN5IHZhbHVlcyBpbiBvYmplY3RNb2RlXG4gICAgaWYgKHN0YXRlLm9iamVjdE1vZGUgJiYgKGNodW5rID09PSBudWxsIHx8IGNodW5rID09PSB1bmRlZmluZWQpKSByZXR1cm47ZWxzZSBpZiAoIXN0YXRlLm9iamVjdE1vZGUgJiYgKCFjaHVuayB8fCAhY2h1bmsubGVuZ3RoKSkgcmV0dXJuO1xuXG4gICAgdmFyIHJldCA9IHNlbGYucHVzaChjaHVuayk7XG4gICAgaWYgKCFyZXQpIHtcbiAgICAgIHBhdXNlZCA9IHRydWU7XG4gICAgICBzdHJlYW0ucGF1c2UoKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIHByb3h5IGFsbCB0aGUgb3RoZXIgbWV0aG9kcy5cbiAgLy8gaW1wb3J0YW50IHdoZW4gd3JhcHBpbmcgZmlsdGVycyBhbmQgZHVwbGV4ZXMuXG4gIGZvciAodmFyIGkgaW4gc3RyZWFtKSB7XG4gICAgaWYgKHRoaXNbaV0gPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygc3RyZWFtW2ldID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzW2ldID0gZnVuY3Rpb24gKG1ldGhvZCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBzdHJlYW1bbWV0aG9kXS5hcHBseShzdHJlYW0sIGFyZ3VtZW50cyk7XG4gICAgICAgIH07XG4gICAgICB9KGkpO1xuICAgIH1cbiAgfVxuXG4gIC8vIHByb3h5IGNlcnRhaW4gaW1wb3J0YW50IGV2ZW50cy5cbiAgdmFyIGV2ZW50cyA9IFsnZXJyb3InLCAnY2xvc2UnLCAnZGVzdHJveScsICdwYXVzZScsICdyZXN1bWUnXTtcbiAgZm9yRWFjaChldmVudHMsIGZ1bmN0aW9uIChldikge1xuICAgIHN0cmVhbS5vbihldiwgc2VsZi5lbWl0LmJpbmQoc2VsZiwgZXYpKTtcbiAgfSk7XG5cbiAgLy8gd2hlbiB3ZSB0cnkgdG8gY29uc3VtZSBzb21lIG1vcmUgYnl0ZXMsIHNpbXBseSB1bnBhdXNlIHRoZVxuICAvLyB1bmRlcmx5aW5nIHN0cmVhbS5cbiAgc2VsZi5fcmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gICAgZGVidWcoJ3dyYXBwZWQgX3JlYWQnLCBuKTtcbiAgICBpZiAocGF1c2VkKSB7XG4gICAgICBwYXVzZWQgPSBmYWxzZTtcbiAgICAgIHN0cmVhbS5yZXN1bWUoKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIHNlbGY7XG59O1xuXG4vLyBleHBvc2VkIGZvciB0ZXN0aW5nIHB1cnBvc2VzIG9ubHkuXG5SZWFkYWJsZS5fZnJvbUxpc3QgPSBmcm9tTGlzdDtcblxuLy8gUGx1Y2sgb2ZmIG4gYnl0ZXMgZnJvbSBhbiBhcnJheSBvZiBidWZmZXJzLlxuLy8gTGVuZ3RoIGlzIHRoZSBjb21iaW5lZCBsZW5ndGhzIG9mIGFsbCB0aGUgYnVmZmVycyBpbiB0aGUgbGlzdC5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxuZnVuY3Rpb24gZnJvbUxpc3Qobiwgc3RhdGUpIHtcbiAgLy8gbm90aGluZyBidWZmZXJlZFxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSByZXR1cm4gbnVsbDtcblxuICB2YXIgcmV0O1xuICBpZiAoc3RhdGUub2JqZWN0TW9kZSkgcmV0ID0gc3RhdGUuYnVmZmVyLnNoaWZ0KCk7ZWxzZSBpZiAoIW4gfHwgbiA+PSBzdGF0ZS5sZW5ndGgpIHtcbiAgICAvLyByZWFkIGl0IGFsbCwgdHJ1bmNhdGUgdGhlIGxpc3RcbiAgICBpZiAoc3RhdGUuZGVjb2RlcikgcmV0ID0gc3RhdGUuYnVmZmVyLmpvaW4oJycpO2Vsc2UgaWYgKHN0YXRlLmJ1ZmZlci5sZW5ndGggPT09IDEpIHJldCA9IHN0YXRlLmJ1ZmZlci5oZWFkLmRhdGE7ZWxzZSByZXQgPSBzdGF0ZS5idWZmZXIuY29uY2F0KHN0YXRlLmxlbmd0aCk7XG4gICAgc3RhdGUuYnVmZmVyLmNsZWFyKCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gcmVhZCBwYXJ0IG9mIGxpc3RcbiAgICByZXQgPSBmcm9tTGlzdFBhcnRpYWwobiwgc3RhdGUuYnVmZmVyLCBzdGF0ZS5kZWNvZGVyKTtcbiAgfVxuXG4gIHJldHVybiByZXQ7XG59XG5cbi8vIEV4dHJhY3RzIG9ubHkgZW5vdWdoIGJ1ZmZlcmVkIGRhdGEgdG8gc2F0aXNmeSB0aGUgYW1vdW50IHJlcXVlc3RlZC5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxuZnVuY3Rpb24gZnJvbUxpc3RQYXJ0aWFsKG4sIGxpc3QsIGhhc1N0cmluZ3MpIHtcbiAgdmFyIHJldDtcbiAgaWYgKG4gPCBsaXN0LmhlYWQuZGF0YS5sZW5ndGgpIHtcbiAgICAvLyBzbGljZSBpcyB0aGUgc2FtZSBmb3IgYnVmZmVycyBhbmQgc3RyaW5nc1xuICAgIHJldCA9IGxpc3QuaGVhZC5kYXRhLnNsaWNlKDAsIG4pO1xuICAgIGxpc3QuaGVhZC5kYXRhID0gbGlzdC5oZWFkLmRhdGEuc2xpY2Uobik7XG4gIH0gZWxzZSBpZiAobiA9PT0gbGlzdC5oZWFkLmRhdGEubGVuZ3RoKSB7XG4gICAgLy8gZmlyc3QgY2h1bmsgaXMgYSBwZXJmZWN0IG1hdGNoXG4gICAgcmV0ID0gbGlzdC5zaGlmdCgpO1xuICB9IGVsc2Uge1xuICAgIC8vIHJlc3VsdCBzcGFucyBtb3JlIHRoYW4gb25lIGJ1ZmZlclxuICAgIHJldCA9IGhhc1N0cmluZ3MgPyBjb3B5RnJvbUJ1ZmZlclN0cmluZyhuLCBsaXN0KSA6IGNvcHlGcm9tQnVmZmVyKG4sIGxpc3QpO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbi8vIENvcGllcyBhIHNwZWNpZmllZCBhbW91bnQgb2YgY2hhcmFjdGVycyBmcm9tIHRoZSBsaXN0IG9mIGJ1ZmZlcmVkIGRhdGFcbi8vIGNodW5rcy5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxuZnVuY3Rpb24gY29weUZyb21CdWZmZXJTdHJpbmcobiwgbGlzdCkge1xuICB2YXIgcCA9IGxpc3QuaGVhZDtcbiAgdmFyIGMgPSAxO1xuICB2YXIgcmV0ID0gcC5kYXRhO1xuICBuIC09IHJldC5sZW5ndGg7XG4gIHdoaWxlIChwID0gcC5uZXh0KSB7XG4gICAgdmFyIHN0ciA9IHAuZGF0YTtcbiAgICB2YXIgbmIgPSBuID4gc3RyLmxlbmd0aCA/IHN0ci5sZW5ndGggOiBuO1xuICAgIGlmIChuYiA9PT0gc3RyLmxlbmd0aCkgcmV0ICs9IHN0cjtlbHNlIHJldCArPSBzdHIuc2xpY2UoMCwgbik7XG4gICAgbiAtPSBuYjtcbiAgICBpZiAobiA9PT0gMCkge1xuICAgICAgaWYgKG5iID09PSBzdHIubGVuZ3RoKSB7XG4gICAgICAgICsrYztcbiAgICAgICAgaWYgKHAubmV4dCkgbGlzdC5oZWFkID0gcC5uZXh0O2Vsc2UgbGlzdC5oZWFkID0gbGlzdC50YWlsID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxpc3QuaGVhZCA9IHA7XG4gICAgICAgIHAuZGF0YSA9IHN0ci5zbGljZShuYik7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgKytjO1xuICB9XG4gIGxpc3QubGVuZ3RoIC09IGM7XG4gIHJldHVybiByZXQ7XG59XG5cbi8vIENvcGllcyBhIHNwZWNpZmllZCBhbW91bnQgb2YgYnl0ZXMgZnJvbSB0aGUgbGlzdCBvZiBidWZmZXJlZCBkYXRhIGNodW5rcy5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxuZnVuY3Rpb24gY29weUZyb21CdWZmZXIobiwgbGlzdCkge1xuICB2YXIgcmV0ID0gYnVmZmVyU2hpbS5hbGxvY1Vuc2FmZShuKTtcbiAgdmFyIHAgPSBsaXN0LmhlYWQ7XG4gIHZhciBjID0gMTtcbiAgcC5kYXRhLmNvcHkocmV0KTtcbiAgbiAtPSBwLmRhdGEubGVuZ3RoO1xuICB3aGlsZSAocCA9IHAubmV4dCkge1xuICAgIHZhciBidWYgPSBwLmRhdGE7XG4gICAgdmFyIG5iID0gbiA+IGJ1Zi5sZW5ndGggPyBidWYubGVuZ3RoIDogbjtcbiAgICBidWYuY29weShyZXQsIHJldC5sZW5ndGggLSBuLCAwLCBuYik7XG4gICAgbiAtPSBuYjtcbiAgICBpZiAobiA9PT0gMCkge1xuICAgICAgaWYgKG5iID09PSBidWYubGVuZ3RoKSB7XG4gICAgICAgICsrYztcbiAgICAgICAgaWYgKHAubmV4dCkgbGlzdC5oZWFkID0gcC5uZXh0O2Vsc2UgbGlzdC5oZWFkID0gbGlzdC50YWlsID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxpc3QuaGVhZCA9IHA7XG4gICAgICAgIHAuZGF0YSA9IGJ1Zi5zbGljZShuYik7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgKytjO1xuICB9XG4gIGxpc3QubGVuZ3RoIC09IGM7XG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGVuZFJlYWRhYmxlKHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG5cbiAgLy8gSWYgd2UgZ2V0IGhlcmUgYmVmb3JlIGNvbnN1bWluZyBhbGwgdGhlIGJ5dGVzLCB0aGVuIHRoYXQgaXMgYVxuICAvLyBidWcgaW4gbm9kZS4gIFNob3VsZCBuZXZlciBoYXBwZW4uXG4gIGlmIChzdGF0ZS5sZW5ndGggPiAwKSB0aHJvdyBuZXcgRXJyb3IoJ1wiZW5kUmVhZGFibGUoKVwiIGNhbGxlZCBvbiBub24tZW1wdHkgc3RyZWFtJyk7XG5cbiAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkKSB7XG4gICAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuICAgIHByb2Nlc3NOZXh0VGljayhlbmRSZWFkYWJsZU5ULCBzdGF0ZSwgc3RyZWFtKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbmRSZWFkYWJsZU5UKHN0YXRlLCBzdHJlYW0pIHtcbiAgLy8gQ2hlY2sgdGhhdCB3ZSBkaWRuJ3QgZ2V0IG9uZSBsYXN0IHVuc2hpZnQuXG4gIGlmICghc3RhdGUuZW5kRW1pdHRlZCAmJiBzdGF0ZS5sZW5ndGggPT09IDApIHtcbiAgICBzdGF0ZS5lbmRFbWl0dGVkID0gdHJ1ZTtcbiAgICBzdHJlYW0ucmVhZGFibGUgPSBmYWxzZTtcbiAgICBzdHJlYW0uZW1pdCgnZW5kJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZm9yRWFjaCh4cywgZikge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHhzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGYoeHNbaV0sIGkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluZGV4T2YoeHMsIHgpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB4cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBpZiAoeHNbaV0gPT09IHgpIHJldHVybiBpO1xuICB9XG4gIHJldHVybiAtMTtcbn0iLCIvLyBhIHRyYW5zZm9ybSBzdHJlYW0gaXMgYSByZWFkYWJsZS93cml0YWJsZSBzdHJlYW0gd2hlcmUgeW91IGRvXG4vLyBzb21ldGhpbmcgd2l0aCB0aGUgZGF0YS4gIFNvbWV0aW1lcyBpdCdzIGNhbGxlZCBhIFwiZmlsdGVyXCIsXG4vLyBidXQgdGhhdCdzIG5vdCBhIGdyZWF0IG5hbWUgZm9yIGl0LCBzaW5jZSB0aGF0IGltcGxpZXMgYSB0aGluZyB3aGVyZVxuLy8gc29tZSBiaXRzIHBhc3MgdGhyb3VnaCwgYW5kIG90aGVycyBhcmUgc2ltcGx5IGlnbm9yZWQuICAoVGhhdCB3b3VsZFxuLy8gYmUgYSB2YWxpZCBleGFtcGxlIG9mIGEgdHJhbnNmb3JtLCBvZiBjb3Vyc2UuKVxuLy9cbi8vIFdoaWxlIHRoZSBvdXRwdXQgaXMgY2F1c2FsbHkgcmVsYXRlZCB0byB0aGUgaW5wdXQsIGl0J3Mgbm90IGFcbi8vIG5lY2Vzc2FyaWx5IHN5bW1ldHJpYyBvciBzeW5jaHJvbm91cyB0cmFuc2Zvcm1hdGlvbi4gIEZvciBleGFtcGxlLFxuLy8gYSB6bGliIHN0cmVhbSBtaWdodCB0YWtlIG11bHRpcGxlIHBsYWluLXRleHQgd3JpdGVzKCksIGFuZCB0aGVuXG4vLyBlbWl0IGEgc2luZ2xlIGNvbXByZXNzZWQgY2h1bmsgc29tZSB0aW1lIGluIHRoZSBmdXR1cmUuXG4vL1xuLy8gSGVyZSdzIGhvdyB0aGlzIHdvcmtzOlxuLy9cbi8vIFRoZSBUcmFuc2Zvcm0gc3RyZWFtIGhhcyBhbGwgdGhlIGFzcGVjdHMgb2YgdGhlIHJlYWRhYmxlIGFuZCB3cml0YWJsZVxuLy8gc3RyZWFtIGNsYXNzZXMuICBXaGVuIHlvdSB3cml0ZShjaHVuayksIHRoYXQgY2FsbHMgX3dyaXRlKGNodW5rLGNiKVxuLy8gaW50ZXJuYWxseSwgYW5kIHJldHVybnMgZmFsc2UgaWYgdGhlcmUncyBhIGxvdCBvZiBwZW5kaW5nIHdyaXRlc1xuLy8gYnVmZmVyZWQgdXAuICBXaGVuIHlvdSBjYWxsIHJlYWQoKSwgdGhhdCBjYWxscyBfcmVhZChuKSB1bnRpbFxuLy8gdGhlcmUncyBlbm91Z2ggcGVuZGluZyByZWFkYWJsZSBkYXRhIGJ1ZmZlcmVkIHVwLlxuLy9cbi8vIEluIGEgdHJhbnNmb3JtIHN0cmVhbSwgdGhlIHdyaXR0ZW4gZGF0YSBpcyBwbGFjZWQgaW4gYSBidWZmZXIuICBXaGVuXG4vLyBfcmVhZChuKSBpcyBjYWxsZWQsIGl0IHRyYW5zZm9ybXMgdGhlIHF1ZXVlZCB1cCBkYXRhLCBjYWxsaW5nIHRoZVxuLy8gYnVmZmVyZWQgX3dyaXRlIGNiJ3MgYXMgaXQgY29uc3VtZXMgY2h1bmtzLiAgSWYgY29uc3VtaW5nIGEgc2luZ2xlXG4vLyB3cml0dGVuIGNodW5rIHdvdWxkIHJlc3VsdCBpbiBtdWx0aXBsZSBvdXRwdXQgY2h1bmtzLCB0aGVuIHRoZSBmaXJzdFxuLy8gb3V0cHV0dGVkIGJpdCBjYWxscyB0aGUgcmVhZGNiLCBhbmQgc3Vic2VxdWVudCBjaHVua3MganVzdCBnbyBpbnRvXG4vLyB0aGUgcmVhZCBidWZmZXIsIGFuZCB3aWxsIGNhdXNlIGl0IHRvIGVtaXQgJ3JlYWRhYmxlJyBpZiBuZWNlc3NhcnkuXG4vL1xuLy8gVGhpcyB3YXksIGJhY2stcHJlc3N1cmUgaXMgYWN0dWFsbHkgZGV0ZXJtaW5lZCBieSB0aGUgcmVhZGluZyBzaWRlLFxuLy8gc2luY2UgX3JlYWQgaGFzIHRvIGJlIGNhbGxlZCB0byBzdGFydCBwcm9jZXNzaW5nIGEgbmV3IGNodW5rLiAgSG93ZXZlcixcbi8vIGEgcGF0aG9sb2dpY2FsIGluZmxhdGUgdHlwZSBvZiB0cmFuc2Zvcm0gY2FuIGNhdXNlIGV4Y2Vzc2l2ZSBidWZmZXJpbmdcbi8vIGhlcmUuICBGb3IgZXhhbXBsZSwgaW1hZ2luZSBhIHN0cmVhbSB3aGVyZSBldmVyeSBieXRlIG9mIGlucHV0IGlzXG4vLyBpbnRlcnByZXRlZCBhcyBhbiBpbnRlZ2VyIGZyb20gMC0yNTUsIGFuZCB0aGVuIHJlc3VsdHMgaW4gdGhhdCBtYW55XG4vLyBieXRlcyBvZiBvdXRwdXQuICBXcml0aW5nIHRoZSA0IGJ5dGVzIHtmZixmZixmZixmZn0gd291bGQgcmVzdWx0IGluXG4vLyAxa2Igb2YgZGF0YSBiZWluZyBvdXRwdXQuICBJbiB0aGlzIGNhc2UsIHlvdSBjb3VsZCB3cml0ZSBhIHZlcnkgc21hbGxcbi8vIGFtb3VudCBvZiBpbnB1dCwgYW5kIGVuZCB1cCB3aXRoIGEgdmVyeSBsYXJnZSBhbW91bnQgb2Ygb3V0cHV0LiAgSW5cbi8vIHN1Y2ggYSBwYXRob2xvZ2ljYWwgaW5mbGF0aW5nIG1lY2hhbmlzbSwgdGhlcmUnZCBiZSBubyB3YXkgdG8gdGVsbFxuLy8gdGhlIHN5c3RlbSB0byBzdG9wIGRvaW5nIHRoZSB0cmFuc2Zvcm0uICBBIHNpbmdsZSA0TUIgd3JpdGUgY291bGRcbi8vIGNhdXNlIHRoZSBzeXN0ZW0gdG8gcnVuIG91dCBvZiBtZW1vcnkuXG4vL1xuLy8gSG93ZXZlciwgZXZlbiBpbiBzdWNoIGEgcGF0aG9sb2dpY2FsIGNhc2UsIG9ubHkgYSBzaW5nbGUgd3JpdHRlbiBjaHVua1xuLy8gd291bGQgYmUgY29uc3VtZWQsIGFuZCB0aGVuIHRoZSByZXN0IHdvdWxkIHdhaXQgKHVuLXRyYW5zZm9ybWVkKSB1bnRpbFxuLy8gdGhlIHJlc3VsdHMgb2YgdGhlIHByZXZpb3VzIHRyYW5zZm9ybWVkIGNodW5rIHdlcmUgY29uc3VtZWQuXG5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBUcmFuc2Zvcm07XG5cbnZhciBEdXBsZXggPSByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudXRpbC5pbmhlcml0cyhUcmFuc2Zvcm0sIER1cGxleCk7XG5cbmZ1bmN0aW9uIFRyYW5zZm9ybVN0YXRlKHN0cmVhbSkge1xuICB0aGlzLmFmdGVyVHJhbnNmb3JtID0gZnVuY3Rpb24gKGVyLCBkYXRhKSB7XG4gICAgcmV0dXJuIGFmdGVyVHJhbnNmb3JtKHN0cmVhbSwgZXIsIGRhdGEpO1xuICB9O1xuXG4gIHRoaXMubmVlZFRyYW5zZm9ybSA9IGZhbHNlO1xuICB0aGlzLnRyYW5zZm9ybWluZyA9IGZhbHNlO1xuICB0aGlzLndyaXRlY2IgPSBudWxsO1xuICB0aGlzLndyaXRlY2h1bmsgPSBudWxsO1xuICB0aGlzLndyaXRlZW5jb2RpbmcgPSBudWxsO1xufVxuXG5mdW5jdGlvbiBhZnRlclRyYW5zZm9ybShzdHJlYW0sIGVyLCBkYXRhKSB7XG4gIHZhciB0cyA9IHN0cmVhbS5fdHJhbnNmb3JtU3RhdGU7XG4gIHRzLnRyYW5zZm9ybWluZyA9IGZhbHNlO1xuXG4gIHZhciBjYiA9IHRzLndyaXRlY2I7XG5cbiAgaWYgKCFjYikgcmV0dXJuIHN0cmVhbS5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignbm8gd3JpdGVjYiBpbiBUcmFuc2Zvcm0gY2xhc3MnKSk7XG5cbiAgdHMud3JpdGVjaHVuayA9IG51bGw7XG4gIHRzLndyaXRlY2IgPSBudWxsO1xuXG4gIGlmIChkYXRhICE9PSBudWxsICYmIGRhdGEgIT09IHVuZGVmaW5lZCkgc3RyZWFtLnB1c2goZGF0YSk7XG5cbiAgY2IoZXIpO1xuXG4gIHZhciBycyA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgcnMucmVhZGluZyA9IGZhbHNlO1xuICBpZiAocnMubmVlZFJlYWRhYmxlIHx8IHJzLmxlbmd0aCA8IHJzLmhpZ2hXYXRlck1hcmspIHtcbiAgICBzdHJlYW0uX3JlYWQocnMuaGlnaFdhdGVyTWFyayk7XG4gIH1cbn1cblxuZnVuY3Rpb24gVHJhbnNmb3JtKG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFRyYW5zZm9ybSkpIHJldHVybiBuZXcgVHJhbnNmb3JtKG9wdGlvbnMpO1xuXG4gIER1cGxleC5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXG4gIHRoaXMuX3RyYW5zZm9ybVN0YXRlID0gbmV3IFRyYW5zZm9ybVN0YXRlKHRoaXMpO1xuXG4gIHZhciBzdHJlYW0gPSB0aGlzO1xuXG4gIC8vIHN0YXJ0IG91dCBhc2tpbmcgZm9yIGEgcmVhZGFibGUgZXZlbnQgb25jZSBkYXRhIGlzIHRyYW5zZm9ybWVkLlxuICB0aGlzLl9yZWFkYWJsZVN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG5cbiAgLy8gd2UgaGF2ZSBpbXBsZW1lbnRlZCB0aGUgX3JlYWQgbWV0aG9kLCBhbmQgZG9uZSB0aGUgb3RoZXIgdGhpbmdzXG4gIC8vIHRoYXQgUmVhZGFibGUgd2FudHMgYmVmb3JlIHRoZSBmaXJzdCBfcmVhZCBjYWxsLCBzbyB1bnNldCB0aGVcbiAgLy8gc3luYyBndWFyZCBmbGFnLlxuICB0aGlzLl9yZWFkYWJsZVN0YXRlLnN5bmMgPSBmYWxzZTtcblxuICBpZiAob3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy50cmFuc2Zvcm0gPT09ICdmdW5jdGlvbicpIHRoaXMuX3RyYW5zZm9ybSA9IG9wdGlvbnMudHJhbnNmb3JtO1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmZsdXNoID09PSAnZnVuY3Rpb24nKSB0aGlzLl9mbHVzaCA9IG9wdGlvbnMuZmx1c2g7XG4gIH1cblxuICAvLyBXaGVuIHRoZSB3cml0YWJsZSBzaWRlIGZpbmlzaGVzLCB0aGVuIGZsdXNoIG91dCBhbnl0aGluZyByZW1haW5pbmcuXG4gIHRoaXMub25jZSgncHJlZmluaXNoJywgZnVuY3Rpb24gKCkge1xuICAgIGlmICh0eXBlb2YgdGhpcy5fZmx1c2ggPT09ICdmdW5jdGlvbicpIHRoaXMuX2ZsdXNoKGZ1bmN0aW9uIChlciwgZGF0YSkge1xuICAgICAgZG9uZShzdHJlYW0sIGVyLCBkYXRhKTtcbiAgICB9KTtlbHNlIGRvbmUoc3RyZWFtKTtcbiAgfSk7XG59XG5cblRyYW5zZm9ybS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcpIHtcbiAgdGhpcy5fdHJhbnNmb3JtU3RhdGUubmVlZFRyYW5zZm9ybSA9IGZhbHNlO1xuICByZXR1cm4gRHVwbGV4LnByb3RvdHlwZS5wdXNoLmNhbGwodGhpcywgY2h1bmssIGVuY29kaW5nKTtcbn07XG5cbi8vIFRoaXMgaXMgdGhlIHBhcnQgd2hlcmUgeW91IGRvIHN0dWZmIVxuLy8gb3ZlcnJpZGUgdGhpcyBmdW5jdGlvbiBpbiBpbXBsZW1lbnRhdGlvbiBjbGFzc2VzLlxuLy8gJ2NodW5rJyBpcyBhbiBpbnB1dCBjaHVuay5cbi8vXG4vLyBDYWxsIGBwdXNoKG5ld0NodW5rKWAgdG8gcGFzcyBhbG9uZyB0cmFuc2Zvcm1lZCBvdXRwdXRcbi8vIHRvIHRoZSByZWFkYWJsZSBzaWRlLiAgWW91IG1heSBjYWxsICdwdXNoJyB6ZXJvIG9yIG1vcmUgdGltZXMuXG4vL1xuLy8gQ2FsbCBgY2IoZXJyKWAgd2hlbiB5b3UgYXJlIGRvbmUgd2l0aCB0aGlzIGNodW5rLiAgSWYgeW91IHBhc3Ncbi8vIGFuIGVycm9yLCB0aGVuIHRoYXQnbGwgcHV0IHRoZSBodXJ0IG9uIHRoZSB3aG9sZSBvcGVyYXRpb24uICBJZiB5b3Vcbi8vIG5ldmVyIGNhbGwgY2IoKSwgdGhlbiB5b3UnbGwgbmV2ZXIgZ2V0IGFub3RoZXIgY2h1bmsuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl90cmFuc2Zvcm0gPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB0aHJvdyBuZXcgRXJyb3IoJ190cmFuc2Zvcm0oKSBpcyBub3QgaW1wbGVtZW50ZWQnKTtcbn07XG5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHRzID0gdGhpcy5fdHJhbnNmb3JtU3RhdGU7XG4gIHRzLndyaXRlY2IgPSBjYjtcbiAgdHMud3JpdGVjaHVuayA9IGNodW5rO1xuICB0cy53cml0ZWVuY29kaW5nID0gZW5jb2Rpbmc7XG4gIGlmICghdHMudHJhbnNmb3JtaW5nKSB7XG4gICAgdmFyIHJzID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgICBpZiAodHMubmVlZFRyYW5zZm9ybSB8fCBycy5uZWVkUmVhZGFibGUgfHwgcnMubGVuZ3RoIDwgcnMuaGlnaFdhdGVyTWFyaykgdGhpcy5fcmVhZChycy5oaWdoV2F0ZXJNYXJrKTtcbiAgfVxufTtcblxuLy8gRG9lc24ndCBtYXR0ZXIgd2hhdCB0aGUgYXJncyBhcmUgaGVyZS5cbi8vIF90cmFuc2Zvcm0gZG9lcyBhbGwgdGhlIHdvcmsuXG4vLyBUaGF0IHdlIGdvdCBoZXJlIG1lYW5zIHRoYXQgdGhlIHJlYWRhYmxlIHNpZGUgd2FudHMgbW9yZSBkYXRhLlxuVHJhbnNmb3JtLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gIHZhciB0cyA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlO1xuXG4gIGlmICh0cy53cml0ZWNodW5rICE9PSBudWxsICYmIHRzLndyaXRlY2IgJiYgIXRzLnRyYW5zZm9ybWluZykge1xuICAgIHRzLnRyYW5zZm9ybWluZyA9IHRydWU7XG4gICAgdGhpcy5fdHJhbnNmb3JtKHRzLndyaXRlY2h1bmssIHRzLndyaXRlZW5jb2RpbmcsIHRzLmFmdGVyVHJhbnNmb3JtKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBtYXJrIHRoYXQgd2UgbmVlZCBhIHRyYW5zZm9ybSwgc28gdGhhdCBhbnkgZGF0YSB0aGF0IGNvbWVzIGluXG4gICAgLy8gd2lsbCBnZXQgcHJvY2Vzc2VkLCBub3cgdGhhdCB3ZSd2ZSBhc2tlZCBmb3IgaXQuXG4gICAgdHMubmVlZFRyYW5zZm9ybSA9IHRydWU7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGRvbmUoc3RyZWFtLCBlciwgZGF0YSkge1xuICBpZiAoZXIpIHJldHVybiBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG5cbiAgaWYgKGRhdGEgIT09IG51bGwgJiYgZGF0YSAhPT0gdW5kZWZpbmVkKSBzdHJlYW0ucHVzaChkYXRhKTtcblxuICAvLyBpZiB0aGVyZSdzIG5vdGhpbmcgaW4gdGhlIHdyaXRlIGJ1ZmZlciwgdGhlbiB0aGF0IG1lYW5zXG4gIC8vIHRoYXQgbm90aGluZyBtb3JlIHdpbGwgZXZlciBiZSBwcm92aWRlZFxuICB2YXIgd3MgPSBzdHJlYW0uX3dyaXRhYmxlU3RhdGU7XG4gIHZhciB0cyA9IHN0cmVhbS5fdHJhbnNmb3JtU3RhdGU7XG5cbiAgaWYgKHdzLmxlbmd0aCkgdGhyb3cgbmV3IEVycm9yKCdDYWxsaW5nIHRyYW5zZm9ybSBkb25lIHdoZW4gd3MubGVuZ3RoICE9IDAnKTtcblxuICBpZiAodHMudHJhbnNmb3JtaW5nKSB0aHJvdyBuZXcgRXJyb3IoJ0NhbGxpbmcgdHJhbnNmb3JtIGRvbmUgd2hlbiBzdGlsbCB0cmFuc2Zvcm1pbmcnKTtcblxuICByZXR1cm4gc3RyZWFtLnB1c2gobnVsbCk7XG59IiwiLy8gQSBiaXQgc2ltcGxlciB0aGFuIHJlYWRhYmxlIHN0cmVhbXMuXG4vLyBJbXBsZW1lbnQgYW4gYXN5bmMgLl93cml0ZShjaHVuaywgZW5jb2RpbmcsIGNiKSwgYW5kIGl0J2xsIGhhbmRsZSBhbGxcbi8vIHRoZSBkcmFpbiBldmVudCBlbWlzc2lvbiBhbmQgYnVmZmVyaW5nLlxuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gV3JpdGFibGU7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgcHJvY2Vzc05leHRUaWNrID0gcmVxdWlyZSgncHJvY2Vzcy1uZXh0aWNrLWFyZ3MnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIGFzeW5jV3JpdGUgPSAhcHJvY2Vzcy5icm93c2VyICYmIFsndjAuMTAnLCAndjAuOS4nXS5pbmRleE9mKHByb2Nlc3MudmVyc2lvbi5zbGljZSgwLCA1KSkgPiAtMSA/IHNldEltbWVkaWF0ZSA6IHByb2Nlc3NOZXh0VGljaztcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIER1cGxleDtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5Xcml0YWJsZS5Xcml0YWJsZVN0YXRlID0gV3JpdGFibGVTdGF0ZTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gcmVxdWlyZSgnY29yZS11dGlsLWlzJyk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIGludGVybmFsVXRpbCA9IHtcbiAgZGVwcmVjYXRlOiByZXF1aXJlKCd1dGlsLWRlcHJlY2F0ZScpXG59O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgU3RyZWFtO1xuKGZ1bmN0aW9uICgpIHtcbiAgdHJ5IHtcbiAgICBTdHJlYW0gPSByZXF1aXJlKCdzdCcgKyAncmVhbScpO1xuICB9IGNhdGNoIChfKSB7fSBmaW5hbGx5IHtcbiAgICBpZiAoIVN0cmVhbSkgU3RyZWFtID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xuICB9XG59KSgpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdidWZmZXInKS5CdWZmZXI7XG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIGJ1ZmZlclNoaW0gPSByZXF1aXJlKCdidWZmZXItc2hpbXMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG51dGlsLmluaGVyaXRzKFdyaXRhYmxlLCBTdHJlYW0pO1xuXG5mdW5jdGlvbiBub3AoKSB7fVxuXG5mdW5jdGlvbiBXcml0ZVJlcShjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHRoaXMuY2h1bmsgPSBjaHVuaztcbiAgdGhpcy5lbmNvZGluZyA9IGVuY29kaW5nO1xuICB0aGlzLmNhbGxiYWNrID0gY2I7XG4gIHRoaXMubmV4dCA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIFdyaXRhYmxlU3RhdGUob3B0aW9ucywgc3RyZWFtKSB7XG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgLy8gb2JqZWN0IHN0cmVhbSBmbGFnIHRvIGluZGljYXRlIHdoZXRoZXIgb3Igbm90IHRoaXMgc3RyZWFtXG4gIC8vIGNvbnRhaW5zIGJ1ZmZlcnMgb3Igb2JqZWN0cy5cbiAgdGhpcy5vYmplY3RNb2RlID0gISFvcHRpb25zLm9iamVjdE1vZGU7XG5cbiAgaWYgKHN0cmVhbSBpbnN0YW5jZW9mIER1cGxleCkgdGhpcy5vYmplY3RNb2RlID0gdGhpcy5vYmplY3RNb2RlIHx8ICEhb3B0aW9ucy53cml0YWJsZU9iamVjdE1vZGU7XG5cbiAgLy8gdGhlIHBvaW50IGF0IHdoaWNoIHdyaXRlKCkgc3RhcnRzIHJldHVybmluZyBmYWxzZVxuICAvLyBOb3RlOiAwIGlzIGEgdmFsaWQgdmFsdWUsIG1lYW5zIHRoYXQgd2UgYWx3YXlzIHJldHVybiBmYWxzZSBpZlxuICAvLyB0aGUgZW50aXJlIGJ1ZmZlciBpcyBub3QgZmx1c2hlZCBpbW1lZGlhdGVseSBvbiB3cml0ZSgpXG4gIHZhciBod20gPSBvcHRpb25zLmhpZ2hXYXRlck1hcms7XG4gIHZhciBkZWZhdWx0SHdtID0gdGhpcy5vYmplY3RNb2RlID8gMTYgOiAxNiAqIDEwMjQ7XG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IGh3bSB8fCBod20gPT09IDAgPyBod20gOiBkZWZhdWx0SHdtO1xuXG4gIC8vIGNhc3QgdG8gaW50cy5cbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gfn50aGlzLmhpZ2hXYXRlck1hcms7XG5cbiAgLy8gZHJhaW4gZXZlbnQgZmxhZy5cbiAgdGhpcy5uZWVkRHJhaW4gPSBmYWxzZTtcbiAgLy8gYXQgdGhlIHN0YXJ0IG9mIGNhbGxpbmcgZW5kKClcbiAgdGhpcy5lbmRpbmcgPSBmYWxzZTtcbiAgLy8gd2hlbiBlbmQoKSBoYXMgYmVlbiBjYWxsZWQsIGFuZCByZXR1cm5lZFxuICB0aGlzLmVuZGVkID0gZmFsc2U7XG4gIC8vIHdoZW4gJ2ZpbmlzaCcgaXMgZW1pdHRlZFxuICB0aGlzLmZpbmlzaGVkID0gZmFsc2U7XG5cbiAgLy8gc2hvdWxkIHdlIGRlY29kZSBzdHJpbmdzIGludG8gYnVmZmVycyBiZWZvcmUgcGFzc2luZyB0byBfd3JpdGU/XG4gIC8vIHRoaXMgaXMgaGVyZSBzbyB0aGF0IHNvbWUgbm9kZS1jb3JlIHN0cmVhbXMgY2FuIG9wdGltaXplIHN0cmluZ1xuICAvLyBoYW5kbGluZyBhdCBhIGxvd2VyIGxldmVsLlxuICB2YXIgbm9EZWNvZGUgPSBvcHRpb25zLmRlY29kZVN0cmluZ3MgPT09IGZhbHNlO1xuICB0aGlzLmRlY29kZVN0cmluZ3MgPSAhbm9EZWNvZGU7XG5cbiAgLy8gQ3J5cHRvIGlzIGtpbmQgb2Ygb2xkIGFuZCBjcnVzdHkuICBIaXN0b3JpY2FsbHksIGl0cyBkZWZhdWx0IHN0cmluZ1xuICAvLyBlbmNvZGluZyBpcyAnYmluYXJ5JyBzbyB3ZSBoYXZlIHRvIG1ha2UgdGhpcyBjb25maWd1cmFibGUuXG4gIC8vIEV2ZXJ5dGhpbmcgZWxzZSBpbiB0aGUgdW5pdmVyc2UgdXNlcyAndXRmOCcsIHRob3VnaC5cbiAgdGhpcy5kZWZhdWx0RW5jb2RpbmcgPSBvcHRpb25zLmRlZmF1bHRFbmNvZGluZyB8fCAndXRmOCc7XG5cbiAgLy8gbm90IGFuIGFjdHVhbCBidWZmZXIgd2Uga2VlcCB0cmFjayBvZiwgYnV0IGEgbWVhc3VyZW1lbnRcbiAgLy8gb2YgaG93IG11Y2ggd2UncmUgd2FpdGluZyB0byBnZXQgcHVzaGVkIHRvIHNvbWUgdW5kZXJseWluZ1xuICAvLyBzb2NrZXQgb3IgZmlsZS5cbiAgdGhpcy5sZW5ndGggPSAwO1xuXG4gIC8vIGEgZmxhZyB0byBzZWUgd2hlbiB3ZSdyZSBpbiB0aGUgbWlkZGxlIG9mIGEgd3JpdGUuXG4gIHRoaXMud3JpdGluZyA9IGZhbHNlO1xuXG4gIC8vIHdoZW4gdHJ1ZSBhbGwgd3JpdGVzIHdpbGwgYmUgYnVmZmVyZWQgdW50aWwgLnVuY29yaygpIGNhbGxcbiAgdGhpcy5jb3JrZWQgPSAwO1xuXG4gIC8vIGEgZmxhZyB0byBiZSBhYmxlIHRvIHRlbGwgaWYgdGhlIG9ud3JpdGUgY2IgaXMgY2FsbGVkIGltbWVkaWF0ZWx5LFxuICAvLyBvciBvbiBhIGxhdGVyIHRpY2suICBXZSBzZXQgdGhpcyB0byB0cnVlIGF0IGZpcnN0LCBiZWNhdXNlIGFueVxuICAvLyBhY3Rpb25zIHRoYXQgc2hvdWxkbid0IGhhcHBlbiB1bnRpbCBcImxhdGVyXCIgc2hvdWxkIGdlbmVyYWxseSBhbHNvXG4gIC8vIG5vdCBoYXBwZW4gYmVmb3JlIHRoZSBmaXJzdCB3cml0ZSBjYWxsLlxuICB0aGlzLnN5bmMgPSB0cnVlO1xuXG4gIC8vIGEgZmxhZyB0byBrbm93IGlmIHdlJ3JlIHByb2Nlc3NpbmcgcHJldmlvdXNseSBidWZmZXJlZCBpdGVtcywgd2hpY2hcbiAgLy8gbWF5IGNhbGwgdGhlIF93cml0ZSgpIGNhbGxiYWNrIGluIHRoZSBzYW1lIHRpY2ssIHNvIHRoYXQgd2UgZG9uJ3RcbiAgLy8gZW5kIHVwIGluIGFuIG92ZXJsYXBwZWQgb253cml0ZSBzaXR1YXRpb24uXG4gIHRoaXMuYnVmZmVyUHJvY2Vzc2luZyA9IGZhbHNlO1xuXG4gIC8vIHRoZSBjYWxsYmFjayB0aGF0J3MgcGFzc2VkIHRvIF93cml0ZShjaHVuayxjYilcbiAgdGhpcy5vbndyaXRlID0gZnVuY3Rpb24gKGVyKSB7XG4gICAgb253cml0ZShzdHJlYW0sIGVyKTtcbiAgfTtcblxuICAvLyB0aGUgY2FsbGJhY2sgdGhhdCB0aGUgdXNlciBzdXBwbGllcyB0byB3cml0ZShjaHVuayxlbmNvZGluZyxjYilcbiAgdGhpcy53cml0ZWNiID0gbnVsbDtcblxuICAvLyB0aGUgYW1vdW50IHRoYXQgaXMgYmVpbmcgd3JpdHRlbiB3aGVuIF93cml0ZSBpcyBjYWxsZWQuXG4gIHRoaXMud3JpdGVsZW4gPSAwO1xuXG4gIHRoaXMuYnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcbiAgdGhpcy5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcblxuICAvLyBudW1iZXIgb2YgcGVuZGluZyB1c2VyLXN1cHBsaWVkIHdyaXRlIGNhbGxiYWNrc1xuICAvLyB0aGlzIG11c3QgYmUgMCBiZWZvcmUgJ2ZpbmlzaCcgY2FuIGJlIGVtaXR0ZWRcbiAgdGhpcy5wZW5kaW5nY2IgPSAwO1xuXG4gIC8vIGVtaXQgcHJlZmluaXNoIGlmIHRoZSBvbmx5IHRoaW5nIHdlJ3JlIHdhaXRpbmcgZm9yIGlzIF93cml0ZSBjYnNcbiAgLy8gVGhpcyBpcyByZWxldmFudCBmb3Igc3luY2hyb25vdXMgVHJhbnNmb3JtIHN0cmVhbXNcbiAgdGhpcy5wcmVmaW5pc2hlZCA9IGZhbHNlO1xuXG4gIC8vIFRydWUgaWYgdGhlIGVycm9yIHdhcyBhbHJlYWR5IGVtaXR0ZWQgYW5kIHNob3VsZCBub3QgYmUgdGhyb3duIGFnYWluXG4gIHRoaXMuZXJyb3JFbWl0dGVkID0gZmFsc2U7XG5cbiAgLy8gY291bnQgYnVmZmVyZWQgcmVxdWVzdHNcbiAgdGhpcy5idWZmZXJlZFJlcXVlc3RDb3VudCA9IDA7XG5cbiAgLy8gYWxsb2NhdGUgdGhlIGZpcnN0IENvcmtlZFJlcXVlc3QsIHRoZXJlIGlzIGFsd2F5c1xuICAvLyBvbmUgYWxsb2NhdGVkIGFuZCBmcmVlIHRvIHVzZSwgYW5kIHdlIG1haW50YWluIGF0IG1vc3QgdHdvXG4gIHRoaXMuY29ya2VkUmVxdWVzdHNGcmVlID0gbmV3IENvcmtlZFJlcXVlc3QodGhpcyk7XG59XG5cbldyaXRhYmxlU3RhdGUucHJvdG90eXBlLmdldEJ1ZmZlciA9IGZ1bmN0aW9uIGdldEJ1ZmZlcigpIHtcbiAgdmFyIGN1cnJlbnQgPSB0aGlzLmJ1ZmZlcmVkUmVxdWVzdDtcbiAgdmFyIG91dCA9IFtdO1xuICB3aGlsZSAoY3VycmVudCkge1xuICAgIG91dC5wdXNoKGN1cnJlbnQpO1xuICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XG4gIH1cbiAgcmV0dXJuIG91dDtcbn07XG5cbihmdW5jdGlvbiAoKSB7XG4gIHRyeSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlU3RhdGUucHJvdG90eXBlLCAnYnVmZmVyJywge1xuICAgICAgZ2V0OiBpbnRlcm5hbFV0aWwuZGVwcmVjYXRlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QnVmZmVyKCk7XG4gICAgICB9LCAnX3dyaXRhYmxlU3RhdGUuYnVmZmVyIGlzIGRlcHJlY2F0ZWQuIFVzZSBfd3JpdGFibGVTdGF0ZS5nZXRCdWZmZXIgJyArICdpbnN0ZWFkLicpXG4gICAgfSk7XG4gIH0gY2F0Y2ggKF8pIHt9XG59KSgpO1xuXG4vLyBUZXN0IF93cml0YWJsZVN0YXRlIGZvciBpbmhlcml0YW5jZSB0byBhY2NvdW50IGZvciBEdXBsZXggc3RyZWFtcyxcbi8vIHdob3NlIHByb3RvdHlwZSBjaGFpbiBvbmx5IHBvaW50cyB0byBSZWFkYWJsZS5cbnZhciByZWFsSGFzSW5zdGFuY2U7XG5pZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuaGFzSW5zdGFuY2UgJiYgdHlwZW9mIEZ1bmN0aW9uLnByb3RvdHlwZVtTeW1ib2wuaGFzSW5zdGFuY2VdID09PSAnZnVuY3Rpb24nKSB7XG4gIHJlYWxIYXNJbnN0YW5jZSA9IEZ1bmN0aW9uLnByb3RvdHlwZVtTeW1ib2wuaGFzSW5zdGFuY2VdO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGUsIFN5bWJvbC5oYXNJbnN0YW5jZSwge1xuICAgIHZhbHVlOiBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgICBpZiAocmVhbEhhc0luc3RhbmNlLmNhbGwodGhpcywgb2JqZWN0KSkgcmV0dXJuIHRydWU7XG5cbiAgICAgIHJldHVybiBvYmplY3QgJiYgb2JqZWN0Ll93cml0YWJsZVN0YXRlIGluc3RhbmNlb2YgV3JpdGFibGVTdGF0ZTtcbiAgICB9XG4gIH0pO1xufSBlbHNlIHtcbiAgcmVhbEhhc0luc3RhbmNlID0gZnVuY3Rpb24gKG9iamVjdCkge1xuICAgIHJldHVybiBvYmplY3QgaW5zdGFuY2VvZiB0aGlzO1xuICB9O1xufVxuXG5mdW5jdGlvbiBXcml0YWJsZShvcHRpb25zKSB7XG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbiAgLy8gV3JpdGFibGUgY3RvciBpcyBhcHBsaWVkIHRvIER1cGxleGVzLCB0b28uXG4gIC8vIGByZWFsSGFzSW5zdGFuY2VgIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHVzaW5nIHBsYWluIGBpbnN0YW5jZW9mYFxuICAvLyB3b3VsZCByZXR1cm4gZmFsc2UsIGFzIG5vIGBfd3JpdGFibGVTdGF0ZWAgcHJvcGVydHkgaXMgYXR0YWNoZWQuXG5cbiAgLy8gVHJ5aW5nIHRvIHVzZSB0aGUgY3VzdG9tIGBpbnN0YW5jZW9mYCBmb3IgV3JpdGFibGUgaGVyZSB3aWxsIGFsc28gYnJlYWsgdGhlXG4gIC8vIE5vZGUuanMgTGF6eVRyYW5zZm9ybSBpbXBsZW1lbnRhdGlvbiwgd2hpY2ggaGFzIGEgbm9uLXRyaXZpYWwgZ2V0dGVyIGZvclxuICAvLyBgX3dyaXRhYmxlU3RhdGVgIHRoYXQgd291bGQgbGVhZCB0byBpbmZpbml0ZSByZWN1cnNpb24uXG4gIGlmICghcmVhbEhhc0luc3RhbmNlLmNhbGwoV3JpdGFibGUsIHRoaXMpICYmICEodGhpcyBpbnN0YW5jZW9mIER1cGxleCkpIHtcbiAgICByZXR1cm4gbmV3IFdyaXRhYmxlKG9wdGlvbnMpO1xuICB9XG5cbiAgdGhpcy5fd3JpdGFibGVTdGF0ZSA9IG5ldyBXcml0YWJsZVN0YXRlKG9wdGlvbnMsIHRoaXMpO1xuXG4gIC8vIGxlZ2FjeS5cbiAgdGhpcy53cml0YWJsZSA9IHRydWU7XG5cbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMud3JpdGUgPT09ICdmdW5jdGlvbicpIHRoaXMuX3dyaXRlID0gb3B0aW9ucy53cml0ZTtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy53cml0ZXYgPT09ICdmdW5jdGlvbicpIHRoaXMuX3dyaXRldiA9IG9wdGlvbnMud3JpdGV2O1xuICB9XG5cbiAgU3RyZWFtLmNhbGwodGhpcyk7XG59XG5cbi8vIE90aGVyd2lzZSBwZW9wbGUgY2FuIHBpcGUgV3JpdGFibGUgc3RyZWFtcywgd2hpY2ggaXMganVzdCB3cm9uZy5cbldyaXRhYmxlLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdDYW5ub3QgcGlwZSwgbm90IHJlYWRhYmxlJykpO1xufTtcblxuZnVuY3Rpb24gd3JpdGVBZnRlckVuZChzdHJlYW0sIGNiKSB7XG4gIHZhciBlciA9IG5ldyBFcnJvcignd3JpdGUgYWZ0ZXIgZW5kJyk7XG4gIC8vIFRPRE86IGRlZmVyIGVycm9yIGV2ZW50cyBjb25zaXN0ZW50bHkgZXZlcnl3aGVyZSwgbm90IGp1c3QgdGhlIGNiXG4gIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgcHJvY2Vzc05leHRUaWNrKGNiLCBlcik7XG59XG5cbi8vIENoZWNrcyB0aGF0IGEgdXNlci1zdXBwbGllZCBjaHVuayBpcyB2YWxpZCwgZXNwZWNpYWxseSBmb3IgdGhlIHBhcnRpY3VsYXJcbi8vIG1vZGUgdGhlIHN0cmVhbSBpcyBpbi4gQ3VycmVudGx5IHRoaXMgbWVhbnMgdGhhdCBgbnVsbGAgaXMgbmV2ZXIgYWNjZXB0ZWRcbi8vIGFuZCB1bmRlZmluZWQvbm9uLXN0cmluZyB2YWx1ZXMgYXJlIG9ubHkgYWxsb3dlZCBpbiBvYmplY3QgbW9kZS5cbmZ1bmN0aW9uIHZhbGlkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGNiKSB7XG4gIHZhciB2YWxpZCA9IHRydWU7XG4gIHZhciBlciA9IGZhbHNlO1xuXG4gIGlmIChjaHVuayA9PT0gbnVsbCkge1xuICAgIGVyID0gbmV3IFR5cGVFcnJvcignTWF5IG5vdCB3cml0ZSBudWxsIHZhbHVlcyB0byBzdHJlYW0nKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgY2h1bmsgIT09ICdzdHJpbmcnICYmIGNodW5rICE9PSB1bmRlZmluZWQgJiYgIXN0YXRlLm9iamVjdE1vZGUpIHtcbiAgICBlciA9IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgbm9uLXN0cmluZy9idWZmZXIgY2h1bmsnKTtcbiAgfVxuICBpZiAoZXIpIHtcbiAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gICAgcHJvY2Vzc05leHRUaWNrKGNiLCBlcik7XG4gICAgdmFsaWQgPSBmYWxzZTtcbiAgfVxuICByZXR1cm4gdmFsaWQ7XG59XG5cbldyaXRhYmxlLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG4gIHZhciByZXQgPSBmYWxzZTtcbiAgdmFyIGlzQnVmID0gQnVmZmVyLmlzQnVmZmVyKGNodW5rKTtcblxuICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBlbmNvZGluZztcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH1cblxuICBpZiAoaXNCdWYpIGVuY29kaW5nID0gJ2J1ZmZlcic7ZWxzZSBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9IHN0YXRlLmRlZmF1bHRFbmNvZGluZztcblxuICBpZiAodHlwZW9mIGNiICE9PSAnZnVuY3Rpb24nKSBjYiA9IG5vcDtcblxuICBpZiAoc3RhdGUuZW5kZWQpIHdyaXRlQWZ0ZXJFbmQodGhpcywgY2IpO2Vsc2UgaWYgKGlzQnVmIHx8IHZhbGlkQ2h1bmsodGhpcywgc3RhdGUsIGNodW5rLCBjYikpIHtcbiAgICBzdGF0ZS5wZW5kaW5nY2IrKztcbiAgICByZXQgPSB3cml0ZU9yQnVmZmVyKHRoaXMsIHN0YXRlLCBpc0J1ZiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG4gIH1cblxuICByZXR1cm4gcmV0O1xufTtcblxuV3JpdGFibGUucHJvdG90eXBlLmNvcmsgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG5cbiAgc3RhdGUuY29ya2VkKys7XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUudW5jb3JrID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuXG4gIGlmIChzdGF0ZS5jb3JrZWQpIHtcbiAgICBzdGF0ZS5jb3JrZWQtLTtcblxuICAgIGlmICghc3RhdGUud3JpdGluZyAmJiAhc3RhdGUuY29ya2VkICYmICFzdGF0ZS5maW5pc2hlZCAmJiAhc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyAmJiBzdGF0ZS5idWZmZXJlZFJlcXVlc3QpIGNsZWFyQnVmZmVyKHRoaXMsIHN0YXRlKTtcbiAgfVxufTtcblxuV3JpdGFibGUucHJvdG90eXBlLnNldERlZmF1bHRFbmNvZGluZyA9IGZ1bmN0aW9uIHNldERlZmF1bHRFbmNvZGluZyhlbmNvZGluZykge1xuICAvLyBub2RlOjpQYXJzZUVuY29kaW5nKCkgcmVxdWlyZXMgbG93ZXIgY2FzZS5cbiAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycpIGVuY29kaW5nID0gZW5jb2RpbmcudG9Mb3dlckNhc2UoKTtcbiAgaWYgKCEoWydoZXgnLCAndXRmOCcsICd1dGYtOCcsICdhc2NpaScsICdiaW5hcnknLCAnYmFzZTY0JywgJ3VjczInLCAndWNzLTInLCAndXRmMTZsZScsICd1dGYtMTZsZScsICdyYXcnXS5pbmRleE9mKChlbmNvZGluZyArICcnKS50b0xvd2VyQ2FzZSgpKSA+IC0xKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKTtcbiAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZWZhdWx0RW5jb2RpbmcgPSBlbmNvZGluZztcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiBkZWNvZGVDaHVuayhzdGF0ZSwgY2h1bmssIGVuY29kaW5nKSB7XG4gIGlmICghc3RhdGUub2JqZWN0TW9kZSAmJiBzdGF0ZS5kZWNvZGVTdHJpbmdzICE9PSBmYWxzZSAmJiB0eXBlb2YgY2h1bmsgPT09ICdzdHJpbmcnKSB7XG4gICAgY2h1bmsgPSBidWZmZXJTaGltLmZyb20oY2h1bmssIGVuY29kaW5nKTtcbiAgfVxuICByZXR1cm4gY2h1bms7XG59XG5cbi8vIGlmIHdlJ3JlIGFscmVhZHkgd3JpdGluZyBzb21ldGhpbmcsIHRoZW4ganVzdCBwdXQgdGhpc1xuLy8gaW4gdGhlIHF1ZXVlLCBhbmQgd2FpdCBvdXIgdHVybi4gIE90aGVyd2lzZSwgY2FsbCBfd3JpdGVcbi8vIElmIHdlIHJldHVybiBmYWxzZSwgdGhlbiB3ZSBuZWVkIGEgZHJhaW4gZXZlbnQsIHNvIHNldCB0aGF0IGZsYWcuXG5mdW5jdGlvbiB3cml0ZU9yQnVmZmVyKHN0cmVhbSwgc3RhdGUsIGlzQnVmLCBjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGlmICghaXNCdWYpIHtcbiAgICBjaHVuayA9IGRlY29kZUNodW5rKHN0YXRlLCBjaHVuaywgZW5jb2RpbmcpO1xuICAgIGlmIChCdWZmZXIuaXNCdWZmZXIoY2h1bmspKSBlbmNvZGluZyA9ICdidWZmZXInO1xuICB9XG4gIHZhciBsZW4gPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcblxuICBzdGF0ZS5sZW5ndGggKz0gbGVuO1xuXG4gIHZhciByZXQgPSBzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrO1xuICAvLyB3ZSBtdXN0IGVuc3VyZSB0aGF0IHByZXZpb3VzIG5lZWREcmFpbiB3aWxsIG5vdCBiZSByZXNldCB0byBmYWxzZS5cbiAgaWYgKCFyZXQpIHN0YXRlLm5lZWREcmFpbiA9IHRydWU7XG5cbiAgaWYgKHN0YXRlLndyaXRpbmcgfHwgc3RhdGUuY29ya2VkKSB7XG4gICAgdmFyIGxhc3QgPSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0O1xuICAgIHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSBuZXcgV3JpdGVSZXEoY2h1bmssIGVuY29kaW5nLCBjYik7XG4gICAgaWYgKGxhc3QpIHtcbiAgICAgIGxhc3QubmV4dCA9IHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCA9IHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3Q7XG4gICAgfVxuICAgIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50ICs9IDE7XG4gIH0gZWxzZSB7XG4gICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCBmYWxzZSwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKTtcbiAgfVxuXG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgd3JpdGV2LCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgc3RhdGUud3JpdGVsZW4gPSBsZW47XG4gIHN0YXRlLndyaXRlY2IgPSBjYjtcbiAgc3RhdGUud3JpdGluZyA9IHRydWU7XG4gIHN0YXRlLnN5bmMgPSB0cnVlO1xuICBpZiAod3JpdGV2KSBzdHJlYW0uX3dyaXRldihjaHVuaywgc3RhdGUub253cml0ZSk7ZWxzZSBzdHJlYW0uX3dyaXRlKGNodW5rLCBlbmNvZGluZywgc3RhdGUub253cml0ZSk7XG4gIHN0YXRlLnN5bmMgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gb253cml0ZUVycm9yKHN0cmVhbSwgc3RhdGUsIHN5bmMsIGVyLCBjYikge1xuICAtLXN0YXRlLnBlbmRpbmdjYjtcbiAgaWYgKHN5bmMpIHByb2Nlc3NOZXh0VGljayhjYiwgZXIpO2Vsc2UgY2IoZXIpO1xuXG4gIHN0cmVhbS5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSB0cnVlO1xuICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG59XG5cbmZ1bmN0aW9uIG9ud3JpdGVTdGF0ZVVwZGF0ZShzdGF0ZSkge1xuICBzdGF0ZS53cml0aW5nID0gZmFsc2U7XG4gIHN0YXRlLndyaXRlY2IgPSBudWxsO1xuICBzdGF0ZS5sZW5ndGggLT0gc3RhdGUud3JpdGVsZW47XG4gIHN0YXRlLndyaXRlbGVuID0gMDtcbn1cblxuZnVuY3Rpb24gb253cml0ZShzdHJlYW0sIGVyKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fd3JpdGFibGVTdGF0ZTtcbiAgdmFyIHN5bmMgPSBzdGF0ZS5zeW5jO1xuICB2YXIgY2IgPSBzdGF0ZS53cml0ZWNiO1xuXG4gIG9ud3JpdGVTdGF0ZVVwZGF0ZShzdGF0ZSk7XG5cbiAgaWYgKGVyKSBvbndyaXRlRXJyb3Ioc3RyZWFtLCBzdGF0ZSwgc3luYywgZXIsIGNiKTtlbHNlIHtcbiAgICAvLyBDaGVjayBpZiB3ZSdyZSBhY3R1YWxseSByZWFkeSB0byBmaW5pc2gsIGJ1dCBkb24ndCBlbWl0IHlldFxuICAgIHZhciBmaW5pc2hlZCA9IG5lZWRGaW5pc2goc3RhdGUpO1xuXG4gICAgaWYgKCFmaW5pc2hlZCAmJiAhc3RhdGUuY29ya2VkICYmICFzdGF0ZS5idWZmZXJQcm9jZXNzaW5nICYmIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCkge1xuICAgICAgY2xlYXJCdWZmZXIoc3RyZWFtLCBzdGF0ZSk7XG4gICAgfVxuXG4gICAgaWYgKHN5bmMpIHtcbiAgICAgIC8qPHJlcGxhY2VtZW50PiovXG4gICAgICBhc3luY1dyaXRlKGFmdGVyV3JpdGUsIHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYik7XG4gICAgICAvKjwvcmVwbGFjZW1lbnQ+Ki9cbiAgICB9IGVsc2Uge1xuICAgICAgYWZ0ZXJXcml0ZShzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhZnRlcldyaXRlKHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYikge1xuICBpZiAoIWZpbmlzaGVkKSBvbndyaXRlRHJhaW4oc3RyZWFtLCBzdGF0ZSk7XG4gIHN0YXRlLnBlbmRpbmdjYi0tO1xuICBjYigpO1xuICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcbn1cblxuLy8gTXVzdCBmb3JjZSBjYWxsYmFjayB0byBiZSBjYWxsZWQgb24gbmV4dFRpY2ssIHNvIHRoYXQgd2UgZG9uJ3Rcbi8vIGVtaXQgJ2RyYWluJyBiZWZvcmUgdGhlIHdyaXRlKCkgY29uc3VtZXIgZ2V0cyB0aGUgJ2ZhbHNlJyByZXR1cm5cbi8vIHZhbHVlLCBhbmQgaGFzIGEgY2hhbmNlIHRvIGF0dGFjaCBhICdkcmFpbicgbGlzdGVuZXIuXG5mdW5jdGlvbiBvbndyaXRlRHJhaW4oc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLm5lZWREcmFpbikge1xuICAgIHN0YXRlLm5lZWREcmFpbiA9IGZhbHNlO1xuICAgIHN0cmVhbS5lbWl0KCdkcmFpbicpO1xuICB9XG59XG5cbi8vIGlmIHRoZXJlJ3Mgc29tZXRoaW5nIGluIHRoZSBidWZmZXIgd2FpdGluZywgdGhlbiBwcm9jZXNzIGl0XG5mdW5jdGlvbiBjbGVhckJ1ZmZlcihzdHJlYW0sIHN0YXRlKSB7XG4gIHN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgPSB0cnVlO1xuICB2YXIgZW50cnkgPSBzdGF0ZS5idWZmZXJlZFJlcXVlc3Q7XG5cbiAgaWYgKHN0cmVhbS5fd3JpdGV2ICYmIGVudHJ5ICYmIGVudHJ5Lm5leHQpIHtcbiAgICAvLyBGYXN0IGNhc2UsIHdyaXRlIGV2ZXJ5dGhpbmcgdXNpbmcgX3dyaXRldigpXG4gICAgdmFyIGwgPSBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudDtcbiAgICB2YXIgYnVmZmVyID0gbmV3IEFycmF5KGwpO1xuICAgIHZhciBob2xkZXIgPSBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWU7XG4gICAgaG9sZGVyLmVudHJ5ID0gZW50cnk7XG5cbiAgICB2YXIgY291bnQgPSAwO1xuICAgIHdoaWxlIChlbnRyeSkge1xuICAgICAgYnVmZmVyW2NvdW50XSA9IGVudHJ5O1xuICAgICAgZW50cnkgPSBlbnRyeS5uZXh0O1xuICAgICAgY291bnQgKz0gMTtcbiAgICB9XG5cbiAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIHRydWUsIHN0YXRlLmxlbmd0aCwgYnVmZmVyLCAnJywgaG9sZGVyLmZpbmlzaCk7XG5cbiAgICAvLyBkb1dyaXRlIGlzIGFsbW9zdCBhbHdheXMgYXN5bmMsIGRlZmVyIHRoZXNlIHRvIHNhdmUgYSBiaXQgb2YgdGltZVxuICAgIC8vIGFzIHRoZSBob3QgcGF0aCBlbmRzIHdpdGggZG9Xcml0ZVxuICAgIHN0YXRlLnBlbmRpbmdjYisrO1xuICAgIHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuICAgIGlmIChob2xkZXIubmV4dCkge1xuICAgICAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlID0gaG9sZGVyLm5leHQ7XG4gICAgICBob2xkZXIubmV4dCA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZSA9IG5ldyBDb3JrZWRSZXF1ZXN0KHN0YXRlKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gU2xvdyBjYXNlLCB3cml0ZSBjaHVua3Mgb25lLWJ5LW9uZVxuICAgIHdoaWxlIChlbnRyeSkge1xuICAgICAgdmFyIGNodW5rID0gZW50cnkuY2h1bms7XG4gICAgICB2YXIgZW5jb2RpbmcgPSBlbnRyeS5lbmNvZGluZztcbiAgICAgIHZhciBjYiA9IGVudHJ5LmNhbGxiYWNrO1xuICAgICAgdmFyIGxlbiA9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuXG4gICAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIGZhbHNlLCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpO1xuICAgICAgZW50cnkgPSBlbnRyeS5uZXh0O1xuICAgICAgLy8gaWYgd2UgZGlkbid0IGNhbGwgdGhlIG9ud3JpdGUgaW1tZWRpYXRlbHksIHRoZW5cbiAgICAgIC8vIGl0IG1lYW5zIHRoYXQgd2UgbmVlZCB0byB3YWl0IHVudGlsIGl0IGRvZXMuXG4gICAgICAvLyBhbHNvLCB0aGF0IG1lYW5zIHRoYXQgdGhlIGNodW5rIGFuZCBjYiBhcmUgY3VycmVudGx5XG4gICAgICAvLyBiZWluZyBwcm9jZXNzZWQsIHNvIG1vdmUgdGhlIGJ1ZmZlciBjb3VudGVyIHBhc3QgdGhlbS5cbiAgICAgIGlmIChzdGF0ZS53cml0aW5nKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChlbnRyeSA9PT0gbnVsbCkgc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG4gIH1cblxuICBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudCA9IDA7XG4gIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCA9IGVudHJ5O1xuICBzdGF0ZS5idWZmZXJQcm9jZXNzaW5nID0gZmFsc2U7XG59XG5cbldyaXRhYmxlLnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBjYihuZXcgRXJyb3IoJ193cml0ZSgpIGlzIG5vdCBpbXBsZW1lbnRlZCcpKTtcbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS5fd3JpdGV2ID0gbnVsbDtcblxuV3JpdGFibGUucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG5cbiAgaWYgKHR5cGVvZiBjaHVuayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gY2h1bms7XG4gICAgY2h1bmsgPSBudWxsO1xuICAgIGVuY29kaW5nID0gbnVsbDtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IGVuY29kaW5nO1xuICAgIGVuY29kaW5nID0gbnVsbDtcbiAgfVxuXG4gIGlmIChjaHVuayAhPT0gbnVsbCAmJiBjaHVuayAhPT0gdW5kZWZpbmVkKSB0aGlzLndyaXRlKGNodW5rLCBlbmNvZGluZyk7XG5cbiAgLy8gLmVuZCgpIGZ1bGx5IHVuY29ya3NcbiAgaWYgKHN0YXRlLmNvcmtlZCkge1xuICAgIHN0YXRlLmNvcmtlZCA9IDE7XG4gICAgdGhpcy51bmNvcmsoKTtcbiAgfVxuXG4gIC8vIGlnbm9yZSB1bm5lY2Vzc2FyeSBlbmQoKSBjYWxscy5cbiAgaWYgKCFzdGF0ZS5lbmRpbmcgJiYgIXN0YXRlLmZpbmlzaGVkKSBlbmRXcml0YWJsZSh0aGlzLCBzdGF0ZSwgY2IpO1xufTtcblxuZnVuY3Rpb24gbmVlZEZpbmlzaChzdGF0ZSkge1xuICByZXR1cm4gc3RhdGUuZW5kaW5nICYmIHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5idWZmZXJlZFJlcXVlc3QgPT09IG51bGwgJiYgIXN0YXRlLmZpbmlzaGVkICYmICFzdGF0ZS53cml0aW5nO1xufVxuXG5mdW5jdGlvbiBwcmVmaW5pc2goc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnByZWZpbmlzaGVkKSB7XG4gICAgc3RhdGUucHJlZmluaXNoZWQgPSB0cnVlO1xuICAgIHN0cmVhbS5lbWl0KCdwcmVmaW5pc2gnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKSB7XG4gIHZhciBuZWVkID0gbmVlZEZpbmlzaChzdGF0ZSk7XG4gIGlmIChuZWVkKSB7XG4gICAgaWYgKHN0YXRlLnBlbmRpbmdjYiA9PT0gMCkge1xuICAgICAgcHJlZmluaXNoKHN0cmVhbSwgc3RhdGUpO1xuICAgICAgc3RhdGUuZmluaXNoZWQgPSB0cnVlO1xuICAgICAgc3RyZWFtLmVtaXQoJ2ZpbmlzaCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcmVmaW5pc2goc3RyZWFtLCBzdGF0ZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBuZWVkO1xufVxuXG5mdW5jdGlvbiBlbmRXcml0YWJsZShzdHJlYW0sIHN0YXRlLCBjYikge1xuICBzdGF0ZS5lbmRpbmcgPSB0cnVlO1xuICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcbiAgaWYgKGNiKSB7XG4gICAgaWYgKHN0YXRlLmZpbmlzaGVkKSBwcm9jZXNzTmV4dFRpY2soY2IpO2Vsc2Ugc3RyZWFtLm9uY2UoJ2ZpbmlzaCcsIGNiKTtcbiAgfVxuICBzdGF0ZS5lbmRlZCA9IHRydWU7XG4gIHN0cmVhbS53cml0YWJsZSA9IGZhbHNlO1xufVxuXG4vLyBJdCBzZWVtcyBhIGxpbmtlZCBsaXN0IGJ1dCBpdCBpcyBub3Rcbi8vIHRoZXJlIHdpbGwgYmUgb25seSAyIG9mIHRoZXNlIGZvciBlYWNoIHN0cmVhbVxuZnVuY3Rpb24gQ29ya2VkUmVxdWVzdChzdGF0ZSkge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIHRoaXMubmV4dCA9IG51bGw7XG4gIHRoaXMuZW50cnkgPSBudWxsO1xuICB0aGlzLmZpbmlzaCA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICB2YXIgZW50cnkgPSBfdGhpcy5lbnRyeTtcbiAgICBfdGhpcy5lbnRyeSA9IG51bGw7XG4gICAgd2hpbGUgKGVudHJ5KSB7XG4gICAgICB2YXIgY2IgPSBlbnRyeS5jYWxsYmFjaztcbiAgICAgIHN0YXRlLnBlbmRpbmdjYi0tO1xuICAgICAgY2IoZXJyKTtcbiAgICAgIGVudHJ5ID0gZW50cnkubmV4dDtcbiAgICB9XG4gICAgaWYgKHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZSkge1xuICAgICAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlLm5leHQgPSBfdGhpcztcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlID0gX3RoaXM7XG4gICAgfVxuICB9O1xufSIsIid1c2Ugc3RyaWN0JztcblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlcjtcbi8qPHJlcGxhY2VtZW50PiovXG52YXIgYnVmZmVyU2hpbSA9IHJlcXVpcmUoJ2J1ZmZlci1zaGltcycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbm1vZHVsZS5leHBvcnRzID0gQnVmZmVyTGlzdDtcblxuZnVuY3Rpb24gQnVmZmVyTGlzdCgpIHtcbiAgdGhpcy5oZWFkID0gbnVsbDtcbiAgdGhpcy50YWlsID0gbnVsbDtcbiAgdGhpcy5sZW5ndGggPSAwO1xufVxuXG5CdWZmZXJMaXN0LnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKHYpIHtcbiAgdmFyIGVudHJ5ID0geyBkYXRhOiB2LCBuZXh0OiBudWxsIH07XG4gIGlmICh0aGlzLmxlbmd0aCA+IDApIHRoaXMudGFpbC5uZXh0ID0gZW50cnk7ZWxzZSB0aGlzLmhlYWQgPSBlbnRyeTtcbiAgdGhpcy50YWlsID0gZW50cnk7XG4gICsrdGhpcy5sZW5ndGg7XG59O1xuXG5CdWZmZXJMaXN0LnByb3RvdHlwZS51bnNoaWZ0ID0gZnVuY3Rpb24gKHYpIHtcbiAgdmFyIGVudHJ5ID0geyBkYXRhOiB2LCBuZXh0OiB0aGlzLmhlYWQgfTtcbiAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSB0aGlzLnRhaWwgPSBlbnRyeTtcbiAgdGhpcy5oZWFkID0gZW50cnk7XG4gICsrdGhpcy5sZW5ndGg7XG59O1xuXG5CdWZmZXJMaXN0LnByb3RvdHlwZS5zaGlmdCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm47XG4gIHZhciByZXQgPSB0aGlzLmhlYWQuZGF0YTtcbiAgaWYgKHRoaXMubGVuZ3RoID09PSAxKSB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBudWxsO2Vsc2UgdGhpcy5oZWFkID0gdGhpcy5oZWFkLm5leHQ7XG4gIC0tdGhpcy5sZW5ndGg7XG4gIHJldHVybiByZXQ7XG59O1xuXG5CdWZmZXJMaXN0LnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbnVsbDtcbiAgdGhpcy5sZW5ndGggPSAwO1xufTtcblxuQnVmZmVyTGlzdC5wcm90b3R5cGUuam9pbiA9IGZ1bmN0aW9uIChzKSB7XG4gIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuICcnO1xuICB2YXIgcCA9IHRoaXMuaGVhZDtcbiAgdmFyIHJldCA9ICcnICsgcC5kYXRhO1xuICB3aGlsZSAocCA9IHAubmV4dCkge1xuICAgIHJldCArPSBzICsgcC5kYXRhO1xuICB9cmV0dXJuIHJldDtcbn07XG5cbkJ1ZmZlckxpc3QucHJvdG90eXBlLmNvbmNhdCA9IGZ1bmN0aW9uIChuKSB7XG4gIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIGJ1ZmZlclNoaW0uYWxsb2MoMCk7XG4gIGlmICh0aGlzLmxlbmd0aCA9PT0gMSkgcmV0dXJuIHRoaXMuaGVhZC5kYXRhO1xuICB2YXIgcmV0ID0gYnVmZmVyU2hpbS5hbGxvY1Vuc2FmZShuID4+PiAwKTtcbiAgdmFyIHAgPSB0aGlzLmhlYWQ7XG4gIHZhciBpID0gMDtcbiAgd2hpbGUgKHApIHtcbiAgICBwLmRhdGEuY29weShyZXQsIGkpO1xuICAgIGkgKz0gcC5kYXRhLmxlbmd0aDtcbiAgICBwID0gcC5uZXh0O1xuICB9XG4gIHJldHVybiByZXQ7XG59OyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vbGliL19zdHJlYW1fdHJhbnNmb3JtLmpzXCIpXG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlcjtcblxudmFyIGlzQnVmZmVyRW5jb2RpbmcgPSBCdWZmZXIuaXNFbmNvZGluZ1xuICB8fCBmdW5jdGlvbihlbmNvZGluZykge1xuICAgICAgIHN3aXRjaCAoZW5jb2RpbmcgJiYgZW5jb2RpbmcudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgY2FzZSAnaGV4JzogY2FzZSAndXRmOCc6IGNhc2UgJ3V0Zi04JzogY2FzZSAnYXNjaWknOiBjYXNlICdiaW5hcnknOiBjYXNlICdiYXNlNjQnOiBjYXNlICd1Y3MyJzogY2FzZSAndWNzLTInOiBjYXNlICd1dGYxNmxlJzogY2FzZSAndXRmLTE2bGUnOiBjYXNlICdyYXcnOiByZXR1cm4gdHJ1ZTtcbiAgICAgICAgIGRlZmF1bHQ6IHJldHVybiBmYWxzZTtcbiAgICAgICB9XG4gICAgIH1cblxuXG5mdW5jdGlvbiBhc3NlcnRFbmNvZGluZyhlbmNvZGluZykge1xuICBpZiAoZW5jb2RpbmcgJiYgIWlzQnVmZmVyRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpO1xuICB9XG59XG5cbi8vIFN0cmluZ0RlY29kZXIgcHJvdmlkZXMgYW4gaW50ZXJmYWNlIGZvciBlZmZpY2llbnRseSBzcGxpdHRpbmcgYSBzZXJpZXMgb2Zcbi8vIGJ1ZmZlcnMgaW50byBhIHNlcmllcyBvZiBKUyBzdHJpbmdzIHdpdGhvdXQgYnJlYWtpbmcgYXBhcnQgbXVsdGktYnl0ZVxuLy8gY2hhcmFjdGVycy4gQ0VTVS04IGlzIGhhbmRsZWQgYXMgcGFydCBvZiB0aGUgVVRGLTggZW5jb2RpbmcuXG4vL1xuLy8gQFRPRE8gSGFuZGxpbmcgYWxsIGVuY29kaW5ncyBpbnNpZGUgYSBzaW5nbGUgb2JqZWN0IG1ha2VzIGl0IHZlcnkgZGlmZmljdWx0XG4vLyB0byByZWFzb24gYWJvdXQgdGhpcyBjb2RlLCBzbyBpdCBzaG91bGQgYmUgc3BsaXQgdXAgaW4gdGhlIGZ1dHVyZS5cbi8vIEBUT0RPIFRoZXJlIHNob3VsZCBiZSBhIHV0Zjgtc3RyaWN0IGVuY29kaW5nIHRoYXQgcmVqZWN0cyBpbnZhbGlkIFVURi04IGNvZGVcbi8vIHBvaW50cyBhcyB1c2VkIGJ5IENFU1UtOC5cbnZhciBTdHJpbmdEZWNvZGVyID0gZXhwb3J0cy5TdHJpbmdEZWNvZGVyID0gZnVuY3Rpb24oZW5jb2RpbmcpIHtcbiAgdGhpcy5lbmNvZGluZyA9IChlbmNvZGluZyB8fCAndXRmOCcpLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvWy1fXS8sICcnKTtcbiAgYXNzZXJ0RW5jb2RpbmcoZW5jb2RpbmcpO1xuICBzd2l0Y2ggKHRoaXMuZW5jb2RpbmcpIHtcbiAgICBjYXNlICd1dGY4JzpcbiAgICAgIC8vIENFU1UtOCByZXByZXNlbnRzIGVhY2ggb2YgU3Vycm9nYXRlIFBhaXIgYnkgMy1ieXRlc1xuICAgICAgdGhpcy5zdXJyb2dhdGVTaXplID0gMztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgLy8gVVRGLTE2IHJlcHJlc2VudHMgZWFjaCBvZiBTdXJyb2dhdGUgUGFpciBieSAyLWJ5dGVzXG4gICAgICB0aGlzLnN1cnJvZ2F0ZVNpemUgPSAyO1xuICAgICAgdGhpcy5kZXRlY3RJbmNvbXBsZXRlQ2hhciA9IHV0ZjE2RGV0ZWN0SW5jb21wbGV0ZUNoYXI7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgLy8gQmFzZS02NCBzdG9yZXMgMyBieXRlcyBpbiA0IGNoYXJzLCBhbmQgcGFkcyB0aGUgcmVtYWluZGVyLlxuICAgICAgdGhpcy5zdXJyb2dhdGVTaXplID0gMztcbiAgICAgIHRoaXMuZGV0ZWN0SW5jb21wbGV0ZUNoYXIgPSBiYXNlNjREZXRlY3RJbmNvbXBsZXRlQ2hhcjtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aGlzLndyaXRlID0gcGFzc1Rocm91Z2hXcml0ZTtcbiAgICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIEVub3VnaCBzcGFjZSB0byBzdG9yZSBhbGwgYnl0ZXMgb2YgYSBzaW5nbGUgY2hhcmFjdGVyLiBVVEYtOCBuZWVkcyA0XG4gIC8vIGJ5dGVzLCBidXQgQ0VTVS04IG1heSByZXF1aXJlIHVwIHRvIDYgKDMgYnl0ZXMgcGVyIHN1cnJvZ2F0ZSkuXG4gIHRoaXMuY2hhckJ1ZmZlciA9IG5ldyBCdWZmZXIoNik7XG4gIC8vIE51bWJlciBvZiBieXRlcyByZWNlaXZlZCBmb3IgdGhlIGN1cnJlbnQgaW5jb21wbGV0ZSBtdWx0aS1ieXRlIGNoYXJhY3Rlci5cbiAgdGhpcy5jaGFyUmVjZWl2ZWQgPSAwO1xuICAvLyBOdW1iZXIgb2YgYnl0ZXMgZXhwZWN0ZWQgZm9yIHRoZSBjdXJyZW50IGluY29tcGxldGUgbXVsdGktYnl0ZSBjaGFyYWN0ZXIuXG4gIHRoaXMuY2hhckxlbmd0aCA9IDA7XG59O1xuXG5cbi8vIHdyaXRlIGRlY29kZXMgdGhlIGdpdmVuIGJ1ZmZlciBhbmQgcmV0dXJucyBpdCBhcyBKUyBzdHJpbmcgdGhhdCBpc1xuLy8gZ3VhcmFudGVlZCB0byBub3QgY29udGFpbiBhbnkgcGFydGlhbCBtdWx0aS1ieXRlIGNoYXJhY3RlcnMuIEFueSBwYXJ0aWFsXG4vLyBjaGFyYWN0ZXIgZm91bmQgYXQgdGhlIGVuZCBvZiB0aGUgYnVmZmVyIGlzIGJ1ZmZlcmVkIHVwLCBhbmQgd2lsbCBiZVxuLy8gcmV0dXJuZWQgd2hlbiBjYWxsaW5nIHdyaXRlIGFnYWluIHdpdGggdGhlIHJlbWFpbmluZyBieXRlcy5cbi8vXG4vLyBOb3RlOiBDb252ZXJ0aW5nIGEgQnVmZmVyIGNvbnRhaW5pbmcgYW4gb3JwaGFuIHN1cnJvZ2F0ZSB0byBhIFN0cmluZ1xuLy8gY3VycmVudGx5IHdvcmtzLCBidXQgY29udmVydGluZyBhIFN0cmluZyB0byBhIEJ1ZmZlciAodmlhIGBuZXcgQnVmZmVyYCwgb3Jcbi8vIEJ1ZmZlciN3cml0ZSkgd2lsbCByZXBsYWNlIGluY29tcGxldGUgc3Vycm9nYXRlcyB3aXRoIHRoZSB1bmljb2RlXG4vLyByZXBsYWNlbWVudCBjaGFyYWN0ZXIuIFNlZSBodHRwczovL2NvZGVyZXZpZXcuY2hyb21pdW0ub3JnLzEyMTE3MzAwOS8gLlxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbihidWZmZXIpIHtcbiAgdmFyIGNoYXJTdHIgPSAnJztcbiAgLy8gaWYgb3VyIGxhc3Qgd3JpdGUgZW5kZWQgd2l0aCBhbiBpbmNvbXBsZXRlIG11bHRpYnl0ZSBjaGFyYWN0ZXJcbiAgd2hpbGUgKHRoaXMuY2hhckxlbmd0aCkge1xuICAgIC8vIGRldGVybWluZSBob3cgbWFueSByZW1haW5pbmcgYnl0ZXMgdGhpcyBidWZmZXIgaGFzIHRvIG9mZmVyIGZvciB0aGlzIGNoYXJcbiAgICB2YXIgYXZhaWxhYmxlID0gKGJ1ZmZlci5sZW5ndGggPj0gdGhpcy5jaGFyTGVuZ3RoIC0gdGhpcy5jaGFyUmVjZWl2ZWQpID9cbiAgICAgICAgdGhpcy5jaGFyTGVuZ3RoIC0gdGhpcy5jaGFyUmVjZWl2ZWQgOlxuICAgICAgICBidWZmZXIubGVuZ3RoO1xuXG4gICAgLy8gYWRkIHRoZSBuZXcgYnl0ZXMgdG8gdGhlIGNoYXIgYnVmZmVyXG4gICAgYnVmZmVyLmNvcHkodGhpcy5jaGFyQnVmZmVyLCB0aGlzLmNoYXJSZWNlaXZlZCwgMCwgYXZhaWxhYmxlKTtcbiAgICB0aGlzLmNoYXJSZWNlaXZlZCArPSBhdmFpbGFibGU7XG5cbiAgICBpZiAodGhpcy5jaGFyUmVjZWl2ZWQgPCB0aGlzLmNoYXJMZW5ndGgpIHtcbiAgICAgIC8vIHN0aWxsIG5vdCBlbm91Z2ggY2hhcnMgaW4gdGhpcyBidWZmZXI/IHdhaXQgZm9yIG1vcmUgLi4uXG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuXG4gICAgLy8gcmVtb3ZlIGJ5dGVzIGJlbG9uZ2luZyB0byB0aGUgY3VycmVudCBjaGFyYWN0ZXIgZnJvbSB0aGUgYnVmZmVyXG4gICAgYnVmZmVyID0gYnVmZmVyLnNsaWNlKGF2YWlsYWJsZSwgYnVmZmVyLmxlbmd0aCk7XG5cbiAgICAvLyBnZXQgdGhlIGNoYXJhY3RlciB0aGF0IHdhcyBzcGxpdFxuICAgIGNoYXJTdHIgPSB0aGlzLmNoYXJCdWZmZXIuc2xpY2UoMCwgdGhpcy5jaGFyTGVuZ3RoKS50b1N0cmluZyh0aGlzLmVuY29kaW5nKTtcblxuICAgIC8vIENFU1UtODogbGVhZCBzdXJyb2dhdGUgKEQ4MDAtREJGRikgaXMgYWxzbyB0aGUgaW5jb21wbGV0ZSBjaGFyYWN0ZXJcbiAgICB2YXIgY2hhckNvZGUgPSBjaGFyU3RyLmNoYXJDb2RlQXQoY2hhclN0ci5sZW5ndGggLSAxKTtcbiAgICBpZiAoY2hhckNvZGUgPj0gMHhEODAwICYmIGNoYXJDb2RlIDw9IDB4REJGRikge1xuICAgICAgdGhpcy5jaGFyTGVuZ3RoICs9IHRoaXMuc3Vycm9nYXRlU2l6ZTtcbiAgICAgIGNoYXJTdHIgPSAnJztcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB0aGlzLmNoYXJSZWNlaXZlZCA9IHRoaXMuY2hhckxlbmd0aCA9IDA7XG5cbiAgICAvLyBpZiB0aGVyZSBhcmUgbm8gbW9yZSBieXRlcyBpbiB0aGlzIGJ1ZmZlciwganVzdCBlbWl0IG91ciBjaGFyXG4gICAgaWYgKGJ1ZmZlci5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBjaGFyU3RyO1xuICAgIH1cbiAgICBicmVhaztcbiAgfVxuXG4gIC8vIGRldGVybWluZSBhbmQgc2V0IGNoYXJMZW5ndGggLyBjaGFyUmVjZWl2ZWRcbiAgdGhpcy5kZXRlY3RJbmNvbXBsZXRlQ2hhcihidWZmZXIpO1xuXG4gIHZhciBlbmQgPSBidWZmZXIubGVuZ3RoO1xuICBpZiAodGhpcy5jaGFyTGVuZ3RoKSB7XG4gICAgLy8gYnVmZmVyIHRoZSBpbmNvbXBsZXRlIGNoYXJhY3RlciBieXRlcyB3ZSBnb3RcbiAgICBidWZmZXIuY29weSh0aGlzLmNoYXJCdWZmZXIsIDAsIGJ1ZmZlci5sZW5ndGggLSB0aGlzLmNoYXJSZWNlaXZlZCwgZW5kKTtcbiAgICBlbmQgLT0gdGhpcy5jaGFyUmVjZWl2ZWQ7XG4gIH1cblxuICBjaGFyU3RyICs9IGJ1ZmZlci50b1N0cmluZyh0aGlzLmVuY29kaW5nLCAwLCBlbmQpO1xuXG4gIHZhciBlbmQgPSBjaGFyU3RyLmxlbmd0aCAtIDE7XG4gIHZhciBjaGFyQ29kZSA9IGNoYXJTdHIuY2hhckNvZGVBdChlbmQpO1xuICAvLyBDRVNVLTg6IGxlYWQgc3Vycm9nYXRlIChEODAwLURCRkYpIGlzIGFsc28gdGhlIGluY29tcGxldGUgY2hhcmFjdGVyXG4gIGlmIChjaGFyQ29kZSA+PSAweEQ4MDAgJiYgY2hhckNvZGUgPD0gMHhEQkZGKSB7XG4gICAgdmFyIHNpemUgPSB0aGlzLnN1cnJvZ2F0ZVNpemU7XG4gICAgdGhpcy5jaGFyTGVuZ3RoICs9IHNpemU7XG4gICAgdGhpcy5jaGFyUmVjZWl2ZWQgKz0gc2l6ZTtcbiAgICB0aGlzLmNoYXJCdWZmZXIuY29weSh0aGlzLmNoYXJCdWZmZXIsIHNpemUsIDAsIHNpemUpO1xuICAgIGJ1ZmZlci5jb3B5KHRoaXMuY2hhckJ1ZmZlciwgMCwgMCwgc2l6ZSk7XG4gICAgcmV0dXJuIGNoYXJTdHIuc3Vic3RyaW5nKDAsIGVuZCk7XG4gIH1cblxuICAvLyBvciBqdXN0IGVtaXQgdGhlIGNoYXJTdHJcbiAgcmV0dXJuIGNoYXJTdHI7XG59O1xuXG4vLyBkZXRlY3RJbmNvbXBsZXRlQ2hhciBkZXRlcm1pbmVzIGlmIHRoZXJlIGlzIGFuIGluY29tcGxldGUgVVRGLTggY2hhcmFjdGVyIGF0XG4vLyB0aGUgZW5kIG9mIHRoZSBnaXZlbiBidWZmZXIuIElmIHNvLCBpdCBzZXRzIHRoaXMuY2hhckxlbmd0aCB0byB0aGUgYnl0ZVxuLy8gbGVuZ3RoIHRoYXQgY2hhcmFjdGVyLCBhbmQgc2V0cyB0aGlzLmNoYXJSZWNlaXZlZCB0byB0aGUgbnVtYmVyIG9mIGJ5dGVzXG4vLyB0aGF0IGFyZSBhdmFpbGFibGUgZm9yIHRoaXMgY2hhcmFjdGVyLlxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUuZGV0ZWN0SW5jb21wbGV0ZUNoYXIgPSBmdW5jdGlvbihidWZmZXIpIHtcbiAgLy8gZGV0ZXJtaW5lIGhvdyBtYW55IGJ5dGVzIHdlIGhhdmUgdG8gY2hlY2sgYXQgdGhlIGVuZCBvZiB0aGlzIGJ1ZmZlclxuICB2YXIgaSA9IChidWZmZXIubGVuZ3RoID49IDMpID8gMyA6IGJ1ZmZlci5sZW5ndGg7XG5cbiAgLy8gRmlndXJlIG91dCBpZiBvbmUgb2YgdGhlIGxhc3QgaSBieXRlcyBvZiBvdXIgYnVmZmVyIGFubm91bmNlcyBhblxuICAvLyBpbmNvbXBsZXRlIGNoYXIuXG4gIGZvciAoOyBpID4gMDsgaS0tKSB7XG4gICAgdmFyIGMgPSBidWZmZXJbYnVmZmVyLmxlbmd0aCAtIGldO1xuXG4gICAgLy8gU2VlIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVVRGLTgjRGVzY3JpcHRpb25cblxuICAgIC8vIDExMFhYWFhYXG4gICAgaWYgKGkgPT0gMSAmJiBjID4+IDUgPT0gMHgwNikge1xuICAgICAgdGhpcy5jaGFyTGVuZ3RoID0gMjtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8vIDExMTBYWFhYXG4gICAgaWYgKGkgPD0gMiAmJiBjID4+IDQgPT0gMHgwRSkge1xuICAgICAgdGhpcy5jaGFyTGVuZ3RoID0gMztcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8vIDExMTEwWFhYXG4gICAgaWYgKGkgPD0gMyAmJiBjID4+IDMgPT0gMHgxRSkge1xuICAgICAgdGhpcy5jaGFyTGVuZ3RoID0gNDtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICB0aGlzLmNoYXJSZWNlaXZlZCA9IGk7XG59O1xuXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbihidWZmZXIpIHtcbiAgdmFyIHJlcyA9ICcnO1xuICBpZiAoYnVmZmVyICYmIGJ1ZmZlci5sZW5ndGgpXG4gICAgcmVzID0gdGhpcy53cml0ZShidWZmZXIpO1xuXG4gIGlmICh0aGlzLmNoYXJSZWNlaXZlZCkge1xuICAgIHZhciBjciA9IHRoaXMuY2hhclJlY2VpdmVkO1xuICAgIHZhciBidWYgPSB0aGlzLmNoYXJCdWZmZXI7XG4gICAgdmFyIGVuYyA9IHRoaXMuZW5jb2Rpbmc7XG4gICAgcmVzICs9IGJ1Zi5zbGljZSgwLCBjcikudG9TdHJpbmcoZW5jKTtcbiAgfVxuXG4gIHJldHVybiByZXM7XG59O1xuXG5mdW5jdGlvbiBwYXNzVGhyb3VnaFdyaXRlKGJ1ZmZlcikge1xuICByZXR1cm4gYnVmZmVyLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcpO1xufVxuXG5mdW5jdGlvbiB1dGYxNkRldGVjdEluY29tcGxldGVDaGFyKGJ1ZmZlcikge1xuICB0aGlzLmNoYXJSZWNlaXZlZCA9IGJ1ZmZlci5sZW5ndGggJSAyO1xuICB0aGlzLmNoYXJMZW5ndGggPSB0aGlzLmNoYXJSZWNlaXZlZCA/IDIgOiAwO1xufVxuXG5mdW5jdGlvbiBiYXNlNjREZXRlY3RJbmNvbXBsZXRlQ2hhcihidWZmZXIpIHtcbiAgdGhpcy5jaGFyUmVjZWl2ZWQgPSBidWZmZXIubGVuZ3RoICUgMztcbiAgdGhpcy5jaGFyTGVuZ3RoID0gdGhpcy5jaGFyUmVjZWl2ZWQgPyAzIDogMDtcbn1cbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBwdW55Y29kZSA9IHJlcXVpcmUoJ3B1bnljb2RlJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG5leHBvcnRzLnBhcnNlID0gdXJsUGFyc2U7XG5leHBvcnRzLnJlc29sdmUgPSB1cmxSZXNvbHZlO1xuZXhwb3J0cy5yZXNvbHZlT2JqZWN0ID0gdXJsUmVzb2x2ZU9iamVjdDtcbmV4cG9ydHMuZm9ybWF0ID0gdXJsRm9ybWF0O1xuXG5leHBvcnRzLlVybCA9IFVybDtcblxuZnVuY3Rpb24gVXJsKCkge1xuICB0aGlzLnByb3RvY29sID0gbnVsbDtcbiAgdGhpcy5zbGFzaGVzID0gbnVsbDtcbiAgdGhpcy5hdXRoID0gbnVsbDtcbiAgdGhpcy5ob3N0ID0gbnVsbDtcbiAgdGhpcy5wb3J0ID0gbnVsbDtcbiAgdGhpcy5ob3N0bmFtZSA9IG51bGw7XG4gIHRoaXMuaGFzaCA9IG51bGw7XG4gIHRoaXMuc2VhcmNoID0gbnVsbDtcbiAgdGhpcy5xdWVyeSA9IG51bGw7XG4gIHRoaXMucGF0aG5hbWUgPSBudWxsO1xuICB0aGlzLnBhdGggPSBudWxsO1xuICB0aGlzLmhyZWYgPSBudWxsO1xufVxuXG4vLyBSZWZlcmVuY2U6IFJGQyAzOTg2LCBSRkMgMTgwOCwgUkZDIDIzOTZcblxuLy8gZGVmaW5lIHRoZXNlIGhlcmUgc28gYXQgbGVhc3QgdGhleSBvbmx5IGhhdmUgdG8gYmVcbi8vIGNvbXBpbGVkIG9uY2Ugb24gdGhlIGZpcnN0IG1vZHVsZSBsb2FkLlxudmFyIHByb3RvY29sUGF0dGVybiA9IC9eKFthLXowLTkuKy1dKzopL2ksXG4gICAgcG9ydFBhdHRlcm4gPSAvOlswLTldKiQvLFxuXG4gICAgLy8gU3BlY2lhbCBjYXNlIGZvciBhIHNpbXBsZSBwYXRoIFVSTFxuICAgIHNpbXBsZVBhdGhQYXR0ZXJuID0gL14oXFwvXFwvPyg/IVxcLylbXlxcP1xcc10qKShcXD9bXlxcc10qKT8kLyxcblxuICAgIC8vIFJGQyAyMzk2OiBjaGFyYWN0ZXJzIHJlc2VydmVkIGZvciBkZWxpbWl0aW5nIFVSTHMuXG4gICAgLy8gV2UgYWN0dWFsbHkganVzdCBhdXRvLWVzY2FwZSB0aGVzZS5cbiAgICBkZWxpbXMgPSBbJzwnLCAnPicsICdcIicsICdgJywgJyAnLCAnXFxyJywgJ1xcbicsICdcXHQnXSxcblxuICAgIC8vIFJGQyAyMzk2OiBjaGFyYWN0ZXJzIG5vdCBhbGxvd2VkIGZvciB2YXJpb3VzIHJlYXNvbnMuXG4gICAgdW53aXNlID0gWyd7JywgJ30nLCAnfCcsICdcXFxcJywgJ14nLCAnYCddLmNvbmNhdChkZWxpbXMpLFxuXG4gICAgLy8gQWxsb3dlZCBieSBSRkNzLCBidXQgY2F1c2Ugb2YgWFNTIGF0dGFja3MuICBBbHdheXMgZXNjYXBlIHRoZXNlLlxuICAgIGF1dG9Fc2NhcGUgPSBbJ1xcJyddLmNvbmNhdCh1bndpc2UpLFxuICAgIC8vIENoYXJhY3RlcnMgdGhhdCBhcmUgbmV2ZXIgZXZlciBhbGxvd2VkIGluIGEgaG9zdG5hbWUuXG4gICAgLy8gTm90ZSB0aGF0IGFueSBpbnZhbGlkIGNoYXJzIGFyZSBhbHNvIGhhbmRsZWQsIGJ1dCB0aGVzZVxuICAgIC8vIGFyZSB0aGUgb25lcyB0aGF0IGFyZSAqZXhwZWN0ZWQqIHRvIGJlIHNlZW4sIHNvIHdlIGZhc3QtcGF0aFxuICAgIC8vIHRoZW0uXG4gICAgbm9uSG9zdENoYXJzID0gWyclJywgJy8nLCAnPycsICc7JywgJyMnXS5jb25jYXQoYXV0b0VzY2FwZSksXG4gICAgaG9zdEVuZGluZ0NoYXJzID0gWycvJywgJz8nLCAnIyddLFxuICAgIGhvc3RuYW1lTWF4TGVuID0gMjU1LFxuICAgIGhvc3RuYW1lUGFydFBhdHRlcm4gPSAvXlsrYS16MC05QS1aXy1dezAsNjN9JC8sXG4gICAgaG9zdG5hbWVQYXJ0U3RhcnQgPSAvXihbK2EtejAtOUEtWl8tXXswLDYzfSkoLiopJC8sXG4gICAgLy8gcHJvdG9jb2xzIHRoYXQgY2FuIGFsbG93IFwidW5zYWZlXCIgYW5kIFwidW53aXNlXCIgY2hhcnMuXG4gICAgdW5zYWZlUHJvdG9jb2wgPSB7XG4gICAgICAnamF2YXNjcmlwdCc6IHRydWUsXG4gICAgICAnamF2YXNjcmlwdDonOiB0cnVlXG4gICAgfSxcbiAgICAvLyBwcm90b2NvbHMgdGhhdCBuZXZlciBoYXZlIGEgaG9zdG5hbWUuXG4gICAgaG9zdGxlc3NQcm90b2NvbCA9IHtcbiAgICAgICdqYXZhc2NyaXB0JzogdHJ1ZSxcbiAgICAgICdqYXZhc2NyaXB0Oic6IHRydWVcbiAgICB9LFxuICAgIC8vIHByb3RvY29scyB0aGF0IGFsd2F5cyBjb250YWluIGEgLy8gYml0LlxuICAgIHNsYXNoZWRQcm90b2NvbCA9IHtcbiAgICAgICdodHRwJzogdHJ1ZSxcbiAgICAgICdodHRwcyc6IHRydWUsXG4gICAgICAnZnRwJzogdHJ1ZSxcbiAgICAgICdnb3BoZXInOiB0cnVlLFxuICAgICAgJ2ZpbGUnOiB0cnVlLFxuICAgICAgJ2h0dHA6JzogdHJ1ZSxcbiAgICAgICdodHRwczonOiB0cnVlLFxuICAgICAgJ2Z0cDonOiB0cnVlLFxuICAgICAgJ2dvcGhlcjonOiB0cnVlLFxuICAgICAgJ2ZpbGU6JzogdHJ1ZVxuICAgIH0sXG4gICAgcXVlcnlzdHJpbmcgPSByZXF1aXJlKCdxdWVyeXN0cmluZycpO1xuXG5mdW5jdGlvbiB1cmxQYXJzZSh1cmwsIHBhcnNlUXVlcnlTdHJpbmcsIHNsYXNoZXNEZW5vdGVIb3N0KSB7XG4gIGlmICh1cmwgJiYgdXRpbC5pc09iamVjdCh1cmwpICYmIHVybCBpbnN0YW5jZW9mIFVybCkgcmV0dXJuIHVybDtcblxuICB2YXIgdSA9IG5ldyBVcmw7XG4gIHUucGFyc2UodXJsLCBwYXJzZVF1ZXJ5U3RyaW5nLCBzbGFzaGVzRGVub3RlSG9zdCk7XG4gIHJldHVybiB1O1xufVxuXG5VcmwucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24odXJsLCBwYXJzZVF1ZXJ5U3RyaW5nLCBzbGFzaGVzRGVub3RlSG9zdCkge1xuICBpZiAoIXV0aWwuaXNTdHJpbmcodXJsKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQYXJhbWV0ZXIgJ3VybCcgbXVzdCBiZSBhIHN0cmluZywgbm90IFwiICsgdHlwZW9mIHVybCk7XG4gIH1cblxuICAvLyBDb3B5IGNocm9tZSwgSUUsIG9wZXJhIGJhY2tzbGFzaC1oYW5kbGluZyBiZWhhdmlvci5cbiAgLy8gQmFjayBzbGFzaGVzIGJlZm9yZSB0aGUgcXVlcnkgc3RyaW5nIGdldCBjb252ZXJ0ZWQgdG8gZm9yd2FyZCBzbGFzaGVzXG4gIC8vIFNlZTogaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTI1OTE2XG4gIHZhciBxdWVyeUluZGV4ID0gdXJsLmluZGV4T2YoJz8nKSxcbiAgICAgIHNwbGl0dGVyID1cbiAgICAgICAgICAocXVlcnlJbmRleCAhPT0gLTEgJiYgcXVlcnlJbmRleCA8IHVybC5pbmRleE9mKCcjJykpID8gJz8nIDogJyMnLFxuICAgICAgdVNwbGl0ID0gdXJsLnNwbGl0KHNwbGl0dGVyKSxcbiAgICAgIHNsYXNoUmVnZXggPSAvXFxcXC9nO1xuICB1U3BsaXRbMF0gPSB1U3BsaXRbMF0ucmVwbGFjZShzbGFzaFJlZ2V4LCAnLycpO1xuICB1cmwgPSB1U3BsaXQuam9pbihzcGxpdHRlcik7XG5cbiAgdmFyIHJlc3QgPSB1cmw7XG5cbiAgLy8gdHJpbSBiZWZvcmUgcHJvY2VlZGluZy5cbiAgLy8gVGhpcyBpcyB0byBzdXBwb3J0IHBhcnNlIHN0dWZmIGxpa2UgXCIgIGh0dHA6Ly9mb28uY29tICBcXG5cIlxuICByZXN0ID0gcmVzdC50cmltKCk7XG5cbiAgaWYgKCFzbGFzaGVzRGVub3RlSG9zdCAmJiB1cmwuc3BsaXQoJyMnKS5sZW5ndGggPT09IDEpIHtcbiAgICAvLyBUcnkgZmFzdCBwYXRoIHJlZ2V4cFxuICAgIHZhciBzaW1wbGVQYXRoID0gc2ltcGxlUGF0aFBhdHRlcm4uZXhlYyhyZXN0KTtcbiAgICBpZiAoc2ltcGxlUGF0aCkge1xuICAgICAgdGhpcy5wYXRoID0gcmVzdDtcbiAgICAgIHRoaXMuaHJlZiA9IHJlc3Q7XG4gICAgICB0aGlzLnBhdGhuYW1lID0gc2ltcGxlUGF0aFsxXTtcbiAgICAgIGlmIChzaW1wbGVQYXRoWzJdKSB7XG4gICAgICAgIHRoaXMuc2VhcmNoID0gc2ltcGxlUGF0aFsyXTtcbiAgICAgICAgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAgICAgICB0aGlzLnF1ZXJ5ID0gcXVlcnlzdHJpbmcucGFyc2UodGhpcy5zZWFyY2guc3Vic3RyKDEpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnF1ZXJ5ID0gdGhpcy5zZWFyY2guc3Vic3RyKDEpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAgICAgdGhpcy5zZWFyY2ggPSAnJztcbiAgICAgICAgdGhpcy5xdWVyeSA9IHt9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9XG5cbiAgdmFyIHByb3RvID0gcHJvdG9jb2xQYXR0ZXJuLmV4ZWMocmVzdCk7XG4gIGlmIChwcm90bykge1xuICAgIHByb3RvID0gcHJvdG9bMF07XG4gICAgdmFyIGxvd2VyUHJvdG8gPSBwcm90by50b0xvd2VyQ2FzZSgpO1xuICAgIHRoaXMucHJvdG9jb2wgPSBsb3dlclByb3RvO1xuICAgIHJlc3QgPSByZXN0LnN1YnN0cihwcm90by5sZW5ndGgpO1xuICB9XG5cbiAgLy8gZmlndXJlIG91dCBpZiBpdCdzIGdvdCBhIGhvc3RcbiAgLy8gdXNlckBzZXJ2ZXIgaXMgKmFsd2F5cyogaW50ZXJwcmV0ZWQgYXMgYSBob3N0bmFtZSwgYW5kIHVybFxuICAvLyByZXNvbHV0aW9uIHdpbGwgdHJlYXQgLy9mb28vYmFyIGFzIGhvc3Q9Zm9vLHBhdGg9YmFyIGJlY2F1c2UgdGhhdCdzXG4gIC8vIGhvdyB0aGUgYnJvd3NlciByZXNvbHZlcyByZWxhdGl2ZSBVUkxzLlxuICBpZiAoc2xhc2hlc0Rlbm90ZUhvc3QgfHwgcHJvdG8gfHwgcmVzdC5tYXRjaCgvXlxcL1xcL1teQFxcL10rQFteQFxcL10rLykpIHtcbiAgICB2YXIgc2xhc2hlcyA9IHJlc3Quc3Vic3RyKDAsIDIpID09PSAnLy8nO1xuICAgIGlmIChzbGFzaGVzICYmICEocHJvdG8gJiYgaG9zdGxlc3NQcm90b2NvbFtwcm90b10pKSB7XG4gICAgICByZXN0ID0gcmVzdC5zdWJzdHIoMik7XG4gICAgICB0aGlzLnNsYXNoZXMgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGlmICghaG9zdGxlc3NQcm90b2NvbFtwcm90b10gJiZcbiAgICAgIChzbGFzaGVzIHx8IChwcm90byAmJiAhc2xhc2hlZFByb3RvY29sW3Byb3RvXSkpKSB7XG5cbiAgICAvLyB0aGVyZSdzIGEgaG9zdG5hbWUuXG4gICAgLy8gdGhlIGZpcnN0IGluc3RhbmNlIG9mIC8sID8sIDssIG9yICMgZW5kcyB0aGUgaG9zdC5cbiAgICAvL1xuICAgIC8vIElmIHRoZXJlIGlzIGFuIEAgaW4gdGhlIGhvc3RuYW1lLCB0aGVuIG5vbi1ob3N0IGNoYXJzICphcmUqIGFsbG93ZWRcbiAgICAvLyB0byB0aGUgbGVmdCBvZiB0aGUgbGFzdCBAIHNpZ24sIHVubGVzcyBzb21lIGhvc3QtZW5kaW5nIGNoYXJhY3RlclxuICAgIC8vIGNvbWVzICpiZWZvcmUqIHRoZSBALXNpZ24uXG4gICAgLy8gVVJMcyBhcmUgb2Jub3hpb3VzLlxuICAgIC8vXG4gICAgLy8gZXg6XG4gICAgLy8gaHR0cDovL2FAYkBjLyA9PiB1c2VyOmFAYiBob3N0OmNcbiAgICAvLyBodHRwOi8vYUBiP0BjID0+IHVzZXI6YSBob3N0OmMgcGF0aDovP0BjXG5cbiAgICAvLyB2MC4xMiBUT0RPKGlzYWFjcyk6IFRoaXMgaXMgbm90IHF1aXRlIGhvdyBDaHJvbWUgZG9lcyB0aGluZ3MuXG4gICAgLy8gUmV2aWV3IG91ciB0ZXN0IGNhc2UgYWdhaW5zdCBicm93c2VycyBtb3JlIGNvbXByZWhlbnNpdmVseS5cblxuICAgIC8vIGZpbmQgdGhlIGZpcnN0IGluc3RhbmNlIG9mIGFueSBob3N0RW5kaW5nQ2hhcnNcbiAgICB2YXIgaG9zdEVuZCA9IC0xO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaG9zdEVuZGluZ0NoYXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaGVjID0gcmVzdC5pbmRleE9mKGhvc3RFbmRpbmdDaGFyc1tpXSk7XG4gICAgICBpZiAoaGVjICE9PSAtMSAmJiAoaG9zdEVuZCA9PT0gLTEgfHwgaGVjIDwgaG9zdEVuZCkpXG4gICAgICAgIGhvc3RFbmQgPSBoZWM7XG4gICAgfVxuXG4gICAgLy8gYXQgdGhpcyBwb2ludCwgZWl0aGVyIHdlIGhhdmUgYW4gZXhwbGljaXQgcG9pbnQgd2hlcmUgdGhlXG4gICAgLy8gYXV0aCBwb3J0aW9uIGNhbm5vdCBnbyBwYXN0LCBvciB0aGUgbGFzdCBAIGNoYXIgaXMgdGhlIGRlY2lkZXIuXG4gICAgdmFyIGF1dGgsIGF0U2lnbjtcbiAgICBpZiAoaG9zdEVuZCA9PT0gLTEpIHtcbiAgICAgIC8vIGF0U2lnbiBjYW4gYmUgYW55d2hlcmUuXG4gICAgICBhdFNpZ24gPSByZXN0Lmxhc3RJbmRleE9mKCdAJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGF0U2lnbiBtdXN0IGJlIGluIGF1dGggcG9ydGlvbi5cbiAgICAgIC8vIGh0dHA6Ly9hQGIvY0BkID0+IGhvc3Q6YiBhdXRoOmEgcGF0aDovY0BkXG4gICAgICBhdFNpZ24gPSByZXN0Lmxhc3RJbmRleE9mKCdAJywgaG9zdEVuZCk7XG4gICAgfVxuXG4gICAgLy8gTm93IHdlIGhhdmUgYSBwb3J0aW9uIHdoaWNoIGlzIGRlZmluaXRlbHkgdGhlIGF1dGguXG4gICAgLy8gUHVsbCB0aGF0IG9mZi5cbiAgICBpZiAoYXRTaWduICE9PSAtMSkge1xuICAgICAgYXV0aCA9IHJlc3Quc2xpY2UoMCwgYXRTaWduKTtcbiAgICAgIHJlc3QgPSByZXN0LnNsaWNlKGF0U2lnbiArIDEpO1xuICAgICAgdGhpcy5hdXRoID0gZGVjb2RlVVJJQ29tcG9uZW50KGF1dGgpO1xuICAgIH1cblxuICAgIC8vIHRoZSBob3N0IGlzIHRoZSByZW1haW5pbmcgdG8gdGhlIGxlZnQgb2YgdGhlIGZpcnN0IG5vbi1ob3N0IGNoYXJcbiAgICBob3N0RW5kID0gLTE7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub25Ib3N0Q2hhcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBoZWMgPSByZXN0LmluZGV4T2Yobm9uSG9zdENoYXJzW2ldKTtcbiAgICAgIGlmIChoZWMgIT09IC0xICYmIChob3N0RW5kID09PSAtMSB8fCBoZWMgPCBob3N0RW5kKSlcbiAgICAgICAgaG9zdEVuZCA9IGhlYztcbiAgICB9XG4gICAgLy8gaWYgd2Ugc3RpbGwgaGF2ZSBub3QgaGl0IGl0LCB0aGVuIHRoZSBlbnRpcmUgdGhpbmcgaXMgYSBob3N0LlxuICAgIGlmIChob3N0RW5kID09PSAtMSlcbiAgICAgIGhvc3RFbmQgPSByZXN0Lmxlbmd0aDtcblxuICAgIHRoaXMuaG9zdCA9IHJlc3Quc2xpY2UoMCwgaG9zdEVuZCk7XG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoaG9zdEVuZCk7XG5cbiAgICAvLyBwdWxsIG91dCBwb3J0LlxuICAgIHRoaXMucGFyc2VIb3N0KCk7XG5cbiAgICAvLyB3ZSd2ZSBpbmRpY2F0ZWQgdGhhdCB0aGVyZSBpcyBhIGhvc3RuYW1lLFxuICAgIC8vIHNvIGV2ZW4gaWYgaXQncyBlbXB0eSwgaXQgaGFzIHRvIGJlIHByZXNlbnQuXG4gICAgdGhpcy5ob3N0bmFtZSA9IHRoaXMuaG9zdG5hbWUgfHwgJyc7XG5cbiAgICAvLyBpZiBob3N0bmFtZSBiZWdpbnMgd2l0aCBbIGFuZCBlbmRzIHdpdGggXVxuICAgIC8vIGFzc3VtZSB0aGF0IGl0J3MgYW4gSVB2NiBhZGRyZXNzLlxuICAgIHZhciBpcHY2SG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lWzBdID09PSAnWycgJiZcbiAgICAgICAgdGhpcy5ob3N0bmFtZVt0aGlzLmhvc3RuYW1lLmxlbmd0aCAtIDFdID09PSAnXSc7XG5cbiAgICAvLyB2YWxpZGF0ZSBhIGxpdHRsZS5cbiAgICBpZiAoIWlwdjZIb3N0bmFtZSkge1xuICAgICAgdmFyIGhvc3RwYXJ0cyA9IHRoaXMuaG9zdG5hbWUuc3BsaXQoL1xcLi8pO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBob3N0cGFydHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHZhciBwYXJ0ID0gaG9zdHBhcnRzW2ldO1xuICAgICAgICBpZiAoIXBhcnQpIGNvbnRpbnVlO1xuICAgICAgICBpZiAoIXBhcnQubWF0Y2goaG9zdG5hbWVQYXJ0UGF0dGVybikpIHtcbiAgICAgICAgICB2YXIgbmV3cGFydCA9ICcnO1xuICAgICAgICAgIGZvciAodmFyIGogPSAwLCBrID0gcGFydC5sZW5ndGg7IGogPCBrOyBqKyspIHtcbiAgICAgICAgICAgIGlmIChwYXJ0LmNoYXJDb2RlQXQoaikgPiAxMjcpIHtcbiAgICAgICAgICAgICAgLy8gd2UgcmVwbGFjZSBub24tQVNDSUkgY2hhciB3aXRoIGEgdGVtcG9yYXJ5IHBsYWNlaG9sZGVyXG4gICAgICAgICAgICAgIC8vIHdlIG5lZWQgdGhpcyB0byBtYWtlIHN1cmUgc2l6ZSBvZiBob3N0bmFtZSBpcyBub3RcbiAgICAgICAgICAgICAgLy8gYnJva2VuIGJ5IHJlcGxhY2luZyBub24tQVNDSUkgYnkgbm90aGluZ1xuICAgICAgICAgICAgICBuZXdwYXJ0ICs9ICd4JztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG5ld3BhcnQgKz0gcGFydFtqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gd2UgdGVzdCBhZ2FpbiB3aXRoIEFTQ0lJIGNoYXIgb25seVxuICAgICAgICAgIGlmICghbmV3cGFydC5tYXRjaChob3N0bmFtZVBhcnRQYXR0ZXJuKSkge1xuICAgICAgICAgICAgdmFyIHZhbGlkUGFydHMgPSBob3N0cGFydHMuc2xpY2UoMCwgaSk7XG4gICAgICAgICAgICB2YXIgbm90SG9zdCA9IGhvc3RwYXJ0cy5zbGljZShpICsgMSk7XG4gICAgICAgICAgICB2YXIgYml0ID0gcGFydC5tYXRjaChob3N0bmFtZVBhcnRTdGFydCk7XG4gICAgICAgICAgICBpZiAoYml0KSB7XG4gICAgICAgICAgICAgIHZhbGlkUGFydHMucHVzaChiaXRbMV0pO1xuICAgICAgICAgICAgICBub3RIb3N0LnVuc2hpZnQoYml0WzJdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub3RIb3N0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICByZXN0ID0gJy8nICsgbm90SG9zdC5qb2luKCcuJykgKyByZXN0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5ob3N0bmFtZSA9IHZhbGlkUGFydHMuam9pbignLicpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaG9zdG5hbWUubGVuZ3RoID4gaG9zdG5hbWVNYXhMZW4pIHtcbiAgICAgIHRoaXMuaG9zdG5hbWUgPSAnJztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaG9zdG5hbWVzIGFyZSBhbHdheXMgbG93ZXIgY2FzZS5cbiAgICAgIHRoaXMuaG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuXG4gICAgaWYgKCFpcHY2SG9zdG5hbWUpIHtcbiAgICAgIC8vIElETkEgU3VwcG9ydDogUmV0dXJucyBhIHB1bnljb2RlZCByZXByZXNlbnRhdGlvbiBvZiBcImRvbWFpblwiLlxuICAgICAgLy8gSXQgb25seSBjb252ZXJ0cyBwYXJ0cyBvZiB0aGUgZG9tYWluIG5hbWUgdGhhdFxuICAgICAgLy8gaGF2ZSBub24tQVNDSUkgY2hhcmFjdGVycywgaS5lLiBpdCBkb2Vzbid0IG1hdHRlciBpZlxuICAgICAgLy8geW91IGNhbGwgaXQgd2l0aCBhIGRvbWFpbiB0aGF0IGFscmVhZHkgaXMgQVNDSUktb25seS5cbiAgICAgIHRoaXMuaG9zdG5hbWUgPSBwdW55Y29kZS50b0FTQ0lJKHRoaXMuaG9zdG5hbWUpO1xuICAgIH1cblxuICAgIHZhciBwID0gdGhpcy5wb3J0ID8gJzonICsgdGhpcy5wb3J0IDogJyc7XG4gICAgdmFyIGggPSB0aGlzLmhvc3RuYW1lIHx8ICcnO1xuICAgIHRoaXMuaG9zdCA9IGggKyBwO1xuICAgIHRoaXMuaHJlZiArPSB0aGlzLmhvc3Q7XG5cbiAgICAvLyBzdHJpcCBbIGFuZCBdIGZyb20gdGhlIGhvc3RuYW1lXG4gICAgLy8gdGhlIGhvc3QgZmllbGQgc3RpbGwgcmV0YWlucyB0aGVtLCB0aG91Z2hcbiAgICBpZiAoaXB2Nkhvc3RuYW1lKSB7XG4gICAgICB0aGlzLmhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZS5zdWJzdHIoMSwgdGhpcy5ob3N0bmFtZS5sZW5ndGggLSAyKTtcbiAgICAgIGlmIChyZXN0WzBdICE9PSAnLycpIHtcbiAgICAgICAgcmVzdCA9ICcvJyArIHJlc3Q7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gbm93IHJlc3QgaXMgc2V0IHRvIHRoZSBwb3N0LWhvc3Qgc3R1ZmYuXG4gIC8vIGNob3Agb2ZmIGFueSBkZWxpbSBjaGFycy5cbiAgaWYgKCF1bnNhZmVQcm90b2NvbFtsb3dlclByb3RvXSkge1xuXG4gICAgLy8gRmlyc3QsIG1ha2UgMTAwJSBzdXJlIHRoYXQgYW55IFwiYXV0b0VzY2FwZVwiIGNoYXJzIGdldFxuICAgIC8vIGVzY2FwZWQsIGV2ZW4gaWYgZW5jb2RlVVJJQ29tcG9uZW50IGRvZXNuJ3QgdGhpbmsgdGhleVxuICAgIC8vIG5lZWQgdG8gYmUuXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBhdXRvRXNjYXBlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGFlID0gYXV0b0VzY2FwZVtpXTtcbiAgICAgIGlmIChyZXN0LmluZGV4T2YoYWUpID09PSAtMSlcbiAgICAgICAgY29udGludWU7XG4gICAgICB2YXIgZXNjID0gZW5jb2RlVVJJQ29tcG9uZW50KGFlKTtcbiAgICAgIGlmIChlc2MgPT09IGFlKSB7XG4gICAgICAgIGVzYyA9IGVzY2FwZShhZSk7XG4gICAgICB9XG4gICAgICByZXN0ID0gcmVzdC5zcGxpdChhZSkuam9pbihlc2MpO1xuICAgIH1cbiAgfVxuXG5cbiAgLy8gY2hvcCBvZmYgZnJvbSB0aGUgdGFpbCBmaXJzdC5cbiAgdmFyIGhhc2ggPSByZXN0LmluZGV4T2YoJyMnKTtcbiAgaWYgKGhhc2ggIT09IC0xKSB7XG4gICAgLy8gZ290IGEgZnJhZ21lbnQgc3RyaW5nLlxuICAgIHRoaXMuaGFzaCA9IHJlc3Quc3Vic3RyKGhhc2gpO1xuICAgIHJlc3QgPSByZXN0LnNsaWNlKDAsIGhhc2gpO1xuICB9XG4gIHZhciBxbSA9IHJlc3QuaW5kZXhPZignPycpO1xuICBpZiAocW0gIT09IC0xKSB7XG4gICAgdGhpcy5zZWFyY2ggPSByZXN0LnN1YnN0cihxbSk7XG4gICAgdGhpcy5xdWVyeSA9IHJlc3Quc3Vic3RyKHFtICsgMSk7XG4gICAgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAgIHRoaXMucXVlcnkgPSBxdWVyeXN0cmluZy5wYXJzZSh0aGlzLnF1ZXJ5KTtcbiAgICB9XG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoMCwgcW0pO1xuICB9IGVsc2UgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAvLyBubyBxdWVyeSBzdHJpbmcsIGJ1dCBwYXJzZVF1ZXJ5U3RyaW5nIHN0aWxsIHJlcXVlc3RlZFxuICAgIHRoaXMuc2VhcmNoID0gJyc7XG4gICAgdGhpcy5xdWVyeSA9IHt9O1xuICB9XG4gIGlmIChyZXN0KSB0aGlzLnBhdGhuYW1lID0gcmVzdDtcbiAgaWYgKHNsYXNoZWRQcm90b2NvbFtsb3dlclByb3RvXSAmJlxuICAgICAgdGhpcy5ob3N0bmFtZSAmJiAhdGhpcy5wYXRobmFtZSkge1xuICAgIHRoaXMucGF0aG5hbWUgPSAnLyc7XG4gIH1cblxuICAvL3RvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gIGlmICh0aGlzLnBhdGhuYW1lIHx8IHRoaXMuc2VhcmNoKSB7XG4gICAgdmFyIHAgPSB0aGlzLnBhdGhuYW1lIHx8ICcnO1xuICAgIHZhciBzID0gdGhpcy5zZWFyY2ggfHwgJyc7XG4gICAgdGhpcy5wYXRoID0gcCArIHM7XG4gIH1cblxuICAvLyBmaW5hbGx5LCByZWNvbnN0cnVjdCB0aGUgaHJlZiBiYXNlZCBvbiB3aGF0IGhhcyBiZWVuIHZhbGlkYXRlZC5cbiAgdGhpcy5ocmVmID0gdGhpcy5mb3JtYXQoKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBmb3JtYXQgYSBwYXJzZWQgb2JqZWN0IGludG8gYSB1cmwgc3RyaW5nXG5mdW5jdGlvbiB1cmxGb3JtYXQob2JqKSB7XG4gIC8vIGVuc3VyZSBpdCdzIGFuIG9iamVjdCwgYW5kIG5vdCBhIHN0cmluZyB1cmwuXG4gIC8vIElmIGl0J3MgYW4gb2JqLCB0aGlzIGlzIGEgbm8tb3AuXG4gIC8vIHRoaXMgd2F5LCB5b3UgY2FuIGNhbGwgdXJsX2Zvcm1hdCgpIG9uIHN0cmluZ3NcbiAgLy8gdG8gY2xlYW4gdXAgcG90ZW50aWFsbHkgd29ua3kgdXJscy5cbiAgaWYgKHV0aWwuaXNTdHJpbmcob2JqKSkgb2JqID0gdXJsUGFyc2Uob2JqKTtcbiAgaWYgKCEob2JqIGluc3RhbmNlb2YgVXJsKSkgcmV0dXJuIFVybC5wcm90b3R5cGUuZm9ybWF0LmNhbGwob2JqKTtcbiAgcmV0dXJuIG9iai5mb3JtYXQoKTtcbn1cblxuVXJsLnByb3RvdHlwZS5mb3JtYXQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGF1dGggPSB0aGlzLmF1dGggfHwgJyc7XG4gIGlmIChhdXRoKSB7XG4gICAgYXV0aCA9IGVuY29kZVVSSUNvbXBvbmVudChhdXRoKTtcbiAgICBhdXRoID0gYXV0aC5yZXBsYWNlKC8lM0EvaSwgJzonKTtcbiAgICBhdXRoICs9ICdAJztcbiAgfVxuXG4gIHZhciBwcm90b2NvbCA9IHRoaXMucHJvdG9jb2wgfHwgJycsXG4gICAgICBwYXRobmFtZSA9IHRoaXMucGF0aG5hbWUgfHwgJycsXG4gICAgICBoYXNoID0gdGhpcy5oYXNoIHx8ICcnLFxuICAgICAgaG9zdCA9IGZhbHNlLFxuICAgICAgcXVlcnkgPSAnJztcblxuICBpZiAodGhpcy5ob3N0KSB7XG4gICAgaG9zdCA9IGF1dGggKyB0aGlzLmhvc3Q7XG4gIH0gZWxzZSBpZiAodGhpcy5ob3N0bmFtZSkge1xuICAgIGhvc3QgPSBhdXRoICsgKHRoaXMuaG9zdG5hbWUuaW5kZXhPZignOicpID09PSAtMSA/XG4gICAgICAgIHRoaXMuaG9zdG5hbWUgOlxuICAgICAgICAnWycgKyB0aGlzLmhvc3RuYW1lICsgJ10nKTtcbiAgICBpZiAodGhpcy5wb3J0KSB7XG4gICAgICBob3N0ICs9ICc6JyArIHRoaXMucG9ydDtcbiAgICB9XG4gIH1cblxuICBpZiAodGhpcy5xdWVyeSAmJlxuICAgICAgdXRpbC5pc09iamVjdCh0aGlzLnF1ZXJ5KSAmJlxuICAgICAgT2JqZWN0LmtleXModGhpcy5xdWVyeSkubGVuZ3RoKSB7XG4gICAgcXVlcnkgPSBxdWVyeXN0cmluZy5zdHJpbmdpZnkodGhpcy5xdWVyeSk7XG4gIH1cblxuICB2YXIgc2VhcmNoID0gdGhpcy5zZWFyY2ggfHwgKHF1ZXJ5ICYmICgnPycgKyBxdWVyeSkpIHx8ICcnO1xuXG4gIGlmIChwcm90b2NvbCAmJiBwcm90b2NvbC5zdWJzdHIoLTEpICE9PSAnOicpIHByb3RvY29sICs9ICc6JztcblxuICAvLyBvbmx5IHRoZSBzbGFzaGVkUHJvdG9jb2xzIGdldCB0aGUgLy8uICBOb3QgbWFpbHRvOiwgeG1wcDosIGV0Yy5cbiAgLy8gdW5sZXNzIHRoZXkgaGFkIHRoZW0gdG8gYmVnaW4gd2l0aC5cbiAgaWYgKHRoaXMuc2xhc2hlcyB8fFxuICAgICAgKCFwcm90b2NvbCB8fCBzbGFzaGVkUHJvdG9jb2xbcHJvdG9jb2xdKSAmJiBob3N0ICE9PSBmYWxzZSkge1xuICAgIGhvc3QgPSAnLy8nICsgKGhvc3QgfHwgJycpO1xuICAgIGlmIChwYXRobmFtZSAmJiBwYXRobmFtZS5jaGFyQXQoMCkgIT09ICcvJykgcGF0aG5hbWUgPSAnLycgKyBwYXRobmFtZTtcbiAgfSBlbHNlIGlmICghaG9zdCkge1xuICAgIGhvc3QgPSAnJztcbiAgfVxuXG4gIGlmIChoYXNoICYmIGhhc2guY2hhckF0KDApICE9PSAnIycpIGhhc2ggPSAnIycgKyBoYXNoO1xuICBpZiAoc2VhcmNoICYmIHNlYXJjaC5jaGFyQXQoMCkgIT09ICc/Jykgc2VhcmNoID0gJz8nICsgc2VhcmNoO1xuXG4gIHBhdGhuYW1lID0gcGF0aG5hbWUucmVwbGFjZSgvWz8jXS9nLCBmdW5jdGlvbihtYXRjaCkge1xuICAgIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQobWF0Y2gpO1xuICB9KTtcbiAgc2VhcmNoID0gc2VhcmNoLnJlcGxhY2UoJyMnLCAnJTIzJyk7XG5cbiAgcmV0dXJuIHByb3RvY29sICsgaG9zdCArIHBhdGhuYW1lICsgc2VhcmNoICsgaGFzaDtcbn07XG5cbmZ1bmN0aW9uIHVybFJlc29sdmUoc291cmNlLCByZWxhdGl2ZSkge1xuICByZXR1cm4gdXJsUGFyc2Uoc291cmNlLCBmYWxzZSwgdHJ1ZSkucmVzb2x2ZShyZWxhdGl2ZSk7XG59XG5cblVybC5wcm90b3R5cGUucmVzb2x2ZSA9IGZ1bmN0aW9uKHJlbGF0aXZlKSB7XG4gIHJldHVybiB0aGlzLnJlc29sdmVPYmplY3QodXJsUGFyc2UocmVsYXRpdmUsIGZhbHNlLCB0cnVlKSkuZm9ybWF0KCk7XG59O1xuXG5mdW5jdGlvbiB1cmxSZXNvbHZlT2JqZWN0KHNvdXJjZSwgcmVsYXRpdmUpIHtcbiAgaWYgKCFzb3VyY2UpIHJldHVybiByZWxhdGl2ZTtcbiAgcmV0dXJuIHVybFBhcnNlKHNvdXJjZSwgZmFsc2UsIHRydWUpLnJlc29sdmVPYmplY3QocmVsYXRpdmUpO1xufVxuXG5VcmwucHJvdG90eXBlLnJlc29sdmVPYmplY3QgPSBmdW5jdGlvbihyZWxhdGl2ZSkge1xuICBpZiAodXRpbC5pc1N0cmluZyhyZWxhdGl2ZSkpIHtcbiAgICB2YXIgcmVsID0gbmV3IFVybCgpO1xuICAgIHJlbC5wYXJzZShyZWxhdGl2ZSwgZmFsc2UsIHRydWUpO1xuICAgIHJlbGF0aXZlID0gcmVsO1xuICB9XG5cbiAgdmFyIHJlc3VsdCA9IG5ldyBVcmwoKTtcbiAgdmFyIHRrZXlzID0gT2JqZWN0LmtleXModGhpcyk7XG4gIGZvciAodmFyIHRrID0gMDsgdGsgPCB0a2V5cy5sZW5ndGg7IHRrKyspIHtcbiAgICB2YXIgdGtleSA9IHRrZXlzW3RrXTtcbiAgICByZXN1bHRbdGtleV0gPSB0aGlzW3RrZXldO1xuICB9XG5cbiAgLy8gaGFzaCBpcyBhbHdheXMgb3ZlcnJpZGRlbiwgbm8gbWF0dGVyIHdoYXQuXG4gIC8vIGV2ZW4gaHJlZj1cIlwiIHdpbGwgcmVtb3ZlIGl0LlxuICByZXN1bHQuaGFzaCA9IHJlbGF0aXZlLmhhc2g7XG5cbiAgLy8gaWYgdGhlIHJlbGF0aXZlIHVybCBpcyBlbXB0eSwgdGhlbiB0aGVyZSdzIG5vdGhpbmcgbGVmdCB0byBkbyBoZXJlLlxuICBpZiAocmVsYXRpdmUuaHJlZiA9PT0gJycpIHtcbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLy8gaHJlZnMgbGlrZSAvL2Zvby9iYXIgYWx3YXlzIGN1dCB0byB0aGUgcHJvdG9jb2wuXG4gIGlmIChyZWxhdGl2ZS5zbGFzaGVzICYmICFyZWxhdGl2ZS5wcm90b2NvbCkge1xuICAgIC8vIHRha2UgZXZlcnl0aGluZyBleGNlcHQgdGhlIHByb3RvY29sIGZyb20gcmVsYXRpdmVcbiAgICB2YXIgcmtleXMgPSBPYmplY3Qua2V5cyhyZWxhdGl2ZSk7XG4gICAgZm9yICh2YXIgcmsgPSAwOyByayA8IHJrZXlzLmxlbmd0aDsgcmsrKykge1xuICAgICAgdmFyIHJrZXkgPSBya2V5c1tya107XG4gICAgICBpZiAocmtleSAhPT0gJ3Byb3RvY29sJylcbiAgICAgICAgcmVzdWx0W3JrZXldID0gcmVsYXRpdmVbcmtleV07XG4gICAgfVxuXG4gICAgLy91cmxQYXJzZSBhcHBlbmRzIHRyYWlsaW5nIC8gdG8gdXJscyBsaWtlIGh0dHA6Ly93d3cuZXhhbXBsZS5jb21cbiAgICBpZiAoc2xhc2hlZFByb3RvY29sW3Jlc3VsdC5wcm90b2NvbF0gJiZcbiAgICAgICAgcmVzdWx0Lmhvc3RuYW1lICYmICFyZXN1bHQucGF0aG5hbWUpIHtcbiAgICAgIHJlc3VsdC5wYXRoID0gcmVzdWx0LnBhdGhuYW1lID0gJy8nO1xuICAgIH1cblxuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBpZiAocmVsYXRpdmUucHJvdG9jb2wgJiYgcmVsYXRpdmUucHJvdG9jb2wgIT09IHJlc3VsdC5wcm90b2NvbCkge1xuICAgIC8vIGlmIGl0J3MgYSBrbm93biB1cmwgcHJvdG9jb2wsIHRoZW4gY2hhbmdpbmdcbiAgICAvLyB0aGUgcHJvdG9jb2wgZG9lcyB3ZWlyZCB0aGluZ3NcbiAgICAvLyBmaXJzdCwgaWYgaXQncyBub3QgZmlsZTosIHRoZW4gd2UgTVVTVCBoYXZlIGEgaG9zdCxcbiAgICAvLyBhbmQgaWYgdGhlcmUgd2FzIGEgcGF0aFxuICAgIC8vIHRvIGJlZ2luIHdpdGgsIHRoZW4gd2UgTVVTVCBoYXZlIGEgcGF0aC5cbiAgICAvLyBpZiBpdCBpcyBmaWxlOiwgdGhlbiB0aGUgaG9zdCBpcyBkcm9wcGVkLFxuICAgIC8vIGJlY2F1c2UgdGhhdCdzIGtub3duIHRvIGJlIGhvc3RsZXNzLlxuICAgIC8vIGFueXRoaW5nIGVsc2UgaXMgYXNzdW1lZCB0byBiZSBhYnNvbHV0ZS5cbiAgICBpZiAoIXNsYXNoZWRQcm90b2NvbFtyZWxhdGl2ZS5wcm90b2NvbF0pIHtcbiAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMocmVsYXRpdmUpO1xuICAgICAgZm9yICh2YXIgdiA9IDA7IHYgPCBrZXlzLmxlbmd0aDsgdisrKSB7XG4gICAgICAgIHZhciBrID0ga2V5c1t2XTtcbiAgICAgICAgcmVzdWx0W2tdID0gcmVsYXRpdmVba107XG4gICAgICB9XG4gICAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgcmVzdWx0LnByb3RvY29sID0gcmVsYXRpdmUucHJvdG9jb2w7XG4gICAgaWYgKCFyZWxhdGl2ZS5ob3N0ICYmICFob3N0bGVzc1Byb3RvY29sW3JlbGF0aXZlLnByb3RvY29sXSkge1xuICAgICAgdmFyIHJlbFBhdGggPSAocmVsYXRpdmUucGF0aG5hbWUgfHwgJycpLnNwbGl0KCcvJyk7XG4gICAgICB3aGlsZSAocmVsUGF0aC5sZW5ndGggJiYgIShyZWxhdGl2ZS5ob3N0ID0gcmVsUGF0aC5zaGlmdCgpKSk7XG4gICAgICBpZiAoIXJlbGF0aXZlLmhvc3QpIHJlbGF0aXZlLmhvc3QgPSAnJztcbiAgICAgIGlmICghcmVsYXRpdmUuaG9zdG5hbWUpIHJlbGF0aXZlLmhvc3RuYW1lID0gJyc7XG4gICAgICBpZiAocmVsUGF0aFswXSAhPT0gJycpIHJlbFBhdGgudW5zaGlmdCgnJyk7XG4gICAgICBpZiAocmVsUGF0aC5sZW5ndGggPCAyKSByZWxQYXRoLnVuc2hpZnQoJycpO1xuICAgICAgcmVzdWx0LnBhdGhuYW1lID0gcmVsUGF0aC5qb2luKCcvJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdC5wYXRobmFtZSA9IHJlbGF0aXZlLnBhdGhuYW1lO1xuICAgIH1cbiAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICAgIHJlc3VsdC5ob3N0ID0gcmVsYXRpdmUuaG9zdCB8fCAnJztcbiAgICByZXN1bHQuYXV0aCA9IHJlbGF0aXZlLmF1dGg7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gcmVsYXRpdmUuaG9zdG5hbWUgfHwgcmVsYXRpdmUuaG9zdDtcbiAgICByZXN1bHQucG9ydCA9IHJlbGF0aXZlLnBvcnQ7XG4gICAgLy8gdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgICBpZiAocmVzdWx0LnBhdGhuYW1lIHx8IHJlc3VsdC5zZWFyY2gpIHtcbiAgICAgIHZhciBwID0gcmVzdWx0LnBhdGhuYW1lIHx8ICcnO1xuICAgICAgdmFyIHMgPSByZXN1bHQuc2VhcmNoIHx8ICcnO1xuICAgICAgcmVzdWx0LnBhdGggPSBwICsgcztcbiAgICB9XG4gICAgcmVzdWx0LnNsYXNoZXMgPSByZXN1bHQuc2xhc2hlcyB8fCByZWxhdGl2ZS5zbGFzaGVzO1xuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICB2YXIgaXNTb3VyY2VBYnMgPSAocmVzdWx0LnBhdGhuYW1lICYmIHJlc3VsdC5wYXRobmFtZS5jaGFyQXQoMCkgPT09ICcvJyksXG4gICAgICBpc1JlbEFicyA9IChcbiAgICAgICAgICByZWxhdGl2ZS5ob3N0IHx8XG4gICAgICAgICAgcmVsYXRpdmUucGF0aG5hbWUgJiYgcmVsYXRpdmUucGF0aG5hbWUuY2hhckF0KDApID09PSAnLydcbiAgICAgICksXG4gICAgICBtdXN0RW5kQWJzID0gKGlzUmVsQWJzIHx8IGlzU291cmNlQWJzIHx8XG4gICAgICAgICAgICAgICAgICAgIChyZXN1bHQuaG9zdCAmJiByZWxhdGl2ZS5wYXRobmFtZSkpLFxuICAgICAgcmVtb3ZlQWxsRG90cyA9IG11c3RFbmRBYnMsXG4gICAgICBzcmNQYXRoID0gcmVzdWx0LnBhdGhuYW1lICYmIHJlc3VsdC5wYXRobmFtZS5zcGxpdCgnLycpIHx8IFtdLFxuICAgICAgcmVsUGF0aCA9IHJlbGF0aXZlLnBhdGhuYW1lICYmIHJlbGF0aXZlLnBhdGhuYW1lLnNwbGl0KCcvJykgfHwgW10sXG4gICAgICBwc3ljaG90aWMgPSByZXN1bHQucHJvdG9jb2wgJiYgIXNsYXNoZWRQcm90b2NvbFtyZXN1bHQucHJvdG9jb2xdO1xuXG4gIC8vIGlmIHRoZSB1cmwgaXMgYSBub24tc2xhc2hlZCB1cmwsIHRoZW4gcmVsYXRpdmVcbiAgLy8gbGlua3MgbGlrZSAuLi8uLiBzaG91bGQgYmUgYWJsZVxuICAvLyB0byBjcmF3bCB1cCB0byB0aGUgaG9zdG5hbWUsIGFzIHdlbGwuICBUaGlzIGlzIHN0cmFuZ2UuXG4gIC8vIHJlc3VsdC5wcm90b2NvbCBoYXMgYWxyZWFkeSBiZWVuIHNldCBieSBub3cuXG4gIC8vIExhdGVyIG9uLCBwdXQgdGhlIGZpcnN0IHBhdGggcGFydCBpbnRvIHRoZSBob3N0IGZpZWxkLlxuICBpZiAocHN5Y2hvdGljKSB7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gJyc7XG4gICAgcmVzdWx0LnBvcnQgPSBudWxsO1xuICAgIGlmIChyZXN1bHQuaG9zdCkge1xuICAgICAgaWYgKHNyY1BhdGhbMF0gPT09ICcnKSBzcmNQYXRoWzBdID0gcmVzdWx0Lmhvc3Q7XG4gICAgICBlbHNlIHNyY1BhdGgudW5zaGlmdChyZXN1bHQuaG9zdCk7XG4gICAgfVxuICAgIHJlc3VsdC5ob3N0ID0gJyc7XG4gICAgaWYgKHJlbGF0aXZlLnByb3RvY29sKSB7XG4gICAgICByZWxhdGl2ZS5ob3N0bmFtZSA9IG51bGw7XG4gICAgICByZWxhdGl2ZS5wb3J0ID0gbnVsbDtcbiAgICAgIGlmIChyZWxhdGl2ZS5ob3N0KSB7XG4gICAgICAgIGlmIChyZWxQYXRoWzBdID09PSAnJykgcmVsUGF0aFswXSA9IHJlbGF0aXZlLmhvc3Q7XG4gICAgICAgIGVsc2UgcmVsUGF0aC51bnNoaWZ0KHJlbGF0aXZlLmhvc3QpO1xuICAgICAgfVxuICAgICAgcmVsYXRpdmUuaG9zdCA9IG51bGw7XG4gICAgfVxuICAgIG11c3RFbmRBYnMgPSBtdXN0RW5kQWJzICYmIChyZWxQYXRoWzBdID09PSAnJyB8fCBzcmNQYXRoWzBdID09PSAnJyk7XG4gIH1cblxuICBpZiAoaXNSZWxBYnMpIHtcbiAgICAvLyBpdCdzIGFic29sdXRlLlxuICAgIHJlc3VsdC5ob3N0ID0gKHJlbGF0aXZlLmhvc3QgfHwgcmVsYXRpdmUuaG9zdCA9PT0gJycpID9cbiAgICAgICAgICAgICAgICAgIHJlbGF0aXZlLmhvc3QgOiByZXN1bHQuaG9zdDtcbiAgICByZXN1bHQuaG9zdG5hbWUgPSAocmVsYXRpdmUuaG9zdG5hbWUgfHwgcmVsYXRpdmUuaG9zdG5hbWUgPT09ICcnKSA/XG4gICAgICAgICAgICAgICAgICAgICAgcmVsYXRpdmUuaG9zdG5hbWUgOiByZXN1bHQuaG9zdG5hbWU7XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgICBzcmNQYXRoID0gcmVsUGF0aDtcbiAgICAvLyBmYWxsIHRocm91Z2ggdG8gdGhlIGRvdC1oYW5kbGluZyBiZWxvdy5cbiAgfSBlbHNlIGlmIChyZWxQYXRoLmxlbmd0aCkge1xuICAgIC8vIGl0J3MgcmVsYXRpdmVcbiAgICAvLyB0aHJvdyBhd2F5IHRoZSBleGlzdGluZyBmaWxlLCBhbmQgdGFrZSB0aGUgbmV3IHBhdGggaW5zdGVhZC5cbiAgICBpZiAoIXNyY1BhdGgpIHNyY1BhdGggPSBbXTtcbiAgICBzcmNQYXRoLnBvcCgpO1xuICAgIHNyY1BhdGggPSBzcmNQYXRoLmNvbmNhdChyZWxQYXRoKTtcbiAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICB9IGVsc2UgaWYgKCF1dGlsLmlzTnVsbE9yVW5kZWZpbmVkKHJlbGF0aXZlLnNlYXJjaCkpIHtcbiAgICAvLyBqdXN0IHB1bGwgb3V0IHRoZSBzZWFyY2guXG4gICAgLy8gbGlrZSBocmVmPSc/Zm9vJy5cbiAgICAvLyBQdXQgdGhpcyBhZnRlciB0aGUgb3RoZXIgdHdvIGNhc2VzIGJlY2F1c2UgaXQgc2ltcGxpZmllcyB0aGUgYm9vbGVhbnNcbiAgICBpZiAocHN5Y2hvdGljKSB7XG4gICAgICByZXN1bHQuaG9zdG5hbWUgPSByZXN1bHQuaG9zdCA9IHNyY1BhdGguc2hpZnQoKTtcbiAgICAgIC8vb2NjYXRpb25hbHkgdGhlIGF1dGggY2FuIGdldCBzdHVjayBvbmx5IGluIGhvc3RcbiAgICAgIC8vdGhpcyBlc3BlY2lhbGx5IGhhcHBlbnMgaW4gY2FzZXMgbGlrZVxuICAgICAgLy91cmwucmVzb2x2ZU9iamVjdCgnbWFpbHRvOmxvY2FsMUBkb21haW4xJywgJ2xvY2FsMkBkb21haW4yJylcbiAgICAgIHZhciBhdXRoSW5Ib3N0ID0gcmVzdWx0Lmhvc3QgJiYgcmVzdWx0Lmhvc3QuaW5kZXhPZignQCcpID4gMCA/XG4gICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5ob3N0LnNwbGl0KCdAJykgOiBmYWxzZTtcbiAgICAgIGlmIChhdXRoSW5Ib3N0KSB7XG4gICAgICAgIHJlc3VsdC5hdXRoID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgICAgICByZXN1bHQuaG9zdCA9IHJlc3VsdC5ob3N0bmFtZSA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgICAvL3RvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gICAgaWYgKCF1dGlsLmlzTnVsbChyZXN1bHQucGF0aG5hbWUpIHx8ICF1dGlsLmlzTnVsbChyZXN1bHQuc2VhcmNoKSkge1xuICAgICAgcmVzdWx0LnBhdGggPSAocmVzdWx0LnBhdGhuYW1lID8gcmVzdWx0LnBhdGhuYW1lIDogJycpICtcbiAgICAgICAgICAgICAgICAgICAgKHJlc3VsdC5zZWFyY2ggPyByZXN1bHQuc2VhcmNoIDogJycpO1xuICAgIH1cbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgaWYgKCFzcmNQYXRoLmxlbmd0aCkge1xuICAgIC8vIG5vIHBhdGggYXQgYWxsLiAgZWFzeS5cbiAgICAvLyB3ZSd2ZSBhbHJlYWR5IGhhbmRsZWQgdGhlIG90aGVyIHN0dWZmIGFib3ZlLlxuICAgIHJlc3VsdC5wYXRobmFtZSA9IG51bGw7XG4gICAgLy90byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICAgIGlmIChyZXN1bHQuc2VhcmNoKSB7XG4gICAgICByZXN1bHQucGF0aCA9ICcvJyArIHJlc3VsdC5zZWFyY2g7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdC5wYXRoID0gbnVsbDtcbiAgICB9XG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8vIGlmIGEgdXJsIEVORHMgaW4gLiBvciAuLiwgdGhlbiBpdCBtdXN0IGdldCBhIHRyYWlsaW5nIHNsYXNoLlxuICAvLyBob3dldmVyLCBpZiBpdCBlbmRzIGluIGFueXRoaW5nIGVsc2Ugbm9uLXNsYXNoeSxcbiAgLy8gdGhlbiBpdCBtdXN0IE5PVCBnZXQgYSB0cmFpbGluZyBzbGFzaC5cbiAgdmFyIGxhc3QgPSBzcmNQYXRoLnNsaWNlKC0xKVswXTtcbiAgdmFyIGhhc1RyYWlsaW5nU2xhc2ggPSAoXG4gICAgICAocmVzdWx0Lmhvc3QgfHwgcmVsYXRpdmUuaG9zdCB8fCBzcmNQYXRoLmxlbmd0aCA+IDEpICYmXG4gICAgICAobGFzdCA9PT0gJy4nIHx8IGxhc3QgPT09ICcuLicpIHx8IGxhc3QgPT09ICcnKTtcblxuICAvLyBzdHJpcCBzaW5nbGUgZG90cywgcmVzb2x2ZSBkb3VibGUgZG90cyB0byBwYXJlbnQgZGlyXG4gIC8vIGlmIHRoZSBwYXRoIHRyaWVzIHRvIGdvIGFib3ZlIHRoZSByb290LCBgdXBgIGVuZHMgdXAgPiAwXG4gIHZhciB1cCA9IDA7XG4gIGZvciAodmFyIGkgPSBzcmNQYXRoLmxlbmd0aDsgaSA+PSAwOyBpLS0pIHtcbiAgICBsYXN0ID0gc3JjUGF0aFtpXTtcbiAgICBpZiAobGFzdCA9PT0gJy4nKSB7XG4gICAgICBzcmNQYXRoLnNwbGljZShpLCAxKTtcbiAgICB9IGVsc2UgaWYgKGxhc3QgPT09ICcuLicpIHtcbiAgICAgIHNyY1BhdGguc3BsaWNlKGksIDEpO1xuICAgICAgdXArKztcbiAgICB9IGVsc2UgaWYgKHVwKSB7XG4gICAgICBzcmNQYXRoLnNwbGljZShpLCAxKTtcbiAgICAgIHVwLS07XG4gICAgfVxuICB9XG5cbiAgLy8gaWYgdGhlIHBhdGggaXMgYWxsb3dlZCB0byBnbyBhYm92ZSB0aGUgcm9vdCwgcmVzdG9yZSBsZWFkaW5nIC4uc1xuICBpZiAoIW11c3RFbmRBYnMgJiYgIXJlbW92ZUFsbERvdHMpIHtcbiAgICBmb3IgKDsgdXAtLTsgdXApIHtcbiAgICAgIHNyY1BhdGgudW5zaGlmdCgnLi4nKTtcbiAgICB9XG4gIH1cblxuICBpZiAobXVzdEVuZEFicyAmJiBzcmNQYXRoWzBdICE9PSAnJyAmJlxuICAgICAgKCFzcmNQYXRoWzBdIHx8IHNyY1BhdGhbMF0uY2hhckF0KDApICE9PSAnLycpKSB7XG4gICAgc3JjUGF0aC51bnNoaWZ0KCcnKTtcbiAgfVxuXG4gIGlmIChoYXNUcmFpbGluZ1NsYXNoICYmIChzcmNQYXRoLmpvaW4oJy8nKS5zdWJzdHIoLTEpICE9PSAnLycpKSB7XG4gICAgc3JjUGF0aC5wdXNoKCcnKTtcbiAgfVxuXG4gIHZhciBpc0Fic29sdXRlID0gc3JjUGF0aFswXSA9PT0gJycgfHxcbiAgICAgIChzcmNQYXRoWzBdICYmIHNyY1BhdGhbMF0uY2hhckF0KDApID09PSAnLycpO1xuXG4gIC8vIHB1dCB0aGUgaG9zdCBiYWNrXG4gIGlmIChwc3ljaG90aWMpIHtcbiAgICByZXN1bHQuaG9zdG5hbWUgPSByZXN1bHQuaG9zdCA9IGlzQWJzb2x1dGUgPyAnJyA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcmNQYXRoLmxlbmd0aCA/IHNyY1BhdGguc2hpZnQoKSA6ICcnO1xuICAgIC8vb2NjYXRpb25hbHkgdGhlIGF1dGggY2FuIGdldCBzdHVjayBvbmx5IGluIGhvc3RcbiAgICAvL3RoaXMgZXNwZWNpYWxseSBoYXBwZW5zIGluIGNhc2VzIGxpa2VcbiAgICAvL3VybC5yZXNvbHZlT2JqZWN0KCdtYWlsdG86bG9jYWwxQGRvbWFpbjEnLCAnbG9jYWwyQGRvbWFpbjInKVxuICAgIHZhciBhdXRoSW5Ib3N0ID0gcmVzdWx0Lmhvc3QgJiYgcmVzdWx0Lmhvc3QuaW5kZXhPZignQCcpID4gMCA/XG4gICAgICAgICAgICAgICAgICAgICByZXN1bHQuaG9zdC5zcGxpdCgnQCcpIDogZmFsc2U7XG4gICAgaWYgKGF1dGhJbkhvc3QpIHtcbiAgICAgIHJlc3VsdC5hdXRoID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgICAgcmVzdWx0Lmhvc3QgPSByZXN1bHQuaG9zdG5hbWUgPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgfVxuICB9XG5cbiAgbXVzdEVuZEFicyA9IG11c3RFbmRBYnMgfHwgKHJlc3VsdC5ob3N0ICYmIHNyY1BhdGgubGVuZ3RoKTtcblxuICBpZiAobXVzdEVuZEFicyAmJiAhaXNBYnNvbHV0ZSkge1xuICAgIHNyY1BhdGgudW5zaGlmdCgnJyk7XG4gIH1cblxuICBpZiAoIXNyY1BhdGgubGVuZ3RoKSB7XG4gICAgcmVzdWx0LnBhdGhuYW1lID0gbnVsbDtcbiAgICByZXN1bHQucGF0aCA9IG51bGw7XG4gIH0gZWxzZSB7XG4gICAgcmVzdWx0LnBhdGhuYW1lID0gc3JjUGF0aC5qb2luKCcvJyk7XG4gIH1cblxuICAvL3RvIHN1cHBvcnQgcmVxdWVzdC5odHRwXG4gIGlmICghdXRpbC5pc051bGwocmVzdWx0LnBhdGhuYW1lKSB8fCAhdXRpbC5pc051bGwocmVzdWx0LnNlYXJjaCkpIHtcbiAgICByZXN1bHQucGF0aCA9IChyZXN1bHQucGF0aG5hbWUgPyByZXN1bHQucGF0aG5hbWUgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgKHJlc3VsdC5zZWFyY2ggPyByZXN1bHQuc2VhcmNoIDogJycpO1xuICB9XG4gIHJlc3VsdC5hdXRoID0gcmVsYXRpdmUuYXV0aCB8fCByZXN1bHQuYXV0aDtcbiAgcmVzdWx0LnNsYXNoZXMgPSByZXN1bHQuc2xhc2hlcyB8fCByZWxhdGl2ZS5zbGFzaGVzO1xuICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblVybC5wcm90b3R5cGUucGFyc2VIb3N0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBob3N0ID0gdGhpcy5ob3N0O1xuICB2YXIgcG9ydCA9IHBvcnRQYXR0ZXJuLmV4ZWMoaG9zdCk7XG4gIGlmIChwb3J0KSB7XG4gICAgcG9ydCA9IHBvcnRbMF07XG4gICAgaWYgKHBvcnQgIT09ICc6Jykge1xuICAgICAgdGhpcy5wb3J0ID0gcG9ydC5zdWJzdHIoMSk7XG4gICAgfVxuICAgIGhvc3QgPSBob3N0LnN1YnN0cigwLCBob3N0Lmxlbmd0aCAtIHBvcnQubGVuZ3RoKTtcbiAgfVxuICBpZiAoaG9zdCkgdGhpcy5ob3N0bmFtZSA9IGhvc3Q7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgaXNTdHJpbmc6IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiB0eXBlb2YoYXJnKSA9PT0gJ3N0cmluZyc7XG4gIH0sXG4gIGlzT2JqZWN0OiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gdHlwZW9mKGFyZykgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbiAgfSxcbiAgaXNOdWxsOiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gYXJnID09PSBudWxsO1xuICB9LFxuICBpc051bGxPclVuZGVmaW5lZDogZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIGFyZyA9PSBudWxsO1xuICB9XG59O1xuIiwiXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZGVwcmVjYXRlO1xuXG4vKipcbiAqIE1hcmsgdGhhdCBhIG1ldGhvZCBzaG91bGQgbm90IGJlIHVzZWQuXG4gKiBSZXR1cm5zIGEgbW9kaWZpZWQgZnVuY3Rpb24gd2hpY2ggd2FybnMgb25jZSBieSBkZWZhdWx0LlxuICpcbiAqIElmIGBsb2NhbFN0b3JhZ2Uubm9EZXByZWNhdGlvbiA9IHRydWVgIGlzIHNldCwgdGhlbiBpdCBpcyBhIG5vLW9wLlxuICpcbiAqIElmIGBsb2NhbFN0b3JhZ2UudGhyb3dEZXByZWNhdGlvbiA9IHRydWVgIGlzIHNldCwgdGhlbiBkZXByZWNhdGVkIGZ1bmN0aW9uc1xuICogd2lsbCB0aHJvdyBhbiBFcnJvciB3aGVuIGludm9rZWQuXG4gKlxuICogSWYgYGxvY2FsU3RvcmFnZS50cmFjZURlcHJlY2F0aW9uID0gdHJ1ZWAgaXMgc2V0LCB0aGVuIGRlcHJlY2F0ZWQgZnVuY3Rpb25zXG4gKiB3aWxsIGludm9rZSBgY29uc29sZS50cmFjZSgpYCBpbnN0ZWFkIG9mIGBjb25zb2xlLmVycm9yKClgLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIC0gdGhlIGZ1bmN0aW9uIHRvIGRlcHJlY2F0ZVxuICogQHBhcmFtIHtTdHJpbmd9IG1zZyAtIHRoZSBzdHJpbmcgdG8gcHJpbnQgdG8gdGhlIGNvbnNvbGUgd2hlbiBgZm5gIGlzIGludm9rZWRcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gYSBuZXcgXCJkZXByZWNhdGVkXCIgdmVyc2lvbiBvZiBgZm5gXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGRlcHJlY2F0ZSAoZm4sIG1zZykge1xuICBpZiAoY29uZmlnKCdub0RlcHJlY2F0aW9uJykpIHtcbiAgICByZXR1cm4gZm47XG4gIH1cblxuICB2YXIgd2FybmVkID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGRlcHJlY2F0ZWQoKSB7XG4gICAgaWYgKCF3YXJuZWQpIHtcbiAgICAgIGlmIChjb25maWcoJ3Rocm93RGVwcmVjYXRpb24nKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICAgIH0gZWxzZSBpZiAoY29uZmlnKCd0cmFjZURlcHJlY2F0aW9uJykpIHtcbiAgICAgICAgY29uc29sZS50cmFjZShtc2cpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS53YXJuKG1zZyk7XG4gICAgICB9XG4gICAgICB3YXJuZWQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIHJldHVybiBkZXByZWNhdGVkO1xufVxuXG4vKipcbiAqIENoZWNrcyBgbG9jYWxTdG9yYWdlYCBmb3IgYm9vbGVhbiB2YWx1ZXMgZm9yIHRoZSBnaXZlbiBgbmFtZWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEByZXR1cm5zIHtCb29sZWFufVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gY29uZmlnIChuYW1lKSB7XG4gIC8vIGFjY2Vzc2luZyBnbG9iYWwubG9jYWxTdG9yYWdlIGNhbiB0cmlnZ2VyIGEgRE9NRXhjZXB0aW9uIGluIHNhbmRib3hlZCBpZnJhbWVzXG4gIHRyeSB7XG4gICAgaWYgKCFnbG9iYWwubG9jYWxTdG9yYWdlKSByZXR1cm4gZmFsc2U7XG4gIH0gY2F0Y2ggKF8pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHZhbCA9IGdsb2JhbC5sb2NhbFN0b3JhZ2VbbmFtZV07XG4gIGlmIChudWxsID09IHZhbCkgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gU3RyaW5nKHZhbCkudG9Mb3dlckNhc2UoKSA9PT0gJ3RydWUnO1xufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0J1ZmZlcihhcmcpIHtcbiAgcmV0dXJuIGFyZyAmJiB0eXBlb2YgYXJnID09PSAnb2JqZWN0J1xuICAgICYmIHR5cGVvZiBhcmcuY29weSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICYmIHR5cGVvZiBhcmcuZmlsbCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICYmIHR5cGVvZiBhcmcucmVhZFVJbnQ4ID09PSAnZnVuY3Rpb24nO1xufSIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG52YXIgZm9ybWF0UmVnRXhwID0gLyVbc2RqJV0vZztcbmV4cG9ydHMuZm9ybWF0ID0gZnVuY3Rpb24oZikge1xuICBpZiAoIWlzU3RyaW5nKGYpKSB7XG4gICAgdmFyIG9iamVjdHMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgb2JqZWN0cy5wdXNoKGluc3BlY3QoYXJndW1lbnRzW2ldKSk7XG4gICAgfVxuICAgIHJldHVybiBvYmplY3RzLmpvaW4oJyAnKTtcbiAgfVxuXG4gIHZhciBpID0gMTtcbiAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gIHZhciBsZW4gPSBhcmdzLmxlbmd0aDtcbiAgdmFyIHN0ciA9IFN0cmluZyhmKS5yZXBsYWNlKGZvcm1hdFJlZ0V4cCwgZnVuY3Rpb24oeCkge1xuICAgIGlmICh4ID09PSAnJSUnKSByZXR1cm4gJyUnO1xuICAgIGlmIChpID49IGxlbikgcmV0dXJuIHg7XG4gICAgc3dpdGNoICh4KSB7XG4gICAgICBjYXNlICclcyc6IHJldHVybiBTdHJpbmcoYXJnc1tpKytdKTtcbiAgICAgIGNhc2UgJyVkJzogcmV0dXJuIE51bWJlcihhcmdzW2krK10pO1xuICAgICAgY2FzZSAnJWonOlxuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShhcmdzW2krK10pO1xuICAgICAgICB9IGNhdGNoIChfKSB7XG4gICAgICAgICAgcmV0dXJuICdbQ2lyY3VsYXJdJztcbiAgICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHg7XG4gICAgfVxuICB9KTtcbiAgZm9yICh2YXIgeCA9IGFyZ3NbaV07IGkgPCBsZW47IHggPSBhcmdzWysraV0pIHtcbiAgICBpZiAoaXNOdWxsKHgpIHx8ICFpc09iamVjdCh4KSkge1xuICAgICAgc3RyICs9ICcgJyArIHg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciArPSAnICcgKyBpbnNwZWN0KHgpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc3RyO1xufTtcblxuXG4vLyBNYXJrIHRoYXQgYSBtZXRob2Qgc2hvdWxkIG5vdCBiZSB1c2VkLlxuLy8gUmV0dXJucyBhIG1vZGlmaWVkIGZ1bmN0aW9uIHdoaWNoIHdhcm5zIG9uY2UgYnkgZGVmYXVsdC5cbi8vIElmIC0tbm8tZGVwcmVjYXRpb24gaXMgc2V0LCB0aGVuIGl0IGlzIGEgbm8tb3AuXG5leHBvcnRzLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uKGZuLCBtc2cpIHtcbiAgLy8gQWxsb3cgZm9yIGRlcHJlY2F0aW5nIHRoaW5ncyBpbiB0aGUgcHJvY2VzcyBvZiBzdGFydGluZyB1cC5cbiAgaWYgKGlzVW5kZWZpbmVkKGdsb2JhbC5wcm9jZXNzKSkge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBleHBvcnRzLmRlcHJlY2F0ZShmbiwgbXNnKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH1cblxuICBpZiAocHJvY2Vzcy5ub0RlcHJlY2F0aW9uID09PSB0cnVlKSB7XG4gICAgcmV0dXJuIGZuO1xuICB9XG5cbiAgdmFyIHdhcm5lZCA9IGZhbHNlO1xuICBmdW5jdGlvbiBkZXByZWNhdGVkKCkge1xuICAgIGlmICghd2FybmVkKSB7XG4gICAgICBpZiAocHJvY2Vzcy50aHJvd0RlcHJlY2F0aW9uKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLnRyYWNlRGVwcmVjYXRpb24pIHtcbiAgICAgICAgY29uc29sZS50cmFjZShtc2cpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihtc2cpO1xuICAgICAgfVxuICAgICAgd2FybmVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICByZXR1cm4gZGVwcmVjYXRlZDtcbn07XG5cblxudmFyIGRlYnVncyA9IHt9O1xudmFyIGRlYnVnRW52aXJvbjtcbmV4cG9ydHMuZGVidWdsb2cgPSBmdW5jdGlvbihzZXQpIHtcbiAgaWYgKGlzVW5kZWZpbmVkKGRlYnVnRW52aXJvbikpXG4gICAgZGVidWdFbnZpcm9uID0gcHJvY2Vzcy5lbnYuTk9ERV9ERUJVRyB8fCAnJztcbiAgc2V0ID0gc2V0LnRvVXBwZXJDYXNlKCk7XG4gIGlmICghZGVidWdzW3NldF0pIHtcbiAgICBpZiAobmV3IFJlZ0V4cCgnXFxcXGInICsgc2V0ICsgJ1xcXFxiJywgJ2knKS50ZXN0KGRlYnVnRW52aXJvbikpIHtcbiAgICAgIHZhciBwaWQgPSBwcm9jZXNzLnBpZDtcbiAgICAgIGRlYnVnc1tzZXRdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBtc2cgPSBleHBvcnRzLmZvcm1hdC5hcHBseShleHBvcnRzLCBhcmd1bWVudHMpO1xuICAgICAgICBjb25zb2xlLmVycm9yKCclcyAlZDogJXMnLCBzZXQsIHBpZCwgbXNnKTtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlYnVnc1tzZXRdID0gZnVuY3Rpb24oKSB7fTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRlYnVnc1tzZXRdO1xufTtcblxuXG4vKipcbiAqIEVjaG9zIHRoZSB2YWx1ZSBvZiBhIHZhbHVlLiBUcnlzIHRvIHByaW50IHRoZSB2YWx1ZSBvdXRcbiAqIGluIHRoZSBiZXN0IHdheSBwb3NzaWJsZSBnaXZlbiB0aGUgZGlmZmVyZW50IHR5cGVzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCB0byBwcmludCBvdXQuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0cyBPcHRpb25hbCBvcHRpb25zIG9iamVjdCB0aGF0IGFsdGVycyB0aGUgb3V0cHV0LlxuICovXG4vKiBsZWdhY3k6IG9iaiwgc2hvd0hpZGRlbiwgZGVwdGgsIGNvbG9ycyovXG5mdW5jdGlvbiBpbnNwZWN0KG9iaiwgb3B0cykge1xuICAvLyBkZWZhdWx0IG9wdGlvbnNcbiAgdmFyIGN0eCA9IHtcbiAgICBzZWVuOiBbXSxcbiAgICBzdHlsaXplOiBzdHlsaXplTm9Db2xvclxuICB9O1xuICAvLyBsZWdhY3kuLi5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gMykgY3R4LmRlcHRoID0gYXJndW1lbnRzWzJdO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSA0KSBjdHguY29sb3JzID0gYXJndW1lbnRzWzNdO1xuICBpZiAoaXNCb29sZWFuKG9wdHMpKSB7XG4gICAgLy8gbGVnYWN5Li4uXG4gICAgY3R4LnNob3dIaWRkZW4gPSBvcHRzO1xuICB9IGVsc2UgaWYgKG9wdHMpIHtcbiAgICAvLyBnb3QgYW4gXCJvcHRpb25zXCIgb2JqZWN0XG4gICAgZXhwb3J0cy5fZXh0ZW5kKGN0eCwgb3B0cyk7XG4gIH1cbiAgLy8gc2V0IGRlZmF1bHQgb3B0aW9uc1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LnNob3dIaWRkZW4pKSBjdHguc2hvd0hpZGRlbiA9IGZhbHNlO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmRlcHRoKSkgY3R4LmRlcHRoID0gMjtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5jb2xvcnMpKSBjdHguY29sb3JzID0gZmFsc2U7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguY3VzdG9tSW5zcGVjdCkpIGN0eC5jdXN0b21JbnNwZWN0ID0gdHJ1ZTtcbiAgaWYgKGN0eC5jb2xvcnMpIGN0eC5zdHlsaXplID0gc3R5bGl6ZVdpdGhDb2xvcjtcbiAgcmV0dXJuIGZvcm1hdFZhbHVlKGN0eCwgb2JqLCBjdHguZGVwdGgpO1xufVxuZXhwb3J0cy5pbnNwZWN0ID0gaW5zcGVjdDtcblxuXG4vLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0FOU0lfZXNjYXBlX2NvZGUjZ3JhcGhpY3Ncbmluc3BlY3QuY29sb3JzID0ge1xuICAnYm9sZCcgOiBbMSwgMjJdLFxuICAnaXRhbGljJyA6IFszLCAyM10sXG4gICd1bmRlcmxpbmUnIDogWzQsIDI0XSxcbiAgJ2ludmVyc2UnIDogWzcsIDI3XSxcbiAgJ3doaXRlJyA6IFszNywgMzldLFxuICAnZ3JleScgOiBbOTAsIDM5XSxcbiAgJ2JsYWNrJyA6IFszMCwgMzldLFxuICAnYmx1ZScgOiBbMzQsIDM5XSxcbiAgJ2N5YW4nIDogWzM2LCAzOV0sXG4gICdncmVlbicgOiBbMzIsIDM5XSxcbiAgJ21hZ2VudGEnIDogWzM1LCAzOV0sXG4gICdyZWQnIDogWzMxLCAzOV0sXG4gICd5ZWxsb3cnIDogWzMzLCAzOV1cbn07XG5cbi8vIERvbid0IHVzZSAnYmx1ZScgbm90IHZpc2libGUgb24gY21kLmV4ZVxuaW5zcGVjdC5zdHlsZXMgPSB7XG4gICdzcGVjaWFsJzogJ2N5YW4nLFxuICAnbnVtYmVyJzogJ3llbGxvdycsXG4gICdib29sZWFuJzogJ3llbGxvdycsXG4gICd1bmRlZmluZWQnOiAnZ3JleScsXG4gICdudWxsJzogJ2JvbGQnLFxuICAnc3RyaW5nJzogJ2dyZWVuJyxcbiAgJ2RhdGUnOiAnbWFnZW50YScsXG4gIC8vIFwibmFtZVwiOiBpbnRlbnRpb25hbGx5IG5vdCBzdHlsaW5nXG4gICdyZWdleHAnOiAncmVkJ1xufTtcblxuXG5mdW5jdGlvbiBzdHlsaXplV2l0aENvbG9yKHN0ciwgc3R5bGVUeXBlKSB7XG4gIHZhciBzdHlsZSA9IGluc3BlY3Quc3R5bGVzW3N0eWxlVHlwZV07XG5cbiAgaWYgKHN0eWxlKSB7XG4gICAgcmV0dXJuICdcXHUwMDFiWycgKyBpbnNwZWN0LmNvbG9yc1tzdHlsZV1bMF0gKyAnbScgKyBzdHIgK1xuICAgICAgICAgICAnXFx1MDAxYlsnICsgaW5zcGVjdC5jb2xvcnNbc3R5bGVdWzFdICsgJ20nO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBzdHI7XG4gIH1cbn1cblxuXG5mdW5jdGlvbiBzdHlsaXplTm9Db2xvcihzdHIsIHN0eWxlVHlwZSkge1xuICByZXR1cm4gc3RyO1xufVxuXG5cbmZ1bmN0aW9uIGFycmF5VG9IYXNoKGFycmF5KSB7XG4gIHZhciBoYXNoID0ge307XG5cbiAgYXJyYXkuZm9yRWFjaChmdW5jdGlvbih2YWwsIGlkeCkge1xuICAgIGhhc2hbdmFsXSA9IHRydWU7XG4gIH0pO1xuXG4gIHJldHVybiBoYXNoO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFZhbHVlKGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcykge1xuICAvLyBQcm92aWRlIGEgaG9vayBmb3IgdXNlci1zcGVjaWZpZWQgaW5zcGVjdCBmdW5jdGlvbnMuXG4gIC8vIENoZWNrIHRoYXQgdmFsdWUgaXMgYW4gb2JqZWN0IHdpdGggYW4gaW5zcGVjdCBmdW5jdGlvbiBvbiBpdFxuICBpZiAoY3R4LmN1c3RvbUluc3BlY3QgJiZcbiAgICAgIHZhbHVlICYmXG4gICAgICBpc0Z1bmN0aW9uKHZhbHVlLmluc3BlY3QpICYmXG4gICAgICAvLyBGaWx0ZXIgb3V0IHRoZSB1dGlsIG1vZHVsZSwgaXQncyBpbnNwZWN0IGZ1bmN0aW9uIGlzIHNwZWNpYWxcbiAgICAgIHZhbHVlLmluc3BlY3QgIT09IGV4cG9ydHMuaW5zcGVjdCAmJlxuICAgICAgLy8gQWxzbyBmaWx0ZXIgb3V0IGFueSBwcm90b3R5cGUgb2JqZWN0cyB1c2luZyB0aGUgY2lyY3VsYXIgY2hlY2suXG4gICAgICAhKHZhbHVlLmNvbnN0cnVjdG9yICYmIHZhbHVlLmNvbnN0cnVjdG9yLnByb3RvdHlwZSA9PT0gdmFsdWUpKSB7XG4gICAgdmFyIHJldCA9IHZhbHVlLmluc3BlY3QocmVjdXJzZVRpbWVzLCBjdHgpO1xuICAgIGlmICghaXNTdHJpbmcocmV0KSkge1xuICAgICAgcmV0ID0gZm9ybWF0VmFsdWUoY3R4LCByZXQsIHJlY3Vyc2VUaW1lcyk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cblxuICAvLyBQcmltaXRpdmUgdHlwZXMgY2Fubm90IGhhdmUgcHJvcGVydGllc1xuICB2YXIgcHJpbWl0aXZlID0gZm9ybWF0UHJpbWl0aXZlKGN0eCwgdmFsdWUpO1xuICBpZiAocHJpbWl0aXZlKSB7XG4gICAgcmV0dXJuIHByaW1pdGl2ZTtcbiAgfVxuXG4gIC8vIExvb2sgdXAgdGhlIGtleXMgb2YgdGhlIG9iamVjdC5cbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyh2YWx1ZSk7XG4gIHZhciB2aXNpYmxlS2V5cyA9IGFycmF5VG9IYXNoKGtleXMpO1xuXG4gIGlmIChjdHguc2hvd0hpZGRlbikge1xuICAgIGtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh2YWx1ZSk7XG4gIH1cblxuICAvLyBJRSBkb2Vzbid0IG1ha2UgZXJyb3IgZmllbGRzIG5vbi1lbnVtZXJhYmxlXG4gIC8vIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9pZS9kd3c1MnNidCh2PXZzLjk0KS5hc3B4XG4gIGlmIChpc0Vycm9yKHZhbHVlKVxuICAgICAgJiYgKGtleXMuaW5kZXhPZignbWVzc2FnZScpID49IDAgfHwga2V5cy5pbmRleE9mKCdkZXNjcmlwdGlvbicpID49IDApKSB7XG4gICAgcmV0dXJuIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgfVxuXG4gIC8vIFNvbWUgdHlwZSBvZiBvYmplY3Qgd2l0aG91dCBwcm9wZXJ0aWVzIGNhbiBiZSBzaG9ydGN1dHRlZC5cbiAgaWYgKGtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgICB2YXIgbmFtZSA9IHZhbHVlLm5hbWUgPyAnOiAnICsgdmFsdWUubmFtZSA6ICcnO1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKCdbRnVuY3Rpb24nICsgbmFtZSArICddJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gICAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdyZWdleHAnKTtcbiAgICB9XG4gICAgaWYgKGlzRGF0ZSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ2RhdGUnKTtcbiAgICB9XG4gICAgaWYgKGlzRXJyb3IodmFsdWUpKSB7XG4gICAgICByZXR1cm4gZm9ybWF0RXJyb3IodmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBiYXNlID0gJycsIGFycmF5ID0gZmFsc2UsIGJyYWNlcyA9IFsneycsICd9J107XG5cbiAgLy8gTWFrZSBBcnJheSBzYXkgdGhhdCB0aGV5IGFyZSBBcnJheVxuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICBhcnJheSA9IHRydWU7XG4gICAgYnJhY2VzID0gWydbJywgJ10nXTtcbiAgfVxuXG4gIC8vIE1ha2UgZnVuY3Rpb25zIHNheSB0aGF0IHRoZXkgYXJlIGZ1bmN0aW9uc1xuICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICB2YXIgbiA9IHZhbHVlLm5hbWUgPyAnOiAnICsgdmFsdWUubmFtZSA6ICcnO1xuICAgIGJhc2UgPSAnIFtGdW5jdGlvbicgKyBuICsgJ10nO1xuICB9XG5cbiAgLy8gTWFrZSBSZWdFeHBzIHNheSB0aGF0IHRoZXkgYXJlIFJlZ0V4cHNcbiAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICB9XG5cbiAgLy8gTWFrZSBkYXRlcyB3aXRoIHByb3BlcnRpZXMgZmlyc3Qgc2F5IHRoZSBkYXRlXG4gIGlmIChpc0RhdGUodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIERhdGUucHJvdG90eXBlLnRvVVRDU3RyaW5nLmNhbGwodmFsdWUpO1xuICB9XG5cbiAgLy8gTWFrZSBlcnJvciB3aXRoIG1lc3NhZ2UgZmlyc3Qgc2F5IHRoZSBlcnJvclxuICBpZiAoaXNFcnJvcih2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgZm9ybWF0RXJyb3IodmFsdWUpO1xuICB9XG5cbiAgaWYgKGtleXMubGVuZ3RoID09PSAwICYmICghYXJyYXkgfHwgdmFsdWUubGVuZ3RoID09IDApKSB7XG4gICAgcmV0dXJuIGJyYWNlc1swXSArIGJhc2UgKyBicmFjZXNbMV07XG4gIH1cblxuICBpZiAocmVjdXJzZVRpbWVzIDwgMCkge1xuICAgIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAncmVnZXhwJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnW09iamVjdF0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuXG4gIGN0eC5zZWVuLnB1c2godmFsdWUpO1xuXG4gIHZhciBvdXRwdXQ7XG4gIGlmIChhcnJheSkge1xuICAgIG91dHB1dCA9IGZvcm1hdEFycmF5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleXMpO1xuICB9IGVsc2Uge1xuICAgIG91dHB1dCA9IGtleXMubWFwKGZ1bmN0aW9uKGtleSkge1xuICAgICAgcmV0dXJuIGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleSwgYXJyYXkpO1xuICAgIH0pO1xuICB9XG5cbiAgY3R4LnNlZW4ucG9wKCk7XG5cbiAgcmV0dXJuIHJlZHVjZVRvU2luZ2xlU3RyaW5nKG91dHB1dCwgYmFzZSwgYnJhY2VzKTtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRQcmltaXRpdmUoY3R4LCB2YWx1ZSkge1xuICBpZiAoaXNVbmRlZmluZWQodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgndW5kZWZpbmVkJywgJ3VuZGVmaW5lZCcpO1xuICBpZiAoaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgdmFyIHNpbXBsZSA9ICdcXCcnICsgSlNPTi5zdHJpbmdpZnkodmFsdWUpLnJlcGxhY2UoL15cInxcIiQvZywgJycpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvJy9nLCBcIlxcXFwnXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXFwiL2csICdcIicpICsgJ1xcJyc7XG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKHNpbXBsZSwgJ3N0cmluZycpO1xuICB9XG4gIGlmIChpc051bWJlcih2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCcnICsgdmFsdWUsICdudW1iZXInKTtcbiAgaWYgKGlzQm9vbGVhbih2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCcnICsgdmFsdWUsICdib29sZWFuJyk7XG4gIC8vIEZvciBzb21lIHJlYXNvbiB0eXBlb2YgbnVsbCBpcyBcIm9iamVjdFwiLCBzbyBzcGVjaWFsIGNhc2UgaGVyZS5cbiAgaWYgKGlzTnVsbCh2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCdudWxsJywgJ251bGwnKTtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRFcnJvcih2YWx1ZSkge1xuICByZXR1cm4gJ1snICsgRXJyb3IucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpICsgJ10nO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdEFycmF5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleXMpIHtcbiAgdmFyIG91dHB1dCA9IFtdO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eSh2YWx1ZSwgU3RyaW5nKGkpKSkge1xuICAgICAgb3V0cHV0LnB1c2goZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cyxcbiAgICAgICAgICBTdHJpbmcoaSksIHRydWUpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0cHV0LnB1c2goJycpO1xuICAgIH1cbiAgfVxuICBrZXlzLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgaWYgKCFrZXkubWF0Y2goL15cXGQrJC8pKSB7XG4gICAgICBvdXRwdXQucHVzaChmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLFxuICAgICAgICAgIGtleSwgdHJ1ZSkpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBvdXRwdXQ7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5LCBhcnJheSkge1xuICB2YXIgbmFtZSwgc3RyLCBkZXNjO1xuICBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih2YWx1ZSwga2V5KSB8fCB7IHZhbHVlOiB2YWx1ZVtrZXldIH07XG4gIGlmIChkZXNjLmdldCkge1xuICAgIGlmIChkZXNjLnNldCkge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tHZXR0ZXIvU2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbR2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChkZXNjLnNldCkge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tTZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cbiAgaWYgKCFoYXNPd25Qcm9wZXJ0eSh2aXNpYmxlS2V5cywga2V5KSkge1xuICAgIG5hbWUgPSAnWycgKyBrZXkgKyAnXSc7XG4gIH1cbiAgaWYgKCFzdHIpIHtcbiAgICBpZiAoY3R4LnNlZW4uaW5kZXhPZihkZXNjLnZhbHVlKSA8IDApIHtcbiAgICAgIGlmIChpc051bGwocmVjdXJzZVRpbWVzKSkge1xuICAgICAgICBzdHIgPSBmb3JtYXRWYWx1ZShjdHgsIGRlc2MudmFsdWUsIG51bGwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RyID0gZm9ybWF0VmFsdWUoY3R4LCBkZXNjLnZhbHVlLCByZWN1cnNlVGltZXMgLSAxKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdHIuaW5kZXhPZignXFxuJykgPiAtMSkge1xuICAgICAgICBpZiAoYXJyYXkpIHtcbiAgICAgICAgICBzdHIgPSBzdHIuc3BsaXQoJ1xcbicpLm1hcChmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICByZXR1cm4gJyAgJyArIGxpbmU7XG4gICAgICAgICAgfSkuam9pbignXFxuJykuc3Vic3RyKDIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0ciA9ICdcXG4nICsgc3RyLnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgcmV0dXJuICcgICAnICsgbGluZTtcbiAgICAgICAgICB9KS5qb2luKCdcXG4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0NpcmN1bGFyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG4gIGlmIChpc1VuZGVmaW5lZChuYW1lKSkge1xuICAgIGlmIChhcnJheSAmJiBrZXkubWF0Y2goL15cXGQrJC8pKSB7XG4gICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgICBuYW1lID0gSlNPTi5zdHJpbmdpZnkoJycgKyBrZXkpO1xuICAgIGlmIChuYW1lLm1hdGNoKC9eXCIoW2EtekEtWl9dW2EtekEtWl8wLTldKilcIiQvKSkge1xuICAgICAgbmFtZSA9IG5hbWUuc3Vic3RyKDEsIG5hbWUubGVuZ3RoIC0gMik7XG4gICAgICBuYW1lID0gY3R4LnN0eWxpemUobmFtZSwgJ25hbWUnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZSgvJy9nLCBcIlxcXFwnXCIpXG4gICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcXCIvZywgJ1wiJylcbiAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLyheXCJ8XCIkKS9nLCBcIidcIik7XG4gICAgICBuYW1lID0gY3R4LnN0eWxpemUobmFtZSwgJ3N0cmluZycpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuYW1lICsgJzogJyArIHN0cjtcbn1cblxuXG5mdW5jdGlvbiByZWR1Y2VUb1NpbmdsZVN0cmluZyhvdXRwdXQsIGJhc2UsIGJyYWNlcykge1xuICB2YXIgbnVtTGluZXNFc3QgPSAwO1xuICB2YXIgbGVuZ3RoID0gb3V0cHV0LnJlZHVjZShmdW5jdGlvbihwcmV2LCBjdXIpIHtcbiAgICBudW1MaW5lc0VzdCsrO1xuICAgIGlmIChjdXIuaW5kZXhPZignXFxuJykgPj0gMCkgbnVtTGluZXNFc3QrKztcbiAgICByZXR1cm4gcHJldiArIGN1ci5yZXBsYWNlKC9cXHUwMDFiXFxbXFxkXFxkP20vZywgJycpLmxlbmd0aCArIDE7XG4gIH0sIDApO1xuXG4gIGlmIChsZW5ndGggPiA2MCkge1xuICAgIHJldHVybiBicmFjZXNbMF0gK1xuICAgICAgICAgICAoYmFzZSA9PT0gJycgPyAnJyA6IGJhc2UgKyAnXFxuICcpICtcbiAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgb3V0cHV0LmpvaW4oJyxcXG4gICcpICtcbiAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgYnJhY2VzWzFdO1xuICB9XG5cbiAgcmV0dXJuIGJyYWNlc1swXSArIGJhc2UgKyAnICcgKyBvdXRwdXQuam9pbignLCAnKSArICcgJyArIGJyYWNlc1sxXTtcbn1cblxuXG4vLyBOT1RFOiBUaGVzZSB0eXBlIGNoZWNraW5nIGZ1bmN0aW9ucyBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBgaW5zdGFuY2VvZmBcbi8vIGJlY2F1c2UgaXQgaXMgZnJhZ2lsZSBhbmQgY2FuIGJlIGVhc2lseSBmYWtlZCB3aXRoIGBPYmplY3QuY3JlYXRlKClgLlxuZnVuY3Rpb24gaXNBcnJheShhcikge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShhcik7XG59XG5leHBvcnRzLmlzQXJyYXkgPSBpc0FycmF5O1xuXG5mdW5jdGlvbiBpc0Jvb2xlYW4oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnYm9vbGVhbic7XG59XG5leHBvcnRzLmlzQm9vbGVhbiA9IGlzQm9vbGVhbjtcblxuZnVuY3Rpb24gaXNOdWxsKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGwgPSBpc051bGw7XG5cbmZ1bmN0aW9uIGlzTnVsbE9yVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbE9yVW5kZWZpbmVkID0gaXNOdWxsT3JVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzTnVtYmVyKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ251bWJlcic7XG59XG5leHBvcnRzLmlzTnVtYmVyID0gaXNOdW1iZXI7XG5cbmZ1bmN0aW9uIGlzU3RyaW5nKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N0cmluZyc7XG59XG5leHBvcnRzLmlzU3RyaW5nID0gaXNTdHJpbmc7XG5cbmZ1bmN0aW9uIGlzU3ltYm9sKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCc7XG59XG5leHBvcnRzLmlzU3ltYm9sID0gaXNTeW1ib2w7XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09PSB2b2lkIDA7XG59XG5leHBvcnRzLmlzVW5kZWZpbmVkID0gaXNVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzUmVnRXhwKHJlKSB7XG4gIHJldHVybiBpc09iamVjdChyZSkgJiYgb2JqZWN0VG9TdHJpbmcocmUpID09PSAnW29iamVjdCBSZWdFeHBdJztcbn1cbmV4cG9ydHMuaXNSZWdFeHAgPSBpc1JlZ0V4cDtcblxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG59XG5leHBvcnRzLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG5cbmZ1bmN0aW9uIGlzRGF0ZShkKSB7XG4gIHJldHVybiBpc09iamVjdChkKSAmJiBvYmplY3RUb1N0cmluZyhkKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xufVxuZXhwb3J0cy5pc0RhdGUgPSBpc0RhdGU7XG5cbmZ1bmN0aW9uIGlzRXJyb3IoZSkge1xuICByZXR1cm4gaXNPYmplY3QoZSkgJiZcbiAgICAgIChvYmplY3RUb1N0cmluZyhlKSA9PT0gJ1tvYmplY3QgRXJyb3JdJyB8fCBlIGluc3RhbmNlb2YgRXJyb3IpO1xufVxuZXhwb3J0cy5pc0Vycm9yID0gaXNFcnJvcjtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XG59XG5leHBvcnRzLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xuXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZShhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbCB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnbnVtYmVyJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnIHx8ICAvLyBFUzYgc3ltYm9sXG4gICAgICAgICB0eXBlb2YgYXJnID09PSAndW5kZWZpbmVkJztcbn1cbmV4cG9ydHMuaXNQcmltaXRpdmUgPSBpc1ByaW1pdGl2ZTtcblxuZXhwb3J0cy5pc0J1ZmZlciA9IHJlcXVpcmUoJy4vc3VwcG9ydC9pc0J1ZmZlcicpO1xuXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyhvKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobyk7XG59XG5cblxuZnVuY3Rpb24gcGFkKG4pIHtcbiAgcmV0dXJuIG4gPCAxMCA/ICcwJyArIG4udG9TdHJpbmcoMTApIDogbi50b1N0cmluZygxMCk7XG59XG5cblxudmFyIG1vbnRocyA9IFsnSmFuJywgJ0ZlYicsICdNYXInLCAnQXByJywgJ01heScsICdKdW4nLCAnSnVsJywgJ0F1ZycsICdTZXAnLFxuICAgICAgICAgICAgICAnT2N0JywgJ05vdicsICdEZWMnXTtcblxuLy8gMjYgRmViIDE2OjE5OjM0XG5mdW5jdGlvbiB0aW1lc3RhbXAoKSB7XG4gIHZhciBkID0gbmV3IERhdGUoKTtcbiAgdmFyIHRpbWUgPSBbcGFkKGQuZ2V0SG91cnMoKSksXG4gICAgICAgICAgICAgIHBhZChkLmdldE1pbnV0ZXMoKSksXG4gICAgICAgICAgICAgIHBhZChkLmdldFNlY29uZHMoKSldLmpvaW4oJzonKTtcbiAgcmV0dXJuIFtkLmdldERhdGUoKSwgbW9udGhzW2QuZ2V0TW9udGgoKV0sIHRpbWVdLmpvaW4oJyAnKTtcbn1cblxuXG4vLyBsb2cgaXMganVzdCBhIHRoaW4gd3JhcHBlciB0byBjb25zb2xlLmxvZyB0aGF0IHByZXBlbmRzIGEgdGltZXN0YW1wXG5leHBvcnRzLmxvZyA9IGZ1bmN0aW9uKCkge1xuICBjb25zb2xlLmxvZygnJXMgLSAlcycsIHRpbWVzdGFtcCgpLCBleHBvcnRzLmZvcm1hdC5hcHBseShleHBvcnRzLCBhcmd1bWVudHMpKTtcbn07XG5cblxuLyoqXG4gKiBJbmhlcml0IHRoZSBwcm90b3R5cGUgbWV0aG9kcyBmcm9tIG9uZSBjb25zdHJ1Y3RvciBpbnRvIGFub3RoZXIuXG4gKlxuICogVGhlIEZ1bmN0aW9uLnByb3RvdHlwZS5pbmhlcml0cyBmcm9tIGxhbmcuanMgcmV3cml0dGVuIGFzIGEgc3RhbmRhbG9uZVxuICogZnVuY3Rpb24gKG5vdCBvbiBGdW5jdGlvbi5wcm90b3R5cGUpLiBOT1RFOiBJZiB0aGlzIGZpbGUgaXMgdG8gYmUgbG9hZGVkXG4gKiBkdXJpbmcgYm9vdHN0cmFwcGluZyB0aGlzIGZ1bmN0aW9uIG5lZWRzIHRvIGJlIHJld3JpdHRlbiB1c2luZyBzb21lIG5hdGl2ZVxuICogZnVuY3Rpb25zIGFzIHByb3RvdHlwZSBzZXR1cCB1c2luZyBub3JtYWwgSmF2YVNjcmlwdCBkb2VzIG5vdCB3b3JrIGFzXG4gKiBleHBlY3RlZCBkdXJpbmcgYm9vdHN0cmFwcGluZyAoc2VlIG1pcnJvci5qcyBpbiByMTE0OTAzKS5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjdG9yIENvbnN0cnVjdG9yIGZ1bmN0aW9uIHdoaWNoIG5lZWRzIHRvIGluaGVyaXQgdGhlXG4gKiAgICAgcHJvdG90eXBlLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gc3VwZXJDdG9yIENvbnN0cnVjdG9yIGZ1bmN0aW9uIHRvIGluaGVyaXQgcHJvdG90eXBlIGZyb20uXG4gKi9cbmV4cG9ydHMuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuXG5leHBvcnRzLl9leHRlbmQgPSBmdW5jdGlvbihvcmlnaW4sIGFkZCkge1xuICAvLyBEb24ndCBkbyBhbnl0aGluZyBpZiBhZGQgaXNuJ3QgYW4gb2JqZWN0XG4gIGlmICghYWRkIHx8ICFpc09iamVjdChhZGQpKSByZXR1cm4gb3JpZ2luO1xuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoYWRkKTtcbiAgdmFyIGkgPSBrZXlzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIG9yaWdpbltrZXlzW2ldXSA9IGFkZFtrZXlzW2ldXTtcbiAgfVxuICByZXR1cm4gb3JpZ2luO1xufTtcblxuZnVuY3Rpb24gaGFzT3duUHJvcGVydHkob2JqLCBwcm9wKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gTU9EVUxFUyAvL1xuXG52YXIgaXNTdHJpbmcgPSByZXF1aXJlKCAndmFsaWRhdGUuaW8tc3RyaW5nLXByaW1pdGl2ZScgKTtcbnZhciBpc05vbk5lZ2F0aXZlSW50ZWdlciA9IHJlcXVpcmUoICd2YWxpZGF0ZS5pby1ub25uZWdhdGl2ZS1pbnRlZ2VyJyApO1xudmFyIGNlaWwgPSByZXF1aXJlKCAnbWF0aC1jZWlsJyApO1xudmFyIHJlcGVhdCA9IHJlcXVpcmUoICd1dGlscy1yZXBlYXQtc3RyaW5nJyApO1xuXG5cbi8vIENPTlNUQU5UUyAvL1xuXG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTE7IC8vIDIqKjUzIC0gMVxuXG5cbi8vIExFRlQgUEFEIC8vXG5cbi8qKlxuKiBGVU5DVElPTjogbHBhZCggc3RyLCBsZW5bLCBwYWRdIClcbipcdExlZnQgcGFkcyBhIHN0cmluZyBzdWNoIHRoYXQgdGhlIHBhZGRlZCBzdHJpbmcgaGFzIGEgbGVuZ3RoIG9mIGF0IGxlYXN0IGBsZW5gLlxuKlxuKiBAcGFyYW0ge1N0cmluZ30gc3RyIC0gc3RyaW5nIHRvIHBhZFxuKiBAcGFyYW0ge051bWJlcn0gbGVuIC0gbWluaW11bSBzdHJpbmcgbGVuZ3RoXG4qIEBwYXJhbSB7U3RyaW5nfSBbcGFkPScgJ10gLSBzdHJpbmcgdXNlZCB0byBwYWRcbiogQHJldHVybnMge1N0cmluZ30gcGFkZGVkIHN0cmluZ1xuKi9cbmZ1bmN0aW9uIGxwYWQoIHN0ciwgbGVuLCBwYWQgKSB7XG5cdHZhciBuO1xuXHR2YXIgcDtcblx0aWYgKCAhaXNTdHJpbmcoIHN0ciApICkge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoICdpbnZhbGlkIGlucHV0IGFyZ3VtZW50LiBGaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nLiBWYWx1ZTogYCcgKyBzdHIgKyAnYC4nICk7XG5cdH1cblx0aWYgKCAhaXNOb25OZWdhdGl2ZUludGVnZXIoIGxlbiApICkge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoICdpbnZhbGlkIGlucHV0IGFyZ3VtZW50LiBTZWNvbmQgYXJndW1lbnQgbXVzdCBiZSBhIG5vbm5lZ2F0aXZlIGludGVnZXIuIFZhbHVlOiBgJyArIGxlbiArICdgLicgKTtcblx0fVxuXHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggPiAyICkge1xuXHRcdHAgPSBwYWQ7XG5cdFx0aWYgKCAhaXNTdHJpbmcoIHAgKSApIHtcblx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoICdpbnZhbGlkIGlucHV0IGFyZ3VtZW50LiBUaGlyZCBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nLiBWYWx1ZTogYCcgKyBwICsgJ2AuJyApO1xuXHRcdH1cblx0XHRpZiAoIHAubGVuZ3RoID09PSAwICkge1xuXHRcdFx0dGhyb3cgbmV3IFJhbmdlRXJyb3IoICdpbnZhbGlkIGlucHV0IGFyZ3VtZW50LiBQYWQgc3RyaW5nIG11c3Qgbm90IGJlIGFuIGVtcHR5IHN0cmluZy4nICk7XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdHAgPSAnICc7XG5cdH1cblx0aWYgKCBsZW4gPiBNQVhfU0FGRV9JTlRFR0VSICkge1xuXHRcdHRocm93IG5ldyBSYW5nZUVycm9yKCAnaW52YWxpZCBpbnB1dCBhcmd1bWVudC4gT3V0cHV0IHN0cmluZyBsZW5ndGggZXhjZWVkcyBtYXhpbXVtIGFsbG93ZWQgc3RyaW5nIGxlbmd0aC4nICk7XG5cdH1cblx0biA9ICggbGVuIC0gc3RyLmxlbmd0aCApIC8gcC5sZW5ndGg7XG5cdGlmICggbiA8PSAwICkge1xuXHRcdHJldHVybiBzdHI7XG5cdH1cblx0biA9IGNlaWwoIG4gKTtcblx0cmV0dXJuIHJlcGVhdCggcCwgbiApICsgc3RyO1xufSAvLyBlbmQgRlVOQ1RJT04gbHBhZCgpXG5cblxuLy8gRVhQT1JUUyAvL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGxwYWQ7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIE1PRFVMRVMgLy9cblxudmFyIGlzU3RyaW5nID0gcmVxdWlyZSggJ3ZhbGlkYXRlLmlvLXN0cmluZy1wcmltaXRpdmUnICk7XG52YXIgaXNOb25OZWdhdGl2ZUludGVnZXIgPSByZXF1aXJlKCAndmFsaWRhdGUuaW8tbm9ubmVnYXRpdmUtaW50ZWdlcicgKTtcblxuXG4vLyBOT1RFUyAvL1xuXG4vKipcbiogVGhlIGFsZ29yaXRobWljIHRyaWNrIHVzZWQgaW4gdGhlIGltcGxlbWVudGF0aW9uIGlzIHRvIHRyZWF0IHN0cmluZyBjb25jYXRlbmF0aW9uIHRoZSBzYW1lIGFzIGJpbmFyeSBhZGRpdGlvbiAoaS5lLiwgYW55IG5hdHVyYWwgbnVtYmVyIChub25uZWdhdGl2ZSBpbnRlZ2VyKSBjYW4gYmUgZXhwcmVzc2VkIGFzIGEgc3VtIG9mIHBvd2VycyBvZiB0d28pLlxuKlxuKiBGb3IgZXhhbXBsZSxcbipcbiogIG4gPSAxMCA9PiAxMDEwID0+IDJeMyArIDJeMCArIDJeMSArIDJeMFxuKlxuKiBXZSBjYW4gcHJvZHVjZSBhIDEwLXJlcGVhdCBzdHJpbmcgYnkgXCJhZGRpbmdcIiB0aGUgcmVzdWx0cyBvZiBhIDgtcmVwZWF0IHN0cmluZyBhbmQgYSAyLXJlcGVhdCBzdHJpbmcuXG4qXG4qIFRoZSBpbXBsZW1lbnRhdGlvbiBpcyB0aGVuIGFzIGZvbGxvd3M6XG4qICA6IExldCBgc2AgYmUgdGhlIHN0cmluZyB0byBiZSByZXBlYXRlZCBhbmQgYG9gIGJlIGFuIG91dHB1dCBzdHJpbmcuXG4qICAwKSBJbml0aWFsaXplIGFuIG91dHB1dCBzdHJpbmcgYG9gLlxuKiAgMSkgQ2hlY2sgdGhlIGxlYXN0IHNpZ25pZmljYW50IGJpdCB0byBkZXRlcm1pbmUgaWYgdGhlIGN1cnJlbnQgYHNgIHN0cmluZyBzaG91bGQgYmUgXCJhZGRlZFwiIHRvIHRoZSBvdXRwdXQgXCJ0b3RhbFwiLlxuKiAgICAgLSBpZiB0aGUgYml0IGlzIGEgb25lLCBhZGRcbiogICAgIC0gb3RoZXJ3aXNlLCBtb3ZlIG9uXG4qICAyKSBEb3VibGUgdGhlIHN0cmluZyBgc2AgYnkgYWRkaW5nIGBzYCB0byBgc2AuXG4qICAzKSBSaWdodC1zaGlmdCB0aGUgYml0cyBvZiBgbmAuXG4qICA0KSBDaGVjayBpZiB3ZSBoYXZlIHNoaWZ0ZWQgb2ZmIGFsbCBiaXRzLlxuKiAgICAgLSBpZiB5ZXMsIGRvbmUuXG4qICAgICAtIG90aGVyd2lzZSwgbW92ZSBvblxuKiAgNSkgUmVwZWF0IDEtNC5cbipcbiogVGhlIHJlc3VsdCBpcyB0aGF0LCBhcyB0aGUgc3RyaW5nIGlzIHJlcGVhdGVkLCB3ZSBjb250aW51YWxseSBjaGVjayB0byBzZWUgaWYgdGhlIGRvdWJsZWQgc3RyaW5nIGlzIG9uZSB3aGljaCB3ZSB3YW50IHRvIGFkZCB0byBvdXIgXCJ0b3RhbFwiLlxuKlxuKiBUaGUgYWxnb3JpdGhtIHJ1bnMgaW4gTyhsb2dfMihuKSkgY29tcGFyZWQgdG8gTyhuKS5cbiovXG5cblxuLy8gQ09OU1RBTlRTIC8vXG5cbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MTsgLy8gMioqNTMgLSAxXG5cblxuLy8gUkVQRUFUIC8vXG5cbi8qKlxuKiBGVU5DVElPTjogcmVwZWF0KCBzdHIsIG4gKVxuKlx0UmVwZWF0cyBhIHN0cmluZyBhIHNwZWNpZmllZCBudW1iZXIgb2YgdGltZXMgYW5kIHJldHVybnMgdGhlIGNvbmNhdGVuYXRlZCByZXN1bHQuXG4qXG4qIEBwYXJhbSB7U3RyaW5nfSBzdHIgLSBzdHJpbmcgdG8gcmVwZWF0XG4qIEBwYXJhbSB7TnVtYmVyfSBuIC0gbnVtYmVyIG9mIHRpbWVzIHRvIHJlcGVhdCB0aGUgc3RyaW5nXG4qIEByZXR1cm5zIHtTdHJpbmd9XG4qL1xuZnVuY3Rpb24gcmVwZWF0KCBzdHIsIG4gKSB7XG5cdHZhciBycHQ7XG5cdHZhciBjbnQ7XG5cdGlmICggIWlzU3RyaW5nKCBzdHIgKSApIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCAnaW52YWxpZCBpbnB1dCBhcmd1bWVudC4gRmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZy4gVmFsdWU6IGAnICsgc3RyICsgJ2AuJyApO1xuXHR9XG5cdGlmICggIWlzTm9uTmVnYXRpdmVJbnRlZ2VyKCBuICkgKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvciggJ2ludmFsaWQgaW5wdXQgYXJndW1lbnQuIFNlY29uZCBhcmd1bWVudCBtdXN0IGJlIGEgbm9ubmVnYXRpdmUgaW50ZWdlci4gVmFsdWU6IGAnICsgbiArICdgLicgKTtcblx0fVxuXHRpZiAoIHN0ci5sZW5ndGggPT09IDAgfHwgbiA9PT0gMCApIHtcblx0XHRyZXR1cm4gJyc7XG5cdH1cblx0Ly8gQ2hlY2sgdGhhdCBvdXRwdXQgc3RyaW5nIHdpbGwgbm90IGV4Y2VlZCB0aGUgbWF4aW11bSBzdHJpbmcgbGVuZ3RoOlxuXHRpZiAoIHN0ci5sZW5ndGggKiBuID4gTUFYX1NBRkVfSU5URUdFUiApIHtcblx0XHR0aHJvdyBuZXcgUmFuZ2VFcnJvciggJ2ludmFsaWQgaW5wdXQgYXJndW1lbnQuIE91dHB1dCBzdHJpbmcgbGVuZ3RoIGV4Y2VlZHMgbWF4aW11bSBhbGxvd2VkIHN0cmluZyBsZW5ndGguJyApO1xuXHR9XG5cdHJwdCA9ICcnO1xuXHRjbnQgPSBuO1xuXHRmb3IoIDsgOyApIHtcblx0XHQvLyBJZiB0aGUgY291bnQgaXMgb2RkLCBhcHBlbmQgdGhlIGN1cnJlbnQgY29uY2F0ZW5hdGVkIHN0cmluZzpcblx0XHRpZiAoIChjbnQmMSkgPT09IDEgKSB7XG5cdFx0XHRycHQgKz0gc3RyO1xuXHRcdH1cblx0XHQvLyBSaWdodC1zaGlmdCB0aGUgYml0czpcblx0XHRjbnQgPj4+PSAxO1xuXHRcdGlmICggY250ID09PSAwICkge1xuXHRcdFx0YnJlYWs7XG5cdFx0fVxuXHRcdC8vIERvdWJsZSB0aGUgc3RyaW5nOlxuXHRcdHN0ciArPSBzdHI7XG5cdH1cblx0cmV0dXJuIHJwdDtcbn0gLy8gZW5kIEZVTkNUSU9OIHJlcGVhdCgpXG5cblxuLy8gRVhQT1JUUyAvL1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcGVhdDtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gTU9EVUxFUyAvL1xuXG52YXIgaXNTdHJpbmcgPSByZXF1aXJlKCAndmFsaWRhdGUuaW8tc3RyaW5nLXByaW1pdGl2ZScgKTtcbnZhciBpc05vbk5lZ2F0aXZlSW50ZWdlciA9IHJlcXVpcmUoICd2YWxpZGF0ZS5pby1ub25uZWdhdGl2ZS1pbnRlZ2VyJyApO1xudmFyIGNlaWwgPSByZXF1aXJlKCAnbWF0aC1jZWlsJyApO1xudmFyIHJlcGVhdCA9IHJlcXVpcmUoICd1dGlscy1yZXBlYXQtc3RyaW5nJyApO1xuXG5cbi8vIENPTlNUQU5UUyAvL1xuXG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTE7IC8vIDIqKjUzIC0gMVxuXG5cbi8vIFJJR0hUIFBBRCAvL1xuXG4vKipcbiogRlVOQ1RJT046IHJwYWQoIHN0ciwgbGVuWywgcGFkXSApXG4qXHRSaWdodCBwYWRzIGEgc3RyaW5nIHN1Y2ggdGhhdCB0aGUgcGFkZGVkIHN0cmluZyBoYXMgYSBsZW5ndGggb2YgYXQgbGVhc3QgYGxlbmAuXG4qXG4qIEBwYXJhbSB7U3RyaW5nfSBzdHIgLSBzdHJpbmcgdG8gcGFkXG4qIEBwYXJhbSB7TnVtYmVyfSBsZW4gLSBtaW5pbXVtIHN0cmluZyBsZW5ndGhcbiogQHBhcmFtIHtTdHJpbmd9IFtwYWQ9JyAnXSAtIHN0cmluZyB1c2VkIHRvIHBhZFxuKiBAcmV0dXJucyB7U3RyaW5nfSBwYWRkZWQgc3RyaW5nXG4qL1xuZnVuY3Rpb24gcnBhZCggc3RyLCBsZW4sIHBhZCApIHtcblx0dmFyIG47XG5cdHZhciBwO1xuXHRpZiAoICFpc1N0cmluZyggc3RyICkgKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvciggJ2ludmFsaWQgaW5wdXQgYXJndW1lbnQuIEZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcuIFZhbHVlOiBgJyArIHN0ciArICdgLicgKTtcblx0fVxuXHRpZiAoICFpc05vbk5lZ2F0aXZlSW50ZWdlciggbGVuICkgKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvciggJ2ludmFsaWQgaW5wdXQgYXJndW1lbnQuIFNlY29uZCBhcmd1bWVudCBtdXN0IGJlIGEgbm9ubmVnYXRpdmUgaW50ZWdlci4gVmFsdWU6IGAnICsgbGVuICsgJ2AuJyApO1xuXHR9XG5cdGlmICggYXJndW1lbnRzLmxlbmd0aCA+IDIgKSB7XG5cdFx0cCA9IHBhZDtcblx0XHRpZiAoICFpc1N0cmluZyggcCApICkge1xuXHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvciggJ2ludmFsaWQgaW5wdXQgYXJndW1lbnQuIFRoaXJkIGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcuIFZhbHVlOiBgJyArIHAgKyAnYC4nICk7XG5cdFx0fVxuXHRcdGlmICggcC5sZW5ndGggPT09IDAgKSB7XG5cdFx0XHR0aHJvdyBuZXcgUmFuZ2VFcnJvciggJ2ludmFsaWQgaW5wdXQgYXJndW1lbnQuIFBhZCBzdHJpbmcgbXVzdCBub3QgYmUgYW4gZW1wdHkgc3RyaW5nLicgKTtcblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0cCA9ICcgJztcblx0fVxuXHRpZiAoIGxlbiA+IE1BWF9TQUZFX0lOVEVHRVIgKSB7XG5cdFx0dGhyb3cgbmV3IFJhbmdlRXJyb3IoICdpbnZhbGlkIGlucHV0IGFyZ3VtZW50LiBPdXRwdXQgc3RyaW5nIGxlbmd0aCBleGNlZWRzIG1heGltdW0gYWxsb3dlZCBzdHJpbmcgbGVuZ3RoLicgKTtcblx0fVxuXHRuID0gKCBsZW4gLSBzdHIubGVuZ3RoICkgLyBwLmxlbmd0aDtcblx0aWYgKCBuIDw9IDAgKSB7XG5cdFx0cmV0dXJuIHN0cjtcblx0fVxuXHRuID0gY2VpbCggbiApO1xuXHRyZXR1cm4gc3RyICsgcmVwZWF0KCBwLCBuICk7XG59IC8vIGVuZCBGVU5DVElPTiBycGFkKClcblxuXG4vLyBFWFBPUlRTIC8vXG5cbm1vZHVsZS5leHBvcnRzID0gcnBhZDtcbiIsIi8qKlxuKlxuKlx0VkFMSURBVEU6IGludGVnZXJcbipcbipcbipcdERFU0NSSVBUSU9OOlxuKlx0XHQtIFZhbGlkYXRlcyBpZiBhIHZhbHVlIGlzIGFuIGludGVnZXIuXG4qXG4qXG4qXHROT1RFUzpcbipcdFx0WzFdXG4qXG4qXG4qXHRUT0RPOlxuKlx0XHRbMV1cbipcbipcbipcdExJQ0VOU0U6XG4qXHRcdE1JVFxuKlxuKlx0Q29weXJpZ2h0IChjKSAyMDE0LiBBdGhhbiBSZWluZXMuXG4qXG4qXG4qXHRBVVRIT1I6XG4qXHRcdEF0aGFuIFJlaW5lcy4ga2dyeXRlQGdtYWlsLmNvbS4gMjAxNC5cbipcbiovXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gTU9EVUxFUyAvL1xuXG52YXIgaXNOdW1iZXIgPSByZXF1aXJlKCAndmFsaWRhdGUuaW8tbnVtYmVyJyApO1xuXG5cbi8vIElTSU5URUdFUiAvL1xuXG4vKipcbiogRlVOQ1RJT046IGlzSW50ZWdlciggdmFsdWUgKVxuKlx0VmFsaWRhdGVzIGlmIGEgdmFsdWUgaXMgYW4gaW50ZWdlci5cbipcbiogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIC0gdmFsdWUgdG8gYmUgdmFsaWRhdGVkXG4qIEByZXR1cm5zIHtCb29sZWFufSBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciB2YWx1ZSBpcyBhbiBpbnRlZ2VyXG4qL1xuZnVuY3Rpb24gaXNJbnRlZ2VyKCB2YWx1ZSApIHtcblx0cmV0dXJuIGlzTnVtYmVyKCB2YWx1ZSApICYmIHZhbHVlJTEgPT09IDA7XG59IC8vIGVuZCBGVU5DVElPTiBpc0ludGVnZXIoKVxuXG5cbi8vIEVYUE9SVFMgLy9cblxubW9kdWxlLmV4cG9ydHMgPSBpc0ludGVnZXI7XG4iLCIvKipcbipcbipcdFZBTElEQVRFOiBub25uZWdhdGl2ZS1pbnRlZ2VyXG4qXG4qXG4qXHRERVNDUklQVElPTjpcbipcdFx0LSBWYWxpZGF0ZXMgaWYgYSB2YWx1ZSBpcyBhIG5vbm5lZ2F0aXZlIGludGVnZXIuXG4qXG4qXG4qXHROT1RFUzpcbipcdFx0WzFdXG4qXG4qXG4qXHRUT0RPOlxuKlx0XHRbMV1cbipcbipcbipcdExJQ0VOU0U6XG4qXHRcdE1JVFxuKlxuKlx0Q29weXJpZ2h0IChjKSAyMDE1LiBBdGhhbiBSZWluZXMuXG4qXG4qXG4qXHRBVVRIT1I6XG4qXHRcdEF0aGFuIFJlaW5lcy4ga2dyeXRlQGdtYWlsLmNvbS4gMjAxNS5cbipcbiovXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gTU9EVUxFUyAvL1xuXG52YXIgaXNJbnRlZ2VyID0gcmVxdWlyZSggJ3ZhbGlkYXRlLmlvLWludGVnZXInICk7XG5cblxuLy8gSVMgTk9OTkVHQVRJVkUgSU5URUdFUiAvL1xuXG4vKipcbiogRlVOQ1RJT046IGlzTm9uTmVnYXRpdmVJbnRlZ2VyKCB2YWx1ZSApXG4qXHRWYWxpZGF0ZXMgaWYgYSB2YWx1ZSBpcyBhIG5vbm5lZ2F0aXZlIGludGVnZXIuXG4qXG4qIEBwYXJhbSB7Kn0gdmFsdWUgLSB2YWx1ZSB0byBiZSB2YWxpZGF0ZWRcbiogQHJldHVybnMge0Jvb2xlYW59IGJvb2xlYW4gaW5kaWNhdGluZyBpZiBhIHZhbHVlIGlzIGEgbm9ubmVnYXRpdmUgaW50ZWdlclxuKi9cbmZ1bmN0aW9uIGlzTm9uTmVnYXRpdmVJbnRlZ2VyKCB2YWx1ZSApIHtcblx0cmV0dXJuIGlzSW50ZWdlciggdmFsdWUgKSAmJiB2YWx1ZSA+PSAwO1xufSAvLyBlbmQgRlVOQ1RJT04gaXNOb25OZWdhdGl2ZUludGVnZXIoKVxuXG5cbi8vIEVYUE9SVFMgLy9cblxubW9kdWxlLmV4cG9ydHMgPSBpc05vbk5lZ2F0aXZlSW50ZWdlcjtcbiIsIi8qKlxuKlxuKlx0VkFMSURBVEU6IG51bWJlclxuKlxuKlxuKlx0REVTQ1JJUFRJT046XG4qXHRcdC0gVmFsaWRhdGVzIGlmIGEgdmFsdWUgaXMgYSBudW1iZXIuXG4qXG4qXG4qXHROT1RFUzpcbipcdFx0WzFdXG4qXG4qXG4qXHRUT0RPOlxuKlx0XHRbMV1cbipcbipcbipcdExJQ0VOU0U6XG4qXHRcdE1JVFxuKlxuKlx0Q29weXJpZ2h0IChjKSAyMDE0LiBBdGhhbiBSZWluZXMuXG4qXG4qXG4qXHRBVVRIT1I6XG4qXHRcdEF0aGFuIFJlaW5lcy4ga2dyeXRlQGdtYWlsLmNvbS4gMjAxNC5cbipcbiovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4qIEZVTkNUSU9OOiBpc051bWJlciggdmFsdWUgKVxuKlx0VmFsaWRhdGVzIGlmIGEgdmFsdWUgaXMgYSBudW1iZXIuXG4qXG4qIEBwYXJhbSB7Kn0gdmFsdWUgLSB2YWx1ZSB0byBiZSB2YWxpZGF0ZWRcbiogQHJldHVybnMge0Jvb2xlYW59IGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHZhbHVlIGlzIGEgbnVtYmVyXG4qL1xuZnVuY3Rpb24gaXNOdW1iZXIoIHZhbHVlICkge1xuXHRyZXR1cm4gKCB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInIHx8IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCggdmFsdWUgKSA9PT0gJ1tvYmplY3QgTnVtYmVyXScgKSAmJiB2YWx1ZS52YWx1ZU9mKCkgPT09IHZhbHVlLnZhbHVlT2YoKTtcbn0gLy8gZW5kIEZVTkNUSU9OIGlzTnVtYmVyKClcblxuXG4vLyBFWFBPUlRTIC8vXG5cbm1vZHVsZS5leHBvcnRzID0gaXNOdW1iZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuKiBUZXN0cyBpZiBhIHZhbHVlIGlzIGEgc3RyaW5nIHByaW1pdGl2ZS5cbipcbiogQHBhcmFtIHsqfSB2YWx1ZSAtIHZhbHVlIHRvIHRlc3RcbiogQHJldHVybnMge0Jvb2xlYW59IGJvb2xlYW4gaW5kaWNhdGluZyBpZiBhIHZhbHVlIGlzIGEgc3RyaW5nIHByaW1pdGl2ZVxuKi9cbmZ1bmN0aW9uIGlzU3RyaW5nKCB2YWx1ZSApIHtcblx0cmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZyc7XG59IC8vIGVuZCBGVU5DVElPTiBpc1N0cmluZygpXG5cblxuLy8gRVhQT1JUUyAvL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzU3RyaW5nO1xuIiwibW9kdWxlLmV4cG9ydHM9e1xuICBcIm5hbWVcIjogXCJhbWkuanNcIixcbiAgXCJ2ZXJzaW9uXCI6IFwiMC4wLjE2XCIsXG4gIFwibWFpblwiOiBcImxpYi9hbWkuanNcIixcbiAgXCJrZXl3b3Jkc1wiOiBbXG4gICAgXCJhbWlcIixcbiAgICBcImFtaS5qc1wiLFxuICAgIFwidGhyZWUuanNcIixcbiAgICBcIndlYmdsXCIsXG4gICAgXCJkaWNvbVwiLFxuICAgIFwibmlmdGlcIixcbiAgICBcImF3ZXNvbWVcIixcbiAgICBcIm1lZGljYWxcIixcbiAgICBcImltYWdpbmdcIixcbiAgICBcInh0a1wiLFxuICAgIFwibnJyZFwiLFxuICAgIFwidnRrXCIsXG4gICAgXCJzdGxcIixcbiAgICBcInRya1wiXG4gIF0sXG4gIFwiYXV0aG9yXCI6IHtcbiAgICBcIm5hbWVcIjogXCJOaWNvbGFzIFJhbm5vdVwiLFxuICAgIFwiZW1haWxcIjogXCJuaWNvbGFzQGV1bmF0ZS5jaFwiLFxuICAgIFwidXJsXCI6IFwiaHR0cHM6Ly9ldW5hdGUuY2hcIlxuICB9LFxuICBcImxpY2Vuc2VcIjogXCJBcGFjaGUtMi4wXCIsXG4gIFwicmVwb3NpdG9yeVwiOiB7XG4gICAgXCJ0eXBlXCI6IFwiZ2l0XCIsXG4gICAgXCJ1cmxcIjogXCJodHRwczovL2ZubmRzYy5naXRodWIuaW8vYW1pXCJcbiAgfSxcbiAgXCJjb25maWdcIjoge1xuICAgIFwidGhyZWVWZXJzaW9uXCI6IFwiODZcIixcbiAgICBcImFtaUNETlwiOiBcImh0dHBzOi8vY2RuanMuY2xvdWRmbGFyZS5jb20vYWpheC9saWJzL2FtaS5qcy9cIixcbiAgICBcImdhS2V5XCI6IFwiVUEtMzkzMDMwMjItM1wiLFxuICAgIFwidHJhbnNmb3Jtc1wiOiBcIi10IFtiYWJlbGlmeSAtLXByZXNldHMgWyBlczIwMTUgXSBdXCJcbiAgfSxcbiAgXCJkZXBlbmRlbmNpZXNcIjoge1xuICAgIFwiZGljb20tcGFyc2VyXCI6IFwiMS43LjNcIixcbiAgICBcImltYWdlLUpQRUcyMDAwXCI6IFwiT0hJRi9pbWFnZS1KUEVHMjAwMCNtYXN0ZXJcIixcbiAgICBcImpwZWctbG9zc2xlc3MtZGVjb2Rlci1qc1wiOiBcIjEuMi4zXCIsXG4gICAgXCJtYXRoLWZsb2F0MzItdG8tYmluYXJ5LXN0cmluZ1wiOiBcIl4xLjAuMFwiLFxuICAgIFwibmlmdGktcmVhZGVyLWpzXCI6IFwidjAuNS4zXCIsXG4gICAgXCJucnJkLWpzXCI6IFwiXjAuMi4xXCIsXG4gICAgXCJwYWtvXCI6IFwiMS4wLjFcIlxuICB9LFxuICBcInNjcmlwdHNcIjoge1xuICAgIFwiZGlzdDpwcmVwYXJlXCI6IFwibm9kZSAuL3NjcmlwdHMvJG5wbV9wYWNrYWdlX2NvbmZpZ19tb2RlLmpzIC0tZGlzdFwiLFxuICAgIFwiZGlzdDp3YXRjaEFtaVwiOiBcIndhdGNoaWZ5IC1kIHNyYy9hbWkgJG5wbV9wYWNrYWdlX2NvbmZpZ190cmFuc2Zvcm1zIC0tc3RhbmRhbG9uZSBBTUkgLW8gZGlzdC9idWlsZC9hbWkuanMgLXZcIixcbiAgICBcImRpc3Q6d2F0Y2hcIjogXCJ3YXRjaGlmeSAkbnBtX3BhY2thZ2VfY29uZmlnX3RhcmdldCAtZCAkbnBtX3BhY2thZ2VfY29uZmlnX3RyYW5zZm9ybXMgLW8gZGlzdC8kbnBtX3BhY2thZ2VfY29uZmlnX3RhcmdldCAtdlwiLFxuICAgIFwiZGlzdFwiOiBcIm5wbSBydW4gZGlzdDpwcmVwYXJlIC0tYW1pLmpzOm1vZGU9JG5wbV9wYWNrYWdlX2NvbmZpZ19tb2RlICYmIChsaXZlLXNlcnZlciBkaXN0IC0tb3Blbj0kbnBtX3BhY2thZ2VfY29uZmlnX29wZW4gJiBucG0gcnVuIGRpc3Q6d2F0Y2ggLS1hbWkuanM6dGFyZ2V0PSRucG1fcGFja2FnZV9jb25maWdfdGFyZ2V0KVwiLFxuICAgIFwiZXhhbXBsZVwiOiBcIm5wbSBydW4gY2xlYW4gJiYgbm9kZSAuL3NjcmlwdHMvcm91dGVyLmpzIGV4YW1wbGVzIFwiLFxuICAgIFwibGVzc29uXCI6IFwibnBtIHJ1biBjbGVhbiAmJiBta2RpciBkaXN0L2J1aWxkICYmIHRvdWNoIGRpc3QvYnVpbGQvYW1pLmpzICYmIG5vZGUgLi9zY3JpcHRzL3JvdXRlci5qcyBsZXNzb25zIFwiLFxuICAgIFwiZGVtb1wiOiBcIm5vZGUgLi9zY3JpcHRzL2xlc3NvbnMuanMgLS1kZW1vXCIsXG4gICAgXCJsaW50XCI6IFwiZXNsaW50ICoqLyouanMgLS1xdWlldFwiLFxuICAgIFwiYnVpbGQ6ZXhhbXBsZXNcIjogXCJucG0gcnVuIGRpc3Q6cHJlcGFyZSAtLWFtaS5qczptb2RlPWV4YW1wbGVzICYmIGZpbmQgZXhhbXBsZXMgLW5hbWUgJyouanMnIC1wcmludDAgfCB4YXJncyAtMCAtbjEgLUl7fSBiYXNoIC1jIFxcXCJlY2hvIEJ1aWxkaW5nIHt9OyBicm93c2VyaWZ5IHt9IC1kIC12ICRucG1fcGFja2FnZV9jb25maWdfdHJhbnNmb3JtcyA+IGRpc3Qve30gXFxcIlwiLFxuICAgIFwiYnVpbGQ6YW1pXCI6IFwiYnJvd3NlcmlmeSBzcmMvYW1pLmpzIC1kIC12ICRucG1fcGFja2FnZV9jb25maWdfdHJhbnNmb3JtcyAtLXN0YW5kYWxvbmUgQU1JID4gYnVpbGQvYW1pLmpzICYmIHVnbGlmeWpzIGJ1aWxkL2FtaS5qcyAtbyBidWlsZC9hbWkubWluLmpzXCIsXG4gICAgXCJidWlsZFwiOiBcIm5wbSBydW4gY2xlYW4gJiYgY3AgaW5kZXguaHRtbCBkaXN0L2luZGV4Lmh0bWwgJiYgbnBtIHJ1biBidWlsZDpleGFtcGxlcyAmJiBucG0gcnVuIGRvY1wiLFxuICAgIFwiYnVpbGQtY2pzXCI6IFwicmltcmFmIGxpYiAmJiBjcm9zcy1lbnYgQkFCRUxfRU5WPWNqcyBiYWJlbCAuL3NyYyAtZCBsaWJcIixcbiAgICBcImNsZWFuXCI6IFwicmltcmFmIC1yZiBkaXN0LypcIixcbiAgICBcInRlc3RcIjogXCJrYXJtYSBzdGFydFwiLFxuICAgIFwiZG9jXCI6IFwianNkb2MgLXAgLXIgLVIgUkVBRE1FLm1kIC1jIGpzZG9jLmNvbmYgLWQgZGlzdC9kb2Mgc3JjXCIsXG4gICAgXCJhbWlcIjogXCJucG0gcnVuIGxpbnQgJiYgbnBtIHJ1biBkZW1vICYmIG5wbSBydW4gYnVpbGQ6YW1pICYmIG5wbSBydW4gdGVzdFwiLFxuICAgIFwiZGVwbG95XCI6IFwibnBtIHJ1biBidWlsZCAmJiBnaC1wYWdlcyAtZCBkaXN0XCJcbiAgfSxcbiAgXCJkZXZEZXBlbmRlbmNpZXNcIjoge1xuICAgIFwiYmFiZWwtY2xpXCI6IFwibGF0ZXN0XCIsXG4gICAgXCJiYWJlbC1wbHVnaW4tYWRkLW1vZHVsZS1leHBvcnRzXCI6IFwiXjAuMi4xXCIsXG4gICAgXCJiYWJlbC1wb2x5ZmlsbFwiOiBcIl42LjEzLjBcIixcbiAgICBcImJhYmVsLXByZXNldC1lczIwMTVcIjogXCJeNi4xMy4yXCIsXG4gICAgXCJiYWJlbGlmeVwiOiBcIjcuMy4wXCIsXG4gICAgXCJicm93c2VyaWZ5XCI6IFwiXjEzLjEuMFwiLFxuICAgIFwiY3Jvc3MtZW52XCI6IFwiXjMuMi4zXCIsXG4gICAgXCJlc2xpbnRcIjogXCJsYXRlc3RcIixcbiAgICBcImVzbGludC1jb25maWctZ29vZ2xlXCI6IFwibGF0ZXN0XCIsXG4gICAgXCJnaC1wYWdlc1wiOiBcImxhdGVzdFwiLFxuICAgIFwiZ2xzbGlmeVwiOiBcIjUuMS4wXCIsXG4gICAgXCJqYXNtaW5lLWNvcmVcIjogXCJsYXRlc3RcIixcbiAgICBcImpzZG9jXCI6IFwianNkb2MzL2pzZG9jI21hc3RlclwiLFxuICAgIFwia2FybWFcIjogXCJsYXRlc3RcIixcbiAgICBcImthcm1hLWJyb3dzZXJpZnlcIjogXCJsYXRlc3RcIixcbiAgICBcImthcm1hLWphc21pbmVcIjogXCJsYXRlc3RcIixcbiAgICBcImthcm1hLXBoYW50b21qcy1sYXVuY2hlclwiOiBcIjEuMC40XCIsXG4gICAgXCJrYXJtYS1zaW5vblwiOiBcIl4xLjAuNVwiLFxuICAgIFwia2FybWEtc3BlYy1yZXBvcnRlclwiOiBcImxhdGVzdFwiLFxuICAgIFwibGl2ZS1zZXJ2ZXJcIjogXCJeMS4xLjBcIixcbiAgICBcInBoYW50b21qcy1wcmVidWlsdFwiOiBcIjIuMS4xNFwiLFxuICAgIFwicmltcmFmXCI6IFwiXjIuNi4xXCIsXG4gICAgXCJzaGVsbGpzXCI6IFwibGF0ZXN0XCIsXG4gICAgXCJzaW5vblwiOiBcIl4yLjAuMFwiLFxuICAgIFwidWdsaWZ5LWpzXCI6IFwiXjIuNy4zXCIsXG4gICAgXCJ3YXRjaGlmeVwiOiBcIjMuNy4wXCJcbiAgfSxcbiAgXCJlbmdpbmVzXCI6IHtcbiAgICBcIm5vZGVcIjogXCI+PTYuOS4wXCJcbiAgfSxcbiAgXCJicm93c2VyaWZ5XCI6IHtcbiAgICBcInRyYW5zZm9ybVwiOiBbXG4gICAgICBcImJhYmVsaWZ5XCJcbiAgICBdXG4gIH1cbn1cbiIsImltcG9ydCBDYW1lcmFzIGZyb20gJy4vY2FtZXJhcy9jYW1lcmFzJztcbmltcG9ydCBDb250cm9scyBmcm9tICcuL2NvbnRyb2xzL2NvbnRyb2xzJztcbmltcG9ydCBDb3JlIGZyb20gJy4vY29yZS9jb3JlJztcbmltcG9ydCBHZW9tZXRyaWVzIGZyb20gJy4vZ2VvbWV0cmllcy9nZW9tZXRyaWVzJztcbmltcG9ydCBIZWxwZXJzIGZyb20gJy4vaGVscGVycy9oZWxwZXJzJztcbmltcG9ydCBMb2FkZXJzIGZyb20gJy4vbG9hZGVycy9sb2FkZXJzJztcbmltcG9ydCBNb2RlbHMgZnJvbSAnLi9tb2RlbHMvbW9kZWxzJztcbmltcG9ydCBQYXJzZXJzIGZyb20gJy4vcGFyc2Vycy9wYXJzZXJzJztcbmltcG9ydCBTaGFkZXJzIGZyb20gJy4vc2hhZGVycy9zaGFkZXJzJztcbmltcG9ydCBXaWRnZXRzIGZyb20gJy4vd2lkZ2V0cy93aWRnZXRzJztcblxuY29uc3QgcGNrZyA9IHJlcXVpcmUoJy4uL3BhY2thZ2UuanNvbicpO1xuXG5leHBvcnQgZGVmYXVsdHtcbiAgQ2FtZXJhcyxcbiAgQ29udHJvbHMsXG4gIENvcmUsXG4gIEdlb21ldHJpZXMsXG4gIEhlbHBlcnMsXG4gIExvYWRlcnMsXG4gIE1vZGVscyxcbiAgUGFyc2VycyxcbiAgU2hhZGVycyxcbiAgV2lkZ2V0cyxcbn07XG5cbndpbmRvdy5jb25zb2xlLmxvZyhgQU1JICR7cGNrZy52ZXJzaW9ufSAoIFRocmVlSlMgJHtwY2tnLmNvbmZpZy50aHJlZVZlcnNpb259KWApO1xuIiwiaW1wb3J0IE9ydGhvZ3JhcGhpYyBmcm9tICcuL2NhbWVyYXMub3J0aG9ncmFwaGljJztcblxuLyoqXG4gKiBAbW9kdWxlIGNhbWVyYXNcbiAqL1xuZXhwb3J0IGRlZmF1bHQge1xuICBPcnRob2dyYXBoaWMsXG59O1xuIiwiaW1wb3J0IEludGVyc2VjdGlvbnMgZnJvbSAnLi4vY29yZS9jb3JlLmludGVyc2VjdGlvbnMnO1xuaW1wb3J0IFZhbGlkYXRvcnMgZnJvbSAnLi4vY29yZS9jb3JlLnZhbGlkYXRvcnMnO1xuXG4vKipcbiAqIE9ydGhvZ3JhcGhpYyBjYW1lcmEgZnJvbSBUSFJFRS5KUyB3aXRoIHNvbWUgZXh0cmEgY29udmVuaWVuY2VcbiAqIGZ1bmN0aW9uYWxpdGllcy5cbiAqXG4gKiBAZXhhbXBsZVxuICogLy9cbiAqIC8vXG4gKlxuICogQG1vZHVsZSBjYW1lcmFzL29ydGhvZ3JhcGhpY1xuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDYW1lcmFzT3J0aG9ncmFwaGljIGV4dGVuZHMgVEhSRUUuT3J0aG9ncmFwaGljQ2FtZXJhIHtcbiAgY29uc3RydWN0b3IobGVmdCwgcmlnaHQsIHRvcCwgYm90dG9tLCBuZWFyLCBmYXIpIHtcbiAgICBzdXBlcihsZWZ0LCByaWdodCwgdG9wLCBib3R0b20sIG5lYXIsIGZhcik7XG5cbiAgICB0aGlzLl9mcm9udCA9IG51bGw7XG4gICAgdGhpcy5fYmFjayA9IG51bGw7XG5cbiAgICB0aGlzLl9kaXJlY3Rpb25zID0gW1xuICAgICAgbmV3IFRIUkVFLlZlY3RvcjMoMSwgMCwgMCksXG4gICAgICBuZXcgVEhSRUUuVmVjdG9yMygwLCAxLCAwKSxcbiAgICAgIG5ldyBUSFJFRS5WZWN0b3IzKDAsIDAsIDEpLFxuICAgICAgXTtcblxuICAgIHRoaXMuX2RpcmVjdGlvbnNMYWJlbCA9IFtcbiAgICAgICdBJywgJ1AnLCAvLyBUT1AvQk9UVE9NXG4gICAgICAnTCcsICdSJywgLy8gTEVGVC9SSUdIVFxuICAgICAgJ0knLCAnUycsIC8vIEZST00vVE9cbiAgICBdO1xuXG4gICAgdGhpcy5fb3JpZW50YXRpb24gPSAnZGVmYXVsdCc7XG4gICAgdGhpcy5fY29udmVudGlvbiA9ICdyYWRpbyc7XG4gICAgdGhpcy5fc3RhY2tPcmllbnRhdGlvbiA9IDA7XG5cbiAgICB0aGlzLl9yaWdodCA9IG51bGw7XG4gICAgdGhpcy5fdXAgPSBudWxsO1xuICAgIHRoaXMuX2RpcmVjdGlvbiA9IG51bGw7XG5cbiAgICB0aGlzLl9jb250cm9scyA9IG51bGw7XG4gICAgdGhpcy5fYm94ID0gbnVsbDtcbiAgICB0aGlzLl9jYW52YXMgPSB7XG4gICAgICB3aWR0aDogbnVsbCxcbiAgICAgIGhlaWdodDogbnVsbCxcbiAgICB9O1xuXG4gICAgdGhpcy5fZnJvbUZyb250ID0gdHJ1ZTtcbiAgICB0aGlzLl9hbmdsZSA9IDA7XG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZSBvcnRob2dyYXBoaWMgY2FtZXJhIHZhcmlhYmxlc1xuICAgKi9cbiAgaW5pdCh4Q29zaW5lLCB5Q29zaW5lLCB6Q29zaW5lLCBjb250cm9scywgYm94LCBjYW52YXMpIHtcbiAgICAvLyBERVBSRUNBVEVEXG4gICAgY29uc29sZS53YXJuKFxuICAgICAgYGNhbWVyYXMub3J0aG9ncmFwaGljLmluaXQoLi4uKSBpcyBkZXByZWNhdGVkLlxuICAgICAgVXNlIC5jb3NpbmVzLCAuY29udHJvbHMsIC5ib3ggYW5kIC5jYW52YXMgaW5zdGVhZC5gKTtcblxuICAgIC8vXG4gICAgaWYgKCEoVmFsaWRhdG9ycy52ZWN0b3IzKHhDb3NpbmUpICYmXG4gICAgICBWYWxpZGF0b3JzLnZlY3RvcjMoeUNvc2luZSkgJiZcbiAgICAgIFZhbGlkYXRvcnMudmVjdG9yMyh6Q29zaW5lKSAmJlxuICAgICAgVmFsaWRhdG9ycy5ib3goYm94KSAmJlxuICAgICAgY29udHJvbHMpKSB7XG4gICAgICB3aW5kb3cuY29uc29sZS5sb2coJ0ludmFsaWQgaW5wdXQgcHJvdmlkZWQuJyk7XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB0aGlzLl9yaWdodCA9IHhDb3NpbmU7XG4gICAgdGhpcy5fdXAgPSB0aGlzLl9hZGp1c3RUb3BEaXJlY3Rpb24oeENvc2luZSwgeUNvc2luZSk7XG4gICAgdGhpcy5fZGlyZWN0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoKS5jcm9zc1ZlY3RvcnModGhpcy5fcmlnaHQsIHRoaXMuX3VwKTtcbiAgICB0aGlzLl9jb250cm9scyA9IGNvbnRyb2xzO1xuICAgIHRoaXMuX2JveCA9IGJveDtcbiAgICB0aGlzLl9jYW52YXMgPSBjYW52YXM7XG5cbiAgICBsZXQgcmF5ID0ge1xuICAgICAgcG9zaXRpb246IHRoaXMuX2JveC5jZW50ZXIsXG4gICAgICBkaXJlY3Rpb246IHRoaXMuX2RpcmVjdGlvbixcbiAgICB9O1xuXG4gICAgbGV0IGludGVyc2VjdGlvbnMgPVxuICAgICAgdGhpcy5fb3JkZXJJbnRlcnNlY3Rpb25zKFxuICAgICAgICBJbnRlcnNlY3Rpb25zLnJheUJveChyYXksIHRoaXMuX2JveCksXG4gICAgICAgIHRoaXMuX2RpcmVjdGlvbik7XG4gICAgdGhpcy5fZnJvbnQgPSBpbnRlcnNlY3Rpb25zWzBdO1xuICAgIHRoaXMuX2JhY2sgPSBpbnRlcnNlY3Rpb25zWzFdO1xuXG4gICAgLy8gc2V0IGRlZmF1bHQgdmFsdWVzXG4gICAgdGhpcy51cC5zZXQodGhpcy5fdXAueCwgdGhpcy5fdXAueSwgdGhpcy5fdXAueik7XG4gICAgdGhpcy5fdXBkYXRlQ2FudmFzKCk7XG4gICAgdGhpcy5fdXBkYXRlUG9zaXRpb25BbmRUYXJnZXQodGhpcy5fZnJvbnQsIHRoaXMuX2JhY2spO1xuICAgIHRoaXMuX3VwZGF0ZU1hdHJpY2VzKCk7XG4gICAgdGhpcy5fdXBkYXRlRGlyZWN0aW9ucygpO1xuICB9XG5cbiAgdXBkYXRlKCkge1xuICAgIC8vIGh0dHA6Ly93d3cuZ3JhaGFtd2lkZW1hbi5jb20vZ3cvYnJhaW4vb3JpZW50YXRpb24vb3JpZW50dGVybXMuaHRtXG4gICAgLy8gZG8gbWFnaWNzIGRlcGVuZGluZyBvbiBvcmllbnRhdGlvbiBhbmQgY29udmVudGlvblxuICAgIC8vIGFsc28gbmVlZHMgYSBkZWZhdWx0IG1vZGVcblxuICAgIGlmICh0aGlzLl9vcmllbnRhdGlvbiA9PT0gJ2RlZmF1bHQnKSB7XG4gICAgICBzd2l0Y2ggKHRoaXMuX2dldE1heEluZGV4KHRoaXMuX2RpcmVjdGlvbnNbMl0pKSB7XG5cbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIHRoaXMuX29yaWVudGF0aW9uID0gJ3NhZ2l0dGFsJztcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgdGhpcy5fb3JpZW50YXRpb24gPSAnY29yb25hbCc7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHRoaXMuX29yaWVudGF0aW9uID0gJ2F4aWFsJztcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRoaXMuX29yaWVudGF0aW9uID0gJ2ZyZWUnO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLl9vcmllbnRhdGlvbiA9PT0gJ2ZyZWUnKSB7XG4gICAgICB0aGlzLl9yaWdodCA9IHRoaXMuX2RpcmVjdGlvbnNbMF07XG4gICAgICB0aGlzLl91cCA9IHRoaXMuX2RpcmVjdGlvbnNbMV07XG4gICAgICB0aGlzLl9kaXJlY3Rpb24gPSB0aGlzLl9kaXJlY3Rpb25zWzJdO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgbGVmdEluZGV4ID0gdGhpcy5sZWZ0RGlyZWN0aW9uKCk7XG4gICAgICBsZXQgbGVmdERpcmVjdGlvbiA9IHRoaXMuX2RpcmVjdGlvbnNbbGVmdEluZGV4XTtcbiAgICAgIGxldCBwb3N0ZXJpb3JJbmRleCA9IHRoaXMucG9zdGVyaW9yRGlyZWN0aW9uKCk7XG4gICAgICBsZXQgcG9zdGVyaW9yRGlyZWN0aW9uID0gdGhpcy5fZGlyZWN0aW9uc1twb3N0ZXJpb3JJbmRleF07XG4gICAgICBsZXQgc3VwZXJpb3JJbmRleCA9IHRoaXMuc3VwZXJpb3JEaXJlY3Rpb24oKTtcbiAgICAgIGxldCBzdXBlcmlvckRpcmVjdGlvbiA9IHRoaXMuX2RpcmVjdGlvbnNbc3VwZXJpb3JJbmRleF07XG5cbiAgICAgIGlmICh0aGlzLl9jb252ZW50aW9uID09PSAncmFkaW8nKSB7XG4gICAgICAgICAgc3dpdGNoICh0aGlzLl9vcmllbnRhdGlvbikge1xuXG4gICAgICAgICAgICBjYXNlICdheGlhbCc6XG4gICAgICAgICAgICAgIC8vIHVwIHZlY3RvciBpcyAnYW50ZXJpb3InXG4gICAgICAgICAgICAgIGlmIChwb3N0ZXJpb3JEaXJlY3Rpb24ueSA+IDApIHtcbiAgICAgICAgICAgICAgICBwb3N0ZXJpb3JEaXJlY3Rpb24ubmVnYXRlKCk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAvLyBsb29raW5nIHRvd2FyZHMgc3VwZXJpb3JcbiAgICAgICAgICAgICAgaWYgKHN1cGVyaW9yRGlyZWN0aW9uLnogPCAwKSB7XG4gICAgICAgICAgICAgICAgc3VwZXJpb3JEaXJlY3Rpb24ubmVnYXRlKCk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICB0aGlzLl9yaWdodCA9IGxlZnREaXJlY3Rpb247IC8vIGRvZXMgbm90IG1hdHRlciByaWdodC9sZWZ0XG4gICAgICAgICAgICAgIHRoaXMuX3VwID0gcG9zdGVyaW9yRGlyZWN0aW9uO1xuICAgICAgICAgICAgICB0aGlzLl9kaXJlY3Rpb24gPSBzdXBlcmlvckRpcmVjdGlvbjtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ2Nvcm9uYWwnOlxuICAgICAgICAgICAgICAvLyB1cCB2ZWN0b3IgaXMgJ3N1cGVyaW9yJ1xuICAgICAgICAgICAgICBpZiAoc3VwZXJpb3JEaXJlY3Rpb24ueiA8IDApIHtcbiAgICAgICAgICAgICAgICBzdXBlcmlvckRpcmVjdGlvbi5uZWdhdGUoKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIC8vIGxvb2tpbmcgdG93YXJkcyBwb3N0ZXJpb3JcbiAgICAgICAgICAgICAgaWYgKHBvc3RlcmlvckRpcmVjdGlvbi55IDwgMCkge1xuICAgICAgICAgICAgICAgIHBvc3RlcmlvckRpcmVjdGlvbi5uZWdhdGUoKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgIHRoaXMuX3JpZ2h0ID0gbGVmdERpcmVjdGlvbjsgLy8gZG9lcyBub3QgbWF0dGVyIHJpZ2h0L2xlZnRcbiAgICAgICAgICAgICAgdGhpcy5fdXAgPSBzdXBlcmlvckRpcmVjdGlvbjtcbiAgICAgICAgICAgICAgdGhpcy5fZGlyZWN0aW9uID0gcG9zdGVyaW9yRGlyZWN0aW9uO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAnc2FnaXR0YWwnOlxuICAgICAgICAgICAgICAvLyB1cCB2ZWN0b3IgaXMgJ3N1cGVyaW9yJ1xuICAgICAgICAgICAgICBpZiAoc3VwZXJpb3JEaXJlY3Rpb24ueiA8IDApIHtcbiAgICAgICAgICAgICAgICBzdXBlcmlvckRpcmVjdGlvbi5uZWdhdGUoKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIC8vIGxvb2tpbmcgdG93YXJkcyByaWdodFxuICAgICAgICAgICAgICBpZiAobGVmdERpcmVjdGlvbi54ID4gMCkge1xuICAgICAgICAgICAgICAgIGxlZnREaXJlY3Rpb24ubmVnYXRlKCk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICB0aGlzLl9yaWdodCA9IHBvc3RlcmlvckRpcmVjdGlvbjsgLy8gZG9lcyBub3QgbWF0dGVyIHJpZ2h0L2xlZnRcbiAgICAgICAgICAgICAgdGhpcy5fdXAgPSBzdXBlcmlvckRpcmVjdGlvbjtcbiAgICAgICAgICAgICAgdGhpcy5fZGlyZWN0aW9uID0gbGVmdERpcmVjdGlvbjtcblxuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgICAgIGBcIiR7dGhpcy5fb3JpZW50YXRpb259XCIgb3JpZW50YXRpb24gaXMgbm90IHZhbGlkLlxuICAgICAgICAgICAgICAgIChjaG9pY2VzOiBheGlhbCwgY29yb25hbCwgc2FnaXR0YWwpYCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0aGlzLl9jb252ZW50aW9uID09PSAnbmV1cm8nKSB7XG4gICAgICAgICAgc3dpdGNoICh0aGlzLl9vcmllbnRhdGlvbikge1xuXG4gICAgICAgICAgICBjYXNlICdheGlhbCc6XG4gICAgICAgICAgICAgIC8vIHVwIHZlY3RvciBpcyAnYW50ZXJpb3InXG4gICAgICAgICAgICAgIGlmIChwb3N0ZXJpb3JEaXJlY3Rpb24ueSA+IDApIHtcbiAgICAgICAgICAgICAgICBwb3N0ZXJpb3JEaXJlY3Rpb24ubmVnYXRlKCk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAvLyBsb29raW5nIHRvd2FyZHMgaW5mZXJpb3JcbiAgICAgICAgICAgICAgaWYgKHN1cGVyaW9yRGlyZWN0aW9uLnogPiAwKSB7XG4gICAgICAgICAgICAgICAgc3VwZXJpb3JEaXJlY3Rpb24ubmVnYXRlKCk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICB0aGlzLl9yaWdodCA9IGxlZnREaXJlY3Rpb247IC8vIGRvZXMgbm90IG1hdHRlciByaWdodC9sZWZ0XG4gICAgICAgICAgICAgIHRoaXMuX3VwID0gcG9zdGVyaW9yRGlyZWN0aW9uO1xuICAgICAgICAgICAgICB0aGlzLl9kaXJlY3Rpb24gPSBzdXBlcmlvckRpcmVjdGlvbjtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ2Nvcm9uYWwnOlxuICAgICAgICAgICAgICAvLyB1cCB2ZWN0b3IgaXMgJ3N1cGVyaW9yJ1xuICAgICAgICAgICAgICBpZiAoc3VwZXJpb3JEaXJlY3Rpb24ueiA8IDApIHtcbiAgICAgICAgICAgICAgICBzdXBlcmlvckRpcmVjdGlvbi5uZWdhdGUoKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIC8vIGxvb2tpbmcgdG93YXJkcyBhbnRlcmlvclxuICAgICAgICAgICAgICBpZiAocG9zdGVyaW9yRGlyZWN0aW9uLnkgPiAwKSB7XG4gICAgICAgICAgICAgICAgcG9zdGVyaW9yRGlyZWN0aW9uLm5lZ2F0ZSgpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgdGhpcy5fcmlnaHQgPSBsZWZ0RGlyZWN0aW9uOyAvLyBkb2VzIG5vdCBtYXR0ZXIgcmlnaHQvbGVmdFxuICAgICAgICAgICAgICB0aGlzLl91cCA9IHN1cGVyaW9yRGlyZWN0aW9uO1xuICAgICAgICAgICAgICB0aGlzLl9kaXJlY3Rpb24gPSBwb3N0ZXJpb3JEaXJlY3Rpb247XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICdzYWdpdHRhbCc6XG4gICAgICAgICAgICAgIC8vIHVwIHZlY3RvciBpcyAnc3VwZXJpb3InXG4gICAgICAgICAgICAgIGlmIChzdXBlcmlvckRpcmVjdGlvbi56IDwgMCkge1xuICAgICAgICAgICAgICAgIHN1cGVyaW9yRGlyZWN0aW9uLm5lZ2F0ZSgpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgLy8gbG9va2luZyB0b3dhcmRzIHJpZ2h0XG4gICAgICAgICAgICAgIGlmIChsZWZ0RGlyZWN0aW9uLnggPiAwKSB7XG4gICAgICAgICAgICAgICAgbGVmdERpcmVjdGlvbi5uZWdhdGUoKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgIHRoaXMuX3JpZ2h0ID0gcG9zdGVyaW9yRGlyZWN0aW9uOyAvLyBkb2VzIG5vdCBtYXR0ZXIgcmlnaHQvbGVmdFxuICAgICAgICAgICAgICB0aGlzLl91cCA9IHN1cGVyaW9yRGlyZWN0aW9uO1xuICAgICAgICAgICAgICB0aGlzLl9kaXJlY3Rpb24gPSBsZWZ0RGlyZWN0aW9uO1xuXG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAgICAgYFwiJHt0aGlzLl9vcmllbnRhdGlvbn1cIiBvcmllbnRhdGlvbiBpcyBub3QgdmFsaWQuXG4gICAgICAgICAgICAgICAgKGNob2ljZXM6IGF4aWFsLCBjb3JvbmFsLCBzYWdpdHRhbClgKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgIGAke3RoaXMuX2NvbnZlbnRpb259IGlzIG5vdCB2YWxpZCAoY2hvaWNlczogcmFkaW8sIG5ldXJvKWApO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHRoYXQgaXMgd2hhdCBkZXRlcm1pbmVzIGxlZnQvcmlnaHRcbiAgICBsZXQgcmF5ID0ge1xuICAgICAgcG9zaXRpb246IHRoaXMuX2JveC5jZW50ZXIsXG4gICAgICBkaXJlY3Rpb246IHRoaXMuX2RpcmVjdGlvbixcbiAgICB9O1xuXG4gICAgbGV0IGludGVyc2VjdGlvbnMgPVxuICAgICAgdGhpcy5fb3JkZXJJbnRlcnNlY3Rpb25zKFxuICAgICAgICBJbnRlcnNlY3Rpb25zLnJheUJveChyYXksIHRoaXMuX2JveCksXG4gICAgICAgIHRoaXMuX2RpcmVjdGlvbik7XG4gICAgdGhpcy5fZnJvbnQgPSBpbnRlcnNlY3Rpb25zWzBdO1xuICAgIHRoaXMuX2JhY2sgPSBpbnRlcnNlY3Rpb25zWzFdO1xuXG4gICAgLy8gc2V0IGRlZmF1bHQgdmFsdWVzXG4gICAgdGhpcy51cC5zZXQodGhpcy5fdXAueCwgdGhpcy5fdXAueSwgdGhpcy5fdXAueik7XG4gICAgdGhpcy5fdXBkYXRlQ2FudmFzKCk7XG4gICAgdGhpcy5fdXBkYXRlUG9zaXRpb25BbmRUYXJnZXQodGhpcy5fZnJvbnQsIHRoaXMuX2JhY2spO1xuICAgIHRoaXMuX3VwZGF0ZU1hdHJpY2VzKCk7XG4gICAgdGhpcy5fdXBkYXRlRGlyZWN0aW9ucygpO1xuICB9XG5cbiAgbGVmdERpcmVjdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fZmluZE1heEluZGV4KHRoaXMuX2RpcmVjdGlvbnMsIDApO1xuICB9XG5cbiAgcG9zdGVyaW9yRGlyZWN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9maW5kTWF4SW5kZXgodGhpcy5fZGlyZWN0aW9ucywgMSk7XG4gIH1cblxuICBzdXBlcmlvckRpcmVjdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fZmluZE1heEluZGV4KHRoaXMuX2RpcmVjdGlvbnMsIDIpO1xuICB9XG5cbiAgLyoqXG4gICAqIEludmVydCByb3dzIGluIHRoZSBjdXJyZW50IHNsaWNlLlxuICAgKiBJbnZlcnRpbmcgcm93cyBpbiAyIHN0ZXBzOlxuICAgKiAgICogRmxpcCB0aGUgXCJ1cFwiIHZlY3RvclxuICAgKiAgICogTG9vayBhdCB0aGUgc2xpY2UgZnJvbSB0aGUgb3RoZXIgc2lkZVxuICAgKi9cbiAgaW52ZXJ0Um93cygpIHtcbiAgICAvLyBmbGlwIFwidXBcIiB2ZWN0b3JcbiAgICAvLyB3ZSBmbGlwIHVwIGZpcnN0IGJlY2F1c2UgaW52ZXJ0Q29sdW1ucyB1cGRhdGUgcHJvamVjdGlvIG1hdHJpY2VzXG4gICAgdGhpcy51cC5tdWx0aXBseVNjYWxhcigtMSk7XG4gICAgdGhpcy5pbnZlcnRDb2x1bW5zKCk7XG5cbiAgICB0aGlzLl91cGRhdGVEaXJlY3Rpb25zKCk7XG4gIH1cblxuICAvKipcbiAgICogSW52ZXJ0IHJvd3MgaW4gdGhlIGN1cnJlbnQgc2xpY2UuXG4gICAqIEludmVydGluZyByb3dzIGluIDEgc3RlcDpcbiAgICogICAqIExvb2sgYXQgdGhlIHNsaWNlIGZyb20gdGhlIG90aGVyIHNpZGVcbiAgICovXG4gIGludmVydENvbHVtbnMoKSB7XG4gICAgdGhpcy5jZW50ZXIoKTtcbiAgICAvLyByb3RhdGUgMTgwIGRlZ3JlZXMgYXJvdW5kIHRoZSB1cCB2ZWN0b3IuLi5cbiAgICBsZXQgb3Bwb3NpdGVQb3NpdGlvbiA9IHRoaXMuX29wcG9zaXRlUG9zaXRpb24odGhpcy5wb3NpdGlvbik7XG5cbiAgICAvLyB1cGRhdGUgcG9zaXN0aW9uIGFuZCB0YXJnZXRcbiAgICAvLyBjbG9uZSBpcyBuZWVkZWQgYmVjYXVzZSB0aGlzLnBvc2l0aW9uIGlzIG92ZXJ3cml0dGVuIGluIG1ldGhvZFxuICAgIHRoaXMuX3VwZGF0ZVBvc2l0aW9uQW5kVGFyZ2V0KG9wcG9zaXRlUG9zaXRpb24sIHRoaXMucG9zaXRpb24uY2xvbmUoKSk7XG4gICAgdGhpcy5fdXBkYXRlTWF0cmljZXMoKTtcbiAgICB0aGlzLl9mcm9tRnJvbnQgPSAhdGhpcy5fZnJvbUZyb250O1xuXG4gICAgdGhpcy5fYW5nbGUgJT0gMzYwO1xuICAgIHRoaXMuX2FuZ2xlID0gMzYwIC0gdGhpcy5fYW5nbGU7XG5cbiAgICB0aGlzLl91cGRhdGVEaXJlY3Rpb25zKCk7XG4gIH1cblxuICAvKipcbiAgICogQ2VudGVyIHNsaWNlIGluIHRoZSBjYW1lcmEgRk9WLlxuICAgKiBJdCBhbHNvIHVwZGF0ZXMgdGhlIGNvbnRyb2xsZXJzIHByb3Blcmx5LlxuICAgKiBXZSBjYW4gY2VudGVyIGEgY2FtZXJhIGZyb20gdGhlIGZyb250IG9yIGZyb20gdGhlIGJhY2suXG4gICAqL1xuICBjZW50ZXIoKSB7XG4gICAgaWYgKHRoaXMuX2Zyb21Gcm9udCkge1xuICAgICAgdGhpcy5fdXBkYXRlUG9zaXRpb25BbmRUYXJnZXQodGhpcy5fZnJvbnQsIHRoaXMuX2JhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl91cGRhdGVQb3NpdGlvbkFuZFRhcmdldCh0aGlzLl9iYWNrLCB0aGlzLl9mcm9udCk7XG4gICAgfVxuXG4gICAgdGhpcy5fdXBkYXRlTWF0cmljZXMoKTtcbiAgICB0aGlzLl91cGRhdGVEaXJlY3Rpb25zKCk7XG4gIH1cblxuICAvKipcbiAgICogUGkvMiByb3RhdGlvbiBhcm91bmQgdGhlIHpDb3NpbmUgYXhpcy5cbiAgICogQ2xvY2std2lzZSByb3RhdGlvbiBmcm9tIHRoZSB1c2VyIHBvaW50IG9mIHZpZXcuXG4gICAqL1xuICByb3RhdGUoYW5nbGU9bnVsbCkge1xuICAgIHRoaXMuY2VudGVyKCk7XG5cbiAgICBsZXQgY29tcHV0ZWRBbmdsZSA9IDkwO1xuXG4gICAgbGV0IGNsb2Nrd2lzZSA9IDE7XG4gICAgaWYgKCF0aGlzLl9mcm9tRnJvbnQpIHtcbiAgICAgIGNsb2Nrd2lzZSA9IC0xO1xuICAgIH1cblxuICAgIGlmIChhbmdsZSA9PT0gbnVsbCkge1xuICAgICAgY29tcHV0ZWRBbmdsZSAqPSAtY2xvY2t3aXNlO1xuICAgICAgdGhpcy5fYW5nbGUgKz0gOTA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbXB1dGVkQW5nbGUgPSAzNjAgLSBjbG9ja3dpc2UgKiAoYW5nbGUgLSB0aGlzLl9hbmdsZSk7XG4gICAgICB0aGlzLl9hbmdsZSA9IGFuZ2xlO1xuICAgIH1cblxuICAgIHRoaXMuX2FuZ2xlICU9IDM2MDtcblxuICAgIC8vIFJvdGF0ZSB0aGUgdXAgdmVjdG9yIGFyb3VuZCB0aGUgXCJ6Q29zaW5lXCJcbiAgICBsZXQgcm90YXRpb24gPSBuZXcgVEhSRUUuTWF0cml4NCgpLm1ha2VSb3RhdGlvbkF4aXMoXG4gICAgICB0aGlzLl9kaXJlY3Rpb24sXG4gICAgICBjb21wdXRlZEFuZ2xlICogTWF0aC5QSS8xODApO1xuICAgIHRoaXMudXAuYXBwbHlNYXRyaXg0KHJvdGF0aW9uKTtcblxuICAgIHRoaXMuX3VwZGF0ZU1hdHJpY2VzKCk7XG4gICAgdGhpcy5fdXBkYXRlRGlyZWN0aW9ucygpO1xuICB9XG5cbiAgLy8gZGltZW5zaW9uc1swXSAvLyB3aWR0aFxuICAvLyBkaW1lbnNpb25zWzFdIC8vIGhlaWdodFxuICAvLyBkaXJlY3Rpb249IDAgd2lkdGgsIDEgaGVpZ2h0LCAyIGJlc3RcbiAgLy8gZmFjdG9yXG4gIGZpdEJveChkaXJlY3Rpb24gPSAwLCBmYWN0b3I9MS41KSB7XG4gICAgLy9cbiAgICAvLyBpZiAoIShkaW1lbnNpb25zICYmIGRpbWVuc2lvbnMubGVuZ3RoID49IDIpKSB7XG4gICAgLy8gICB3aW5kb3cuY29uc29sZS5sb2coJ0ludmFsaWQgZGltZW5zaW9ucyBjb250YWluZXIuJyk7XG4gICAgLy8gICB3aW5kb3cuY29uc29sZS5sb2coZGltZW5zaW9ucyk7XG5cbiAgICAvLyAgIHJldHVybiBmYWxzZTtcbiAgICAvLyB9XG5cbiAgICAvL1xuICAgIGxldCB6b29tID0gMTtcblxuICAgIC8vIHVwZGF0ZSB6b29tXG4gICAgc3dpdGNoIChkaXJlY3Rpb24pIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgem9vbSA9IGZhY3RvciAqIHRoaXMuX2NvbXB1dGVab29tKHRoaXMuX2NhbnZhcy53aWR0aCwgdGhpcy5fcmlnaHQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgem9vbSA9IGZhY3RvciAqIHRoaXMuX2NvbXB1dGVab29tKHRoaXMuX2NhbnZhcy5oZWlnaHQsIHRoaXMuX3VwKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIHpvb20gPSBmYWN0b3IgKiAoTWF0aC5taW4oXG4gICAgICAgICAgdGhpcy5fY29tcHV0ZVpvb20odGhpcy5fY2FudmFzLndpZHRoLCB0aGlzLl9yaWdodCksXG4gICAgICAgICAgdGhpcy5fY29tcHV0ZVpvb20odGhpcy5fY2FudmFzLmhlaWdodCwgdGhpcy5fdXApXG4gICAgICAgICkpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGlmICghem9vbSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHRoaXMuem9vbSA9IHpvb207XG5cbiAgICB0aGlzLmNlbnRlcigpO1xuICB9XG5cbiAgX2FkanVzdFRvcERpcmVjdGlvbihob3Jpem9udGFsRGlyZWN0aW9uLCB2ZXJ0aWNhbERpcmVjdGlvbikge1xuICAgIGNvbnN0IHZNYXhJbmRleCA9IHRoaXMuX2dldE1heEluZGV4KHZlcnRpY2FsRGlyZWN0aW9uKTtcblxuICAgIC8vIHNob3VsZCBoYW5kbGUgdk1heCBpbmRleCA9PT0gMFxuICAgIGlmICgodk1heEluZGV4ID09PSAyICYmIHZlcnRpY2FsRGlyZWN0aW9uLmdldENvbXBvbmVudCh2TWF4SW5kZXgpIDwgMCkgfHxcbiAgICAgICAgKHZNYXhJbmRleCA9PT0gMSAmJiB2ZXJ0aWNhbERpcmVjdGlvbi5nZXRDb21wb25lbnQodk1heEluZGV4KSA+IDApIHx8XG4gICAgICAgICh2TWF4SW5kZXggPT09IDAgJiYgdmVydGljYWxEaXJlY3Rpb24uZ2V0Q29tcG9uZW50KHZNYXhJbmRleCkgPiAwKSkge1xuICAgICAgdmVydGljYWxEaXJlY3Rpb24ubmVnYXRlKCk7XG4gICAgfVxuXG4gICByZXR1cm4gdmVydGljYWxEaXJlY3Rpb247XG4gIH1cblxuICBfZ2V0TWF4SW5kZXgodmVjdG9yKSB7XG4gICAgLy8gaW5pdCB3aXRoIFggdmFsdWVcbiAgICBsZXQgbWF4VmFsdWUgPSBNYXRoLmFicyh2ZWN0b3IueCk7XG4gICAgbGV0IGluZGV4ID0gMDtcblxuICAgIGlmIChNYXRoLmFicyh2ZWN0b3IueSkgPiBtYXhWYWx1ZSkge1xuICAgICAgbWF4VmFsdWUgPSBNYXRoLmFicyh2ZWN0b3IueSk7XG4gICAgICBpbmRleCA9IDE7XG4gICAgfVxuXG4gICAgaWYgKE1hdGguYWJzKHZlY3Rvci56KSA+IG1heFZhbHVlKSB7XG4gICAgICBpbmRleCA9IDI7XG4gICAgfVxuXG4gICAgcmV0dXJuIGluZGV4O1xuICB9XG5cbiAgX2ZpbmRNYXhJbmRleChkaXJlY3Rpb25zLCB0YXJnZXQpIHtcbiAgICAvLyBnZXQgaW5kZXggb2YgdGhlIG1vc3Qgc3VwZXJpb3IgZGlyZWN0aW9uXG4gICAgbGV0IG1heEluZGljZXMgPSB0aGlzLl9nZXRNYXhJbmRpY2VzKGRpcmVjdGlvbnMpO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXhJbmRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAobWF4SW5kaWNlc1tpXSA9PT0gdGFyZ2V0KSB7XG4gICAgICAgIHJldHVybiBpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIF9nZXRNYXhJbmRpY2VzKGRpcmVjdGlvbnMpIHtcbiAgICBsZXQgaW5kaWNlcyA9IFtdO1xuICAgIGluZGljZXMucHVzaCh0aGlzLl9nZXRNYXhJbmRleChkaXJlY3Rpb25zWzBdKSk7XG4gICAgaW5kaWNlcy5wdXNoKHRoaXMuX2dldE1heEluZGV4KGRpcmVjdGlvbnNbMV0pKTtcbiAgICBpbmRpY2VzLnB1c2godGhpcy5fZ2V0TWF4SW5kZXgoZGlyZWN0aW9uc1syXSkpO1xuXG4gICAgcmV0dXJuIGluZGljZXM7XG4gIH1cblxuICBfb3JkZXJJbnRlcnNlY3Rpb25zKGludGVyc2VjdGlvbnMsIGRpcmVjdGlvbikge1xuICAgIGNvbnN0IG9yZGVyZWQgPVxuICAgICAgaW50ZXJzZWN0aW9uc1swXS5kb3QoZGlyZWN0aW9uKSA8IGludGVyc2VjdGlvbnNbMV0uZG90KGRpcmVjdGlvbik7XG5cbiAgICBpZiAoIW9yZGVyZWQpIHtcbiAgICAgICAgcmV0dXJuIFtpbnRlcnNlY3Rpb25zWzFdLCBpbnRlcnNlY3Rpb25zWzBdXTtcbiAgICB9XG5cbiAgIHJldHVybiBpbnRlcnNlY3Rpb25zO1xuICB9XG5cbiAgX3VwZGF0ZUNhbnZhcygpIHtcbiAgICBsZXQgY2FtRmFjdG9yID0gMjtcbiAgICB0aGlzLmxlZnQgPSAtdGhpcy5fY2FudmFzLndpZHRoIC8gY2FtRmFjdG9yO1xuICAgIHRoaXMucmlnaHQgPSB0aGlzLl9jYW52YXMud2lkdGggLyBjYW1GYWN0b3I7XG4gICAgdGhpcy50b3AgPSB0aGlzLl9jYW52YXMuaGVpZ2h0IC8gY2FtRmFjdG9yO1xuICAgIHRoaXMuYm90dG9tID0gLXRoaXMuX2NhbnZhcy5oZWlnaHQgLyBjYW1GYWN0b3I7XG5cbiAgICB0aGlzLl91cGRhdGVNYXRyaWNlcygpO1xuICAgIHRoaXMuY29udHJvbHMuaGFuZGxlUmVzaXplKCk7XG4gIH1cblxuICBfb3Bwb3NpdGVQb3NpdGlvbihwb3NpdGlvbikge1xuICAgIGxldCBvcHBvc2l0ZVBvc2l0aW9uID0gcG9zaXRpb24uY2xvbmUoKTtcbiAgICAvLyBjZW50ZXIgd29ybGQgcG9zdGlvbiBhcm91bmQgYm94IGNlbnRlclxuICAgIG9wcG9zaXRlUG9zaXRpb24uc3ViKHRoaXMuX2JveC5jZW50ZXIpO1xuICAgIC8vIHJvdGF0ZVxuICAgIGxldCByb3RhdGlvbiA9IG5ldyBUSFJFRS5NYXRyaXg0KCkubWFrZVJvdGF0aW9uQXhpcyhcbiAgICAgIHRoaXMudXAsXG4gICAgICBNYXRoLlBJKTtcblxuICAgIG9wcG9zaXRlUG9zaXRpb24uYXBwbHlNYXRyaXg0KHJvdGF0aW9uKTtcbiAgICAvLyB0cmFuc2xhdGUgYmFjayB0byB3b3JsZCBwb3NpdGlvblxuICAgIG9wcG9zaXRlUG9zaXRpb24uYWRkKHRoaXMuX2JveC5jZW50ZXIpO1xuICAgIHJldHVybiBvcHBvc2l0ZVBvc2l0aW9uO1xuICB9XG5cbiAgX2NvbXB1dGVab29tKGRpbWVuc2lvbiwgZGlyZWN0aW9uKSB7XG4gICAgaWYgKCEoZGltZW5zaW9uICYmIGRpbWVuc2lvbiA+IDApKSB7XG4gICAgICB3aW5kb3cuY29uc29sZS5sb2coJ0ludmFsaWQgZGltZW5zaW9uIHByb3ZpZGVkLicpO1xuICAgICAgd2luZG93LmNvbnNvbGUubG9nKGRpbWVuc2lvbik7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gcmF5XG4gICAgbGV0IHJheSA9IHtcbiAgICAgIHBvc2l0aW9uOiB0aGlzLl9ib3guY2VudGVyLmNsb25lKCksXG4gICAgICBkaXJlY3Rpb246IGRpcmVjdGlvbixcbiAgICB9O1xuXG4gICAgbGV0IGludGVyc2VjdGlvbnMgPSBJbnRlcnNlY3Rpb25zLnJheUJveChyYXksIHRoaXMuX2JveCk7XG4gICAgaWYgKGludGVyc2VjdGlvbnMubGVuZ3RoIDwgMikge1xuICAgICAgd2luZG93LmNvbnNvbGUubG9nKCdDYW4gbm90IGFkanVzdCB0aGUgY2FtZXJhICggPCAyIGludGVyc2VjdGlvbnMpLicpO1xuICAgICAgd2luZG93LmNvbnNvbGUubG9nKHJheSk7XG4gICAgICB3aW5kb3cuY29uc29sZS5sb2codGhpcy5fYm94KTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGltZW5zaW9uIC8gaW50ZXJzZWN0aW9uc1swXS5kaXN0YW5jZVRvKGludGVyc2VjdGlvbnNbMV0pO1xuICB9XG5cbiAgX3VwZGF0ZVBvc2l0aW9uQW5kVGFyZ2V0KHBvc2l0aW9uLCB0YXJnZXQpIHtcbiAgICAgIC8vIHBvc2l0aW9uXG4gICAgICB0aGlzLnBvc2l0aW9uLnNldChwb3NpdGlvbi54LCBwb3NpdGlvbi55LCBwb3NpdGlvbi56KTtcblxuICAgICAgLy8gdGFyZ2V0c1xuICAgICAgdGhpcy5sb29rQXQodGFyZ2V0LngsIHRhcmdldC55LCB0YXJnZXQueik7XG4gICAgICB0aGlzLl9jb250cm9scy50YXJnZXQuc2V0KHRhcmdldC54LCB0YXJnZXQueSwgdGFyZ2V0LnopO1xuICB9XG5cbiAgX3VwZGF0ZU1hdHJpY2VzKCkge1xuICAgIHRoaXMuX2NvbnRyb2xzLnVwZGF0ZSgpO1xuICAgIC8vIFRIRU4gY2FtZXJhXG4gICAgdGhpcy51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XG4gICAgdGhpcy51cGRhdGVNYXRyaXhXb3JsZCgpO1xuICB9XG5cbiAgX3VwZGF0ZUxhYmVscygpIHtcbiAgICB0aGlzLl9kaXJlY3Rpb25zTGFiZWwgPSBbXG4gICAgICB0aGlzLl92ZWN0b3IyTGFiZWwodGhpcy5fdXApLFxuICAgICAgdGhpcy5fdmVjdG9yMkxhYmVsKHRoaXMuX3VwLmNsb25lKCkubmVnYXRlKCkpLFxuICAgICAgdGhpcy5fdmVjdG9yMkxhYmVsKHRoaXMuX3JpZ2h0KSxcbiAgICAgIHRoaXMuX3ZlY3RvcjJMYWJlbCh0aGlzLl9yaWdodC5jbG9uZSgpLm5lZ2F0ZSgpKSxcbiAgICAgIHRoaXMuX3ZlY3RvcjJMYWJlbCh0aGlzLl9kaXJlY3Rpb24pLFxuICAgICAgdGhpcy5fdmVjdG9yMkxhYmVsKHRoaXMuX2RpcmVjdGlvbi5jbG9uZSgpLm5lZ2F0ZSgpKSxcbiAgICBdO1xuICB9XG5cbiAgX3ZlY3RvcjJMYWJlbChkaXJlY3Rpb24pIHtcbiAgICBjb25zdCBpbmRleCA9IHRoaXMuX2dldE1heEluZGV4KGRpcmVjdGlvbik7XG4gICAgLy8gc2V0IHZlY3RvciBtYXggdmFsdWUgdG8gMVxuICAgIGNvbnN0IHNjYWxlZERpcmVjdGlvbiA9XG4gICAgICBkaXJlY3Rpb24uY2xvbmUoKS5kaXZpZGVTY2FsYXIoTWF0aC5hYnMoZGlyZWN0aW9uLmdldENvbXBvbmVudChpbmRleCkpKTtcbiAgICBjb25zdCBkZWx0YSA9IDAuMjtcbiAgICBsZXQgbGFiZWwgPSAnJztcblxuICAgIC8vIGxvb3AgdGhyb3VnaCBjb21wb25lbnRzIG9mIHRoZSB2ZWN0b3JcbiAgICBmb3IgKGxldCBpID0gMDsgaTwzOyBpKyspIHtcbiAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgIGlmIChzY2FsZWREaXJlY3Rpb24uZ2V0Q29tcG9uZW50KGkpICsgZGVsdGEgPj0gMSkge1xuICAgICAgICAgIGxhYmVsICs9ICdMJztcbiAgICAgICAgfSBlbHNlIGlmIChzY2FsZWREaXJlY3Rpb24uZ2V0Q29tcG9uZW50KGkpIC0gZGVsdGEgPD0gLTEpIHtcbiAgICAgICAgICBsYWJlbCArPSAnUic7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGkgPT09IDEpIHtcbiAgICAgICAgaWYgKHNjYWxlZERpcmVjdGlvbi5nZXRDb21wb25lbnQoaSkgKyBkZWx0YSA+PSAxKSB7XG4gICAgICAgICAgbGFiZWwgKz0gJ1AnO1xuICAgICAgICB9IGVsc2UgaWYgKHNjYWxlZERpcmVjdGlvbi5nZXRDb21wb25lbnQoaSkgLSBkZWx0YSA8PSAtMSkge1xuICAgICAgICAgIGxhYmVsICs9ICdBJztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoaSA9PT0gMikge1xuICAgICAgICBpZiAoc2NhbGVkRGlyZWN0aW9uLmdldENvbXBvbmVudChpKSArIGRlbHRhID49IDEpIHtcbiAgICAgICAgICBsYWJlbCArPSAnUyc7XG4gICAgICAgIH0gZWxzZSBpZiAoc2NhbGVkRGlyZWN0aW9uLmdldENvbXBvbmVudChpKSAtIGRlbHRhIDw9IC0xKSB7XG4gICAgICAgICAgbGFiZWwgKz0gJ0knO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGxhYmVsO1xuICB9XG5cbiAgX3VwZGF0ZURpcmVjdGlvbnMoKSB7XG4gICAgLy8gdXAgaXMgY29ycmVjdFxuICAgIHRoaXMuX3VwID0gdGhpcy51cC5jbG9uZSgpO1xuXG4gICAgLy8gZGlyZWN0aW9uXG4gICAgbGV0IHBMb2NhbCA9IG5ldyBUSFJFRS5WZWN0b3IzKDAsIDAsIC0xKTtcbiAgICBsZXQgcFdvcmxkID0gcExvY2FsLmFwcGx5TWF0cml4NCh0aGlzLm1hdHJpeFdvcmxkKTtcbiAgICB0aGlzLl9kaXJlY3Rpb24gPSBwV29ybGQuc3ViKHRoaXMucG9zaXRpb24pLm5vcm1hbGl6ZSgpO1xuXG4gICAgLy8gcmlnaHRcbiAgICB0aGlzLl9yaWdodCA9IG5ldyBUSFJFRS5WZWN0b3IzKCkuY3Jvc3NWZWN0b3JzKHRoaXMuX2RpcmVjdGlvbiwgdGhpcy51cCk7XG5cbiAgICAvLyB1cGRhdGUgbGFiZWxzIGFjY29yZGluZ2x5XG4gICAgdGhpcy5fdXBkYXRlTGFiZWxzKCk7XG4gIH1cblxuICBzZXQgY29udHJvbHMoY29udHJvbHMpIHtcbiAgICB0aGlzLl9jb250cm9scyA9IGNvbnRyb2xzO1xuICB9XG5cbiAgZ2V0IGNvbnRyb2xzKCkge1xuICAgIHJldHVybiB0aGlzLl9jb250cm9scztcbiAgfVxuXG4gIHNldCBib3goYm94KSB7XG4gICAgdGhpcy5fYm94ID0gYm94O1xuICB9XG5cbiAgZ2V0IGJveCgpIHtcbiAgICByZXR1cm4gdGhpcy5fYm94O1xuICB9XG5cbiAgc2V0IGNhbnZhcyhjYW52YXMpIHtcbiAgICB0aGlzLl9jYW52YXMgPSBjYW52YXM7XG4gICAgdGhpcy5fdXBkYXRlQ2FudmFzKCk7XG4gIH1cblxuICBnZXQgY2FudmFzKCkge1xuICAgIHJldHVybiB0aGlzLl9jYW52YXM7XG4gIH1cblxuICBzZXQgYW5nbGUoYW5nbGUpIHtcbiAgICB0aGlzLnJvdGF0ZShhbmdsZSk7XG4gIH1cblxuICBnZXQgYW5nbGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FuZ2xlO1xuICB9XG5cbiAgc2V0IGRpcmVjdGlvbnMoZGlyZWN0aW9ucykge1xuICAgIHRoaXMuX2RpcmVjdGlvbnMgPSBkaXJlY3Rpb25zO1xuICB9XG5cbiAgZ2V0IGRpcmVjdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RpcmVjdGlvbnM7XG4gIH1cblxuICBzZXQgY29udmVudGlvbihjb252ZW50aW9uKSB7XG4gICAgdGhpcy5fY29udmVudGlvbiA9IGNvbnZlbnRpb247XG4gIH1cblxuICBnZXQgY29udmVudGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fY29udmVudGlvbjtcbiAgfVxuXG4gIHNldCBvcmllbnRhdGlvbihvcmllbnRhdGlvbikge1xuICAgIHRoaXMuX29yaWVudGF0aW9uID0gb3JpZW50YXRpb247XG4gIH1cblxuICBnZXQgb3JpZW50YXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX29yaWVudGF0aW9uO1xuICB9XG5cbiAgc2V0IGRpcmVjdGlvbnNMYWJlbChkaXJlY3Rpb25zTGFiZWwpIHtcbiAgICB0aGlzLl9kaXJlY3Rpb25zTGFiZWwgPSBkaXJlY3Rpb25zTGFiZWw7XG4gIH1cblxuICBnZXQgZGlyZWN0aW9uc0xhYmVsKCkge1xuICAgIHJldHVybiB0aGlzLl9kaXJlY3Rpb25zTGFiZWw7XG4gIH1cblxuICBzZXQgc3RhY2tPcmllbnRhdGlvbihzdGFja09yaWVudGF0aW9uKSB7XG4gICAgdGhpcy5fc3RhY2tPcmllbnRhdGlvbiA9IHN0YWNrT3JpZW50YXRpb247XG5cbiAgICBpZiAodGhpcy5fc3RhY2tPcmllbnRhdGlvbiA9PT0gMCkge1xuICAgICAgdGhpcy5fb3JpZW50YXRpb24gPSAnZGVmYXVsdCc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG1heEluZGV4ID1cbiAgICAgICAgdGhpcy5fZ2V0TWF4SW5kZXgoXG4gICAgICAgICAgdGhpcy5fZGlyZWN0aW9uc1sodGhpcy5fc3RhY2tPcmllbnRhdGlvbiArIDIpICUgM10pO1xuXG4gICAgICBpZiAobWF4SW5kZXggPT09IDApIHtcbiAgICAgICAgdGhpcy5fb3JpZW50YXRpb24gPSAnc2FnaXR0YWwnO1xuICAgICAgfSBlbHNlIGlmIChtYXhJbmRleCA9PT0gMSkge1xuICAgICAgICB0aGlzLl9vcmllbnRhdGlvbiA9ICdjb3JvbmFsJztcbiAgICAgIH0gZWxzZSBpZiAobWF4SW5kZXggPT09IDIpIHtcbiAgICAgICAgdGhpcy5fb3JpZW50YXRpb24gPSAnYXhpYWwnO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGdldCBzdGFja09yaWVudGF0aW9uKCkge1xuICAgIC8vXG4gICAgaWYgKHRoaXMuX29yaWVudGF0aW9uID09PSAnZGVmYXVsdCcpIHtcbiAgICAgIHRoaXMuX3N0YWNrT3JpZW50YXRpb24gPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgbWF4SW5kZXggPSB0aGlzLl9nZXRNYXhJbmRleCh0aGlzLl9kaXJlY3Rpb24pO1xuXG4gICAgICBpZiAobWF4SW5kZXggPT09IHRoaXMuX2dldE1heEluZGV4KHRoaXMuX2RpcmVjdGlvbnNbMl0pKSB7XG4gICAgICAgIHRoaXMuX3N0YWNrT3JpZW50YXRpb24gPSAwO1xuICAgICAgfSBlbHNlIGlmIChtYXhJbmRleCA9PT0gdGhpcy5fZ2V0TWF4SW5kZXgodGhpcy5fZGlyZWN0aW9uc1swXSkpIHtcbiAgICAgICAgdGhpcy5fc3RhY2tPcmllbnRhdGlvbiA9IDE7XG4gICAgICB9IGVsc2UgaWYgKG1heEluZGV4ID09PSB0aGlzLl9nZXRNYXhJbmRleCh0aGlzLl9kaXJlY3Rpb25zWzFdKSkge1xuICAgICAgICB0aGlzLl9zdGFja09yaWVudGF0aW9uID0gMjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fc3RhY2tPcmllbnRhdGlvbjtcbiAgfVxuXG59XG4iLCJpbXBvcnQgVHJhY2tiYWxsIGZyb20gJy4vY29udHJvbHMudHJhY2tiYWxsJztcbmltcG9ydCBUcmFja2JhbGxPcnRobyBmcm9tICcuL2NvbnRyb2xzLnRyYWNrYmFsbG9ydGhvJztcblxuZXhwb3J0IGRlZmF1bHQge1xuICBUcmFja2JhbGwsXG4gIFRyYWNrYmFsbE9ydGhvLFxufTtcbiIsIi8qKlxuICogT3JpZ2luYWwgYXV0aG9ycyBmcm9tIFRIUkVFSlMgcmVwb1xuICogQGF1dGhvciBFYmVyaGFyZCBHcmFldGhlciAvIGh0dHA6Ly9lZ3JhZXRoZXIuY29tL1xuICogQGF1dGhvciBNYXJrIEx1bmRpbiAgLyBodHRwOi8vbWFyay1sdW5kaW4uY29tXG4gKiBAYXV0aG9yIFNpbW9uZSBNYW5pbmkgLyBodHRwOi8vZGFyb24xMzM3LmdpdGh1Yi5pb1xuICogQGF1dGhvciBMdWNhIEFudGlnYSAgLyBodHRwOi8vbGFudGlnYS5naXRodWIuaW9cbiAqL1xuXG4gZXhwb3J0IGRlZmF1bHQgY2xhc3MgVHJhY2tiYWxsIGV4dGVuZHMgVEhSRUUuRXZlbnREaXNwYXRjaGVyIHtcbiAgY29uc3RydWN0b3Iob2JqZWN0LCBkb21FbGVtZW50KSB7XG4gICAgc3VwZXIoKTtcblxuICAgIGxldCBfdGhpcyA9IHRoaXM7XG4gICAgbGV0IFNUQVRFID0ge05PTkU6IC0xLCBST1RBVEU6IDAsIFpPT006IDEsIFBBTjogMiwgVE9VQ0hfUk9UQVRFOiAzLCBUT1VDSF9aT09NOiA0LCBUT1VDSF9QQU46IDUsIENVU1RPTTogOTl9O1xuXG4gICAgdGhpcy5vYmplY3QgPSBvYmplY3Q7XG4gICAgdGhpcy5kb21FbGVtZW50ID0gKGRvbUVsZW1lbnQgIT09IHVuZGVmaW5lZCkgPyBkb21FbGVtZW50IDogZG9jdW1lbnQ7XG5cbiAgICAvLyBBUElcblxuICAgIHRoaXMuZW5hYmxlZCA9IHRydWU7XG5cbiAgICB0aGlzLnNjcmVlbiA9IHtsZWZ0OiAwLCB0b3A6IDAsIHdpZHRoOiAwLCBoZWlnaHQ6IDB9O1xuXG4gICAgdGhpcy5yb3RhdGVTcGVlZCA9IDEuMDtcbiAgICB0aGlzLnpvb21TcGVlZCA9IDEuMjtcbiAgICB0aGlzLnBhblNwZWVkID0gMC4zO1xuXG4gICAgdGhpcy5ub1JvdGF0ZSA9IGZhbHNlO1xuICAgIHRoaXMubm9ab29tID0gZmFsc2U7XG4gICAgdGhpcy5ub1BhbiA9IGZhbHNlO1xuICAgIHRoaXMubm9DdXN0b20gPSBmYWxzZTtcblxuICAgIHRoaXMuZm9yY2VTdGF0ZSA9IC0xO1xuXG4gICAgdGhpcy5zdGF0aWNNb3ZpbmcgPSBmYWxzZTtcbiAgICB0aGlzLmR5bmFtaWNEYW1waW5nRmFjdG9yID0gMC4yO1xuXG4gICAgdGhpcy5taW5EaXN0YW5jZSA9IDA7XG4gICAgdGhpcy5tYXhEaXN0YW5jZSA9IEluZmluaXR5O1xuXG4gICAgdGhpcy5rZXlzID0gWzY1IC8qIEEqLywgODMgLyogUyovLCA2OF07XG5cbiAgICAvLyBpbnRlcm5hbHNcblxuICAgIHRoaXMudGFyZ2V0ID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICAgIGxldCBFUFMgPSAwLjAwMDAwMTtcblxuICAgIGxldCBsYXN0UG9zaXRpb24gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gICAgbGV0IF9zdGF0ZSA9IFNUQVRFLk5PTkUsXG4gICAgX3ByZXZTdGF0ZSA9IFNUQVRFLk5PTkUsXG5cbiAgICBfZXllID0gbmV3IFRIUkVFLlZlY3RvcjMoKSxcblxuICAgIF9tb3ZlUHJldiA9IG5ldyBUSFJFRS5WZWN0b3IyKCksXG4gICAgX21vdmVDdXJyID0gbmV3IFRIUkVFLlZlY3RvcjIoKSxcblxuICAgIF9sYXN0QXhpcyA9IG5ldyBUSFJFRS5WZWN0b3IzKCksXG4gICAgX2xhc3RBbmdsZSA9IDAsXG5cbiAgICBfem9vbVN0YXJ0ID0gbmV3IFRIUkVFLlZlY3RvcjIoKSxcbiAgICBfem9vbUVuZCA9IG5ldyBUSFJFRS5WZWN0b3IyKCksXG5cbiAgICBfdG91Y2hab29tRGlzdGFuY2VTdGFydCA9IDAsXG4gICAgX3RvdWNoWm9vbURpc3RhbmNlRW5kID0gMCxcblxuICAgIF9wYW5TdGFydCA9IG5ldyBUSFJFRS5WZWN0b3IyKCksXG4gICAgX3BhbkVuZCA9IG5ldyBUSFJFRS5WZWN0b3IyKCksXG5cbiAgICBfY3VzdG9tU3RhcnQgPSBuZXcgVEhSRUUuVmVjdG9yMigpLFxuICAgIF9jdXN0b21FbmQgPSBuZXcgVEhSRUUuVmVjdG9yMigpO1xuXG4gICAgLy8gZm9yIHJlc2V0XG5cbiAgICB0aGlzLnRhcmdldDAgPSB0aGlzLnRhcmdldC5jbG9uZSgpO1xuICAgIHRoaXMucG9zaXRpb24wID0gdGhpcy5vYmplY3QucG9zaXRpb24uY2xvbmUoKTtcbiAgICB0aGlzLnVwMCA9IHRoaXMub2JqZWN0LnVwLmNsb25lKCk7XG5cbiAgICAvLyBldmVudHNcblxuICAgIGxldCBjaGFuZ2VFdmVudCA9IHt0eXBlOiAnY2hhbmdlJ307XG4gICAgbGV0IHN0YXJ0RXZlbnQgPSB7dHlwZTogJ3N0YXJ0J307XG4gICAgbGV0IGVuZEV2ZW50ID0ge3R5cGU6ICdlbmQnfTtcblxuICAgIC8vIG1ldGhvZHNcblxuICAgIHRoaXMuaGFuZGxlUmVzaXplID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5kb21FbGVtZW50ID09PSBkb2N1bWVudCkge1xuICAgICAgICB0aGlzLnNjcmVlbi5sZWZ0ID0gMDtcbiAgICAgICAgdGhpcy5zY3JlZW4udG9wID0gMDtcbiAgICAgICAgdGhpcy5zY3JlZW4ud2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aDtcbiAgICAgICAgdGhpcy5zY3JlZW4uaGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IGJveCA9IHRoaXMuZG9tRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgLy8gYWRqdXN0bWVudHMgY29tZSBmcm9tIHNpbWlsYXIgY29kZSBpbiB0aGUganF1ZXJ5IG9mZnNldCgpIGZ1bmN0aW9uXG4gICAgICAgIGxldCBkID0gdGhpcy5kb21FbGVtZW50Lm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgICB0aGlzLnNjcmVlbi5sZWZ0ID0gYm94LmxlZnQgKyB3aW5kb3cucGFnZVhPZmZzZXQgLSBkLmNsaWVudExlZnQ7XG4gICAgICAgIHRoaXMuc2NyZWVuLnRvcCA9IGJveC50b3AgKyB3aW5kb3cucGFnZVlPZmZzZXQgLSBkLmNsaWVudFRvcDtcbiAgICAgICAgdGhpcy5zY3JlZW4ud2lkdGggPSBib3gud2lkdGg7XG4gICAgICAgIHRoaXMuc2NyZWVuLmhlaWdodCA9IGJveC5oZWlnaHQ7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMuaGFuZGxlRXZlbnQgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgaWYgKHR5cGVvZiB0aGlzW2V2ZW50LnR5cGVdID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhpc1tldmVudC50eXBlXShldmVudCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGxldCBnZXRNb3VzZU9uU2NyZWVuID0gKGZ1bmN0aW9uKCkge1xuICAgICAgbGV0IHZlY3RvciA9IG5ldyBUSFJFRS5WZWN0b3IyKCk7XG5cbiAgICAgIHJldHVybiBmdW5jdGlvbihwYWdlWCwgcGFnZVkpIHtcbiAgICAgICAgdmVjdG9yLnNldChcbiAgICAgICAgICAgIChwYWdlWCAtIF90aGlzLnNjcmVlbi5sZWZ0KSAvIF90aGlzLnNjcmVlbi53aWR0aCxcbiAgICAgICAgICAgIChwYWdlWSAtIF90aGlzLnNjcmVlbi50b3ApIC8gX3RoaXMuc2NyZWVuLmhlaWdodFxuICAgICAgICApO1xuXG4gICAgICAgIHJldHVybiB2ZWN0b3I7XG4gICAgICB9O1xuICAgIH0oKSk7XG5cbiAgICBsZXQgZ2V0TW91c2VPbkNpcmNsZSA9IChmdW5jdGlvbigpIHtcbiAgICAgIGxldCB2ZWN0b3IgPSBuZXcgVEhSRUUuVmVjdG9yMigpO1xuXG4gICAgICByZXR1cm4gZnVuY3Rpb24ocGFnZVgsIHBhZ2VZKSB7XG4gICAgICAgIHZlY3Rvci5zZXQoXG4gICAgICAgICAgICAoKHBhZ2VYIC0gX3RoaXMuc2NyZWVuLndpZHRoICogMC41IC0gX3RoaXMuc2NyZWVuLmxlZnQpIC8gKF90aGlzLnNjcmVlbi53aWR0aCAqIDAuNSkpLFxuICAgICAgICAgICAgKChfdGhpcy5zY3JlZW4uaGVpZ2h0ICsgMiAqIChfdGhpcy5zY3JlZW4udG9wIC0gcGFnZVkpKSAvIF90aGlzLnNjcmVlbi53aWR0aCkgLy8gc2NyZWVuLndpZHRoIGludGVudGlvbmFsXG4gICAgICAgICk7XG5cbiAgICAgICAgcmV0dXJuIHZlY3RvcjtcbiAgICAgIH07XG4gICAgfSgpKTtcblxuICAgIHRoaXMucm90YXRlQ2FtZXJhID0gKGZ1bmN0aW9uKCkge1xuICAgICAgbGV0IGF4aXMgPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxuICAgICAgICAgIHF1YXRlcm5pb24gPSBuZXcgVEhSRUUuUXVhdGVybmlvbigpLFxuICAgICAgICAgIGV5ZURpcmVjdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCksXG4gICAgICAgICAgb2JqZWN0VXBEaXJlY3Rpb24gPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxuICAgICAgICAgIG9iamVjdFNpZGV3YXlzRGlyZWN0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoKSxcbiAgICAgICAgICBtb3ZlRGlyZWN0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoKSxcbiAgICAgICAgICBhbmdsZTtcblxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICBtb3ZlRGlyZWN0aW9uLnNldChfbW92ZUN1cnIueCAtIF9tb3ZlUHJldi54LCBfbW92ZUN1cnIueSAtIF9tb3ZlUHJldi55LCAwKTtcbiAgICAgICAgYW5nbGUgPSBtb3ZlRGlyZWN0aW9uLmxlbmd0aCgpO1xuXG4gICAgICAgIGlmIChhbmdsZSkge1xuICAgICAgICAgIF9leWUuY29weShfdGhpcy5vYmplY3QucG9zaXRpb24pLnN1YihfdGhpcy50YXJnZXQpO1xuXG4gICAgICAgICAgZXllRGlyZWN0aW9uLmNvcHkoX2V5ZSkubm9ybWFsaXplKCk7XG4gICAgICAgICAgb2JqZWN0VXBEaXJlY3Rpb24uY29weShfdGhpcy5vYmplY3QudXApLm5vcm1hbGl6ZSgpO1xuICAgICAgICAgIG9iamVjdFNpZGV3YXlzRGlyZWN0aW9uLmNyb3NzVmVjdG9ycyhvYmplY3RVcERpcmVjdGlvbiwgZXllRGlyZWN0aW9uKS5ub3JtYWxpemUoKTtcblxuICAgICAgICAgIG9iamVjdFVwRGlyZWN0aW9uLnNldExlbmd0aChfbW92ZUN1cnIueSAtIF9tb3ZlUHJldi55KTtcbiAgICAgICAgICBvYmplY3RTaWRld2F5c0RpcmVjdGlvbi5zZXRMZW5ndGgoX21vdmVDdXJyLnggLSBfbW92ZVByZXYueCk7XG5cbiAgICAgICAgICBtb3ZlRGlyZWN0aW9uLmNvcHkob2JqZWN0VXBEaXJlY3Rpb24uYWRkKG9iamVjdFNpZGV3YXlzRGlyZWN0aW9uKSk7XG5cbiAgICAgICAgICBheGlzLmNyb3NzVmVjdG9ycyhtb3ZlRGlyZWN0aW9uLCBfZXllKS5ub3JtYWxpemUoKTtcblxuICAgICAgICAgIGFuZ2xlICo9IF90aGlzLnJvdGF0ZVNwZWVkO1xuICAgICAgICAgIHF1YXRlcm5pb24uc2V0RnJvbUF4aXNBbmdsZShheGlzLCBhbmdsZSk7XG5cbiAgICAgICAgICBfZXllLmFwcGx5UXVhdGVybmlvbihxdWF0ZXJuaW9uKTtcbiAgICAgICAgICBfdGhpcy5vYmplY3QudXAuYXBwbHlRdWF0ZXJuaW9uKHF1YXRlcm5pb24pO1xuXG4gICAgICAgICAgX2xhc3RBeGlzLmNvcHkoYXhpcyk7XG4gICAgICAgICAgX2xhc3RBbmdsZSA9IGFuZ2xlO1xuICAgICAgICB9IGVsc2UgaWYgKCFfdGhpcy5zdGF0aWNNb3ZpbmcgJiYgX2xhc3RBbmdsZSkge1xuICAgICAgICAgIF9sYXN0QW5nbGUgKj0gTWF0aC5zcXJ0KDEuMCAtIF90aGlzLmR5bmFtaWNEYW1waW5nRmFjdG9yKTtcbiAgICAgICAgICBfZXllLmNvcHkoX3RoaXMub2JqZWN0LnBvc2l0aW9uKS5zdWIoX3RoaXMudGFyZ2V0KTtcbiAgICAgICAgICBxdWF0ZXJuaW9uLnNldEZyb21BeGlzQW5nbGUoX2xhc3RBeGlzLCBfbGFzdEFuZ2xlKTtcbiAgICAgICAgICBfZXllLmFwcGx5UXVhdGVybmlvbihxdWF0ZXJuaW9uKTtcbiAgICAgICAgICBfdGhpcy5vYmplY3QudXAuYXBwbHlRdWF0ZXJuaW9uKHF1YXRlcm5pb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgX21vdmVQcmV2LmNvcHkoX21vdmVDdXJyKTtcbiAgICAgIH07XG4gICAgfSgpKTtcblxuICAgIHRoaXMuem9vbUNhbWVyYSA9IGZ1bmN0aW9uKCkge1xuICAgICAgbGV0IGZhY3RvcjtcblxuICAgICAgaWYgKF9zdGF0ZSA9PT0gU1RBVEUuVE9VQ0hfWk9PTSkge1xuICAgICAgICBmYWN0b3IgPSBfdG91Y2hab29tRGlzdGFuY2VTdGFydCAvIF90b3VjaFpvb21EaXN0YW5jZUVuZDtcbiAgICAgICAgX3RvdWNoWm9vbURpc3RhbmNlU3RhcnQgPSBfdG91Y2hab29tRGlzdGFuY2VFbmQ7XG4gICAgICAgIF9leWUubXVsdGlwbHlTY2FsYXIoZmFjdG9yKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZhY3RvciA9IDEuMCArIChfem9vbUVuZC55IC0gX3pvb21TdGFydC55KSAqIF90aGlzLnpvb21TcGVlZDtcblxuICAgICAgICBpZiAoZmFjdG9yICE9PSAxLjAgJiYgZmFjdG9yID4gMC4wKSB7XG4gICAgICAgICAgX2V5ZS5tdWx0aXBseVNjYWxhcihmYWN0b3IpO1xuXG4gICAgICAgICAgaWYgKF90aGlzLnN0YXRpY01vdmluZykge1xuICAgICAgICAgICAgX3pvb21TdGFydC5jb3B5KF96b29tRW5kKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgX3pvb21TdGFydC55ICs9IChfem9vbUVuZC55IC0gX3pvb21TdGFydC55KSAqIHRoaXMuZHluYW1pY0RhbXBpbmdGYWN0b3I7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMucGFuQ2FtZXJhID0gKGZ1bmN0aW9uKCkge1xuICAgICAgbGV0IG1vdXNlQ2hhbmdlID0gbmV3IFRIUkVFLlZlY3RvcjIoKSxcbiAgICAgICAgICBvYmplY3RVcCA9IG5ldyBUSFJFRS5WZWN0b3IzKCksXG4gICAgICAgICAgcGFuID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICBtb3VzZUNoYW5nZS5jb3B5KF9wYW5FbmQpLnN1YihfcGFuU3RhcnQpO1xuXG4gICAgICAgIGlmIChtb3VzZUNoYW5nZS5sZW5ndGhTcSgpKSB7XG4gICAgICAgICAgbW91c2VDaGFuZ2UubXVsdGlwbHlTY2FsYXIoX2V5ZS5sZW5ndGgoKSAqIF90aGlzLnBhblNwZWVkKTtcblxuICAgICAgICAgIHBhbi5jb3B5KF9leWUpLmNyb3NzKF90aGlzLm9iamVjdC51cCkuc2V0TGVuZ3RoKG1vdXNlQ2hhbmdlLngpO1xuICAgICAgICAgIHBhbi5hZGQob2JqZWN0VXAuY29weShfdGhpcy5vYmplY3QudXApLnNldExlbmd0aChtb3VzZUNoYW5nZS55KSk7XG5cbiAgICAgICAgICBfdGhpcy5vYmplY3QucG9zaXRpb24uYWRkKHBhbik7XG4gICAgICAgICAgX3RoaXMudGFyZ2V0LmFkZChwYW4pO1xuXG4gICAgICAgICAgaWYgKF90aGlzLnN0YXRpY01vdmluZykge1xuICAgICAgICAgICAgX3BhblN0YXJ0LmNvcHkoX3BhbkVuZCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIF9wYW5TdGFydC5hZGQobW91c2VDaGFuZ2Uuc3ViVmVjdG9ycyhfcGFuRW5kLCBfcGFuU3RhcnQpLm11bHRpcGx5U2NhbGFyKF90aGlzLmR5bmFtaWNEYW1waW5nRmFjdG9yKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0oKSk7XG5cbiAgICB0aGlzLmNoZWNrRGlzdGFuY2VzID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIV90aGlzLm5vWm9vbSB8fCAhX3RoaXMubm9QYW4pIHtcbiAgICAgICAgaWYgKF9leWUubGVuZ3RoU3EoKSA+IF90aGlzLm1heERpc3RhbmNlICogX3RoaXMubWF4RGlzdGFuY2UpIHtcbiAgICAgICAgICBfdGhpcy5vYmplY3QucG9zaXRpb24uYWRkVmVjdG9ycyhfdGhpcy50YXJnZXQsIF9leWUuc2V0TGVuZ3RoKF90aGlzLm1heERpc3RhbmNlKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoX2V5ZS5sZW5ndGhTcSgpIDwgX3RoaXMubWluRGlzdGFuY2UgKiBfdGhpcy5taW5EaXN0YW5jZSkge1xuICAgICAgICAgIF90aGlzLm9iamVjdC5wb3NpdGlvbi5hZGRWZWN0b3JzKF90aGlzLnRhcmdldCwgX2V5ZS5zZXRMZW5ndGgoX3RoaXMubWluRGlzdGFuY2UpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLnVwZGF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgX2V5ZS5zdWJWZWN0b3JzKF90aGlzLm9iamVjdC5wb3NpdGlvbiwgX3RoaXMudGFyZ2V0KTtcblxuICAgICAgaWYgKCFfdGhpcy5ub1JvdGF0ZSkge1xuICAgICAgICBfdGhpcy5yb3RhdGVDYW1lcmEoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFfdGhpcy5ub1pvb20pIHtcbiAgICAgICAgX3RoaXMuem9vbUNhbWVyYSgpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIV90aGlzLm5vUGFuKSB7XG4gICAgICAgIF90aGlzLnBhbkNhbWVyYSgpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIV90aGlzLm5vQ3VzdG9tKSB7XG4gICAgICAgIF90aGlzLmN1c3RvbShfY3VzdG9tU3RhcnQsIF9jdXN0b21FbmQpO1xuICAgICAgfVxuXG4gICAgICBfdGhpcy5vYmplY3QucG9zaXRpb24uYWRkVmVjdG9ycyhfdGhpcy50YXJnZXQsIF9leWUpO1xuXG4gICAgICBfdGhpcy5jaGVja0Rpc3RhbmNlcygpO1xuXG4gICAgICBfdGhpcy5vYmplY3QubG9va0F0KF90aGlzLnRhcmdldCk7XG5cbiAgICAgIGlmIChsYXN0UG9zaXRpb24uZGlzdGFuY2VUb1NxdWFyZWQoX3RoaXMub2JqZWN0LnBvc2l0aW9uKSA+IEVQUykge1xuICAgICAgICBfdGhpcy5kaXNwYXRjaEV2ZW50KGNoYW5nZUV2ZW50KTtcblxuICAgICAgICBsYXN0UG9zaXRpb24uY29weShfdGhpcy5vYmplY3QucG9zaXRpb24pO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLnJlc2V0ID0gZnVuY3Rpb24oKSB7XG4gICAgICBfc3RhdGUgPSBTVEFURS5OT05FO1xuICAgICAgX3ByZXZTdGF0ZSA9IFNUQVRFLk5PTkU7XG5cbiAgICAgIF90aGlzLnRhcmdldC5jb3B5KF90aGlzLnRhcmdldDApO1xuICAgICAgX3RoaXMub2JqZWN0LnBvc2l0aW9uLmNvcHkoX3RoaXMucG9zaXRpb24wKTtcbiAgICAgIF90aGlzLm9iamVjdC51cC5jb3B5KF90aGlzLnVwMCk7XG5cbiAgICAgIF9leWUuc3ViVmVjdG9ycyhfdGhpcy5vYmplY3QucG9zaXRpb24sIF90aGlzLnRhcmdldCk7XG5cbiAgICAgIF90aGlzLm9iamVjdC5sb29rQXQoX3RoaXMudGFyZ2V0KTtcblxuICAgICAgX3RoaXMuZGlzcGF0Y2hFdmVudChjaGFuZ2VFdmVudCk7XG5cbiAgICAgIGxhc3RQb3NpdGlvbi5jb3B5KF90aGlzLm9iamVjdC5wb3NpdGlvbik7XG4gICAgfTtcblxuICAgIHRoaXMuc2V0U3RhdGUgPSBmdW5jdGlvbih0YXJnZXRTdGF0ZSkge1xuICAgICAgX3RoaXMuZm9yY2VTdGF0ZSA9IHRhcmdldFN0YXRlO1xuICAgICAgX3ByZXZTdGF0ZSA9IHRhcmdldFN0YXRlO1xuICAgICAgX3N0YXRlID0gdGFyZ2V0U3RhdGU7XG4gICAgfTtcblxuICAgIHRoaXMuY3VzdG9tID0gZnVuY3Rpb24oY3VzdG9tU3RhcnQsIGN1c3RvbUVuZCkge1xuXG4gICAgfTtcblxuICAgIC8vIGxpc3RlbmVyc1xuXG4gICAgZnVuY3Rpb24ga2V5ZG93bihldmVudCkge1xuICAgICAgaWYgKF90aGlzLmVuYWJsZWQgPT09IGZhbHNlKSByZXR1cm47XG5cbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywga2V5ZG93bik7XG5cbiAgICAgIF9wcmV2U3RhdGUgPSBfc3RhdGU7XG5cbiAgICAgIGlmIChfc3RhdGUgIT09IFNUQVRFLk5PTkUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIGlmIChldmVudC5rZXlDb2RlID09PSBfdGhpcy5rZXlzW1NUQVRFLlJPVEFURV0gJiYgIV90aGlzLm5vUm90YXRlKSB7XG4gICAgICAgIF9zdGF0ZSA9IFNUQVRFLlJPVEFURTtcbiAgICAgIH0gZWxzZSBpZiAoZXZlbnQua2V5Q29kZSA9PT0gX3RoaXMua2V5c1tTVEFURS5aT09NXSAmJiAhX3RoaXMubm9ab29tKSB7XG4gICAgICAgIF9zdGF0ZSA9IFNUQVRFLlpPT007XG4gICAgICB9IGVsc2UgaWYgKGV2ZW50LmtleUNvZGUgPT09IF90aGlzLmtleXNbU1RBVEUuUEFOXSAmJiAhX3RoaXMubm9QYW4pIHtcbiAgICAgICAgX3N0YXRlID0gU1RBVEUuUEFOO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGtleXVwKGV2ZW50KSB7XG4gICAgICBpZiAoX3RoaXMuZW5hYmxlZCA9PT0gZmFsc2UpIHJldHVybjtcblxuICAgICAgX3N0YXRlID0gX3ByZXZTdGF0ZTtcblxuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBrZXlkb3duLCBmYWxzZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbW91c2Vkb3duKGV2ZW50KSB7XG4gICAgICBpZiAoX3RoaXMuZW5hYmxlZCA9PT0gZmFsc2UpIHJldHVybjtcblxuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgICBpZiAoX3N0YXRlID09PSBTVEFURS5OT05FKSB7XG4gICAgICAgIF9zdGF0ZSA9IGV2ZW50LmJ1dHRvbjtcbiAgICAgIH1cblxuICAgICAgaWYgKF9zdGF0ZSA9PT0gU1RBVEUuUk9UQVRFICYmICFfdGhpcy5ub1JvdGF0ZSkge1xuICAgICAgICBfbW92ZUN1cnIuY29weShnZXRNb3VzZU9uQ2lyY2xlKGV2ZW50LnBhZ2VYLCBldmVudC5wYWdlWSkpO1xuICAgICAgICBfbW92ZVByZXYuY29weShfbW92ZUN1cnIpO1xuICAgICAgfSBlbHNlIGlmIChfc3RhdGUgPT09IFNUQVRFLlpPT00gJiYgIV90aGlzLm5vWm9vbSkge1xuICAgICAgICBfem9vbVN0YXJ0LmNvcHkoZ2V0TW91c2VPblNjcmVlbihldmVudC5wYWdlWCwgZXZlbnQucGFnZVkpKTtcbiAgICAgICAgX3pvb21FbmQuY29weShfem9vbVN0YXJ0KTtcbiAgICAgIH0gZWxzZSBpZiAoX3N0YXRlID09PSBTVEFURS5QQU4gJiYgIV90aGlzLm5vUGFuKSB7XG4gICAgICAgIF9wYW5TdGFydC5jb3B5KGdldE1vdXNlT25TY3JlZW4oZXZlbnQucGFnZVgsIGV2ZW50LnBhZ2VZKSk7XG4gICAgICAgIF9wYW5FbmQuY29weShfcGFuU3RhcnQpO1xuICAgICAgfSBlbHNlIGlmIChfc3RhdGUgPT09IFNUQVRFLkNVU1RPTSAmJiAhX3RoaXMubm9DdXN0b20pIHtcbiAgICAgICAgX2N1c3RvbVN0YXJ0LmNvcHkoZ2V0TW91c2VPblNjcmVlbihldmVudC5wYWdlWCwgZXZlbnQucGFnZVkpKTtcbiAgICAgICAgX2N1c3RvbUVuZC5jb3B5KF9wYW5TdGFydCk7XG4gICAgICB9XG5cbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIG1vdXNlbW92ZSwgZmFsc2UpO1xuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIG1vdXNldXAsIGZhbHNlKTtcblxuICAgICAgX3RoaXMuZGlzcGF0Y2hFdmVudChzdGFydEV2ZW50KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtb3VzZW1vdmUoZXZlbnQpIHtcbiAgICAgIGlmIChfdGhpcy5lbmFibGVkID09PSBmYWxzZSkgcmV0dXJuO1xuXG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cbiAgICAgIGlmIChfc3RhdGUgPT09IFNUQVRFLlJPVEFURSAmJiAhX3RoaXMubm9Sb3RhdGUpIHtcbiAgICAgICAgX21vdmVQcmV2LmNvcHkoX21vdmVDdXJyKTtcbiAgICAgICAgX21vdmVDdXJyLmNvcHkoZ2V0TW91c2VPbkNpcmNsZShldmVudC5wYWdlWCwgZXZlbnQucGFnZVkpKTtcbiAgICAgIH0gZWxzZSBpZiAoX3N0YXRlID09PSBTVEFURS5aT09NICYmICFfdGhpcy5ub1pvb20pIHtcbiAgICAgICAgX3pvb21FbmQuY29weShnZXRNb3VzZU9uU2NyZWVuKGV2ZW50LnBhZ2VYLCBldmVudC5wYWdlWSkpO1xuICAgICAgfSBlbHNlIGlmIChfc3RhdGUgPT09IFNUQVRFLlBBTiAmJiAhX3RoaXMubm9QYW4pIHtcbiAgICAgICAgX3BhbkVuZC5jb3B5KGdldE1vdXNlT25TY3JlZW4oZXZlbnQucGFnZVgsIGV2ZW50LnBhZ2VZKSk7XG4gICAgICB9IGVsc2UgaWYgKF9zdGF0ZSA9PT0gU1RBVEUuQ1VTVE9NICYmICFfdGhpcy5ub0N1c3RvbSkge1xuICAgICAgICBfY3VzdG9tRW5kLmNvcHkoZ2V0TW91c2VPblNjcmVlbihldmVudC5wYWdlWCwgZXZlbnQucGFnZVkpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtb3VzZXVwKGV2ZW50KSB7XG4gICAgICBpZiAoX3RoaXMuZW5hYmxlZCA9PT0gZmFsc2UpIHJldHVybjtcblxuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgICBpZiAoX3RoaXMuZm9yY2VTdGF0ZSA9PT0gLTEpIHtcbiAgICAgICAgX3N0YXRlID0gU1RBVEUuTk9ORTtcbiAgICAgIH1cblxuICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgbW91c2Vtb3ZlKTtcbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBtb3VzZXVwKTtcbiAgICAgIF90aGlzLmRpc3BhdGNoRXZlbnQoZW5kRXZlbnQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1vdXNld2hlZWwoZXZlbnQpIHtcbiAgICAgIGlmIChfdGhpcy5lbmFibGVkID09PSBmYWxzZSkgcmV0dXJuO1xuXG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cbiAgICAgIGxldCBkZWx0YSA9IDA7XG5cbiAgICAgIGlmIChldmVudC53aGVlbERlbHRhKSB7XG4gLy8gV2ViS2l0IC8gT3BlcmEgLyBFeHBsb3JlciA5XG5cbiAgICAgICAgZGVsdGEgPSBldmVudC53aGVlbERlbHRhIC8gNDA7XG4gICAgICB9IGVsc2UgaWYgKGV2ZW50LmRldGFpbCkge1xuIC8vIEZpcmVmb3hcblxuICAgICAgICBkZWx0YSA9IC1ldmVudC5kZXRhaWwgLyAzO1xuICAgICAgfVxuXG4gICAgICBpZiAoX3N0YXRlICE9PSBTVEFURS5DVVNUT00pIHtcbiAgICAgICAgX3pvb21TdGFydC55ICs9IGRlbHRhICogMC4wMTtcbiAgICAgIH0gZWxzZSBpZiAoX3N0YXRlID09PSBTVEFURS5DVVNUT00pIHtcbiAgICAgICAgX2N1c3RvbVN0YXJ0LnkgKz0gZGVsdGEgKiAwLjAxO1xuICAgICAgfVxuXG4gICAgICBfdGhpcy5kaXNwYXRjaEV2ZW50KHN0YXJ0RXZlbnQpO1xuICAgICAgX3RoaXMuZGlzcGF0Y2hFdmVudChlbmRFdmVudCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG91Y2hzdGFydChldmVudCkge1xuICAgICAgaWYgKF90aGlzLmVuYWJsZWQgPT09IGZhbHNlKSByZXR1cm47XG5cbiAgICAgIGlmIChfdGhpcy5mb3JjZVN0YXRlID09PSAtMSkge1xuICAgICAgICBzd2l0Y2ggKGV2ZW50LnRvdWNoZXMubGVuZ3RoKSB7XG5cbiAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICBfc3RhdGUgPSBTVEFURS5UT1VDSF9ST1RBVEU7XG4gICAgICAgICAgICBfbW92ZUN1cnIuY29weShnZXRNb3VzZU9uQ2lyY2xlKGV2ZW50LnRvdWNoZXNbMF0ucGFnZVgsIGV2ZW50LnRvdWNoZXNbMF0ucGFnZVkpKTtcbiAgICAgICAgICAgIF9tb3ZlUHJldi5jb3B5KF9tb3ZlQ3Vycik7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIF9zdGF0ZSA9IFNUQVRFLlRPVUNIX1pPT007XG4gICAgICAgICAgICB2YXIgZHggPSBldmVudC50b3VjaGVzWzBdLnBhZ2VYIC0gZXZlbnQudG91Y2hlc1sxXS5wYWdlWDtcbiAgICAgICAgICAgIHZhciBkeSA9IGV2ZW50LnRvdWNoZXNbMF0ucGFnZVkgLSBldmVudC50b3VjaGVzWzFdLnBhZ2VZO1xuICAgICAgICAgICAgX3RvdWNoWm9vbURpc3RhbmNlRW5kID0gX3RvdWNoWm9vbURpc3RhbmNlU3RhcnQgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuXG4gICAgICAgICAgICB2YXIgeCA9IChldmVudC50b3VjaGVzWzBdLnBhZ2VYICsgZXZlbnQudG91Y2hlc1sxXS5wYWdlWCkgLyAyO1xuICAgICAgICAgICAgdmFyIHkgPSAoZXZlbnQudG91Y2hlc1swXS5wYWdlWSArIGV2ZW50LnRvdWNoZXNbMV0ucGFnZVkpIC8gMjtcbiAgICAgICAgICAgIF9wYW5TdGFydC5jb3B5KGdldE1vdXNlT25TY3JlZW4oeCwgeSkpO1xuICAgICAgICAgICAgX3BhbkVuZC5jb3B5KF9wYW5TdGFydCk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBfc3RhdGUgPSBTVEFURS5OT05FO1xuXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHsgTk9ORTogLTEsIFJPVEFURTogMCwgWk9PTTogMSwgUEFOOiAyLCBUT1VDSF9ST1RBVEU6IDMsIFRPVUNIX1pPT01fUEFOOiA0LCBDVVNUT006IDk5IH07XG4gICAgICAgIHN3aXRjaCAoX3N0YXRlKSB7XG5cbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAvLyAxIG9yIDIgZmluZ2Vycywgc21hZSBiZWhhdmlvclxuICAgICAgICAgICAgX3N0YXRlID0gU1RBVEUuVE9VQ0hfUk9UQVRFO1xuICAgICAgICAgICAgX21vdmVDdXJyLmNvcHkoZ2V0TW91c2VPbkNpcmNsZShldmVudC50b3VjaGVzWzBdLnBhZ2VYLCBldmVudC50b3VjaGVzWzBdLnBhZ2VZKSk7XG4gICAgICAgICAgICBfbW92ZVByZXYuY29weShfbW92ZUN1cnIpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgaWYgKGV2ZW50LnRvdWNoZXMubGVuZ3RoID49IDIpIHtcbiAgICAgICAgICAgICAgX3N0YXRlID0gU1RBVEUuVE9VQ0hfWk9PTTtcbiAgICAgICAgICAgICAgdmFyIGR4ID0gZXZlbnQudG91Y2hlc1swXS5wYWdlWCAtIGV2ZW50LnRvdWNoZXNbMV0ucGFnZVg7XG4gICAgICAgICAgICAgIHZhciBkeSA9IGV2ZW50LnRvdWNoZXNbMF0ucGFnZVkgLSBldmVudC50b3VjaGVzWzFdLnBhZ2VZO1xuICAgICAgICAgICAgICBfdG91Y2hab29tRGlzdGFuY2VFbmQgPSBfdG91Y2hab29tRGlzdGFuY2VTdGFydCA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBfc3RhdGUgPSBTVEFURS5aT09NO1xuICAgICAgICAgICAgICBfem9vbVN0YXJ0LmNvcHkoZ2V0TW91c2VPblNjcmVlbihldmVudC50b3VjaGVzWzBdLnBhZ2VYLCBldmVudC50b3VjaGVzWzBdLnBhZ2VZKSk7XG4gICAgICAgICAgICAgIF96b29tRW5kLmNvcHkoX3pvb21TdGFydCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICBpZiAoZXZlbnQudG91Y2hlcy5sZW5ndGggPj0gMikge1xuICAgICAgICAgICAgICBfc3RhdGUgPSBTVEFURS5UT1VDSF9QQU47XG4gICAgICAgICAgICAgIHZhciB4ID0gKGV2ZW50LnRvdWNoZXNbMF0ucGFnZVggKyBldmVudC50b3VjaGVzWzFdLnBhZ2VYKSAvIDI7XG4gICAgICAgICAgICAgIHZhciB5ID0gKGV2ZW50LnRvdWNoZXNbMF0ucGFnZVkgKyBldmVudC50b3VjaGVzWzFdLnBhZ2VZKSAvIDI7XG4gICAgICAgICAgICAgIF9wYW5TdGFydC5jb3B5KGdldE1vdXNlT25TY3JlZW4oeCwgeSkpO1xuICAgICAgICAgICAgICBfcGFuRW5kLmNvcHkoX3BhblN0YXJ0KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIF9zdGF0ZSA9IFNUQVRFLlBBTjtcbiAgICAgICAgICAgICAgX3BhblN0YXJ0LmNvcHkoZ2V0TW91c2VPblNjcmVlbihldmVudC50b3VjaGVzWzBdLnBhZ2VYLCBldmVudC50b3VjaGVzWzBdLnBhZ2VZKSk7XG4gICAgICAgICAgICAgIF9wYW5FbmQuY29weShfcGFuU3RhcnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDk5OlxuICAgICAgICAgICAgX3N0YXRlID0gU1RBVEUuQ1VTVE9NO1xuICAgICAgICAgICAgdmFyIHggPSAoZXZlbnQudG91Y2hlc1swXS5wYWdlWCArIGV2ZW50LnRvdWNoZXNbMV0ucGFnZVgpIC8gMjtcbiAgICAgICAgICAgIHZhciB5ID0gKGV2ZW50LnRvdWNoZXNbMF0ucGFnZVkgKyBldmVudC50b3VjaGVzWzFdLnBhZ2VZKSAvIDI7XG4gICAgICAgICAgICBfY3VzdG9tU3RhcnQuY29weShnZXRNb3VzZU9uU2NyZWVuKHgsIHkpKTtcbiAgICAgICAgICAgIF9jdXN0b21FbmQuY29weShfY3VzdG9tU3RhcnQpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgX3N0YXRlID0gU1RBVEUuTk9ORTtcblxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIF90aGlzLmRpc3BhdGNoRXZlbnQoc3RhcnRFdmVudCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG91Y2htb3ZlKGV2ZW50KSB7XG4gICAgICBpZiAoX3RoaXMuZW5hYmxlZCA9PT0gZmFsc2UpIHJldHVybjtcblxuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgICBpZiAoX3RoaXMuZm9yY2VTdGF0ZSA9PT0gLTEpIHtcbiAgICAgICAgc3dpdGNoIChldmVudC50b3VjaGVzLmxlbmd0aCkge1xuXG4gICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgX21vdmVQcmV2LmNvcHkoX21vdmVDdXJyKTtcbiAgICAgICAgICAgIF9tb3ZlQ3Vyci5jb3B5KGdldE1vdXNlT25DaXJjbGUoZXZlbnQudG91Y2hlc1swXS5wYWdlWCwgZXZlbnQudG91Y2hlc1swXS5wYWdlWSkpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICB2YXIgZHggPSBldmVudC50b3VjaGVzWzBdLnBhZ2VYIC0gZXZlbnQudG91Y2hlc1sxXS5wYWdlWDtcbiAgICAgICAgICAgIHZhciBkeSA9IGV2ZW50LnRvdWNoZXNbMF0ucGFnZVkgLSBldmVudC50b3VjaGVzWzFdLnBhZ2VZO1xuICAgICAgICAgICAgX3RvdWNoWm9vbURpc3RhbmNlRW5kID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcblxuICAgICAgICAgICAgdmFyIHggPSAoZXZlbnQudG91Y2hlc1swXS5wYWdlWCArIGV2ZW50LnRvdWNoZXNbMV0ucGFnZVgpIC8gMjtcbiAgICAgICAgICAgIHZhciB5ID0gKGV2ZW50LnRvdWNoZXNbMF0ucGFnZVkgKyBldmVudC50b3VjaGVzWzFdLnBhZ2VZKSAvIDI7XG4gICAgICAgICAgICBfcGFuRW5kLmNvcHkoZ2V0TW91c2VPblNjcmVlbih4LCB5KSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBfc3RhdGUgPSBTVEFURS5OT05FO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyB7IE5PTkU6IC0xLCBST1RBVEU6IDAsIFpPT006IDEsIFBBTjogMiwgVE9VQ0hfUk9UQVRFOiAzLCBUT1VDSF9aT09NX1BBTjogNCwgQ1VTVE9NOiA5OSB9O1xuICAgICAgICBzd2l0Y2ggKF9zdGF0ZSkge1xuXG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgX21vdmVQcmV2LmNvcHkoX21vdmVDdXJyKTtcbiAgICAgICAgICAgIF9tb3ZlQ3Vyci5jb3B5KGdldE1vdXNlT25DaXJjbGUoZXZlbnQudG91Y2hlc1swXS5wYWdlWCwgZXZlbnQudG91Y2hlc1swXS5wYWdlWSkpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICBfem9vbUVuZC5jb3B5KGdldE1vdXNlT25TY3JlZW4oZXZlbnQudG91Y2hlc1swXS5wYWdlWCwgZXZlbnQudG91Y2hlc1swXS5wYWdlWSkpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICBfcGFuRW5kLmNvcHkoZ2V0TW91c2VPblNjcmVlbihldmVudC50b3VjaGVzWzBdLnBhZ2VYLCBldmVudC50b3VjaGVzWzBdLnBhZ2VZKSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIC8vIDIgZmluZ2VycyFcbiAgICAgICAgICAgIC8vIFRPVUNIIFpPT01cbiAgICAgICAgICAgIHZhciBkeCA9IGV2ZW50LnRvdWNoZXNbMF0ucGFnZVggLSBldmVudC50b3VjaGVzWzFdLnBhZ2VYO1xuICAgICAgICAgICAgdmFyIGR5ID0gZXZlbnQudG91Y2hlc1swXS5wYWdlWSAtIGV2ZW50LnRvdWNoZXNbMV0ucGFnZVk7XG4gICAgICAgICAgICBfdG91Y2hab29tRGlzdGFuY2VFbmQgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAvLyAyIGZpbmdlcnNcbiAgICAgICAgICAgIC8vIFRPVUNIX1BBTlxuICAgICAgICAgICAgdmFyIHggPSAoZXZlbnQudG91Y2hlc1swXS5wYWdlWCArIGV2ZW50LnRvdWNoZXNbMV0ucGFnZVgpIC8gMjtcbiAgICAgICAgICAgIHZhciB5ID0gKGV2ZW50LnRvdWNoZXNbMF0ucGFnZVkgKyBldmVudC50b3VjaGVzWzFdLnBhZ2VZKSAvIDI7XG4gICAgICAgICAgICBfcGFuRW5kLmNvcHkoZ2V0TW91c2VPblNjcmVlbih4LCB5KSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgOTk6XG4gICAgICAgICAgICB2YXIgeCA9IChldmVudC50b3VjaGVzWzBdLnBhZ2VYICsgZXZlbnQudG91Y2hlc1sxXS5wYWdlWCkgLyAyO1xuICAgICAgICAgICAgdmFyIHkgPSAoZXZlbnQudG91Y2hlc1swXS5wYWdlWSArIGV2ZW50LnRvdWNoZXNbMV0ucGFnZVkpIC8gMjtcbiAgICAgICAgICAgIF9jdXN0b21FbmQuY29weShnZXRNb3VzZU9uU2NyZWVuKHgsIHkpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIF9zdGF0ZSA9IFNUQVRFLk5PTkU7XG5cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvdWNoZW5kKGV2ZW50KSB7XG4gICAgICBpZiAoX3RoaXMuZW5hYmxlZCA9PT0gZmFsc2UpIHJldHVybjtcblxuICAgICAgaWYgKF90aGlzLmZvcmNlU3RhdGUgPT09IC0xKSB7XG4gICAgICAgIHN3aXRjaCAoZXZlbnQudG91Y2hlcy5sZW5ndGgpIHtcblxuICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIF9tb3ZlUHJldi5jb3B5KF9tb3ZlQ3Vycik7XG4gICAgICAgICAgICBfbW92ZUN1cnIuY29weShnZXRNb3VzZU9uQ2lyY2xlKGV2ZW50LnRvdWNoZXNbMF0ucGFnZVgsIGV2ZW50LnRvdWNoZXNbMF0ucGFnZVkpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgX3RvdWNoWm9vbURpc3RhbmNlU3RhcnQgPSBfdG91Y2hab29tRGlzdGFuY2VFbmQgPSAwO1xuXG4gICAgICAgICAgICB2YXIgeCA9IChldmVudC50b3VjaGVzWzBdLnBhZ2VYICsgZXZlbnQudG91Y2hlc1sxXS5wYWdlWCkgLyAyO1xuICAgICAgICAgICAgdmFyIHkgPSAoZXZlbnQudG91Y2hlc1swXS5wYWdlWSArIGV2ZW50LnRvdWNoZXNbMV0ucGFnZVkpIC8gMjtcbiAgICAgICAgICAgIF9wYW5FbmQuY29weShnZXRNb3VzZU9uU2NyZWVuKHgsIHkpKTtcbiAgICAgICAgICAgIF9wYW5TdGFydC5jb3B5KF9wYW5FbmQpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIF9zdGF0ZSA9IFNUQVRFLk5PTkU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzd2l0Y2ggKF9zdGF0ZSkge1xuXG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgX21vdmVQcmV2LmNvcHkoX21vdmVDdXJyKTtcbiAgICAgICAgICAgIF9tb3ZlQ3Vyci5jb3B5KGdldE1vdXNlT25DaXJjbGUoZXZlbnQudG91Y2hlc1swXS5wYWdlWCwgZXZlbnQudG91Y2hlc1swXS5wYWdlWSkpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAvLyBUT1VDSCBaT09NXG4gICAgICAgICAgICBfdG91Y2hab29tRGlzdGFuY2VTdGFydCA9IF90b3VjaFpvb21EaXN0YW5jZUVuZCA9IDA7XG4gICAgICAgICAgICBfc3RhdGUgPSBTVEFURS5aT09NO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAvLyBUT1VDSCBaT09NXG4gICAgICAgICAgICBpZiAoZXZlbnQudG91Y2hlcy5sZW5ndGggPj0gMikge1xuICAgICAgICAgICAgICB2YXIgeCA9IChldmVudC50b3VjaGVzWzBdLnBhZ2VYICsgZXZlbnQudG91Y2hlc1sxXS5wYWdlWCkgLyAyO1xuICAgICAgICAgICAgICB2YXIgeSA9IChldmVudC50b3VjaGVzWzBdLnBhZ2VZICsgZXZlbnQudG91Y2hlc1sxXS5wYWdlWSkgLyAyO1xuICAgICAgICAgICAgICBfcGFuRW5kLmNvcHkoZ2V0TW91c2VPblNjcmVlbih4LCB5KSk7XG4gICAgICAgICAgICAgIF9wYW5TdGFydC5jb3B5KF9wYW5FbmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3N0YXRlID0gU1RBVEUuUEFOO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDk5OlxuICAgICAgICAgICAgdmFyIHggPSAoZXZlbnQudG91Y2hlc1swXS5wYWdlWCArIGV2ZW50LnRvdWNoZXNbMV0ucGFnZVgpIC8gMjtcbiAgICAgICAgICAgIHZhciB5ID0gKGV2ZW50LnRvdWNoZXNbMF0ucGFnZVkgKyBldmVudC50b3VjaGVzWzFdLnBhZ2VZKSAvIDI7XG4gICAgICAgICAgICBfY3VzdG9tRW5kLmNvcHkoZ2V0TW91c2VPblNjcmVlbih4LCB5KSk7XG4gICAgICAgICAgICBfY3VzdG9tU3RhcnQuY29weShfY3VzdG9tRW5kKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIF9zdGF0ZSA9IFNUQVRFLk5PTkU7XG5cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBfdGhpcy5kaXNwYXRjaEV2ZW50KGVuZEV2ZW50KTtcbiAgICB9XG5cbiAgICB0aGlzLmRvbUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY29udGV4dG1lbnUnLCBmdW5jdGlvbihldmVudCkge1xuIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG59LCBmYWxzZSk7XG5cbiAgICB0aGlzLmRvbUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgbW91c2Vkb3duLCBmYWxzZSk7XG5cbiAgICB0aGlzLmRvbUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V3aGVlbCcsIG1vdXNld2hlZWwsIGZhbHNlKTtcbiAgICB0aGlzLmRvbUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NTW91c2VTY3JvbGwnLCBtb3VzZXdoZWVsLCBmYWxzZSk7IC8vIGZpcmVmb3hcblxuICAgIHRoaXMuZG9tRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgdG91Y2hzdGFydCwgZmFsc2UpO1xuICAgIHRoaXMuZG9tRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRvdWNoZW5kLCBmYWxzZSk7XG4gICAgdGhpcy5kb21FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRvdWNobW92ZSwgZmFsc2UpO1xuXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBrZXlkb3duLCBmYWxzZSk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2tleXVwJywga2V5dXAsIGZhbHNlKTtcblxuICAgIHRoaXMuaGFuZGxlUmVzaXplKCk7XG5cbiAgICAvLyBmb3JjZSBhbiB1cGRhdGUgYXQgc3RhcnRcbiAgICB0aGlzLnVwZGF0ZSgpO1xuICB9XG59XG4iLCIvKipcbiAqIEBhdXRob3IgRWJlcmhhcmQgR3JhZXRoZXIgLyBodHRwOi8vZWdyYWV0aGVyLmNvbS9cbiAqIEBhdXRob3IgTWFyayBMdW5kaW4gIC8gaHR0cDovL21hcmstbHVuZGluLmNvbVxuICogQGF1dGhvciBQYXRyaWNrIEZ1bGxlciAvIGh0dHA6Ly9wYXRyaWNrLWZ1bGxlci5jb21cbiAqIEBhdXRob3IgTWF4IFNtb2xlbnMgLyBodHRwczovL2dpdGh1Yi5jb20vbXNtb2xlbnNcbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUcmFja2JhbGxvcnRobyBleHRlbmRzIFRIUkVFLkV2ZW50RGlzcGF0Y2hlciB7XG4gIGNvbnN0cnVjdG9yKG9iamVjdCwgZG9tRWxlbWVudCwgc3RhdGUgPSB7Tk9ORTogLTEsIFJPVEFURTogMSwgWk9PTTogMiwgUEFOOiAwLCBTQ1JPTEw6IDQsIFRPVUNIX1JPVEFURTogNCwgVE9VQ0hfWk9PTV9QQU46IDV9KSB7XG4gICAgc3VwZXIoKTtcblxuICAgIGxldCBfdGhpcyA9IHRoaXM7XG4gICAgbGV0IFNUQVRFID0gc3RhdGU7XG5cbiAgICB0aGlzLm9iamVjdCA9IG9iamVjdDtcbiAgICB0aGlzLmRvbUVsZW1lbnQgPSAoZG9tRWxlbWVudCAhPT0gdW5kZWZpbmVkKSA/IGRvbUVsZW1lbnQgOiBkb2N1bWVudDtcblxuICAgIC8vIEFQSVxuXG4gICAgdGhpcy5lbmFibGVkID0gdHJ1ZTtcblxuICAgIHRoaXMuc2NyZWVuID0ge2xlZnQ6IDAsIHRvcDogMCwgd2lkdGg6IDAsIGhlaWdodDogMH07XG5cbiAgICB0aGlzLnJhZGl1cyA9IDA7XG5cbiAgICB0aGlzLnpvb21TcGVlZCA9IDEuMjtcblxuICAgIHRoaXMubm9ab29tID0gZmFsc2U7XG4gICAgdGhpcy5ub1BhbiA9IGZhbHNlO1xuXG4gICAgdGhpcy5zdGF0aWNNb3ZpbmcgPSBmYWxzZTtcbiAgICB0aGlzLmR5bmFtaWNEYW1waW5nRmFjdG9yID0gMC4yO1xuXG4gICAgdGhpcy5rZXlzID0gWzY1IC8qIEEqLywgODMgLyogUyovLCA2OF07XG5cbiAgICAvLyBpbnRlcm5hbHNcblxuICAgIHRoaXMudGFyZ2V0ID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICAgIGxldCBFUFMgPSAwLjAwMDAwMTtcblxuICAgIGxldCBfY2hhbmdlZCA9IHRydWU7XG5cbiAgICBsZXQgX3N0YXRlID0gU1RBVEUuTk9ORSxcbiAgICBfcHJldlN0YXRlID0gU1RBVEUuTk9ORSxcblxuICAgIF9leWUgPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxuXG4gICAgX3pvb21TdGFydCA9IG5ldyBUSFJFRS5WZWN0b3IyKCksXG4gICAgX3pvb21FbmQgPSBuZXcgVEhSRUUuVmVjdG9yMigpLFxuXG4gICAgX3RvdWNoWm9vbURpc3RhbmNlU3RhcnQgPSAwLFxuICAgIF90b3VjaFpvb21EaXN0YW5jZUVuZCA9IDAsXG5cbiAgICBfcGFuU3RhcnQgPSBuZXcgVEhSRUUuVmVjdG9yMigpLFxuICAgIF9wYW5FbmQgPSBuZXcgVEhSRUUuVmVjdG9yMigpO1xuXG4gICAgLy8gd2luZG93IGxldmVsIGZpcmUgYWZ0ZXIuLi5cblxuICAgIC8vIGZvciByZXNldFxuXG4gICAgdGhpcy50YXJnZXQwID0gdGhpcy50YXJnZXQuY2xvbmUoKTtcbiAgICB0aGlzLnBvc2l0aW9uMCA9IHRoaXMub2JqZWN0LnBvc2l0aW9uLmNsb25lKCk7XG4gICAgdGhpcy51cDAgPSB0aGlzLm9iamVjdC51cC5jbG9uZSgpO1xuXG4gICAgdGhpcy5sZWZ0MCA9IHRoaXMub2JqZWN0LmxlZnQ7XG4gICAgdGhpcy5yaWdodDAgPSB0aGlzLm9iamVjdC5yaWdodDtcbiAgICB0aGlzLnRvcDAgPSB0aGlzLm9iamVjdC50b3A7XG4gICAgdGhpcy5ib3R0b20wID0gdGhpcy5vYmplY3QuYm90dG9tO1xuXG4gICAgLy8gZXZlbnRzXG5cbiAgICBsZXQgY2hhbmdlRXZlbnQgPSB7dHlwZTogJ2NoYW5nZSd9O1xuICAgIGxldCBzdGFydEV2ZW50ID0ge3R5cGU6ICdzdGFydCd9O1xuICAgIGxldCBlbmRFdmVudCA9IHt0eXBlOiAnZW5kJ307XG5cbiAgICAvLyBtZXRob2RzXG5cbiAgICB0aGlzLmhhbmRsZVJlc2l6ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMuZG9tRWxlbWVudCA9PT0gZG9jdW1lbnQpIHtcbiAgICAgICAgdGhpcy5zY3JlZW4ubGVmdCA9IDA7XG4gICAgICAgIHRoaXMuc2NyZWVuLnRvcCA9IDA7XG4gICAgICAgIHRoaXMuc2NyZWVuLndpZHRoID0gd2luZG93LmlubmVyV2lkdGg7XG4gICAgICAgIHRoaXMuc2NyZWVuLmhlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCBib3ggPSB0aGlzLmRvbUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIC8vIGFkanVzdG1lbnRzIGNvbWUgZnJvbSBzaW1pbGFyIGNvZGUgaW4gdGhlIGpxdWVyeSBvZmZzZXQoKSBmdW5jdGlvblxuICAgICAgICBsZXQgZCA9IHRoaXMuZG9tRWxlbWVudC5vd25lckRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICAgICAgdGhpcy5zY3JlZW4ubGVmdCA9IGJveC5sZWZ0ICsgd2luZG93LnBhZ2VYT2Zmc2V0IC0gZC5jbGllbnRMZWZ0O1xuICAgICAgICB0aGlzLnNjcmVlbi50b3AgPSBib3gudG9wICsgd2luZG93LnBhZ2VZT2Zmc2V0IC0gZC5jbGllbnRUb3A7XG4gICAgICAgIHRoaXMuc2NyZWVuLndpZHRoID0gYm94LndpZHRoO1xuICAgICAgICB0aGlzLnNjcmVlbi5oZWlnaHQgPSBib3guaGVpZ2h0O1xuICAgICAgfVxuXG4gICAgICB0aGlzLnJhZGl1cyA9IDAuNSAqIE1hdGgubWluKHRoaXMuc2NyZWVuLndpZHRoLCB0aGlzLnNjcmVlbi5oZWlnaHQpO1xuXG4gICAgICB0aGlzLmxlZnQwID0gdGhpcy5vYmplY3QubGVmdDtcbiAgICAgIHRoaXMucmlnaHQwID0gdGhpcy5vYmplY3QucmlnaHQ7XG4gICAgICB0aGlzLnRvcDAgPSB0aGlzLm9iamVjdC50b3A7XG4gICAgICB0aGlzLmJvdHRvbTAgPSB0aGlzLm9iamVjdC5ib3R0b207XG4gICAgfTtcblxuICAgIHRoaXMuaGFuZGxlRXZlbnQgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgaWYgKHR5cGVvZiB0aGlzW2V2ZW50LnR5cGVdID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhpc1tldmVudC50eXBlXShldmVudCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGxldCBnZXRNb3VzZU9uU2NyZWVuID0gKGZ1bmN0aW9uKCkge1xuICAgICAgbGV0IHZlY3RvciA9IG5ldyBUSFJFRS5WZWN0b3IyKCk7XG5cbiAgICAgIHJldHVybiBmdW5jdGlvbiBnZXRNb3VzZU9uU2NyZWVuKHBhZ2VYLCBwYWdlWSkge1xuICAgICAgICB2ZWN0b3Iuc2V0KFxuICAgICAgICAgIChwYWdlWCAtIF90aGlzLnNjcmVlbi5sZWZ0KSAvIF90aGlzLnNjcmVlbi53aWR0aCxcbiAgICAgICAgICAocGFnZVkgLSBfdGhpcy5zY3JlZW4udG9wKSAvIF90aGlzLnNjcmVlbi5oZWlnaHRcbiAgICAgICAgKTtcblxuICAgICAgICByZXR1cm4gdmVjdG9yO1xuICAgICAgfTtcbiAgICB9KCkpO1xuXG4gICAgdGhpcy56b29tQ2FtZXJhID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoX3N0YXRlID09PSBTVEFURS5UT1VDSF9aT09NX1BBTikge1xuICAgICAgICB2YXIgZmFjdG9yID0gX3RvdWNoWm9vbURpc3RhbmNlRW5kIC8gX3RvdWNoWm9vbURpc3RhbmNlU3RhcnQ7XG4gICAgICAgIF90b3VjaFpvb21EaXN0YW5jZVN0YXJ0ID0gX3RvdWNoWm9vbURpc3RhbmNlRW5kO1xuXG4gICAgICAgIF90aGlzLm9iamVjdC56b29tICo9IGZhY3RvcjtcblxuICAgICAgICBfY2hhbmdlZCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgZmFjdG9yID0gMS4wICsgKF96b29tRW5kLnkgLSBfem9vbVN0YXJ0LnkpICogX3RoaXMuem9vbVNwZWVkO1xuXG4gICAgICAgIGlmIChNYXRoLmFicyhmYWN0b3IgLSAxLjApID4gRVBTICYmIGZhY3RvciA+IDAuMCkge1xuICAgICAgICAgIF90aGlzLm9iamVjdC56b29tIC89IGZhY3RvcjtcblxuICAgICAgICAgIGlmIChfdGhpcy5zdGF0aWNNb3ZpbmcpIHtcbiAgICAgICAgICAgIF96b29tU3RhcnQuY29weShfem9vbUVuZCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIF96b29tU3RhcnQueSArPSAoX3pvb21FbmQueSAtIF96b29tU3RhcnQueSkgKiB0aGlzLmR5bmFtaWNEYW1waW5nRmFjdG9yO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIF9jaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLnBhbkNhbWVyYSA9IChmdW5jdGlvbigpIHtcbiAgICAgIGxldCBtb3VzZUNoYW5nZSA9IG5ldyBUSFJFRS5WZWN0b3IyKCksXG4gICAgICAgIG9iamVjdFVwID0gbmV3IFRIUkVFLlZlY3RvcjMoKSxcbiAgICAgICAgcGFuID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIHBhbkNhbWVyYSgpIHtcbiAgICAgICAgbW91c2VDaGFuZ2UuY29weShfcGFuRW5kKS5zdWIoX3BhblN0YXJ0KTtcblxuICAgICAgICBpZiAobW91c2VDaGFuZ2UubGVuZ3RoU3EoKSkge1xuICAgICAgICAgIC8vIFNjYWxlIG1vdmVtZW50IHRvIGtlZXAgY2xpY2tlZC9kcmFnZ2VkIHBvc2l0aW9uIHVuZGVyIGN1cnNvclxuICAgICAgICAgIGxldCBzY2FsZV94ID0gKF90aGlzLm9iamVjdC5yaWdodCAtIF90aGlzLm9iamVjdC5sZWZ0KSAvIF90aGlzLm9iamVjdC56b29tO1xuICAgICAgICAgIGxldCBzY2FsZV95ID0gKF90aGlzLm9iamVjdC50b3AgLSBfdGhpcy5vYmplY3QuYm90dG9tKSAvIF90aGlzLm9iamVjdC56b29tO1xuICAgICAgICAgIG1vdXNlQ2hhbmdlLnggKj0gc2NhbGVfeDtcbiAgICAgICAgICBtb3VzZUNoYW5nZS55ICo9IHNjYWxlX3k7XG5cbiAgICAgICAgICBwYW4uY29weShfZXllKS5jcm9zcyhfdGhpcy5vYmplY3QudXApLnNldExlbmd0aChtb3VzZUNoYW5nZS54KTtcbiAgICAgICAgICBwYW4uYWRkKG9iamVjdFVwLmNvcHkoX3RoaXMub2JqZWN0LnVwKS5zZXRMZW5ndGgobW91c2VDaGFuZ2UueSkpO1xuXG4gICAgICAgICAgX3RoaXMub2JqZWN0LnBvc2l0aW9uLmFkZChwYW4pO1xuICAgICAgICAgIF90aGlzLnRhcmdldC5hZGQocGFuKTtcblxuICAgICAgICAgIGlmIChfdGhpcy5zdGF0aWNNb3ZpbmcpIHtcbiAgICAgICAgICAgIF9wYW5TdGFydC5jb3B5KF9wYW5FbmQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBfcGFuU3RhcnQuYWRkKG1vdXNlQ2hhbmdlLnN1YlZlY3RvcnMoX3BhbkVuZCwgX3BhblN0YXJ0KS5tdWx0aXBseVNjYWxhcihfdGhpcy5keW5hbWljRGFtcGluZ0ZhY3RvcikpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIF9jaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9KCkpO1xuXG4gICAgdGhpcy51cGRhdGUgPSBmdW5jdGlvbigpIHtcbiAgICAgIF9leWUuc3ViVmVjdG9ycyhfdGhpcy5vYmplY3QucG9zaXRpb24sIF90aGlzLnRhcmdldCk7XG5cbiAgICAgIGlmICghX3RoaXMubm9ab29tKSB7XG4gICAgICAgIF90aGlzLnpvb21DYW1lcmEoKTtcblxuICAgICAgICBpZiAoX2NoYW5nZWQpIHtcbiAgICAgICAgICBfdGhpcy5vYmplY3QudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghX3RoaXMubm9QYW4pIHtcbiAgICAgICAgX3RoaXMucGFuQ2FtZXJhKCk7XG4gICAgICB9XG5cbiAgICAgIF90aGlzLm9iamVjdC5wb3NpdGlvbi5hZGRWZWN0b3JzKF90aGlzLnRhcmdldCwgX2V5ZSk7XG5cbiAgICAgIF90aGlzLm9iamVjdC5sb29rQXQoX3RoaXMudGFyZ2V0KTtcblxuICAgICAgaWYgKF9jaGFuZ2VkKSB7XG4gICAgICAgIF90aGlzLmRpc3BhdGNoRXZlbnQoY2hhbmdlRXZlbnQpO1xuXG4gICAgICAgIF9jaGFuZ2VkID0gZmFsc2U7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMucmVzZXQgPSBmdW5jdGlvbigpIHtcbiAgICAgIF9zdGF0ZSA9IFNUQVRFLk5PTkU7XG4gICAgICBfcHJldlN0YXRlID0gU1RBVEUuTk9ORTtcblxuICAgICAgX3RoaXMudGFyZ2V0LmNvcHkoX3RoaXMudGFyZ2V0MCk7XG4gICAgICBfdGhpcy5vYmplY3QucG9zaXRpb24uY29weShfdGhpcy5wb3NpdGlvbjApO1xuICAgICAgX3RoaXMub2JqZWN0LnVwLmNvcHkoX3RoaXMudXAwKTtcblxuICAgICAgX2V5ZS5zdWJWZWN0b3JzKF90aGlzLm9iamVjdC5wb3NpdGlvbiwgX3RoaXMudGFyZ2V0KTtcblxuICAgICAgX3RoaXMub2JqZWN0LmxlZnQgPSBfdGhpcy5sZWZ0MDtcbiAgICAgIF90aGlzLm9iamVjdC5yaWdodCA9IF90aGlzLnJpZ2h0MDtcbiAgICAgIF90aGlzLm9iamVjdC50b3AgPSBfdGhpcy50b3AwO1xuICAgICAgX3RoaXMub2JqZWN0LmJvdHRvbSA9IF90aGlzLmJvdHRvbTA7XG5cbiAgICAgIF90aGlzLm9iamVjdC5sb29rQXQoX3RoaXMudGFyZ2V0KTtcblxuICAgICAgX3RoaXMuZGlzcGF0Y2hFdmVudChjaGFuZ2VFdmVudCk7XG5cbiAgICAgIF9jaGFuZ2VkID0gZmFsc2U7XG4gICAgfTtcblxuICAgIC8vIGxpc3RlbmVyc1xuXG4gICAgZnVuY3Rpb24ga2V5ZG93bihldmVudCkge1xuICAgICAgaWYgKF90aGlzLmVuYWJsZWQgPT09IGZhbHNlKSByZXR1cm47XG5cbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywga2V5ZG93bik7XG5cbiAgICAgIF9wcmV2U3RhdGUgPSBfc3RhdGU7XG5cbiAgICAgIGlmIChfc3RhdGUgIT09IFNUQVRFLk5PTkUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIGlmIChldmVudC5rZXlDb2RlID09PSBfdGhpcy5rZXlzW1NUQVRFLlJPVEFURV0gJiYgIV90aGlzLm5vUm90YXRlKSB7XG4gICAgICAgIF9zdGF0ZSA9IFNUQVRFLlJPVEFURTtcbiAgICAgIH0gZWxzZSBpZiAoZXZlbnQua2V5Q29kZSA9PT0gX3RoaXMua2V5c1tTVEFURS5aT09NXSAmJiAhX3RoaXMubm9ab29tKSB7XG4gICAgICAgIF9zdGF0ZSA9IFNUQVRFLlpPT007XG4gICAgICB9IGVsc2UgaWYgKGV2ZW50LmtleUNvZGUgPT09IF90aGlzLmtleXNbU1RBVEUuUEFOXSAmJiAhX3RoaXMubm9QYW4pIHtcbiAgICAgICAgX3N0YXRlID0gU1RBVEUuUEFOO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGtleXVwKGV2ZW50KSB7XG4gICAgICBpZiAoX3RoaXMuZW5hYmxlZCA9PT0gZmFsc2UpIHJldHVybjtcblxuICAgICAgX3N0YXRlID0gX3ByZXZTdGF0ZTtcblxuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBrZXlkb3duLCBmYWxzZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbW91c2Vkb3duKGV2ZW50KSB7XG4gICAgICBpZiAoX3RoaXMuZW5hYmxlZCA9PT0gZmFsc2UpIHJldHVybjtcblxuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgICBpZiAoX3N0YXRlID09PSBTVEFURS5OT05FKSB7XG4gICAgICAgIF9zdGF0ZSA9IGV2ZW50LmJ1dHRvbjtcbiAgICAgIH1cblxuICAgICAgaWYgKF9zdGF0ZSA9PT0gU1RBVEUuUk9UQVRFICYmICFfdGhpcy5ub1JvdGF0ZSkge1xuXG4gICAgICB9IGVsc2UgaWYgKF9zdGF0ZSA9PT0gU1RBVEUuWk9PTSAmJiAhX3RoaXMubm9ab29tKSB7XG4gICAgICAgIF96b29tU3RhcnQuY29weShnZXRNb3VzZU9uU2NyZWVuKGV2ZW50LnBhZ2VYLCBldmVudC5wYWdlWSkpO1xuICAgICAgICBfem9vbUVuZC5jb3B5KF96b29tU3RhcnQpO1xuICAgICAgfSBlbHNlIGlmIChfc3RhdGUgPT09IFNUQVRFLlBBTiAmJiAhX3RoaXMubm9QYW4pIHtcbiAgICAgICAgX3BhblN0YXJ0LmNvcHkoZ2V0TW91c2VPblNjcmVlbihldmVudC5wYWdlWCwgZXZlbnQucGFnZVkpKTtcbiAgICAgICAgX3BhbkVuZC5jb3B5KF9wYW5TdGFydCk7XG4gICAgICB9XG5cbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIG1vdXNlbW92ZSwgZmFsc2UpO1xuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIG1vdXNldXAsIGZhbHNlKTtcblxuICAgICAgX3RoaXMuZGlzcGF0Y2hFdmVudChzdGFydEV2ZW50KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtb3VzZW1vdmUoZXZlbnQpIHtcbiAgICAgIGlmIChfdGhpcy5lbmFibGVkID09PSBmYWxzZSkgcmV0dXJuO1xuXG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cbiAgICAgIGlmIChfc3RhdGUgPT09IFNUQVRFLlJPVEFURSAmJiAhX3RoaXMubm9Sb3RhdGUpIHtcblxuICAgICAgfSBlbHNlIGlmIChfc3RhdGUgPT09IFNUQVRFLlpPT00gJiYgIV90aGlzLm5vWm9vbSkge1xuICAgICAgICBfem9vbUVuZC5jb3B5KGdldE1vdXNlT25TY3JlZW4oZXZlbnQucGFnZVgsIGV2ZW50LnBhZ2VZKSk7XG4gICAgICB9IGVsc2UgaWYgKF9zdGF0ZSA9PT0gU1RBVEUuUEFOICYmICFfdGhpcy5ub1Bhbikge1xuICAgICAgICBfcGFuRW5kLmNvcHkoZ2V0TW91c2VPblNjcmVlbihldmVudC5wYWdlWCwgZXZlbnQucGFnZVkpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtb3VzZXVwKGV2ZW50KSB7XG4gICAgICBpZiAoX3RoaXMuZW5hYmxlZCA9PT0gZmFsc2UpIHJldHVybjtcblxuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgICBfc3RhdGUgPSBTVEFURS5OT05FO1xuXG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBtb3VzZW1vdmUpO1xuICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIG1vdXNldXApO1xuICAgICAgX3RoaXMuZGlzcGF0Y2hFdmVudChlbmRFdmVudCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbW91c2V3aGVlbChldmVudCkge1xuICAgICAgaWYgKF90aGlzLmVuYWJsZWQgPT09IGZhbHNlKSByZXR1cm47XG5cbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgICAgbGV0IGRlbHRhID0gMDtcblxuICAgICAgaWYgKGV2ZW50LndoZWVsRGVsdGEpIHtcbiAgICAgICAgLy8gV2ViS2l0IC8gT3BlcmEgLyBFeHBsb3JlciA5XG5cbiAgICAgICAgZGVsdGEgPSBldmVudC53aGVlbERlbHRhIC8gNDA7XG4gICAgICB9IGVsc2UgaWYgKGV2ZW50LmRldGFpbCkge1xuICAgICAgICAvLyBGaXJlZm94XG5cbiAgICAgICAgZGVsdGEgPSAtZXZlbnQuZGV0YWlsIC8gMztcbiAgICAgIH1cblxuICAgICAgLy8gRklSRSBTQ1JPTEwgRVZFTlRcblxuICAgICAgX3RoaXMuZGlzcGF0Y2hFdmVudCh7XG4gICAgICAgIHR5cGU6ICdPblNjcm9sbCcsXG4gICAgICAgIGRlbHRhOiBkZWx0YSxcbiAgICAgIH0pO1xuXG4gICAgICAvLyBfem9vbVN0YXJ0LnkgKz0gZGVsdGEgKiAwLjAxO1xuICAgICAgX3RoaXMuZGlzcGF0Y2hFdmVudChzdGFydEV2ZW50KTtcbiAgICAgIF90aGlzLmRpc3BhdGNoRXZlbnQoZW5kRXZlbnQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvdWNoc3RhcnQoZXZlbnQpIHtcbiAgICAgIGlmIChfdGhpcy5lbmFibGVkID09PSBmYWxzZSkgcmV0dXJuO1xuXG4gICAgICBzd2l0Y2ggKGV2ZW50LnRvdWNoZXMubGVuZ3RoKSB7XG5cbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIF9zdGF0ZSA9IFNUQVRFLlRPVUNIX1JPVEFURTtcblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBfc3RhdGUgPSBTVEFURS5UT1VDSF9aT09NX1BBTjtcbiAgICAgICAgICB2YXIgZHggPSBldmVudC50b3VjaGVzWzBdLnBhZ2VYIC0gZXZlbnQudG91Y2hlc1sxXS5wYWdlWDtcbiAgICAgICAgICB2YXIgZHkgPSBldmVudC50b3VjaGVzWzBdLnBhZ2VZIC0gZXZlbnQudG91Y2hlc1sxXS5wYWdlWTtcbiAgICAgICAgICBfdG91Y2hab29tRGlzdGFuY2VFbmQgPSBfdG91Y2hab29tRGlzdGFuY2VTdGFydCA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG5cbiAgICAgICAgICB2YXIgeCA9IChldmVudC50b3VjaGVzWzBdLnBhZ2VYICsgZXZlbnQudG91Y2hlc1sxXS5wYWdlWCkgLyAyO1xuICAgICAgICAgIHZhciB5ID0gKGV2ZW50LnRvdWNoZXNbMF0ucGFnZVkgKyBldmVudC50b3VjaGVzWzFdLnBhZ2VZKSAvIDI7XG4gICAgICAgICAgX3BhblN0YXJ0LmNvcHkoZ2V0TW91c2VPblNjcmVlbih4LCB5KSk7XG4gICAgICAgICAgX3BhbkVuZC5jb3B5KF9wYW5TdGFydCk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBfc3RhdGUgPSBTVEFURS5OT05FO1xuXG4gICAgICB9XG4gICAgICBfdGhpcy5kaXNwYXRjaEV2ZW50KHN0YXJ0RXZlbnQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvdWNobW92ZShldmVudCkge1xuICAgICAgaWYgKF90aGlzLmVuYWJsZWQgPT09IGZhbHNlKSByZXR1cm47XG5cbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgICAgc3dpdGNoIChldmVudC50b3VjaGVzLmxlbmd0aCkge1xuXG4gICAgICAgIGNhc2UgMTpcblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICB2YXIgZHggPSBldmVudC50b3VjaGVzWzBdLnBhZ2VYIC0gZXZlbnQudG91Y2hlc1sxXS5wYWdlWDtcbiAgICAgICAgICB2YXIgZHkgPSBldmVudC50b3VjaGVzWzBdLnBhZ2VZIC0gZXZlbnQudG91Y2hlc1sxXS5wYWdlWTtcbiAgICAgICAgICBfdG91Y2hab29tRGlzdGFuY2VFbmQgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuXG4gICAgICAgICAgdmFyIHggPSAoZXZlbnQudG91Y2hlc1swXS5wYWdlWCArIGV2ZW50LnRvdWNoZXNbMV0ucGFnZVgpIC8gMjtcbiAgICAgICAgICB2YXIgeSA9IChldmVudC50b3VjaGVzWzBdLnBhZ2VZICsgZXZlbnQudG91Y2hlc1sxXS5wYWdlWSkgLyAyO1xuICAgICAgICAgIF9wYW5FbmQuY29weShnZXRNb3VzZU9uU2NyZWVuKHgsIHkpKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIF9zdGF0ZSA9IFNUQVRFLk5PTkU7XG5cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b3VjaGVuZChldmVudCkge1xuICAgICAgaWYgKF90aGlzLmVuYWJsZWQgPT09IGZhbHNlKSByZXR1cm47XG5cbiAgICAgIHN3aXRjaCAoZXZlbnQudG91Y2hlcy5sZW5ndGgpIHtcblxuICAgICAgICBjYXNlIDE6XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgX3RvdWNoWm9vbURpc3RhbmNlU3RhcnQgPSBfdG91Y2hab29tRGlzdGFuY2VFbmQgPSAwO1xuXG4gICAgICAgICAgdmFyIHggPSAoZXZlbnQudG91Y2hlc1swXS5wYWdlWCArIGV2ZW50LnRvdWNoZXNbMV0ucGFnZVgpIC8gMjtcbiAgICAgICAgICB2YXIgeSA9IChldmVudC50b3VjaGVzWzBdLnBhZ2VZICsgZXZlbnQudG91Y2hlc1sxXS5wYWdlWSkgLyAyO1xuICAgICAgICAgIF9wYW5FbmQuY29weShnZXRNb3VzZU9uU2NyZWVuKHgsIHkpKTtcbiAgICAgICAgICBfcGFuU3RhcnQuY29weShfcGFuRW5kKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgfVxuXG4gICAgICBfc3RhdGUgPSBTVEFURS5OT05FO1xuICAgICAgX3RoaXMuZGlzcGF0Y2hFdmVudChlbmRFdmVudCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29udGV4dG1lbnUoZXZlbnQpIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuXG4gICAgdGhpcy5kaXNwb3NlID0gZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmRvbUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignY29udGV4dG1lbnUnLCBjb250ZXh0bWVudSwgZmFsc2UpO1xuICAgICAgdGhpcy5kb21FbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIG1vdXNlZG93biwgZmFsc2UpO1xuICAgICAgdGhpcy5kb21FbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNld2hlZWwnLCBtb3VzZXdoZWVsLCBmYWxzZSk7XG4gICAgICB0aGlzLmRvbUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignTW96TW91c2VQaXhlbFNjcm9sbCcsIG1vdXNld2hlZWwsIGZhbHNlKTsgLy8gZmlyZWZveFxuXG4gICAgICB0aGlzLmRvbUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHRvdWNoc3RhcnQsIGZhbHNlKTtcbiAgICAgIHRoaXMuZG9tRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRvdWNoZW5kLCBmYWxzZSk7XG4gICAgICB0aGlzLmRvbUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdG91Y2htb3ZlLCBmYWxzZSk7XG5cbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIG1vdXNlbW92ZSwgZmFsc2UpO1xuICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIG1vdXNldXAsIGZhbHNlKTtcblxuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBrZXlkb3duLCBmYWxzZSk7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5dXAnLCBrZXl1cCwgZmFsc2UpO1xuICAgIH07XG5cbiAgICB0aGlzLmRvbUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY29udGV4dG1lbnUnLCBjb250ZXh0bWVudSwgZmFsc2UpO1xuICAgIHRoaXMuZG9tRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBtb3VzZWRvd24sIGZhbHNlKTtcbiAgICB0aGlzLmRvbUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V3aGVlbCcsIG1vdXNld2hlZWwsIGZhbHNlKTtcbiAgICB0aGlzLmRvbUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignTW96TW91c2VQaXhlbFNjcm9sbCcsIG1vdXNld2hlZWwsIGZhbHNlKTsgLy8gZmlyZWZveFxuXG4gICAgdGhpcy5kb21FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCB0b3VjaHN0YXJ0LCBmYWxzZSk7XG4gICAgdGhpcy5kb21FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdG91Y2hlbmQsIGZhbHNlKTtcbiAgICB0aGlzLmRvbUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdG91Y2htb3ZlLCBmYWxzZSk7XG5cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGtleWRvd24sIGZhbHNlKTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigna2V5dXAnLCBrZXl1cCwgZmFsc2UpO1xuXG4gICAgdGhpcy5oYW5kbGVSZXNpemUoKTtcblxuICAgIC8vIGZvcmNlIGFuIHVwZGF0ZSBhdCBzdGFydFxuICAgIHRoaXMudXBkYXRlKCk7XG4gIH1cbn1cblxuIiwiLyoqXG4gKiBDb2xvcnMgdXRpbGl0eSBmdW5jdGlvbnNcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ29sb3JzIHtcblxuICAvKipcbiAgICogQ29udmVydCBMQUIgdG8gWFlaXG4gICAqIGh0dHA6Ly93d3cuZWFzeXJnYi5jb20vaW5kZXgucGhwP1g9TUFUSCZIPTA4I3RleHQ4XG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gbFxuICAgKiBAcGFyYW0geyp9IGFcbiAgICogQHBhcmFtIHsqfSBiXG4gICAqXG4gICAqIEByZXR1cm4geyp9XG4gICAqL1xuICBzdGF0aWMgY2llbGFiMlhZWihsLCBhLCBiKSB7XG4gICAgY29uc3QgcmVmWCA9IDk1LjA0NztcbiAgICBjb25zdCByZWZZID0gMTAwLjAwO1xuICAgIGNvbnN0IHJlZlogPSAxMDguODgzO1xuXG4gICAgbGV0IHkgPSAobCArIDE2KSAvIDExNjtcbiAgICBsZXQgeCA9IGEgLyA1MDAgKyB5O1xuICAgIGxldCB6ID0geSAtIGIgLyAyMDA7XG5cbiAgICBpZiAoTWF0aC5wb3coeSwgMykgPiAwLjAwODg1Nikge1xuICAgICAgeSA9IE1hdGgucG93KHksIDMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB5ID0gKHkgLSAxNiAvIDExNikgLyA3Ljc4NztcbiAgICB9XG5cbiAgICBpZiAoTWF0aC5wb3coeCwgMykgPiAwLjAwODg1Nikge1xuICAgICAgeCA9IE1hdGgucG93KHgsIDMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB4ID0gKHggLSAxNiAvIDExNikgLyA3Ljc4NztcbiAgICB9XG5cbiAgICBpZiAoTWF0aC5wb3coeiwgMykgPiAwLjAwODg1Nikge1xuICAgICAgeiA9IE1hdGgucG93KHosIDMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB6ID0gKHogLSAxNiAvIDExNikgLyA3Ljc4NztcbiAgICB9XG5cbiAgICByZXR1cm4gW3JlZlggKiB4LCByZWZZICogeSwgcmVmWiAqIHpdO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnQgWFlaIHRvIFJHQiBzcGFjZVxuICAgKlxuICAgKiBAcGFyYW0geyp9IHhcbiAgICogQHBhcmFtIHsqfSB5XG4gICAqIEBwYXJhbSB7Kn0gelxuICAgKlxuICAgKiBAcmV0dXJuIHsqfVxuICAgKi9cbiAgc3RhdGljIHh5ejJSR0IoeCwgeSwgeikge1xuICAgIHggLz0gMTAwO1xuICAgIHkgLz0gMTAwO1xuICAgIHogLz0gMTAwO1xuICAgIGxldCByID0geCAqIDMuMjQwNiArIHkgKiAtMS41MzcyICsgeiAqIC0wLjQ5ODY7XG4gICAgbGV0IGcgPSB4ICogLTAuOTY4OSArIHkgKiAxLjg3NTggKyB6ICogMC4wNDE1O1xuICAgIGxldCBiID0geCAqIDAuMDU1NyArIHkgKiAtMC4yMDQwICsgeiAqIDEuMDU3MDtcblxuICAgIGlmIChyID4gMC4wMDMxMzA4KSB7XG4gICAgICByID0gMS4wNTUgKiAoTWF0aC5wb3cociwgMSAvIDIuNCkpIC0gMC4wNTU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHIgPSAxMi45MiAqIHI7XG4gICAgfVxuXG4gICAgaWYgKGcgPiAwLjAwMzEzMDgpIHtcbiAgICAgIGcgPSAxLjA1NSAqIChNYXRoLnBvdyhnLCAxIC8gMi40KSkgLSAwLjA1NTtcbiAgICB9IGVsc2Uge1xuICAgICAgZyA9IDEyLjkyICogZztcbiAgICB9XG5cbiAgICBpZiAoYiA+IDAuMDAzMTMwOCkge1xuICAgICAgYiA9IDEuMDU1ICogKE1hdGgucG93KGIsIDEgLyAyLjQpKSAtIDAuMDU1O1xuICAgIH0gZWxzZSB7XG4gICAgICBiID0gMTIuOTIgKiBiO1xuICAgIH1cblxuICAgIHIgPSByICogMjU1O1xuICAgIGcgPSBnICogMjU1O1xuICAgIGIgPSBiICogMjU1O1xuXG4gICAgcmV0dXJuIFtyLCBnLCBiXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0IExBQiB0byBSR0JcbiAgICpcbiAgICogQHBhcmFtIHsqfSBsXG4gICAqIEBwYXJhbSB7Kn0gYVxuICAgKiBAcGFyYW0geyp9IGJcbiAgICpcbiAgICogQHJldHVybiB7Kn1cbiAgICovXG4gIHN0YXRpYyBjaWVsYWIyUkdCKGwgPSA1MCwgYSA9IDAsIGIgPSAwKSB7XG4gICAgaWYgKCEobCA+PSAwICYmIGwgPD0gMTAwKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgbGV0IHh5eiA9IHRoaXMuY2llbGFiMlhZWihsLCBhLCBiKTtcbiAgICByZXR1cm4gdGhpcy54eXoyUkdCKC4uLnh5eik7XG4gIH1cblxufVxuIiwiaW1wb3J0IENvcmVVdGlscyBmcm9tICcuL2NvcmUudXRpbHMnO1xuaW1wb3J0IFZhbGlkYXRvcnMgZnJvbSAnLi9jb3JlLnZhbGlkYXRvcnMnO1xuXG4vKipcbiAqIENvbXB1dGUvdGVzdCBpbnRlcnNlY3Rpb24gYmV0d2VlbiBkaWZmZXJlbnQgb2JqZWN0cy5cbiAqXG4gKiBAbW9kdWxlIGNvcmUvaW50ZXJzZWN0aW9uc1xuICovXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEludGVyc2VjdGlvbnMge1xuXG4vKipcbiAqIENvbXB1dGUgaW50ZXJzZWN0aW9uIGJldHdlZW4gb3JpZW50ZWQgYm91bmRpbmcgYm94IGFuZCBhIHBsYW5lLlxuICpcbiAqIFJldHVybnMgaW50ZXJzZWN0aW9uIGluIHBsYW5lJ3Mgc3BhY2UuXG4gKlxuICogU2hvdWxkIHJldHVybiBhdCBsZWFzdCAzIGludGVyc2VjdGlvbnMuIElmIG5vdCwgdGhlIHBsYW5lIGFuZCB0aGUgYm94IGRvIG5vdFxuICogaW50ZXJzZWN0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBhYWJiIC0gQXhlIEFsaWduZWQgQm91bmRpbmcgQm94IHJlcHJlc2VudGF0aW9uLlxuICogQHBhcmFtIHtUSFJFRS5WZWN0b3IzfSBhYWJiLmhhbGZEaW1lbnNpb25zIC0gSGFsZiBkaW1lbnNpb25zIG9mIHRoZSBib3guXG4gKiBAcGFyYW0ge1RIUkVFLlZlY3RvcjN9IGFhYmIuY2VudGVyIC0gQ2VudGVyIG9mIHRoZSBib3guXG4gKiBAcGFyYW0ge1RIUkVFLk1hdHJpeDR9IGFhYmIudG9BQUJCIC0gVHJhbnNmb3JtIHRvIGdvIGZyb20gcGxhbmUgc3BhY2UgdG8gYm94IHNwYWNlLlxuICogQHBhcmFtIHtPYmplY3R9IHBsYW5lIC0gUGxhbmUgcmVwcmVzZW50YXRpb25cbiAqIEBwYXJhbSB7VEhSRUUuVmVjdG9yM30gcGxhbmUucG9zaXRpb24gLSBwb3NpdGlvbiBvZiBub3JtYWwgd2hpY2ggZGVzY3JpYmVzIHRoZSBwbGFuZS5cbiAqIEBwYXJhbSB7VEhSRUUuVmVjdG9yM30gcGxhbmUuZGlyZWN0aW9uIC0gRGlyZWN0aW9uIG9mIG5vcm1hbCB3aGljaCBkZXNjcmliZXMgdGhlIHBsYW5lLlxuICpcbiAqIEByZXR1cm5zIHtBcnJheTxUSFJFRS5WZWN0b3IzPn0gTGlzdCBvZiBhbGwgaW50ZXJzZWN0aW9ucyBpbiBwbGFuZSdzIHNwYWNlLlxuICogQHJldHVybnMge2Jvb2xlYW59IGZhbHNlIGlzIGludmFsaWQgaW5wdXQgcHJvdmlkZWQuXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vUmV0dXJucyBhcnJheSB3aXRoIGludGVyc2VjdGlvbiBOIGludGVyc2VjdGlvbnNcbiAqIGxldCBhYWJiID0ge1xuICogICBjZW50ZXI6IG5ldyBUSFJFRS5WZWN0b3IzKDE1MCwgMTUwLCAxNTApLFxuICogICBoYWxmRGltZW5zaW9uczogbmV3IFRIUkVFLlZlY3RvcjMoNTAsIDYwLCA3MCksXG4gKiAgIHRvQUFCQjogbmV3IFRIUkVFLk1hdHJpeDQoKVxuICogfVxuICogbGV0IHBsYW5lID0ge1xuICogICBwb3NpdGlvbjogbmV3IFRIUkVFLlZlY3RvcjMoMTEwLCAxMjAsIDEzMCksXG4gKiAgIGRpcmVjdGlvbjogbmV3IFRIUkVFLlZlY3RvcjMoMSwgMCwgMClcbiAqIH1cbiAqXG4gKiBsZXQgaW50ZXJzZWN0aW9ucyA9IENvcmVJbnRlcnNlY3Rpb25zLmFhYmJQbGFuZShhYWJiLCBwbGFuZSk7XG4gKiAvLyBpbnRlcnNlY3Rpb25zID09XG4gKiAvL1sgeyB4IDogMTEwLCB5IDogOTAsICB6IDogODAgfSxcbiAqIC8vICB7IHggOiAxMTAsIHkgOiAyMTAsIHogOiAyMjAgfSxcbiAqIC8vICB7IHggOiAxMTAsIHkgOiAyMTAsIHogOiA4MCB9LFxuICogLy8gIHsgeCA6IDExMCwgeSA6IDkwLCAgeiA6IDIyMCB9IF1cbiAqXG4gKiAvL1JldHVybnMgZW1wdHkgYXJyYXkgd2l0aCAwIGludGVyc2VjdGlvbnNcbiAqIGxldCBhYWJiID0ge1xuICpcbiAqIH1cbiAqIGxldCBwbGFuZSA9IHtcbiAqXG4gKiB9XG4gKlxuICogbGV0IGludGVyc2VjdGlvbnMgPSBWSlMuQ29yZS5WYWxpZGF0b3JzLm1hdHJpeDQobmV3IFRIUkVFLlZlY3RvcjMoKSk7XG4gKlxuICogLy9SZXR1cm5zIGZhbHNlIGlmIGludmFsaWQgaW5wdXQ/XG4gKlxuICovXG4gIHN0YXRpYyBhYWJiUGxhbmUoYWFiYiwgcGxhbmUpIHtcbiAgICAvL1xuICAgIC8vIG9iYiA9IHsgaGFsZkRpbWVuc2lvbnMsIG9yaWVudGF0aW9uLCBjZW50ZXIsIHRvQUFCQiB9XG4gICAgLy8gcGxhbmUgPSB7IHBvc2l0aW9uLCBkaXJlY3Rpb24gfVxuICAgIC8vXG4gICAgLy9cbiAgICAvLyBMT0dJQzpcbiAgICAvL1xuICAgIC8vIFRlc3QgaW50ZXJzZWN0aW9uIG9mIGVhY2ggZWRnZSBvZiB0aGUgT3JpZW50ZWQgQm91bmRpbmcgQm94IHdpdGggdGhlIFBsYW5lXG4gICAgLy9cbiAgICAvLyBBTEwgRURHRVNcbiAgICAvL1xuICAgIC8vICAgICAgListLS0tLS0tK1xuICAgIC8vICAgIC4nIHwgICAgIC4nfFxuICAgIC8vICAgKy0tLSstLS0rJyAgfFxuICAgIC8vICAgfCAgIHwgICB8ICAgfFxuICAgIC8vICAgfCAgLCstLS0rLS0tK1xuICAgIC8vICAgfC4nICAgICB8IC4nXG4gICAgLy8gICArLS0tLS0tLSsnXG4gICAgLy9cbiAgICAvLyBTUEFDRSBPUklFTlRBVElPTlxuICAgIC8vXG4gICAgLy8gICAgICAgK1xuICAgIC8vICAgICBqIHxcbiAgICAvLyAgICAgICB8XG4gICAgLy8gICAgICAgfCAgIGlcbiAgICAvLyAgIGsgICwrLS0tLS0tLStcbiAgICAvLyAgICAuJ1xuICAgIC8vICAgK1xuICAgIC8vXG4gICAgLy9cbiAgICAvLyAxLSBNb3ZlIFBsYW5lIHBvc2l0aW9uIGFuZCBvcmllbnRhdGlvbiBpbiBJSksgc3BhY2VcbiAgICAvLyAyLSBUZXN0IEVkZ2VzLyBJSksgUGxhbmUgaW50ZXJzZWN0aW9uc1xuICAgIC8vIDMtIFJldHVybiBpbnRlcnNlY3Rpb24gRWRnZS8gSUpLIFBsYW5lIGlmIGl0IHRvdWNoZXMgdGhlIE9yaWVudGVkIEJCb3hcblxuICAgIGxldCBpbnRlcnNlY3Rpb25zID0gW107XG5cbiAgICBpZiAoISh0aGlzLnZhbGlkYXRlQWFiYihhYWJiKSAmJlxuICAgICAgIHRoaXMudmFsaWRhdGVQbGFuZShwbGFuZSkpKSB7XG4gICAgICB3aW5kb3cuY29uc29sZS5sb2coJ0ludmFsaWQgYWFiYiBvciBwbGFuZSBwcm92aWRlZC4nKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBpbnZlcnQgc3BhY2UgbWF0cml4XG4gICAgbGV0IGZyb21BQUJCID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcbiAgICBmcm9tQUFCQi5nZXRJbnZlcnNlKGFhYmIudG9BQUJCKTtcblxuICAgIGxldCB0MSA9IHBsYW5lLmRpcmVjdGlvbi5jbG9uZSgpLmFwcGx5TWF0cml4NChhYWJiLnRvQUFCQik7XG4gICAgbGV0IHQwID0gbmV3IFRIUkVFLlZlY3RvcjMoMCwgMCwgMCkuYXBwbHlNYXRyaXg0KGFhYmIudG9BQUJCKTtcblxuICAgIGxldCBwbGFuZUFBQkIgPSB0aGlzLnBvc2RpcihcbiAgICAgIHBsYW5lLnBvc2l0aW9uLmNsb25lKCkuYXBwbHlNYXRyaXg0KGFhYmIudG9BQUJCKSxcbiAgICAgIG5ldyBUSFJFRS5WZWN0b3IzKHQxLnggLSB0MC54LCB0MS55IC0gdDAueSwgdDEueiAtIHQwLnopLm5vcm1hbGl6ZSgpXG4gICAgKTtcblxuICAgIGxldCBiYm94ID0gQ29yZVV0aWxzLmJib3goYWFiYi5jZW50ZXIsIGFhYmIuaGFsZkRpbWVuc2lvbnMpO1xuXG4gICAgbGV0IG9yaWVudGF0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoXG4gICAgICBuZXcgVEhSRUUuVmVjdG9yMygxLCAwLCAwKSxcbiAgICAgIG5ldyBUSFJFRS5WZWN0b3IzKDAsIDEsIDApLFxuICAgICAgbmV3IFRIUkVFLlZlY3RvcjMoMCwgMCwgMSkpO1xuXG4gICAgLy8gMTIgZWRnZXMgKGkuZS4gcmF5KS9wbGFuZSBpbnRlcnNlY3Rpb24gdGVzdHNcbiAgICAvLyBSQVlTIFNUQVJUSU5HIEZST00gVEhFIEZJUlNUIENPUk5FUiAoMCwgMCwgMClcbiAgICAvL1xuICAgIC8vICAgICAgICtcbiAgICAvLyAgICAgICB8XG4gICAgLy8gICAgICAgfFxuICAgIC8vICAgICAgIHxcbiAgICAvLyAgICAgICwrLS0tKy0tLStcbiAgICAvLyAgICAuJ1xuICAgIC8vICAgK1xuXG4gICAgbGV0IHJheSA9IHRoaXMucG9zZGlyKFxuICAgICAgbmV3IFRIUkVFLlZlY3RvcjMoXG4gICAgICAgIGFhYmIuY2VudGVyLnggLSBhYWJiLmhhbGZEaW1lbnNpb25zLngsXG4gICAgICAgIGFhYmIuY2VudGVyLnkgLSBhYWJiLmhhbGZEaW1lbnNpb25zLnksXG4gICAgICAgIGFhYmIuY2VudGVyLnogLSBhYWJiLmhhbGZEaW1lbnNpb25zLnopLFxuICAgICAgb3JpZW50YXRpb24ueFxuICAgICk7XG4gICAgdGhpcy5yYXlQbGFuZUluQkJveChyYXksIHBsYW5lQUFCQiwgYmJveCwgaW50ZXJzZWN0aW9ucyk7XG5cbiAgICByYXkuZGlyZWN0aW9uID0gb3JpZW50YXRpb24ueTtcbiAgICB0aGlzLnJheVBsYW5lSW5CQm94KHJheSwgcGxhbmVBQUJCLCBiYm94LCBpbnRlcnNlY3Rpb25zKTtcblxuICAgIHJheS5kaXJlY3Rpb24gPSBvcmllbnRhdGlvbi56O1xuICAgIHRoaXMucmF5UGxhbmVJbkJCb3gocmF5LCBwbGFuZUFBQkIsIGJib3gsIGludGVyc2VjdGlvbnMpO1xuXG4gICAgLy8gUkFZUyBTVEFSVElORyBGUk9NIFRIRSBMQVNUIENPUk5FUlxuICAgIC8vXG4gICAgLy8gICAgICAgICAgICAgICArXG4gICAgLy8gICAgICAgICAgICAgLidcbiAgICAvLyAgICstLS0tLS0tKydcbiAgICAvLyAgICAgICAgICAgfFxuICAgIC8vICAgICAgICAgICB8XG4gICAgLy8gICAgICAgICAgIHxcbiAgICAvLyAgICAgICAgICAgK1xuICAgIC8vXG5cbiAgICBsZXQgcmF5MiA9IHRoaXMucG9zZGlyKFxuICAgICAgbmV3IFRIUkVFLlZlY3RvcjMoXG4gICAgICAgIGFhYmIuY2VudGVyLnggKyBhYWJiLmhhbGZEaW1lbnNpb25zLngsXG4gICAgICAgIGFhYmIuY2VudGVyLnkgKyBhYWJiLmhhbGZEaW1lbnNpb25zLnksXG4gICAgICAgIGFhYmIuY2VudGVyLnogKyBhYWJiLmhhbGZEaW1lbnNpb25zLnopLFxuICAgICAgb3JpZW50YXRpb24ueFxuICAgICk7XG4gICAgdGhpcy5yYXlQbGFuZUluQkJveChyYXkyLCBwbGFuZUFBQkIsIGJib3gsIGludGVyc2VjdGlvbnMpO1xuXG4gICAgcmF5Mi5kaXJlY3Rpb24gPSBvcmllbnRhdGlvbi55O1xuICAgIHRoaXMucmF5UGxhbmVJbkJCb3gocmF5MiwgcGxhbmVBQUJCLCBiYm94LCBpbnRlcnNlY3Rpb25zKTtcblxuICAgIHJheTIuZGlyZWN0aW9uID0gb3JpZW50YXRpb24uejtcbiAgICB0aGlzLnJheVBsYW5lSW5CQm94KHJheTIsIHBsYW5lQUFCQiwgYmJveCwgaW50ZXJzZWN0aW9ucyk7XG5cbiAgICAvLyBSQVlTIFNUQVJUSU5HIEZST00gVEhFIFNFQ09ORCBDT1JORVJcbiAgICAvL1xuICAgIC8vICAgICAgICAgICAgICAgK1xuICAgIC8vICAgICAgICAgICAgICAgfFxuICAgIC8vICAgICAgICAgICAgICAgfFxuICAgIC8vICAgICAgICAgICAgICAgfFxuICAgIC8vICAgICAgICAgICAgICAgK1xuICAgIC8vICAgICAgICAgICAgIC4nXG4gICAgLy8gICAgICAgICAgICsnXG5cbiAgICBsZXQgcmF5MyA9IHRoaXMucG9zZGlyKFxuICAgICAgbmV3IFRIUkVFLlZlY3RvcjMoXG4gICAgICAgIGFhYmIuY2VudGVyLnggKyBhYWJiLmhhbGZEaW1lbnNpb25zLngsXG4gICAgICAgIGFhYmIuY2VudGVyLnkgLSBhYWJiLmhhbGZEaW1lbnNpb25zLnksXG4gICAgICAgIGFhYmIuY2VudGVyLnogLSBhYWJiLmhhbGZEaW1lbnNpb25zLnopLFxuICAgICAgb3JpZW50YXRpb24ueVxuICAgICk7XG4gICAgdGhpcy5yYXlQbGFuZUluQkJveChyYXkzLCBwbGFuZUFBQkIsIGJib3gsIGludGVyc2VjdGlvbnMpO1xuXG4gICAgcmF5My5kaXJlY3Rpb24gPSBvcmllbnRhdGlvbi56O1xuICAgIHRoaXMucmF5UGxhbmVJbkJCb3gocmF5MywgcGxhbmVBQUJCLCBiYm94LCBpbnRlcnNlY3Rpb25zKTtcblxuICAgIC8vIFJBWVMgU1RBUlRJTkcgRlJPTSBUSEUgVEhJUkQgQ09STkVSXG4gICAgLy9cbiAgICAvLyAgICAgIC4rLS0tLS0tLStcbiAgICAvLyAgICAuJ1xuICAgIC8vICAgK1xuICAgIC8vXG4gICAgLy9cbiAgICAvL1xuICAgIC8vXG5cbiAgICBsZXQgcmF5NCA9IHRoaXMucG9zZGlyKFxuICAgICAgbmV3IFRIUkVFLlZlY3RvcjMoXG4gICAgICAgIGFhYmIuY2VudGVyLnggLSBhYWJiLmhhbGZEaW1lbnNpb25zLngsXG4gICAgICAgIGFhYmIuY2VudGVyLnkgKyBhYWJiLmhhbGZEaW1lbnNpb25zLnksXG4gICAgICAgIGFhYmIuY2VudGVyLnogLSBhYWJiLmhhbGZEaW1lbnNpb25zLnopLFxuICAgICAgb3JpZW50YXRpb24ueFxuICAgICk7XG4gICAgdGhpcy5yYXlQbGFuZUluQkJveChyYXk0LCBwbGFuZUFBQkIsIGJib3gsIGludGVyc2VjdGlvbnMpO1xuXG4gICAgcmF5NC5kaXJlY3Rpb24gPSBvcmllbnRhdGlvbi56O1xuICAgIHRoaXMucmF5UGxhbmVJbkJCb3gocmF5NCwgcGxhbmVBQUJCLCBiYm94LCBpbnRlcnNlY3Rpb25zKTtcblxuICAgIC8vIFJBWVMgU1RBUlRJTkcgRlJPTSBUSEUgRk9VUlRIIENPUk5FUlxuICAgIC8vXG4gICAgLy9cbiAgICAvL1xuICAgIC8vICAgK1xuICAgIC8vICAgfFxuICAgIC8vICAgfFxuICAgIC8vICAgfFxuICAgIC8vICAgKy0tLS0tLS0rXG5cbiAgICBsZXQgcmF5NSA9IHRoaXMucG9zZGlyKFxuICAgICAgbmV3IFRIUkVFLlZlY3RvcjMoXG4gICAgICAgIGFhYmIuY2VudGVyLnggLSBhYWJiLmhhbGZEaW1lbnNpb25zLngsXG4gICAgICAgIGFhYmIuY2VudGVyLnkgLSBhYWJiLmhhbGZEaW1lbnNpb25zLnksXG4gICAgICAgIGFhYmIuY2VudGVyLnogKyBhYWJiLmhhbGZEaW1lbnNpb25zLnopLFxuICAgICAgb3JpZW50YXRpb24ueFxuICAgICk7XG4gICAgdGhpcy5yYXlQbGFuZUluQkJveChyYXk1LCBwbGFuZUFBQkIsIGJib3gsIGludGVyc2VjdGlvbnMpO1xuXG4gICAgcmF5NS5kaXJlY3Rpb24gPSBvcmllbnRhdGlvbi55O1xuICAgIHRoaXMucmF5UGxhbmVJbkJCb3gocmF5NSwgcGxhbmVBQUJCLCBiYm94LCBpbnRlcnNlY3Rpb25zKTtcblxuICAgIC8vIEB0b2RvIG1ha2Ugc3VyZSBvYmplY3RzIGFyZSB1bmlxdWUuLi5cblxuICAgIC8vIGJhY2sgdG8gb3JpZ2luYWwgc3BhY2VcbiAgICBpbnRlcnNlY3Rpb25zLm1hcChcbiAgICAgIGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIGVsZW1lbnQuYXBwbHlNYXRyaXg0KGZyb21BQUJCKTtcbiAgICAgIH1cbiAgICApO1xuXG4gICAgcmV0dXJuIGludGVyc2VjdGlvbnM7XG4gIH1cblxuLyoqXG4gKiBDb21wdXRlIGludGVyc2VjdGlvbiBiZXR3ZWVuIGEgcmF5IGFuZCBhIHBsYW5lLlxuICpcbiAqIEBtZW1iZXJPZiB0aGlzXG4gKiBAcHVibGljXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHJheSAtIFJheSByZXByZXNlbnRhdGlvbi5cbiAqIEBwYXJhbSB7VEhSRUUuVmVjdG9yM30gcmF5LnBvc2l0aW9uIC0gcG9zaXRpb24gb2Ygbm9ybWFsIHdoaWNoIGRlc2NyaWJlcyB0aGUgcmF5LlxuICogQHBhcmFtIHtUSFJFRS5WZWN0b3IzfSByYXkuZGlyZWN0aW9uIC0gRGlyZWN0aW9uIG9mIG5vcm1hbCB3aGljaCBkZXNjcmliZXMgdGhlIHJheS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBwbGFuZSAtIFBsYW5lIHJlcHJlc2VudGF0aW9uXG4gKiBAcGFyYW0ge1RIUkVFLlZlY3RvcjN9IHBsYW5lLnBvc2l0aW9uIC0gcG9zaXRpb24gb2Ygbm9ybWFsIHdoaWNoIGRlc2NyaWJlcyB0aGUgcGxhbmUuXG4gKiBAcGFyYW0ge1RIUkVFLlZlY3RvcjN9IHBsYW5lLmRpcmVjdGlvbiAtIERpcmVjdGlvbiBvZiBub3JtYWwgd2hpY2ggZGVzY3JpYmVzIHRoZSBwbGFuZS5cbiAqXG4gKiBAcmV0dXJucyB7VEhSRUUuVmVjdG9yM3xudWxsfSBJbnRlcnNlY3Rpb24gYmV0d2VlbiByYXkgYW5kIHBsYW5lIG9yIG51bGwuXG4gKi9cbiAgc3RhdGljIHJheVBsYW5lKHJheSwgcGxhbmUpIHtcbiAgLy8gcmF5OiB7cG9zaXRpb24sIGRpcmVjdGlvbn1cbiAgLy8gcGxhbmU6IHtwb3NpdGlvbiwgZGlyZWN0aW9ufVxuXG4gIGlmIChyYXkuZGlyZWN0aW9uLmRvdChwbGFuZS5kaXJlY3Rpb24pICE9PSAwKSB7XG4gICAgLy9cbiAgICAvLyBub3QgcGFyYWxsZWwsIG1vdmUgZm9yd2FyZFxuICAgIC8vXG4gICAgLy8gTE9HSUM6XG4gICAgLy9cbiAgICAvLyBSYXkgZXF1YXRpb246IFAgPSBQMCArIHRWXG4gICAgLy8gUCA9IDxQeCwgUHksIFB6PlxuICAgIC8vIFAwID0gPHJheS5wb3NpdGlvbi54LCByYXkucG9zaXRpb24ueSwgcmF5LnBvc2l0aW9uLno+XG4gICAgLy8gViA9IDxyYXkuZGlyZWN0aW9uLngsIHJheS5kaXJlY3Rpb24ueSwgcmF5LmRpcmVjdGlvbi56PlxuICAgIC8vXG4gICAgLy8gVGhlcmVmb3JlOlxuICAgIC8vIFB4ID0gcmF5LnBvc2l0aW9uLnggKyB0KnJheS5kaXJlY3Rpb24ueFxuICAgIC8vIFB5ID0gcmF5LnBvc2l0aW9uLnkgKyB0KnJheS5kaXJlY3Rpb24ueVxuICAgIC8vIFB6ID0gcmF5LnBvc2l0aW9uLnogKyB0KnJheS5kaXJlY3Rpb24uelxuICAgIC8vXG4gICAgLy9cbiAgICAvL1xuICAgIC8vIFBsYW5lIGVxdWF0aW9uOiBheCArIGJ5ICsgY3ogKyBkID0gMFxuICAgIC8vIGEgPSBwbGFuZS5kaXJlY3Rpb24ueFxuICAgIC8vIGIgPSBwbGFuZS5kaXJlY3Rpb24ueVxuICAgIC8vIGMgPSBwbGFuZS5kaXJlY3Rpb24uelxuICAgIC8vIGQgPSAtKCBwbGFuZS5kaXJlY3Rpb24ueCpwbGFuZS5wb3NpdGlvbi54ICtcbiAgICAvLyAgICAgICAgcGxhbmUuZGlyZWN0aW9uLnkqcGxhbmUucG9zaXRpb24ueSArXG4gICAgLy8gICAgICAgIHBsYW5lLmRpcmVjdGlvbi56KnBsYW5lLnBvc2l0aW9uLnogKVxuICAgIC8vXG4gICAgLy9cbiAgICAvLyAxLSBpbiB0aGUgcGxhbmUgZXF1YXRpb24sIHdlIHJlcGxhY2UgeCwgeSBhbmQgeiBieSBQeCwgUHkgYW5kIFB6XG4gICAgLy8gMi0gZmluZCB0XG4gICAgLy8gMy0gcmVwbGFjZSB0IGluIFB4LCBQeSBhbmQgUHogdG8gZ2V0IHRoZSBjb29yZGluYXRlIG9mIHRoZSBpbnRlcnNlY3Rpb25cbiAgICAvL1xuICAgIGxldCB0ID0gKHBsYW5lLmRpcmVjdGlvbi54ICogKHBsYW5lLnBvc2l0aW9uLnggLSByYXkucG9zaXRpb24ueCkgKyBwbGFuZS5kaXJlY3Rpb24ueSAqIChwbGFuZS5wb3NpdGlvbi55IC0gcmF5LnBvc2l0aW9uLnkpICsgcGxhbmUuZGlyZWN0aW9uLnogKiAocGxhbmUucG9zaXRpb24ueiAtIHJheS5wb3NpdGlvbi56KSkgL1xuICAgICAgICAocGxhbmUuZGlyZWN0aW9uLnggKiByYXkuZGlyZWN0aW9uLnggKyBwbGFuZS5kaXJlY3Rpb24ueSAqIHJheS5kaXJlY3Rpb24ueSArIHBsYW5lLmRpcmVjdGlvbi56ICogcmF5LmRpcmVjdGlvbi56KTtcblxuICAgIGxldCBpbnRlcnNlY3Rpb24gPSBuZXcgVEhSRUUuVmVjdG9yMyhcbiAgICAgICAgcmF5LnBvc2l0aW9uLnggKyB0ICogcmF5LmRpcmVjdGlvbi54LFxuICAgICAgICByYXkucG9zaXRpb24ueSArIHQgKiByYXkuZGlyZWN0aW9uLnksXG4gICAgICAgIHJheS5wb3NpdGlvbi56ICsgdCAqIHJheS5kaXJlY3Rpb24ueik7XG5cbiAgICByZXR1cm4gaW50ZXJzZWN0aW9uO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbiAgLyoqXG4gICAqIENvbXB1dGUgaW50ZXJzZWN0aW9uIGJldHdlZW4gYSByYXkgYW5kIGEgYm94XG4gICAqIEBwYXJhbSB7T2JqZWN0fSByYXlcbiAgICogQHBhcmFtIHtPYmplY3R9IGJveFxuICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICovXG4gIHN0YXRpYyByYXlCb3gocmF5LCBib3gpIHtcbiAgICAvLyBzaG91bGQgYWxzbyBkbyB0aGUgc3BhY2UgdHJhbnNmb3JtcyBoZXJlXG4gICAgLy8gcmF5OiB7cG9zaXRpb24sIGRpcmVjdGlvbn1cbiAgICAvLyBib3g6IHtoYWxmRGltZW5zaW9ucywgY2VudGVyfVxuXG4gICAgbGV0IGludGVyc2VjdGlvbnMgPSBbXTtcblxuICAgIGxldCBiYm94ID0gQ29yZVV0aWxzLmJib3goYm94LmNlbnRlciwgYm94LmhhbGZEaW1lbnNpb25zKTtcblxuICAgIC8vIHdpbmRvdy5jb25zb2xlLmxvZyhiYm94KTtcblxuICAgIC8vIFggbWluXG4gICAgbGV0IHBsYW5lID0gdGhpcy5wb3NkaXIoXG4gICAgICBuZXcgVEhSRUUuVmVjdG9yMyhcbiAgICAgICAgYmJveC5taW4ueCxcbiAgICAgICAgYm94LmNlbnRlci55LFxuICAgICAgICBib3guY2VudGVyLnopLFxuICAgICAgbmV3IFRIUkVFLlZlY3RvcjMoLTEsIDAsIDApXG4gICAgKTtcbiAgICB0aGlzLnJheVBsYW5lSW5CQm94KHJheSwgcGxhbmUsIGJib3gsIGludGVyc2VjdGlvbnMpO1xuXG4gICAgLy8gWCBtYXhcbiAgICBwbGFuZSA9IHRoaXMucG9zZGlyKFxuICAgICAgbmV3IFRIUkVFLlZlY3RvcjMoXG4gICAgICAgIGJib3gubWF4LngsXG4gICAgICAgIGJveC5jZW50ZXIueSxcbiAgICAgICAgYm94LmNlbnRlci56KSxcbiAgICAgIG5ldyBUSFJFRS5WZWN0b3IzKDEsIDAsIDApXG4gICAgKTtcbiAgICB0aGlzLnJheVBsYW5lSW5CQm94KHJheSwgcGxhbmUsIGJib3gsIGludGVyc2VjdGlvbnMpO1xuXG4gICAgLy8gWSBtaW5cbiAgICBwbGFuZSA9IHRoaXMucG9zZGlyKFxuICAgICAgbmV3IFRIUkVFLlZlY3RvcjMoXG4gICAgICAgIGJveC5jZW50ZXIueCxcbiAgICAgICAgYmJveC5taW4ueSxcbiAgICAgICAgYm94LmNlbnRlci56KSxcbiAgICAgIG5ldyBUSFJFRS5WZWN0b3IzKDAsIC0xLCAwKVxuICAgICk7XG4gICAgdGhpcy5yYXlQbGFuZUluQkJveChyYXksIHBsYW5lLCBiYm94LCBpbnRlcnNlY3Rpb25zKTtcblxuICAgIC8vIFkgbWF4XG4gICAgcGxhbmUgPSB0aGlzLnBvc2RpcihcbiAgICAgIG5ldyBUSFJFRS5WZWN0b3IzKFxuICAgICAgICBib3guY2VudGVyLngsXG4gICAgICAgIGJib3gubWF4LnksXG4gICAgICAgIGJveC5jZW50ZXIueiksXG4gICAgICBuZXcgVEhSRUUuVmVjdG9yMygwLCAxLCAwKVxuICAgICk7XG4gICAgdGhpcy5yYXlQbGFuZUluQkJveChyYXksIHBsYW5lLCBiYm94LCBpbnRlcnNlY3Rpb25zKTtcblxuICAgIC8vIFogbWluXG4gICAgcGxhbmUgPSB0aGlzLnBvc2RpcihcbiAgICAgIG5ldyBUSFJFRS5WZWN0b3IzKFxuICAgICAgICBib3guY2VudGVyLngsXG4gICAgICAgIGJveC5jZW50ZXIueSxcbiAgICAgICAgYmJveC5taW4ueiksXG4gICAgICBuZXcgVEhSRUUuVmVjdG9yMygwLCAwLCAtMSlcbiAgICApO1xuICAgIHRoaXMucmF5UGxhbmVJbkJCb3gocmF5LCBwbGFuZSwgYmJveCwgaW50ZXJzZWN0aW9ucyk7XG5cbiAgICAvLyBaIG1heFxuICAgIHBsYW5lID0gdGhpcy5wb3NkaXIoXG4gICAgICBuZXcgVEhSRUUuVmVjdG9yMyhcbiAgICAgICAgYm94LmNlbnRlci54LFxuICAgICAgICBib3guY2VudGVyLnksXG4gICAgICAgIGJib3gubWF4LnopLFxuICAgICAgbmV3IFRIUkVFLlZlY3RvcjMoMCwgMCwgMSlcbiAgICApO1xuICAgIHRoaXMucmF5UGxhbmVJbkJCb3gocmF5LCBwbGFuZSwgYmJveCwgaW50ZXJzZWN0aW9ucyk7XG5cbiAgICByZXR1cm4gaW50ZXJzZWN0aW9ucztcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnRlcnNlY3Rpb24gYmV0d2VlbiByYXkgYW5kIGEgcGxhbmUgdGhhdCBhcmUgaW4gYSBib3guXG4gICAqIEBwYXJhbSB7Kn0gcmF5XG4gICAqIEBwYXJhbSB7Kn0gcGxhbmVBQUJCXG4gICAqIEBwYXJhbSB7Kn0gYmJveFxuICAgKiBAcGFyYW0geyp9IGludGVyc2VjdGlvbnNcbiAgICovXG4gIHN0YXRpYyByYXlQbGFuZUluQkJveChyYXksIHBsYW5lQUFCQiwgYmJveCwgaW50ZXJzZWN0aW9ucykge1xuICAgIGxldCBpbnRlcnNlY3Rpb24gPSB0aGlzLnJheVBsYW5lKHJheSwgcGxhbmVBQUJCKTtcbiAgICAvLyB3aW5kb3cuY29uc29sZS5sb2coaW50ZXJzZWN0aW9uKTtcbiAgICBpZiAoaW50ZXJzZWN0aW9uICYmIHRoaXMuaW5CQm94KGludGVyc2VjdGlvbiwgYmJveCkpIHtcbiAgICAgIGlmICghaW50ZXJzZWN0aW9ucy5maW5kKHRoaXMuZmluZEludGVyc2VjdGlvbihpbnRlcnNlY3Rpb24pKSkge1xuICAgICAgICBpbnRlcnNlY3Rpb25zLnB1c2goaW50ZXJzZWN0aW9uKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRmluZCBpbnRlcnNlY3Rpb24gaW4gYXJyYXlcbiAgICogQHBhcmFtIHsqfSBteWludGVyc2VjdGlvblxuICAgKi9cbiAgc3RhdGljIGZpbmRJbnRlcnNlY3Rpb24obXlpbnRlcnNlY3Rpb24pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gZm91bmQoZWxlbWVudCwgaW5kZXgsIGFycmF5KSB7XG4gICAgICBpZiAobXlpbnRlcnNlY3Rpb24ueCA9PT0gZWxlbWVudC54ICYmXG4gICAgICAgIG15aW50ZXJzZWN0aW9uLnkgPT09IGVsZW1lbnQueSAmJlxuICAgICAgICBteWludGVyc2VjdGlvbi56ID09PSBlbGVtZW50LnopIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIElzIHBvaW50IGluIGJveC5cbiAgICogQHBhcmFtIHtPYmplY3R9IHBvaW50XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBiYm94XG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBzdGF0aWMgaW5CQm94KHBvaW50LCBiYm94KSB7XG4gICAgLy9cbiAgICBsZXQgZXBzaWxvbiA9IDAuMDAwMTtcbiAgICBpZiAocG9pbnQgJiZcbiAgICAgICAgcG9pbnQueCA+PSBiYm94Lm1pbi54IC0gZXBzaWxvbiAmJlxuICAgICAgICBwb2ludC55ID49IGJib3gubWluLnkgLSBlcHNpbG9uICYmXG4gICAgICAgIHBvaW50LnogPj0gYmJveC5taW4ueiAtIGVwc2lsb24gJiZcbiAgICAgICAgcG9pbnQueCA8PSBiYm94Lm1heC54ICsgZXBzaWxvbiAmJlxuICAgICAgICBwb2ludC55IDw9IGJib3gubWF4LnkgKyBlcHNpbG9uICYmXG4gICAgICAgIHBvaW50LnogPD0gYmJveC5tYXgueiArIGVwc2lsb24pIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBzdGF0aWMgcG9zZGlyKHBvc2l0aW9uLCBkaXJlY3Rpb24pIHtcbiAgICByZXR1cm4ge3Bvc2l0aW9uLCBkaXJlY3Rpb259O1xuICB9XG5cbiAgc3RhdGljIHZhbGlkYXRlUGxhbmUocGxhbmUpIHtcbiAgICAvL1xuICAgIGlmIChwbGFuZSA9PT0gbnVsbCkge1xuICAgICAgd2luZG93LmNvbnNvbGUubG9nKCdJbnZhbGlkIHBsYW5lLicpO1xuICAgICAgd2luZG93LmNvbnNvbGUubG9nKHBsYW5lKTtcblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmICghVmFsaWRhdG9ycy52ZWN0b3IzKHBsYW5lLnBvc2l0aW9uKSkge1xuICAgICAgd2luZG93LmNvbnNvbGUubG9nKCdJbnZhbGlkIHBsYW5lLnBvc2l0aW9uLicpO1xuICAgICAgd2luZG93LmNvbnNvbGUubG9nKHBsYW5lLnBvc2l0aW9uKTtcblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmICghVmFsaWRhdG9ycy52ZWN0b3IzKHBsYW5lLmRpcmVjdGlvbikpIHtcbiAgICAgIHdpbmRvdy5jb25zb2xlLmxvZygnSW52YWxpZCBwbGFuZS5kaXJlY3Rpb24uJyk7XG4gICAgICB3aW5kb3cuY29uc29sZS5sb2cocGxhbmUuZGlyZWN0aW9uKTtcblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgc3RhdGljIHZhbGlkYXRlQWFiYihhYWJiKSB7XG4gICAgLy9cbiAgICBpZiAoYWFiYiA9PT0gbnVsbCkge1xuICAgICAgd2luZG93LmNvbnNvbGUubG9nKCdJbnZhbGlkIGFhYmIuJyk7XG4gICAgICB3aW5kb3cuY29uc29sZS5sb2coYWFiYik7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKCFWYWxpZGF0b3JzLm1hdHJpeDQoYWFiYi50b0FBQkIpKSB7XG4gICAgICB3aW5kb3cuY29uc29sZS5sb2coJ0ludmFsaWQgYWFiYi50b0FBQkI6ICcpO1xuICAgICAgd2luZG93LmNvbnNvbGUubG9nKGFhYmIudG9BQUJCKTtcblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmICghVmFsaWRhdG9ycy52ZWN0b3IzKGFhYmIuY2VudGVyKSkge1xuICAgICAgd2luZG93LmNvbnNvbGUubG9nKCdJbnZhbGlkIGFhYmIuY2VudGVyLicpO1xuICAgICAgd2luZG93LmNvbnNvbGUubG9nKGFhYmIuY2VudGVyKTtcblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmICghKFZhbGlkYXRvcnMudmVjdG9yMyhhYWJiLmhhbGZEaW1lbnNpb25zKSAmJlxuICAgICAgIGFhYmIuaGFsZkRpbWVuc2lvbnMueCA+PSAwICYmXG4gICAgICAgYWFiYi5oYWxmRGltZW5zaW9ucy55ID49IDAgJiZcbiAgICAgICBhYWJiLmhhbGZEaW1lbnNpb25zLnogPj0gMCkpIHtcbiAgICAgIHdpbmRvdy5jb25zb2xlLmxvZygnSW52YWxpZCBhYWJiLmhhbGZEaW1lbnNpb25zLicpO1xuICAgICAgd2luZG93LmNvbnNvbGUubG9nKGFhYmIuaGFsZkRpbWVuc2lvbnMpO1xuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxufVxuIiwiaW1wb3J0IENvbG9ycyBmcm9tICcuL2NvcmUuY29sb3JzJztcbmltcG9ydCBJbnRlcnNlY3Rpb25zIGZyb20gJy4vY29yZS5pbnRlcnNlY3Rpb25zJztcbmltcG9ydCBQYWNrIGZyb20gJy4vY29yZS5wYWNrJztcbmltcG9ydCBWYWxpZGF0b3JzIGZyb20gJy4vY29yZS52YWxpZGF0b3JzJztcbmltcG9ydCBVdGlscyBmcm9tICcuL2NvcmUudXRpbHMnO1xuXG4vKipcbiAqIEBtb2R1bGUgY29yZVxuICovXG5leHBvcnQgZGVmYXVsdCB7XG4gIENvbG9ycyxcbiAgSW50ZXJzZWN0aW9ucyxcbiAgVXRpbHMsXG4gIFZhbGlkYXRvcnMsXG59O1xuIiwiLyoqXG4gKiBQYWNraW5nIGZ1bmN0aW9ucy5cbiAqXG4gKiBAbW9kdWxlIGNvcmUvcGFjayAqL1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQYWNrIHtcblxuICAvKipcbiAgICpcbiAgICovXG4gIC8vIHN0YXRpYyBwYWNrVG84Qml0c1RleHR1cmUoYml0cywgY2hhbm5lbHMsIGZyYW1lLCB0ZXh0dXJlU2l6ZSwgc3RhcnRWb3hlbCwgc3RvcFZveGVsKSB7XG4gIC8vICAgbGV0IHBhY2tlZCA9IHtcbiAgLy8gICAgIHRleHR1cmVUeXBlOiBudWxsLFxuICAvLyAgICAgZGF0YTogbnVsbFxuICAvLyAgIH07XG5cbiAgLy8gICBsZXQgcGFja0luZGV4ID0gMDtcbiAgLy8gICBsZXQgZnJhbWVJbmRleCA9IDA7XG4gIC8vICAgbGV0IGluRnJhbWVJbmRleCA9IDA7XG4gIC8vICAgbGV0IGZyYW1lRGltZW5zaW9uID0gZnJhbWVbMF0ucm93cyAqIGZyYW1lWzBdLmNvbHVtbnM7XG4gIC8vICAgbGV0IGRhdGEgPSBudWxsO1xuXG4gIC8vICAgaWYgKGJpdHMgPT09IDggJiYgY2hhbm5lbHMgPT09IDEpIHtcbiAgLy8gICAgIGxldCBkYXRhID0gbmV3IFVpbnQ4QXJyYXkodGV4dHVyZVNpemUgKiB0ZXh0dXJlU2l6ZSAqIDEpO1xuICAvLyAgICAgZm9yIChsZXQgaSA9IHN0YXJ0Vm94ZWw7IGkgPCBzdG9wVm94ZWw7IGkrKykge1xuICAvLyAgICAgICAvKmpzaGludCBiaXR3aXNlOiBmYWxzZSovXG4gIC8vICAgICAgIGZyYW1lSW5kZXggPSB+fihpIC8gZnJhbWVEaW1lbnNpb24pO1xuICAvLyAgICAgICBpbkZyYW1lSW5kZXggPSBpICUgKGZyYW1lRGltZW5zaW9uKTtcbiAgLy8gICAgICAgLypqc2hpbnQgYml0d2lzZTogdHJ1ZSovXG5cbiAgLy8gICAgICAgZGF0YVtwYWNrSW5kZXhdID0gZnJhbWVbZnJhbWVJbmRleF0ucGl4ZWxEYXRhW2luRnJhbWVJbmRleF07XG4gIC8vICAgICAgIHBhY2tJbmRleCsrO1xuXG4gIC8vICAgICB9XG4gIC8vICAgICBwYWNrZWQudGV4dHVyZVR5cGUgPSBUSFJFRS5SR0JGb3JtYXQ7XG4gIC8vICAgICBwYWNrZWQuZGF0YSA9IGRhdGE7XG4gIC8vICAgfSBlbHNlIGlmIChiaXRzID09PSAxNiAmJiBjaGFubmVscyA9PT0gMSkge1xuICAvLyAgICAgbGV0IGRhdGEgPSBuZXcgVWludDhBcnJheSh0ZXh0dXJlU2l6ZSAqIHRleHR1cmVTaXplICogMik7XG4gIC8vICAgICBmb3IgKGxldCBpID0gc3RhcnRWb3hlbDsgaSA8IHN0b3BWb3hlbDsgaSsrKSB7XG4gIC8vICAgICAgIC8qanNoaW50IGJpdHdpc2U6IGZhbHNlKi9cbiAgLy8gICAgICAgZnJhbWVJbmRleCA9IH5+KGkgLyBmcmFtZURpbWVuc2lvbik7XG4gIC8vICAgICAgIGluRnJhbWVJbmRleCA9IGkgJSAoZnJhbWVEaW1lbnNpb24pO1xuICAvLyAgICAgICAvKmpzaGludCBiaXR3aXNlOiB0cnVlKi9cblxuICAvLyAgICAgICAvLyBzbG93IVxuICAvLyAgICAgICAvL2xldCBhc2IgPSBWSlMuY29yZS5wYWNrLnVpbnQxNlRvQWxwaGFMdW1pbmFuY2UoZnJhbWVbZnJhbWVJbmRleF0ucGl4ZWxEYXRhW2luRnJhbWVJbmRleF0pO1xuICAvLyAgICAgICBsZXQgcmF3ID0gZnJhbWVbZnJhbWVJbmRleF0ucGl4ZWxEYXRhW2luRnJhbWVJbmRleF07XG5cbiAgLy8gICAgICAgLypqc2hpbnQgYml0d2lzZTogZmFsc2UqL1xuICAvLyAgICAgICBsZXQgbHNiID0gcmF3ICYgMHgwMEZGO1xuICAvLyAgICAgICBsZXQgbXNiID0gKHJhdyA+Pj4gOCkgJiAweDAwRkY7XG4gIC8vICAgICAgIC8qanNoaW50IGJpdHdpc2U6IHRydWUqL1xuICAvLyAgICAgICBkYXRhWzIgKiBwYWNrSW5kZXhdID0gbHNiO1xuICAvLyAgICAgICBkYXRhWzIgKiBwYWNrSW5kZXggKyAxXSA9IG1zYjtcbiAgLy8gICAgICAgcGFja0luZGV4Kys7XG4gIC8vICAgICB9XG4gIC8vICAgICBwYWNrZWQudGV4dHVyZVR5cGUgPSBUSFJFRS5MdW1pbmFuY2VBbHBoYUZvcm1hdDtcbiAgLy8gICAgIHBhY2tlZC5kYXRhID0gZGF0YTtcbiAgLy8gICB9IGVsc2UgaWYgKGJpdHMgPT09IDMyICYmIGNoYW5uZWxzID09PSAxKSB7XG5cbiAgLy8gICAgIGxldCBkYXRhID0gbmV3IFVpbnQ4QXJyYXkodGV4dHVyZVNpemUgKiB0ZXh0dXJlU2l6ZSAqIDQpO1xuICAvLyAgICAgZm9yIChsZXQgaSA9IHN0YXJ0Vm94ZWw7IGkgPCBzdG9wVm94ZWw7IGkrKykge1xuICAvLyAgICAgICAvKmpzaGludCBiaXR3aXNlOiBmYWxzZSovXG4gIC8vICAgICAgIGZyYW1lSW5kZXggPSB+fihpIC8gZnJhbWVEaW1lbnNpb24pO1xuICAvLyAgICAgICBpbkZyYW1lSW5kZXggPSBpICUgKGZyYW1lRGltZW5zaW9uKTtcbiAgLy8gICAgICAgLypqc2hpbnQgYml0d2lzZTogdHJ1ZSovXG5cbiAgLy8gICAgICAgLy8gc2xvdyFcbiAgLy8gICAgICAgLy9sZXQgYXNiID0gVkpTLmNvcmUucGFjay51aW50MTZUb0FscGhhTHVtaW5hbmNlKGZyYW1lW2ZyYW1lSW5kZXhdLnBpeGVsRGF0YVtpbkZyYW1lSW5kZXhdKTtcbiAgLy8gICAgICAgbGV0IHJhdyA9IGZyYW1lW2ZyYW1lSW5kZXhdLnBpeGVsRGF0YVtpbkZyYW1lSW5kZXhdO1xuXG4gIC8vICAgICAgIC8qanNoaW50IGJpdHdpc2U6IGZhbHNlKi9cbiAgLy8gICAgICAgbGV0IGIwID0gcmF3ICYgMHgwMDAwMDBGRjtcbiAgLy8gICAgICAgbGV0IGIxID0gKHJhdyA+Pj4gOCkgJiAweDAwMDAwMEZGO1xuICAvLyAgICAgICBsZXQgYjIgPSAocmF3ID4+PiA4KSAmIDB4MDAwMDAwRkY7XG4gIC8vICAgICAgIGxldCBiMyA9IChyYXcgPj4+IDgpICYgMHgwMDAwMDBGRjtcbiAgLy8gICAgICAgLy8gbGV0IGxzYjEgPSByYXcgJiAweEZGO1xuICAvLyAgICAgICAvLyBsZXQgbXNiMSA9IChyYXcgPj4gOCkgJiAweEZGO1xuICAvLyAgICAgICAvKmpzaGludCBiaXR3aXNlOiB0cnVlKi9cbiAgLy8gICAgICAgZGF0YVs0ICogcGFja0luZGV4XSA9IGIwO1xuICAvLyAgICAgICBkYXRhWzQgKiBwYWNrSW5kZXggKyAxXSA9IGIxO1xuICAvLyAgICAgICBkYXRhWzQgKiBwYWNrSW5kZXggKyAyXSA9IGIyO1xuICAvLyAgICAgICBkYXRhWzQgKiBwYWNrSW5kZXggKyAzXSA9IGIzO1xuICAvLyAgICAgICBwYWNrSW5kZXgrKztcbiAgLy8gICAgIH1cbiAgLy8gICAgIHBhY2tlZC50ZXh0dXJlVHlwZSA9IFRIUkVFLlJHQkFGb3JtYXQ7XG4gIC8vICAgICBwYWNrZWQuZGF0YSA9IGRhdGE7XG4gIC8vICAgfSBlbHNlIGlmIChiaXRzID09PSA4ICYmIGNoYW5uZWxzID09PSAzKSB7XG4gIC8vICAgICBsZXQgZGF0YSA9IG5ldyBVaW50OEFycmF5KHRleHR1cmVTaXplICogdGV4dHVyZVNpemUgKiAzKTtcbiAgLy8gICAgIGZvciAobGV0IGkgPSBzdGFydFZveGVsOyBpIDwgc3RvcFZveGVsOyBpKyspIHtcbiAgLy8gICAgICAgLypqc2hpbnQgYml0d2lzZTogZmFsc2UqL1xuICAvLyAgICAgICBmcmFtZUluZGV4ID0gfn4oaSAvIGZyYW1lRGltZW5zaW9uKTtcbiAgLy8gICAgICAgaW5GcmFtZUluZGV4ID0gaSAlIChmcmFtZURpbWVuc2lvbik7XG4gIC8vICAgICAgIC8qanNoaW50IGJpdHdpc2U6IHRydWUqL1xuXG4gIC8vICAgICAgIGRhdGFbMyAqIHBhY2tJbmRleF0gPSBmcmFtZVtmcmFtZUluZGV4XS5waXhlbERhdGFbMyAqIGluRnJhbWVJbmRleF07XG4gIC8vICAgICAgIGRhdGFbMyAqIHBhY2tJbmRleCArIDFdID0gZnJhbWVbZnJhbWVJbmRleF0ucGl4ZWxEYXRhWzMgKiBpbkZyYW1lSW5kZXggKyAxXTtcbiAgLy8gICAgICAgZGF0YVszICogcGFja0luZGV4ICsgMl0gPSBmcmFtZVtmcmFtZUluZGV4XS5waXhlbERhdGFbMyAqIGluRnJhbWVJbmRleCArIDJdO1xuICAvLyAgICAgICBwYWNrSW5kZXgrKztcblxuICAvLyAgICAgfVxuICAvLyAgICAgcGFja2VkLnRleHR1cmVUeXBlID0gVEhSRUUuTHVtaW5hbmNlRm9ybWF0O1xuICAvLyAgICAgcGFja2VkLmRhdGEgPSBkYXRhO1xuICAvLyAgIH1cblxuICAvLyAgIHJldHVybiBwYWNrZWQ7XG5cbiAgLy8gfVxufVxuXG4vLyAndXNlIHN0cmljdCc7XG5cbi8vIHZhciBWSlMgPSBWSlMgfHwge307XG4vLyBWSlMuY29yZSA9IFZKUy5jb3JlIHx8IHt9O1xuXG4vLyAvKipcbi8vICAqIEBjb25zdHJ1Y3RvclxuLy8gICogQGNsYXNzXG4vLyAgKiBAbWVtYmVyT2YgVkpTLmNvcmVcbi8vICAqIEBwdWJsaWNcbi8vICovXG4vLyBWSlMuY29yZS5wYWNrID0gVkpTLmNvcmUucGFjayB8fCB7fTtcblxuLy8gLy8gRGVhbCB3aXRoIGVuZGlhbmVzc1xuLy8gLy8gZG8gbm90IGFkZCBhIGlmIHRoZXJlIGFmIGlzIGlzIHNsb3cgaW4gYm9nIGxvb3BzXG4vLyAvLyBhZGQgbW9yZSBmdW5jdGlvbnNcbi8vIFZKUy5jb3JlLnBhY2sudWludDE2VG9BbHBoYUx1bWluYW5jZSA9IGZ1bmN0aW9uKHVpbnQxNiwgYWIpIHtcbi8vICAgLypqc2hpbnQgYml0d2lzZTogZmFsc2UqL1xuLy8gICB2YXIgbHNiID0gdWludDE2ICYgMHhGRjtcbi8vICAgdmFyIG1zYiA9ICh1aW50MTYgPj4gOCkgJiAweEZGO1xuLy8gICAvKmpzaGludCBiaXR3aXNlOiB0cnVlKi9cbi8vICAgYWIgPSBbbHNiLCBtc2JdO1xuLy8gfTtcblxuLy8gVkpTLmNvcmUucGFjay51aW50OFRvTHVtaW5hbmNlID0gZnVuY3Rpb24odWludDgpIHtcbi8vICAgcmV0dXJuIHVpbnQ4O1xuLy8gfTtcblxuLy8gVkpTLmNvcmUucGFjay51aW50OFYzVG9SR0IgPSBmdW5jdGlvbih1aW50OFYzKSB7XG4vLyAgIHJldHVybiB1aW50OFYzO1xuLy8gfTtcblxuLy8gLyoqKiBFeHBvcnRzICoqKi9cblxuLy8gdmFyIG1vZHVsZVR5cGUgPSB0eXBlb2YgbW9kdWxlO1xuLy8gaWYgKChtb2R1bGVUeXBlICE9PSAndW5kZWZpbmVkJykgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbi8vICAgbW9kdWxlLmV4cG9ydHMgPSBWSlMuY29yZS5wYWNrO1xuLy8gfVxuIiwiY29uc3QgVVJMID0gcmVxdWlyZSgndXJsJyk7XG5pbXBvcnQgVmFsaWRhdG9ycyBmcm9tICcuL2NvcmUudmFsaWRhdG9ycyc7XG5cbi8qKlxuICogR2VuZXJhbCBwdXJwb3NlIGZ1bmN0aW9ucy5cbiAqXG4gKiBAbW9kdWxlIGNvcmUvdXRpbHNcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ29yZVV0aWxzIHtcblxuICAvKipcbiAgICogR2VuZXJhdGUgYSBib3VkaW5nIGJveCBvYmplY3QuXG4gICAqIEBwYXJhbSB7VEhSRUUuVmVjdG9yM30gY2VudGVyIC0gQ2VudGVyIG9mIHRoZSBib3guXG4gICAqIEBwYXJhbSB7VEhSRUUuVmVjdG9yM30gaGFsZkRpbWVuc2lvbnMgLSBIYWxmIERpbWVuc2lvbnMgb2YgdGhlIGJveC5cbiAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgYm91bmRpbmcgYm94IG9iamVjdC4ge09iamVjdC5taW59IGlzIGEge1RIUkVFLlZlY3RvcjN9XG4gICAqIGNvbnRhaW5pbmcgdGhlIG1pbiBib3VuZHMuIHtPYmplY3QubWF4fSBpcyBhIHtUSFJFRS5WZWN0b3IzfSBjb250YWluaW5nIHRoZVxuICAgKiBtYXggYm91bmRzLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBGYWxzZSBpbnB1dCBOT1QgdmFsaWQuXG4gICAqIEBleGFtcGxlXG4gICAqIC8vIFJldHVybnNcbiAgICogLy97IG1pbjogeyB4IDogMCwgeSA6IDAsICB6IDogMCB9LFxuICAgKiAvLyAgbWF4OiB7IHggOiAyLCB5IDogNCwgIHogOiA2IH1cbiAgICogLy99XG4gICAqIFZKUy5Db3JlLlV0aWxzLmJib3goXG4gICAqICAgbmV3IFRIUkVFLlZlY3RvcjMoMSwgMiwgMyksIG5ldyBUSFJFRS5WZWN0b3IzKDEsIDIsIDMpKTtcbiAgICpcbiAgICogLy9SZXR1cm5zIGZhbHNlXG4gICAqIFZKUy5Db3JlLlV0aWxzLmJib3gobmV3IFRIUkVFLlZlY3RvcjMoKSwgbmV3IFRIUkVFLk1hdHJpeDQoKSk7XG4gICAqXG4gICAqL1xuICBzdGF0aWMgYmJveChjZW50ZXIsIGhhbGZEaW1lbnNpb25zKSB7XG4gICAgLy8gbWFrZSBzdXJlIHdlIGhhdmUgdmFsaWQgaW5wdXRzXG4gICAgaWYgKCEoVmFsaWRhdG9ycy52ZWN0b3IzKGNlbnRlcikgJiZcbiAgICAgIFZhbGlkYXRvcnMudmVjdG9yMyhoYWxmRGltZW5zaW9ucykpKSB7XG4gICAgICB3aW5kb3cuY29uc29sZS5sb2coJ0ludmFsaWQgY2VudGVyIG9yIHBsYW5lIGhhbGZEaW1lbnNpb25zLicpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIG1ha2Ugc3VyZSBoYWxmIGRpbWVuc2lvbnMgYXJlID49IDBcbiAgICBpZiAoIShoYWxmRGltZW5zaW9ucy54ID49IDAgJiZcbiAgICAgIGhhbGZEaW1lbnNpb25zLnkgPj0gMCAmJlxuICAgICAgaGFsZkRpbWVuc2lvbnMueiA+PSAwKSkge1xuICAgICAgd2luZG93LmNvbnNvbGUubG9nKCdoYWxmRGltZW5zaW9ucyBtdXN0IGJlID49IDAuJyk7XG4gICAgICB3aW5kb3cuY29uc29sZS5sb2coaGFsZkRpbWVuc2lvbnMpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIG1pbi9tYXggYm91bmRcbiAgICBsZXQgbWluID0gY2VudGVyLmNsb25lKCkuc3ViKGhhbGZEaW1lbnNpb25zKTtcbiAgICBsZXQgbWF4ID0gY2VudGVyLmNsb25lKCkuYWRkKGhhbGZEaW1lbnNpb25zKTtcblxuICAgIHJldHVybiB7XG4gICAgICBtaW4sXG4gICAgICBtYXgsXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGaW5kIG1pbi9tYXggdmFsdWVzIGluIGFuIGFycmF5XG4gICAqIEBwYXJhbSB7QXJyYXl9IGRhdGFcbiAgICogQHJldHVybiB7QXJyYXl9XG4gICAqL1xuICBzdGF0aWMgbWluTWF4KGRhdGEgPSBbXSkge1xuICAgIGxldCBtaW5NYXggPSBbNjU1MzUsIC0zMjc2OF07XG4gICAgbGV0IG51bVBpeGVscyA9IGRhdGEubGVuZ3RoO1xuXG4gICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IG51bVBpeGVsczsgaW5kZXgrKykge1xuICAgICAgbGV0IHNwdiA9IGRhdGFbaW5kZXhdO1xuICAgICAgbWluTWF4WzBdID0gTWF0aC5taW4obWluTWF4WzBdLCBzcHYpO1xuICAgICAgbWluTWF4WzFdID0gTWF0aC5tYXgobWluTWF4WzFdLCBzcHYpO1xuICAgIH1cblxuICAgIHJldHVybiBtaW5NYXg7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgSFRNTEVsZW1lbnRcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gb2JqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBzdGF0aWMgaXNFbGVtZW50KG9iaikge1xuICAgIHRyeSB7XG4gICAgICAvLyBVc2luZyBXMyBET00yICh3b3JrcyBmb3IgRkYsIE9wZXJhIGFuZCBDaHJvbSlcbiAgICAgIHJldHVybiBvYmogaW5zdGFuY2VvZiBIVE1MRWxlbWVudDtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBCcm93c2VycyBub3Qgc3VwcG9ydGluZyBXMyBET00yIGRvbid0IGhhdmUgSFRNTEVsZW1lbnQgYW5kXG4gICAgICAvLyBhbiBleGNlcHRpb24gaXMgdGhyb3duIGFuZCB3ZSBlbmQgdXAgaGVyZS4gVGVzdGluZyBzb21lXG4gICAgICAvLyBwcm9wZXJ0aWVzIHRoYXQgYWxsIGVsZW1lbnRzIGhhdmUuICh3b3JrcyBvbiBJRTcpXG4gICAgICByZXR1cm4gKHR5cGVvZiBvYmogPT09ICdvYmplY3QnKSAmJlxuICAgICAgICAob2JqLm5vZGVUeXBlID09PSAxKSAmJiAodHlwZW9mIG9iai5zdHlsZSA9PT0gJ29iamVjdCcpICYmXG4gICAgICAgICh0eXBlb2Ygb2JqLm93bmVyRG9jdW1lbnQgPT09ICdvYmplY3QnKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgc3RyaW5nXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIHN0YXRpYyBpc1N0cmluZyhzdHIpIHtcbiAgICByZXR1cm4gdHlwZW9mIHN0ciA9PT0gJ3N0cmluZycgfHwgc3RyIGluc3RhbmNlb2YgU3RyaW5nO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlIHVybFxuICAgKiBAcGFyYW0geyp9IHVybFxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqL1xuICBzdGF0aWMgcGFyc2VVcmwodXJsKSB7XG4gICAgLy9cbiAgICBjb25zdCBkYXRhID0ge307XG4gICAgZGF0YS5maWxlbmFtZSA9ICcnO1xuICAgIGRhdGEuZXh0ZW5zaW9uID0gJyc7XG4gICAgZGF0YS5wYXRobmFtZSA9ICcnO1xuICAgIGRhdGEucXVlcnkgPSAnJztcblxuICAgIGxldCBwYXJzZWRVcmwgPSBVUkwucGFyc2UodXJsKTtcbiAgICBkYXRhLnBhdGhuYW1lID0gcGFyc2VkVXJsLnBhdGhuYW1lO1xuICAgIGRhdGEucXVlcnkgPSBwYXJzZWRVcmwucXVlcnk7XG5cbiAgICAvLyBnZXQgZmlsZSBuYW1lXG4gICAgZGF0YS5maWxlbmFtZSA9IGRhdGEucGF0aG5hbWUuc3BsaXQoJy8nKS5wb3AoKTtcblxuICAgIC8vIGZpbmQgZXh0ZW5zaW9uXG4gICAgbGV0IHNwbGl0dGVkTmFtZSA9IGRhdGEuZmlsZW5hbWUuc3BsaXQoJy4nKTtcbiAgICBpZiAoc3BsaXR0ZWROYW1lLmxlbmd0aCA8PSAxKSB7XG4gICAgICBkYXRhLmV4dGVuc2lvbiA9ICdkaWNvbSc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRhdGEuZXh0ZW5zaW9uID0gZGF0YS5maWxlbmFtZS5zcGxpdCgnLicpLnBvcCgpO1xuICAgIH1cblxuICAgIGlmICghaXNOYU4oZGF0YS5leHRlbnNpb24pKSB7XG4gICAgICBkYXRhLmV4dGVuc2lvbiA9ICdkaWNvbSc7XG4gICAgfVxuXG4gICAgaWYgKGRhdGEucXVlcnkgJiZcbiAgICAgIGRhdGEucXVlcnkuaW5jbHVkZXMoJ2NvbnRlbnRUeXBlPWFwcGxpY2F0aW9uJTJGZGljb20nKSkge1xuICAgICAgZGF0YS5leHRlbnNpb24gPSAnZGljb20nO1xuICAgIH1cblxuICAgIHJldHVybiBkYXRhO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbXB1dGUgSUpLIHRvIExQUyB0cmFuZm9ybS5cbiAgICpcbiAgICogQHBhcmFtIHsqfSB4Q29zXG4gICAqIEBwYXJhbSB7Kn0geUNvc1xuICAgKiBAcGFyYW0geyp9IHpDb3NcbiAgICogQHBhcmFtIHsqfSBzcGFjaW5nXG4gICAqIEBwYXJhbSB7Kn0gb3JpZ2luXG4gICAqIEBwYXJhbSB7Kn0gcmVnaXN0cmF0aW9uTWF0cml4XG4gICAqXG4gICAqIEByZXR1cm4geyp9XG4gICAqL1xuICBzdGF0aWMgaWprMkxQUyhcbiAgICB4Q29zLCB5Q29zLCB6Q29zLFxuICAgIHNwYWNpbmcsIG9yaWdpbixcbiAgICByZWdpc3RyYXRpb25NYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4NCgpKSB7XG4gICAgY29uc3QgaWprMkxQUyA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XG4gICAgaWprMkxQUy5zZXQoXG4gICAgICB4Q29zLnggKiBzcGFjaW5nLngsIHlDb3MueCAqIHNwYWNpbmcueSwgekNvcy54ICogc3BhY2luZy56LCBvcmlnaW4ueCxcbiAgICAgIHhDb3MueSAqIHNwYWNpbmcueCwgeUNvcy55ICogc3BhY2luZy55LCB6Q29zLnkgKiBzcGFjaW5nLnosIG9yaWdpbi55LFxuICAgICAgeENvcy56ICogc3BhY2luZy54LCB5Q29zLnogKiBzcGFjaW5nLnksIHpDb3MueiAqIHNwYWNpbmcueiwgb3JpZ2luLnosXG4gICAgICAwLCAwLCAwLCAxKTtcbiAgICBpamsyTFBTLnByZW11bHRpcGx5KHJlZ2lzdHJhdGlvbk1hdHJpeCk7XG5cbiAgICByZXR1cm4gaWprMkxQUztcbiAgfVxuXG4gIC8qKlxuICAgKiBDb21wdXRlIEFBQkIgdG8gTFBTIHRyYW5zZm9ybS5cbiAgICogQUFCQjogQXhlIEFsaWduZWQgQm91bmRpbmcgQm94LlxuICAgKlxuICAgKiBAcGFyYW0geyp9IHhDb3NcbiAgICogQHBhcmFtIHsqfSB5Q29zXG4gICAqIEBwYXJhbSB7Kn0gekNvc1xuICAgKiBAcGFyYW0geyp9IG9yaWdpblxuICAgKlxuICAgKiBAcmV0dXJuIHsqfVxuICAgKi9cbiAgc3RhdGljIGFhYmIyTFBTKFxuICAgIHhDb3MsIHlDb3MsIHpDb3MsXG4gICAgb3JpZ2luKSB7XG4gICAgY29uc3QgYWFiYjJMUFMgPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xuICAgIGFhYmIyTFBTLnNldChcbiAgICAgICAgeENvcy54LCB5Q29zLngsIHpDb3MueCwgb3JpZ2luLngsXG4gICAgICAgIHhDb3MueSwgeUNvcy55LCB6Q29zLnksIG9yaWdpbi55LFxuICAgICAgICB4Q29zLnosIHlDb3MueiwgekNvcy56LCBvcmlnaW4ueixcbiAgICAgICAgMCwgMCwgMCwgMSk7XG5cbiAgICByZXR1cm4gYWFiYjJMUFM7XG4gIH1cblxuICAvKipcbiAgICogVHJhbnNmb3JtIGNvb3JkaW5hdGVzIGZyb20gd29ybGQgY29vcmRpbmF0ZSB0byBkYXRhXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gbHBzMklKS1xuICAgKiBAcGFyYW0geyp9IHdvcmxkQ29vcmRpbmF0ZXNcbiAgICpcbiAgICogQHJldHVybiB7Kn1cbiAgICovXG4gICAgc3RhdGljIHdvcmxkVG9EYXRhKGxwczJJSkssIHdvcmxkQ29vcmRpbmF0ZXMpIHtcbiAgICBsZXQgZGF0YUNvb3JkaW5hdGUgPSBuZXcgVEhSRUUuVmVjdG9yMygpXG4gICAgICAuY29weSh3b3JsZENvb3JkaW5hdGVzKVxuICAgICAgLmFwcGx5TWF0cml4NChscHMySUpLKTtcblxuICAgIC8vIHNhbWUgcm91bmRpbmcgaW4gdGhlIHNoYWRlcnNcbiAgICBkYXRhQ29vcmRpbmF0ZS5hZGRTY2FsYXIoMC41KS5mbG9vcigpO1xuXG4gICAgcmV0dXJuIGRhdGFDb29yZGluYXRlO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB2b3hlbCB2YWx1ZVxuICAgKlxuICAgKiBAcGFyYW0geyp9IHN0YWNrXG4gICAqIEBwYXJhbSB7Kn0gY29vcmRpbmF0ZVxuICAgKlxuICAgKiBAcmV0dXJuIHsqfVxuICAgKi9cbiAgc3RhdGljIHZhbHVlKHN0YWNrLCBjb29yZGluYXRlKSB7XG4gICAgaWYgKGNvb3JkaW5hdGUueiA+PSAwICYmXG4gICAgICAgIGNvb3JkaW5hdGUueiA8IHN0YWNrLl9mcmFtZS5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBzdGFjay5fZnJhbWVbY29vcmRpbmF0ZS56XS5cbiAgICAgICAgdmFsdWUoY29vcmRpbmF0ZS54LCBjb29yZGluYXRlLnkpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQXBwbHkgc2xvcGUvaW50ZXJjZXB0IHRvIGEgdmFsdWVcbiAgICpcbiAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgKiBAcGFyYW0geyp9IHNsb3BlXG4gICAqIEBwYXJhbSB7Kn0gaW50ZXJjZXB0XG4gICAqXG4gICAqIEByZXR1cm4geyp9XG4gICAqL1xuICBzdGF0aWMgcmVzY2FsZVNsb3BlSW50ZXJjZXB0KHZhbHVlLCBzbG9wZSwgaW50ZXJjZXB0KSB7XG4gICAgcmV0dXJuIHZhbHVlICogc2xvcGUgKyBpbnRlcmNlcHQ7XG4gIH1cblxufVxuIiwiLyoqXG4gKiBWYWxpZGF0ZSBiYXNpYyBzdHJ1Y3R1cmVzLlxuICpcbiAqIEBleGFtcGxlXG4gKiAvL1JldHVybnMgdHJ1ZVxuICogVkpTLkNvcmUuVmFsaWRhdG9ycy5tYXRyaXg0KG5ldyBUSFJFRS5NYXRyaXg0KCkpO1xuICpcbiAqIC8vUmV0dXJucyBmYWxzZVxuICogVkpTLkNvcmUuVmFsaWRhdG9ycy5tYXRyaXg0KG5ldyBUSFJFRS5WZWN0b3IzKCkpO1xuICpcbiAqIEBtb2R1bGUgY29yZS92YWxpZGF0b3JzXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVmFsaWRhdG9ycyB7XG5cbiAgLyoqXG4gICAqIFZhbGlkYXRlcyBhIG1hdHJpeCBhcyBhIFRIUkVFSlMuTWF0cml4NFxuICAgKiBsaW5rXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RUb1Rlc3QgLSBUaGUgb2JqZWN0IHRvIGJlIHRlc3RlZC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWxpZCBNYXRyaXg0LCBmYWxzZSBpZiBOT1QuXG4gICAqL1xuICBzdGF0aWMgbWF0cml4NChvYmplY3RUb1Rlc3QpIHtcbiAgICBpZiAoIShvYmplY3RUb1Rlc3QgIT09IG51bGwgJiZcbiAgICAgICB0eXBlb2Ygb2JqZWN0VG9UZXN0ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgIG9iamVjdFRvVGVzdC5oYXNPd25Qcm9wZXJ0eSgnZWxlbWVudHMnKSAmJlxuICAgICAgIG9iamVjdFRvVGVzdC5lbGVtZW50cy5sZW5ndGggPT09IDE2ICYmXG4gICAgICAgdHlwZW9mIG9iamVjdFRvVGVzdC5pZGVudGl0eSA9PT0gJ2Z1bmN0aW9uJyYmXG4gICAgICAgdHlwZW9mIG9iamVjdFRvVGVzdC5jb3B5ID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAgdHlwZW9mIG9iamVjdFRvVGVzdC5kZXRlcm1pbmFudCA9PT0gJ2Z1bmN0aW9uJykpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAqIFZhbGlkYXRlcyBhIHZlY3RvciBhcyBhIFRIUkVFSlMuVmVjdG9yM1xuICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RUb1Rlc3QgLSBUaGUgb2JqZWN0IHRvIGJlIHRlc3RlZC5cbiAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHZhbGlkIFZlY3RvcjMsIGZhbHNlIGlmIE5PVC5cbiAgKi9cbiAgc3RhdGljIHZlY3RvcjMob2JqZWN0VG9UZXN0KSB7XG4gICAgaWYgKCEob2JqZWN0VG9UZXN0ICE9PSBudWxsICYmXG4gICAgICAgdHlwZW9mIG9iamVjdFRvVGVzdCAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICBvYmplY3RUb1Rlc3QuaGFzT3duUHJvcGVydHkoJ3gnKSAmJlxuICAgICAgIG9iamVjdFRvVGVzdC5oYXNPd25Qcm9wZXJ0eSgneScpICYmXG4gICAgICAgb2JqZWN0VG9UZXN0Lmhhc093blByb3BlcnR5KCd6JykgJiZcbiAgICAgICAhb2JqZWN0VG9UZXN0Lmhhc093blByb3BlcnR5KCd3JykpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuIC8qKlxuICAqIFZhbGlkYXRlcyBhIGJveC5cbiAgKlxuICAqIEBleGFtcGxlXG4gICogLy8gYSBib3ggaXMgZGVmaW5lZCBhc1xuICAqIGxldCBib3ggPSB7XG4gICogICBjZW50ZXI6IFRIUkVFLlZlY3RvcjMsXG4gICogICBoYWxmRGltZW5zaW9uczogVEhSRUUuVmVjdG9yM1xuICAqIH1cbiAgKlxuICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RUb1Rlc3QgLSBUaGUgb2JqZWN0IHRvIGJlIHRlc3RlZC5cbiAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHZhbGlkIGJveCwgZmFsc2UgaWYgTk9ULlxuICAqL1xuICBzdGF0aWMgYm94KG9iamVjdFRvVGVzdCkge1xuICAgIGlmICghKG9iamVjdFRvVGVzdCAhPT0gbnVsbCAmJlxuICAgICAgIHR5cGVvZiBvYmplY3RUb1Rlc3QgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgb2JqZWN0VG9UZXN0Lmhhc093blByb3BlcnR5KCdjZW50ZXInKSAmJlxuICAgICAgIHRoaXMudmVjdG9yMyhvYmplY3RUb1Rlc3QuY2VudGVyKSAmJlxuICAgICAgIG9iamVjdFRvVGVzdC5oYXNPd25Qcm9wZXJ0eSgnaGFsZkRpbWVuc2lvbnMnKSAmJlxuICAgICAgIHRoaXMudmVjdG9yMyhvYmplY3RUb1Rlc3QuaGFsZkRpbWVuc2lvbnMpICYmXG4gICAgICAgb2JqZWN0VG9UZXN0LmhhbGZEaW1lbnNpb25zLnggPj0gMCAmJlxuICAgICAgIG9iamVjdFRvVGVzdC5oYWxmRGltZW5zaW9ucy55ID49IDAgJiZcbiAgICAgICBvYmplY3RUb1Rlc3QuaGFsZkRpbWVuc2lvbnMueiA+PSAwKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAvKipcbiAgKiBWYWxpZGF0ZXMgYSByYXkuXG4gICpcbiAgKiBAZXhhbXBsZVxuICAqIC8vIGEgcmF5IGlzIGRlZmluZWQgYXNcbiAgKiBsZXQgcmF5ID0ge1xuICAqICAgcG9zdGlvbjogVEhSRUUuVmVjdG9yMyxcbiAgKiAgIGRpcmVjdGlvbjogVEhSRUUuVmVjdG9yM1xuICAqIH1cbiAgKlxuICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RUb1Rlc3QgLSBUaGUgb2JqZWN0IHRvIGJlIHRlc3RlZC5cbiAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHZhbGlkIHJheSwgZmFsc2UgaWYgTk9ULlxuICAqL1xuICBzdGF0aWMgcmF5KG9iamVjdFRvVGVzdCkge1xuICAgIGlmICghKG9iamVjdFRvVGVzdCAhPT0gbnVsbCAmJlxuICAgICAgIHR5cGVvZiBvYmplY3RUb1Rlc3QgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgb2JqZWN0VG9UZXN0Lmhhc093blByb3BlcnR5KCdwb3NpdGlvbicpICYmXG4gICAgICAgdGhpcy52ZWN0b3IzKG9iamVjdFRvVGVzdC5wb3NpdGlvbikgJiZcbiAgICAgICBvYmplY3RUb1Rlc3QuaGFzT3duUHJvcGVydHkoJ2RpcmVjdGlvbicpICYmXG4gICAgICAgdGhpcy52ZWN0b3IzKG9iamVjdFRvVGVzdC5kaXJlY3Rpb24pKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG4iLCJpbXBvcnQgU2xpY2UgZnJvbSAnLi9nZW9tZXRyaWVzLnNsaWNlJztcbmltcG9ydCBWb3hlbCBmcm9tICcuL2dlb21ldHJpZXMudm94ZWwnO1xuXG4vKipcbiAqIEBtb2R1bGUgZ2VvbWV0cmllc1xuICovXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgU2xpY2UsXG4gIFZveGVsLFxufTtcbiIsIi8qKiAqIEltcG9ydHMgKioqL1xuaW1wb3J0IGNvcmVJbnRlcnNlY3Rpb25zIGZyb20gJy4uL2NvcmUvY29yZS5pbnRlcnNlY3Rpb25zJztcblxuLyoqXG4gKlxuICogSXQgaXMgdHlwaWNhbGx5IHVzZWQgZm9yIGNyZWF0aW5nIGFuIGlycmVndWxhciAzRCBwbGFuYXIgc2hhcGUgZ2l2ZW4gYSBib3ggYW5kIHRoZSBjdXQtcGxhbmUuXG4gKlxuICogRGVtbzoge0BsaW5rIGh0dHBzOi8vZm5uZHNjLmdpdGh1Yi5pby92anMjZ2VvbWV0cnlfc2xpY2V9XG4gKlxuICogQG1vZHVsZSBnZW9tZXRyaWVzL3NsaWNlXG4gKlxuICogQHBhcmFtIHtUSFJFRS5WZWN0b3IzfSBoYWxmRGltZW5zaW9ucyAtIEhhbGYtZGltZW5zaW9ucyBvZiB0aGUgYm94IHRvIGJlIHNsaWNlZC5cbiAqIEBwYXJhbSB7VEhSRUUuVmVjdG9yM30gY2VudGVyIC0gQ2VudGVyIG9mIHRoZSBib3ggdG8gYmUgc2xpY2VkLlxuICogQHBhcmFtIHtUSFJFRS5WZWN0b3IzPFRIUkVFLlZlY3RvcjM+fSBvcmllbnRhdGlvbiAtIE9yaWVudGF0aW9uIG9mIHRoZSBib3ggdG8gYmUgc2xpY2VkLiAobWlnaHQgbm90IGJlIG5lY2Vzc2FyeS4uPylcbiAqIEBwYXJhbSB7VEhSRUUuVmVjdG9yM30gcG9zaXRpb24gLSBQb3NpdGlvbiBvZiB0aGUgY3V0dGluZyBwbGFuZS5cbiAqIEBwYXJhbSB7VEhSRUUuVmVjdG9yM30gZGlyZWN0aW9uIC0gQ3Jvc3MgZGlyZWN0aW9uIG9mIHRoZSBjdXR0aW5nIHBsYW5lLlxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBEZWZpbmUgYm94IHRvIGJlIHNsaWNlZFxuICogbGV0IGhhbGZEaW1lbnNpb25zID0gbmV3IFRIUkVFLlZlY3RvcigxMjMsIDQ1LCA2Nyk7XG4gKiBsZXQgY2VudGVyID0gbmV3IFRIUkVFLlZlY3RvcjMoMCwgMCwgMCk7XG4gKiBsZXQgb3JpZW50YXRpb24gPSBuZXcgVEhSRUUuVmVjdG9yMyhcbiAqICAgbmV3IFRIUkVFLlZlY3RvcjMoMSwgMCwgMCksXG4gKiAgIG5ldyBUSFJFRS5WZWN0b3IzKDAsIDEsIDApLFxuICogICBuZXcgVEhSRUUuVmVjdG9yMygwLCAwLCAxKVxuICogKTtcbiAqXG4gKiAvLyBEZWZpbmUgc2xpY2UgcGxhbmVcbiAqIGxldCBwb3NpdGlvbiA9IGNlbnRlci5jbG9uZSgpO1xuICogbGV0IGRpcmVjdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKC0wLjIsIDAuNSwgMC4zKTtcbiAqXG4gKiAvLyBDcmVhdGUgdGhlIHNsaWNlIGdlb21ldHJ5ICYgbWF0ZXJpYWxzXG4gKiBsZXQgc2xpY2VHZW9tZXRyeSA9IG5ldyBWSlMuZ2VvbWV0cmllcy5zbGljZShoYWxmRGltZW5zaW9ucywgY2VudGVyLCBvcmllbnRhdGlvbiwgcG9zaXRpb24sIGRpcmVjdGlvbik7XG4gKiBsZXQgc2xpY2VNYXRlcmlhbCA9IG5ldyBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCh7XG4gKiAgICdzaWRlJzogVEhSRUUuRG91YmxlU2lkZSxcbiAqICAgJ2NvbG9yJzogMHhGRjU3MjJcbiAqIH0pO1xuICpcbiAqICAvLyBDcmVhdGUgbWVzaCBhbmQgYWRkIGl0IHRvIHRoZSBzY2VuZVxuICogIGxldCBzbGljZSA9IG5ldyBUSFJFRS5NZXNoKHNsaWNlR2VvbWV0cnksIHNsaWNlTWF0ZXJpYWwpO1xuICogIHNjZW5lLmFkZChzbGljZSk7XG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgR2VvbWV0cmllc1NsaWNlIGV4dGVuZHMgVEhSRUUuU2hhcGVHZW9tZXRyeSB7XG4gICAgY29uc3RydWN0b3IoaGFsZkRpbWVuc2lvbnMsIGNlbnRlciwgcG9zaXRpb24sIGRpcmVjdGlvbiwgdG9BQUJCID0gbmV3IFRIUkVFLk1hdHJpeDQoKSkge1xuICAgICAgLy9cbiAgICAgIC8vIHByZXBhcmUgZGF0YSBmb3IgdGhlIHNoYXBlIVxuICAgICAgLy9cbiAgICAgIGxldCBhYWJiID0ge1xuICAgICAgICBoYWxmRGltZW5zaW9ucyxcbiAgICAgICAgY2VudGVyLFxuICAgICAgICB0b0FBQkIsXG4gICAgICB9O1xuXG4gICAgICBsZXQgcGxhbmUgPSB7XG4gICAgICAgIHBvc2l0aW9uLFxuICAgICAgICBkaXJlY3Rpb24sXG4gICAgICB9O1xuXG4gICAgICAvLyBCT09NIVxuICAgICAgbGV0IGludGVyc2VjdGlvbnMgPSBjb3JlSW50ZXJzZWN0aW9ucy5hYWJiUGxhbmUoYWFiYiwgcGxhbmUpO1xuXG4gICAgICAvLyBjYW4gbm90IGV4aXN0IGJlZm9yZSBjYWxsaW5nIHRoZSBjb25zdHJ1Y3RvclxuICAgICAgaWYgKGludGVyc2VjdGlvbnMubGVuZ3RoIDwgMykge1xuICAgICAgICB3aW5kb3cuY29uc29sZS5sb2coJ1dBUk5JTkc6IExlc3MgdGhhbiAzIGludGVyc2VjdGlvbnMgYmV0d2VlbiBBQUJCIGFuZCBQbGFuZS4nKTtcbiAgICAgICAgd2luZG93LmNvbnNvbGUubG9nKCdBQUJCJyk7XG4gICAgICAgIHdpbmRvdy5jb25zb2xlLmxvZyhhYWJiKTtcbiAgICAgICAgd2luZG93LmNvbnNvbGUubG9nKCdQbGFuZScpO1xuICAgICAgICB3aW5kb3cuY29uc29sZS5sb2cocGxhbmUpO1xuICAgICAgICB3aW5kb3cuY29uc29sZS5sb2coJ2V4aXRpbmcuLi4nKTtcbiAgICAgICAgLy8gb3IgdGhyb3cgZXJyb3I/XG4gICAgICAgIHRocm93ICdnZW9tZXRyaWVzLnNsaWNlIGhhcyBsZXNzIHRoYW4gMyBpbnRlcnNlY3Rpb25zLCBjYW4gbm90IGNyZWF0ZSBhIHZhbGlkIGdlb21ldHJ5Lic7XG4gICAgICB9XG5cbiAgICAgIGxldCBvcmRlcmVkSW50ZXJzZWN0aW9ucyA9IEdlb21ldHJpZXNTbGljZS5vcmRlckludGVyc2VjdGlvbnMoaW50ZXJzZWN0aW9ucywgZGlyZWN0aW9uKTtcbiAgICAgIGxldCBzbGljZVNoYXBlID0gR2VvbWV0cmllc1NsaWNlLnNoYXBlKG9yZGVyZWRJbnRlcnNlY3Rpb25zKTtcblxuICAgICAgLy9cbiAgICAgIC8vIEdlbmVyYXRlIEdlb21ldHJ5IGZyb20gc2hhcGVcbiAgICAgIC8vIEl0IGRvZXMgdHJpYW5ndWxhdGlvbiBmb3IgdXMhXG4gICAgICAvL1xuICAgICAgc3VwZXIoc2xpY2VTaGFwZSk7XG4gICAgICB0aGlzLnR5cGUgPSAnU2xpY2VHZW9tZXRyeSc7XG5cbiAgICAgIC8vIHVwZGF0ZSByZWFsIHBvc2l0aW9uIG9mIGVhY2ggdmVydGV4ISAobm90IGluIDJkKVxuICAgICAgdGhpcy52ZXJ0aWNlcyA9IG9yZGVyZWRJbnRlcnNlY3Rpb25zO1xuICAgICAgdGhpcy52ZXJ0aWNlc05lZWRVcGRhdGUgPSB0cnVlO1xuICAgIH1cblxuICAgIHN0YXRpYyBzaGFwZShwb2ludHMpIHtcbiAgICAgIC8vXG4gICAgICAvLyBDcmVhdGUgU2hhcGVcbiAgICAgIC8vXG4gICAgICBsZXQgc2hhcGUgPSBuZXcgVEhSRUUuU2hhcGUoKTtcbiAgICAgIC8vIG1vdmUgdG8gZmlyc3QgcG9pbnQhXG4gICAgICBzaGFwZS5tb3ZlVG8ocG9pbnRzWzBdLnh5LngsIHBvaW50c1swXS54eS55KTtcblxuICAgICAgLy8gbG9vcCB0aHJvdWdoIGFsbCBwb2ludHMhXG4gICAgICBmb3IgKGxldCBsID0gMTsgbCA8IHBvaW50cy5sZW5ndGg7IGwrKykge1xuICAgICAgICAvLyBwcm9qZWN0IGVhY2ggb24gcGxhbmUhXG4gICAgICAgIHNoYXBlLmxpbmVUbyhwb2ludHNbbF0ueHkueCwgcG9pbnRzW2xdLnh5LnkpO1xuICAgICAgfVxuXG4gICAgICAvLyBjbG9zZSB0aGUgc2hhcGUhXG4gICAgICBzaGFwZS5saW5lVG8ocG9pbnRzWzBdLnh5LngsIHBvaW50c1swXS54eS55KTtcbiAgICAgIHJldHVybiBzaGFwZTtcbiAgICB9XG5cbiAvKipcbiAgKlxuICAqIENvbnZlbmllbmNlIGZ1bmN0aW9uIHRvIGV4dHJhY3QgY2VudGVyIG9mIG1hc3MgZnJvbSBsaXN0IG9mIHBvaW50cy5cbiAgKlxuICAqIEBwcml2YXRlXG4gICpcbiAgKiBAcGFyYW0ge0FycmF5PFRIUkVFLlZlY3RvcjM+fSBwb2ludHMgLSBTZXQgb2YgcG9pbnRzIGZyb20gd2hpY2ggd2Ugd2FudCB0byBleHRyYWN0IHRoZSBjZW50ZXIgb2YgbWFzcy5cbiAgKlxuICAqIEByZXR1cm5zIHtUSFJFRS5WZWN0b3IzfSBDZW50ZXIgb2YgbWFzcyBmcm9tIGdpdmVuIHBvaW50cy5cbiAgKi9cbiAgc3RhdGljIGNlbnRlck9mTWFzcyhwb2ludHMpIHtcbiAgICBsZXQgY2VudGVyT2ZNYXNzID0gbmV3IFRIUkVFLlZlY3RvcjMoMCwgMCwgMCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNlbnRlck9mTWFzcy54ICs9IHBvaW50c1tpXS54O1xuICAgICAgY2VudGVyT2ZNYXNzLnkgKz0gcG9pbnRzW2ldLnk7XG4gICAgICBjZW50ZXJPZk1hc3MueiArPSBwb2ludHNbaV0uejtcbiAgICB9XG4gICAgY2VudGVyT2ZNYXNzLmRpdmlkZVNjYWxhcihwb2ludHMubGVuZ3RoKTtcblxuICAgIHJldHVybiBjZW50ZXJPZk1hc3M7XG4gIH1cblxuIC8qKlxuICAqXG4gICogT3JkZXIgM0QgcGxhbmFyIHBvaW50cyBhcm91bmQgYSByZWZlbmNlIHBvaW50LlxuICAqXG4gICogQHByaXZhdGVcbiAgKlxuICAqIEBwYXJhbSB7QXJyYXk8VEhSRUUuVmVjdG9yMz59IHBvaW50cyAtIFNldCBvZiBwbGFuYXIgM0QgcG9pbnRzIHRvIGJlIG9yZGVyZWQuXG4gICogQHBhcmFtIHtUSFJFRS5WZWN0b3IzfSBkaXJlY3Rpb24gLSBEaXJlY3Rpb24gb2YgdGhlIHBsYW5lIGluIHdoaWNoIHBvaW50cyBhbmQgcmVmZXJlbmNlIGFyZSBzaXR0aW5nLlxuICAqXG4gICogQHJldHVybnMge0FycmF5PE9iamVjdD59IFNldCBvZiBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBvcmRlcmVkIHBvaW50cy5cbiAgKi9cbiAgc3RhdGljIG9yZGVySW50ZXJzZWN0aW9ucyhwb2ludHMsIGRpcmVjdGlvbikge1xuICAgIGxldCByZWZlcmVuY2UgPSBHZW9tZXRyaWVzU2xpY2UuY2VudGVyT2ZNYXNzKHBvaW50cyk7XG4gICAgLy8gZGlyZWN0aW9uIGZyb20gZmlyc3QgcG9pbnQgdG8gcmVmZXJlbmNlXG4gICAgbGV0IHJlZmVyZW5jZURpcmVjdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKFxuICAgICAgcG9pbnRzWzBdLnggLSByZWZlcmVuY2UueCxcbiAgICAgIHBvaW50c1swXS55IC0gcmVmZXJlbmNlLnksXG4gICAgICBwb2ludHNbMF0ueiAtIHJlZmVyZW5jZS56XG4gICAgICApLm5vcm1hbGl6ZSgpO1xuXG4gICAgbGV0IGJhc2UgPSBuZXcgVEhSRUUuVmVjdG9yMygwLCAwLCAwKVxuICAgICAgICAuY3Jvc3NWZWN0b3JzKHJlZmVyZW5jZURpcmVjdGlvbiwgZGlyZWN0aW9uKVxuICAgICAgICAubm9ybWFsaXplKCk7XG5cbiAgICBsZXQgb3JkZXJlZHBvaW50cyA9IFtdO1xuXG4gICAgLy8gb3RoZXIgbGluZXMgLy8gaWYgaW50ZXIsIHJldHVybiBsb2NhdGlvbiArIGFuZ2xlXG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCBwb2ludHMubGVuZ3RoOyBqKyspIHtcbiAgICAgIGxldCBwb2ludCA9IG5ldyBUSFJFRS5WZWN0b3IzKFxuICAgICAgICBwb2ludHNbal0ueCxcbiAgICAgICAgcG9pbnRzW2pdLnksXG4gICAgICAgIHBvaW50c1tqXS56KTtcbiAgICAgIHBvaW50LmRpcmVjdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKFxuICAgICAgICBwb2ludHNbal0ueCAtIHJlZmVyZW5jZS54LFxuICAgICAgICBwb2ludHNbal0ueSAtIHJlZmVyZW5jZS55LFxuICAgICAgICBwb2ludHNbal0ueiAtIHJlZmVyZW5jZS56KS5ub3JtYWxpemUoKTtcblxuICAgICAgbGV0IHggPSByZWZlcmVuY2VEaXJlY3Rpb24uZG90KHBvaW50LmRpcmVjdGlvbik7XG4gICAgICBsZXQgeSA9IGJhc2UuZG90KHBvaW50LmRpcmVjdGlvbik7XG4gICAgICBwb2ludC54eSA9IHt4LCB5fTtcblxuICAgICAgbGV0IHRoZXRhID0gTWF0aC5hdGFuMih5LCB4KSAqICgxODAgLyBNYXRoLlBJKTtcbiAgICAgIHBvaW50LmFuZ2xlID0gdGhldGE7XG5cbiAgICAgIG9yZGVyZWRwb2ludHMucHVzaChwb2ludCk7XG4gICAgfVxuXG4gICAgb3JkZXJlZHBvaW50cy5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgIHJldHVybiBhLmFuZ2xlIC0gYi5hbmdsZTtcbiAgICB9KTtcblxuICAgIGxldCBub0R1cHMgPSBbb3JkZXJlZHBvaW50c1swXV07XG4gICAgbGV0IGVwc2lsb24gPSAwLjAwMDE7XG4gICAgZm9yKGxldCBpPTE7IGk8b3JkZXJlZHBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYoTWF0aC5hYnMob3JkZXJlZHBvaW50c1tpLTFdLmFuZ2xlIC0gb3JkZXJlZHBvaW50c1tpXS5hbmdsZSkgPiBlcHNpbG9uKSB7XG4gICAgICAgIG5vRHVwcy5wdXNoKG9yZGVyZWRwb2ludHNbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBub0R1cHM7XG4gIH1cblxufVxuIiwiLyoqXG4gKlxuICogQG1vZHVsZSBnZW9tZXRyaWVzL3ZveGVsXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgR2VvbWV0cmllc1ZveGVsIGV4dGVuZHMgVEhSRUUuQm94R2VvbWV0cnkge1xuICBjb25zdHJ1Y3RvcihkYXRhUG9zaXRpb24pIHtcbiAgICBzdXBlcigxLCAxLCAxKTtcblxuICAgIHRoaXMuX2xvY2F0aW9uID0gZGF0YVBvc2l0aW9uO1xuXG4gICAgdGhpcy5hcHBseU1hdHJpeChuZXcgVEhSRUUuTWF0cml4NCgpLm1ha2VUcmFuc2xhdGlvbihcbiAgICAgIHRoaXMuX2xvY2F0aW9uLngsXG4gICAgICB0aGlzLl9sb2NhdGlvbi55LFxuICAgICAgdGhpcy5fbG9jYXRpb24ueikpO1xuXG4gICAgdGhpcy52ZXJ0aWNlc05lZWRVcGRhdGUgPSB0cnVlO1xuICB9XG5cbiAgcmVzZXRWZXJ0aWNlcygpIHtcbiAgICB0aGlzLnZlcnRpY2VzWzBdLnNldCgwLjUsIDAuNSwgMC41KTtcbiAgICB0aGlzLnZlcnRpY2VzWzFdLnNldCgwLjUsIDAuNSwgLTAuNSk7XG4gICAgdGhpcy52ZXJ0aWNlc1syXS5zZXQoMC41LCAtMC41LCAwLjUpO1xuICAgIHRoaXMudmVydGljZXNbM10uc2V0KDAuNSwgLTAuNSwgLTAuNSk7XG4gICAgdGhpcy52ZXJ0aWNlc1s0XS5zZXQoLTAuNSwgMC41LCAtMC41KTtcbiAgICB0aGlzLnZlcnRpY2VzWzVdLnNldCgtMC41LCAwLjUsIDAuNSk7XG4gICAgdGhpcy52ZXJ0aWNlc1s2XS5zZXQoLTAuNSwgLTAuNSwgLTAuNSk7XG4gICAgdGhpcy52ZXJ0aWNlc1s3XS5zZXQoLTAuNSwgLTAuNSwgMC41KTtcbiAgfVxuXG4gIHNldCBsb2NhdGlvbihsb2NhdGlvbikge1xuICAgIHRoaXMuX2xvY2F0aW9uID0gbG9jYXRpb247XG5cbiAgICAvLyB1cGRhdGUgdmVydGljZXMgZnJvbSBsb2NhdGlvblxuICAgIHRoaXMudmVydGljZXNbMF0uc2V0KCsgMC41LCArIDAuNSwgKyAwLjUpO1xuICAgIHRoaXMudmVydGljZXNbMV0uc2V0KCsgMC41LCArIDAuNSwgLSAwLjUpO1xuICAgIHRoaXMudmVydGljZXNbMl0uc2V0KCsgMC41LCAtIDAuNSwgKyAwLjUpO1xuICAgIHRoaXMudmVydGljZXNbM10uc2V0KCsgMC41LCAtIDAuNSwgLSAwLjUpO1xuICAgIHRoaXMudmVydGljZXNbNF0uc2V0KC0gMC41LCArIDAuNSwgLSAwLjUpO1xuICAgIHRoaXMudmVydGljZXNbNV0uc2V0KC0gMC41LCArIDAuNSwgKyAwLjUpO1xuICAgIHRoaXMudmVydGljZXNbNl0uc2V0KC0gMC41LCAtIDAuNSwgLSAwLjUpO1xuICAgIHRoaXMudmVydGljZXNbN10uc2V0KC0gMC41LCAtIDAuNSwgKyAwLjUpO1xuXG4gICAgdGhpcy5hcHBseU1hdHJpeChcbiAgICAgIG5ldyBUSFJFRS5NYXRyaXg0KCkubWFrZVRyYW5zbGF0aW9uKFxuICAgICAgICB0aGlzLl9sb2NhdGlvbi54LFxuICAgICAgICB0aGlzLl9sb2NhdGlvbi55LFxuICAgICAgICB0aGlzLl9sb2NhdGlvbi56KSk7XG5cbiAgICB0aGlzLnZlcnRpY2VzTmVlZFVwZGF0ZSA9IHRydWU7XG4gIH1cblxuICBnZXQgbG9jYXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2xvY2F0aW9uO1xuICB9XG5cblxufVxuIiwiLyoqICogSW1wb3J0cyAqKiovXG5cbi8qKlxuICogQG1vZHVsZSBoZWxwZXJzL2JvcmRlclxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBIZWxwZXJzQm9yZGVyIGV4dGVuZHMgVEhSRUUuT2JqZWN0M0Qge1xuICBjb25zdHJ1Y3RvcihoZWxwZXJzU2xpY2UpIHtcbiAgICAvL1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLl9oZWxwZXJzU2xpY2UgPSBoZWxwZXJzU2xpY2U7XG5cbiAgICB0aGlzLl92aXNpYmxlID0gdHJ1ZTtcbiAgICB0aGlzLl9jb2xvciA9IDB4ZmYwMDAwO1xuICAgIHRoaXMuX21hdGVyaWFsID0gbnVsbDtcbiAgICB0aGlzLl9nZW9tZXRyeSA9IG51bGw7XG4gICAgdGhpcy5fbWVzaCA9IG51bGw7XG5cbiAgICB0aGlzLl9jcmVhdGUoKTtcbiAgfVxuXG4gIHNldCBoZWxwZXJzU2xpY2UoaGVscGVyc1NsaWNlKSB7XG4gICAgdGhpcy5faGVscGVyc1NsaWNlID0gaGVscGVyc1NsaWNlO1xuICAgIHRoaXMuX3VwZGF0ZSgpO1xuICB9XG5cbiAgZ2V0IGhlbHBlcnNTbGljZSgpIHtcbiAgICByZXR1cm4gdGhpcy5faGVscGVyc1NsaWNlO1xuICB9XG5cbiAgc2V0IHZpc2libGUodmlzaWJsZSkge1xuICAgIHRoaXMuX3Zpc2libGUgPSB2aXNpYmxlO1xuICAgIGlmICh0aGlzLl9tZXNoKSB7XG4gICAgICB0aGlzLl9tZXNoLnZpc2libGUgPSB0aGlzLl92aXNpYmxlO1xuICAgIH1cbiAgfVxuXG4gIGdldCB2aXNpYmxlKCkge1xuICAgIHJldHVybiB0aGlzLl92aXNpYmxlO1xuICB9XG5cbiAgc2V0IGNvbG9yKGNvbG9yKSB7XG4gICAgdGhpcy5fY29sb3IgPSBjb2xvcjtcbiAgICBpZiAodGhpcy5fbWF0ZXJpYWwpIHtcbiAgICAgIHRoaXMuX21hdGVyaWFsLmNvbG9yLnNldCh0aGlzLl9jb2xvcik7XG4gICAgfVxuICB9XG5cbiAgZ2V0IGNvbG9yKCkge1xuICAgIHJldHVybiB0aGlzLl9jb2xvcjtcbiAgfVxuXG4gIF9jcmVhdGUoKSB7XG4gICAgaWYgKCF0aGlzLl9tYXRlcmlhbCkge1xuICAgICAgdGhpcy5fbWF0ZXJpYWwgPSBuZXcgVEhSRUUuTGluZUJhc2ljTWF0ZXJpYWwoe1xuICAgICAgICBjb2xvcjogdGhpcy5fY29sb3IsXG4gICAgICAgIGxpbmV3aWR0aDogMSxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vXG4gICAgaWYgKCF0aGlzLl9oZWxwZXJzU2xpY2UuZ2VvbWV0cnkudmVydGljZXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9nZW9tZXRyeSA9IG5ldyBUSFJFRS5HZW9tZXRyeSgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5faGVscGVyc1NsaWNlLmdlb21ldHJ5LnZlcnRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLl9nZW9tZXRyeS52ZXJ0aWNlcy5wdXNoKHRoaXMuX2hlbHBlcnNTbGljZS5nZW9tZXRyeS52ZXJ0aWNlc1tpXSk7XG4gICAgfVxuICAgIHRoaXMuX2dlb21ldHJ5LnZlcnRpY2VzLnB1c2godGhpcy5faGVscGVyc1NsaWNlLmdlb21ldHJ5LnZlcnRpY2VzWzBdKTtcblxuICAgIHRoaXMuX21lc2ggPSBuZXcgVEhSRUUuTGluZSh0aGlzLl9nZW9tZXRyeSwgdGhpcy5fbWF0ZXJpYWwpO1xuICAgIGlmICh0aGlzLl9oZWxwZXJzU2xpY2UuYWFiYlNwYWNlID09PSAnSUpLJykge1xuICAgICAgdGhpcy5fbWVzaC5hcHBseU1hdHJpeCh0aGlzLl9oZWxwZXJzU2xpY2Uuc3RhY2suaWprMkxQUyk7XG4gICAgfVxuICAgIHRoaXMuX21lc2gudmlzaWJsZSA9IHRoaXMuX3Zpc2libGU7XG5cbiAgICAvLyBhbmQgYWRkIGl0IVxuICAgIHRoaXMuYWRkKHRoaXMuX21lc2gpO1xuICB9XG5cbiAgX3VwZGF0ZSgpIHtcbiAgICAvLyB1cGRhdGUgc2xpY2VcbiAgICBpZiAodGhpcy5fbWVzaCkge1xuICAgICAgdGhpcy5yZW1vdmUodGhpcy5fbWVzaCk7XG4gICAgICB0aGlzLl9tZXNoLmdlb21ldHJ5LmRpc3Bvc2UoKTtcbiAgICAgIHRoaXMuX21lc2ggPSBudWxsO1xuICAgIH1cblxuICAgIHRoaXMuX2NyZWF0ZSgpO1xuICB9XG5cbiAgZGlzcG9zZSgpIHtcbiAgICB0aGlzLl9tZXNoLm1hdGVyaWFsLmRpc3Bvc2UoKTtcbiAgICB0aGlzLl9tZXNoLm1hdGVyaWFsID0gbnVsbDtcbiAgICB0aGlzLl9nZW9tZXRyeS5kaXNwb3NlKCk7XG4gICAgdGhpcy5fZ2VvbWV0cnkgPSBudWxsO1xuICAgIHRoaXMuX21hdGVyaWFsLmRpc3Bvc2UoKTtcbiAgICB0aGlzLl9tYXRlcmlhbCA9IG51bGw7XG4gIH1cbn1cbiIsIlxuLyoqXG4gKiBAbW9kdWxlIGhlbHBlcnMvYm91bmRpbmdib3hcbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBIZWxwZXJzQm91bmRpbmdCb3ggZXh0ZW5kcyBUSFJFRS5PYmplY3QzRCB7XG4gIGNvbnN0cnVjdG9yKHN0YWNrKSB7XG4gICAgLy9cbiAgICBzdXBlcigpO1xuXG4gICAgLy8gcHJpdmF0ZSB2YXJzXG4gICAgdGhpcy5fc3RhY2sgPSBzdGFjaztcbiAgICB0aGlzLl92aXNpYmxlID0gdHJ1ZTtcbiAgICB0aGlzLl9jb2xvciA9IDB4RkZGRkZGO1xuICAgIHRoaXMuX21hdGVyaWFsID0gbnVsbDtcbiAgICB0aGlzLl9nZW9tZXRyeSA9IG51bGw7XG4gICAgdGhpcy5fbWVzaCA9IG51bGw7XG5cbiAgICAvLyBjcmVhdGUgb2JqZWN0XG4gICAgdGhpcy5fY3JlYXRlKCk7XG4gIH1cblxuICAvLyBnZXR0ZXJzL3NldHRlcnNcbiAgc2V0IHZpc2libGUodmlzaWJsZSkge1xuICAgIHRoaXMuX3Zpc2libGUgPSB2aXNpYmxlO1xuICAgIGlmICh0aGlzLl9tZXNoKSB7XG4gICAgICB0aGlzLl9tZXNoLnZpc2libGUgPSB0aGlzLl92aXNpYmxlO1xuICAgIH1cbiAgfVxuXG4gIGdldCB2aXNpYmxlKCkge1xuICAgIHJldHVybiB0aGlzLl92aXNpYmxlO1xuICB9XG5cbiAgc2V0IGNvbG9yKGNvbG9yKSB7XG4gICAgdGhpcy5fY29sb3IgPSBjb2xvcjtcbiAgICBpZiAodGhpcy5fbWF0ZXJpYWwpIHtcbiAgICAgIHRoaXMuX21hdGVyaWFsLmNvbG9yLnNldCh0aGlzLl9jb2xvcik7XG4gICAgfVxuICB9XG5cbiAgZ2V0IGNvbG9yKCkge1xuICAgIHJldHVybiB0aGlzLl9jb2xvcjtcbiAgfVxuXG4gIC8vIHByaXZhdGUgbWV0aG9kc1xuICBfY3JlYXRlKCkge1xuICAgIC8vIENvbnZlbmllbmNlIHZhcnNcbiAgICBsZXQgZGltZW5zaW9ucyA9IHRoaXMuX3N0YWNrLmRpbWVuc2lvbnNJSks7XG4gICAgbGV0IGhhbGZEaW1lbnNpb25zID0gdGhpcy5fc3RhY2suaGFsZkRpbWVuc2lvbnNJSks7XG4gICAgbGV0IG9mZnNldCA9IG5ldyBUSFJFRS5WZWN0b3IzKC0wLjUsIC0wLjUsIC0wLjUpO1xuXG4gICAgLy8gR2VvbWV0cnlcbiAgICB0aGlzLl9nZW9tZXRyeSA9IG5ldyBUSFJFRS5Cb3hHZW9tZXRyeShcbiAgICAgIGRpbWVuc2lvbnMueCwgZGltZW5zaW9ucy55LCBkaW1lbnNpb25zLnopO1xuICAgIC8vIHBvc2l0aW9uIGJib3ggaW4gaW1hZ2Ugc3BhY2VcbiAgICB0aGlzLl9nZW9tZXRyeSAuYXBwbHlNYXRyaXgobmV3IFRIUkVFLk1hdHJpeDQoKS5tYWtlVHJhbnNsYXRpb24oXG4gICAgICBoYWxmRGltZW5zaW9ucy54ICsgb2Zmc2V0LngsXG4gICAgICBoYWxmRGltZW5zaW9ucy55ICsgb2Zmc2V0LnksXG4gICAgICBoYWxmRGltZW5zaW9ucy56ICsgb2Zmc2V0LnopKTtcblxuXG4gICAgLy8gTWVzaFxuICAgIGxldCBib3hNZXNoID1cbiAgICAgIG5ldyBUSFJFRS5NZXNoKHRoaXMuX2dlb21ldHJ5LCBuZXcgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwoMHhmZjAwMDApKTtcbiAgICB0aGlzLl9tZXNoID0gbmV3IFRIUkVFLkJveEhlbHBlcihib3hNZXNoLCB0aGlzLl9jb2xvcik7XG5cbiAgICAvLyBNYXRlcmlhbFxuICAgIHRoaXMuX21hdGVyaWFsID0gdGhpcy5fbWVzaC5tYXRlcmlhbDtcblxuICAgIC8vIHBvc2l0aW9uIGJib3ggaW4gd29ybGQgc3BhY2VcbiAgICB0aGlzLl9tZXNoLmFwcGx5TWF0cml4KHRoaXMuX3N0YWNrLmlqazJMUFMpO1xuICAgIHRoaXMuX21lc2gudmlzaWJsZSA9IHRoaXMuX3Zpc2libGU7XG5cbiAgICAvLyBhbmQgYWRkIGl0IVxuICAgIHRoaXMuYWRkKHRoaXMuX21lc2gpO1xuICB9XG5cbiAgX3VwZGF0ZSgpIHtcbiAgICAvLyB1cGRhdGUgc2xpY2VcbiAgICBpZiAodGhpcy5fbWVzaCkge1xuICAgICAgdGhpcy5yZW1vdmUodGhpcy5fbWVzaCk7XG4gICAgICB0aGlzLl9tZXNoLmdlb21ldHJ5LmRpc3Bvc2UoKTtcbiAgICAgIHRoaXMuX21lc2guZ2VvbWV0cnkgPSBudWxsO1xuICAgICAgdGhpcy5fbWVzaC5tYXRlcmlhbC5kaXNwb3NlKCk7XG4gICAgICB0aGlzLl9tZXNoLm1hdGVyaWFsID0gbnVsbDtcbiAgICAgIHRoaXMuX21lc2ggPSBudWxsO1xuICAgIH1cblxuICAgIHRoaXMuX2NyZWF0ZSgpO1xuICB9XG5cbiAgZGlzcG9zZSgpIHtcbiAgICB0aGlzLl9tZXNoLm1hdGVyaWFsLmRpc3Bvc2UoKTtcbiAgICB0aGlzLl9tZXNoLm1hdGVyaWFsID0gbnVsbDtcbiAgICB0aGlzLl9nZW9tZXRyeS5kaXNwb3NlKCk7XG4gICAgdGhpcy5fZ2VvbWV0cnkgPSBudWxsO1xuICAgIHRoaXMuX21hdGVyaWFsLmRpc3Bvc2UoKTtcbiAgICB0aGlzLl9tYXRlcmlhbCA9IG51bGw7XG4gIH1cbn1cbiIsImltcG9ydCBCb3JkZXIgZnJvbSAnLi9oZWxwZXJzLmJvcmRlcic7XG5pbXBvcnQgQm91bmRpbmdCb3ggZnJvbSAnLi9oZWxwZXJzLmJvdW5kaW5nYm94JztcbmltcG9ydCBMb2NhbGl6ZXIgZnJvbSAnLi9oZWxwZXJzLmxvY2FsaXplcic7XG5pbXBvcnQgTHV0IGZyb20gJy4vaGVscGVycy5sdXQnO1xuaW1wb3J0IFByb2dyZXNzQmFyIGZyb20gJy4vaGVscGVycy5wcm9ncmVzc2Jhcic7XG5pbXBvcnQgUHJvZ3Jlc3NCYXJFdmVudEJhc2VkIGZyb20gJy4vaGVscGVycy5wcm9ncmVzc2Jhci5ldmVudGJhc2VkJztcbmltcG9ydCBTbGljZSBmcm9tICcuL2hlbHBlcnMuc2xpY2UnO1xuaW1wb3J0IFN0YWNrIGZyb20gJy4vaGVscGVycy5zdGFjayc7XG5pbXBvcnQgVm9sdW1lUmVuZGVyaW5nIGZyb20gJy4vaGVscGVycy52b2x1bWVyZW5kZXJpbmcnO1xuaW1wb3J0IFggZnJvbSAnLi94L2hlbHBlcnMueCc7XG5cbi8qKlxuICogQG1vZHVsZSBoZWxwZXJzXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQge1xuICBCb3JkZXIsXG4gIEJvdW5kaW5nQm94LFxuICBMb2NhbGl6ZXIsXG4gIEx1dCxcbiAgUHJvZ3Jlc3NCYXIsXG4gIFByb2dyZXNzQmFyRXZlbnRCYXNlZCxcbiAgU2xpY2UsXG4gIFN0YWNrLFxuICBWb2x1bWVSZW5kZXJpbmcsXG4gIFgsXG59O1xuIiwiLyoqICogSW1wb3J0cyAqKiovXG5pbXBvcnQgU2hhZGVyc1VuaWZvcm0gZnJvbVxuICAnLi4vc2hhZGVycy9zaGFkZXJzLmxvY2FsaXplci51bmlmb3JtJztcbmltcG9ydCBTaGFkZXJzVmVydGV4IGZyb21cbiAgJy4uL3NoYWRlcnMvc2hhZGVycy5sb2NhbGl6ZXIudmVydGV4JztcbmltcG9ydCBTaGFkZXJzRnJhZ21lbnQgZnJvbVxuICAnLi4vc2hhZGVycy9zaGFkZXJzLmxvY2FsaXplci5mcmFnbWVudCc7XG5cbi8qKlxuICogQG1vZHVsZSBoZWxwZXJzL2xvY2FsaXplclxuICovXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEhlbHBlcnNMb2NhbGl6ZXIgZXh0ZW5kcyBUSFJFRS5PYmplY3QzRCB7XG4gIGNvbnN0cnVjdG9yKHN0YWNrLCBnZW9tZXRyeSwgcmVmZXJlbmNlUGxhbmUpIHtcbiAgICAvL1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLl9zdGFjayA9IHN0YWNrO1xuICAgIHRoaXMuX3JlZmVyZW5jZVBsYW5lID0gcmVmZXJlbmNlUGxhbmU7XG4gICAgdGhpcy5fcGxhbmUxID0gbnVsbDtcbiAgICB0aGlzLl9jb2xvcjEgPSBudWxsO1xuICAgIHRoaXMuX3BsYW5lMiA9IG51bGw7XG4gICAgdGhpcy5fY29sb3IyID0gbnVsbDtcbiAgICB0aGlzLl9wbGFuZTMgPSBudWxsO1xuICAgIHRoaXMuX2NvbG9yMyA9IG51bGw7XG4gICAgdGhpcy5fY2FudmFzV2lkdGggPSAwO1xuICAgIHRoaXMuX2NhbnZhc0hlaWdodCA9IDA7XG4gICAgdGhpcy5fc2hhZGVyc0ZyYWdtZW50ID0gU2hhZGVyc0ZyYWdtZW50O1xuICAgIHRoaXMuX3NoYWRlcnNWZXJ0ZXggPSBTaGFkZXJzVmVydGV4O1xuICAgIHRoaXMuX3VuaWZvcm1zID0gU2hhZGVyc1VuaWZvcm0udW5pZm9ybXMoKTtcbiAgICB0aGlzLl9tYXRlcmlhbCA9IG51bGw7XG4gICAgdGhpcy5fZ2VvbWV0cnkgPSBnZW9tZXRyeTtcblxuICAgIHRoaXMuX2NyZWF0ZSgpO1xuICB9XG5cbiAgX2NyZWF0ZSgpIHtcbiAgICB0aGlzLl9wcmVwYXJlTWF0ZXJpYWwoKTtcbiAgICB0aGlzLl9tZXNoID0gbmV3IFRIUkVFLk1lc2godGhpcy5fZ2VvbWV0cnksIHRoaXMuX21hdGVyaWFsKTtcbiAgICB0aGlzLl9tZXNoLmFwcGx5TWF0cml4KHRoaXMuX3N0YWNrLl9pamsyTFBTKTtcbiAgICB0aGlzLmFkZCh0aGlzLl9tZXNoKTtcbiAgfVxuXG4gIF9wcmVwYXJlTWF0ZXJpYWwoKSB7XG4gICAgaWYgKCF0aGlzLm1hdGVyaWFsKSB7XG4gICAgICAvLyByZWZlcmVuY2UgcGxhbmVcbiAgICAgIHRoaXMuX3VuaWZvcm1zLnVTbGljZS52YWx1ZSA9IHRoaXMuX3JlZmVyZW5jZVBsYW5lO1xuXG4gICAgICAvLyBsb2NhbGl6ZXIgcGxhbmVzXG4gICAgICBpZiAodGhpcy5fcGxhbmUxKSB7XG4gICAgICAgIHRoaXMuX3VuaWZvcm1zLnVQbGFuZTEudmFsdWUgPSB0aGlzLl9wbGFuZTE7XG4gICAgICAgIHRoaXMuX3VuaWZvcm1zLnVQbGFuZUNvbG9yMS52YWx1ZSA9IHRoaXMuX2NvbG9yMTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX3BsYW5lMikge1xuICAgICAgICB0aGlzLl91bmlmb3Jtcy51UGxhbmUyLnZhbHVlID0gdGhpcy5fcGxhbmUyO1xuICAgICAgICB0aGlzLl91bmlmb3Jtcy51UGxhbmVDb2xvcjIudmFsdWUgPSB0aGlzLl9jb2xvcjI7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9wbGFuZTMpIHtcbiAgICAgICAgdGhpcy5fdW5pZm9ybXMudVBsYW5lMy52YWx1ZSA9IHRoaXMuX3BsYW5lMztcbiAgICAgICAgdGhpcy5fdW5pZm9ybXMudVBsYW5lQ29sb3IzLnZhbHVlID0gdGhpcy5fY29sb3IzO1xuICAgICAgfVxuXG4gICAgICAvL1xuICAgICAgdGhpcy5fdW5pZm9ybXMudUNhbnZhc1dpZHRoLnZhbHVlID0gdGhpcy5fY2FudmFzV2lkdGg7XG4gICAgICB0aGlzLl91bmlmb3Jtcy51Q2FudmFzSGVpZ2h0LnZhbHVlID0gdGhpcy5fY2FudmFzSGVpZ2h0O1xuXG4gICAgICAvLyBnZW5lcmF0ZSBtYXRlcmlhbFxuICAgICAgbGV0IGZzID0gbmV3IFNoYWRlcnNGcmFnbWVudCh0aGlzLl91bmlmb3Jtcyk7XG4gICAgICBsZXQgdnMgPSBuZXcgU2hhZGVyc1ZlcnRleCgpO1xuICAgICAgdGhpcy5fbWF0ZXJpYWwgPSBuZXcgVEhSRUUuU2hhZGVyTWF0ZXJpYWwoXG4gICAgICAgIHtzaWRlOiBUSFJFRS5Eb3VibGVTaWRlLFxuICAgICAgICAgdW5pZm9ybXM6IHRoaXMuX3VuaWZvcm1zLFxuICAgICAgICAgdmVydGV4U2hhZGVyOiB2cy5jb21wdXRlKCksXG4gICAgICAgICBmcmFnbWVudFNoYWRlcjogZnMuY29tcHV0ZSgpLFxuICAgICAgICB9KTtcbiAgICAgIHRoaXMuX21hdGVyaWFsLnRyYW5zcGFyZW50ID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICB1cGRhdGUoKSB7XG4gICAgaWYgKHRoaXMuX21lc2gpIHtcbiAgICAgIHRoaXMucmVtb3ZlKHRoaXMuX21lc2gpO1xuICAgICAgdGhpcy5fbWVzaC5nZW9tZXRyeS5kaXNwb3NlKCk7XG4gICAgICB0aGlzLl9tZXNoLmdlb21ldHJ5ID0gbnVsbDtcbiAgICAgIHRoaXMuX21lc2ggPSBudWxsO1xuICAgIH1cblxuICAgIHRoaXMuX2NyZWF0ZSgpO1xuICB9XG5cbiAgZ2V0IGdlb21ldHJ5KCkge1xuICAgIHJldHVybiB0aGlzLl9nZW9tZXRyeTtcbiAgfVxuXG4gIHNldCBnZW9tZXRyeShnZW9tZXRyeSkge1xuICAgIHRoaXMuX2dlb21ldHJ5ID0gZ2VvbWV0cnk7XG5cbiAgICBpZiAodGhpcy5fbWVzaCkge1xuICAgICAgdGhpcy5yZW1vdmUodGhpcy5fbWVzaCk7XG4gICAgICB0aGlzLl9tZXNoLmdlb21ldHJ5LmRpc3Bvc2UoKTtcbiAgICAgIHRoaXMuX21lc2guZ2VvbWV0cnkgPSBudWxsO1xuICAgICAgdGhpcy5fbWVzaCA9IG51bGw7XG4gICAgfVxuXG4gICAgdGhpcy5fY3JlYXRlKCk7XG4gIH1cblxuICBnZXQgcmVmZXJlbmNlUGxhbmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlZmVyZW5jZVBsYW5lO1xuICB9XG5cbiAgc2V0IHJlZmVyZW5jZVBsYW5lKHJlZmVyZW5jZVBsYW5lKSB7XG4gICAgdGhpcy5fcmVmZXJlbmNlUGxhbmUgPSByZWZlcmVuY2VQbGFuZTtcbiAgICB0aGlzLl91bmlmb3Jtcy51U2xpY2UudmFsdWUgPSB0aGlzLl9yZWZlcmVuY2VQbGFuZTtcbiAgfVxuXG4gIGdldCBwbGFuZTEoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BsYW5lMTtcbiAgfVxuXG4gIHNldCBwbGFuZTEocGxhbmUxKSB7XG4gICAgdGhpcy5fcGxhbmUxID0gcGxhbmUxO1xuICAgIHRoaXMuX3VuaWZvcm1zLnVQbGFuZTEudmFsdWUgPSB0aGlzLl9wbGFuZTE7XG4gIH1cblxuICBnZXQgY29sb3IxKCkge1xuICAgIHJldHVybiB0aGlzLl9jb2xvcjE7XG4gIH1cblxuICBzZXQgY29sb3IxKGNvbG9yMSkge1xuICAgIHRoaXMuX2NvbG9yMSA9IGNvbG9yMTtcbiAgICB0aGlzLl91bmlmb3Jtcy51UGxhbmVDb2xvcjEudmFsdWUgPSB0aGlzLl9jb2xvcjE7XG4gIH1cblxuICBnZXQgcGxhbmUyKCkge1xuICAgIHJldHVybiB0aGlzLl9wbGFuZTI7XG4gIH1cblxuICBzZXQgcGxhbmUyKHBsYW5lMikge1xuICAgIHRoaXMuX3BsYW5lMiA9IHBsYW5lMjtcbiAgICB0aGlzLl91bmlmb3Jtcy51UGxhbmUyLnZhbHVlID0gdGhpcy5fcGxhbmUyO1xuICB9XG5cbiAgZ2V0IGNvbG9yMigpIHtcbiAgICByZXR1cm4gdGhpcy5fY29sb3IyO1xuICB9XG5cbiAgc2V0IGNvbG9yMihjb2xvcjIpIHtcbiAgICB0aGlzLl9jb2xvcjIgPSBjb2xvcjI7XG4gICAgdGhpcy5fdW5pZm9ybXMudVBsYW5lQ29sb3IyLnZhbHVlID0gdGhpcy5fY29sb3IyO1xuICB9XG5cbiAgZ2V0IHBsYW5lMygpIHtcbiAgICByZXR1cm4gdGhpcy5fcGxhbmUzO1xuICB9XG5cbiAgc2V0IHBsYW5lMyhwbGFuZTMpIHtcbiAgICB0aGlzLl9wbGFuZTMgPSBwbGFuZTM7XG4gICAgdGhpcy5fdW5pZm9ybXMudVBsYW5lMy52YWx1ZSA9IHRoaXMuX3BsYW5lMztcbiAgfVxuXG4gIGdldCBjb2xvcjMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbG9yMztcbiAgfVxuXG4gIHNldCBjb2xvcjMoY29sb3IzKSB7XG4gICAgdGhpcy5fY29sb3IzID0gY29sb3IzO1xuICAgIHRoaXMuX3VuaWZvcm1zLnVQbGFuZUNvbG9yMy52YWx1ZSA9IHRoaXMuX2NvbG9yMztcbiAgfVxuXG4gIGdldCBjYW52YXNXaWR0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5fY2FudmFzV2lkdGg7XG4gIH1cblxuICBzZXQgY2FudmFzV2lkdGgoY2FudmFzV2lkdGgpIHtcbiAgICB0aGlzLl9jYW52YXNXaWR0aCA9IGNhbnZhc1dpZHRoO1xuICAgIHRoaXMuX3VuaWZvcm1zLnVDYW52YXNXaWR0aC52YWx1ZSA9IHRoaXMuX2NhbnZhc1dpZHRoO1xuICB9XG5cbiAgZ2V0IGNhbnZhc0hlaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy5fY2FudmFzSGVpZ2h0O1xuICB9XG5cbiAgc2V0IGNhbnZhc0hlaWdodChjYW52YXNIZWlnaHQpIHtcbiAgICB0aGlzLl9jYW52YXNIZWlnaHQgPSBjYW52YXNIZWlnaHQ7XG4gICAgdGhpcy5fdW5pZm9ybXMudUNhbnZhc0hlaWdodC52YWx1ZSA9IHRoaXMuX2NhbnZhc0hlaWdodDtcbiAgfVxufVxuIiwiXG4vKipcbiAqIEBtb2R1bGUgaGVscGVycy9sdXRcbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBIZWxwZXJzTHV0IHtcbiAgY29uc3RydWN0b3IoY29udGFpbmVySUQsXG4gICAgICAgICAgICAgIGx1dCA9ICdkZWZhdWx0JyxcbiAgICAgICAgICAgICAgbHV0TyA9ICdsaW5lYXInLFxuICAgICAgICAgICAgICBjb2xvciA9IFtbMCwgMCwgMCwgMF0sIFsxLCAxLCAxLCAxXV0sXG4gICAgICAgICAgICAgIG9wYWNpdHkgPSBbWzAsIDBdLCBbMSwgMV1dLFxuICAgICAgICAgICAgICBkaXNjcmV0ZSA9IGZhbHNlKSB7XG4gICAgLy8gbWluL21heCAoMC0xIG9yIHJlYWwgaW50ZW5zaXRpZXMpXG4gICAgLy8gc2hvdy9oaWRlXG4gICAgLy8gaG9yaXpvbnRhbC92ZXJ0aWNhbFxuICAgIHRoaXMuX2NvbnRhaW5lcklEID0gY29udGFpbmVySUQ7XG5cbiAgICB0aGlzLl9kaXNjcmV0ZSA9IGRpc2NyZXRlO1xuICAgIHRoaXMuX2NvbG9yID0gY29sb3I7XG4gICAgdGhpcy5fbHV0ID0gbHV0O1xuICAgIHRoaXMuX2x1dHMgPSB7W2x1dF06IGNvbG9yfTtcblxuICAgIHRoaXMuX29wYWNpdHkgPSBvcGFjaXR5O1xuICAgIHRoaXMuX2x1dE8gPSBsdXRPO1xuICAgIHRoaXMuX2x1dHNPID0ge1tsdXRPXTogb3BhY2l0eX07XG5cbiAgICB0aGlzLmluaXRDYW52YXMoKTtcbiAgICB0aGlzLnBhaW50Q2FudmFzKCk7XG4gIH1cblxuICBpbml0Q2FudmFzKCkge1xuICAgIC8vIGNvbnRhaW5lclxuICAgIHRoaXMuX2NhbnZhc0NvbnRhaW5lciA9IHRoaXMuaW5pdENhbnZhc0NvbnRhaW5lcih0aGlzLl9jb250YWluZXJJRCk7XG4gICAgLy8gYmFja2dyb3VuZFxuICAgIHRoaXMuX2NhbnZhc0JnID0gdGhpcy5jcmVhdGVDYW52YXMoKTtcbiAgICB0aGlzLl9jYW52YXNDb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5fY2FudmFzQmcpO1xuICAgIC8vIGZvcmVncm91bmRcbiAgICB0aGlzLl9jYW52YXMgPSB0aGlzLmNyZWF0ZUNhbnZhcygpO1xuICAgIHRoaXMuX2NhbnZhc0NvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLl9jYW52YXMpO1xuICB9XG5cbiAgaW5pdENhbnZhc0NvbnRhaW5lcihjYW52YXNDb250YWluZXJJZCkge1xuICAgIGxldCBjYW52YXNDb250YWluZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChjYW52YXNDb250YWluZXJJZCk7XG4gICAgY2FudmFzQ29udGFpbmVyLnN0eWxlLndpZHRoID0gJzI1NiBweCc7XG4gICAgY2FudmFzQ29udGFpbmVyLnN0eWxlLmhlaWdodCA9ICcxMjggcHgnO1xuICAgIGNhbnZhc0NvbnRhaW5lci5zdHlsZS5ib3JkZXIgPSAnMXB4IHNvbGlkICNGOUY5RjknO1xuICAgIHJldHVybiBjYW52YXNDb250YWluZXI7XG4gIH1cblxuICBjcmVhdGVDYW52YXMoKSB7XG4gICAgbGV0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgIGNhbnZhcy5oZWlnaHQgPSAxNjtcbiAgICBjYW52YXMud2lkdGggPSAyNTY7XG4gICAgcmV0dXJuIGNhbnZhcztcbiAgfVxuXG4gIHBhaW50Q2FudmFzKCkge1xuICAgIC8vIHNldHVwIGNvbnRleHRcbiAgICBsZXQgY3R4ID0gdGhpcy5fY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgY3R4LmNsZWFyUmVjdCgwLCAwLCB0aGlzLl9jYW52YXMud2lkdGgsIHRoaXMuX2NhbnZhcy5oZWlnaHQpO1xuICAgIGN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSAnc291cmNlLW92ZXInO1xuXG4gICAgLy8gYXBwbHkgY29sb3JcbiAgICBpZiAoIXRoaXMuX2Rpc2NyZXRlKSB7XG4gICAgICBsZXQgY29sb3IgPSBjdHguY3JlYXRlTGluZWFyR3JhZGllbnQoMCwgMCwgdGhpcy5fY2FudmFzLndpZHRoLCB0aGlzLl9jYW52YXMuaGVpZ2h0KTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fY29sb3IubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29sb3IuYWRkQ29sb3JTdG9wKHRoaXMuX2NvbG9yW2ldWzBdLCBgcmdiYSggJHtNYXRoLnJvdW5kKHRoaXMuX2NvbG9yW2ldWzFdICogMjU1KX0sICR7TWF0aC5yb3VuZCh0aGlzLl9jb2xvcltpXVsyXSAqIDI1NSl9LCAke01hdGgucm91bmQodGhpcy5fY29sb3JbaV1bM10gKiAyNTUpfSwgMSlgKTtcbiAgICAgIH1cblxuICAgICAgY3R4LmZpbGxTdHlsZSA9IGNvbG9yO1xuICAgICAgY3R4LmZpbGxSZWN0KDAsIDAsIHRoaXMuX2NhbnZhcy53aWR0aCwgdGhpcy5fY2FudmFzLmhlaWdodCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN0eC5saW5lV2lkdGg9Mip0aGlzLl9jYW52YXMuaGVpZ2h0O1xuXG4gICAgICBmb3IgKGxldCBpPTA7IGk8dGhpcy5fY29sb3IubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IGN1cnJlbnRQb3MgPSB0aGlzLl9jb2xvcltpXVswXTtcbiAgICAgICAgbGV0IG5leHRQb3MgPSAxO1xuICAgICAgICBpZiAoaSA8IHRoaXMuX2NvbG9yLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICBuZXh0UG9zID0gdGhpcy5fY29sb3JbaSsxXVswXTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcHJldmlvdXNQb3MgPSAwO1xuICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICBwcmV2aW91c1BvcyA9IHRoaXMuX2NvbG9yW2ktMV1bMF07XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgZnJvbSA9IHByZXZpb3VzUG9zICsgKGN1cnJlbnRQb3MgLSBwcmV2aW91c1BvcykvMjtcbiAgICAgICAgbGV0IHRvID0gY3VycmVudFBvcyArIChuZXh0UG9zIC0gY3VycmVudFBvcykvMjtcbiAgICAgICAgbGV0IGNvbG9yID0gdGhpcy5fY29sb3JbaV07XG4gICAgICAgIGxldCBvcGFjaXR5ID0gdGhpcy5fb3BhY2l0eVtpXSA/IHRoaXMuX29wYWNpdHlbaV1bMV0gOiAxO1xuXG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gYHJnYmEoICR7TWF0aC5yb3VuZChjb2xvclsxXSAqIDI1NSl9LCAke01hdGgucm91bmQoY29sb3JbMl0gKiAyNTUpfSwgJHtNYXRoLnJvdW5kKGNvbG9yWzNdICogMjU1KX0sICR7b3BhY2l0eX0pYDtcbiAgICAgICAgY3R4Lm1vdmVUbyhmcm9tKnRoaXMuX2NhbnZhcy53aWR0aCwgMCk7XG4gICAgICAgIGN0eC5saW5lVG8odG8qdGhpcy5fY2FudmFzLndpZHRoLCAwKTtcbiAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLl9kaXNjcmV0ZSkge1xuICAgICAgLy8gaWYgZGlzY3JldGUsIHdlIGFscmVhZHkgdG9vayBjYXJlIG9mIHRoZSBvcGFjaXR5LlxuICAgICAgLy8gc2V0dXAgY29udGV4dFxuICAgICAgY3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9ICdkZXN0aW5hdGlvbi1pbic7XG5cbiAgICAgIC8vIGFwcGx5IG9wYWNpdHlcbiAgICAgIGxldCBvcGFjaXR5ID0gY3R4LmNyZWF0ZUxpbmVhckdyYWRpZW50KDAsIDAsIHRoaXMuX2NhbnZhcy53aWR0aCwgdGhpcy5fY2FudmFzLmhlaWdodCk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX29wYWNpdHkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgb3BhY2l0eS5hZGRDb2xvclN0b3AodGhpcy5fb3BhY2l0eVtpXVswXSwgJ3JnYmEoMjU1LCAyNTUsIDI1NSwgJyArIHRoaXMuX29wYWNpdHlbaV1bMV0gKyAnKScpO1xuICAgICAgfVxuICAgICAgY3R4LmZpbGxTdHlsZSA9IG9wYWNpdHk7XG4gICAgICBjdHguZmlsbFJlY3QoMCwgMCwgdGhpcy5fY2FudmFzLndpZHRoLCB0aGlzLl9jYW52YXMuaGVpZ2h0KTtcbiAgICB9XG4gIH1cblxuICBnZXQgdGV4dHVyZSgpIHtcbiAgICBsZXQgdGV4dHVyZSA9IG5ldyBUSFJFRS5UZXh0dXJlKHRoaXMuX2NhbnZhcyk7XG4gICAgdGV4dHVyZS5tYXBwaW5nID0gVEhSRUUuVVZNYXBwaW5nO1xuICAgIHRleHR1cmUud3JhcFMgPSB0ZXh0dXJlLndyYXBUID0gVEhSRUUuQ2xhbXBUb0VkZ2VXcmFwcGluZztcbiAgICB0ZXh0dXJlLm1hZ0ZpbHRlciA9IHRleHR1cmUubWluRmlsdGVyID0gVEhSRUUuTmVhcmVzdEZpbHRlcjtcbiAgICB0ZXh0dXJlLnByZW11bHRpcGx5QWxwaGEgPSB0cnVlO1xuICAgIHRleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgIHJldHVybiB0ZXh0dXJlO1xuICB9XG5cbiAgc2V0IGx1dCh0YXJnZXRMVVQpIHtcbiAgICB0aGlzLl9jb2xvciA9IHRoaXMuX2x1dHNbdGFyZ2V0TFVUXTtcbiAgICB0aGlzLl9sdXQgPSB0YXJnZXRMVVQ7XG5cbiAgICB0aGlzLnBhaW50Q2FudmFzKCk7XG4gIH1cblxuICBnZXQgbHV0KCkge1xuICAgIHJldHVybiB0aGlzLl9sdXQ7XG4gIH1cblxuICBzZXQgbHV0cyhuZXdMdXRzKSB7XG4gICAgdGhpcy5fbHV0cyA9IG5ld0x1dHM7XG4gIH1cblxuICBnZXQgbHV0cygpIHtcbiAgICByZXR1cm4gdGhpcy5fbHV0cztcbiAgfVxuXG4gIHNldCBsdXRPKHRhcmdldExVVE8pIHtcbiAgICB0aGlzLl9vcGFjaXR5ID0gdGhpcy5fbHV0c09bdGFyZ2V0TFVUT107XG4gICAgdGhpcy5fbHV0TyA9IHRhcmdldExVVE87XG5cbiAgICB0aGlzLnBhaW50Q2FudmFzKCk7XG4gIH1cblxuICBnZXQgbHV0TygpIHtcbiAgICByZXR1cm4gdGhpcy5fbHV0TztcbiAgfVxuXG4gIHNldCBsdXRzTyhuZXdMdXRzTykge1xuICAgIHRoaXMuX2x1dHNPID0gbmV3THV0c087XG4gIH1cblxuICBnZXQgbHV0c08oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2x1dHNPO1xuICB9XG5cbiAgc2V0IGRpc2NyZXRlKGRpc2NyZXRlKSB7XG4gICAgdGhpcy5fZGlzY3JldGUgPSBkaXNjcmV0ZTtcblxuICAgIHRoaXMucGFpbnRDYW52YXMoKTtcbiAgfVxuXG4gIGdldCBkaXNjcmV0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGlzY3JldGU7XG4gIH1cblxuICBsdXRzQXZhaWxhYmxlKHR5cGUgPSAnY29sb3InKSB7XG4gICAgbGV0IGF2YWlsYWJsZSA9IFtdO1xuICAgIGxldCBsdXRzID0gdGhpcy5fbHV0cztcblxuICAgIGlmICh0eXBlICE9PSAnY29sb3InKSB7XG4gICAgICBsdXRzID0gdGhpcy5fbHV0c087XG4gICAgfVxuXG4gICAgZm9yIChsZXQgaSBpbiBsdXRzKSB7XG4gICAgICBhdmFpbGFibGUucHVzaChpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXZhaWxhYmxlO1xuICB9XG5cbiAgLy8gYWRkIGx1dHMgdG8gY2xhc3MnIGx1dCAoc28gYSB1c2VyIGNhbiBhZGQgaXRzIG93biBhcyB3ZWxsKVxuICBzdGF0aWMgcHJlc2V0THV0cygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgJ2RlZmF1bHQnOiBbWzAsIDAsIDAsIDBdLCBbMSwgMSwgMSwgMV1dLFxuICAgICAgJ3NwZWN0cnVtJzogW1swLCAwLCAwLCAwXSwgWzAuMSwgMCwgMCwgMV0sIFswLjMzLCAwLCAxLCAxXSwgWzAuNSwgMCwgMSwgMF0sIFswLjY2LCAxLCAxLCAwXSwgWzAuOSwgMSwgMCwgMF0sIFsxLCAxLCAxLCAxXV0sXG4gICAgICAnaG90X2FuZF9jb2xkJzogW1swLCAwLCAwLCAxXSwgWzAuMTUsIDAsIDEsIDFdLCBbMC4zLCAwLCAxLCAwXSwgWzAuNDUsIDAsIDAsIDBdLCBbMC41LCAwLCAwLCAwXSwgWzAuNTUsIDAsIDAsIDBdLCBbMC43LCAxLCAxLCAwXSwgWzAuODUsIDEsIDAsIDBdLCBbMSwgMSwgMSwgMV1dLFxuICAgICAgJ2dvbGQnOiBbWzAsIDAsIDAsIDBdLCBbMC4xMywgMC4xOSwgMC4wMywgMF0sIFswLjI1LCAwLjM5LCAwLjEyLCAwXSwgWzAuMzgsIDAuNTksIDAuMjYsIDBdLCBbMC41MCwgMC44MCwgMC40NiwgMC4wOF0sIFswLjYzLCAwLjk5LCAwLjcxLCAwLjIxXSwgWzAuNzUsIDAuOTksIDAuODgsIDAuMzRdLCBbMC44OCwgMC45OSwgMC45OSwgMC40OF0sIFsxLCAwLjkwLCAwLjk1LCAwLjYxXV0sXG4gICAgICAncmVkJzogW1swLCAwLjc1LCAwLCAwXSwgWzAuNSwgMSwgMC41LCAwXSwgWzAuOTUsIDEsIDEsIDBdLCBbMSwgMSwgMSwgMV1dLFxuICAgICAgJ2dyZWVuJzogW1swLCAwLCAwLjc1LCAwXSwgWzAuNSwgMC41LCAxLCAwXSwgWzAuOTUsIDEsIDEsIDBdLCBbMSwgMSwgMSwgMV1dLFxuICAgICAgJ2JsdWUnOiBbWzAsIDAsIDAsIDFdLCBbMC41LCAwLCAwLjUsIDFdLCBbMC45NSwgMCwgMSwgMV0sIFsxLCAxLCAxLCAxXV0sXG4gICAgICAnd2Fsa2luZ19kZWFkJzogW1swLCAwLjEsIDEsIDFdLCBbMSwgMSwgMSwgMV1dLFxuICAgICAgJ3JhbmRvbSc6IFtbMCwgMCwgMCwgMF0sIFswLjI3LCAwLjE4LCAwLjE4LCAwLjE4XSwgWzAuNDEsIDEsIDEsIDFdLCBbMC43LCAxLCAwLCAwXSwgWzEsIDEsIDEsIDFdXSxcbiAgICB9O1xuICB9XG5cbiAgc3RhdGljIHByZXNldEx1dHNPKCkge1xuICAgIHJldHVybiB7XG4gICAgICAnbGluZWFyJzogW1swLCAwXSwgWzEsIDFdXSxcbiAgICAgICdsb3dwYXNzJzogW1swLCAwLjhdLCBbMC4yLCAwLjZdLCBbMC4zLCAwLjFdLCBbMSwgMF1dLFxuICAgICAgJ2JhbmRwYXNzJzogW1swLCAwXSwgWzAuNCwgMC44XSwgWzAuNiwgMC44XSwgWzEsIDBdXSxcbiAgICAgICdoaWdocGFzcyc6IFtbMCwgMF0sIFswLjcsIDAuMV0sIFswLjgsIDAuNl0sIFsxLCAwLjhdXSxcbiAgICAgICdmbGF0JzogW1swLCAuN10sIFsxLCAxXV0sXG4gICAgICAncmFuZG9tJzogW1swLCAwLl0sIFswLjM4LCAwLl0sIFswLjU1LCAxLl0sIFswLjcyLCAxLl0sIFsxLCAwLjA1XV0sXG4gICAgfTtcbiAgfVxuXG59XG4iLCIvKipcbiAqIEhlbHBlcnMgbWF0ZXJpYWwgbWl4aW4uXG4gKlxuICogQG1vZHVsZSBoZWxwZXJzL21hdGVyaWFsL21peGluXG4gKi9cblxubGV0IEhlcmxwZXJzTWF0ZXJpYWxNaXhpbiA9IChzdXBlcmNsYXNzKSA9PiBjbGFzcyBleHRlbmRzIHN1cGVyY2xhc3Mge1xuXG4gIF9jcmVhdGVNYXRlcmlhbChleHRyYU9wdGlvbnMpIHtcbiAgICAvLyBnZW5lcmF0ZSBzaGFkZXJzIG9uLWRlbWFuZCFcbiAgICBsZXQgZnMgPSBuZXcgdGhpcy5fc2hhZGVyc0ZyYWdtZW50KHRoaXMuX3VuaWZvcm1zKTtcbiAgICBsZXQgdnMgPSBuZXcgdGhpcy5fc2hhZGVyc1ZlcnRleCgpO1xuXG4gICAgLy8gbWF0ZXJpYWxcbiAgICBsZXQgZ2xvYmFsT3B0aW9ucyA9IHtcbiAgICAgIHVuaWZvcm1zOiB0aGlzLl91bmlmb3JtcyxcbiAgICAgIHZlcnRleFNoYWRlcjogdnMuY29tcHV0ZSgpLFxuICAgICAgZnJhZ21lbnRTaGFkZXI6IGZzLmNvbXB1dGUoKSxcbiAgICB9O1xuXG4gICAgbGV0IG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKGV4dHJhT3B0aW9ucywgZ2xvYmFsT3B0aW9ucyk7XG4gICAgdGhpcy5fbWF0ZXJpYWwgPSBuZXcgVEhSRUUuU2hhZGVyTWF0ZXJpYWwob3B0aW9ucyk7XG4gICAgdGhpcy5fbWF0ZXJpYWwubmVlZHNVcGRhdGUgPSB0cnVlO1xuICB9XG5cbiAgX3VwZGF0ZU1hdGVyaWFsKCkge1xuICAgIC8vIGdlbmVyYXRlIHNoYWRlcnMgb24tZGVtYW5kIVxuICAgIGxldCBmcyA9IG5ldyB0aGlzLl9zaGFkZXJzRnJhZ21lbnQodGhpcy5fdW5pZm9ybXMpO1xuICAgIGxldCB2cyA9IG5ldyB0aGlzLl9zaGFkZXJzVmVydGV4KCk7XG5cbiAgICB0aGlzLl9tYXRlcmlhbC52ZXJ0ZXhTaGFkZXIgPSB2cy5jb21wdXRlKCk7XG4gICAgdGhpcy5fbWF0ZXJpYWwuZnJhZ21lbnRTaGFkZXIgPSBmcy5jb21wdXRlKCk7XG5cbiAgICB0aGlzLl9tYXRlcmlhbC5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gIH1cblxuICBfcHJlcGFyZVRleHR1cmUoKSB7XG4gICAgdGhpcy5fdGV4dHVyZXMgPSBbXTtcbiAgICBmb3IgKGxldCBtID0gMDsgbSA8IHRoaXMuX3N0YWNrLl9yYXdEYXRhLmxlbmd0aDsgbSsrKSB7XG4gICAgICBsZXQgdGV4ID0gbmV3IFRIUkVFLkRhdGFUZXh0dXJlKFxuICAgICAgICB0aGlzLl9zdGFjay5yYXdEYXRhW21dLFxuICAgICAgICB0aGlzLl9zdGFjay50ZXh0dXJlU2l6ZSxcbiAgICAgICAgdGhpcy5fc3RhY2sudGV4dHVyZVNpemUsXG4gICAgICAgIHRoaXMuX3N0YWNrLnRleHR1cmVUeXBlLFxuICAgICAgICBUSFJFRS5VbnNpZ25lZEJ5dGVUeXBlLFxuICAgICAgICBUSFJFRS5VVk1hcHBpbmcsXG4gICAgICAgIFRIUkVFLkNsYW1wVG9FZGdlV3JhcHBpbmcsXG4gICAgICAgIFRIUkVFLkNsYW1wVG9FZGdlV3JhcHBpbmcsXG4gICAgICAgIFRIUkVFLk5lYXJlc3RGaWx0ZXIsXG4gICAgICAgIFRIUkVFLk5lYXJlc3RGaWx0ZXIpO1xuICAgICAgdGV4Lm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgIHRleC5mbGlwWSA9IHRydWU7XG4gICAgICB0aGlzLl90ZXh0dXJlcy5wdXNoKHRleCk7XG4gICAgfVxuICB9XG5cbn07XG5cbmV4cG9ydCBkZWZhdWx0IEhlcmxwZXJzTWF0ZXJpYWxNaXhpbjtcbiIsImltcG9ydCBDb3JlVXRpbHMgZnJvbSAnLi4vY29yZS9jb3JlLnV0aWxzJztcbi8qKlxuICogRXZlbnQgQmFzZWQgcHJvZ3Jlc3NiYXJcbiAqIEBtb2R1bGUgaGVscGVycy9wcm9ncmVzc0JhclxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogbGV0IGxvYWRlciA9IG5ldyBMb2FkZXJzVm9sdW1lKCk7XG4gKiBjb25zdCBkb21Db250YWluZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncHJvZ3Jlc3NiYXInKTtcbiAqIGNvbnN0IHBiID0gbmV3IEhlbHBlcnNQcm9ncmVzc0JhckV2ZW50QmFzZWQobG9hZGVyLCBkb21Db250YWluZXIpO1xuICovXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEhlbHBlcnNQcm9ncmVzc0JhckV2ZW50QmFzZWQge1xuICBjb25zdHJ1Y3RvcihlbWl0dGVyLCBkb21UYXJnZXQpIHtcbiAgICBpZiAoIWVtaXR0ZXIgfHwgIXRoaXMuX2lzRnVuY3Rpb24oZW1pdHRlci5lbWl0KSkge1xuICAgICAgY29uc29sZS5lcnJvcigncGxlYXNlIGdpdmUgdGhlIHRoaXMuX2VtaXR0ZXIgaW5zdGFuY2UnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoQ29yZVV0aWxzLmlzU3RyaW5nKGRvbVRhcmdldCkpIHtcbiAgICAgIHRoaXMuX2RvbSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGRvbVRhcmdldCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2RvbSA9IGRvbVRhcmdldDtcbiAgICB9XG5cbiAgICBpZiAoIUNvcmVVdGlscy5pc0VsZW1lbnQodGhpcy5fZG9tKSkge1xuICAgICAgY29uc29sZS5lcnJvcigncGxlYXNlIGdpdmUgdGhlIGlkIG9mIGNvbnRhaW5lciBkb20gb3IgZGlyZWN0bHkgYSBkb20gaW5zdGFuY2UnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fZW1pdHRlciA9IGVtaXR0ZXI7XG4gICAgdGhpcy5pbml0Q29udGFpbmVyRG9tKCk7XG4gICAgdGhpcy5pbml0RXZlbnRMaXN0ZW5uZXIoKTtcbiAgICB0aGlzLmxvYWRlZCA9IDA7XG4gICAgdGhpcy50b3RhbEZpbGUgPSAwO1xuICB9XG5cbiAgX2lzRnVuY3Rpb24oZm4pIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGZuKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbiAgfVxuXG4gIGluaXRFdmVudExpc3Rlbm5lcigpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcblxuICAgIHRoaXMuX2VtaXR0ZXIub24oJ2xvYWQtc3RhcnQnLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgY29uc3QgdG90YWxGaWxlcyA9IGV2ZW50LnRvdGFsRmlsZXM7XG4gICAgICBzZWxmLnRvdGFsRmlsZSA9IHRvdGFsRmlsZXM7XG4gICAgICBzZWxmLl9kb21Ub3RhbEZpbGUuaW5uZXJIVE1MID0gdG90YWxGaWxlcztcbiAgICB9KTtcblxuICAgIHRoaXMuX2VtaXR0ZXIub24oJ2ZldGNoLXN0YXJ0JywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgIGNvbnN0IGZldGNoTGkgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsaScpO1xuXG4gICAgICBjb25zdCBmaWxlVGFnID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBmaWxlVGFnLmlubmVySFRNTCA9ICdmaWxlOiAnICsgZXZlbnQuZmlsZTtcbiAgICAgIGZpbGVUYWcuc3R5bGUuY29sb3IgPSAnI2ZmZmZmZic7XG4gICAgICBmZXRjaExpLmFwcGVuZChmaWxlVGFnKTtcblxuICAgICAgZmV0Y2hMaS5jbGFzc05hbWUgPSAnZmV0Y2gtZmlsZSc7XG4gICAgICBmZXRjaExpLmlkID0gJ2ZpbGUtJyArIGV2ZW50LmZpbGU7XG4gICAgICBmZXRjaExpLnN0eWxlLm1hcmdpbkJvdHRvbSA9ICc3cHgnO1xuICAgICAgZmV0Y2hMaS5zdHlsZS5ib3JkZXIgPSAnMXB4IHNvbGlkICNmZmZmZmY7JztcbiAgICAgIGZldGNoTGkuc3R5bGUud2lkdGggPSAnNjAlJztcbiAgICAgIGNvbnN0IGZldGNocHJvZ3Jlc3MgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIGZldGNocHJvZ3Jlc3MuaWQgPSAnZmlsZS1mZXRjaC0nICsgZXZlbnQuZmlsZTtcbiAgICAgIGZldGNocHJvZ3Jlc3Muc3R5bGUud2lkdGggPSAnMCUnO1xuICAgICAgZmV0Y2hMaS5hcHBlbmQoZmV0Y2hwcm9ncmVzcyk7XG4gICAgICBzZWxmLl9kb21Qcm9jZXNzTGlzdC5hcHBlbmQoZmV0Y2hMaSk7XG4gICAgfSk7XG5cbiAgICB0aGlzLl9lbWl0dGVyLm9uKCdmZXRjaC1wcm9ncmVzcycsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICBjb25zdCBpZCA9ICdmaWxlLWZldGNoLScgKyBldmVudC5maWxlO1xuICAgICAgY29uc3QgZmlsZUZldGNoRG9tID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpO1xuICAgICAgZmlsZUZldGNoRG9tLnN0eWxlLndpZHRoID0gKGV2ZW50LmxvYWRlZCAvIGV2ZW50LnRvdGFsKSAqIDEwMCArICclJztcbiAgICAgIGZpbGVGZXRjaERvbS5zdHlsZS5ib3JkZXIgPSAnMXB4IHNvbGlkIHJlZCc7XG4gICAgfSk7XG5cbiAgICB0aGlzLl9lbWl0dGVyLm9uKCdmZXRjaC1zdWNjZXNzJywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgIC8vIHNob3cgcmVzdWx0XG4gICAgICBjb25zdCBsaVBhcmVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdmaWxlLScgKyBldmVudC5maWxlKTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgcmVzdWx0LmlkID0gJ2ZpbGUtcmVzdWx0LScgKyBldmVudC5maWxlO1xuICAgICAgcmVzdWx0LmlubmVySFRNTCA9ICdmZXRjaC1zdWNjZXNzJztcbiAgICAgIHJlc3VsdC5zdHlsZS5jb2xvciA9ICcjZmZmZmZmJztcbiAgICAgIGxpUGFyZW50LmFwcGVuZChyZXN1bHQpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5fZW1pdHRlci5vbignZmV0Y2gtZXJyb3InLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgLy8gY29uc29sZS5sb2coZXZlbnQpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5fZW1pdHRlci5vbignZmV0Y2gtYWJvcnQnLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgLy8gY29uc29sZS5sb2coZXZlbnQpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5fZW1pdHRlci5vbignZmV0Y2gtZW5kJywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgIC8vIGNvbnNvbGUubG9nKGV2ZW50KTtcbiAgICB9KTtcblxuICAgIHRoaXMuX2VtaXR0ZXIub24oJ2ZldGNoLXRpbWVvdXQnLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgLy8gY29uc29sZS5sb2coZXZlbnQpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5fZW1pdHRlci5vbigncGFyc2Utc3RhcnQnLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgY29uc3QgbGlQYXJlbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZmlsZS0nICsgZXZlbnQuZmlsZSlcbiAgICAgIGNvbnN0IHBhcnNlcHJvZ3Jlc3MgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIHBhcnNlcHJvZ3Jlc3MuaWQgPSAnZmlsZS1wYXJzZS0nICsgZXZlbnQuZmlsZTtcbiAgICAgIHBhcnNlcHJvZ3Jlc3Muc3R5bGUud2lkdGggPSAnMCUnO1xuICAgICAgbGlQYXJlbnQuYXBwZW5kKHBhcnNlcHJvZ3Jlc3MpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5fZW1pdHRlci5vbigncGFyc2luZycsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICBjb25zdCBpZCA9ICdmaWxlLXBhcnNlLScgKyBldmVudC5maWxlO1xuICAgICAgY29uc3QgZmlsZVBhcnNlRG9tID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpO1xuICAgICAgZmlsZVBhcnNlRG9tLnN0eWxlLndpZHRoID0gKGV2ZW50LnBhcnNlZCAvIGV2ZW50LnRvdGFsKSAqIDEwMCArICclJztcbiAgICAgIGZpbGVQYXJzZURvbS5zdHlsZS5ib3JkZXIgPSAnMXB4IHNvbGlkIHllbGxvdyc7XG4gICAgfSk7XG5cbiAgICB0aGlzLl9lbWl0dGVyLm9uKCdwYXJzZS1zdWNjZXNzJywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgIHNlbGYubG9hZGVkICs9IDE7XG4gICAgICBzZWxmLl9kb21DdXJyZW50RmlsZS5pbm5lckhUTUwgPSBzZWxmLmxvYWRlZDtcbiAgICAgIHNlbGYuX2RvbUN1cnJlbnRQcm9ncmVzcy5zdHlsZS53aWR0aCA9IChzZWxmLmxvYWRlZCAvIHNlbGYudG90YWxGaWxlKSAqXG4gICAgICAgIDEwMCArICclJztcbiAgICAgIC8vIHNob3cgcmVzdWx0XG4gICAgICBjb25zdCBsaVBhcmVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdmaWxlLScgKyBldmVudC5maWxlKVxuICAgICAgY29uc3QgcmVzdWx0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICByZXN1bHQuaWQgPSAnZmlsZS1yZXN1bHQtJyArIGV2ZW50LmZpbGU7XG4gICAgICByZXN1bHQuaW5uZXJIVE1MID0gJ3BhcnNlLXN1Y2Nlc3MnO1xuICAgICAgcmVzdWx0LnN0eWxlLmNvbG9yID0gJyNmZmZmZmYnO1xuICAgICAgbGlQYXJlbnQuYXBwZW5kKHJlc3VsdCk7XG4gICAgfSk7XG4gIH1cblxuICBpbml0Q29udGFpbmVyRG9tKCkge1xuICAgIGNvbnN0IGNvbnRhaW5lckRvbSA9XG4gICAgICBcIjxkaXYgaWQ9J2FtaS1wcm9ncmVzcy1iYXItY29udGFpbmVyJyBzdHlsZT0nYmFja2dyb3VuZC1jb2xvcjogcmdiKDMzLCAzMywgMzMpOyBjb2xvcjogI2ZmZmZmZjsnPlwiICtcbiAgICAgIFwiPGRpdj5cIiArXG4gICAgICBcIjxsYWJlbCBmb3I9J3Byb2dyZXNzLWJhcicgaWQ9J3Byb2dyZXNzLWxhYmVsJyBzdHlsZT0nd2lkdGg6IDYwJTsgYm9yZGVyOiAxcHggc29saWQgI2ZmZmZmZjsgdGV4dC1hbGlnbjogY2VudGVyOyc+XCIgK1xuICAgICAgXCI8c3BhbiBpZD0nY3VycmVudC1maWxlLWluZGV4Jz4wPC9zcGFuPlwiICtcbiAgICAgIFwiL1wiICtcbiAgICAgIFwiPHNwYW4gaWQ9J3RvdGFsLWZpbGUnPjA8L3NwYW4+XCIgK1xuICAgICAgXCI8L2xhYmVsPlwiICtcbiAgICAgIFwiPGRpdiBpZD0ncHJvZ3Jlc3MtYmFyJyBzdHlsZT0nd2lkdGg6IDYwJTsgYm9yZGVyOiAxcHggc29saWQgI2ZmZmZmZjsgdGV4dC1hbGlnbjogY2VudGVyOyc+XCIgK1xuICAgICAgXCI8ZGl2IGlkPSdjdXJyZW50LXByb2dyZXNzJyBzdHlsZT0nYm9yZGVyOiAxcHggc29saWQgcmVkOyB3aWR0aDogMCU7Jz48L2Rpdj5cIiArXG4gICAgICBcIjwvZGl2PlwiICtcbiAgICAgIFwiPC9kaXY+XCIgK1xuICAgICAgXCI8dWwgaWQ9J3Byb2Nlc3MtbGlzdCcgc3R5bGU9J2xpc3Qtc3R5bGUtdHlwZTogbm9uZTsgcGFkZGluZzogMDsgb3ZlcmZsb3cteTogYXV0bzsnPlwiICtcbiAgICAgIC8vIFwiPGxpIGNsYXNzPSdmZXRjaC1maWxlJz5cIiArXG4gICAgICAvLyBcIjxkaXYgaWQ9J2ZpbGUtZmV0Y2gteHh4eHhpZCc+PC9kaXY+XCIgK1xuICAgICAgLy8gXCI8ZGl2IGlkPSdmaWxlLXBhcnNlLXh4eHh4aWQnPjwvZGl2PlwiICtcbiAgICAgIC8vIFwiPC9saT5cIiArXG4gICAgICBcIjwvdWw+XCIgK1xuICAgICAgXCI8L2Rpdj5cIjtcbiAgICBjb25zdCB3cmFwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgd3JhcC5pbm5lckhUTUwgPSBjb250YWluZXJEb207XG4gICAgdGhpcy5fZG9tLmFwcGVuZCh3cmFwKTtcbiAgICAvLyBkb20gaW50ZXJmYWNlXG4gICAgdGhpcy5fZG9tQ3VycmVudEZpbGUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY3VycmVudC1maWxlLWluZGV4Jyk7XG4gICAgdGhpcy5fZG9tVG90YWxGaWxlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3RvdGFsLWZpbGUnKTtcbiAgICB0aGlzLl9kb21Qcm9jZXNzTGlzdCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdwcm9jZXNzLWxpc3QnKTtcbiAgICB0aGlzLl9kb21DdXJyZW50UHJvZ3Jlc3MgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY3VycmVudC1wcm9ncmVzcycpO1xuICB9XG59XG4iLCJcbi8qKlxuICogQG1vZHVsZSBoZWxwZXJzL3Byb2dyZXNzQmFyXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSGVscGVyc1Byb2dyZXNzQmFyIHtcbiAgY29uc3RydWN0b3IoY29udGFpbmVyKSB7XG4gICAgdGhpcy5fY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgIHRoaXMuX21vZGVzID0ge1xuICAgICAgJ2xvYWQnOiB7XG4gICAgICAgICduYW1lJzogJ2xvYWQnLFxuICAgICAgICAnY29sb3InOiAnI0ZGRjU2RicsXG4gICAgICB9LFxuICAgICAgJ3BhcnNlJzoge1xuICAgICAgICAnbmFtZSc6ICdwYXJzZScsXG4gICAgICAgICdjb2xvcic6ICcjMjE5NkYzJyxcbiAgICAgIH0sXG4gICAgfTtcblxuICAgIHRoaXMucmVxdWVzdEFuaW1hdGlvbkZyYW1lSUQgPSBudWxsO1xuXG4gICAgdGhpcy5fbW9kZSA9IG51bGw7XG4gICAgdGhpcy5fdmFsdWUgPSBudWxsO1xuICAgIHRoaXMuX3RvdGFsID0gbnVsbDtcblxuICAgIHRoaXMuaW5pdCgpO1xuICB9XG5cbiAgZnJlZSgpIHtcbiAgICBsZXQgcHJvZ3Jlc3NDb250YWluZXJzID0gdGhpcy5fY29udGFpbmVyLmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ3Byb2dyZXNzIGNvbnRhaW5lcicpO1xuICAgIGlmIChwcm9ncmVzc0NvbnRhaW5lcnMubGVuZ3RoID4gMCkge1xuICAgICAgcHJvZ3Jlc3NDb250YWluZXJzWzBdLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQocHJvZ3Jlc3NDb250YWluZXJzWzBdKTtcbiAgICB9XG4gICAgcHJvZ3Jlc3NDb250YWluZXJzID0gbnVsbDtcbiAgICAvLyBzdG9wIHJlbmRlcmluZyBsb29wXG4gICAgd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMucmVxdWVzdEFuaW1hdGlvbkZyYW1lSUQpO1xuICB9XG5cbiAgaW5pdCgpIHtcbiAgICBsZXQgcHJvZ3Jlc3NDb250YWluZXIgPSB0aGlzLl9kb21Db250YWluZXIoKTtcblxuICAgIGZvciAobGV0IG1vZGUgaW4gdGhpcy5fbW9kZXMpIHtcbiAgICAgIGlmICh0aGlzLl9tb2Rlcy5oYXNPd25Qcm9wZXJ0eShtb2RlKSkge1xuICAgICAgICBsZXQgYmFyID0gdGhpcy5fZG9tQmFyKHRoaXMuX21vZGVzW21vZGVdKTtcbiAgICAgICAgcHJvZ3Jlc3NDb250YWluZXIuYXBwZW5kQ2hpbGQoYmFyKTtcbiAgICAgICAgYmFyID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl9jb250YWluZXIuYXBwZW5kQ2hpbGQocHJvZ3Jlc3NDb250YWluZXIpO1xuICAgIHByb2dyZXNzQ29udGFpbmVyID0gbnVsbDtcblxuICAgIC8vIHN0YXJ0IHJlbmRlcmluZyBsb29wXG4gICAgdGhpcy51cGRhdGVVSSgpO1xuICB9XG5cbiAgdXBkYXRlKHZhbHVlLCB0b3RhbCwgbW9kZSkge1xuICAgIHRoaXMuX21vZGUgPSBtb2RlO1xuICAgIHRoaXMuX3ZhbHVlID0gdmFsdWU7XG4gICAgLy8gZGVwZW5kaW5nIG9uIENETiwgdG90YWwgcmV0dXJuIHRvIFhIVFRQUmVxdWVzdCBjYW4gYmUgMC5cbiAgICAvLyBJbiB0aGlzIGNhc2UsIHdlIGdlbmVyYXRlIGEgcmFuZG9tIG51bWJlciB0byBhbmltYXRlIHRoZSBwcm9ncmVzc2JhclxuICAgIGlmICh0b3RhbCA9PT0gMCkge1xuICAgICAgdGhpcy5fdG90YWwgPSB2YWx1ZTtcbiAgICAgIHRoaXMuX3ZhbHVlID0gTWF0aC5yYW5kb20oKSp2YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fdG90YWwgPSB0b3RhbDtcbiAgICB9XG4gIH1cblxuICB1cGRhdGVVSSgpIHtcbiAgICB0aGlzLnJlcXVlc3RBbmltYXRpb25GcmFtZUlEID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+e1xuICAgICAgdGhpcy51cGRhdGVVSSgpO1xuICAgIH0pO1xuXG4gICAgaWYgKCEodGhpcy5fbW9kZXMuaGFzT3duUHJvcGVydHkodGhpcy5fbW9kZSkgJiZcbiAgICAgIHRoaXMuX21vZGVzW3RoaXMuX21vZGVdLmhhc093blByb3BlcnR5KCduYW1lJykgJiZcbiAgICAgIHRoaXMuX21vZGVzW3RoaXMuX21vZGVdLmhhc093blByb3BlcnR5KCdjb2xvcicpKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnN0IG1lc3NhZ2UgPSAnJztcbiAgICBjb25zdCBwcm9ncmVzcyA9IE1hdGgucm91bmQoKHRoaXMuX3ZhbHVlIC8gdGhpcy5fdG90YWwpICogMTAwKTtcbiAgICBjb25zdCBjb2xvciA9IHRoaXMuX21vZGVzW3RoaXMuX21vZGVdLmNvbG9yO1xuXG4gICAgbGV0IHByb2dyZXNzQmFyID0gdGhpcy5fY29udGFpbmVyLmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ3Byb2dyZXNzICcgKyB0aGlzLl9tb2Rlc1t0aGlzLl9tb2RlXS5uYW1lKTtcbiAgICBpZiAocHJvZ3Jlc3NCYXIubGVuZ3RoID4gMCkge1xuICAgICAgcHJvZ3Jlc3NCYXJbMF0uc3R5bGUuYm9yZGVyQ29sb3IgPSBjb2xvcjtcbiAgICAgIHByb2dyZXNzQmFyWzBdLnN0eWxlLndpZHRoID0gcHJvZ3Jlc3MgKyAnJSc7XG4gICAgfVxuICAgIHByb2dyZXNzQmFyID0gbnVsbDtcbiAgfVxuXG4gIF9kb21Db250YWluZXIoKSB7XG4gICAgbGV0IGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXG4gICAgLy8gY2xhc3MgaXRcbiAgICBjb250YWluZXIuY2xhc3NMaXN0LmFkZCgncHJvZ3Jlc3MnKTtcbiAgICBjb250YWluZXIuY2xhc3NMaXN0LmFkZCgnY29udGFpbmVyJyk7XG5cbiAgICAvLyBzdHlsZSBpdFxuICAgIGNvbnRhaW5lci5zdHlsZS53aWR0aCA9ICcxMDAlJztcbiAgICBjb250YWluZXIuc3R5bGUuaGVpZ2h0ID0gJzhweCc7XG4gICAgY29udGFpbmVyLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICBjb250YWluZXIuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gJ3JnYmEoMTU4LCAxNTgsIDE1OCwgMC41KSc7XG4gICAgY29udGFpbmVyLnN0eWxlLnRvcCA9ICcwJztcbiAgICBjb250YWluZXIuc3R5bGUuekluZGV4ID0gJzEnO1xuXG4gICAgcmV0dXJuIGNvbnRhaW5lcjtcbiAgfVxuXG4gIF9kb21CYXIobW9kZSkge1xuICAgIGlmICghKG1vZGUuaGFzT3duUHJvcGVydHkoJ25hbWUnKSAmJlxuICAgICAgKG1vZGUuaGFzT3duUHJvcGVydHkoJ2NvbG9yJykpKSkge1xuICAgICAgd2luZG93LmNvbnNvbGUubG9nKCdJbnZhbGlkIG1vZGUgcHJvdmlkZWQuJyk7XG4gICAgICB3aW5kb3cuY29uc29sZS5sb2cobW9kZSk7XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBsZXQgYmFyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cbiAgICAvLyBjbGFzcyBpdFxuICAgIGJhci5jbGFzc0xpc3QuYWRkKG1vZGUubmFtZSk7XG4gICAgYmFyLmNsYXNzTGlzdC5hZGQoJ3Byb2dyZXNzJyk7XG5cbiAgICAvLyBzdHlsZSBpdFxuICAgIGJhci5zdHlsZS5ib3JkZXIgPSAnMnB4IHNvbGlkICcgKyBtb2RlLmNvbG9yO1xuICAgIGJhci5zdHlsZS53aWR0aCA9ICcwJSc7XG5cbiAgICByZXR1cm4gYmFyO1xuICB9XG5cbn1cbiIsIi8qKiAqIEltcG9ydHMgKioqL1xuaW1wb3J0IEdlb21ldHJpZXNTbGljZSBmcm9tICcuLi9nZW9tZXRyaWVzL2dlb21ldHJpZXMuc2xpY2UnO1xuaW1wb3J0IFNoYWRlcnNVbmlmb3JtIGZyb20gJy4uL3NoYWRlcnMvc2hhZGVycy5kYXRhLnVuaWZvcm0nO1xuaW1wb3J0IFNoYWRlcnNWZXJ0ZXggZnJvbSAnLi4vc2hhZGVycy9zaGFkZXJzLmRhdGEudmVydGV4JztcbmltcG9ydCBTaGFkZXJzRnJhZ21lbnQgZnJvbSAnLi4vc2hhZGVycy9zaGFkZXJzLmRhdGEuZnJhZ21lbnQnO1xuXG5pbXBvcnQgSGVscGVyc01hdGVyaWFsTWl4aW4gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLm1hdGVyaWFsLm1peGluJztcblxuLyoqXG4gKiBAbW9kdWxlIGhlbHBlcnMvc2xpY2VcbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBIZWxwZXJzU2xpY2UgZXh0ZW5kcyBIZWxwZXJzTWF0ZXJpYWxNaXhpbihUSFJFRS5PYmplY3QzRCkge1xuICBjb25zdHJ1Y3RvcihzdGFjayxcbiAgICAgICAgICAgICAgaW5kZXggPSAwLFxuICAgICAgICAgICAgICBwb3NpdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKDAsIDAsIDApLFxuICAgICAgICAgICAgICBkaXJlY3Rpb24gPSBuZXcgVEhSRUUuVmVjdG9yMygwLCAwLCAxKSxcbiAgICAgICAgICAgICAgYWFiYlNwYWNlID0gJ0lKSycpIHtcbiAgICAvL1xuICAgIHN1cGVyKCk7XG5cbiAgICAvLyBwcml2YXRlIHZhcnNcbiAgICB0aGlzLl9zdGFjayA9IHN0YWNrO1xuXG4gICAgLy8gaW1hZ2Ugc2V0dGluZ3NcbiAgICAvLyBpbmRleCBvbmx5IHVzZWQgdG8gZ3JhYiB3aW5kb3cvbGV2ZWwgYW5kIGludGVyY2VwdC9zbG9wZVxuICAgIHRoaXMuX2ludmVydCA9IHRoaXMuX3N0YWNrLmludmVydDtcblxuICAgIHRoaXMuX2x1dCA9ICdub25lJztcbiAgICB0aGlzLl9sdXRUZXh0dXJlID0gbnVsbDtcbiAgICAvLyBpZiBhdXRvID09PSB0cnVlLCBnZXQgZnJvbSBpbmRleFxuICAgIC8vIGVsc2UgZnJvbSBzdGFjayB3aGljaCBob2xkcyB0aGUgZGVmYXVsdCB2YWx1ZXNcbiAgICB0aGlzLl9pbnRlbnNpdHlBdXRvID0gdHJ1ZTtcbiAgICB0aGlzLl9pbnRlcnBvbGF0aW9uID0gMTsgLy8gZGVmYXVsdCB0byB0cmlsaW5lYXIgaW50ZXJwb2xhdGlvblxuICAgIC8vIHN0YXJ0cyBhdCAwXG4gICAgdGhpcy5faW5kZXggPSBpbmRleDtcbiAgICB0aGlzLl93aW5kb3dXaWR0aCA9IG51bGw7XG4gICAgdGhpcy5fd2luZG93Q2VudGVyID0gbnVsbDtcbiAgICB0aGlzLl9yZXNjYWxlU2xvcGUgPSBudWxsO1xuICAgIHRoaXMuX3Jlc2NhbGVJbnRlcmNlcHQgPSBudWxsO1xuXG4gICAgdGhpcy5fY2FudmFzV2lkdGggPSAwO1xuICAgIHRoaXMuX2NhbnZhc0hlaWdodCA9IDA7XG4gICAgdGhpcy5fYm9yZGVyQ29sb3IgPSBudWxsO1xuXG4gICAgLy8gT2JqZWN0M0Qgc2V0dGluZ3NcbiAgICAvLyBzaGFwZVxuICAgIHRoaXMuX3BsYW5lUG9zaXRpb24gPSBwb3NpdGlvbjtcbiAgICB0aGlzLl9wbGFuZURpcmVjdGlvbiA9IGRpcmVjdGlvbjtcbiAgICAvLyBjaGFuZ2UgYWFCQlNwYWNlIGNoYW5nZXMgdGhlIGJveCBkaW1lbnNpb25zXG4gICAgLy8gYWxzbyBjaGFuZ2VzIHRoZSB0cmFuc2Zvcm1cbiAgICAvLyB0aGVyZSBpcyBhbHNvIGEgc3dpdGNoIHRvIG1vdmUgYmFjayBtZXNoIHRvIExQUyBzcGFjZSBhdXRvbWF0aWNhbGx5XG4gICAgdGhpcy5fYWFCQnNwYWNlID0gYWFiYlNwYWNlOyAvLyBvciBMUFMgLT4gZGlmZmVyZW50IHRyYW5zZm9ybXMsIGVzcCBmb3IgdGhlIGdlb21ldHJ5L21lc2hcbiAgICB0aGlzLl9tYXRlcmlhbCA9IG51bGw7XG4gICAgdGhpcy5fdGV4dHVyZXMgPSBbXTtcbiAgICB0aGlzLl9zaGFkZXJzRnJhZ21lbnQgPSBTaGFkZXJzRnJhZ21lbnQ7XG4gICAgdGhpcy5fc2hhZGVyc1ZlcnRleCA9IFNoYWRlcnNWZXJ0ZXg7XG4gICAgdGhpcy5fdW5pZm9ybXMgPSBTaGFkZXJzVW5pZm9ybS51bmlmb3JtcygpO1xuICAgIHRoaXMuX2dlb21ldHJ5ID0gbnVsbDtcbiAgICB0aGlzLl9tZXNoID0gbnVsbDtcbiAgICB0aGlzLl92aXNpYmxlID0gdHJ1ZTtcblxuICAgIC8vIHVwZGF0ZSBkaW1lbnNpb25zLCBjZW50ZXIsIGV0Yy5cbiAgICAvLyBkZXBlbmRpbmcgb24gYWFCQlNwYWNlXG4gICAgdGhpcy5faW5pdCgpO1xuXG4gICAgLy8gdXBkYXRlIG9iamVjdFxuICAgIHRoaXMuX2NyZWF0ZSgpO1xuICB9XG5cbiAgLy8gZ2V0dGVycy9zZXR0ZXJzXG5cbiAgZ2V0IHN0YWNrKCkge1xuICAgIHJldHVybiB0aGlzLl9zdGFjaztcbiAgfVxuXG4gIHNldCBzdGFjayhzdGFjaykge1xuICAgIHRoaXMuX3N0YWNrID0gc3RhY2s7XG4gIH1cblxuICBnZXQgd2luZG93V2lkdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dpbmRvd1dpZHRoO1xuICB9XG5cbiAgc2V0IHdpbmRvd1dpZHRoKHdpbmRvd1dpZHRoKSB7XG4gICAgdGhpcy5fd2luZG93V2lkdGggPSB3aW5kb3dXaWR0aDtcbiAgICB0aGlzLnVwZGF0ZUludGVuc2l0eVNldHRpbmdzVW5pZm9ybXMoKTtcbiAgfVxuXG4gIGdldCB3aW5kb3dDZW50ZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dpbmRvd0NlbnRlcjtcbiAgfVxuXG4gIHNldCB3aW5kb3dDZW50ZXIod2luZG93Q2VudGVyKSB7XG4gICAgdGhpcy5fd2luZG93Q2VudGVyID0gd2luZG93Q2VudGVyO1xuICAgIHRoaXMudXBkYXRlSW50ZW5zaXR5U2V0dGluZ3NVbmlmb3JtcygpO1xuICB9XG5cbiAgZ2V0IHJlc2NhbGVTbG9wZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVzY2FsZVNsb3BlO1xuICB9XG5cbiAgc2V0IHJlc2NhbGVTbG9wZShyZXNjYWxlU2xvcGUpIHtcbiAgICB0aGlzLl9yZXNjYWxlU2xvcGUgPSByZXNjYWxlU2xvcGU7XG4gICAgdGhpcy51cGRhdGVJbnRlbnNpdHlTZXR0aW5nc1VuaWZvcm1zKCk7XG4gIH1cblxuICBnZXQgcmVzY2FsZUludGVyY2VwdCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVzY2FsZUludGVyY2VwdDtcbiAgfVxuXG4gIHNldCByZXNjYWxlSW50ZXJjZXB0KHJlc2NhbGVJbnRlcmNlcHQpIHtcbiAgICB0aGlzLl9yZXNjYWxlSW50ZXJjZXB0ID0gcmVzY2FsZUludGVyY2VwdDtcbiAgICB0aGlzLnVwZGF0ZUludGVuc2l0eVNldHRpbmdzVW5pZm9ybXMoKTtcbiAgfVxuXG4gIGdldCBpbnZlcnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ludmVydDtcbiAgfVxuXG4gIHNldCBpbnZlcnQoaW52ZXJ0KSB7XG4gICAgdGhpcy5faW52ZXJ0ID0gaW52ZXJ0O1xuICAgIHRoaXMudXBkYXRlSW50ZW5zaXR5U2V0dGluZ3NVbmlmb3JtcygpO1xuICB9XG5cbiAgZ2V0IGx1dCgpIHtcbiAgICByZXR1cm4gdGhpcy5fbHV0O1xuICB9XG5cbiAgc2V0IGx1dChsdXQpIHtcbiAgICB0aGlzLl9sdXQgPSBsdXQ7XG4gIH1cblxuICBnZXQgbHV0VGV4dHVyZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fbHV0VGV4dHVyZTtcbiAgfVxuXG4gIHNldCBsdXRUZXh0dXJlKGx1dFRleHR1cmUpIHtcbiAgICB0aGlzLl9sdXRUZXh0dXJlID0gbHV0VGV4dHVyZTtcbiAgICB0aGlzLnVwZGF0ZUludGVuc2l0eVNldHRpbmdzVW5pZm9ybXMoKTtcbiAgfVxuXG4gIGdldCBpbnRlbnNpdHlBdXRvKCkge1xuICAgIHJldHVybiB0aGlzLl9pbnRlbnNpdHlBdXRvO1xuICB9XG5cbiAgc2V0IGludGVuc2l0eUF1dG8oaW50ZW5zaXR5QXV0bykge1xuICAgIHRoaXMuX2ludGVuc2l0eUF1dG8gPSBpbnRlbnNpdHlBdXRvO1xuICAgIHRoaXMudXBkYXRlSW50ZW5zaXR5U2V0dGluZ3MoKTtcbiAgICB0aGlzLnVwZGF0ZUludGVuc2l0eVNldHRpbmdzVW5pZm9ybXMoKTtcbiAgfVxuXG4gIGdldCBpbnRlcnBvbGF0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9pbnRlcnBvbGF0aW9uO1xuICB9XG5cbiAgc2V0IGludGVycG9sYXRpb24oaW50ZXJwb2xhdGlvbikge1xuICAgIHRoaXMuX2ludGVycG9sYXRpb24gPSBpbnRlcnBvbGF0aW9uO1xuICAgIHRoaXMudXBkYXRlSW50ZW5zaXR5U2V0dGluZ3NVbmlmb3JtcygpO1xuICAgIHRoaXMuX3VwZGF0ZU1hdGVyaWFsKCk7XG4gIH1cblxuICBnZXQgaW5kZXgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2luZGV4O1xuICB9XG5cbiAgc2V0IGluZGV4KGluZGV4KSB7XG4gICAgdGhpcy5faW5kZXggPSBpbmRleDtcbiAgICB0aGlzLl91cGRhdGUoKTtcbiAgfVxuXG4gIHNldCBwbGFuZVBvc2l0aW9uKHBvc2l0aW9uKSB7XG4gICAgdGhpcy5fcGxhbmVQb3NpdGlvbiA9IHBvc2l0aW9uO1xuICAgIHRoaXMuX3VwZGF0ZSgpO1xuICB9XG5cbiAgZ2V0IHBsYW5lUG9zaXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BsYW5lUG9zaXRpb247XG4gIH1cblxuICBzZXQgcGxhbmVEaXJlY3Rpb24oZGlyZWN0aW9uKSB7XG4gICAgdGhpcy5fcGxhbmVEaXJlY3Rpb24gPSBkaXJlY3Rpb247XG4gICAgdGhpcy5fdXBkYXRlKCk7XG4gIH1cblxuICBnZXQgcGxhbmVEaXJlY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BsYW5lRGlyZWN0aW9uO1xuICB9XG5cbiAgc2V0IGhhbGZEaW1lbnNpb25zKGhhbGZEaW1lbnNpb25zKSB7XG4gICAgdGhpcy5faGFsZkRpbWVuc2lvbnMgPSBoYWxmRGltZW5zaW9ucztcbiAgfVxuXG4gIGdldCBoYWxmRGltZW5zaW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5faGFsZkRpbWVuc2lvbnM7XG4gIH1cblxuICBzZXQgY2VudGVyKGNlbnRlcikge1xuICAgIHRoaXMuX2NlbnRlciA9IGNlbnRlcjtcbiAgfVxuXG4gIGdldCBjZW50ZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NlbnRlcjtcbiAgfVxuXG4gIHNldCBhYWJiU3BhY2UoYWFiYlNwYWNlKSB7XG4gICAgdGhpcy5fYWFCQnNwYWNlID0gYWFiYlNwYWNlO1xuICAgIHRoaXMuX2luaXQoKTtcbiAgfVxuXG4gIGdldCBhYWJiU3BhY2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FhQkJzcGFjZTtcbiAgfVxuXG4gIHNldCBtZXNoKG1lc2gpIHtcbiAgICB0aGlzLl9tZXNoID0gbWVzaDtcbiAgfVxuXG4gIGdldCBtZXNoKCkge1xuICAgIHJldHVybiB0aGlzLl9tZXNoO1xuICB9XG5cbiAgc2V0IGdlb21ldHJ5KGdlb21ldHJ5KSB7XG4gICAgdGhpcy5fZ2VvbWV0cnkgPSBnZW9tZXRyeTtcbiAgfVxuXG4gIGdldCBnZW9tZXRyeSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2VvbWV0cnk7XG4gIH1cblxuICBzZXQgY2FudmFzV2lkdGgoY2FudmFzV2lkdGgpIHtcbiAgICB0aGlzLl9jYW52YXNXaWR0aCA9IGNhbnZhc1dpZHRoO1xuICAgIHRoaXMuX3VuaWZvcm1zLnVDYW52YXNXaWR0aC52YWx1ZSA9IHRoaXMuX2NhbnZhc1dpZHRoO1xuICB9XG5cbiAgZ2V0IGNhbnZhc1dpZHRoKCkge1xuICAgIHJldHVybiB0aGlzLl9jYW52YXNXaWR0aDtcbiAgfVxuXG4gIHNldCBjYW52YXNIZWlnaHQoY2FudmFzSGVpZ2h0KSB7XG4gICAgdGhpcy5fY2FudmFzSGVpZ2h0ID0gY2FudmFzSGVpZ2h0O1xuICAgIHRoaXMuX3VuaWZvcm1zLnVDYW52YXNIZWlnaHQudmFsdWUgPSB0aGlzLl9jYW52YXNIZWlnaHQ7XG4gIH1cblxuICBnZXQgY2FudmFzSGVpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLl9jYW52YXNIZWlnaHQ7XG4gIH1cblxuICBzZXQgYm9yZGVyQ29sb3IoYm9yZGVyQ29sb3IpIHtcbiAgICB0aGlzLl9ib3JkZXJDb2xvciA9IGJvcmRlckNvbG9yO1xuICAgIHRoaXMuX3VuaWZvcm1zLnVCb3JkZXJDb2xvci52YWx1ZSA9IG5ldyBUSFJFRS5Db2xvcihib3JkZXJDb2xvcik7XG4gIH1cblxuICBnZXQgYm9yZGVyQ29sb3IoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2JvcmRlckNvbG9yO1xuICB9XG5cbiAgX2luaXQoKSB7XG4gICAgaWYgKCF0aGlzLl9zdGFjayB8fCAhdGhpcy5fc3RhY2suX3ByZXBhcmVkIHx8ICF0aGlzLl9zdGFjay5fcGFja2VkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2FhQkJzcGFjZSA9PT0gJ0lKSycpIHtcbiAgICAgIHRoaXMuX2hhbGZEaW1lbnNpb25zID0gdGhpcy5fc3RhY2suaGFsZkRpbWVuc2lvbnNJSks7XG4gICAgICB0aGlzLl9jZW50ZXIgPSBuZXcgVEhSRUUuVmVjdG9yMyhcbiAgICAgICAgdGhpcy5fc3RhY2suaGFsZkRpbWVuc2lvbnNJSksueCAtIDAuNSxcbiAgICAgICAgdGhpcy5fc3RhY2suaGFsZkRpbWVuc2lvbnNJSksueSAtIDAuNSxcbiAgICAgICAgdGhpcy5fc3RhY2suaGFsZkRpbWVuc2lvbnNJSksueiAtIDAuNSk7XG4gICAgICB0aGlzLl90b0FBQkIgPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBMUFNcbiAgICAgIGxldCBhYUJCb3ggPSB0aGlzLl9zdGFjay5BQUJCb3goKTtcbiAgICAgIHRoaXMuX2hhbGZEaW1lbnNpb25zID0gYWFCQm94LmNsb25lKCkubXVsdGlwbHlTY2FsYXIoMC41KTtcbiAgICAgIHRoaXMuX2NlbnRlciA9IHRoaXMuX3N0YWNrLmNlbnRlckFBQkJveCgpO1xuICAgICAgdGhpcy5fdG9BQUJCID0gdGhpcy5fc3RhY2subHBzMkFBQkI7XG4gICAgfVxuICB9XG5cbiAgLy8gcHJpdmF0ZSBtZXRob2RzXG4gIF9jcmVhdGUoKSB7XG4gICAgaWYgKCF0aGlzLl9zdGFjayB8fCAhdGhpcy5fc3RhY2sucHJlcGFyZWQgfHwgIXRoaXMuX3N0YWNrLnBhY2tlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIENvbnZlbmllbmNlIHZhcnNcbiAgICB0cnkge1xuICAgICAgdGhpcy5fZ2VvbWV0cnkgPSBuZXcgR2VvbWV0cmllc1NsaWNlKFxuICAgICAgICB0aGlzLl9oYWxmRGltZW5zaW9ucyxcbiAgICAgICAgdGhpcy5fY2VudGVyLFxuICAgICAgICB0aGlzLl9wbGFuZVBvc2l0aW9uLFxuICAgICAgICB0aGlzLl9wbGFuZURpcmVjdGlvbixcbiAgICAgICAgdGhpcy5fdG9BQUJCKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB3aW5kb3cuY29uc29sZS5sb2coZSk7XG4gICAgICB3aW5kb3cuY29uc29sZS5sb2coJ2ludmFsaWQgc2xpY2UgZ2VvbWV0cnkgLSBleGl0aW5nLi4uJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLl9nZW9tZXRyeS52ZXJ0aWNlcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5fbWF0ZXJpYWwpIHtcbiAgICAgIC8vXG4gICAgICB0aGlzLl91bmlmb3Jtcy51VGV4dHVyZVNpemUudmFsdWUgPSB0aGlzLl9zdGFjay50ZXh0dXJlU2l6ZTtcbiAgICAgIHRoaXMuX3VuaWZvcm1zLnVEYXRhRGltZW5zaW9ucy52YWx1ZSA9IFt0aGlzLl9zdGFjay5kaW1lbnNpb25zSUpLLngsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdGFjay5kaW1lbnNpb25zSUpLLnksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdGFjay5kaW1lbnNpb25zSUpLLnpdO1xuICAgICAgdGhpcy5fdW5pZm9ybXMudVdvcmxkVG9EYXRhLnZhbHVlID0gdGhpcy5fc3RhY2subHBzMklKSztcbiAgICAgIHRoaXMuX3VuaWZvcm1zLnVOdW1iZXJPZkNoYW5uZWxzLnZhbHVlID0gdGhpcy5fc3RhY2subnVtYmVyT2ZDaGFubmVscztcbiAgICAgIHRoaXMuX3VuaWZvcm1zLnVQaXhlbFR5cGUudmFsdWUgPSB0aGlzLl9zdGFjay5waXhlbFR5cGU7XG4gICAgICB0aGlzLl91bmlmb3Jtcy51Qml0c0FsbG9jYXRlZC52YWx1ZSA9IHRoaXMuX3N0YWNrLmJpdHNBbGxvY2F0ZWQ7XG4gICAgICB0aGlzLl91bmlmb3Jtcy51UGFja2VkUGVyUGl4ZWwudmFsdWUgPSB0aGlzLl9zdGFjay5wYWNrZWRQZXJQaXhlbDtcbiAgICAgIC8vIGNvbXB1dGUgdGV4dHVyZSBpZiBtYXRlcmlhbCBleGlzdFxuICAgICAgdGhpcy5fcHJlcGFyZVRleHR1cmUoKTtcbiAgICAgIHRoaXMuX3VuaWZvcm1zLnVUZXh0dXJlQ29udGFpbmVyLnZhbHVlID0gdGhpcy5fdGV4dHVyZXM7XG5cbiAgICAgIHRoaXMuX2NyZWF0ZU1hdGVyaWFsKHtcbiAgICAgICAgc2lkZTogVEhSRUUuRG91YmxlU2lkZSxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIHVwZGF0ZSBpbnRlbnNpdHkgcmVsYXRlZCBzdHVmZlxuICAgIHRoaXMudXBkYXRlSW50ZW5zaXR5U2V0dGluZ3MoKTtcbiAgICB0aGlzLnVwZGF0ZUludGVuc2l0eVNldHRpbmdzVW5pZm9ybXMoKTtcblxuICAgIC8vIGNyZWF0ZSB0aGUgbWVzaCFcbiAgICB0aGlzLl9tZXNoID0gbmV3IFRIUkVFLk1lc2godGhpcy5fZ2VvbWV0cnksIHRoaXMuX21hdGVyaWFsKTtcbiAgICBpZiAodGhpcy5fYWFCQnNwYWNlID09PSAnSUpLJykge1xuICAgICAgdGhpcy5fbWVzaC5hcHBseU1hdHJpeCh0aGlzLl9zdGFjay5pamsyTFBTKTtcbiAgICB9XG5cbiAgICB0aGlzLl9tZXNoLnZpc2libGUgPSB0aGlzLl92aXNpYmxlO1xuXG4gICAgLy8gYW5kIGFkZCBpdCFcbiAgICB0aGlzLmFkZCh0aGlzLl9tZXNoKTtcbiAgfVxuXG4gIHVwZGF0ZUludGVuc2l0eVNldHRpbmdzKCkge1xuICAgIC8vIGlmIGF1dG8sIGdldCBmcm9tIGZyYW1lIGluZGV4XG4gICAgaWYgKHRoaXMuX2ludGVuc2l0eUF1dG8pIHtcbiAgICAgIHRoaXMudXBkYXRlSW50ZW5zaXR5U2V0dGluZygnd2luZG93Q2VudGVyJyk7XG4gICAgICB0aGlzLnVwZGF0ZUludGVuc2l0eVNldHRpbmcoJ3dpbmRvd1dpZHRoJyk7XG4gICAgICB0aGlzLnVwZGF0ZUludGVuc2l0eVNldHRpbmcoJ3Jlc2NhbGVTbG9wZScpO1xuICAgICAgdGhpcy51cGRhdGVJbnRlbnNpdHlTZXR0aW5nKCdyZXNjYWxlSW50ZXJjZXB0Jyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0aGlzLl93aW5kb3dDZW50ZXIgPT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5fd2luZG93Q2VudGVyID0gdGhpcy5fc3RhY2sud2luZG93Q2VudGVyO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5fX3dpbmRvd1dpZHRoID09PSBudWxsKSB7XG4gICAgICAgIHRoaXMuX3dpbmRvd1dpZHRoID0gdGhpcy5fc3RhY2sud2luZG93V2lkdGg7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9yZXNjYWxlU2xvcGUgPT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5fcmVzY2FsZVNsb3BlID0gdGhpcy5fc3RhY2sucmVzY2FsZVNsb3BlO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5fcmVzY2FsZUludGVyY2VwdCA9PT0gbnVsbCkge1xuICAgICAgICB0aGlzLl9yZXNjYWxlSW50ZXJjZXB0ID0gdGhpcy5fc3RhY2sucmVzY2FsZUludGVyY2VwdDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB1cGRhdGVJbnRlbnNpdHlTZXR0aW5nc1VuaWZvcm1zKCkge1xuICAgIC8vIGNvbXBlbnNhdGUgZm9yIHRoZSBvZmZzZXQgdG8gb25seSBwYXNzID4gMCB2YWx1ZXMgdG8gc2hhZGVyc1xuICAgIC8vIG1vZGVscyA+IG1vZGVscy5zdGFjay5qcyA6IF9wYWNrVG84Qml0c1xuICAgIGxldCBvZmZzZXQgPSAwO1xuICAgIGlmICh0aGlzLl9zdGFjay5fbWluTWF4WzBdIDwgMCkge1xuICAgICAgb2Zmc2V0IC09IHRoaXMuX3N0YWNrLl9taW5NYXhbMF07XG4gICAgfVxuXG4gICAgLy8gc2V0IHNsaWNlIHdpbmRvdyBjZW50ZXIgYW5kIHdpZHRoXG4gICAgdGhpcy5fdW5pZm9ybXMudVJlc2NhbGVTbG9wZUludGVyY2VwdC52YWx1ZSA9XG4gICAgICBbdGhpcy5fcmVzY2FsZVNsb3BlLCB0aGlzLl9yZXNjYWxlSW50ZXJjZXB0XTtcbiAgICB0aGlzLl91bmlmb3Jtcy51V2luZG93Q2VudGVyV2lkdGgudmFsdWUgPVxuICAgICAgW29mZnNldCArIHRoaXMuX3dpbmRvd0NlbnRlciwgdGhpcy5fd2luZG93V2lkdGhdO1xuXG4gICAgLy8gaW52ZXJ0XG4gICAgdGhpcy5fdW5pZm9ybXMudUludmVydC52YWx1ZSA9IHRoaXMuX2ludmVydCA9PT0gdHJ1ZSA/IDEgOiAwO1xuXG4gICAgLy8gaW50ZXJwb2xhdGlvblxuICAgIHRoaXMuX3VuaWZvcm1zLnVJbnRlcnBvbGF0aW9uLnZhbHVlID0gdGhpcy5faW50ZXJwb2xhdGlvbjtcblxuICAgIC8vIGx1dFxuICAgIGlmICh0aGlzLl9sdXQgPT09ICdub25lJykge1xuICAgICAgdGhpcy5fdW5pZm9ybXMudUx1dC52YWx1ZSA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3VuaWZvcm1zLnVMdXQudmFsdWUgPSAxO1xuICAgICAgdGhpcy5fdW5pZm9ybXMudVRleHR1cmVMVVQudmFsdWUgPSB0aGlzLl9sdXRUZXh0dXJlO1xuICAgIH1cbiAgfVxuXG4gIHVwZGF0ZUludGVuc2l0eVNldHRpbmcoc2V0dGluZykge1xuICAgIGlmICh0aGlzLl9zdGFjay5mcmFtZVt0aGlzLl9pbmRleF0gJiZcbiAgICAgICAgdGhpcy5fc3RhY2suZnJhbWVbdGhpcy5faW5kZXhdW3NldHRpbmddKSB7XG4gICAgICB0aGlzWydfJyArIHNldHRpbmddID0gdGhpcy5fc3RhY2suZnJhbWVbdGhpcy5faW5kZXhdW3NldHRpbmddO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzWydfJyArIHNldHRpbmddID0gdGhpcy5fc3RhY2tbc2V0dGluZ107XG4gICAgfVxuICB9XG5cbiAgX3VwZGF0ZSgpIHtcbiAgICAvLyB1cGRhdGUgc2xpY2VcbiAgICBpZiAodGhpcy5fbWVzaCkge1xuICAgICAgdGhpcy5yZW1vdmUodGhpcy5fbWVzaCk7XG4gICAgICB0aGlzLl9tZXNoLmdlb21ldHJ5LmRpc3Bvc2UoKTtcbiAgICAgIHRoaXMuX21lc2guZ2VvbWV0cnkgPSBudWxsO1xuICAgICAgLy8gd2UgZG8gbm90IHdhbnQgdG8gZGlzcG9zZSB0aGUgdGV4dHVyZSFcbiAgICAgIC8vIHRoaXMuX21lc2gubWF0ZXJpYWwuZGlzcG9zZSgpO1xuICAgICAgLy8gdGhpcy5fbWVzaC5tYXRlcmlhbCA9IG51bGw7XG4gICAgICB0aGlzLl9tZXNoID0gbnVsbDtcbiAgICB9XG5cbiAgICB0aGlzLl9jcmVhdGUoKTtcbiAgfVxuXG4gIGRpc3Bvc2UoKSB7XG4gICAgLy8gUmVsZWFzZSBtZW1vcnlcbiAgICBmb3IodmFyIGogPTA7IGo8IHRoaXMuX3RleHR1cmVzLmxlbmd0aDsgaisrKSB7XG4gICAgICB0aGlzLl90ZXh0dXJlc1tqXS5kaXNwb3NlKCk7XG4gICAgICB0aGlzLl90ZXh0dXJlc1tqXSA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMuX3RleHR1cmVzID0gbnVsbDtcbiAgICB0aGlzLl9zaGFkZXJzRnJhZ21lbnQgPSBudWxsO1xuICAgIHRoaXMuX3NoYWRlcnNWZXJ0ZXggPSBudWxsO1xuXG4gICAgdGhpcy5fdW5pZm9ybXMgPSBudWxsO1xuXG4gICAgLy8gbWF0ZXJpYWwsIGdlb21ldHJ5IGFuZCBtZXNoXG4gICAgdGhpcy5yZW1vdmUodGhpcy5fbWVzaCk7XG4gICAgdGhpcy5fbWVzaC5nZW9tZXRyeS5kaXNwb3NlKCk7XG4gICAgdGhpcy5fbWVzaC5nZW9tZXRyeSA9IG51bGw7XG4gICAgdGhpcy5fbWVzaC5tYXRlcmlhbC5kaXNwb3NlKCk7XG4gICAgdGhpcy5fbWVzaC5tYXRlcmlhbCA9IG51bGw7XG4gICAgdGhpcy5fbWVzaCA9IG51bGw7XG5cbiAgICB0aGlzLl9nZW9tZXRyeS5kaXNwb3NlKCk7XG4gICAgdGhpcy5fZ2VvbWV0cnkgPSBudWxsO1xuICAgIHRoaXMuX21hdGVyaWFsLnZlcnRleFNoYWRlciA9IG51bGw7XG4gICAgdGhpcy5fbWF0ZXJpYWwuZnJhZ21lbnRTaGFkZXIgPSBudWxsO1xuICAgIHRoaXMuX21hdGVyaWFsLnVuaWZvcm1zID0gbnVsbDtcbiAgICB0aGlzLl9tYXRlcmlhbC5kaXNwb3NlKCk7XG4gICAgdGhpcy5fbWF0ZXJpYWwgPSBudWxsO1xuXG4gICAgdGhpcy5fc3RhY2sgPSBudWxsO1xuICB9XG5cbiAgY2FydGVzaWFuRXF1YXRpb24oKSB7XG4gICAgLy8gTWFrZSBzdXJlIHdlIGhhdmUgYSBnZW9tZXRyeVxuICAgIGlmICghdGhpcy5fZ2VvbWV0cnkgfHxcbiAgICAgICAhdGhpcy5fZ2VvbWV0cnkudmVydGljZXMgfHxcbiAgICAgICB0aGlzLl9nZW9tZXRyeS52ZXJ0aWNlcy5sZW5ndGggPCAzKSB7XG4gICAgICByZXR1cm4gbmV3IFRIUkVFLlZlY3RvcjQoKTtcbiAgICB9XG5cbiAgICBsZXQgdmVydGljZXMgPSB0aGlzLl9nZW9tZXRyeS52ZXJ0aWNlcztcbiAgICBsZXQgZGF0YVRvV29ybGQgPSB0aGlzLl9zdGFjay5pamsyTFBTO1xuICAgIGxldCBwMSA9IG5ldyBUSFJFRS5WZWN0b3IzKHZlcnRpY2VzWzBdLngsIHZlcnRpY2VzWzBdLnksIHZlcnRpY2VzWzBdLnopXG4gICAgICAuYXBwbHlNYXRyaXg0KGRhdGFUb1dvcmxkKTtcbiAgICBsZXQgcDIgPSBuZXcgVEhSRUUuVmVjdG9yMyh2ZXJ0aWNlc1sxXS54LCB2ZXJ0aWNlc1sxXS55LCB2ZXJ0aWNlc1sxXS56KVxuICAgICAgLmFwcGx5TWF0cml4NChkYXRhVG9Xb3JsZCk7XG4gICAgbGV0IHAzID0gbmV3IFRIUkVFLlZlY3RvcjModmVydGljZXNbMl0ueCwgdmVydGljZXNbMl0ueSwgdmVydGljZXNbMl0ueilcbiAgICAgIC5hcHBseU1hdHJpeDQoZGF0YVRvV29ybGQpO1xuICAgIGxldCB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cdFx0bGV0IHYyID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICBsZXQgbm9ybWFsID0gdjFcbiAgICAgIC5zdWJWZWN0b3JzKHAzLCBwMilcbiAgICAgIC5jcm9zcyh2Mi5zdWJWZWN0b3JzKHAxLCBwMikpXG4gICAgICAubm9ybWFsaXplKCk7XG5cbiAgICByZXR1cm4gbmV3IFRIUkVFLlZlY3RvcjQoXG4gICAgICBub3JtYWwueCxcbiAgICAgIG5vcm1hbC55LFxuICAgICAgbm9ybWFsLnosXG4gICAgICAtIG5vcm1hbC5kb3QocDEpXG4gICAgKTtcbiAgfVxufVxuIiwiLyoqICogSW1wb3J0cyAqKiovXG5pbXBvcnQgSGVscGVyc0JvcmRlciBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuYm9yZGVyJztcbmltcG9ydCBIZWxwZXJzQm91bmRpbmdCb3ggZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmJvdW5kaW5nYm94JztcbmltcG9ydCBIZWxwZXJzU2xpY2UgZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLnNsaWNlJztcblxuLyoqXG4gKiBIZWxwZXIgdG8gZWFzaWx5IGRpc3BsYXkgYW5kIGludGVyYWN0IHdpdGggYSBzdGFjay48YnI+XG4gKjxicj5cbiAqIERlZmF1bHRzOjxicj5cbiAqICAgLSBvcmllbnRhdGlvbjogMCAoYWNxdWlzaXRpb24gZGlyZWN0aW9uKTxicj5cbiAqICAgLSBpbmRleDogbWlkZGxlIHNsaWNlIGluIGFjcXVpc2l0aW9uIGRpcmVjdGlvbjxicj5cbiAqPGJyPlxuICogRmVhdHVyZXM6PGJyPlxuICogICAtIHNsaWNlIGZyb20gdGhlIHN0YWNrIChpbiBhbnkgZGlyZWN0aW9uKTxicj5cbiAqICAgLSBzbGljZSBib3JkZXI8YnI+XG4gKiAgIC0gc3RhY2sgYm91bmRpbmcgYm94PGJyPlxuICo8YnI+XG4gKiBMaXZlIGRlbW8gYXQ6IHtAbGluayBodHRwOi8vanNmaWRkbGUubmV0L2doL2dldC9saWJyYXJ5L3B1cmUvZm5uZHNjL2FtaS90cmVlL21hc3Rlci9sZXNzb25zLzAxI3J1bnxMZXNzb24gMDF9XG4gKlxuICogQGV4YW1wbGVcbiAqIGxldCBzdGFjayA9IG5ldyBWSlMuTW9kZWxzLlN0YWNrKCk7XG4gKiAuLi4gLy8gcHJlcGFyZSB0aGUgc3RhY2tcbiAqXG4gKiBsZXQgc3RhY2tIZWxwZXIgPSBuZXcgVkpTLkhlbHBlcnMuU3RhY2soc3RhY2spO1xuICogc3RhY2tIZWxwZXIuYmJveC5jb2xvciA9IDB4RjlGOUY5O1xuICogc3RhY2tIZWxwZXIuYm9yZGVyLmNvbG9yID0gMHhGOUY5Rjk7XG4gKlxuICogbGV0IHNjZW5lID0gbmV3IFRIUkVFLlNjZW5lKCk7XG4gKiBzY2VuZS5hZGQoc3RhY2tIZWxwZXIpO1xuICpcbiAqIEBleHRlbmRzIFRIUkVFLk9iamVjdDNEXG4gKlxuICogQHNlZSBtb2R1bGU6aGVscGVycy9ib3JkZXJcbiAqIEBzZWUgbW9kdWxlOmhlbHBlcnMvYm91bmRpbmdib3hcbiAqIEBzZWUgbW9kdWxlOmhlbHBlcnMvc2xpY2VcbiAqXG4gKiBAbW9kdWxlIGhlbHBlcnMvc3RhY2tcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSGVscGVyc1N0YWNrIGV4dGVuZHMgVEhSRUUuT2JqZWN0M0Qge1xuICBjb25zdHJ1Y3RvcihzdGFjaykge1xuICAgIC8vXG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMuX3N0YWNrID0gc3RhY2s7XG4gICAgdGhpcy5fYkJveCA9IG51bGw7XG4gICAgdGhpcy5fc2xpY2UgPSBudWxsO1xuICAgIHRoaXMuX2JvcmRlciA9IG51bGw7XG4gICAgdGhpcy5fZHVtbXkgPSBudWxsO1xuXG4gICAgdGhpcy5fb3JpZW50YXRpb24gPSAwO1xuICAgIHRoaXMuX2luZGV4ID0gMDtcblxuICAgIHRoaXMuX3VuaWZvcm1zID0gbnVsbDtcbiAgICB0aGlzLl9hdXRvV2luZG93TGV2ZWwgPSBmYWxzZTtcbiAgICB0aGlzLl9vdXRPZkJvdW5kcyA9IGZhbHNlO1xuICAgIHRoaXMuX29yaWVudGF0aW9uTWF4SW5kZXggPSAwO1xuXG4gICAgdGhpcy5fY2FudmFzV2lkdGggPSAwO1xuICAgIHRoaXMuX2NhbnZhc0hlaWdodCA9IDA7XG4gICAgdGhpcy5fYm9yZGVyQ29sb3IgPSBudWxsO1xuXG5cbiAgICAvLyB0aGlzLl9hcnJvdyA9IHtcbiAgICAvLyAgIHZpc2libGU6IHRydWUsXG4gICAgLy8gICBjb2xvcjogMHhGRkYzMzYsXG4gICAgLy8gICBsZW5ndGg6IDIwLFxuICAgIC8vICAgbWF0ZXJpYWw6IG51bGwsXG4gICAgLy8gICBnZW9tZXRyeTogbnVsbCxcbiAgICAvLyAgIG1lc2g6IG51bGxcbiAgICAvLyB9O1xuICAgIHRoaXMuX2NyZWF0ZSgpO1xuICB9XG5cbiAgLy9cbiAgLy8gUFVCTElDIE1FVEhPRFNcbiAgLy9cblxuICAvL1xuICAvLyBTRVRURVJTL0dFVFRFUlNcbiAgLy9cblxuICAvKipcbiAgICogR2V0IHN0YWNrLlxuICAgKlxuICAgKiBAdHlwZSB7TW9kZWxzU3RhY2t9XG4gICAqL1xuICBnZXQgc3RhY2soKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0YWNrO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCBzdGFjay5cbiAgICpcbiAgICogQHR5cGUge01vZGVsc1N0YWNrfVxuICAgKi9cbiAgc2V0IHN0YWNrKHN0YWNrKSB7XG4gICAgdGhpcy5fc3RhY2sgPSBzdGFjaztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYm91bmRpbmcgYm94IGhlbHBlci5cbiAgICpcbiAgICogQHR5cGUge0hlbHBlcnNCb3VuZGluZ0JveH1cbiAgICovXG4gIGdldCBiYm94KCkge1xuICAgIHJldHVybiB0aGlzLl9iQm94O1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBzbGljZSBoZWxwZXIuXG4gICAqXG4gICAqIEB0eXBlIHtIZWxwZXJzU2xpY2V9XG4gICAqL1xuICBnZXQgc2xpY2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NsaWNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBib3JkZXIgaGVscGVyLlxuICAgKlxuICAgKiBAdHlwZSB7SGVscGVyc1NsaWNlfVxuICAgKi9cbiAgZ2V0IGJvcmRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5fYm9yZGVyO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldC9nZXQgY3VycmVudCBzbGljZSBpbmRleC48YnI+XG4gICAqIFNldHMgb3V0T2ZCb3VuZHMgZmxhZyB0byBrbm93IGlmIHRhcmdldCBpbmRleCBpcyBpbi9vdXQgc3RhY2sgYm91bmRpbmcgYm94Ljxicj5cbiAgICogPGJyPlxuICAgKiBJbnRlcm5hbGx5IHVwZGF0ZXMgdGhlIHNsaWNlSGVscGVyIGluZGV4IGFuZCBwb3NpdGlvbi4gQWxzbyB1cGRhdGVzIHRoZVxuICAgKiBib3JkZXJIZWxwZXIgd2l0aCB0aGUgdXBkYXRlZCBzbGljZUhlbHBlci5cbiAgICpcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCBpbmRleCgpIHtcbiAgICByZXR1cm4gdGhpcy5faW5kZXg7XG4gIH1cblxuICBzZXQgaW5kZXgoaW5kZXgpIHtcbiAgICB0aGlzLl9pbmRleCA9IGluZGV4O1xuXG4gICAgLy8gdXBkYXRlIHRoZSBzbGljZVxuICAgIHRoaXMuX3NsaWNlLmluZGV4ID0gaW5kZXg7XG4gICAgbGV0IGhhbGZEaW1lbnNpb25zID0gdGhpcy5fc3RhY2suaGFsZkRpbWVuc2lvbnNJSks7XG4gICAgdGhpcy5fc2xpY2UucGxhbmVQb3NpdGlvbiA9IHRoaXMuX3ByZXBhcmVTbGljZVBvc2l0aW9uKGhhbGZEaW1lbnNpb25zLCB0aGlzLl9pbmRleCk7XG5cbiAgICAvLyBhbHNvIHVwZGF0ZSB0aGUgYm9yZGVyXG4gICAgdGhpcy5fYm9yZGVyLmhlbHBlcnNTbGljZSA9IHRoaXMuX3NsaWNlO1xuXG4gICAgLy8gdXBkYXRlIG91ck9mQm91bmRzIGZsYWdcbiAgICB0aGlzLl9pc0luZGV4T3V0T2ZCb3VuZHMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQvZ2V0IGN1cnJlbnQgc2xpY2Ugb3JpZW50YXRpb24uPGJyPlxuICAgKiBWYWx1ZXM6IDxicj5cbiAgICogICAtIDA6IGFjcXVpc2l0aW9uIGRpcmVjdGlvbiAoc2xpY2Ugbm9ybWFsIGlzIHpfY29zaW5lKTxicj5cbiAgICogICAtIDE6IG5leHQgZGlyZWN0aW9uIChzbGljZSBub3JtYWwgaXMgeF9jb3NpbmUpPGJyPlxuICAgKiAgIC0gMjogbmV4dCBkaXJlY3Rpb24gKHNsaWNlIG5vcm1hbCBpcyB5X2Nvc2luZSk8YnI+XG4gICAqICAgLSBuOiBzZXQgb3JpZW50YXRpb24gdG8gMDxicj5cbiAgICogPGJyPlxuICAgKiBJbnRlcm5hbGx5IHVwZGF0ZXMgdGhlIHNsaWNlSGVscGVyIGRpcmVjdGlvbi4gQWxzbyB1cGRhdGVzIHRoZVxuICAgKiBib3JkZXJIZWxwZXIgd2l0aCB0aGUgdXBkYXRlZCBzbGljZUhlbHBlci5cbiAgICpcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIHNldCBvcmllbnRhdGlvbihvcmllbnRhdGlvbikge1xuICAgIHRoaXMuX29yaWVudGF0aW9uID0gb3JpZW50YXRpb247XG4gICAgdGhpcy5fY29tcHV0ZU9yaWVudGF0aW9uTWF4SW5kZXgoKTtcblxuICAgIHRoaXMuX3NsaWNlLnBsYW5lRGlyZWN0aW9uID0gdGhpcy5fcHJlcGFyZURpcmVjdGlvbih0aGlzLl9vcmllbnRhdGlvbik7XG5cbiAgICAvLyBhbHNvIHVwZGF0ZSB0aGUgYm9yZGVyXG4gICAgdGhpcy5fYm9yZGVyLmhlbHBlcnNTbGljZSA9IHRoaXMuX3NsaWNlO1xuICB9XG5cbiAgZ2V0IG9yaWVudGF0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9vcmllbnRhdGlvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQvZ2V0IHRoZSBvdXRPZkJvdW5kIGZsYWcuXG4gICAqXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cbiAgc2V0IG91dE9mQm91bmRzKG91dE9mQm91bmRzKSB7XG4gICAgdGhpcy5fb3V0T2ZCb3VuZHMgPSBvdXRPZkJvdW5kcztcbiAgfVxuXG4gIGdldCBvdXRPZkJvdW5kcygpIHtcbiAgICByZXR1cm4gdGhpcy5fb3V0T2ZCb3VuZHM7XG4gIH1cblxuICAvKipcbiAgICogU2V0L2dldCB0aGUgb3JpZW50YXRpb25NYXhJbmRleCBmbGFnLlxuICAgKlxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICovXG4gIHNldCBvcmllbnRhdGlvbk1heEluZGV4KG9yaWVudGF0aW9uTWF4SW5kZXgpIHtcbiAgICB0aGlzLl9vcmllbnRhdGlvbk1heEluZGV4ID0gb3JpZW50YXRpb25NYXhJbmRleDtcbiAgfVxuXG4gIGdldCBvcmllbnRhdGlvbk1heEluZGV4KCkge1xuICAgIHJldHVybiB0aGlzLl9vcmllbnRhdGlvbk1heEluZGV4O1xuICB9XG5cbiAgc2V0IGNhbnZhc1dpZHRoKGNhbnZhc1dpZHRoKSB7XG4gICAgdGhpcy5fY2FudmFzV2lkdGggPSBjYW52YXNXaWR0aDtcbiAgICB0aGlzLl9zbGljZS5jYW52YXNXaWR0aCA9IHRoaXMuX2NhbnZhc1dpZHRoO1xuICB9XG5cbiAgZ2V0IGNhbnZhc1dpZHRoKCkge1xuICAgIHJldHVybiB0aGlzLl9jYW52YXNXaWR0aDtcbiAgfVxuXG4gIHNldCBjYW52YXNIZWlnaHQoY2FudmFzSGVpZ2h0KSB7XG4gICAgdGhpcy5fY2FudmFzSGVpZ2h0ID0gY2FudmFzSGVpZ2h0O1xuICAgIHRoaXMuX3NsaWNlLmNhbnZhc0hlaWdodCA9IHRoaXMuX2NhbnZhc0hlaWdodDtcbiAgfVxuXG4gIGdldCBjYW52YXNIZWlnaHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhbnZhc0hlaWdodDtcbiAgfVxuXG4gIHNldCBib3JkZXJDb2xvcihib3JkZXJDb2xvcikge1xuICAgIHRoaXMuX2JvcmRlckNvbG9yID0gYm9yZGVyQ29sb3I7XG4gICAgdGhpcy5fYm9yZGVyLmNvbG9yID0gYm9yZGVyQ29sb3I7XG4gICAgdGhpcy5fc2xpY2UuYm9yZGVyQ29sb3IgPSB0aGlzLl9ib3JkZXJDb2xvcjtcbiAgfVxuXG4gIGdldCBib3JkZXJDb2xvcigpIHtcbiAgICByZXR1cm4gdGhpcy5fYm9yZGVyQ29sb3I7XG4gIH1cblxuICAvL1xuICAvLyBQUklWQVRFIE1FVEhPRFNcbiAgLy9cblxuICAvKipcbiAgICogSW5pdGlhbCBzZXR1cCwgaW5jbHVkaW5nIHN0YWNrIHByZXBhcmUsIGJib3ggcHJlcGFyZSwgc2xpY2UgcHJlcGFyZSBhbmRcbiAgICogYm9yZGVyIHByZXBhcmUuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfY3JlYXRlKCkge1xuICAgIGlmICh0aGlzLl9zdGFjaykge1xuICAgICAgLy8gcHJlcGFyZSBzdGhlIHN0YWNrIGludGVybmFsc1xuICAgICAgdGhpcy5fcHJlcGFyZVN0YWNrKCk7XG5cbiAgICAgIC8vIHByZXBhcmUgdmlzdWFsIG9iamVjdHNcbiAgICAgIHRoaXMuX3ByZXBhcmVCQm94KCk7XG4gICAgICB0aGlzLl9wcmVwYXJlU2xpY2UoKTtcbiAgICAgIHRoaXMuX3ByZXBhcmVCb3JkZXIoKTtcbiAgICAgIC8vIHRvZG86IEFycm93XG4gICAgfSBlbHNlIHtcbiAgICAgIHdpbmRvdy5jb25zb2xlLmxvZygnbm8gc3RhY2sgdG8gYmUgcHJlcGFyZWQuLi4nKTtcbiAgICB9XG4gIH1cblxuICBfY29tcHV0ZU9yaWVudGF0aW9uTWF4SW5kZXgoKSB7XG4gICAgbGV0IGRpbWVuc2lvbnNJSksgPSB0aGlzLl9zdGFjay5kaW1lbnNpb25zSUpLO1xuICAgIHRoaXMuX29yaWVudGF0aW9uTWF4SW5kZXggPSAwO1xuICAgIHN3aXRjaCAodGhpcy5fb3JpZW50YXRpb24pIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgdGhpcy5fb3JpZW50YXRpb25NYXhJbmRleCA9IGRpbWVuc2lvbnNJSksueiAtIDE7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxOlxuICAgICAgICB0aGlzLl9vcmllbnRhdGlvbk1heEluZGV4ID0gZGltZW5zaW9uc0lKSy54IC0gMTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIHRoaXMuX29yaWVudGF0aW9uTWF4SW5kZXggPSBkaW1lbnNpb25zSUpLLnkgLSAxO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIC8vIGRvIG5vdGhpbmchXG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHaXZlbiBvcmllbnRhdGlvbiwgY2hlY2sgaWYgaW5kZXggaXMgaW4vb3V0IG9mIGJvdW5kcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9pc0luZGV4T3V0T2ZCb3VuZHMoKSB7XG4gICAgdGhpcy5fY29tcHV0ZU9yaWVudGF0aW9uTWF4SW5kZXgoKTtcbiAgICBpZiAodGhpcy5faW5kZXggPj0gdGhpcy5fb3JpZW50YXRpb25NYXhJbmRleCB8fCB0aGlzLl9pbmRleCA8IDApIHtcbiAgICAgIHRoaXMuX291dE9mQm91bmRzID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fb3V0T2ZCb3VuZHMgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUHJlcGFyZSBhIHN0YWNrIGZvciB2aXN1YWxpemF0aW9uLiAoaW1hZ2UgdG8gd29ybGQgdHJhbnNmb3JtLCBmcmFtZXMgb3JkZXIsXG4gICAqIHBhY2sgZGF0YSBpbnRvIDggYml0cyB0ZXh0dXJlcywgZXRjLilcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9wcmVwYXJlU3RhY2soKSB7XG4gICAgLy8gbWFrZSBzdXJlIHRoZXJlIGlzIHNvbWV0aGluZywgaWYgbm90IHRocm93IGFuIGVycm9yXG4gICAgLy8gY29tcHV0ZSBpbWFnZSB0byB3b3JrZCB0cmFuc2Zvcm0sIG9yZGVyIGZyYW1lcywgZXRjLlxuICAgIGlmICghdGhpcy5fc3RhY2sucHJlcGFyZWQpIHtcbiAgICAgIHRoaXMuX3N0YWNrLnByZXBhcmUoKTtcbiAgICB9XG4gICAgLy8gcGFjayBkYXRhIGludG8gOCBiaXRzIHJnYmEgdGV4dHVyZSBmb3IgdGhlIHNoYWRlclxuICAgIC8vIHRoaXMgb25lIGNhbiBiZSBzbG93Li4uXG4gICAgaWYgKCF0aGlzLl9zdGFjay5wYWNrZWQpIHtcbiAgICAgIHRoaXMuX3N0YWNrLnBhY2soKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2V0dXAgYm91bmRpbmcgYm94IGhlbHBlciBnaXZlbiBwcmVwYXJlZCBzdGFjayBhbmQgYWRkIGJvdW5kaW5nIGJveCBoZWxwZXJcbiAgICogdG8gc3RhY2sgaGVscGVyLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3ByZXBhcmVCQm94KCkge1xuICAgIHRoaXMuX2JCb3ggPSBuZXcgSGVscGVyc0JvdW5kaW5nQm94KHRoaXMuX3N0YWNrKTtcbiAgICB0aGlzLmFkZCh0aGlzLl9iQm94KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXR1cCBib3JkZXIgaGVscGVyIGdpdmVuIHNsaWNlIGhlbHBlciBhbmQgYWRkIGJvcmRlciBoZWxwZXJcbiAgICogdG8gc3RhY2sgaGVscGVyLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3ByZXBhcmVCb3JkZXIoKSB7XG4gICAgdGhpcy5fYm9yZGVyID0gbmV3IEhlbHBlcnNCb3JkZXIodGhpcy5fc2xpY2UpO1xuICAgIHRoaXMuYWRkKHRoaXMuX2JvcmRlcik7XG4gIH1cblxuICAvKipcbiAgICogU2V0dXAgc2xpY2UgaGVscGVyIGdpdmVuIHByZXBhcmVkIHN0YWNrIGhlbHBlciBhbmQgYWRkIHNsaWNlIGhlbHBlclxuICAgKiB0byBzdGFjayBoZWxwZXIuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcHJlcGFyZVNsaWNlKCkge1xuICAgIGxldCBoYWxmRGltZW5zaW9uc0lKSyA9IHRoaXMuX3N0YWNrLmhhbGZEaW1lbnNpb25zSUpLO1xuICAgIC8vIGNvbXB1dGUgaW5pdGlhbCBpbmRleCBnaXZlbiBvcmllbnRhdGlvblxuICAgIHRoaXMuX2luZGV4ID0gdGhpcy5fcHJlcGFyZVNsaWNlSW5kZXgoaGFsZkRpbWVuc2lvbnNJSkspO1xuICAgIC8vIGNvbXB1dGUgaW5pdGlhbCBwb3NpdGlvbiBnaXZlbiBvcmllbnRhdGlvbiBhbmQgaW5kZXhcbiAgICBsZXQgcG9zaXRpb24gPSB0aGlzLl9wcmVwYXJlU2xpY2VQb3NpdGlvbihoYWxmRGltZW5zaW9uc0lKSywgdGhpcy5faW5kZXgpO1xuICAgIC8vIGNvbXB1dGUgaW5pdGlhbCBkaXJlY3Rpb24gb3JpZW50YXRpb25cbiAgICBsZXQgZGlyZWN0aW9uID0gdGhpcy5fcHJlcGFyZURpcmVjdGlvbih0aGlzLl9vcmllbnRhdGlvbik7XG5cbiAgICB0aGlzLl9zbGljZSA9IG5ldyBIZWxwZXJzU2xpY2UodGhpcy5fc3RhY2ssIHRoaXMuX2luZGV4LCBwb3NpdGlvbiwgZGlyZWN0aW9uKTtcbiAgICB0aGlzLmFkZCh0aGlzLl9zbGljZSk7XG4gIH1cblxuICAvKipcbiAgICogQ29tcHV0ZSBzbGljZSBpbmRleCBkZXBlbmRpbmcgb24gb3JpZW50YXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7VEhSRUUuVmVjdG9yM30gaW5kaWNlcyAtIEluZGljZXMgaW4gZWFjaCBkaXJlY3Rpb24uXG4gICAqXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFNsaWNlIGluZGV4IGFjY29yZGluZyB0byBjdXJyZW50IG9yaWVudGF0aW9uLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3ByZXBhcmVTbGljZUluZGV4KGluZGljZXMpIHtcbiAgICBsZXQgaW5kZXggPSAwO1xuICAgIHN3aXRjaCAodGhpcy5fb3JpZW50YXRpb24pIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgaW5kZXggPSBNYXRoLmZsb29yKGluZGljZXMueik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxOlxuICAgICAgICBpbmRleCA9IE1hdGguZmxvb3IoaW5kaWNlcy54KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIGluZGV4ID0gTWF0aC5mbG9vcihpbmRpY2VzLnkpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIC8vIGRvIG5vdGhpbmchXG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gaW5kZXg7XG4gIH1cblxuICAvKipcbiAgICogQ29tcHV0ZSBzbGljZSBwb3NpdGlvbiBkZXBlbmRpbmcgb24gb3JpZW50YXRpb24uXG4gICAqIFNldHMgaW5kZXggaW4gcHJvcGVyIGxvY2F0aW9uIG9mIHJlZmVyZW5jZSBwb3NpdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtUSFJFRS5WZWN0b3IzfSByUG9zaXRpb24gLSBSZWZlcmVuY2UgcG9zaXRpb24uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCAtIEN1cnJlbnQgaW5kZXguXG4gICAqXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFNsaWNlIGluZGV4IGFjY29yZGluZyB0byBjdXJyZW50IG9yaWVudGF0aW9uLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3ByZXBhcmVTbGljZVBvc2l0aW9uKHJQb3NpdGlvbiwgaW5kZXgpIHtcbiAgICBsZXQgcG9zaXRpb24gPSBuZXcgVEhSRUUuVmVjdG9yMygwLCAwLCAwKTtcbiAgICBzd2l0Y2ggKHRoaXMuX29yaWVudGF0aW9uKSB7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIHBvc2l0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoXG4gICAgICAgICAgTWF0aC5mbG9vcihyUG9zaXRpb24ueCksXG4gICAgICAgICAgTWF0aC5mbG9vcihyUG9zaXRpb24ueSksXG4gICAgICAgICAgaW5kZXgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgcG9zaXRpb24gPSBuZXcgVEhSRUUuVmVjdG9yMyhcbiAgICAgICAgICBpbmRleCxcbiAgICAgICAgICBNYXRoLmZsb29yKHJQb3NpdGlvbi55KSxcbiAgICAgICAgICBNYXRoLmZsb29yKHJQb3NpdGlvbi56KSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyOlxuICAgICAgICBwb3NpdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKFxuICAgICAgICAgIE1hdGguZmxvb3IoclBvc2l0aW9uLngpLFxuICAgICAgICAgIGluZGV4LFxuICAgICAgICAgIE1hdGguZmxvb3IoclBvc2l0aW9uLnopKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICAvLyBkbyBub3RoaW5nIVxuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIHBvc2l0aW9uO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbXB1dGUgc2xpY2UgZGlyZWN0aW9uIGRlcGVuZGluZyBvbiBvcmllbnRhdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9yaWVudGF0aW9uIC0gU2xpY2Ugb3JpZW50YXRpb24uXG4gICAqXG4gICAqIEByZXR1cm5zIHtUSFJFRS5WZWN0b3IzfSBTbGljZSBkaXJlY3Rpb25cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9wcmVwYXJlRGlyZWN0aW9uKG9yaWVudGF0aW9uKSB7XG4gICAgbGV0IGRpcmVjdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKDAsIDAsIDEpO1xuICAgIHN3aXRjaCAob3JpZW50YXRpb24pIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgZGlyZWN0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoMCwgMCwgMSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxOlxuICAgICAgICBkaXJlY3Rpb24gPSBuZXcgVEhSRUUuVmVjdG9yMygxLCAwLCAwKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIGRpcmVjdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKDAsIDEsIDApO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIC8vIGRvIG5vdGhpbmchXG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHJldHVybiBkaXJlY3Rpb247XG4gIH1cblxuICAvKipcbiAgICogUmVsZWFzZSB0aGUgc3RhY2sgaGVscGVyIG1lbW9yeSBpbmNsdWRpbmcgdGhlIHNsaWNlIG1lbW9yeS5cbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgZGlzcG9zZSgpIHtcbiAgICB0aGlzLnJlbW92ZSh0aGlzLl9zbGljZSk7XG4gICAgdGhpcy5fc2xpY2UuZGlzcG9zZSgpO1xuICAgIHRoaXMuX3NsaWNlID0gbnVsbDtcbiAgICB0aGlzLl9iQm94LmRpc3Bvc2UoKTtcbiAgICB0aGlzLl9iQm94ID0gIG51bGw7XG4gICAgdGhpcy5fYm9yZGVyLmRpc3Bvc2UoKTtcbiAgICB0aGlzLl9ib3JkZXIgPSAgbnVsbDtcbiAgfVxuXG59XG4iLCIvKiogKiBJbXBvcnRzICoqKi9cbmltcG9ydCBTaGFkZXJzVW5pZm9ybSBmcm9tICcuLi9zaGFkZXJzL3NoYWRlcnMudnIudW5pZm9ybSc7XG5pbXBvcnQgU2hhZGVyc1ZlcnRleCBmcm9tICcuLi9zaGFkZXJzL3NoYWRlcnMudnIudmVydGV4JztcbmltcG9ydCBTaGFkZXJzRnJhZ21lbnQgZnJvbSAnLi4vc2hhZGVycy9zaGFkZXJzLnZyLmZyYWdtZW50JztcblxuaW1wb3J0IEhlbHBlcnNNYXRlcmlhbE1peGluIGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5tYXRlcmlhbC5taXhpbic7XG5cblxuLyoqXG4gKiBAbW9kdWxlIGhlbHBlcnMvdm9sdW1lcmVuZGVyaW5nXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSGVscGVyc1ZvbHVtZVJlbmRlcmluZyBleHRlbmRzIEhlbHBlcnNNYXRlcmlhbE1peGluKFRIUkVFLk9iamVjdDNEKSB7XG4gIGNvbnN0cnVjdG9yKHN0YWNrKSB7XG4gICAgLy9cbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5fc3RhY2sgPSBzdGFjaztcbiAgICB0aGlzLl90ZXh0dXJlcyA9IFtdO1xuICAgIHRoaXMuX3NoYWRlcnNGcmFnbWVudCA9IFNoYWRlcnNGcmFnbWVudDtcbiAgICB0aGlzLl9zaGFkZXJzVmVydGV4ID0gU2hhZGVyc1ZlcnRleDtcbiAgICB0aGlzLl91bmlmb3JtcyA9IFNoYWRlcnNVbmlmb3JtLnVuaWZvcm1zKCk7XG4gICAgdGhpcy5fbWF0ZXJpYWwgPSBudWxsO1xuICAgIHRoaXMuX2dlb21ldHJ5ID0gbnVsbDtcblxuICAgIHRoaXMuX2ludGVycG9sYXRpb24gPSAxOyAvLyBkZWZhdWx0IHRvIHRyaWxpbmVhciBpbnRlcnBvbGF0aW9uXG5cbiAgICB0aGlzLl9jcmVhdGUoKTtcbiAgfVxuXG4gIF9jcmVhdGUoKSB7XG4gICAgdGhpcy5fcHJlcGFyZVN0YWNrKCk7XG4gICAgdGhpcy5fcHJlcGFyZVRleHR1cmUoKTtcbiAgICB0aGlzLl9wcmVwYXJlTWF0ZXJpYWwoKTtcbiAgICB0aGlzLl9wcmVwYXJlR2VvbWV0cnkoKTtcblxuICAgIHRoaXMuX21lc2ggPSBuZXcgVEhSRUUuTWVzaCh0aGlzLl9nZW9tZXRyeSwgdGhpcy5fbWF0ZXJpYWwpO1xuICAgIHRoaXMuYWRkKHRoaXMuX21lc2gpO1xuICB9XG5cbiAgX3ByZXBhcmVTdGFjaygpIHtcbiAgICBpZiAoIXRoaXMuX3N0YWNrLnByZXBhcmVkKSB7XG4gICAgICB0aGlzLl9zdGFjay5wcmVwYXJlKCk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLl9zdGFjay5wYWNrZWQpIHtcbiAgICAgIHRoaXMuX3N0YWNrLnBhY2soKTtcbiAgICB9XG4gIH1cblxuICBfcHJlcGFyZU1hdGVyaWFsKCkge1xuICAgIC8vIGNvbXBlbnNhdGUgZm9yIHRoZSBvZmZzZXQgdG8gb25seSBwYXNzID4gMCB2YWx1ZXMgdG8gc2hhZGVyc1xuICAgIC8vIG1vZGVscyA+IG1vZGVscy5zdGFjay5qcyA6IF9wYWNrVG84Qml0c1xuICAgIGxldCBvZmZzZXQgPSAwO1xuICAgIGlmICh0aGlzLl9zdGFjay5fbWluTWF4WzBdIDwgMCkge1xuICAgICAgb2Zmc2V0ID0gdGhpcy5fc3RhY2suX21pbk1heFswXTtcbiAgICB9XG5cbiAgICAvLyB1bmlmb3Jtc1xuICAgIHRoaXMuX3VuaWZvcm1zID0gU2hhZGVyc1VuaWZvcm0udW5pZm9ybXMoKTtcbiAgICB0aGlzLl91bmlmb3Jtcy51V29ybGRCQm94LnZhbHVlID0gdGhpcy5fc3RhY2sud29ybGRCb3VuZGluZ0JveCgpO1xuICAgIHRoaXMuX3VuaWZvcm1zLnVUZXh0dXJlU2l6ZS52YWx1ZSA9IHRoaXMuX3N0YWNrLnRleHR1cmVTaXplO1xuICAgIHRoaXMuX3VuaWZvcm1zLnVUZXh0dXJlQ29udGFpbmVyLnZhbHVlID0gdGhpcy5fdGV4dHVyZXM7XG4gICAgdGhpcy5fdW5pZm9ybXMudVdvcmxkVG9EYXRhLnZhbHVlID0gdGhpcy5fc3RhY2subHBzMklKSztcbiAgICB0aGlzLl91bmlmb3Jtcy51TnVtYmVyT2ZDaGFubmVscy52YWx1ZSA9IHRoaXMuX3N0YWNrLm51bWJlck9mQ2hhbm5lbHM7XG4gICAgdGhpcy5fdW5pZm9ybXMudVBpeGVsVHlwZS52YWx1ZSA9IHRoaXMuX3N0YWNrLnBpeGVsVHlwZTtcbiAgICB0aGlzLl91bmlmb3Jtcy51Qml0c0FsbG9jYXRlZC52YWx1ZSA9IHRoaXMuX3N0YWNrLmJpdHNBbGxvY2F0ZWQ7XG4gICAgdGhpcy5fdW5pZm9ybXMudVBhY2tlZFBlclBpeGVsLnZhbHVlID0gdGhpcy5fc3RhY2sucGFja2VkUGVyUGl4ZWw7XG4gICAgdGhpcy5fdW5pZm9ybXMudVdpbmRvd0NlbnRlcldpZHRoLnZhbHVlID0gW29mZnNldCArIHRoaXMuX3N0YWNrLndpbmRvd0NlbnRlciwgdGhpcy5fc3RhY2sud2luZG93V2lkdGggKiAwLjhdO1xuICAgIHRoaXMuX3VuaWZvcm1zLnVSZXNjYWxlU2xvcGVJbnRlcmNlcHQudmFsdWUgPSBbdGhpcy5fc3RhY2sucmVzY2FsZVNsb3BlLCB0aGlzLl9zdGFjay5yZXNjYWxlSW50ZXJjZXB0XTtcbiAgICB0aGlzLl91bmlmb3Jtcy51RGF0YURpbWVuc2lvbnMudmFsdWUgPSBbdGhpcy5fc3RhY2suZGltZW5zaW9uc0lKSy54LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RhY2suZGltZW5zaW9uc0lKSy55LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RhY2suZGltZW5zaW9uc0lKSy56XTtcbiAgICB0aGlzLl91bmlmb3Jtcy51SW50ZXJwb2xhdGlvbi52YWx1ZSA9IHRoaXMuX2ludGVycG9sYXRpb247XG5cbiAgICB0aGlzLl9jcmVhdGVNYXRlcmlhbCh7XG4gICAgICBzaWRlOiBUSFJFRS5Gcm9udFNpZGUsXG4gICAgICB0cmFuc3BhcmVudDogdHJ1ZSxcbiAgICB9KTtcbiAgfVxuXG4gIF9wcmVwYXJlR2VvbWV0cnkoKSB7XG4gICAgbGV0IHdvcmxkQkJveCA9IHRoaXMuX3N0YWNrLndvcmxkQm91bmRpbmdCb3goKTtcbiAgICBsZXQgY2VudGVyTFBTID0gdGhpcy5fc3RhY2sud29ybGRDZW50ZXIoKTtcblxuICAgIHRoaXMuX2dlb21ldHJ5ID0gbmV3IFRIUkVFLkJveEdlb21ldHJ5KFxuICAgICAgd29ybGRCQm94WzFdIC0gd29ybGRCQm94WzBdLFxuICAgICAgd29ybGRCQm94WzNdIC0gd29ybGRCQm94WzJdLFxuICAgICAgd29ybGRCQm94WzVdIC0gd29ybGRCQm94WzRdKTtcbiAgICB0aGlzLl9nZW9tZXRyeS5hcHBseU1hdHJpeChuZXcgVEhSRUUuTWF0cml4NCgpLm1ha2VUcmFuc2xhdGlvbihcbiAgICAgIGNlbnRlckxQUy54LCBjZW50ZXJMUFMueSwgY2VudGVyTFBTLnopKTtcbiAgfVxuXG4gIGdldCB1bmlmb3JtcygpIHtcbiAgICByZXR1cm4gdGhpcy5fdW5pZm9ybXM7XG4gIH1cblxuICBzZXQgdW5pZm9ybXModW5pZm9ybXMpIHtcbiAgICB0aGlzLl91bmlmb3JtcyA9IHVuaWZvcm1zO1xuICB9XG5cbiAgZ2V0IHN0YWNrKCkge1xuICAgIHJldHVybiB0aGlzLl9zdGFjaztcbiAgfVxuXG4gIHNldCBzdGFjayhzdGFjaykge1xuICAgIHRoaXMuX3N0YWNrID0gc3RhY2s7XG4gIH1cblxuICBnZXQgaW50ZXJwb2xhdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5faW50ZXJwb2xhdGlvbjtcbiAgfVxuXG4gIHNldCBpbnRlcnBvbGF0aW9uKGludGVycG9sYXRpb24pIHtcbiAgICB0aGlzLl9pbnRlcnBvbGF0aW9uID0gaW50ZXJwb2xhdGlvbjtcbiAgICB0aGlzLl91bmlmb3Jtcy51SW50ZXJwb2xhdGlvbi52YWx1ZSA9IHRoaXMuX2ludGVycG9sYXRpb247XG4gICAgdGhpcy5fdXBkYXRlTWF0ZXJpYWwoKTtcbiAgfVxufVxuIiwiLyoqXG4gKiBAbW9kdWxlIGhlbHBlcnMveC9pbnRlcmFjdG9yXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEludGVyYWN0b3Ige1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgfVxuXG4gIC8vIHByaXZhdGUgbWV0aG9kc1xuICBfY3JlYXRlKCkge1xuICB9XG5cbiAgX3VwZGF0ZSgpIHtcbiAgfVxuXG59XG4iLCJpbXBvcnQgSW50ZXJhY3RvciBmcm9tICcuL2hlbHBlcnMueC5pbnRlcmFjdG9yJztcbmltcG9ydCBNZXNoIGZyb20gJy4vaGVscGVycy54Lm1lc2gnO1xuaW1wb3J0IFJlbmRlcmVyM0QgZnJvbSAnLi9oZWxwZXJzLngucmVuZGVyZXIzZCc7XG5pbXBvcnQgUmVuZGVyZXIyRCBmcm9tICcuL2hlbHBlcnMueC5yZW5kZXJlcjJkJztcbmltcG9ydCBWb2x1bWUgZnJvbSAnLi9oZWxwZXJzLngudm9sdW1lJztcblxuLyoqXG4gKiBAbW9kdWxlIGhlbHBlcnNcbiAqL1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIEludGVyYWN0b3IsXG4gIE1lc2gsXG4gIFJlbmRlcmVyM0QsXG4gIFJlbmRlcmVyMkQsXG4gIFZvbHVtZSxcbn07XG4iLCIvKipcbiAqIEBtb2R1bGUgaGVscGVycy94L21lc2hcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3Mge1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuX2ZpbGUgPSBudWxsO1xuXG4gICAgdGhpcy5fM2pzVlRLX2xvYWRlciA9IG5ldyBUSFJFRS5WVEtMb2FkZXIoKTtcbiAgICB0aGlzLl9tZXNoID0gbnVsbDtcbiAgICB0aGlzLl9tYXRlcmlhbENvbG9yID0gMHhFOTFFNjM7XG4gICAgdGhpcy5fUkFTdG9MUFMgPSBudWxsO1xuICAgIHRoaXMuX21hdGVyaWFsID0gbmV3IFRIUkVFLk1lc2hMYW1iZXJ0TWF0ZXJpYWwoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoYWRpbmc6IFRIUkVFLlNtb290aFNoYWRpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3I6IHRoaXMuX21hdGVyaWFsQ29sb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2lkZTogVEhSRUUuRG91YmxlU2lkZX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgfVxuXG4gIC8vIGFjY2Vzc29yIHByb3BlcnRpZXNcbiAgZ2V0IGZpbGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZpbGU7XG4gIH1cblxuICBzZXQgZmlsZShmbmFtZSkge1xuICAgIHRoaXMuX2ZpbGUgPSBmbmFtZTtcbiAgfVxuXG4gIGdldCBtYXRlcmlhbENvbG9yKCkge1xuICAgIHJldHVybiB0aGlzLl9tYXRlcmlhbENvbG9yO1xuICB9XG5cbiAgc2V0IG1hdGVyaWFsQ29sb3IoY29sb3IpIHtcbiAgICB0aGlzLl9tYXRlcmlhbENvbG9yID0gY29sb3I7XG4gIH1cblxuICAvLyBsb2FkIGZ1bmN0aW9uXG4gIGxvYWQoKSB7XG4gICAgaWYgKHRoaXMuZmlsZSkge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgdGhpcy5fM2pzVlRLX2xvYWRlci5sb2FkKHRoaXMuZmlsZSxcbiAgICAgICAgICAoZ2VvbWV0cnkpID0+IHtcbiAgICAgICAgICAgICAgZ2VvbWV0cnkuY29tcHV0ZVZlcnRleE5vcm1hbHMoKTtcbiAgICAgICAgICAgICAgdGhpcy5fbWVzaCA9IG5ldyBUSFJFRS5NZXNoKGdlb21ldHJ5LCB0aGlzLl9tYXRlcmlhbCk7XG4gICAgICAgICAgICAgIHRoaXMuX1JBU3RvTFBTID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcbiAgICAgICAgICAgICAgdGhpcy5fUkFTdG9MUFMuc2V0KC0xLCAwLCAwLCAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDAsIC0xLCAwLCAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDAsIDAsIDEsIDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMCwgMCwgMCwgMSk7XG4gICAgICAgICAgICAgIHRoaXMuX21lc2guYXBwbHlNYXRyaXgodGhpcy5fUkFTdG9MUFMpO1xuICAgICAgICAgICAgICAvLyByZXNvbHZlIHRoZSBwcm9taXNlIGFuZCByZXR1cm4gdGhlIG1lc2hcbiAgICAgICAgICAgICAgcmVzb2x2ZSh0aGlzLl9tZXNoKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgICgpID0+IHt9LFxuICAgICAgICAgIChlcnJvcikgPT4ge1xuICAgICAgICAgICAgY29uc29sZS5sb2coZXJyb3IpO1xuICAgICAgICAgICAgcmVqZWN0KHtcbiAgICAgICAgICAgICAgbWVzc2FnZTogYENvdWxkbid0IGxvYWQgZmlsZTogJHt0aGlzLmZpbGV9LmAsXG4gICAgICAgICAgICAgIGVycm9yLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KHttZXNzYWdlOiBgRmlsZSBpcyBub3QgZGVmaW5lZDogJHt0aGlzLmZpbGV9LmB9KTtcbiAgfVxufVxuIiwiLyoqXG4gKiBAbW9kdWxlIGhlbHBlcnMveC9yZW5kZXJlcjJkXG4gKi9cbmltcG9ydCBDYW1lcmFzT3J0aG9ncmFwaGljIGZyb20gJy4uLy4uL2NhbWVyYXMvY2FtZXJhcy5vcnRob2dyYXBoaWMnO1xuaW1wb3J0IENvbnRyb2xzT3J0aG9ncmFwaGljIGZyb20gJy4uLy4uL2NvbnRyb2xzL2NvbnRyb2xzLnRyYWNrYmFsbG9ydGhvJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcihjb250YWluZXJJZD0ncjJkJywgb3JpZW50YXRpb249J2RlZmF1bHQnKSB7XG4gICAgdGhpcy5fY29udGFpbmVyID0gbnVsbDtcbiAgICB0aGlzLl9yZW5kZXJlciA9IG51bGw7XG4gICAgdGhpcy5fY2FtZXJhID0gbnVsbDtcbiAgICB0aGlzLl9jb250cm9scyA9IG51bGw7XG4gICAgdGhpcy5fb3JpZW50YXRpb24gPSBvcmllbnRhdGlvbjtcbiAgICB0aGlzLl9zY2VuZSA9IG51bGw7XG4gICAgdGhpcy5fb2JqZWN0ID0gbnVsbDtcblxuICAgIHRoaXMuX2luaXRSZW5kZXJlcihjb250YWluZXJJZCk7XG4gICAgdGhpcy5faW5pdENhbWVyYSgpO1xuICAgIHRoaXMuX2luaXRTY2VuZSgpO1xuICAgIHRoaXMuX2luaXRDb250cm9scygpO1xuXG4gICAgLy8gc2V0dXAgZXZlbnQgbGlzdGVuZXJzXG4gICAgdGhpcy5fb25TY3JvbGwgPSB0aGlzLl9vblNjcm9sbC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX29uV2luZG93UmVzaXplID0gdGhpcy5fb25XaW5kb3dSZXNpemUuYmluZCh0aGlzKTtcbiAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXJzKCk7XG4gIH1cblxuICBhZGQob2JqZWN0KSB7XG4gICAgdGhpcy5fb2JqZWN0ID0gb2JqZWN0O1xuICAgIHRoaXMuX3NjZW5lLmFkZCh0aGlzLl9vYmplY3QpO1xuXG4gICAgdGhpcy5fc2V0dXBDYW1lcmEodGhpcy5fb2JqZWN0LnN0YWNrKTtcbiAgICB0aGlzLl9vcmllbnRDYW1lcmEodGhpcy5fb2JqZWN0LCB0aGlzLl9vcmllbnRhdGlvbik7XG5cbiAgICB0aGlzLl9vYmplY3QuY2FudmFzV2lkdGggPSB0aGlzLl9jb250YWluZXIuY2xpZW50V2lkdGg7XG4gICAgdGhpcy5fb2JqZWN0LmNhbnZhc0hlaWdodCA9IHRoaXMuX2NvbnRhaW5lci5jbGllbnRIZWlnaHQ7XG4gIH1cblxuICBhZGRFdmVudExpc3RlbmVycygpIHtcbiAgICB0aGlzLl9jb250cm9scy5hZGRFdmVudExpc3RlbmVyKCdPblNjcm9sbCcsIHRoaXMuX29uU2Nyb2xsLCBmYWxzZSk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMuX29uV2luZG93UmVzaXplLCBmYWxzZSk7XG4gIH1cblxuICByZW1vdmVFdmVudExpc3RlbmVycygpIHtcbiAgICB0aGlzLl9jb250cm9scy5yZW1vdmVFdmVudExpc3RlbmVyKCdPblNjcm9sbCcsIHRoaXMuX29uU2Nyb2xsLCBmYWxzZSk7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMuX29uV2luZG93UmVzaXplLCBmYWxzZSk7XG4gIH1cblxuICBhbmltYXRlKCkge1xuICAgIHRoaXMuX2NvbnRyb2xzLnVwZGF0ZSgpO1xuICAgIHRoaXMuX3JlbmRlcmVyLnJlbmRlcih0aGlzLl9zY2VuZSwgdGhpcy5fY2FtZXJhKTtcblxuICAgIC8vIHJlcXVlc3QgbmV3IGZyYW1lXG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMuYW5pbWF0ZS5iaW5kKHRoaXMpKTtcbiAgfVxuXG4gIC8vIHByaXZhdGUgbWV0aG9kc1xuXG4gIF9pbml0UmVuZGVyZXIoY29udGFpbmVySWQpIHtcbiAgICAvLyByZW5kZXJlclxuICAgIHRoaXMuX2NvbnRhaW5lciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGNvbnRhaW5lcklkKTtcbiAgICB0aGlzLl9yZW5kZXJlciA9IG5ldyBUSFJFRS5XZWJHTFJlbmRlcmVyKHtcbiAgICAgIGFudGlhbGlhczogdHJ1ZSxcbiAgICB9KTtcbiAgICB0aGlzLl9yZW5kZXJlci5zZXRTaXplKHRoaXMuX2NvbnRhaW5lci5jbGllbnRXaWR0aCxcbiAgICAgIHRoaXMuX2NvbnRhaW5lci5jbGllbnRIZWlnaHQpO1xuICAgIHRoaXMuX3JlbmRlcmVyLnNldENsZWFyQ29sb3IoMHgyMTIxMjEsIDEpO1xuICAgIHRoaXMuX3JlbmRlcmVyLnNldFBpeGVsUmF0aW8od2luZG93LmRldmljZVBpeGVsUmF0aW8pO1xuICAgIHRoaXMuX2NvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLl9yZW5kZXJlci5kb21FbGVtZW50KTtcbiAgfVxuXG4gIF9pbml0Q2FtZXJhKCkge1xuICAgIHRoaXMuX2NhbWVyYSA9IG5ldyBDYW1lcmFzT3J0aG9ncmFwaGljKHRoaXMuX2NvbnRhaW5lci5jbGllbnRXaWR0aCAvIC0yLFxuICAgICAgdGhpcy5fY29udGFpbmVyLmNsaWVudFdpZHRoIC8gMiwgdGhpcy5fY29udGFpbmVyLmNsaWVudEhlaWdodCAvIDIsXG4gICAgICB0aGlzLl9jb250YWluZXIuY2xpZW50SGVpZ2h0IC8gLTIsIDEsIDEwMDApO1xuICB9XG5cbiAgX2luaXRTY2VuZSgpIHtcbiAgICB0aGlzLl9zY2VuZSA9IG5ldyBUSFJFRS5TY2VuZSgpO1xuICB9XG5cbiAgX2luaXRDb250cm9scygpIHtcbiAgICAvLyBjb250cm9sc1xuICAgIHRoaXMuX2NvbnRyb2xzID0gbmV3IENvbnRyb2xzT3J0aG9ncmFwaGljKHRoaXMuX2NhbWVyYSwgdGhpcy5fY29udGFpbmVyKTtcbiAgICB0aGlzLl9jb250cm9scy5zdGF0aWNNb3ZpbmcgPSB0cnVlO1xuICAgIHRoaXMuX2NvbnRyb2xzLm5vUm90YXRlID0gdHJ1ZTtcbiAgICB0aGlzLl9jYW1lcmEuY29udHJvbHMgPSB0aGlzLl9jb250cm9scztcbiAgfVxuXG4gIF9zZXR1cENhbWVyYShzdGFjaykge1xuICAgIC8vIHNldCBjYW1lcmFcbiAgICBsZXQgd29ybGRiYiA9IHN0YWNrLndvcmxkQm91bmRpbmdCb3goKTtcbiAgICBsZXQgbHBzRGltcyA9IG5ldyBUSFJFRS5WZWN0b3IzKFxuICAgICAgd29ybGRiYlsxXSAtIHdvcmxkYmJbMF0sXG4gICAgICB3b3JsZGJiWzNdIC0gd29ybGRiYlsyXSxcbiAgICAgIHdvcmxkYmJbNV0gLSB3b3JsZGJiWzRdXG4gICAgKTtcblxuICAgIC8vIGJveDoge2hhbGZEaW1lbnNpb25zLCBjZW50ZXJ9XG4gICAgbGV0IGJveCA9IHtcbiAgICAgIGNlbnRlcjogc3RhY2sud29ybGRDZW50ZXIoKS5jbG9uZSgpLFxuICAgICAgaGFsZkRpbWVuc2lvbnM6IG5ldyBUSFJFRS5WZWN0b3IzKGxwc0RpbXMueCArIDEwLCBscHNEaW1zLnkgKyAxMCxcbiAgICAgICAgbHBzRGltcy56ICsgMTApLFxuICAgIH07XG5cbiAgICAvLyBpbml0IGFuZCB6b29tXG4gICAgbGV0IGNhbnZhcyA9IHtcbiAgICAgICAgd2lkdGg6IHRoaXMuX2NvbnRhaW5lci5jbGllbnRXaWR0aCxcbiAgICAgICAgaGVpZ2h0OiB0aGlzLl9jb250YWluZXIuY2xpZW50SGVpZ2h0LFxuICAgICAgfTtcblxuICAgIHRoaXMuX2NhbWVyYS5kaXJlY3Rpb25zID0gW3N0YWNrLnhDb3NpbmUsIHN0YWNrLnlDb3NpbmUsIHN0YWNrLnpDb3NpbmVdO1xuICAgIHRoaXMuX2NhbWVyYS5ib3ggPSBib3g7XG4gICAgdGhpcy5fY2FtZXJhLmNhbnZhcyA9IGNhbnZhcztcbiAgICB0aGlzLl9jYW1lcmEudXBkYXRlKCk7XG4gICAgdGhpcy5fY2FtZXJhLmZpdEJveCgyKTtcbiAgfVxuXG4gIF9vcmllbnRDYW1lcmEodGFyZ2V0LCBvcmllbnRhdGlvbj0nZGVmYXVsdCcpIHtcbiAgICAgIHRoaXMuX2NhbWVyYS5vcmllbnRhdGlvbiA9IG9yaWVudGF0aW9uO1xuICAgICAgdGhpcy5fY2FtZXJhLnVwZGF0ZSgpO1xuICAgICAgdGhpcy5fY2FtZXJhLmZpdEJveCgyKTtcbiAgICAgIHRhcmdldC5vcmllbnRhdGlvbiA9IHRoaXMuX2NhbWVyYS5zdGFja09yaWVudGF0aW9uO1xuICB9XG5cbiAgX29uV2luZG93UmVzaXplKCkge1xuICAgICAgdGhpcy5fY2FtZXJhLmNhbnZhcyA9IHtcbiAgICAgICAgd2lkdGg6IHRoaXMuX2NvbnRhaW5lci5jbGllbnRXaWR0aCxcbiAgICAgICAgaGVpZ2h0OiB0aGlzLl9jb250YWluZXIuY2xpZW50SGVpZ2h0LFxuICAgICAgfTtcbiAgICAgIHRoaXMuX2NhbWVyYS5maXRCb3goMik7XG4gICAgICB0aGlzLl9yZW5kZXJlci5zZXRTaXplKHRoaXMuX2NvbnRhaW5lci5jbGllbnRXaWR0aCxcbiAgICAgICAgdGhpcy5fY29udGFpbmVyLmNsaWVudEhlaWdodCk7XG4gICAgICB0aGlzLl9vYmplY3QuY2FudmFzV2lkdGggPSB0aGlzLl9jb250YWluZXIuY2xpZW50V2lkdGg7XG4gICAgICB0aGlzLl9vYmplY3QuY2FudmFzSGVpZ2h0ID0gdGhpcy5fY29udGFpbmVyLmNsaWVudEhlaWdodDtcbiAgfVxuXG4gIF9vblNjcm9sbChldmVudCkge1xuICAgIGlmIChldmVudC5kZWx0YSA+IDApIHtcbiAgICAgIGlmICh0aGlzLl9vYmplY3QuaW5kZXggPj0gdGhpcy5fb2JqZWN0Lm9yaWVudGF0aW9uTWF4SW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdGhpcy5fb2JqZWN0LmluZGV4ICs9IDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0aGlzLl9vYmplY3QuaW5kZXggPD0gMCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB0aGlzLl9vYmplY3QuaW5kZXggLT0gMTtcbiAgICB9XG4gIH1cblxufVxuIiwiLyoqXG4gKiBAbW9kdWxlIGhlbHBlcnMveC9yZW5kZXJlcjNkXG4gKi9cbmltcG9ydCBDb250cm9sc1RyYWNrYmFsbCBmcm9tICcuLi8uLi9jb250cm9scy9jb250cm9scy50cmFja2JhbGwnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGNvbnRhaW5lcklkPSdyM2QnKSB7XG4gICAgdGhpcy5fY29udGFpbmVyID0gbnVsbDtcbiAgICB0aGlzLl9yZW5kZXJlciA9IG51bGw7XG4gICAgdGhpcy5fY2FtZXJhID0gbnVsbDtcbiAgICB0aGlzLl9jb250cm9scyA9IG51bGw7XG4gICAgdGhpcy5fc2NlbmUgPSBudWxsO1xuXG4gICAgdGhpcy5faW5pdFJlbmRlcmVyKGNvbnRhaW5lcklkKTtcbiAgICB0aGlzLl9pbml0Q2FtZXJhKCk7XG4gICAgdGhpcy5faW5pdFNjZW5lKCk7XG4gICAgdGhpcy5faW5pdENvbnRyb2xzKCk7XG5cbiAgICAvLyBzZXR1cCBldmVudCBsaXN0ZW5lcnNcbiAgICB0aGlzLl9vbldpbmRvd1Jlc2l6ZSA9IHRoaXMuX29uV2luZG93UmVzaXplLmJpbmQodGhpcyk7XG4gICAgdGhpcy5hZGRFdmVudExpc3RlbmVycygpO1xuICB9XG5cbiAgc2V0IGNvbnRhaW5lcihjb250YWluZXIpIHtcbiAgICB0aGlzLl9jb250YWluZXIgPSBjb250YWluZXI7XG4gIH1cblxuICBnZXQgY29udGFpbmVyKCkge1xuICAgIHJldHVybiB0aGlzLl9jb250YWluZXI7XG4gIH1cblxuICBhZGQob2JqKSB7XG4gICAgdGhpcy5fc2NlbmUuYWRkKG9iaik7XG4gIH1cblxuICBhZGRFdmVudExpc3RlbmVycygpIHtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5fb25XaW5kb3dSZXNpemUsIGZhbHNlKTtcbiAgfVxuXG4gIHJlbW92ZUV2ZW50TGlzdGVuZXJzKCkge1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLl9vbldpbmRvd1Jlc2l6ZSwgZmFsc2UpO1xuICB9XG5cbiAgY2VudGVyKHdvcmxkUG9zaXRpb24pIHtcbiAgICAvLyB1cGRhdGUgY2FtcmVhJ3MgYW5kIGNvbnRyb2wncyB0YXJnZXRcbiAgICB0aGlzLl9jYW1lcmEubG9va0F0KHdvcmxkUG9zaXRpb24ueCwgd29ybGRQb3NpdGlvbi55LCB3b3JsZFBvc2l0aW9uLnopO1xuICAgIHRoaXMuX2NhbWVyYS51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XG4gICAgdGhpcy5fY29udHJvbHMudGFyZ2V0LnNldCh3b3JsZFBvc2l0aW9uLngsIHdvcmxkUG9zaXRpb24ueSxcbiAgICAgIHdvcmxkUG9zaXRpb24ueik7XG4gIH1cblxuICBhbmltYXRlKCkge1xuICAgIHRoaXMuX2NvbnRyb2xzLnVwZGF0ZSgpO1xuICAgIHRoaXMuX3JlbmRlcmVyLnJlbmRlcih0aGlzLl9zY2VuZSwgdGhpcy5fY2FtZXJhKTtcblxuICAgIC8vIHJlcXVlc3QgbmV3IGZyYW1lXG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMuYW5pbWF0ZS5iaW5kKHRoaXMpKTtcbiAgfVxuXG4gIC8vIHByaXZhdGUgbWV0aG9kc1xuXG4gIF9vbldpbmRvd1Jlc2l6ZSgpIHtcbiAgICB0aGlzLl9jYW1lcmEuYXNwZWN0ID1cbiAgICAgIHRoaXMuX2NvbnRhaW5lci5jbGllbnRXaWR0aCAvIHRoaXMuX2NvbnRhaW5lci5jbGllbnRIZWlnaHQ7XG4gICAgdGhpcy5fY2FtZXJhLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcblxuICAgIHRoaXMuX3JlbmRlcmVyLnNldFNpemUodGhpcy5fY29udGFpbmVyLmNsaWVudFdpZHRoLFxuICAgICAgdGhpcy5fY29udGFpbmVyLmNsaWVudEhlaWdodCk7XG4gIH1cblxuICBfaW5pdFJlbmRlcmVyKGNvbnRhaW5lcklkKSB7XG4gICAgLy8gcmVuZGVyZXJcbiAgICB0aGlzLl9jb250YWluZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChjb250YWluZXJJZCk7XG4gICAgdGhpcy5fcmVuZGVyZXIgPSBuZXcgVEhSRUUuV2ViR0xSZW5kZXJlcih7XG4gICAgICBhbnRpYWxpYXM6IHRydWUsXG4gICAgfSk7XG4gICAgdGhpcy5fcmVuZGVyZXIuc2V0U2l6ZSh0aGlzLl9jb250YWluZXIuY2xpZW50V2lkdGgsXG4gICAgICB0aGlzLl9jb250YWluZXIuY2xpZW50SGVpZ2h0KTtcbiAgICB0aGlzLl9yZW5kZXJlci5zZXRDbGVhckNvbG9yKDB4NDI0MjQyLCAxKTtcbiAgICB0aGlzLl9yZW5kZXJlci5zZXRQaXhlbFJhdGlvKHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvKTtcbiAgICB0aGlzLl9jb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5fcmVuZGVyZXIuZG9tRWxlbWVudCk7XG4gIH1cblxuICBfaW5pdENhbWVyYSgpIHtcbiAgICB0aGlzLl9jYW1lcmEgPSBuZXcgVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEoNDUsXG4gICAgICB0aGlzLl9jb250YWluZXIuY2xpZW50V2lkdGggLyB0aGlzLl9jb250YWluZXIuY2xpZW50SGVpZ2h0LCAxLCAxMDAwMDAwMCk7XG4gICAgdGhpcy5fY2FtZXJhLnBvc2l0aW9uLnggPSAyNTA7XG4gICAgdGhpcy5fY2FtZXJhLnBvc2l0aW9uLnkgPSAyNTA7XG4gICAgdGhpcy5fY2FtZXJhLnBvc2l0aW9uLnogPSAyNTA7XG4gIH1cblxuICBfaW5pdFNjZW5lKCkge1xuICAgIC8vIGFkZCBzb21lIGxpZ2h0cyB0byB0aGUgc2NlbmUgYnkgZGVmYXVsdFxuICAgIHRoaXMuX3NjZW5lID0gbmV3IFRIUkVFLlNjZW5lKCk7XG5cbiAgICAvLyBhbWJpZW50XG4gICAgdGhpcy5fc2NlbmUuYWRkKG5ldyBUSFJFRS5BbWJpZW50TGlnaHQoMHgzNTM1MzUpKTtcblxuICAgIC8vIGRpcmVjdGlvbmFsIDFcbiAgICBsZXQgZGlyZWN0aW9uYWxMaWdodCA9IG5ldyBUSFJFRS5EaXJlY3Rpb25hbExpZ2h0KDB4ZmZmZmZmLCAxKTtcbiAgICBkaXJlY3Rpb25hbExpZ2h0LnBvc2l0aW9uLnNldCgyMDAsIDIwMCwgMTAwMCkubm9ybWFsaXplKCk7XG4gICAgdGhpcy5fc2NlbmUuYWRkKGRpcmVjdGlvbmFsTGlnaHQpO1xuXG4gICAgLy8gZGlyZWN0aW9uYWwgMlxuICAgIGxldCBkaXJlY3Rpb25hbExpZ2h0MiA9IG5ldyBUSFJFRS5EaXJlY3Rpb25hbExpZ2h0KDB4ZmZmZmZmLCAxKTtcbiAgICBkaXJlY3Rpb25hbExpZ2h0Mi5wb3NpdGlvbi5zZXQoLTIwMCwgLTIwMCwgLTEwMDApLm5vcm1hbGl6ZSgpO1xuICAgIHRoaXMuX3NjZW5lLmFkZChkaXJlY3Rpb25hbExpZ2h0Mik7XG4gIH1cblxuICBfaW5pdENvbnRyb2xzKCkge1xuICAgIC8vIGNvbnRyb2xzXG4gICAgdGhpcy5fY29udHJvbHMgPSBuZXcgQ29udHJvbHNUcmFja2JhbGwodGhpcy5fY2FtZXJhLCB0aGlzLl9jb250YWluZXIpO1xuICAgIHRoaXMuX2NvbnRyb2xzLnJvdGF0ZVNwZWVkID0gMS40O1xuICAgIHRoaXMuX2NvbnRyb2xzLnpvb21TcGVlZCA9IDEuMjtcbiAgICB0aGlzLl9jb250cm9scy5wYW5TcGVlZCA9IDAuODtcbiAgfVxuXG59XG4iLCIvKipcbiAqIEBtb2R1bGUgaGVscGVycy94L3ZvbHVtZVxuICovXG5cbmltcG9ydCBIZWxwZXJzU3RhY2sgZnJvbSAnLi4vaGVscGVycy5zdGFjayc7XG5pbXBvcnQgTG9hZGVyc1ZvbHVtZSBmcm9tICcuLi8uLi9sb2FkZXJzL2xvYWRlcnMudm9sdW1lJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgZXh0ZW5kcyBUSFJFRS5PYmplY3QzRCB7XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMuX2ZpbGUgPSBudWxsO1xuICAgIHRoaXMuX3Byb2dyZXNzYmFyQ29udGFpbmVyID0gbnVsbDtcbiAgICB0aGlzLl9zdGFjayA9IG51bGw7XG4gICAgdGhpcy5fY2VudGVyTFBTID0gbnVsbDtcbiAgICB0aGlzLl94U2xpY2UgPSBudWxsO1xuICAgIHRoaXMuX3lTbGljZSA9IG51bGw7XG4gICAgdGhpcy5felNsaWNlID0gbnVsbDtcbiAgfVxuXG4gIC8vIGFjY2Vzc29yIHByb3BlcnRpZXNcbiAgZ2V0IGZpbGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZpbGU7XG4gIH1cblxuICBzZXQgZmlsZShmbmFtZSkge1xuICAgIHRoaXMuX2ZpbGUgPSBmbmFtZTtcbiAgfVxuXG4gIHNldCBwcm9ncmVzc2JhckNvbnRhaW5lcihjb250YWluZXIpIHtcbiAgICB0aGlzLl9wcm9ncmVzc2JhckNvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgfVxuXG4gIGdldCBjZW50ZXJMUFMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NlbnRlckxQUztcbiAgfVxuXG4gIGdldCBzdGFjaygpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RhY2s7XG4gIH1cblxuICAvLyBwcml2YXRlIG1ldGhvZHNcbiAgX2NyZWF0ZVNsaWNlKG9yaWVudGF0aW9uKSB7XG4gICAgaWYgKHRoaXMuX3N0YWNrKSB7XG4gICAgICBjb25zdCBzdGFja0hlbHBlciA9IG5ldyBIZWxwZXJzU3RhY2sodGhpcy5fc3RhY2spO1xuICAgICAgc3RhY2tIZWxwZXIub3JpZW50YXRpb24gPSBvcmllbnRhdGlvbjtcblxuICAgICAgaWYgKG9yaWVudGF0aW9uPT09MCkge1xuICAgICAgICBzdGFja0hlbHBlci5ib3JkZXIuY29sb3IgPSAweEY0NDMzNjtcbiAgICAgICAgdGhpcy5feFNsaWNlID0gc3RhY2tIZWxwZXI7XG4gICAgICB9IGVsc2UgaWYgKG9yaWVudGF0aW9uPT09MSkge1xuICAgICAgICBzdGFja0hlbHBlci5iYm94LnZpc2libGUgPSBmYWxzZTtcbiAgICAgICAgc3RhY2tIZWxwZXIuYm9yZGVyLmNvbG9yID0gMHg0Q0FGNTA7XG4gICAgICAgIHRoaXMuX3lTbGljZSA9IHN0YWNrSGVscGVyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhY2tIZWxwZXIuYmJveC52aXNpYmxlID0gZmFsc2U7XG4gICAgICAgIHN0YWNrSGVscGVyLmJvcmRlci5jb2xvciA9IDB4MjE5NkYzO1xuICAgICAgICB0aGlzLl96U2xpY2UgPSBzdGFja0hlbHBlcjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fY2VudGVyTFBTID0gc3RhY2tIZWxwZXIuc3RhY2sud29ybGRDZW50ZXIoKTtcbiAgICB9XG4gIH1cblxuICAvLyBwdWJsaWMgbWV0aG9kc1xuICBsb2FkKCkge1xuICAgIGlmICh0aGlzLmZpbGUpIHtcbiAgICAgIC8vIGluc3RhbnRpYXRlIHRoZSBsb2FkZXJcbiAgICAgIC8vIGl0IGxvYWRzIGFuZCBwYXJzZXMgdGhlIGRpY29tIGltYWdlXG4gICAgICBjb25zdCBsb2FkZXIgPSBuZXcgTG9hZGVyc1ZvbHVtZSh0aGlzLl9wcm9ncmVzc2JhckNvbnRhaW5lcik7XG4gICAgICByZXR1cm4gbG9hZGVyLmxvYWQodGhpcy5maWxlKS50aGVuKCgpID0+IHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICBpZiAobG9hZGVyLmRhdGEubGVuZ3RoIDw9IDApIHtcbiAgICAgICAgICAgIHJldHVybiByZWplY3Qoe21lc3NhZ2U6IGBObyBkYXRhIGxvYWRlZDogJHtsb2FkZXIuZGF0YX0uYH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIGNyZWF0ZSB0aGUgdGhyZWUgc2xpY2VzIHdoZW4gYWxsIGZpbGVzIGhhdmUgYmVlbiBsb2FkZWRcbiAgICAgICAgICBjb25zdCBzZXJpZXMgPSBsb2FkZXIuZGF0YVswXS5tZXJnZVNlcmllcyhsb2FkZXIuZGF0YSlbMF07XG4gICAgICAgICAgbG9hZGVyLmZyZWUoKTtcblxuICAgICAgICAgIHRoaXMuX3N0YWNrID0gc2VyaWVzLnN0YWNrWzBdO1xuICAgICAgICAgIHRoaXMuX2NyZWF0ZVNsaWNlKDApO1xuICAgICAgICAgIHRoaXMuYWRkKHRoaXMuX3hTbGljZSk7XG4gICAgICAgICAgdGhpcy5fY3JlYXRlU2xpY2UoMSk7XG4gICAgICAgICAgdGhpcy5hZGQodGhpcy5feVNsaWNlKTtcbiAgICAgICAgICB0aGlzLl9jcmVhdGVTbGljZSgyKTtcbiAgICAgICAgICB0aGlzLmFkZCh0aGlzLl96U2xpY2UpO1xuXG4gICAgICAgICAgcmV0dXJuIHJlc29sdmUodGhpcyk7XG4gICAgICAgIH0pO1xuICAgICAgfSkuY2F0Y2goZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgbG9hZGVyLmZyZWUoKTtcbiAgICAgICAgd2luZG93LmNvbnNvbGUubG9nKCdTb21ldGhpbmcgd2VudCB3cm9uZyBsb2FkaW5nIHRoZSB2b2x1bWUuLi4nKTtcbiAgICAgICAgd2luZG93LmNvbnNvbGUubG9nKGVycm9yKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBQcm9taXNlLnJlamVjdCh7bWVzc2FnZTogYEZpbGUgbm90IGRlZmluZWQ6ICR7dGhpcy5maWxlfS5gfSk7XG4gIH1cbn1cbiIsIi8qKiBJbXBvcnRzICoqL1xuaW1wb3J0IEhlbHBlcnNQcm9ncmVzc0JhciBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMucHJvZ3Jlc3NiYXInO1xuaW1wb3J0IEV2ZW50RW1pdHRlciBmcm9tICdldmVudHMnO1xuXG5cbi8qKlxuICpcbiAqIEl0IGlzIHR5cGljYWxseSB1c2VkIHRvIGxvYWQgYSBESUNPTSBpbWFnZS4gVXNlIGxvYWRpbmcgbWFuYWdlciBmb3JcbiAqIGFkdmFuY2VkIHVzYWdlLCBzdWNoIGFzIG11bHRpcGxlIGZpbGVzIGhhbmRsaW5nLlxuICpcbiAqIERlbW86IHtAbGluayBodHRwczovL2ZubmRzYy5naXRodWIuaW8vdmpzI2xvYWRlcl9kaWNvbX1cbiAqXG4gKiBAbW9kdWxlIGxvYWRlcnMvYmFzZVxuICogQGV4dGVuZHMgRXZlbnRFbWl0dGVyXG4gKiBAZXhhbXBsZVxuICogdmFyIGZpbGVzID0gWycvZGF0YS9kY20vZnJ1aXQnXTtcbiAqXG4gKiAvLyBJbnN0YW50aWF0ZSBhIGRpY29tIGxvYWRlclxuICogdmFyIGxEaWNvbW9hZGVyID0gbmV3IGRpY29tKCk7XG4gKlxuICogLy8gbG9hZCBhIHJlc291cmNlXG4gKiBsb2FkZXIubG9hZChcbiAqICAgLy8gcmVzb3VyY2UgVVJMXG4gKiAgIGZpbGVzWzBdLFxuICogICAvLyBGdW5jdGlvbiB3aGVuIHJlc291cmNlIGlzIGxvYWRlZFxuICogICBmdW5jdGlvbihvYmplY3QpIHtcbiAqICAgICAvL3NjZW5lLmFkZCggb2JqZWN0ICk7XG4gKiAgICAgd2luZG93LmNvbnNvbGUubG9nKG9iamVjdCk7XG4gKiAgIH1cbiAqICk7XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExvYWRlcnNCYXNlIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIExvYWRlci5cbiAgICogQHBhcmFtIHtkb219IGNvbnRhaW5lciAtIFRoZSBkb20gY29udGFpbmVyIG9mIGxvYWRlci5cbiAgICogQHBhcmFtIHtvYmplY3R9IFByb2dyZXNzQmFyIC0gVGhlIHByb2dyZXNzYmFyIG9mIGxvYWRlci5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGNvbnRhaW5lciA9IG51bGwsIFByb2dyZXNzQmFyID0gSGVscGVyc1Byb2dyZXNzQmFyKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLl9sb2FkZWQgPSAtMTtcbiAgICB0aGlzLl90b3RhbExvYWRlZCA9IC0xO1xuICAgIHRoaXMuX3BhcnNlZCA9IC0xO1xuICAgIHRoaXMuX3RvdGFsUGFyc2VkID0gLTE7XG5cbiAgICB0aGlzLl9kYXRhID0gW107XG5cbiAgICB0aGlzLl9jb250YWluZXIgPSBjb250YWluZXI7XG4gICAgdGhpcy5fcHJvZ3Jlc3NCYXIgPSBudWxsO1xuICAgIGlmICh0aGlzLl9jb250YWluZXIgJiYgUHJvZ3Jlc3NCYXIpIHtcbiAgICAgIHRoaXMuX3Byb2dyZXNzQmFyID0gbmV3IFByb2dyZXNzQmFyKHRoaXMuX2NvbnRhaW5lcik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIGZyZWUgdGhlIHJlZmVyZW5jZS5cbiAgICovXG4gIGZyZWUoKSB7XG4gICAgdGhpcy5fY29udGFpbmVyID0gbnVsbDtcbiAgICAvLyB0aGlzLl9oZWxwZXJzUHJvZ3Jlc3NCYXIgPSBudWxsO1xuXG4gICAgaWYgKHRoaXMuX3Byb2dyZXNzQmFyKSB7XG4gICAgICB0aGlzLl9wcm9ncmVzc0Jhci5mcmVlKCk7XG4gICAgICB0aGlzLl9wcm9ncmVzc0JhciA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIGxvYWQgdGhlIHJlc291cmNlIGJ5IHVybC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHVybCAtIHJlc291cmNlIHVybC5cbiAgICogQHJldHVybiB7cHJvbWlzZX0gcHJvbWlzZS5cbiAgICovXG4gIGZldGNoKHVybCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25zdCByZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICByZXF1ZXN0Lm9wZW4oJ0dFVCcsIHVybCk7XG4gICAgICByZXF1ZXN0LmNyb3NzT3JpZ2luID0gdHJ1ZTtcbiAgICAgIHJlcXVlc3QucmVzcG9uc2VUeXBlID0gJ2FycmF5YnVmZmVyJztcblxuICAgICAgcmVxdWVzdC5vbmxvYWRzdGFydCA9IChldmVudCkgPT4ge1xuICAgICAgICAvLyBlbWl0ICdmZXRjaC1zdGFydCcgZXZlbnRcbiAgICAgICAgdGhpcy5lbWl0KCdmZXRjaC1zdGFydCcsIHtcbiAgICAgICAgICBmaWxlOiB1cmwsXG4gICAgICAgICAgdGltZTogbmV3IERhdGUoKSxcbiAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gICAgICByZXF1ZXN0Lm9ubG9hZCA9IChldmVudCkgPT4ge1xuICAgICAgICBpZiAocmVxdWVzdC5zdGF0dXMgPT09IDIwMCkge1xuICAgICAgICAgIHRoaXMuX2xvYWRlZCA9IGV2ZW50LmxvYWRlZDtcbiAgICAgICAgICB0aGlzLl90b3RhbExvYWRlZCA9IGV2ZW50LnRvdGFsO1xuXG4gICAgICAgICAgLy8gd2lsbCBiZSByZW1vdmVkIGFmdGVyIGV2ZW50ZXIgc2V0IHVwXG4gICAgICAgICAgaWYgKHRoaXMuX3Byb2dyZXNzQmFyKSB7XG4gICAgICAgICAgICB0aGlzLl9wcm9ncmVzc0Jhci51cGRhdGUodGhpcy5fbG9hZGVkLCB0aGlzLl90b3RhbExvYWRlZCxcbiAgICAgICAgICAgICAgJ2xvYWQnKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsZXQgYnVmZmVyID0gcmVxdWVzdC5yZXNwb25zZTtcbiAgICAgICAgICBsZXQgcmVzcG9uc2UgPSB7XG4gICAgICAgICAgICB1cmwsXG4gICAgICAgICAgICBidWZmZXIsXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIC8vIGVtaXQgJ2ZldGNoLXN1Y2Nlc3MnIGV2ZW50XG4gICAgICAgICAgdGhpcy5lbWl0KCdmZXRjaC1zdWNjZXNzJywge1xuICAgICAgICAgICAgZmlsZTogdXJsLFxuICAgICAgICAgICAgdGltZTogbmV3IERhdGUoKSxcbiAgICAgICAgICAgIHRvdGFsTG9hZGVkOiBldmVudC50b3RhbCxcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHJlc29sdmUocmVzcG9uc2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlamVjdChyZXF1ZXN0LnN0YXR1c1RleHQpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICByZXF1ZXN0Lm9uZXJyb3IgPSAoKSA9PiB7XG4gICAgICAgIC8vIGVtaXQgJ2ZldGNoLWVycm9yJyBldmVudFxuICAgICAgICB0aGlzLmVtaXQoJ2ZldGNoLWVycm9yJywge1xuICAgICAgICAgIGZpbGU6IHVybCxcbiAgICAgICAgICB0aW1lOiBuZXcgRGF0ZSgpLFxuICAgICAgICB9KTtcblxuICAgICAgICByZWplY3QocmVxdWVzdC5zdGF0dXNUZXh0KTtcbiAgICAgIH07XG5cbiAgICAgIHJlcXVlc3Qub25hYm9ydCA9IChldmVudCkgPT4ge1xuICAgICAgICAvLyBlbWl0ICdmZXRjaC1zdGFydCcgZXZlbnRcbiAgICAgICAgdGhpcy5lbWl0KCdmZXRjaC1hYm9ydCcsIHtcbiAgICAgICAgICBmaWxlOiB1cmwsXG4gICAgICAgICAgdGltZTogbmV3IERhdGUoKSxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmVqZWN0KHJlcXVlc3Quc3RhdHVzVGV4dCk7XG4gICAgICB9O1xuXG4gICAgICByZXF1ZXN0Lm9udGltZW91dCA9ICgpID0+IHtcbiAgICAgICAgLy8gZW1pdCAnZmV0Y2gtdGltZW91dCcgZXZlbnRcbiAgICAgICAgdGhpcy5lbWl0KCdmZXRjaC10aW1lb3V0Jywge1xuICAgICAgICAgIGZpbGU6IHVybCxcbiAgICAgICAgICB0aW1lOiBuZXcgRGF0ZSgpLFxuICAgICAgICB9KTtcblxuICAgICAgICByZWplY3QocmVxdWVzdC5zdGF0dXNUZXh0KTtcbiAgICAgIH07XG5cbiAgICAgIHJlcXVlc3Qub25wcm9ncmVzcyA9IChldmVudCkgPT4ge1xuICAgICAgICB0aGlzLl9sb2FkZWQgPSBldmVudC5sb2FkZWQ7XG4gICAgICAgIHRoaXMuX3RvdGFsTG9hZGVkID0gZXZlbnQudG90YWw7XG4gICAgICAgIC8vIGVtaXQgJ2ZldGNoLXByb2dyZXNzJyBldmVudFxuICAgICAgICB0aGlzLmVtaXQoJ2ZldGNoLXByb2dyZXNzJywge1xuICAgICAgICAgIGZpbGU6IHVybCxcbiAgICAgICAgICB0b3RhbDogZXZlbnQudG90YWwsXG4gICAgICAgICAgbG9hZGVkOiBldmVudC5sb2FkZWQsXG4gICAgICAgICAgdGltZTogbmV3IERhdGUoKSxcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIHdpbGwgYmUgcmVtb3ZlZCBhZnRlciBldmVudGVyIHNldCB1cFxuICAgICAgICBpZiAodGhpcy5fcHJvZ3Jlc3NCYXIpIHtcbiAgICAgICAgICB0aGlzLl9wcm9ncmVzc0Jhci51cGRhdGUodGhpcy5fbG9hZGVkLCB0aGlzLl90b3RhbExvYWRlZCxcbiAgICAgICAgICAgICdsb2FkJyk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHJlcXVlc3Qub25sb2FkZW5kID0gKGV2ZW50KSA9PiB7XG4gICAgICAgIC8vIGVtaXQgJ2ZldGNoLWVuZCcgZXZlbnRcbiAgICAgICAgdGhpcy5lbWl0KCdmZXRjaC1lbmQnLCB7XG4gICAgICAgICAgZmlsZTogdXJsLFxuICAgICAgICAgIHRpbWU6IG5ldyBEYXRlKCksXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBqdXN0IHVzZSBvbmxvYWQgd2hlbiBzdWNjZXNzIGFuZCBvbmVycm9yIHdoZW4gZmFpbHVyZSwgZXRjIG9uYWJvcnRcbiAgICAgICAgLy8gcmVqZWN0KHJlcXVlc3Quc3RhdHVzVGV4dCk7XG4gICAgICB9O1xuXG4gICAgICByZXF1ZXN0LnNlbmQoKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBwYXJzZSB0aGUgZGF0YSBsb2FkZWRcbiAgICogU0hPVUxEIEJFIGltcGxlbWVudGQgYnkgZGV0YWlsIGxvYWRlci5cbiAgICogQHBhcmFtIHtvYmplY3R9IHJlc3BvbnNlIC0gbG9hZGVkIGRhdGEuXG4gICAqIEByZXR1cm4ge3Byb21pc2V9IHByb21pc2UuXG4gICAqL1xuICBwYXJzZShyZXNwb25zZSkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICByZXNvbHZlKHJlc3BvbnNlKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBkZWZhdWx0IGxvYWQgc2VxdWVuY2UgZ3JvdXAgcHJvbWlzZS5cbiAgICogQHBhcmFtIHthcnJheX0gdXJsIC0gcmVzb3VyY2UgdXJsLlxuICAgKiBAcmV0dXJuIHtwcm9taXNlfSBwcm9taXNlLlxuICAgKi9cbiAgbG9hZFNlcXVlbmNlR3JvdXAodXJsKSB7XG4gICAgY29uc3QgZmV0Y2hTZXF1ZW5jZSA9IFtdO1xuXG4gICAgdXJsLmZvckVhY2goKGZpbGUpID0+IHtcbiAgICAgIGZldGNoU2VxdWVuY2UucHVzaChcbiAgICAgICAgdGhpcy5mZXRjaChmaWxlKVxuICAgICAgKTtcbiAgICB9KTtcblxuICAgIHJldHVybiBQcm9taXNlLmFsbChmZXRjaFNlcXVlbmNlKVxuICAgICAgLnRoZW4oKHJhd2RhdGEpID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2UocmF3ZGF0YSk7XG4gICAgICB9KVxuICAgICAgLnRoZW4oKGRhdGEpID0+IHtcbiAgICAgICAgdGhpcy5fZGF0YS5wdXNoKGRhdGEpO1xuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgIH0pXG4gICAgICAuY2F0Y2goZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgd2luZG93LmNvbnNvbGUubG9nKCdvb3BzLi4uIHNvbWV0aGluZyB3ZW50IHdyb25nLi4uJyk7XG4gICAgICAgIHdpbmRvdy5jb25zb2xlLmxvZyhlcnJvcik7XG4gICAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBkZWZhdWx0IGxvYWQgc2VxdWVuY2UgcHJvbWlzZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHVybCAtIHJlc291cmNlIHVybC5cbiAgICogQHJldHVybiB7cHJvbWlzZX0gcHJvbWlzZS5cbiAgICovXG4gIGxvYWRTZXF1ZW5jZSh1cmwpIHtcbiAgICByZXR1cm4gdGhpcy5mZXRjaCh1cmwpXG4gICAgICAudGhlbigocmF3ZGF0YSkgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZShyYXdkYXRhKTtcbiAgICAgIH0pXG4gICAgICAudGhlbigoZGF0YSkgPT4ge1xuICAgICAgICB0aGlzLl9kYXRhLnB1c2goZGF0YSk7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgfSlcbiAgICAgIC5jYXRjaChmdW5jdGlvbihlcnJvcikge1xuICAgICAgICB3aW5kb3cuY29uc29sZS5sb2coJ29vcHMuLi4gc29tZXRoaW5nIHdlbnQgd3JvbmcuLi4nKTtcbiAgICAgICAgd2luZG93LmNvbnNvbGUubG9nKGVycm9yKTtcbiAgICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIGxvYWQgdGhlIGRhdGEgYnkgdXJsKHVybHMpXG4gICAqIEBwYXJhbSB7c3RyaW5nfGFycmF5fSB1cmwgLSByZXNvdXJjZSB1cmwuXG4gICAqIEByZXR1cm4ge3Byb21pc2V9IHByb21pc2VcbiAgICovXG4gIGxvYWQodXJsKSB7XG4gICAgLy8gaWYgd2UgbG9hZCBhIHNpbmdsZSBmaWxlLCBjb252ZXJ0IGl0IHRvIGFuIGFycmF5XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHVybCkpIHtcbiAgICAgIHVybCA9IFt1cmxdO1xuICAgIH1cblxuICAgIC8vIGVtaXQgJ2xvYWQtc3RhcnQnIGV2ZW50XG4gICAgdGhpcy5lbWl0KCdsb2FkLXN0YXJ0Jywge1xuICAgICAgZmlsZXM6IHVybCxcbiAgICAgIHRpbWU6IG5ldyBEYXRlKCksXG4gICAgfSk7XG5cbiAgICBjb25zdCBsb2FkU2VxdWVuY2VzID0gW107XG4gICAgdXJsLmZvckVhY2goKGZpbGUpID0+IHtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShmaWxlKSkge1xuICAgICAgICBsb2FkU2VxdWVuY2VzLnB1c2goXG4gICAgICAgICAgdGhpcy5sb2FkU2VxdWVuY2UoZmlsZSlcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxvYWRTZXF1ZW5jZXMucHVzaChcbiAgICAgICAgICB0aGlzLmxvYWRTZXF1ZW5jZUdyb3VwKGZpbGUpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKGxvYWRTZXF1ZW5jZXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCBkYXRhXG4gICAqIEBwYXJhbSB7YXJyYXl9IGRhdGFcbiAgICovXG4gIHNldCBkYXRhKGRhdGEpIHtcbiAgICB0aGlzLl9kYXRhID0gZGF0YTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgZGF0YVxuICAgKiBAcmV0dXJuIHthcnJheX0gZGF0YSBsb2FkZWRcbiAgICovXG4gIGdldCBkYXRhKCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRhO1xuICB9XG5cbn1cbiIsImltcG9ydCBWb2x1bWUgZnJvbSAnLi9sb2FkZXJzLnZvbHVtZSc7XG5cbi8qKlxuICogQG1vZHVsZSBsb2FkZXJzXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQge1xuICBWb2x1bWUsXG59O1xuIiwiLyoqICogSW1wb3J0cyAqKiovXG5jb25zdCBQQUtPID0gcmVxdWlyZSgncGFrbycpO1xuXG5pbXBvcnQgTG9hZGVyc0Jhc2UgZnJvbSAnLi9sb2FkZXJzLmJhc2UnO1xuaW1wb3J0IENvcmVVdGlscyBmcm9tICcuLi9jb3JlL2NvcmUudXRpbHMnO1xuaW1wb3J0IE1vZGVsc1NlcmllcyBmcm9tICcuLi9tb2RlbHMvbW9kZWxzLnNlcmllcyc7XG5pbXBvcnQgTW9kZWxzU3RhY2sgZnJvbSAnLi4vbW9kZWxzL21vZGVscy5zdGFjayc7XG5pbXBvcnQgTW9kZWxzRnJhbWUgZnJvbSAnLi4vbW9kZWxzL21vZGVscy5mcmFtZSc7XG5pbXBvcnQgUGFyc2Vyc0RpY29tIGZyb20gJy4uL3BhcnNlcnMvcGFyc2Vycy5kaWNvbSc7XG5pbXBvcnQgUGFyc2Vyc01oZCBmcm9tICcuLi9wYXJzZXJzL3BhcnNlcnMubWhkJztcbmltcG9ydCBQYXJzZXJzTmlmdGkgZnJvbSAnLi4vcGFyc2Vycy9wYXJzZXJzLm5pZnRpJztcbmltcG9ydCBQYXJzZXJzTnJyZCBmcm9tICcuLi9wYXJzZXJzL3BhcnNlcnMubnJyZCc7XG5cbi8qKlxuICpcbiAqIEl0IGlzIHR5cGljYWxseSB1c2VkIHRvIGxvYWQgYSBESUNPTSBpbWFnZS4gVXNlIGxvYWRpbmcgbWFuYWdlciBmb3JcbiAqIGFkdmFuY2VkIHVzYWdlLCBzdWNoIGFzIG11bHRpcGxlIGZpbGVzIGhhbmRsaW5nLlxuICpcbiAqIERlbW86IHtAbGluayBodHRwczovL2ZubmRzYy5naXRodWIuaW8vdmpzI2xvYWRlcl9kaWNvbX1cbiAqXG4gKiBAbW9kdWxlIGxvYWRlcnMvdm9sdW1lc1xuICogQGV4dGVuZHMgTG9hZGVyc0Jhc2VcbiAqIEBleGFtcGxlXG4gKiB2YXIgZmlsZXMgPSBbJy9kYXRhL2RjbS9mcnVpdCddO1xuICpcbiAqIC8vIEluc3RhbnRpYXRlIGEgZGljb20gbG9hZGVyXG4gKiB2YXIgbERpY29tb2FkZXIgPSBuZXcgZGljb20oKTtcbiAqXG4gKiAvLyBsb2FkIGEgcmVzb3VyY2VcbiAqIGxvYWRlci5sb2FkKFxuICogICAvLyByZXNvdXJjZSBVUkxcbiAqICAgZmlsZXNbMF0sXG4gKiAgIC8vIEZ1bmN0aW9uIHdoZW4gcmVzb3VyY2UgaXMgbG9hZGVkXG4gKiAgIGZ1bmN0aW9uKG9iamVjdCkge1xuICogICAgIC8vc2NlbmUuYWRkKCBvYmplY3QgKTtcbiAqICAgICB3aW5kb3cuY29uc29sZS5sb2cob2JqZWN0KTtcbiAqICAgfVxuICogKTtcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTG9hZGVyc1ZvbHVtZXMgZXh0ZW5kcyBMb2FkZXJzQmFzZSB7XG5cbiAgLyoqXG4gICAqIFBhcnNlIHJlc3BvbnNlLlxuICAgKiByZXNwb25zZSBpcyBmb3JtYXRlZCBhczpcbiAgICogICAge1xuICAgKiAgICAgIHVybDogJ3Jlc291cmNlIHVybCcsXG4gICAqICAgICAgYnVmZmVyOiB4bWxyZXNwb25zZSxcbiAgICogICAgfVxuICAgKiBAcGFyYW0ge29iamVjdH0gcmVzcG9uc2UgLSByZXNwb25zZVxuICAgKiBAcmV0dXJuIHtwcm9taXNlfSBwcm9taXNlXG4gICAqL1xuICBwYXJzZShyZXNwb25zZSkge1xuICAgIC8vIGVtaXQgJ3BhcnNlLXN0YXJ0JyBldmVudFxuICAgIHRoaXMuZW1pdCgncGFyc2Utc3RhcnQnLCB7XG4gICAgICBmaWxlOiByZXNwb25zZS51cmwsXG4gICAgICB0aW1lOiBuZXcgRGF0ZSgpLFxuICAgIH0pO1xuICAgIC8vIGdpdmUgYSBjaGFuY2UgdG8gdGhlIFVJIHRvIHVwZGF0ZSBiZWNhdXNlXG4gICAgLy8gYWZ0ZXIgdGhlIHJlbmRlcmluZyB3aWxsIGJlIGJsb2NrZWQgd2l0aCBpbnRlbnNpdmUgSlNcbiAgICAvLyB3aWxsIGJlIHJlbW92ZWQgYWZ0ZXIgZXZlbnRlciBzZXQgdXBcbiAgICBpZiAodGhpcy5fcHJvZ3Jlc3NCYXIpIHtcbiAgICAgIHRoaXMuX3Byb2dyZXNzQmFyLnVwZGF0ZSgwLCAxMDAsICdwYXJzZScpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgUHJvbWlzZShcbiAgICAgIChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgd2luZG93LnNldFRpbWVvdXQoXG4gICAgICAgICAgKCkgPT4ge1xuICAgICAgICAgICAgcmVzb2x2ZShuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgIGxldCBkYXRhID0gcmVzcG9uc2U7XG5cbiAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgICAgICAgICAgICAgZGF0YSA9IFtkYXRhXTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGRhdGEuZm9yRWFjaCgoZGF0YXNldCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuX3ByZXByb2Nlc3MoZGF0YXNldCk7XG4gICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIGlmIChkYXRhLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIGRhdGEgPSBkYXRhWzBdO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGlmIHJhdy9taGQgcGFpclxuICAgICAgICAgICAgICAgIGxldCBtaGRGaWxlID1cbiAgICAgICAgICAgICAgICAgIGRhdGEuZmlsdGVyKHRoaXMuX2ZpbHRlckJ5RXh0ZW5zaW9uLmJpbmQobnVsbCwgJ01IRCcpKTtcbiAgICAgICAgICAgICAgICBsZXQgcmF3RmlsZSA9XG4gICAgICAgICAgICAgICAgICBkYXRhLmZpbHRlcih0aGlzLl9maWx0ZXJCeUV4dGVuc2lvbi5iaW5kKG51bGwsICdSQVcnKSk7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGEubGVuZ3RoID09PSAyICYmXG4gICAgICAgICAgICAgICAgICAgIG1oZEZpbGUubGVuZ3RoID09PSAxICYmXG4gICAgICAgICAgICAgICAgICAgIHJhd0ZpbGUubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICBkYXRhLnVybCA9IG1oZEZpbGVbMF0udXJsO1xuICAgICAgICAgICAgICAgICAgZGF0YS5leHRlbnNpb24gPSBtaGRGaWxlWzBdLmV4dGVuc2lvbjtcbiAgICAgICAgICAgICAgICAgIGRhdGEubWhkQnVmZmVyID0gbWhkRmlsZVswXS5idWZmZXI7XG4gICAgICAgICAgICAgICAgICBkYXRhLnJhd0J1ZmZlciA9IHJhd0ZpbGVbMF0uYnVmZmVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGxldCBQYXJzZXIgPSB0aGlzLl9wYXJzZXIoZGF0YS5leHRlbnNpb24pO1xuICAgICAgICAgICAgICBpZiAoIVBhcnNlcikge1xuICAgICAgICAgICAgICAgIC8vIGVtaXQgJ3BhcnNlLWVycm9yJyBldmVudFxuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgncGFyc2UtZXJyb3InLCB7XG4gICAgICAgICAgICAgICAgICBmaWxlOiByZXNwb25zZS51cmwsXG4gICAgICAgICAgICAgICAgICB0aW1lOiBuZXcgRGF0ZSgpLFxuICAgICAgICAgICAgICAgICAgZXJyb3I6IGRhdGEuZmlsZW5hbWUgKyAnY2FuIG5vdCBiZSBwYXJzZWQuJyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZWplY3QoZGF0YS5maWxlbmFtZSArICcgY2FuIG5vdCBiZSBwYXJzZWQuJyk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAvLyBjaGVjayBleHRlbnNpb25cbiAgICAgICAgICAgICAgbGV0IHZvbHVtZVBhcnNlciA9IG51bGw7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdm9sdW1lUGFyc2VyID0gbmV3IFBhcnNlcihkYXRhLCAwKTtcbiAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHdpbmRvdy5jb25zb2xlLmxvZyhlKTtcbiAgICAgICAgICAgICAgICAvLyBlbWl0ICdwYXJzZS1lcnJvcicgZXZlbnRcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ3BhcnNlLWVycm9yJywge1xuICAgICAgICAgICAgICAgICAgZmlsZTogcmVzcG9uc2UudXJsLFxuICAgICAgICAgICAgICAgICAgdGltZTogbmV3IERhdGUoKSxcbiAgICAgICAgICAgICAgICAgIGVycm9yOiBlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIC8vIGNyZWF0ZSBhIHNlcmllc1xuICAgICAgICAgICAgICBsZXQgc2VyaWVzID0gbmV3IE1vZGVsc1NlcmllcygpO1xuICAgICAgICAgICAgICAvLyBnbG9iYWwgaW5mb3JtYXRpb25cbiAgICAgICAgICAgICAgc2VyaWVzLnNlcmllc0luc3RhbmNlVUlEID0gdm9sdW1lUGFyc2VyLnNlcmllc0luc3RhbmNlVUlEKCk7XG4gICAgICAgICAgICAgIHNlcmllcy50cmFuc2ZlclN5bnRheFVJRCA9IHZvbHVtZVBhcnNlci50cmFuc2ZlclN5bnRheFVJRCgpO1xuICAgICAgICAgICAgICBzZXJpZXMuc2VyaWVzRGVzY3JpcHRpb24gPSB2b2x1bWVQYXJzZXIuc2VyaWVzRGVzY3JpcHRpb24oKTtcbiAgICAgICAgICAgICAgc2VyaWVzLnN0dWR5RGVzY3JpcHRpb24gPSB2b2x1bWVQYXJzZXIuc3R1ZHlEZXNjcmlwdGlvbigpO1xuICAgICAgICAgICAgICBzZXJpZXMubnVtYmVyT2ZGcmFtZXMgPSB2b2x1bWVQYXJzZXIubnVtYmVyT2ZGcmFtZXMoKTtcbiAgICAgICAgICAgICAgaWYgKCFzZXJpZXMubnVtYmVyT2ZGcmFtZXMpIHtcbiAgICAgICAgICAgICAgICBzZXJpZXMubnVtYmVyT2ZGcmFtZXMgPSAxO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHNlcmllcy5udW1iZXJPZkNoYW5uZWxzID0gdm9sdW1lUGFyc2VyLm51bWJlck9mQ2hhbm5lbHMoKTtcbiAgICAgICAgICAgICAgc2VyaWVzLm1vZGFsaXR5ID0gdm9sdW1lUGFyc2VyLm1vZGFsaXR5KCk7XG4gICAgICAgICAgICAgIC8vIGlmIGl0IGlzIGEgc2VnbWVudGF0aW9uLCBhdHRhY2ggZXh0cmEgaW5mb3JtYXRpb25cbiAgICAgICAgICAgICAgaWYgKHNlcmllcy5tb2RhbGl0eSA9PT0gJ1NFRycpIHtcbiAgICAgICAgICAgICAgICAvLyBjb2xvcnNcbiAgICAgICAgICAgICAgICAvLyBsYWJlbHNcbiAgICAgICAgICAgICAgICAvLyBldGMuXG4gICAgICAgICAgICAgICAgc2VyaWVzLnNlZ21lbnRhdGlvblR5cGUgPSB2b2x1bWVQYXJzZXIuc2VnbWVudGF0aW9uVHlwZSgpO1xuICAgICAgICAgICAgICAgIHNlcmllcy5zZWdtZW50YXRpb25TZWdtZW50cyA9XG4gICAgICAgICAgICAgICAgICB2b2x1bWVQYXJzZXIuc2VnbWVudGF0aW9uU2VnbWVudHMoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLyBwYXRpZW50IGluZm9ybWF0aW9uXG4gICAgICAgICAgICAgIHNlcmllcy5wYXRpZW50SUQgPSB2b2x1bWVQYXJzZXIucGF0aWVudElEKCk7XG4gICAgICAgICAgICAgIHNlcmllcy5wYXRpZW50TmFtZSA9IHZvbHVtZVBhcnNlci5wYXRpZW50TmFtZSgpO1xuICAgICAgICAgICAgICBzZXJpZXMucGF0aWVudEFnZSA9IHZvbHVtZVBhcnNlci5wYXRpZW50QWdlKCk7XG4gICAgICAgICAgICAgIHNlcmllcy5wYXRpZW50QmlydGhkYXRlID0gdm9sdW1lUGFyc2VyLnBhdGllbnRCaXJ0aGRhdGUoKTtcbiAgICAgICAgICAgICAgc2VyaWVzLnBhdGllbnRTZXggPSB2b2x1bWVQYXJzZXIucGF0aWVudFNleCgpO1xuXG4gICAgICAgICAgICAgIC8vIGp1c3QgY3JlYXRlIDEgZHVtbXkgc3RhY2sgZm9yIG5vd1xuICAgICAgICAgICAgICBsZXQgc3RhY2sgPSBuZXcgTW9kZWxzU3RhY2soKTtcbiAgICAgICAgICAgICAgc3RhY2subnVtYmVyT2ZDaGFubmVscyA9IHZvbHVtZVBhcnNlci5udW1iZXJPZkNoYW5uZWxzKCk7XG4gICAgICAgICAgICAgIHN0YWNrLnBpeGVsUmVwcmVzZW50YXRpb24gPVxuICAgICAgICAgICAgICAgIHZvbHVtZVBhcnNlci5waXhlbFJlcHJlc2VudGF0aW9uKCk7XG4gICAgICAgICAgICAgIHN0YWNrLnBpeGVsVHlwZSA9IHZvbHVtZVBhcnNlci5waXhlbFR5cGUoKTtcbiAgICAgICAgICAgICAgc3RhY2suaW52ZXJ0ID0gdm9sdW1lUGFyc2VyLmludmVydCgpO1xuICAgICAgICAgICAgICBzdGFjay5zcGFjaW5nQmV0d2VlblNsaWNlcyA9XG4gICAgICAgICAgICAgICAgdm9sdW1lUGFyc2VyLnNwYWNpbmdCZXR3ZWVuU2xpY2VzKCk7XG4gICAgICAgICAgICAgIHN0YWNrLm1vZGFsaXR5ID0gc2VyaWVzLm1vZGFsaXR5O1xuICAgICAgICAgICAgICAvLyBpZiBpdCBpcyBhIHNlZ21lbnRhdGlvbiwgYXR0YWNoIGV4dHJhIGluZm9ybWF0aW9uXG4gICAgICAgICAgICAgIGlmIChzdGFjay5tb2RhbGl0eSA9PT0gJ1NFRycpIHtcbiAgICAgICAgICAgICAgICAvLyBjb2xvcnNcbiAgICAgICAgICAgICAgICAvLyBsYWJlbHNcbiAgICAgICAgICAgICAgICAvLyBldGMuXG4gICAgICAgICAgICAgICAgc3RhY2suc2VnbWVudGF0aW9uVHlwZSA9IHNlcmllcy5zZWdtZW50YXRpb25UeXBlO1xuICAgICAgICAgICAgICAgIHN0YWNrLnNlZ21lbnRhdGlvblNlZ21lbnRzID0gc2VyaWVzLnNlZ21lbnRhdGlvblNlZ21lbnRzO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHNlcmllcy5zdGFjay5wdXNoKHN0YWNrKTtcbiAgICAgICAgICAgICAgLy8gcmVjdXJzaXZlIGNhbGwgZm9yIGVhY2ggZnJhbWVcbiAgICAgICAgICAgICAgLy8gYmV0dGVyIHRoYW4gZm9yIGxvb3AgdG8gYmUgYWJsZVxuICAgICAgICAgICAgICAvLyB0byB1cGRhdGUgZG9tIHdpdGggXCJwcm9ncmVzc1wiIGNhbGxiYWNrXG4gICAgICAgICAgICAgIHNldFRpbWVvdXQoXG4gICAgICAgICAgICAgICAgdGhpcy5wYXJzZUZyYW1lKFxuICAgICAgICAgICAgICAgICAgc2VyaWVzLCBzdGFjaywgcmVzcG9uc2UudXJsLCAwLFxuICAgICAgICAgICAgICAgICAgdm9sdW1lUGFyc2VyLCByZXNvbHZlLCByZWplY3QpLCAwKTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICB9LCAxMCk7XG4gICAgICB9XG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiByZWN1cnNpdmUgcGFyc2UgZnJhbWVcbiAgICogQHBhcmFtIHtNb2RlbHNTZXJpZXN9IHNlcmllcyAtIGRhdGEgc2VyaWVzXG4gICAqIEBwYXJhbSB7TW9kZWxzU3RhY2t9IHN0YWNrIC0gZGF0YSBzdGFja1xuICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsIC0gcmVzb3VyY2UgdXJsXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpIC0gZnJhbWUgaW5kZXhcbiAgICogQHBhcmFtIHtwYXJzZXJ9IGRhdGFQYXJzZXIgLSBzZWxlY3RlZCBwYXJzZXJcbiAgICogQHBhcmFtIHtwcm9taXNlLnJlc29sdmV9IHJlc29sdmUgLSBwcm9taXNlIHJlc29sdmUgYXJnc1xuICAgKiBAcGFyYW0ge3Byb21pc2UucmVqZWN0fSByZWplY3QgLSBwcm9taXNlIHJlamVjdCBhcmdzXG4gICAqL1xuICBwYXJzZUZyYW1lKHNlcmllcywgc3RhY2ssIHVybCwgaSwgZGF0YVBhcnNlciwgcmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgbGV0IGZyYW1lID0gbmV3IE1vZGVsc0ZyYW1lKCk7XG4gICAgZnJhbWUuc29wSW5zdGFuY2VVSUQgPSBkYXRhUGFyc2VyLnNvcEluc3RhbmNlVUlEKGkpO1xuICAgIGZyYW1lLnVybCA9IHVybDtcbiAgICBmcmFtZS5pbmRleCA9IGk7XG4gICAgZnJhbWUucm93cyA9IGRhdGFQYXJzZXIucm93cyhpKTtcbiAgICBmcmFtZS5jb2x1bW5zID0gZGF0YVBhcnNlci5jb2x1bW5zKGkpO1xuICAgIGZyYW1lLm51bWJlck9mQ2hhbm5lbHMgPSBzdGFjay5udW1iZXJPZkNoYW5uZWxzO1xuICAgIGZyYW1lLnBpeGVsUmVwcmVzZW50YXRpb24gPSBzdGFjay5waXhlbFJlcHJlc2VudGF0aW9uO1xuICAgIGZyYW1lLnBpeGVsVHlwZSA9IHN0YWNrLnBpeGVsVHlwZTtcbiAgICBmcmFtZS5waXhlbERhdGEgPSBkYXRhUGFyc2VyLmV4dHJhY3RQaXhlbERhdGEoaSk7XG4gICAgZnJhbWUucGl4ZWxTcGFjaW5nID0gZGF0YVBhcnNlci5waXhlbFNwYWNpbmcoaSk7XG4gICAgZnJhbWUuc3BhY2luZ0JldHdlZW5TbGljZXMgPSBkYXRhUGFyc2VyLnNwYWNpbmdCZXR3ZWVuU2xpY2VzKGkpO1xuICAgIGZyYW1lLnNsaWNlVGhpY2tuZXNzID0gZGF0YVBhcnNlci5zbGljZVRoaWNrbmVzcyhpKTtcbiAgICBmcmFtZS5pbWFnZU9yaWVudGF0aW9uID0gZGF0YVBhcnNlci5pbWFnZU9yaWVudGF0aW9uKGkpO1xuICAgIGZyYW1lLnJpZ2h0SGFuZGVkID0gZGF0YVBhcnNlci5yaWdodEhhbmRlZCgpO1xuICAgIHN0YWNrLnJpZ2h0SGFuZGVkID0gZnJhbWUucmlnaHRIYW5kZWQ7XG4gICAgaWYgKGZyYW1lLmltYWdlT3JpZW50YXRpb24gPT09IG51bGwpIHtcbiAgICAgIGZyYW1lLmltYWdlT3JpZW50YXRpb24gPSBbMSwgMCwgMCwgMCwgMSwgMF07XG4gICAgfVxuICAgIGZyYW1lLmltYWdlUG9zaXRpb24gPSBkYXRhUGFyc2VyLmltYWdlUG9zaXRpb24oaSk7XG4gICAgaWYgKGZyYW1lLmltYWdlUG9zaXRpb24gPT09IG51bGwpIHtcbiAgICAgIGZyYW1lLmltYWdlUG9zaXRpb24gPSBbMCwgMCwgaV07XG4gICAgfVxuICAgIGZyYW1lLmRpbWVuc2lvbkluZGV4VmFsdWVzID0gZGF0YVBhcnNlci5kaW1lbnNpb25JbmRleFZhbHVlcyhpKTtcbiAgICBmcmFtZS5iaXRzQWxsb2NhdGVkID0gZGF0YVBhcnNlci5iaXRzQWxsb2NhdGVkKGkpO1xuICAgIGZyYW1lLmluc3RhbmNlTnVtYmVyID0gZGF0YVBhcnNlci5pbnN0YW5jZU51bWJlcihpKTtcbiAgICBmcmFtZS53aW5kb3dDZW50ZXIgPSBkYXRhUGFyc2VyLndpbmRvd0NlbnRlcihpKTtcbiAgICBmcmFtZS53aW5kb3dXaWR0aCA9IGRhdGFQYXJzZXIud2luZG93V2lkdGgoaSk7XG4gICAgZnJhbWUucmVzY2FsZVNsb3BlID0gZGF0YVBhcnNlci5yZXNjYWxlU2xvcGUoaSk7XG4gICAgZnJhbWUucmVzY2FsZUludGVyY2VwdCA9IGRhdGFQYXJzZXIucmVzY2FsZUludGVyY2VwdChpKTtcbiAgICAvLyBzaG91bGQgcGFzcyBmcmFtZSBpbmRleCBmb3IgY29uc2lzdGVuY3kuLi5cbiAgICBmcmFtZS5taW5NYXggPSBkYXRhUGFyc2VyLm1pbk1heFBpeGVsRGF0YShmcmFtZS5waXhlbERhdGEpO1xuXG4gICAgLy8gaWYgc2VyaWVzLm1vXG4gICAgaWYgKHNlcmllcy5tb2RhbGl0eSA9PT0gJ1NFRycpIHtcbiAgICAgIGZyYW1lLnJlZmVyZW5jZWRTZWdtZW50TnVtYmVyID0gZGF0YVBhcnNlci5yZWZlcmVuY2VkU2VnbWVudE51bWJlcihpKTtcbiAgICB9XG5cbiAgICBzdGFjay5mcmFtZS5wdXNoKGZyYW1lKTtcblxuICAgIC8vIHVwZGF0ZSBzdGF0dXNcbiAgICB0aGlzLl9wYXJzZWQgPSBpICsgMTtcbiAgICB0aGlzLl90b3RhbFBhcnNlZCA9IHNlcmllcy5udW1iZXJPZkZyYW1lcztcblxuICAgIC8vIHdpbGwgYmUgcmVtb3ZlZCBhZnRlciBldmVudGVyIHNldCB1cFxuICAgIGlmICh0aGlzLl9wcm9ncmVzc0Jhcikge1xuICAgICAgdGhpcy5fcHJvZ3Jlc3NCYXIudXBkYXRlKHRoaXMuX3BhcnNlZCwgdGhpcy5fdG90YWxQYXJzZWQsICdwYXJzZScpO1xuICAgIH1cblxuICAgIC8vIGVtaXQgJ3BhcnNpbmcnIGV2ZW50XG4gICAgdGhpcy5lbWl0KCdwYXJzaW5nJywge1xuICAgICAgZmlsZTogdXJsLFxuICAgICAgdG90YWw6IHRoaXMuX3RvdGFsUGFyc2VkLFxuICAgICAgcGFyc2VkOiB0aGlzLl9wYXJzZWQsXG4gICAgICB0aW1lOiBuZXcgRGF0ZSgpLFxuICAgIH0pO1xuXG4gICAgaWYgKHRoaXMuX3BhcnNlZCA9PT0gdGhpcy5fdG90YWxQYXJzZWQpIHtcbiAgICAgIC8vIGVtaXQgJ3BhcnNlLXN1Y2Nlc3MnIGV2ZW50XG4gICAgICB0aGlzLmVtaXQoJ3BhcnNlLXN1Y2Nlc3MnLCB7XG4gICAgICAgIGZpbGU6IHVybCxcbiAgICAgICAgdG90YWw6IHRoaXMuX3RvdGFsUGFyc2VkLFxuICAgICAgICBwYXJzZWQ6IHRoaXMuX3BhcnNlZCxcbiAgICAgICAgdGltZTogbmV3IERhdGUoKSxcbiAgICAgIH0pO1xuXG4gICAgICByZXNvbHZlKHNlcmllcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNldFRpbWVvdXQoXG4gICAgICAgIHRoaXMucGFyc2VGcmFtZShcbiAgICAgICAgICBzZXJpZXMsIHN0YWNrLCB1cmwsIHRoaXMuX3BhcnNlZCwgZGF0YVBhcnNlciwgcmVzb2x2ZSwgcmVqZWN0KSwgMFxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHBhcnNlciBnaXZlbiBhbiBleHRlbnNpb25cbiAgICogQHBhcmFtIHtzdHJpbmd9IGV4dGVuc2lvbiAtIGV4dGVuc2lvblxuICAgKiBAcmV0dXJuIHtwYXJzZXJ9IHNlbGVjdGVkIHBhcnNlclxuICAgKi9cbiAgX3BhcnNlcihleHRlbnNpb24pIHtcbiAgICBsZXQgUGFyc2VyID0gbnVsbDtcblxuICAgIHN3aXRjaCAoZXh0ZW5zaW9uLnRvVXBwZXJDYXNlKCkpIHtcbiAgICAgIGNhc2UgJ05JSSc6XG4gICAgICBjYXNlICdOSUlfJzpcbiAgICAgICAgUGFyc2VyID0gUGFyc2Vyc05pZnRpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ0RDTSc6XG4gICAgICBjYXNlICdESUNPTSc6XG4gICAgICBjYXNlICdJTUEnOlxuICAgICAgY2FzZSAnJzpcbiAgICAgICAgUGFyc2VyID0gUGFyc2Vyc0RpY29tO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ01IRCc6XG4gICAgICAgIFBhcnNlciA9IFBhcnNlcnNNaGQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnTlJSRCc6XG4gICAgICAgIFBhcnNlciA9IFBhcnNlcnNOcnJkO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHdpbmRvdy5jb25zb2xlLmxvZygndW5zdXBwb3J0ZWQgZXh0ZW5zaW9uOiAnICsgZXh0ZW5zaW9uKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gUGFyc2VyO1xuICB9XG5cblxuICAvKipcbiAgICogUHJlLXByb2Nlc3MgZGF0YSB0byBiZSBwYXJzZWQgKGZpbmQgZGF0YSB0eXBlIGFuZCBkZS1jb21wcmVzcylcbiAgICogQHBhcmFtIHsqfSBkYXRhXG4gICAqL1xuICBfcHJlcHJvY2VzcyhkYXRhKSB7XG4gICAgY29uc3QgcGFyc2VkVXJsID0gQ29yZVV0aWxzLnBhcnNlVXJsKGRhdGEudXJsKTtcbiAgICAvLyB1cGRhdGUgZGF0YVxuICAgIGRhdGEuZmlsZW5hbWUgPSBwYXJzZWRVcmwuZmlsZW5hbWU7XG4gICAgZGF0YS5leHRlbnNpb24gPSBwYXJzZWRVcmwuZXh0ZW5zaW9uO1xuICAgIGRhdGEucGF0aG5hbWUgPSBwYXJzZWRVcmwucGF0aG5hbWU7XG4gICAgZGF0YS5xdWVyeSA9IHBhcnNlZFVybC5xdWVyeTtcblxuICAgIC8vIHVuemlwIGlmIGV4dGVuc2lvbiBpcyAnLmd6J1xuICAgIGlmIChkYXRhLmV4dGVuc2lvbiA9PT0gJ2d6Jykge1xuICAgICAgZGF0YS5nemNvbXByZXNzZWQgPSB0cnVlO1xuICAgICAgZGF0YS5leHRlbnNpb24gPVxuICAgICAgICBkYXRhLmZpbGVuYW1lLnNwbGl0KCcuZ3onKS5zaGlmdCgpLnNwbGl0KCcuJykucG9wKCk7XG4gICAgICBsZXQgZGVjb21wcmVzc2VkRGF0YSA9IFBBS08uaW5mbGF0ZShkYXRhLmJ1ZmZlcik7XG4gICAgICBkYXRhLmJ1ZmZlciA9IGRlY29tcHJlc3NlZERhdGEuYnVmZmVyO1xuICAgIH0gZWxzZSB7XG4gICAgICBkYXRhLmd6Y29tcHJlc3NlZCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBGaWx0ZXIgZGF0YSBieSBleHRlbnNpb25cbiAgICogQHBhcmFtIHsqfSBleHRlbnNpb25cbiAgICogQHBhcmFtIHsqfSBpdGVtXG4gICAqIEByZXR1cm5zIEJvb2xlYW5cbiAgICovXG4gIF9maWx0ZXJCeUV4dGVuc2lvbihleHRlbnNpb24sIGl0ZW0pIHtcbiAgICBpZiAoaXRlbS5leHRlbnNpb24udG9VcHBlckNhc2UoKSA9PT0gZXh0ZW5zaW9uLnRvVXBwZXJDYXNlKCkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbiIsIi8qKlxuICogQmFzZSBvYmplY3QuXG4gKlxuICogQG1vZHVsZSBtb2RlbHMvYmFzZVxuICovXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1vZGVsc0Jhc2Uge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLl9pZCA9IC0xO1xuICB9XG4gIC8qKlxuICAgKiBNZXJnZSAyIGFycmF5cyBvZiBtb2RlbHMuXG4gICAqIE1lcmdlIHRoZSB0YXJnZXQgYXJyYXkgaW50byB0aGUgcmVmZXJlbmNlIGFycmF5LlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5LjxNb2RlbHM+fSByZWZlcmVuY2VBcnJheSAtIEFycmF5IHRvIGJlIG1lcmdlIGFnYWluc3RcbiAgICogQHBhcmFtIHtBcnJheS48TW9kZWxzPn0gdGFyZ2V0QXJyYXkgLSBBcnJheSB0byBiZSBtZXJnZWQgYWdhaW5zdCByZWZlcmVuY2UuXG4gICAqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgbWVyZ2Ugd2FzIHN1Y2Vzc2Z1bC4gRmFsc2UgaWYgc29tZXRoaW5nIHdlbnQgd3JvbmcuXG4gICAqL1xuICBtZXJnZU1vZGVscyhyZWZlcmVuY2VBcnJheSwgdGFyZ2V0QXJyYXkpIHtcbiAgICBpZiAoISh0aGlzLl92YWxpZGF0ZU1vZGVsQXJyYXkocmVmZXJlbmNlQXJyYXkpICYmXG4gICAgICB0aGlzLl92YWxpZGF0ZU1vZGVsQXJyYXkodGFyZ2V0QXJyYXkpKSkge1xuICAgICAgd2luZG93LmNvbnNvbGUubG9nKCdpbnZhbGlkIGlucHV0cyBwcm92aWRlZC4nKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRhcmdldEFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAvLyB0ZXN0IHRhcmdldEFycmF5IGFnYWluc3QgZXhpc3RpbmcgdGFyZ2V0QXJyYXlcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgcmVmZXJlbmNlQXJyYXkubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgaWYgKHJlZmVyZW5jZUFycmF5W2pdLm1lcmdlKHRhcmdldEFycmF5W2ldKSkge1xuICAgICAgICAgIC8vIG1lcmdlZCBzdWNjZXNzZnVsbHlcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfSBlbHNlIGlmIChqID09PSByZWZlcmVuY2VBcnJheS5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgLy8gbGFzdCBtZXJnZSB3YXMgbm90IHN1Y2Nlc3NmdWxcbiAgICAgICAgICAvLyB0aGlzIGlzIGEgbmV3IHRhcmdldEFycmF5XG4gICAgICAgICAgcmVmZXJlbmNlQXJyYXkucHVzaCh0YXJnZXRBcnJheVtpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNZXJnZSBtb2RlbCBhZ2FpbnN0IGN1cnJlbnQgbW9kZWwuXG4gICAqL1xuICBtZXJnZShtb2RlbCkge1xuICAgIC8vIG1ha2Ugc3VyZSBtb2RlbCBpcyB2YWxpZFxuICAgIGlmKCEodGhpcy52YWxpZGF0ZShtb2RlbCkpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gdGhleSBjYW4gYmUgbWVyZ2VkIGlmIHRoZXkgbWF0Y2hcbiAgICBpZih0aGlzLl9pZCA9PT0gbW9kZWwuX2lkKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFZhbGlkYXRlIGEgbW9kZWwuXG4gICAqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgbW9kZWwgaXMgdmFsaWQuIEZhbHNlIGlmIG5vdC5cbiAgICovXG4gIHZhbGlkYXRlKG1vZGVsKSB7XG4gICAgaWYgKCEobW9kZWwgJiZcbiAgICAgIG1vZGVsICE9PSBudWxsICYmXG4gICAgICB0eXBlb2YgbW9kZWwubWVyZ2UgPT09ICdmdW5jdGlvbicpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogVmFsaWRhdGUgYXJyYXkgb2YgbW9kZWxzLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5LjxNb2RlbHM+fSBtb2RlbEFycmF5IC0gQXJyYXkgY29udGFpbmluZyBtb2RlbHMuXG4gICAqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYXJyYXkgaXMgdmFsaWQuIEZhbHNlIGlmIG5vdC5cbiAgICovXG4gIF92YWxpZGF0ZU1vZGVsQXJyYXkobW9kZWxBcnJheSkge1xuICAgIGlmICghKG1vZGVsQXJyYXkgIT09IG51bGwgJiYgQXJyYXkgPT09IG1vZGVsQXJyYXkuY29uc3RydWN0b3IpKSB7XG4gICAgICB3aW5kb3cuY29uc29sZS5sb2coJ2ludmFsaWQgbW9kZWwgYXJyYXkgcHJvdmlkZWQuJyk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtb2RlbEFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoIShtb2RlbEFycmF5W2ldICYmXG4gICAgICAgIG1vZGVsQXJyYXlbaV0gIT09IG51bGwgJiZcbiAgICAgICAgdHlwZW9mIG1vZGVsQXJyYXlbaV0udmFsaWRhdGUgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgbW9kZWxBcnJheVtpXS52YWxpZGF0ZShtb2RlbEFycmF5W2ldKSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG4iLCIvKiogKiBJbXBvcnRzICoqKi9cbmltcG9ydCBNb2RlbHNCYXNlIGZyb20gJy4uL21vZGVscy9tb2RlbHMuYmFzZSc7XG5cbi8qKlxuICogRnJhbWUgb2JqZWN0LlxuICpcbiAqIEBtb2R1bGUgbW9kZWxzL2ZyYW1lXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1vZGVsc0ZyYW1lIGV4dGVuZHMgTW9kZWxzQmFzZSB7XG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdG9yXG4gICAqL1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5fc29wSW5zdGFuY2VVSUQgPSBudWxsO1xuICAgIHRoaXMuX3VybCA9IG51bGw7XG4gICAgdGhpcy5fc3RhY2tJRCA9IC0xO1xuICAgIHRoaXMuX3Jvd3MgPSAwO1xuICAgIHRoaXMuX2NvbHVtbnMgPSAwO1xuICAgIHRoaXMuX2RpbWVuc2lvbkluZGV4VmFsdWVzID0gW107XG4gICAgdGhpcy5faW1hZ2VQb3NpdGlvbiA9IG51bGw7XG4gICAgdGhpcy5faW1hZ2VPcmllbnRhdGlvbiA9IG51bGw7XG4gICAgdGhpcy5fcmlnaHRIYW5kZWQgPSB0cnVlO1xuICAgIHRoaXMuX3NsaWNlVGhpY2tuZXNzID0gMTtcbiAgICB0aGlzLl9zcGFjaW5nQmV0d2VlblNsaWNlcyA9IG51bGw7XG4gICAgdGhpcy5fcGl4ZWxSZXByZXNlbnRhdGlvbiA9IDA7XG4gICAgdGhpcy5fcGl4ZWxUeXBlID0gMDtcbiAgICB0aGlzLl9waXhlbFNwYWNpbmcgPSBudWxsO1xuICAgIHRoaXMuX3BpeGVsQXNwZWN0UmF0aW8gPSBudWxsO1xuICAgIHRoaXMuX3BpeGVsRGF0YSA9IG51bGw7XG5cbiAgICB0aGlzLl9pbnN0YW5jZU51bWJlciA9IG51bGw7XG4gICAgdGhpcy5fd2luZG93Q2VudGVyID0gbnVsbDtcbiAgICB0aGlzLl93aW5kb3dXaWR0aCA9IG51bGw7XG4gICAgdGhpcy5fcmVzY2FsZVNsb3BlID0gbnVsbDtcbiAgICB0aGlzLl9yZXNjYWxlSW50ZXJjZXB0ID0gbnVsbDtcblxuICAgIHRoaXMuX2JpdHNBbGxvY2F0ZWQgPSA4O1xuXG4gICAgdGhpcy5fbWluTWF4ID0gbnVsbDtcbiAgICB0aGlzLl9kaXN0ID0gbnVsbDtcblxuICAgIHRoaXMuX2luZGV4ID0gLTE7XG5cbiAgICB0aGlzLl9yZWZlcmVuY2VkU2VnbWVudE51bWJlciA9IC0xO1xuICB9XG5cbiAgLyoqXG4gICAqIFZhbGlkYXRlIHRoZSBmcmFtZS5cbiAgICpcbiAgICogQHBhcmFtIHsqfSBtb2RlbFxuICAgKlxuICAgKiBAcmV0dXJuIHsqfVxuICAgKi9cbiAgdmFsaWRhdGUobW9kZWwpIHtcbiAgICBpZiAoIShzdXBlci52YWxpZGF0ZShtb2RlbCkgJiZcbiAgICAgIHR5cGVvZiBtb2RlbC5jb3NpbmVzID09PSAnZnVuY3Rpb24nICYmXG4gICAgICB0eXBlb2YgbW9kZWwuc3BhY2luZ1hZID09PSAnZnVuY3Rpb24nICYmXG4gICAgICBtb2RlbC5oYXNPd25Qcm9wZXJ0eSgnX3NvcEluc3RhbmNlVUlEJykgJiZcbiAgICAgIG1vZGVsLmhhc093blByb3BlcnR5KCdfZGltZW5zaW9uSW5kZXhWYWx1ZXMnKSAmJlxuICAgICAgbW9kZWwuaGFzT3duUHJvcGVydHkoJ19pbWFnZU9yaWVudGF0aW9uJykgJiZcbiAgICAgIG1vZGVsLmhhc093blByb3BlcnR5KCdfaW1hZ2VQb3NpdGlvbicpKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIE1lcmdlIGN1cnJlbnQgZnJhbWUgd2l0aCBwcm92aWRlZCBmcmFtZS5cbiAgICpcbiAgICogRnJhbWVzIGNhbiBiZSBtZXJnZWQgKGkuZS4gYXJlIGlkZW50aWNhbCkgaWYgZm9sbG93aW5nIGFyZSBlcXVhbHM6XG4gICAqICAtIGRpbWVuc2lvbkluZGV4VmFsdWVzXG4gICAqICAtIGltYWdlT3JpZW50YXRpb25cbiAgICogIC0gaW1hZ2VQb3NpdGlvblxuICAgKiAgLSBpbnN0YW5jZU51bWJlclxuICAgKiAgLSBzb3BJbnN0YW5jZVVJRFxuICAgKlxuICAgKiBAcGFyYW0geyp9IGZyYW1lXG4gICAqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgZnJhbWVzIGNvdWxkIGJlIG1lcmdlLiBGYWxzZSBpZiBub3QuXG4gICAqL1xuICBtZXJnZShmcmFtZSkge1xuICAgIGlmICghdGhpcy52YWxpZGF0ZShmcmFtZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fY29tcGFyZUFycmF5cyhcbiAgICAgICAgICB0aGlzLl9kaW1lbnNpb25JbmRleFZhbHVlcywgZnJhbWUuZGltZW5zaW9uSW5kZXhWYWx1ZXMpICYmXG4gICAgICAgIHRoaXMuX2NvbXBhcmVBcnJheXMoXG4gICAgICAgICAgdGhpcy5faW1hZ2VPcmllbnRhdGlvbiwgZnJhbWUuaW1hZ2VPcmllbnRhdGlvbikgJiZcbiAgICAgICAgdGhpcy5fY29tcGFyZUFycmF5cyhcbiAgICAgICAgICB0aGlzLl9pbWFnZVBvc2l0aW9uLCBmcmFtZS5pbWFnZVBvc2l0aW9uKSAmJlxuICAgICAgICB0aGlzLl9pbnN0YW5jZU51bWJlciA9PT0gZnJhbWUuaW5zdGFuY2VOdW1iZXIgJiZcbiAgICAgICAgdGhpcy5fc29wSW5zdGFuY2VVSUQgPT09IGZyYW1lLnNvcEluc3RhbmNlVUlEKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBYLCB5IGFuZCBaIGNvc2luZXMgZnJvbSBpbWFnZSBvcmllbnRhdGlvblxuICAgKiBSZXR1cm5zIGRlZmF1bHQgb3JpZW50YXRpb24gaWYgX2ltYWdlT3JpZW50YXRpb24gd2FzIGludmFsaWQuXG4gICAqXG4gICAqIEByZXR1cm5zIHthcnJheX0gQXJyYXlbM10gY29udGFpbmluZyBjb3NpbmVzWCwgWSBhbmQgWi5cbiAgICovXG4gIGNvc2luZXMoKSB7XG4gICAgbGV0IGNvc2luZXMgPSBbbmV3IFRIUkVFLlZlY3RvcjMoMSwgMCwgMCksXG4gICAgICBuZXcgVEhSRUUuVmVjdG9yMygwLCAxLCAwKSxcbiAgICAgIG5ldyBUSFJFRS5WZWN0b3IzKDAsIDAsIDEpXTtcblxuICAgICBpZiAodGhpcy5faW1hZ2VPcmllbnRhdGlvbiAmJlxuICAgICAgdGhpcy5faW1hZ2VPcmllbnRhdGlvbi5sZW5ndGggPT09IDYpIHtcbiAgICAgIGxldCB4Q29zID1cbiAgICAgICAgbmV3IFRIUkVFLlZlY3RvcjMoXG4gICAgICAgICAgdGhpcy5faW1hZ2VPcmllbnRhdGlvblswXSxcbiAgICAgICAgICB0aGlzLl9pbWFnZU9yaWVudGF0aW9uWzFdLFxuICAgICAgICAgIHRoaXMuX2ltYWdlT3JpZW50YXRpb25bMl0pO1xuICAgICAgbGV0IHlDb3MgPVxuICAgICAgICBuZXcgVEhSRUUuVmVjdG9yMyhcbiAgICAgICAgICB0aGlzLl9pbWFnZU9yaWVudGF0aW9uWzNdLFxuICAgICAgICAgIHRoaXMuX2ltYWdlT3JpZW50YXRpb25bNF0sXG4gICAgICAgICAgdGhpcy5faW1hZ2VPcmllbnRhdGlvbls1XSk7XG5cbiAgICAgIGlmICh4Q29zLmxlbmd0aCgpID4gMCAmJiB5Q29zLmxlbmd0aCgpID4gMCkge1xuICAgICAgICBjb3NpbmVzWzBdID0geENvcztcbiAgICAgICAgY29zaW5lc1sxXSA9IHlDb3M7XG4gICAgICAgIGNvc2luZXNbMl0gPVxuICAgICAgICAgIG5ldyBUSFJFRS5WZWN0b3IzKDAsIDAsIDApLlxuICAgICAgICAgIGNyb3NzVmVjdG9ycyhjb3NpbmVzWzBdLCBjb3NpbmVzWzFdKS5cbiAgICAgICAgICBub3JtYWxpemUoKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgd2luZG93LmNvbnNvbGUubG9nKCdObyB2YWxpZCBpbWFnZSBvcmllbnRhdGlvbiBmb3IgZnJhbWUnKTtcbiAgICAgIHdpbmRvdy5jb25zb2xlLmxvZyh0aGlzKTtcbiAgICAgIHdpbmRvdy5jb25zb2xlLmxvZygnUmV0dXJuaW5nIGRlZmF1bHQgb3JpZW50YXRpb24uJyk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLl9yaWdodEhhbmRlZCkge1xuICAgICAgY29zaW5lc1syXS5uZWdhdGUoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY29zaW5lcztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgeC95IHNwYWNpbmcgb2YgYSBmcmFtZS5cbiAgICpcbiAgICogQHJldHVybiB7Kn1cbiAgICovXG4gIHNwYWNpbmdYWSgpIHtcbiAgICBsZXQgc3BhY2luZ1hZID0gWzEuMCwgMS4wXTtcblxuICAgIGlmICh0aGlzLnBpeGVsU3BhY2luZykge1xuICAgICAgc3BhY2luZ1hZWzBdID0gdGhpcy5waXhlbFNwYWNpbmdbMF07XG5cbiAgICAgIHNwYWNpbmdYWVsxXSA9IHRoaXMucGl4ZWxTcGFjaW5nWzFdO1xuICAgIH0gZWxzZSBpZiAodGhpcy5waXhlbEFzcGVjdFJhdGlvKSB7XG4gICAgICBzcGFjaW5nWFlbMF0gPSAxLjA7XG4gICAgICBzcGFjaW5nWFlbMV0gPSAxLjAgKiB0aGlzLnBpeGVsQXNwZWN0UmF0aW9bMV0gLyB0aGlzLnBpeGVsQXNwZWN0UmF0aW9bMF07XG4gICAgfVxuXG4gICAgcmV0dXJuIHNwYWNpbmdYWTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgZGF0YSB2YWx1ZVxuICAgKlxuICAgKiBAcGFyYW0geyp9IGNvbHVtblxuICAgKiBAcGFyYW0geyp9IHJvd1xuICAgKlxuICAgKiBAcmV0dXJuIHsqfVxuICAgKi9cbiAgdmFsdWUoY29sdW1uLCByb3cpIHtcbiAgICByZXR1cm4gdGhpcy5waXhlbERhdGFbY29sdW1uICsgdGhpcy5fY29sdW1ucyAqIHJvd107XG4gIH1cblxuICAvKipcbiAgICogQ29tcGFyZSAyIGFycmF5cy5cbiAgICpcbiAgICogMiBudWxsIGFycmF5cyByZXR1cm4gdHJ1ZS5cbiAgICogRG8gbm8gcGVyZm9ybSBzdHJpY3QgdHlwZSBjaGVja2luZy5cbiAgICpcbiAgICogQHBhcmFtIHsqfSByZWZlcmVuY2VcbiAgICogQHBhcmFtIHsqfSB0YXJnZXRcbiAgICpcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBhcnJheXMgYXJlIGlkZW50aWNhbHMuIEZhbHNlIGlmIG5vdC5cbiAgICovXG4gIF9jb21wYXJlQXJyYXlzKHJlZmVyZW5jZSwgdGFyZ2V0KSB7XG4gICAgLy8gY291bGQgYm90aCBiZSBudWxsXG4gICAgaWYgKHJlZmVyZW5jZSA9PT0gdGFyZ2V0KSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBpZiBub3QgbnVsbC4uLi5cbiAgICBpZiAocmVmZXJlbmNlICYmXG4gICAgICAgIHRhcmdldCAmJlxuICAgICAgICByZWZlcmVuY2Uuam9pbigpID09PSB0YXJnZXQuam9pbigpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBnZXQgcm93cygpIHtcbiAgICByZXR1cm4gdGhpcy5fcm93cztcbiAgfVxuXG4gIHNldCByb3dzKHJvd3MpIHtcbiAgICB0aGlzLl9yb3dzID0gcm93cztcbiAgfVxuXG4gIGdldCBjb2x1bW5zKCkge1xuICAgIHJldHVybiB0aGlzLl9jb2x1bW5zO1xuICB9XG5cbiAgc2V0IGNvbHVtbnMoY29sdW1ucykge1xuICAgIHRoaXMuX2NvbHVtbnMgPSBjb2x1bW5zO1xuICB9XG5cbiAgZ2V0IHNwYWNpbmdCZXR3ZWVuU2xpY2VzKCkge1xuICAgIHJldHVybiB0aGlzLl9zcGFjaW5nQmV0d2VlblNsaWNlcztcbiAgfVxuXG4gIHNldCBzcGFjaW5nQmV0d2VlblNsaWNlcyhzcGFjaW5nQmV0d2VlblNsaWNlcykge1xuICAgIHRoaXMuX3NwYWNpbmdCZXR3ZWVuU2xpY2VzID0gc3BhY2luZ0JldHdlZW5TbGljZXM7XG4gIH1cblxuICBnZXQgc2xpY2VUaGlja25lc3MoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NsaWNlVGhpY2tuZXNzO1xuICB9XG5cbiAgc2V0IHNsaWNlVGhpY2tuZXNzKHNsaWNlVGhpY2tuZXNzKSB7XG4gICAgdGhpcy5fc2xpY2VUaGlja25lc3MgPSBzbGljZVRoaWNrbmVzcztcbiAgfVxuXG4gIGdldCBpbWFnZVBvc2l0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9pbWFnZVBvc2l0aW9uO1xuICB9XG5cbiAgc2V0IGltYWdlUG9zaXRpb24oaW1hZ2VQb3NpdGlvbikge1xuICAgIHRoaXMuX2ltYWdlUG9zaXRpb24gPSBpbWFnZVBvc2l0aW9uO1xuICB9XG5cbiAgZ2V0IGltYWdlT3JpZW50YXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ltYWdlT3JpZW50YXRpb247XG4gIH1cblxuICBzZXQgaW1hZ2VPcmllbnRhdGlvbihpbWFnZU9yaWVudGF0aW9uKSB7XG4gICAgdGhpcy5faW1hZ2VPcmllbnRhdGlvbiA9IGltYWdlT3JpZW50YXRpb247XG4gIH1cblxuICBnZXQgd2luZG93V2lkdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dpbmRvd1dpZHRoO1xuICB9XG5cbiAgc2V0IHdpbmRvd1dpZHRoKHdpbmRvd1dpZHRoKSB7XG4gICAgdGhpcy5fd2luZG93V2lkdGggPSB3aW5kb3dXaWR0aDtcbiAgfVxuXG4gIGdldCB3aW5kb3dDZW50ZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dpbmRvd0NlbnRlcjtcbiAgfVxuXG4gIHNldCB3aW5kb3dDZW50ZXIod2luZG93Q2VudGVyKSB7XG4gICAgdGhpcy5fd2luZG93Q2VudGVyID0gd2luZG93Q2VudGVyO1xuICB9XG5cbiAgZ2V0IHJlc2NhbGVTbG9wZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVzY2FsZVNsb3BlO1xuICB9XG5cbiAgc2V0IHJlc2NhbGVTbG9wZShyZXNjYWxlU2xvcGUpIHtcbiAgICB0aGlzLl9yZXNjYWxlU2xvcGUgPSByZXNjYWxlU2xvcGU7XG4gIH1cblxuICBnZXQgcmVzY2FsZUludGVyY2VwdCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVzY2FsZUludGVyY2VwdDtcbiAgfVxuXG4gIHNldCByZXNjYWxlSW50ZXJjZXB0KHJlc2NhbGVJbnRlcmNlcHQpIHtcbiAgICB0aGlzLl9yZXNjYWxlSW50ZXJjZXB0ID0gcmVzY2FsZUludGVyY2VwdDtcbiAgfVxuXG4gIGdldCBiaXRzQWxsb2NhdGVkKCkge1xuICAgIHJldHVybiB0aGlzLl9iaXRzQWxsb2NhdGVkO1xuICB9XG5cbiAgc2V0IGJpdHNBbGxvY2F0ZWQoYml0c0FsbG9jYXRlZCkge1xuICAgIHRoaXMuX2JpdHNBbGxvY2F0ZWQgPSBiaXRzQWxsb2NhdGVkO1xuICB9XG5cbiAgZ2V0IGRpc3QoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Rpc3Q7XG4gIH1cblxuICBzZXQgZGlzdChkaXN0KSB7XG4gICAgdGhpcy5fZGlzdCA9IGRpc3Q7XG4gIH1cblxuICBnZXQgcGl4ZWxTcGFjaW5nKCkge1xuICAgIHJldHVybiB0aGlzLl9waXhlbFNwYWNpbmc7XG4gIH1cblxuICBzZXQgcGl4ZWxTcGFjaW5nKHBpeGVsU3BhY2luZykge1xuICAgIHRoaXMuX3BpeGVsU3BhY2luZyA9IHBpeGVsU3BhY2luZztcbiAgfVxuXG4gIGdldCBwaXhlbEFzcGVjdFJhdGlvKCkge1xuICAgIHJldHVybiB0aGlzLl9waXhlbEFzcGVjdFJhdGlvO1xuICB9XG5cbiAgc2V0IHBpeGVsQXNwZWN0UmF0aW8ocGl4ZWxBc3BlY3RSYXRpbykge1xuICAgIHRoaXMuX3BpeGVsQXNwZWN0UmF0aW8gPSBwaXhlbEFzcGVjdFJhdGlvO1xuICB9XG5cbiAgZ2V0IG1pbk1heCgpIHtcbiAgICByZXR1cm4gdGhpcy5fbWluTWF4O1xuICB9XG5cbiAgc2V0IG1pbk1heChtaW5NYXgpIHtcbiAgICB0aGlzLl9taW5NYXggPSBtaW5NYXg7XG4gIH1cblxuICBnZXQgZGltZW5zaW9uSW5kZXhWYWx1ZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RpbWVuc2lvbkluZGV4VmFsdWVzO1xuICB9XG5cbiAgc2V0IGRpbWVuc2lvbkluZGV4VmFsdWVzKGRpbWVuc2lvbkluZGV4VmFsdWVzKSB7XG4gICAgdGhpcy5fZGltZW5zaW9uSW5kZXhWYWx1ZXMgPSBkaW1lbnNpb25JbmRleFZhbHVlcztcbiAgfVxuXG4gIGdldCBpbnN0YW5jZU51bWJlcigpIHtcbiAgICByZXR1cm4gdGhpcy5faW5zdGFuY2VOdW1iZXI7XG4gIH1cblxuICBzZXQgaW5zdGFuY2VOdW1iZXIoaW5zdGFuY2VOdW1iZXIpIHtcbiAgICB0aGlzLl9pbnN0YW5jZU51bWJlciA9IGluc3RhbmNlTnVtYmVyO1xuICB9XG5cbiAgZ2V0IHBpeGVsRGF0YSgpIHtcbiAgICByZXR1cm4gdGhpcy5fcGl4ZWxEYXRhO1xuICB9XG5cbiAgc2V0IHBpeGVsRGF0YShwaXhlbERhdGEpIHtcbiAgICB0aGlzLl9waXhlbERhdGEgPSBwaXhlbERhdGE7XG4gIH1cblxuICBzZXQgc29wSW5zdGFuY2VVSUQoc29wSW5zdGFuY2VVSUQpIHtcbiAgICB0aGlzLl9zb3BJbnN0YW5jZVVJRCA9IHNvcEluc3RhbmNlVUlEO1xuICB9XG5cbiAgZ2V0IHNvcEluc3RhbmNlVUlEKCkge1xuICAgIHJldHVybiB0aGlzLl9zb3BJbnN0YW5jZVVJRDtcbiAgfVxuXG4gIGdldCBwaXhlbFJlcHJlc2VudGF0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9waXhlbFJlcHJlc2VudGF0aW9uO1xuICB9XG5cbiAgc2V0IHBpeGVsUmVwcmVzZW50YXRpb24ocGl4ZWxSZXByZXNlbnRhdGlvbikge1xuICAgIHRoaXMuX3BpeGVsUmVwcmVzZW50YXRpb24gPSBwaXhlbFJlcHJlc2VudGF0aW9uO1xuICB9XG5cbiAgZ2V0IHBpeGVsVHlwZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fcGl4ZWxUeXBlO1xuICB9XG5cbiAgc2V0IHBpeGVsVHlwZShwaXhlbFR5cGUpIHtcbiAgICB0aGlzLl9waXhlbFR5cGUgPSBwaXhlbFR5cGU7XG4gIH1cblxuICBnZXQgdXJsKCkge1xuICAgIHJldHVybiB0aGlzLl91cmw7XG4gIH1cblxuICBzZXQgdXJsKHVybCkge1xuICAgIHRoaXMuX3VybCA9IHVybDtcbiAgfVxuXG4gIGdldCByZWZlcmVuY2VkU2VnbWVudE51bWJlcigpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVmZXJlbmNlZFNlZ21lbnROdW1iZXI7XG4gIH1cblxuICBzZXQgcmVmZXJlbmNlZFNlZ21lbnROdW1iZXIocmVmZXJlbmNlZFNlZ21lbnROdW1iZXIpIHtcbiAgICB0aGlzLl9yZWZlcmVuY2VkU2VnbWVudE51bWJlciA9IHJlZmVyZW5jZWRTZWdtZW50TnVtYmVyO1xuICB9XG5cbiAgZ2V0IHJpZ2h0SGFuZGVkKCkge1xuICAgIHJldHVybiB0aGlzLl9yaWdodEhhbmRlZDtcbiAgfVxuXG4gIHNldCByaWdodEhhbmRlZChyaWdodEhhbmRlZCkge1xuICAgIHRoaXMuX3JpZ2h0SGFuZGVkID0gcmlnaHRIYW5kZWQ7XG4gIH1cblxuICBnZXQgaW5kZXgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2luZGV4O1xuICB9XG5cbiAgc2V0IGluZGV4KGluZGV4KSB7XG4gICAgdGhpcy5faW5kZXggPSBpbmRleDtcbiAgfVxufVxuIiwiaW1wb3J0IEZyYW1lIGZyb20gJy4vbW9kZWxzLmZyYW1lJztcbmltcG9ydCBTdGFjayBmcm9tICcuL21vZGVscy5zdGFjayc7XG5pbXBvcnQgU2VyaWVzIGZyb20gJy4vbW9kZWxzLnNlcmllcyc7XG5pbXBvcnQgVm94ZWwgZnJvbSAnLi9tb2RlbHMudm94ZWwnO1xuXG4vKipcbiAqIEBtb2R1bGUgbW9kZWxzXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQge1xuICBGcmFtZSxcbiAgU3RhY2ssXG4gIFNlcmllcyxcbiAgVm94ZWwsXG59O1xuIiwiLyoqICogSW1wb3J0cyAqKiovXG5pbXBvcnQgTW9kZWxzQmFzZSBmcm9tICcuLi9tb2RlbHMvbW9kZWxzLmJhc2UnO1xuXG4vKipcbiAqIFNlcmllcyBvYmplY3QuXG4gKlxuICogQG1vZHVsZSBtb2RlbHMvc2VyaWVzXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1vZGVsc1NlcmllcyBleHRlbmRzIE1vZGVsc0Jhc2Uge1xuICAvKipcbiAgICogTW9kZWxzIHNlcmllcyBjb25zdHJ1Y3RvclxuICAgKi9cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMuX2NvbmNhdGVuYXRpb25VSUQgPSAtMTtcbiAgICB0aGlzLl9zZXJpZXNJbnN0YW5jZVVJRCA9IC0xO1xuICAgIHRoaXMuX3RyYW5zZmVyU3ludGF4VUlEID0gJyc7XG4gICAgdGhpcy5fc2VyaWVzTnVtYmVyID0gLTE7XG4gICAgdGhpcy5fc2VyaWVzRGVzY3JpcHRpb24gPSAnJztcbiAgICB0aGlzLl9zdHVkeURlc2NyaXB0aW9uID0gJyc7XG4gICAgdGhpcy5fbW9kYWxpdHkgPSAnTW9kYWxpdHkgbm90IHNldCc7XG4gICAgdGhpcy5fZGltZW5zaW9uSW5kZXhTZXF1ZW5jZSA9IFtdO1xuICAgIC8vIGl0IGlzIHVzZWQgaW4gdGhlIGxvYWRlciBpbiBjYXNlIGEgZGljb20vbmlmdGkgY29udGFpbnMgbXVsdGlwbGUgZnJhbWVzXG4gICAgLy8gc2hvdWxkIGJlIHVwZGF0ZWQgYWZ0ZXIgbWVyZ2Ugb3IgcmVuYW1lZFxuICAgIHRoaXMuX251bWJlck9mRnJhbWVzID0gMDtcbiAgICB0aGlzLl9udW1iZXJPZkNoYW5uZWxzID0gMTtcblxuICAgIC8vIHBhdGllbnQgaW5mb3JtYXRpb25cbiAgICB0aGlzLl9wYXRpZW50SUQgPSAnJztcbiAgICB0aGlzLl9wYXRpZW50TmFtZSA9ICcnO1xuICAgIHRoaXMuX3BhdGllbnRBZ2UgPSAnJztcbiAgICB0aGlzLl9wYXRpZW50QmlydGhkYXRlID0gJyc7XG4gICAgdGhpcy5fcGF0aWVudFNleCA9ICcnO1xuXG4gICAgLy8gU0VHTUVOVEFUSU9OIFNUVUZGXG4gICAgdGhpcy5fc2VnbWVudGF0aW9uVHlwZSA9IG51bGw7XG4gICAgdGhpcy5fc2VnbWVudGF0aW9uU2VnbWVudHMgPSBbXTtcblxuICAgIC8vIFNUQUNLXG4gICAgdGhpcy5fc3RhY2sgPSBbXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBWYWxpZGF0ZSBhIHNlcmllcy5cbiAgICpcbiAgICogUmVxdWlyZW1lbnRzOlxuICAgKiAgIC0gbWVyZ2VTZXJpZXMgbWV0aG9kXG4gICAqICAgLSBfc2VyaWVzSW5zdGFuY2VVSURcbiAgICogICAtIF9udW1iZXJPZkZyYW1lc1xuICAgKiAgIC0gX251bWJlck9mQ2hhbm5lbHNcbiAgICogICBfIF9zdGFja1xuICAgKlxuICAgKiBAcGFyYW0ge01vZGVsc1Nlcmllc30gbW9kZWwgLSBNb2RlbCB0byBiZSB2YWxpZGF0ZWQgYXMgc2VyaWVzLlxuICAgKlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHNlcmllcyBpcyB2YWxpZC4gRmFsc2UgaWYgbm90LlxuICAgKlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIHZhbGlkYXRlKG1vZGVsKSB7XG4gICAgaWYgKCEoc3VwZXIudmFsaWRhdGUobW9kZWwpICYmXG4gICAgICB0eXBlb2YgbW9kZWwubWVyZ2VTZXJpZXMgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgIG1vZGVsLmhhc093blByb3BlcnR5KCdfc2VyaWVzSW5zdGFuY2VVSUQnKSAmJlxuICAgICAgbW9kZWwuaGFzT3duUHJvcGVydHkoJ19udW1iZXJPZkZyYW1lcycpICYmXG4gICAgICBtb2RlbC5oYXNPd25Qcm9wZXJ0eSgnX251bWJlck9mQ2hhbm5lbHMnKSAmJlxuICAgICAgbW9kZWwuaGFzT3duUHJvcGVydHkoJ19zdGFjaycpICYmXG4gICAgICB0eXBlb2YgbW9kZWwuX3N0YWNrICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgQXJyYXkgPT09IG1vZGVsLl9zdGFjay5jb25zdHJ1Y3RvcikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNZXJnZSBjdXJyZW50IHNlcmllcyB3aXRoIHByb3ZpZGVkIHNlcmllcy5cbiAgICogMiBzZXJpZXMgY2FuIE9OTFkgYmUgbWVyZ2UgaWYgdGhleSBoYXZlIHRoZSBzYW1lIFNlcmllc0luc3RhbmNlVUlELlxuICAgKlxuICAgKiBBbHNvIG1lcmdlcyB0aGUgc3RhY2tzIGluc2lkZSBhIHNlcmllcy5cbiAgICpcbiAgICogQHBhcmFtIHtNb2RlbHNTZXJpZXN9IHNlcmllcyAtIFNlcmllcyB0byBiZSBtZXJnZWQgYWdhaW5zdCBjdXJyZW50IHNlcmllcy5cbiAgICpcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBzZXJpZXMgY291bGQgYmUgbWVyZ2UuIEZhbHNlIGlmIG5vdC5cbiAgICpcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBtZXJnZShzZXJpZXMpIHtcbiAgICBpZiAoIXRoaXMudmFsaWRhdGUoc2VyaWVzKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9zZXJpZXNJbnN0YW5jZVVJRCA9PT0gc2VyaWVzLnNlcmllc0luc3RhbmNlVUlEKSB7XG4gICAgICByZXR1cm4gdGhpcy5tZXJnZU1vZGVscyh0aGlzLl9zdGFjaywgc2VyaWVzLnN0YWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBNZXJnZSBjdXJyZW50IHNlcmllcyB3aXRoIHByb3ZpZGVkIGFycmF5IG9mIHNlcmllcy5cbiAgICogMiBzZXJpZXMgY2FuIE9OTFkgYmUgbWVyZ2UgaWYgdGhleSBoYXZlIHRoZSBzYW1lIFNlcmllc0luc3RhbmNlVUlELlxuICAgKlxuICAgKiBBbHNvIG1lcmdlcyB0aGUgc3RhY2tzIGluc2lkZSBhIHNlcmllcy5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheS48TW9kZWxzU2VyaWVzPn0gdGFyZ2V0IC0gU2VyaWVzIHRvIGJlIG1lcmdlZCBhZ2FpbnN0IGN1cnJlbnQgc2VyaWVzLlxuICAgKlxuICAgKiBAcmV0dXJuIHtBcnJheS48TW9kZWxzU2VyaWVzPn0gQXJyYXkgb2Ygc2VyaWVzIHByb3Blcmx5IG1lcmdlZC5cbiAgICovXG4gIG1lcmdlU2VyaWVzKHRhcmdldCkge1xuICAgIGxldCBzZXJpZXNDb250YWluZXIgPSBbdGhpc107XG4gICAgdGhpcy5tZXJnZU1vZGVscyhzZXJpZXNDb250YWluZXIsIHRhcmdldCk7XG4gICAgcmV0dXJuIHNlcmllc0NvbnRhaW5lcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXJpZXMgaW5zdGFuY2UgVUlEIHNldHRlclxuICAgKlxuICAgKiBAcGFyYW0geyp9IHNlcmllc0luc3RhbmNlVUlEXG4gICAqL1xuICBzZXQgc2VyaWVzSW5zdGFuY2VVSUQoc2VyaWVzSW5zdGFuY2VVSUQpIHtcbiAgICB0aGlzLl9zZXJpZXNJbnN0YW5jZVVJRCA9IHNlcmllc0luc3RhbmNlVUlEO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlcmllcyBpbnN0YWNlIFVJRCBnZXR0ZXJcbiAgICpcbiAgICogQHJldHVybiB7Kn1cbiAgICovXG4gIGdldCBzZXJpZXNJbnN0YW5jZVVJRCgpIHtcbiAgICByZXR1cm4gdGhpcy5fc2VyaWVzSW5zdGFuY2VVSUQ7XG4gIH1cblxuICAvKipcbiAgICogVHJhbnNmZXIgc3ludGF4IFVJRCBzZXR0ZXJcbiAgICpcbiAgICogQHBhcmFtIHsqfSB0cmFuc2ZlclN5bnRheFVJRFxuICAgKi9cbiAgc2V0IHRyYW5zZmVyU3ludGF4VUlEKHRyYW5zZmVyU3ludGF4VUlEKSB7XG4gICAgdGhpcy5fdHJhbnNmZXJTeW50YXhVSUQgPSB0cmFuc2ZlclN5bnRheFVJRDtcbiAgfVxuXG4gIC8qKlxuICAgKiBUcmFuc2ZlciBzeW50YXggVUlEIGdldHRlclxuICAgKlxuICAgKiBAcmV0dXJuIHsqfVxuICAgKi9cbiAgZ2V0IHRyYW5zZmVyU3ludGF4VUlEKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc2ZlclN5bnRheFVJRDtcbiAgfVxuXG4gIC8qKlxuICAgKiBUcmFuc2ZlciBzeW50YXggVUlEIGdldHRlclxuICAgKlxuICAgKiBAcmV0dXJuIHsqfVxuICAgKi9cbiAgZ2V0IHRyYW5zZmVyU3ludGF4VUlETGFiZWwoKSB7XG4gICAgc3dpdGNoICh0aGlzLl90cmFuc2ZlclN5bnRheFVJRCkge1xuICAgICAgY2FzZSAnMS4yLjg0MC4xMDAwOC4xLjIuNC45MCc6XG4gICAgICAgIHJldHVybiAnSlBFRyAyMDAwIExvc3NsZXNzJztcbiAgICAgIGNhc2UgJzEuMi44NDAuMTAwMDguMS4yLjQuOTEnOlxuICAgICAgICByZXR1cm4gJ0pQRUcgMjAwMCBMb3NzeSc7XG4gICAgICBjYXNlICcxLjIuODQwLjEwMDA4LjEuMi40LjU3JzpcbiAgICAgICAgcmV0dXJuICdKUEVHIExvc3NsZXNzLCBOb25oaWVyYXJjaGljYWwgKFByb2Nlc3NlcyAxNCknO1xuICAgICAgY2FzZSAnMS4yLjg0MC4xMDAwOC4xLjIuNC43MCc6XG4gICAgICAgIHJldHVybiAnSlBFRyBMb3NzbGVzcywgTm9uaGllcmFyY2hpY2FsIChQcm9jZXNzZXMgMTQgW1NlbGVjdGlvbiAxXSknO1xuICAgICAgY2FzZSAnMS4yLjg0MC4xMDAwOC4xLjIuNC41MCc6XG4gICAgICAgIHJldHVybiAnSlBFRyBCYXNlbGluZSBsb3NzeSBwcm9jZXNzIDEgKDggYml0KSc7XG4gICAgICBjYXNlICcxLjIuODQwLjEwMDA4LjEuMi40LjUxJzpcbiAgICAgICAgcmV0dXJuICdKUEVHIEJhc2VsaW5lIGxvc3N5IHByb2Nlc3MgMiAmIDQgKDEyIGJpdCknO1xuICAgICAgY2FzZSAnMS4yLjg0MC4xMDAwOC4xLjInOlxuICAgICAgICByZXR1cm4gJ0ltcGxpY2l0IFZSIExpdHRsZSBFbmRpYW4nO1xuICAgICAgY2FzZSAnMS4yLjg0MC4xMDAwOC4xLjIuMSc6XG4gICAgICAgIHJldHVybiAnRXhwbGljaXQgVlIgTGl0dGxlIEVuZGlhbic7XG4gICAgICBjYXNlICcxLjIuODQwLjEwMDA4LjEuMi4yJzpcbiAgICAgICAgcmV0dXJuICdFeHBsaWNpdCBWUiBCaWcgRW5kaWFuJztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBgVW5rbm93biB0cmFuc2ZlcnN5bnRheDogJHt0aGlzLl90cmFuc2ZlclN5bnRheFVJRH1gO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTdHVkeSBkZXNjcmlwaXRpb24gc2V0dGVyXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gc3R1ZHlEZXNjcmlwdGlvblxuICAgKi9cbiAgc2V0IHN0dWR5RGVzY3JpcHRpb24oc3R1ZHlEZXNjcmlwdGlvbikge1xuICAgIHRoaXMuX3N0dWR5RGVzY3JpcHRpb24gPSBzdHVkeURlc2NyaXB0aW9uO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0dWR5IGRlc2NyaXB0aW9uIGdldHRlclxuICAgKlxuICAgKiBAcmV0dXJuIHsqfVxuICAgKi9cbiAgZ2V0IHN0dWR5RGVzY3JpcHRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0dWR5RGVzY3JpcHRpb247XG4gIH1cblxuICAvKipcbiAgICogU2VyaWVzIGRlc2NyaXBpdGlvbiBzZXR0ZXJcbiAgICpcbiAgICogQHBhcmFtIHsqfSBzZXJpZXNEZXNjcmlwdGlvblxuICAgKi9cbiAgc2V0IHNlcmllc0Rlc2NyaXB0aW9uKHNlcmllc0Rlc2NyaXB0aW9uKSB7XG4gICAgdGhpcy5fc2VyaWVzRGVzY3JpcHRpb24gPSBzZXJpZXNEZXNjcmlwdGlvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXJpZXMgZGVzY3JpcHRpb24gZ2V0dGVyXG4gICAqXG4gICAqIEByZXR1cm4geyp9XG4gICAqL1xuICBnZXQgc2VyaWVzRGVzY3JpcHRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Nlcmllc0Rlc2NyaXB0aW9uO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhdGllbnQgSUQgc2V0dGVyXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gcGF0aWVudElEXG4gICAqL1xuICBzZXQgcGF0aWVudElEKHBhdGllbnRJRCkge1xuICAgIHRoaXMuX3BhdGllbnRJRCA9IHBhdGllbnRJRDtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXRpZW50IElEIGdldHRlclxuICAgKlxuICAgKiBAcmV0dXJuIHsqfVxuICAgKi9cbiAgZ2V0IHBhdGllbnRJRCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcGF0aWVudElEO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhdGllbnQgbmFtZSBzZXR0ZXJcbiAgICpcbiAgICogQHBhcmFtIHsqfSBwYXRpZW50TmFtZVxuICAgKi9cbiAgc2V0IHBhdGllbnROYW1lKHBhdGllbnROYW1lKSB7XG4gICAgdGhpcy5fcGF0aWVudE5hbWUgPSBwYXRpZW50TmFtZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXRpZW50IG5hbWUgZ2V0dGVyXG4gICAqXG4gICAqIEByZXR1cm4geyp9XG4gICAqL1xuICBnZXQgcGF0aWVudE5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhdGllbnROYW1lO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhdGllbnQgYWdlIHNldHRlclxuICAgKlxuICAgKiBAcGFyYW0geyp9IHBhdGllbnRBZ2VcbiAgICovXG4gIHNldCBwYXRpZW50QWdlKHBhdGllbnRBZ2UpIHtcbiAgICB0aGlzLl9wYXRpZW50QWdlID0gcGF0aWVudEFnZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXRpZW50IGFnZSBnZXR0ZXJcbiAgICpcbiAgICogQHJldHVybiB7Kn1cbiAgICovXG4gIGdldCBwYXRpZW50QWdlKCkge1xuICAgIHJldHVybiB0aGlzLl9wYXRpZW50QWdlO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhdGllbnQgYmlydGhkYXRlIHNldHRlclxuICAgKlxuICAgKiBAcGFyYW0geyp9IHBhdGllbnRCaXJ0aGRhdGVcbiAgICovXG4gIHNldCBwYXRpZW50QmlydGhkYXRlKHBhdGllbnRCaXJ0aGRhdGUpIHtcbiAgICB0aGlzLl9wYXRpZW50QmlydGhkYXRlID0gcGF0aWVudEJpcnRoZGF0ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXRpZW50IGJpcnRoZGF0ZSBnZXR0ZXJcbiAgICpcbiAgICogQHJldHVybiB7Kn1cbiAgICovXG4gIGdldCBwYXRpZW50QmlydGhkYXRlKCkge1xuICAgIHJldHVybiB0aGlzLl9wYXRpZW50QmlydGhkYXRlO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhdGllbnQgc2V4IHNldHRlclxuICAgKlxuICAgKiBAcGFyYW0geyp9IHBhdGllbnRTZXhcbiAgICovXG4gIHNldCBwYXRpZW50U2V4KHBhdGllbnRTZXgpIHtcbiAgICB0aGlzLl9wYXRpZW50U2V4ID0gcGF0aWVudFNleDtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXRpZW50IHNleCBnZXR0ZXJcbiAgICpcbiAgICogQHJldHVybiB7Kn1cbiAgICovXG4gIGdldCBwYXRpZW50U2V4KCkge1xuICAgIHJldHVybiB0aGlzLl9wYXRpZW50U2V4O1xuICB9XG5cbiAgLyoqXG4gICAqIE51bWJlciBvZiBmcmFtZXMgc2V0dGVyXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gbnVtYmVyT2ZGcmFtZXNcbiAgICovXG4gIHNldCBudW1iZXJPZkZyYW1lcyhudW1iZXJPZkZyYW1lcykge1xuICAgIHRoaXMuX251bWJlck9mRnJhbWVzID0gbnVtYmVyT2ZGcmFtZXM7XG4gIH1cblxuICAvKipcbiAgICogTnVtYmVyIG9mIGZyYW1lcyBnZXR0ZXJcbiAgICpcbiAgICogQHJldHVybiB7Kn1cbiAgICovXG4gIGdldCBudW1iZXJPZkZyYW1lcygpIHtcbiAgICByZXR1cm4gdGhpcy5fbnVtYmVyT2ZGcmFtZXM7XG4gIH1cblxuICAvKipcbiAgICogTnVtYmVyIG9mIGNoYW5uZWxzIHNldHRlclxuICAgKlxuICAgKiBAcGFyYW0geyp9IG51bWJlck9mQ2hhbm5lbHNcbiAgICovXG4gIHNldCBudW1iZXJPZkNoYW5uZWxzKG51bWJlck9mQ2hhbm5lbHMpIHtcbiAgICB0aGlzLl9udW1iZXJPZkNoYW5uZWxzID0gbnVtYmVyT2ZDaGFubmVscztcbiAgfVxuXG4gIC8qKlxuICAgKiBOdW1iZXIgb2YgY2hhbm5lbHMgZ2V0dGVyXG4gICAqXG4gICAqIEByZXR1cm4geyp9XG4gICAqL1xuICBnZXQgbnVtYmVyT2ZDaGFubmVscygpIHtcbiAgICByZXR1cm4gdGhpcy5fbnVtYmVyT2ZDaGFubmVscztcbiAgfVxuXG4gIHNldCBzdGFjayhzdGFjaykge1xuICAgIHRoaXMuX3N0YWNrID0gc3RhY2s7XG4gIH1cblxuICBnZXQgc3RhY2soKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0YWNrO1xuICB9XG5cbiAgc2V0IG1vZGFsaXR5KG1vZGFsaXR5KSB7XG4gICAgdGhpcy5fbW9kYWxpdHkgPSBtb2RhbGl0eTtcbiAgfVxuXG4gIGdldCBtb2RhbGl0eSgpIHtcbiAgICByZXR1cm4gdGhpcy5fbW9kYWxpdHk7XG4gIH1cblxuICBzZXQgc2VnbWVudGF0aW9uVHlwZShzZWdtZW50YXRpb25UeXBlKSB7XG4gICAgdGhpcy5fc2VnbWVudGF0aW9uVHlwZSA9IHNlZ21lbnRhdGlvblR5cGU7XG4gIH1cblxuICBnZXQgc2VnbWVudGF0aW9uVHlwZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fc2VnbWVudGF0aW9uVHlwZTtcbiAgfVxuXG4gIHNldCBzZWdtZW50YXRpb25TZWdtZW50cyhzZWdtZW50YXRpb25TZWdtZW50cykge1xuICAgIHRoaXMuX3NlZ21lbnRhdGlvblNlZ21lbnRzID0gc2VnbWVudGF0aW9uU2VnbWVudHM7XG4gIH1cblxuICBnZXQgc2VnbWVudGF0aW9uU2VnbWVudHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NlZ21lbnRhdGlvblNlZ21lbnRzO1xuICB9XG59XG4iLCIvKiogKiBJbXBvcnRzICoqKi9cbmltcG9ydCBDb3JlQ29sb3JzIGZyb20gJy4uL2NvcmUvY29yZS5jb2xvcnMnO1xuaW1wb3J0IENvcmVVdGlscyBmcm9tICcuLi9jb3JlL2NvcmUudXRpbHMnO1xuaW1wb3J0IE1vZGVsc0Jhc2UgZnJvbSAnLi4vbW9kZWxzL21vZGVscy5iYXNlJztcblxuY29uc3QgYmluYXJ5U3RyaW5nID0gcmVxdWlyZSgnbWF0aC1mbG9hdDMyLXRvLWJpbmFyeS1zdHJpbmcnKTtcblxuLyoqXG4gKiBTdGFjayBvYmplY3QuXG4gKlxuICogQG1vZHVsZSBtb2RlbHMvc3RhY2tcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTW9kZWxzU3RhY2sgZXh0ZW5kcyBNb2RlbHNCYXNlIHtcbiAgLyoqXG4gICAqIE1vZGVscyBTdGFjayBjb25zdHJ1Y3RvclxuICAgKi9cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMuX3VpZCA9IG51bGw7XG4gICAgdGhpcy5fc3RhY2tJRCA9IC0xO1xuXG4gICAgdGhpcy5fZnJhbWUgPSBbXTtcbiAgICB0aGlzLl9udW1iZXJPZkZyYW1lcyA9IDA7XG5cbiAgICB0aGlzLl9yb3dzID0gMDtcbiAgICB0aGlzLl9jb2x1bW5zID0gMDtcbiAgICB0aGlzLl9udW1iZXJPZkNoYW5uZWxzID0gMTtcbiAgICB0aGlzLl9iaXRzQWxsb2NhdGVkID0gODtcbiAgICB0aGlzLl9waXhlbFR5cGUgPSAwO1xuICAgIHRoaXMuX3BpeGVsUmVwcmVzZW50YXRpb24gPSAwO1xuXG4gICAgdGhpcy5fdGV4dHVyZVNpemUgPSA0MDk2O1xuICAgIHRoaXMuX25iVGV4dHVyZXMgPSA3O1xuICAgIHRoaXMuX3Jhd0RhdGEgPSBbXTtcblxuICAgIHRoaXMuX3dpbmRvd0NlbnRlciA9IDA7XG4gICAgdGhpcy5fd2luZG93V2lkdGggPSAwO1xuXG4gICAgdGhpcy5fcmVzY2FsZVNsb3BlID0gMTtcbiAgICB0aGlzLl9yZXNjYWxlSW50ZXJjZXB0ID0gMDtcblxuICAgIHRoaXMuX21pbk1heCA9IFs2NTUzNSwgLTMyNzY4XTtcblxuICAgIC8vIFRSQU5TRk9STUFUSU9OIE1BVFJJQ0VTXG4gICAgdGhpcy5fcmVnTWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcblxuICAgIHRoaXMuX2lqazJMUFMgPSBudWxsO1xuICAgIHRoaXMuX2xwczJJSksgPSBudWxsO1xuXG4gICAgdGhpcy5fYWFiYjJMUFMgPSBudWxsO1xuICAgIHRoaXMuX2xwczJBQUJCID0gbnVsbDtcblxuICAgIC8vXG4gICAgLy8gSUpLIGRpbWVuc2lvbnNcbiAgICB0aGlzLl9kaW1lbnNpb25zSUpLID0gbnVsbDtcbiAgICB0aGlzLl9oYWxmRGltZW5zaW9uc0lKSyA9IG51bGw7XG4gICAgdGhpcy5fc3BhY2luZyA9IG5ldyBUSFJFRS5WZWN0b3IzKDEsIDEsIDEpO1xuICAgIHRoaXMuX3NwYWNpbmdCZXR3ZWVuU2xpY2VzID0gMDtcbiAgICB0aGlzLl9zbGljZVRoaWNrbmVzcyA9IDA7XG4gICAgdGhpcy5fb3JpZ2luID0gbnVsbDtcbiAgICB0aGlzLl9yaWdodEhhbmRlZCA9IHRydWU7XG4gICAgdGhpcy5feENvc2luZSA9IG5ldyBUSFJFRS5WZWN0b3IzKDEsIDAsIDApO1xuICAgIHRoaXMuX3lDb3NpbmUgPSBuZXcgVEhSRUUuVmVjdG9yMygwLCAxLCAwKTtcbiAgICB0aGlzLl96Q29zaW5lID0gbmV3IFRIUkVFLlZlY3RvcjMoMCwgMCwgMSk7XG5cbiAgICAvLyBjb252ZW5pZW5jZSB2YXJzXG4gICAgdGhpcy5fcHJlcGFyZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9wYWNrZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9wYWNrZWRQZXJQaXhlbCA9IDE7XG5cbiAgICAvL1xuICAgIHRoaXMuX21vZGFsaXR5ID0gJ01vZGFsaXR5IG5vdCBzZXQnO1xuXG4gICAgLy8gU0VHTUVOVEFUSU9OIFNUVUZGXG4gICAgdGhpcy5fc2VnbWVudGF0aW9uVHlwZSA9IG51bGw7XG4gICAgdGhpcy5fc2VnbWVudGF0aW9uU2VnbWVudHMgPSBbXTtcbiAgICB0aGlzLl9zZWdtZW50YXRpb25EZWZhdWx0Q29sb3IgPSBbNjMsIDE3NCwgMTI4XTtcbiAgICB0aGlzLl9mcmFtZVNlZ21lbnQgPSBbXTtcbiAgICB0aGlzLl9zZWdtZW50YXRpb25MVVQgPSBbXTtcbiAgICB0aGlzLl9zZWdtZW50YXRpb25MVVRPID0gW107XG5cbiAgICAvLyBwaG90b21ldHJpY0ludGVycHJldGF0aW9uIE1vbm9jaHJvbWUxIFZTIE1vbm9jaHJvbWUyXG4gICAgdGhpcy5faW52ZXJ0ID0gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogUHJlcGFyZSBzZWdtZW50YXRpb24gc3RhY2suXG4gICAqIEEgc2VnbWVudGF0aW9uIHN0YWNrIGNhbiBob2xkIHggZnJhbWVzIHRoYXQgYXJlIGF0IHRoZSBzYW1lIGxvY2F0aW9uXG4gICAqIGJ1dCBzZWdtZW50YXRpb24gc3BlY2lmaWMgaW5mb3JtYXRpb246XG4gICAqIC0gRnJhbWUgWCBjb250YWlucyB2b3hlbHMgZm9yIHNlZ21lbnRhdGlvbiBBLlxuICAgKiAtIEZyYW1lIFkgY29udGFpbnMgdm94ZWxzIGZvciBzZWdtZW50dGF0aW9uIEIuXG4gICAqIC0gRnJhbWUgWCBhbmQgWSBhcmUgYXQgdGhlIHNhbWUgbG9jYXRpb24uXG4gICAqXG4gICAqIFdlIGN1cnJlbnRseSBtZXJnZSBvdmVybGFwaW5nIGZyYW1lcyBpbnRvIDEuXG4gICAqL1xuICBwcmVwYXJlU2VnbWVudGF0aW9uKCkge1xuICAgIC8vIHN0b3JlIGZyYW1lIGFuZCBkbyBzcGVjaWFsIHByZS1wcm9jZXNzaW5nXG4gICAgdGhpcy5fZnJhbWVTZWdtZW50ID0gdGhpcy5fZnJhbWU7XG4gICAgbGV0IG1lcmdlZEZyYW1lcyA9IFtdO1xuXG4gICAgLy8gb3JkZXIgZnJhbWVzXG4gICAgdGhpcy5jb21wdXRlQ29zaW5lcygpO1xuICAgIHRoaXMuX2ZyYW1lLm1hcCh0aGlzLl9jb21wdXRlRGlzdGFuY2VBcnJheU1hcC5iaW5kKG51bGwsIHRoaXMuX3pDb3NpbmUpKTtcbiAgICB0aGlzLl9mcmFtZS5zb3J0KHRoaXMuX3NvcnREaXN0YW5jZUFycmF5U29ydCk7XG5cbiAgICAvLyBtZXJnZSBmcmFtZXNcbiAgICBsZXQgcHJldkluZGV4ID0gLTE7XG4gICAgZm9yIChsZXQgaSA9IDA7IGk8dGhpcy5fZnJhbWUubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICghbWVyZ2VkRnJhbWVzW3ByZXZJbmRleF0gfHxcbiAgICAgICAgICBtZXJnZWRGcmFtZXNbcHJldkluZGV4XS5fZGlzdCAhPSB0aGlzLl9mcmFtZVtpXS5fZGlzdCkge1xuICAgICAgICBtZXJnZWRGcmFtZXMucHVzaCh0aGlzLl9mcmFtZVtpXSk7XG4gICAgICAgIHByZXZJbmRleCsrO1xuXG4gICAgICAgIC8vIFNjYWxlIGZyYW1lXG4gICAgICAgIC8vIGJ5IGRlZmF1bHQgZWFjaCBmcmFtZSBjb250YWlucyBiaW5hcnkgZGF0YSBhYm91dCBhIHNlZ21lbnRhdGlvbi5cbiAgICAgICAgLy8gd2Ugc2NhbGUgaXQgYnkgdGhlIHJlZmVyZW5jZVNlZ21lbnROdW1iZXIgaW4gb3JkZXIgdG8gaGF2ZSBhXG4gICAgICAgIC8vIHNlZ21lbnRhdGlvbiBzcGVjaWZpYyB2b3hlbCB2YWx1ZSByYXRoZXIgdGhhbiAwIG9yIDEuXG4gICAgICAgIC8vIFRoYXQgYWxsb3dzIHVzIHRvIG1lcmdlIGZyYW1lcyBsYXRlciBvbi5cbiAgICAgICAgLy8gSWYgd2UgbWVyZ2UgZnJhbWVzIHdpdGhvdXQgc2NhbGluZywgdGhlbiB3ZSBjYW4gbm90IGRpZmZlcmVuY2lhdGVcbiAgICAgICAgLy8gdm94ZWxzIGZyb20gc2VnbWVudGF0aW9uIEEgb3IgQiBhcyB0aGUgdmFsdWUgaXMgMCBvciAxIGluIGJvdGggY2FzZXMuXG4gICAgICAgIGZvciAoXG4gICAgICAgICAgbGV0IGs9MDtcbiAgICAgICAgICBrPG1lcmdlZEZyYW1lc1twcmV2SW5kZXhdLl9yb3dzICogbWVyZ2VkRnJhbWVzW3ByZXZJbmRleF0uX2NvbHVtbnM7XG4gICAgICAgICAgaysrKSB7XG4gICAgICAgICAgbWVyZ2VkRnJhbWVzW3ByZXZJbmRleF0uX3BpeGVsRGF0YVtrXSAqPVxuICAgICAgICAgICAgdGhpcy5fZnJhbWVbaV0uX3JlZmVyZW5jZWRTZWdtZW50TnVtYmVyO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBmcmFtZSBhbHJlYWR5IGV4c2l0cyBhdCB0aGlzIGxvY2F0aW9uLlxuICAgICAgICAvLyBtZXJnZSBkYXRhIGZyb20gdGhpcyBzZWdtZW50YXRpb24gaW50byBleGlzdGluZyBmcmFtZVxuICAgICAgICBmb3IgKFxuICAgICAgICAgIGxldCBrPTA7XG4gICAgICAgICAgazxtZXJnZWRGcmFtZXNbcHJldkluZGV4XS5fcm93cyAqIG1lcmdlZEZyYW1lc1twcmV2SW5kZXhdLl9jb2x1bW5zO1xuICAgICAgICAgIGsrKykge1xuICAgICAgICAgIG1lcmdlZEZyYW1lc1twcmV2SW5kZXhdLl9waXhlbERhdGFba10gKz1cbiAgICAgICAgICAgIHRoaXMuX2ZyYW1lW2ldLnBpeGVsRGF0YVtrXSAqXG4gICAgICAgICAgICAgIHRoaXMuX2ZyYW1lW2ldLl9yZWZlcmVuY2VkU2VnbWVudE51bWJlcjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBtZXJnZWRGcmFtZXNbcHJldkluZGV4XS5taW5NYXggPVxuICAgICAgICBDb3JlVXRpbHMubWluTWF4KG1lcmdlZEZyYW1lc1twcmV2SW5kZXhdLl9waXhlbERhdGEpO1xuICAgIH1cblxuICAgIC8vIGdldCBpbmZvcm1hdGlvbiBhYm91dCBzZWdtZW50c1xuICAgIGxldCBkaWN0ID0ge307XG4gICAgbGV0IG1heCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGk8dGhpcy5fc2VnbWVudGF0aW9uU2VnbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIG1heCA9XG4gICAgICAgIE1hdGgubWF4KFxuICAgICAgICAgIG1heCwgcGFyc2VJbnQodGhpcy5fc2VnbWVudGF0aW9uU2VnbWVudHNbaV0uc2VnbWVudE51bWJlciwgMTApKTtcblxuICAgICAgbGV0IGNvbG9yID0gdGhpcy5fc2VnbWVudGF0aW9uU2VnbWVudHNbaV0ucmVjb21tZW5kZWREaXNwbGF5Q0lFTGFiO1xuICAgICAgaWYgKGNvbG9yID09PSBudWxsKSB7XG4gICAgICAgIGRpY3RbdGhpcy5fc2VnbWVudGF0aW9uU2VnbWVudHNbaV0uc2VnbWVudE51bWJlcl0gPVxuICAgICAgICAgIHRoaXMuX3NlZ21lbnRhdGlvbkRlZmF1bHRDb2xvcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRpY3RbdGhpcy5fc2VnbWVudGF0aW9uU2VnbWVudHNbaV0uc2VnbWVudE51bWJlcl0gPVxuICAgICAgICAgIENvcmVDb2xvcnMuY2llbGFiMlJHQiguLi5jb2xvcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gZ2VuZXJhdGUgTFVUc1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IG1heDsgaSsrKSB7XG4gICAgICBsZXQgaW5kZXggPSBpIC8gbWF4O1xuICAgICAgbGV0IG9wYWNpdHkgPSBpID8gMSA6IDA7XG4gICAgICBsZXQgcmdiID0gWzAsIDAsIDBdO1xuICAgICAgaWYgKGRpY3QuaGFzT3duUHJvcGVydHkoaS50b1N0cmluZygpKSkge1xuICAgICAgICByZ2IgPSBkaWN0W2kudG9TdHJpbmcoKV07XG4gICAgICB9XG5cbiAgICAgIHJnYlswXSAvPSAyNTU7XG4gICAgICByZ2JbMV0gLz0gMjU1O1xuICAgICAgcmdiWzJdIC89IDI1NTtcblxuICAgICAgdGhpcy5fc2VnbWVudGF0aW9uTFVULnB1c2goW2luZGV4LCAuLi5yZ2JdKTtcbiAgICAgIHRoaXMuX3NlZ21lbnRhdGlvbkxVVE8ucHVzaChbaW5kZXgsIG9wYWNpdHldKTtcbiAgICB9XG5cbiAgICB0aGlzLl9mcmFtZSA9IG1lcmdlZEZyYW1lcztcbiAgfVxuXG4gIC8qKlxuICAgKiBDb21wdXRlIGNvc2luZXNcbiAgICogT3JkZXIgZnJhbWVzXG4gICAqIGNvbXB1dGVTcGFjaW5nXG4gICAqIHNhbml0eUNoZWNrXG4gICAqIGluaXQgc29tZSB2YXJzXG4gICAqIGNvbXB1dGUgbWluL21heFxuICAgKiBjb21wdXRlIHRyYW5zZm9ybWF0aW9uIG1hdHJpY2VzXG4gICAqXG4gICAqIEByZXR1cm4geyp9XG4gICAqL1xuICBwcmVwYXJlKCkge1xuICAgIC8vIGlmIHNlZ21lbnRhdGlvbiwgbWVyZ2Ugc29tZSBmcmFtZXMuLi5cbiAgICBpZiAodGhpcy5fbW9kYWxpdHkgPT09ICdTRUcnKSB7XG4gICAgICB0aGlzLnByZXBhcmVTZWdtZW50YXRpb24oKTtcbiAgICB9XG5cbiAgICAvLyB3ZSBuZWVkIGF0IGxlYXN0IDEgZnJhbWVcbiAgICBpZiAodGhpcy5fZnJhbWUgJiYgdGhpcy5fZnJhbWUubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy5fbnVtYmVyT2ZGcmFtZXMgPSB0aGlzLl9mcmFtZS5sZW5ndGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdpbmRvdy5jb25zb2xlLmxvZygnX2ZyYW1lIGRvZXNuXFwndCBjb250YWluIGFueXRoaW5nLi4uLicpO1xuICAgICAgd2luZG93LmNvbnNvbGUubG9nKHRoaXMuX2ZyYW1lKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBwYXNzIHBhcmFtZXRlcnMgZnJvbSBmcmFtZSB0byBzdGFja1xuICAgIHRoaXMuX3Jvd3MgPSB0aGlzLl9mcmFtZVswXS5yb3dzO1xuICAgIHRoaXMuX2NvbHVtbnMgPSB0aGlzLl9mcmFtZVswXS5jb2x1bW5zO1xuICAgIHRoaXMuX2RpbWVuc2lvbnNJSksgPVxuICAgICAgbmV3IFRIUkVFLlZlY3RvcjModGhpcy5fY29sdW1ucywgdGhpcy5fcm93cywgdGhpcy5fbnVtYmVyT2ZGcmFtZXMpO1xuICAgIHRoaXMuX2hhbGZEaW1lbnNpb25zSUpLID0gbmV3IFRIUkVFLlZlY3RvcjMoXG4gICAgICB0aGlzLl9kaW1lbnNpb25zSUpLLnggLyAyLFxuICAgICAgdGhpcy5fZGltZW5zaW9uc0lKSy55IC8gMixcbiAgICAgIHRoaXMuX2RpbWVuc2lvbnNJSksueiAvIDJcbiAgICApO1xuICAgIHRoaXMuX3NwYWNpbmdCZXR3ZWVuU2xpY2VzID0gdGhpcy5fZnJhbWVbMF0uc3BhY2luZ0JldHdlZW5TbGljZXM7XG4gICAgdGhpcy5fc2xpY2VUaGlja25lc3MgPSB0aGlzLl9mcmFtZVswXS5zbGljZVRoaWNrbmVzcztcblxuICAgIC8vIGNvbXB1dGUgZGlyZWN0aW9uIGNvc2luZXNcbiAgICB0aGlzLmNvbXB1dGVDb3NpbmVzKCk7XG5cbiAgICAvLyBvcmRlciB0aGUgZnJhbWVzXG4gICAgdGhpcy5vcmRlckZyYW1lcygpO1xuXG4gICAgLy8gY29tcHV0ZS9ndWVzcyBzcGFjaW5nXG4gICAgdGhpcy5jb21wdXRlU3BhY2luZygpO1xuICAgIC8vIHNldCBleHRyYSB2YXJzIGlmIG51bGxzXG4gICAgLy8gZG8gaXQgbm93IGJlY2F1c2UgYmVmb3JlIHdlIHdvdWxkIHRoaW5rIGltYWdlIHBvc2l0aW9uL29yaWVudGF0aW9uXG4gICAgLy8gYXJlIGRlZmluZWQgYW5kIHdlIHdvdWxkIHVzZSBpdCB0byBjb21wdXRlIHNwYWNpbmcuXG4gICAgaWYgKCF0aGlzLl9mcmFtZVswXS5pbWFnZVBvc2l0aW9uKSB7XG4gICAgICB0aGlzLl9mcmFtZVswXS5pbWFnZVBvc2l0aW9uID0gWzAsIDAsIDBdO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuX2ZyYW1lWzBdLmltYWdlT3JpZW50YXRpb24pIHtcbiAgICAgIHRoaXMuX2ZyYW1lWzBdLmltYWdlT3JpZW50YXRpb24gPSBbMSwgMCwgMCwgMCwgMSwgMF07XG4gICAgfVxuXG4gICAgdGhpcy5fb3JpZ2luID0gdGhpcy5fYXJyYXlUb1ZlY3RvcjModGhpcy5fZnJhbWVbMF0uaW1hZ2VQb3NpdGlvbiwgMCk7XG5cbiAgICAvLyBjb21wdXRlIHRyYW5zZm9ybXNcbiAgICB0aGlzLmNvbXB1dGVJSksyTFBTKCk7XG5cbiAgICB0aGlzLmNvbXB1dGVMUFMyQUFCQigpO1xuICAgIC8vIHRoaXMucGFja0VjaG9zKCk7XG5cbiAgICB0aGlzLl9yZXNjYWxlU2xvcGUgPSB0aGlzLl9mcmFtZVswXS5yZXNjYWxlU2xvcGUgfHwgMTtcbiAgICB0aGlzLl9yZXNjYWxlSW50ZXJjZXB0ID0gdGhpcy5fZnJhbWVbMF0ucmVzY2FsZUludGVyY2VwdCB8fCAwO1xuXG4gICAgLy8gcmVzY2FsZS9zbG9wZSBtaW4gbWF4XG4gICAgdGhpcy5jb21wdXRlTWluTWF4SW50ZW5zaXRpZXMoKTtcbiAgICB0aGlzLl9taW5NYXhbMF0gPSBNb2RlbHNTdGFjay52YWx1ZVJlc2NhbGVTbG9wZUludGVyY2VwdChcbiAgICAgIHRoaXMuX21pbk1heFswXSxcbiAgICAgIHRoaXMuX3Jlc2NhbGVTbG9wZSxcbiAgICAgIHRoaXMuX3Jlc2NhbGVJbnRlcmNlcHQpO1xuICAgIHRoaXMuX21pbk1heFsxXSA9IE1vZGVsc1N0YWNrLnZhbHVlUmVzY2FsZVNsb3BlSW50ZXJjZXB0KFxuICAgICAgdGhpcy5fbWluTWF4WzFdLFxuICAgICAgdGhpcy5fcmVzY2FsZVNsb3BlLFxuICAgICAgdGhpcy5fcmVzY2FsZUludGVyY2VwdCk7XG5cbiAgICBsZXQgd2lkdGggPSB0aGlzLl9mcmFtZVswXS53aW5kb3dXaWR0aCB8fCB0aGlzLl9taW5NYXhbMV0gLSB0aGlzLl9taW5NYXhbMF07XG4gICAgdGhpcy5fd2luZG93V2lkdGggPSB0aGlzLl9yZXNjYWxlU2xvcGUgKiB3aWR0aCArIHRoaXMuX3Jlc2NhbGVJbnRlcmNlcHQ7XG5cbiAgICBsZXQgY2VudGVyID0gdGhpcy5fZnJhbWVbMF0ud2luZG93Q2VudGVyIHx8IHRoaXMuX21pbk1heFswXSArIHdpZHRoIC8gMjtcbiAgICB0aGlzLl93aW5kb3dDZW50ZXIgPSB0aGlzLl9yZXNjYWxlU2xvcGUgKiBjZW50ZXIgKyB0aGlzLl9yZXNjYWxlSW50ZXJjZXB0O1xuXG4gICAgdGhpcy5fYml0c0FsbG9jYXRlZCA9IHRoaXMuX2ZyYW1lWzBdLmJpdHNBbGxvY2F0ZWQ7XG4gICAgdGhpcy5fcHJlcGFyZWQgPSB0cnVlO1xuICB9XG5cbiAgcGFja0VjaG9zKCkge1xuICAgIC8vIDQgZWNobyB0aW1lcy4uLlxuICAgIGxldCBlY2hvcyA9IDQ7XG4gICAgbGV0IHBhY2tlZEVjaG8gPSBbXTtcbiAgICBmb3IgKGxldCBpPTA7IGk8IHRoaXMuX2ZyYW1lLmxlbmd0aDsgaSs9ZWNob3MpIHtcbiAgICAgIGxldCBmcmFtZSA9IHRoaXMuX2ZyYW1lW2ldO1xuICAgICAgZm9yIChsZXQgaz0wOyBrPHRoaXMuX3Jvd3MgKiB0aGlzLl9jb2x1bW5zOyBrKyspIHtcbiAgICAgICAgZm9yIChsZXQgaj0xOyBqPGVjaG9zOyBqKyspIHtcbiAgICAgICAgICBmcmFtZS5waXhlbERhdGFba10gKz0gdGhpcy5fZnJhbWVbaStqXS5waXhlbERhdGFba107XG4gICAgICAgIH1cbiAgICAgICAgZnJhbWUucGl4ZWxEYXRhW2tdIC89IGVjaG9zO1xuICAgICAgfVxuICAgICAgcGFja2VkRWNoby5wdXNoKGZyYW1lKTtcbiAgICB9XG4gICAgdGhpcy5fZnJhbWUgPSBwYWNrZWRFY2hvO1xuICAgIHRoaXMuX251bWJlck9mRnJhbWVzID0gdGhpcy5fZnJhbWUubGVuZ3RoO1xuICAgIHRoaXMuX2RpbWVuc2lvbnNJSksgPVxuICAgICAgbmV3IFRIUkVFLlZlY3RvcjModGhpcy5fY29sdW1ucywgdGhpcy5fcm93cywgdGhpcy5fbnVtYmVyT2ZGcmFtZXMpO1xuICAgIHRoaXMuX2hhbGZEaW1lbnNpb25zSUpLID0gbmV3IFRIUkVFLlZlY3RvcjMoXG4gICAgICB0aGlzLl9kaW1lbnNpb25zSUpLLnggLyAyLFxuICAgICAgdGhpcy5fZGltZW5zaW9uc0lKSy55IC8gMixcbiAgICAgIHRoaXMuX2RpbWVuc2lvbnNJSksueiAvIDJcbiAgICApO1xuICB9XG5cbiAgLy8gZnJhbWUuY29zaW5lcyAtIHJldHVybnMgYXJyYXkgW3gsIHksIHpdXG4gIGNvbXB1dGVDb3NpbmVzKCkge1xuICAgIGlmICh0aGlzLl9mcmFtZSAmJlxuICAgICAgdGhpcy5fZnJhbWVbMF0pIHtcbiAgICAgIGxldCBjb3NpbmVzID0gdGhpcy5fZnJhbWVbMF0uY29zaW5lcygpO1xuICAgICAgdGhpcy5feENvc2luZSA9IGNvc2luZXNbMF07XG4gICAgICB0aGlzLl95Q29zaW5lID0gY29zaW5lc1sxXTtcbiAgICAgIHRoaXMuX3pDb3NpbmUgPSBjb3NpbmVzWzJdO1xuICAgIH1cbiAgfVxuXG4gIG9yZGVyRnJhbWVzKCkge1xuICAgIC8vIG9yZGVyIHRoZSBmcmFtZXMgYmFzZWQgb24gdGhlaXJzIGRpbWVuc2lvbiBpbmRpY2VzXG4gICAgLy8gZmlyc3QgaW5kZXggaXMgdGhlIG1vc3QgaW1wb3J0YW50LlxuICAgIC8vIDEsMSwxLDEgd2lsbGwgYmUgZmlyc3RcbiAgICAvLyAxLDEsMiwxIHdpbGwgYmUgbmV4dFxuICAgIC8vIDEsMSwyLDMgd2lsbCBiZSBuZXh0XG4gICAgLy8gMSwxLDMsMSB3aWwgYmUgbmV4dFxuICAgIGlmICh0aGlzLl9mcmFtZVswXS5kaW1lbnNpb25JbmRleFZhbHVlcykge1xuICAgICAgdGhpcy5fZnJhbWUuc29ydCh0aGlzLl9vcmRlckZyYW1lT25EaW1lbnNpb25JbmRpY2VzQXJyYXlTb3J0KTtcblxuICAgIC8vIGVsc2Ugb3JkZXIgd2l0aCBpbWFnZSBwb3NpdGlvbiBhbmQgb3JpZW50YXRpb25cbiAgICB9IGVsc2UgaWYgKFxuICAgICAgdGhpcy5fZnJhbWVbMF0uaW1hZ2VQb3NpdGlvbiAmJiB0aGlzLl9mcmFtZVswXS5pbWFnZU9yaWVudGF0aW9uICYmXG4gICAgICB0aGlzLl9mcmFtZVsxXSAmJlxuICAgICAgdGhpcy5fZnJhbWVbMV0uaW1hZ2VQb3NpdGlvbiAmJiB0aGlzLl9mcmFtZVsxXS5pbWFnZU9yaWVudGF0aW9uICYmXG4gICAgICB0aGlzLl9mcmFtZVswXS5pbWFnZVBvc2l0aW9uLmpvaW4oKSAhPT0gdGhpcy5fZnJhbWVbMV0uaW1hZ2VQb3NpdGlvbi5qb2luKCkpIHtcbiAgICAgIC8vIGNvbXB1dGUgYW5kIHNvcnQgYnkgZGlzdCBpbiB0aGlzIHNlcmllc1xuICAgICAgdGhpcy5fZnJhbWUubWFwKHRoaXMuX2NvbXB1dGVEaXN0YW5jZUFycmF5TWFwLmJpbmQobnVsbCwgdGhpcy5fekNvc2luZSkpO1xuICAgICAgdGhpcy5fZnJhbWUuc29ydCh0aGlzLl9zb3J0RGlzdGFuY2VBcnJheVNvcnQpO1xuICAgIH0gZWxzZSBpZiAoXG4gICAgICB0aGlzLl9mcmFtZVswXS5pbnN0YW5jZU51bWJlciAhPT0gbnVsbCAmJlxuICAgICAgdGhpcy5fZnJhbWVbMV0gJiYgdGhpcy5fZnJhbWVbMV0uaW5zdGFuY2VOdW1iZXIgIT09IG51bGwgJiZcbiAgICAgIHRoaXMuX2ZyYW1lWzBdLmluc3RhbmNlTnVtYmVyICE9PSB0aGlzLl9mcmFtZVsxXS5pbnN0YW5jZU51bWJlcikge1xuICAgICAgdGhpcy5fZnJhbWUuc29ydCh0aGlzLl9zb3J0SW5zdGFuY2VOdW1iZXJBcnJheVNvcnQpO1xuICAgIH0gZWxzZSBpZiAoXG4gICAgICB0aGlzLl9mcmFtZVswXS5zb3BJbnN0YW5jZVVJRCAmJlxuICAgICAgdGhpcy5fZnJhbWVbMV0gJiYgdGhpcy5fZnJhbWVbMV0uc29wSW5zdGFuY2VVSUQgJiZcbiAgICAgIHRoaXMuX2ZyYW1lWzBdLnNvcEluc3RhbmNlVUlEICE9PSB0aGlzLl9mcmFtZVsxXS5zb3BJbnN0YW5jZVVJRCkge1xuICAgICAgdGhpcy5fZnJhbWUuc29ydCh0aGlzLl9zb3J0U29wSW5zdGFuY2VVSURBcnJheVNvcnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB3aW5kb3cuY29uc29sZS5sb2codGhpcy5fZnJhbWVbMF0pO1xuICAgICAgLy8gd2luZG93LmNvbnNvbGUubG9nKHRoaXMuX2ZyYW1lWzFdKTtcbiAgICAgIC8vIHdpbmRvdy5jb25zb2xlLmxvZyh0aGlzLl9mcmFtZVswXS5pbnN0YW5jZU51bWJlciAhPT0gbnVsbCAmJiB0cnVlKTtcbiAgICAgIC8vIHdpbmRvdy5jb25zb2xlLmxvZyhcbiAgICAgIC8vIHRoaXMuX2ZyYW1lWzBdLmluc3RhbmNlTnVtYmVyICE9PSB0aGlzLl9mcmFtZVsxXS5pbnN0YW5jZU51bWJlcik7XG4gICAgICB3aW5kb3cuY29uc29sZS5sb2coJ2RvIG5vdCBrbm93IGhvdyB0byBvcmRlciB0aGUgZnJhbWVzLi4uJyk7XG4gICAgICAvLyBlbHNlIHNsaWNlIGxvY2F0aW9uXG4gICAgICAvLyBpbWFnZSBudW1iZXJcbiAgICAgIC8vIE9SREVSSU5HIEJBU0VEIE9OIGluc3RhbmNlIG51bWJlclxuICAgICAgLy8gX29yZGVyaW5nID0gJ2luc3RhbmNlX251bWJlcic7XG4gICAgICAvLyBmaXJzdF9pbWFnZS5zb3J0KGZ1bmN0aW9uKGEsYil7XG4gICAgICAvLyByZXR1cm4gYVtcImluc3RhbmNlX251bWJlclwiXS1iW1wiaW5zdGFuY2VfbnVtYmVyXCJdfSk7XG4gICAgfVxuICB9XG5cbiAgY29tcHV0ZVNwYWNpbmcoKSB7XG4gICAgdGhpcy54eVNwYWNpbmcoKTtcbiAgICB0aGlzLnpTcGFjaW5nKCk7XG4gIH1cblxuICAvKipcbiAgICogQ29tcHV0ZSBzdGFjayB6IHNwYWNpbmdcbiAgICovXG4gIHpTcGFjaW5nKCkge1xuICAgIGlmICh0aGlzLl9udW1iZXJPZkZyYW1lcyA+IDEpIHtcbiAgICAgIGlmICh0aGlzLl9mcmFtZVswXS5waXhlbFNwYWNpbmcgJiYgdGhpcy5fZnJhbWVbMF0ucGl4ZWxTcGFjaW5nWzJdKSB7XG4gICAgICAgIHRoaXMuX3NwYWNpbmcueiA9IHRoaXMuX2ZyYW1lWzBdLnBpeGVsU3BhY2luZ1syXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGNvbXB1dGUgYW5kIHNvcnQgYnkgZGlzdCBpbiB0aGlzIHNlcmllc1xuICAgICAgICB0aGlzLl9mcmFtZS5tYXAoXG4gICAgICAgICAgdGhpcy5fY29tcHV0ZURpc3RhbmNlQXJyYXlNYXAuYmluZChudWxsLCB0aGlzLl96Q29zaW5lKSk7XG5cbiAgICAgICAgLy8gaWYgZGlzdGFuY2VzIGFyZSBkaWZmZXJlbnQsIHJlLXNvcnQgYXJyYXlcbiAgICAgICAgaWYgKHRoaXMuX2ZyYW1lWzFdLmRpc3QgIT09IHRoaXMuX2ZyYW1lWzBdLmRpc3QpIHtcbiAgICAgICAgICB0aGlzLl9mcmFtZS5zb3J0KHRoaXMuX3NvcnREaXN0YW5jZUFycmF5U29ydCk7XG4gICAgICAgICAgdGhpcy5fc3BhY2luZy56ID0gdGhpcy5fZnJhbWVbMV0uZGlzdCAtIHRoaXMuX2ZyYW1lWzBdLmRpc3Q7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fc3BhY2luZ0JldHdlZW5TbGljZXMpIHtcbiAgICAgICAgICB0aGlzLl9zcGFjaW5nLnogPSB0aGlzLl9zcGFjaW5nQmV0d2VlblNsaWNlcztcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9mcmFtZVswXS5zbGljZVRoaWNrbmVzcykge1xuICAgICAgICAgIHRoaXMuX3NwYWNpbmcueiA9IHRoaXMuX2ZyYW1lWzBdLnNsaWNlVGhpY2tuZXNzO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gU3BhY2luZ1xuICAgIC8vIGNhbiBub3QgYmUgMCBpZiBub3QgbWF0cml4IGNhbiBub3QgYmUgaW52ZXJ0ZWQuXG4gICAgaWYgKHRoaXMuX3NwYWNpbmcueiA9PT0gMCkge1xuICAgICAgdGhpcy5fc3BhY2luZy56ID0gMTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogIEZSQU1FIENBTiBETyBJVFxuICAgKi9cbiAgeHlTcGFjaW5nKCkge1xuICAgIGlmICh0aGlzLl9mcmFtZSAmJlxuICAgICAgdGhpcy5fZnJhbWVbMF0pIHtcbiAgICAgIGxldCBzcGFjaW5nWFkgPSB0aGlzLl9mcmFtZVswXS5zcGFjaW5nWFkoKTtcbiAgICAgIHRoaXMuX3NwYWNpbmcueCA9IHNwYWNpbmdYWVswXTtcbiAgICAgIHRoaXMuX3NwYWNpbmcueSA9IHNwYWNpbmdYWVsxXTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRmluZCBtaW4gYW5kIG1heCBpbnRlbnNpdGllcyBhbW9uZyBhbGwgZnJhbWVzLlxuICAgKi9cbiAgY29tcHV0ZU1pbk1heEludGVuc2l0aWVzKCkge1xuICAgIC8vIHdoYXQgYWJvdXQgY29sb3JzISEhIT9cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2ZyYW1lLmxlbmd0aDsgaSsrKSB7XG4gICAgICAvLyBnZXQgbWluL21heFxuICAgICAgdGhpcy5fbWluTWF4WzBdID0gTWF0aC5taW4odGhpcy5fbWluTWF4WzBdLCB0aGlzLl9mcmFtZVtpXS5taW5NYXhbMF0pO1xuICAgICAgdGhpcy5fbWluTWF4WzFdID0gTWF0aC5tYXgodGhpcy5fbWluTWF4WzFdLCB0aGlzLl9mcmFtZVtpXS5taW5NYXhbMV0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDb21wdXRlIElKSyB0byBMUFMgYW5kIGludmVydCB0cmFuc2Zvcm1zXG4gICAqL1xuICBjb21wdXRlSUpLMkxQUygpIHtcbiAgICAvLyBpamsgdG8gbHBzXG4gICAgdGhpcy5faWprMkxQUyA9IENvcmVVdGlscy5pamsyTFBTKFxuICAgICAgdGhpcy5feENvc2luZSwgdGhpcy5feUNvc2luZSwgdGhpcy5fekNvc2luZSxcbiAgICAgIHRoaXMuX3NwYWNpbmcsIHRoaXMuX29yaWdpbixcbiAgICAgIHRoaXMuX3JlZ01hdHJpeFxuICAgICk7XG5cbiAgICAvLyBscHMgMiBpamtcbiAgICB0aGlzLl9scHMySUpLID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcbiAgICB0aGlzLl9scHMySUpLLmdldEludmVyc2UodGhpcy5faWprMkxQUyk7XG4gIH1cblxuICAvKipcbiAgICogQ29tcHV0ZSBMUFMgdG8gQUFCQiBhbmQgaW52ZXJ0IHRyYW5zZm9ybXNcbiAgICovXG4gIGNvbXB1dGVMUFMyQUFCQigpIHtcbiAgICB0aGlzLl9hYWJiMkxQUyA9IENvcmVVdGlscy5hYWJiMkxQUyhcbiAgICAgIHRoaXMuX3hDb3NpbmUsIHRoaXMuX3lDb3NpbmUsIHRoaXMuX3pDb3NpbmUsXG4gICAgICB0aGlzLl9vcmlnaW5cbiAgICApO1xuXG4gICAgdGhpcy5fbHBzMkFBQkIgPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xuICAgIHRoaXMuX2xwczJBQUJCLmdldEludmVyc2UodGhpcy5fYWFiYjJMUFMpO1xuICB9XG5cbiAgLyoqXG4gICAqIE1lcmdlIHN0YWNrc1xuICAgKlxuICAgKiBAcGFyYW0geyp9IHN0YWNrXG4gICAqXG4gICAqIEByZXR1cm4geyp9XG4gICAqL1xuICBtZXJnZShzdGFjaykge1xuICAgIC8vIGFsc28gbWFrZSBzdXJlIHgveS96IGNvc2luZXMgYXJlIGEgbWF0Y2ghXG4gICAgaWYgKHRoaXMuX3N0YWNrSUQgPT09IHN0YWNrLnN0YWNrSUQpIHtcbiAgICAgIHJldHVybiB0aGlzLm1lcmdlTW9kZWxzKHRoaXMuX2ZyYW1lLCBzdGFjay5mcmFtZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUGFjayBjdXJyZW50IHN0YWNrIHBpeGVsIGRhdGEgaW50byA4IGJpdHMgYXJyYXkgYnVmZmVyc1xuICAgKi9cbiAgcGFjaygpIHtcbiAgICAvLyBHZXQgdG90YWwgbnVtYmVyIG9mIHZveGVsc1xuICAgIGNvbnN0IG5iVm94ZWxzID1cbiAgICAgIHRoaXMuX2RpbWVuc2lvbnNJSksueCAqIHRoaXMuX2RpbWVuc2lvbnNJSksueSAqIHRoaXMuX2RpbWVuc2lvbnNJSksuejtcblxuICAgIC8vIFBhY2tpbmcgc3R5bGVcbiAgICBpZiAodGhpcy5fYml0c0FsbG9jYXRlZCA9PT0gMTYgJiYgdGhpcy5fbnVtYmVyT2ZDaGFubmVscyA9PT0gMSkge1xuICAgICAgdGhpcy5fcGFja2VkUGVyUGl4ZWwgPSAyO1xuICAgIH1cblxuICAgIC8vIExvb3AgdGhyb3VnaCBhbGwgdGhlIHRleHR1cmVzIHdlIG5lZWRcbiAgICBjb25zdCB0ZXh0dXJlRGltZW5zaW9uID0gdGhpcy5fdGV4dHVyZVNpemUgKiB0aGlzLl90ZXh0dXJlU2l6ZTtcbiAgICBjb25zdCByZXF1aXJlZFRleHR1cmVzID1cbiAgICAgIE1hdGguY2VpbChuYlZveGVscyAvICh0ZXh0dXJlRGltZW5zaW9uICogdGhpcy5fcGFja2VkUGVyUGl4ZWwpKTtcbiAgICBsZXQgdm94ZWxJbmRleFN0YXJ0ID0gMDtcbiAgICBsZXQgdm94ZWxJbmRleFN0b3AgPSB0aGlzLl9wYWNrZWRQZXJQaXhlbCAqIHRleHR1cmVEaW1lbnNpb247XG4gICAgaWYgKHZveGVsSW5kZXhTdG9wID4gbmJWb3hlbHMpIHtcbiAgICAgIHZveGVsSW5kZXhTdG9wID0gbmJWb3hlbHM7XG4gICAgfVxuXG4gICAgZm9yIChsZXQgaWkgPSAwOyBpaSA8IHJlcXVpcmVkVGV4dHVyZXM7IGlpKyspIHtcbiAgICAgIGxldCBwYWNrZWQgPVxuICAgICAgICB0aGlzLl9wYWNrVG84Qml0cyhcbiAgICAgICAgICB0aGlzLl9udW1iZXJPZkNoYW5uZWxzLFxuICAgICAgICAgIHRoaXMuX2ZyYW1lLFxuICAgICAgICAgIHRoaXMuX3RleHR1cmVTaXplLFxuICAgICAgICAgIHZveGVsSW5kZXhTdGFydCxcbiAgICAgICAgICB2b3hlbEluZGV4U3RvcCk7XG4gICAgICB0aGlzLl90ZXh0dXJlVHlwZSA9IHBhY2tlZC50ZXh0dXJlVHlwZTtcbiAgICAgIHRoaXMuX3Jhd0RhdGEucHVzaChwYWNrZWQuZGF0YSk7XG5cbiAgICAgIHZveGVsSW5kZXhTdGFydCArPSB0aGlzLl9wYWNrZWRQZXJQaXhlbCAqIHRleHR1cmVEaW1lbnNpb247XG4gICAgICB2b3hlbEluZGV4U3RvcCArPSB0aGlzLl9wYWNrZWRQZXJQaXhlbCAqIHRleHR1cmVEaW1lbnNpb247XG4gICAgICBpZiAodm94ZWxJbmRleFN0b3AgPiBuYlZveGVscykge1xuICAgICAgICB2b3hlbEluZGV4U3RvcCA9IG5iVm94ZWxzO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuX3BhY2tlZCA9IHRydWU7XG4gIH1cblxuICAvKipcbiAgICogUGFjayBmcmFtZSBkYXRhIHRvIDMyIGJpdHMgdGV4dHVyZVxuICAgKiBAcGFyYW0geyp9IGNoYW5uZWxzXG4gICAqIEBwYXJhbSB7Kn0gZnJhbWVcbiAgICogQHBhcmFtIHsqfSB0ZXh0dXJlU2l6ZVxuICAgKiBAcGFyYW0geyp9IHN0YXJ0Vm94ZWxcbiAgICogQHBhcmFtIHsqfSBzdG9wVm94ZWxcbiAgICovXG4gIF9wYWNrVG84Qml0cyhjaGFubmVscywgZnJhbWUsIHRleHR1cmVTaXplLCBzdGFydFZveGVsLCBzdG9wVm94ZWwpIHtcbiAgICBjb25zdCBwYWNrZWQgPSB7XG4gICAgICB0ZXh0dXJlVHlwZTogbnVsbCxcbiAgICAgIGRhdGE6IG51bGwsXG4gICAgfTtcblxuICAgIGNvbnN0IGJpdHNBbGxvY2F0ZWQgPSBmcmFtZVswXS5iaXRzQWxsb2NhdGVkO1xuICAgIGNvbnN0IHBpeGVsVHlwZSA9IGZyYW1lWzBdLnBpeGVsVHlwZTtcblxuICAgIC8vIHRyYW5zZm9ybSBzaWduZWQgdG8gdW5zaWduZWQgZm9yIGNvbnZlbmllbmNlXG4gICAgbGV0IG9mZnNldCA9IDA7XG4gICAgaWYgKHRoaXMuX21pbk1heFswXSA8IDApIHtcbiAgICAgIG9mZnNldCAtPSB0aGlzLl9taW5NYXhbMF07XG4gICAgfVxuXG4gICAgbGV0IHBhY2tJbmRleCA9IDA7XG4gICAgbGV0IGZyYW1lSW5kZXggPSAwO1xuICAgIGxldCBpbkZyYW1lSW5kZXggPSAwO1xuICAgIC8vIGZyYW1lIHNob3VsZCByZXR1cm4gaXQhXG4gICAgY29uc3QgZnJhbWVEaW1lbnNpb24gPSBmcmFtZVswXS5yb3dzICogZnJhbWVbMF0uY29sdW1ucztcblxuICAgIGlmIChiaXRzQWxsb2NhdGVkID09PSA4ICYmIGNoYW5uZWxzID09PSAxIHx8IGJpdHNBbGxvY2F0ZWQgPT09IDEpIHtcbiAgICAgIGxldCBkYXRhID0gbmV3IFVpbnQ4QXJyYXkodGV4dHVyZVNpemUgKiB0ZXh0dXJlU2l6ZSAqIDEpO1xuICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0Vm94ZWw7IGkgPCBzdG9wVm94ZWw7IGkrKykge1xuICAgICAgICBmcmFtZUluZGV4ID0gfn4oaSAvIGZyYW1lRGltZW5zaW9uKTtcbiAgICAgICAgaW5GcmFtZUluZGV4ID0gaSAlIChmcmFtZURpbWVuc2lvbik7XG5cbiAgICAgICAgZGF0YVtwYWNrSW5kZXhdID0gb2Zmc2V0ICsgZnJhbWVbZnJhbWVJbmRleF0ucGl4ZWxEYXRhW2luRnJhbWVJbmRleF07XG4gICAgICAgIHBhY2tJbmRleCsrO1xuICAgICAgfVxuICAgICAgcGFja2VkLnRleHR1cmVUeXBlID0gVEhSRUUuTHVtaW5hbmNlRm9ybWF0O1xuICAgICAgcGFja2VkLmRhdGEgPSBkYXRhO1xuICAgIH0gZWxzZSBpZiAoYml0c0FsbG9jYXRlZCA9PT0gMTYgJiYgY2hhbm5lbHMgPT09IDEpIHtcbiAgICAgIGxldCBkYXRhID0gbmV3IFVpbnQ4QXJyYXkodGV4dHVyZVNpemUgKiB0ZXh0dXJlU2l6ZSAqIDQpO1xuICAgICAgbGV0IGNvb3JkaW5hdGUgPSAwO1xuICAgICAgbGV0IGNoYW5uZWxPZmZzZXQgPSAwO1xuXG4gICAgICBmb3IgKGxldCBpID0gc3RhcnRWb3hlbDsgaSA8IHN0b3BWb3hlbDsgaSsrKSB7XG4gICAgICAgIGZyYW1lSW5kZXggPSB+fihpIC8gZnJhbWVEaW1lbnNpb24pO1xuICAgICAgICBpbkZyYW1lSW5kZXggPSBpICUgKGZyYW1lRGltZW5zaW9uKTtcblxuXG4gICAgICAgIGxldCByYXcgPSBvZmZzZXQgKyBmcmFtZVtmcmFtZUluZGV4XS5waXhlbERhdGFbaW5GcmFtZUluZGV4XTtcbiAgICAgICAgZGF0YVs0ICogY29vcmRpbmF0ZSArIDIgKiBjaGFubmVsT2Zmc2V0XSA9IHJhdyAmIDB4MDBGRjtcbiAgICAgICAgZGF0YVs0ICogY29vcmRpbmF0ZSArIDIgKiBjaGFubmVsT2Zmc2V0ICsgMV0gPSAocmF3ID4+PiA4KSAmIDB4MDBGRjtcblxuICAgICAgICBwYWNrSW5kZXgrKztcbiAgICAgICAgY29vcmRpbmF0ZSA9IE1hdGguZmxvb3IocGFja0luZGV4IC8gMik7XG4gICAgICAgIGNoYW5uZWxPZmZzZXQgPSBwYWNrSW5kZXggJSAyO1xuICAgICAgfVxuXG4gICAgICBwYWNrZWQudGV4dHVyZVR5cGUgPSBUSFJFRS5SR0JBRm9ybWF0O1xuICAgICAgcGFja2VkLmRhdGEgPSBkYXRhO1xuICAgIH0gZWxzZSBpZiAoYml0c0FsbG9jYXRlZCA9PT0gMzIgJiYgY2hhbm5lbHMgPT09IDEgJiYgcGl4ZWxUeXBlID09PSAwKSB7XG4gICAgICBsZXQgZGF0YSA9IG5ldyBVaW50OEFycmF5KHRleHR1cmVTaXplICogdGV4dHVyZVNpemUgKiA0KTtcbiAgICAgIGZvciAobGV0IGkgPSBzdGFydFZveGVsOyBpIDwgc3RvcFZveGVsOyBpKyspIHtcbiAgICAgICAgZnJhbWVJbmRleCA9IH5+KGkgLyBmcmFtZURpbWVuc2lvbik7XG4gICAgICAgIGluRnJhbWVJbmRleCA9IGkgJSAoZnJhbWVEaW1lbnNpb24pO1xuXG4gICAgICAgIGxldCByYXcgPSBvZmZzZXQgKyBmcmFtZVtmcmFtZUluZGV4XS5waXhlbERhdGFbaW5GcmFtZUluZGV4XTtcbiAgICAgICAgZGF0YVs0ICogcGFja0luZGV4XSA9IHJhdyAmIDB4MDAwMDAwRkY7XG4gICAgICAgIGRhdGFbNCAqIHBhY2tJbmRleCArIDFdID0gKHJhdyA+Pj4gOCkgJiAweDAwMDAwMEZGO1xuICAgICAgICBkYXRhWzQgKiBwYWNrSW5kZXggKyAyXSA9IChyYXcgPj4+IDE2KSAmIDB4MDAwMDAwRkY7XG4gICAgICAgIGRhdGFbNCAqIHBhY2tJbmRleCArIDNdID0gKHJhdyA+Pj4gMjQpICYgMHgwMDAwMDBGRjtcblxuICAgICAgICBwYWNrSW5kZXgrKztcbiAgICAgIH1cbiAgICAgIHBhY2tlZC50ZXh0dXJlVHlwZSA9IFRIUkVFLlJHQkFGb3JtYXQ7XG4gICAgICBwYWNrZWQuZGF0YSA9IGRhdGE7XG4gICAgfSBlbHNlIGlmIChiaXRzQWxsb2NhdGVkID09PSAzMiAmJiBjaGFubmVscyA9PT0gMSAmJiBwaXhlbFR5cGUgPT09IDEpIHtcbiAgICAgIGxldCBkYXRhID0gbmV3IFVpbnQ4QXJyYXkodGV4dHVyZVNpemUgKiB0ZXh0dXJlU2l6ZSAqIDQpO1xuXG4gICAgICBmb3IgKGxldCBpID0gc3RhcnRWb3hlbDsgaSA8IHN0b3BWb3hlbDsgaSsrKSB7XG4gICAgICAgIGZyYW1lSW5kZXggPSB+fihpIC8gZnJhbWVEaW1lbnNpb24pO1xuICAgICAgICBpbkZyYW1lSW5kZXggPSBpICUgKGZyYW1lRGltZW5zaW9uKTtcblxuICAgICAgICBsZXQgcmF3ID0gb2Zmc2V0ICsgZnJhbWVbZnJhbWVJbmRleF0ucGl4ZWxEYXRhW2luRnJhbWVJbmRleF07XG4gICAgICAgIGxldCBiaXRTdHJpbmcgPSBiaW5hcnlTdHJpbmcocmF3KTtcbiAgICAgICAgbGV0IGJpdFN0cmluZ0FycmF5ID0gYml0U3RyaW5nLm1hdGNoKC8uezEsOH0vZyk7XG5cbiAgICAgICAgZGF0YVs0ICogcGFja0luZGV4XSA9IHBhcnNlSW50KGJpdFN0cmluZ0FycmF5WzBdLCAyKTtcbiAgICAgICAgZGF0YVs0ICogcGFja0luZGV4ICsgMV0gPSBwYXJzZUludChiaXRTdHJpbmdBcnJheVsxXSwgMik7XG4gICAgICAgIGRhdGFbNCAqIHBhY2tJbmRleCArIDJdID0gcGFyc2VJbnQoYml0U3RyaW5nQXJyYXlbMl0sIDIpO1xuICAgICAgICBkYXRhWzQgKiBwYWNrSW5kZXggKyAzXSA9IHBhcnNlSW50KGJpdFN0cmluZ0FycmF5WzNdLCAyKTtcblxuICAgICAgICBwYWNrSW5kZXgrKztcbiAgICAgIH1cblxuICAgICAgcGFja2VkLnRleHR1cmVUeXBlID0gVEhSRUUuUkdCQUZvcm1hdDtcbiAgICAgIHBhY2tlZC5kYXRhID0gZGF0YTtcbiAgICB9IGVsc2UgaWYgKGJpdHNBbGxvY2F0ZWQgPT09IDggJiYgY2hhbm5lbHMgPT09IDMpIHtcbiAgICAgIGxldCBkYXRhID0gbmV3IFVpbnQ4QXJyYXkodGV4dHVyZVNpemUgKiB0ZXh0dXJlU2l6ZSAqIDMpO1xuXG4gICAgICBmb3IgKGxldCBpID0gc3RhcnRWb3hlbDsgaSA8IHN0b3BWb3hlbDsgaSsrKSB7XG4gICAgICAgIGZyYW1lSW5kZXggPSB+fihpIC8gZnJhbWVEaW1lbnNpb24pO1xuICAgICAgICBpbkZyYW1lSW5kZXggPSBpICUgKGZyYW1lRGltZW5zaW9uKTtcblxuICAgICAgICBkYXRhWzMgKiBwYWNrSW5kZXhdID1cbiAgICAgICAgICBmcmFtZVtmcmFtZUluZGV4XS5waXhlbERhdGFbMyAqIGluRnJhbWVJbmRleF07XG4gICAgICAgIGRhdGFbMyAqIHBhY2tJbmRleCArIDFdID1cbiAgICAgICAgICBmcmFtZVtmcmFtZUluZGV4XS5waXhlbERhdGFbMyAqIGluRnJhbWVJbmRleCArIDFdO1xuICAgICAgICBkYXRhWzMgKiBwYWNrSW5kZXggKyAyXSA9XG4gICAgICAgICAgZnJhbWVbZnJhbWVJbmRleF0ucGl4ZWxEYXRhWzMgKiBpbkZyYW1lSW5kZXggKyAyXTtcbiAgICAgICAgcGFja0luZGV4Kys7XG4gICAgICB9XG5cbiAgICAgIHBhY2tlZC50ZXh0dXJlVHlwZSA9IFRIUkVFLlJHQkZvcm1hdDtcbiAgICAgIHBhY2tlZC5kYXRhID0gZGF0YTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGFja2VkO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgc3RhY2sgd29ybGQgY2VudGVyXG4gICAqXG4gICAqQHJldHVybiB7Kn1cbiAgICovXG4gIHdvcmxkQ2VudGVyKCkge1xuICAgIGxldCBjZW50ZXIgPSB0aGlzLl9oYWxmRGltZW5zaW9uc0lKSy5jbG9uZSgpLmFkZFNjYWxhcigtMC41KVxuICAgICAgLmFwcGx5TWF0cml4NCh0aGlzLl9pamsyTFBTKTtcbiAgICByZXR1cm4gY2VudGVyO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgc3RhY2sgd29ybGQgYm91bmRpbmcgYm94XG4gICAqIEByZXR1cm4geyp9XG4gICAqL1xuICB3b3JsZEJvdW5kaW5nQm94KCkge1xuICAgIGxldCBiYm94ID0gW1xuICAgICAgTnVtYmVyLk1BWF9WQUxVRSwgTnVtYmVyLk1JTl9WQUxVRSxcbiAgICAgIE51bWJlci5NQVhfVkFMVUUsIE51bWJlci5NSU5fVkFMVUUsXG4gICAgICBOdW1iZXIuTUFYX1ZBTFVFLCBOdW1iZXIuTUlOX1ZBTFVFLFxuICAgIF07XG5cbiAgICBjb25zdCBkaW1zID0gdGhpcy5fZGltZW5zaW9uc0lKSztcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IGRpbXMueDsgaSArPSBkaW1zLngpIHtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDw9IGRpbXMueTsgaiArPSBkaW1zLnkpIHtcbiAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPD0gZGltcy56OyBrICs9IGRpbXMueikge1xuICAgICAgICAgIGxldCB3b3JsZCA9IG5ldyBUSFJFRS5WZWN0b3IzKGksIGosIGspLmFwcGx5TWF0cml4NCh0aGlzLl9pamsyTFBTKTtcbiAgICAgICAgICBiYm94ID0gW1xuICAgICAgICAgICAgTWF0aC5taW4oYmJveFswXSwgd29ybGQueCksIE1hdGgubWF4KGJib3hbMV0sIHdvcmxkLngpLCAvLyB4IG1pbi9tYXhcbiAgICAgICAgICAgIE1hdGgubWluKGJib3hbMl0sIHdvcmxkLnkpLCBNYXRoLm1heChiYm94WzNdLCB3b3JsZC55KSxcbiAgICAgICAgICAgIE1hdGgubWluKGJib3hbNF0sIHdvcmxkLnopLCBNYXRoLm1heChiYm94WzVdLCB3b3JsZC56KSxcbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYmJveDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgQUFCQiBzaXplIGluIExQUyBzcGFjZS5cbiAgICpcbiAgICogQHJldHVybiB7Kn1cbiAgICovXG4gIEFBQkJveCgpIHtcbiAgICBsZXQgd29ybGQwID0gbmV3IFRIUkVFLlZlY3RvcjMoKS5hZGRTY2FsYXIoLTAuNSlcbiAgICAgIC5hcHBseU1hdHJpeDQodGhpcy5faWprMkxQUylcbiAgICAgIC5hcHBseU1hdHJpeDQodGhpcy5fbHBzMkFBQkIpO1xuXG4gICAgbGV0IHdvcmxkNyA9IHRoaXMuX2RpbWVuc2lvbnNJSksuY2xvbmUoKS5hZGRTY2FsYXIoLTAuNSlcbiAgICAgIC5hcHBseU1hdHJpeDQodGhpcy5faWprMkxQUylcbiAgICAgIC5hcHBseU1hdHJpeDQodGhpcy5fbHBzMkFBQkIpO1xuXG4gICAgbGV0IG1pbkJCb3ggPSBuZXcgVEhSRUUuVmVjdG9yMyhcbiAgICAgIE1hdGguYWJzKHdvcmxkMC54IC0gd29ybGQ3LngpLFxuICAgICAgTWF0aC5hYnMod29ybGQwLnkgLSB3b3JsZDcueSksXG4gICAgICBNYXRoLmFicyh3b3JsZDAueiAtIHdvcmxkNy56KVxuICAgICk7XG5cbiAgICByZXR1cm4gbWluQkJveDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgQUFCQiBjZW50ZXIgaW4gTFBTIHNwYWNlXG4gICAqL1xuICBjZW50ZXJBQUJCb3goKSB7XG4gICAgbGV0IGNlbnRlckJCb3ggPSB0aGlzLndvcmxkQ2VudGVyKCk7XG4gICAgY2VudGVyQkJveC5hcHBseU1hdHJpeDQodGhpcy5fbHBzMkFBQkIpO1xuICAgIHJldHVybiBjZW50ZXJCQm94O1xuICB9XG5cbiAgc3RhdGljIGluZGV4SW5EaW1lbnNpb25zKGluZGV4LCBkaW1lbnNpb25zKSB7XG4gICAgaWYgKGluZGV4LnggPj0gMCAmJlxuICAgICAgICAgaW5kZXgueSA+PSAwICYmXG4gICAgICAgICBpbmRleC56ID49IDAgJiZcbiAgICAgICAgIGluZGV4LnggPCBkaW1lbnNpb25zLnggJiZcbiAgICAgICAgIGluZGV4LnkgPCBkaW1lbnNpb25zLnkgJiZcbiAgICAgICAgIGluZGV4LnogPCBkaW1lbnNpb25zLnopIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIF9hcnJheVRvVmVjdG9yMyhhcnJheSwgaW5kZXgpIHtcbiAgICByZXR1cm4gbmV3IFRIUkVFLlZlY3RvcjMoXG4gICAgICBhcnJheVtpbmRleF0sXG4gICAgICBhcnJheVtpbmRleCArIDFdLFxuICAgICAgYXJyYXlbaW5kZXggKyAyXVxuICAgICAgKTtcbiAgfVxuXG4gIF9vcmRlckZyYW1lT25EaW1lbnNpb25JbmRpY2VzQXJyYXlTb3J0KGEsIGIpIHtcbiAgICBpZiAoJ2RpbWVuc2lvbkluZGV4VmFsdWVzJyBpbiBhICYmIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhLmRpbWVuc2lvbkluZGV4VmFsdWVzKSA9PT0gJ1tvYmplY3QgQXJyYXldJyAmJiAnZGltZW5zaW9uSW5kZXhWYWx1ZXMnIGluIGIgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGIuZGltZW5zaW9uSW5kZXhWYWx1ZXMpID09PSAnW29iamVjdCBBcnJheV0nKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGEuZGltZW5zaW9uSW5kZXhWYWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHBhcnNlSW50KGEuZGltZW5zaW9uSW5kZXhWYWx1ZXNbaV0sIDEwKSA+IHBhcnNlSW50KGIuZGltZW5zaW9uSW5kZXhWYWx1ZXNbaV0sIDEwKSkge1xuICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJzZUludChhLmRpbWVuc2lvbkluZGV4VmFsdWVzW2ldLCAxMCkgPCBwYXJzZUludChiLmRpbWVuc2lvbkluZGV4VmFsdWVzW2ldLCAxMCkpIHtcbiAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgd2luZG93LmNvbnNvbGUubG9nKCdPbmUgb2YgdGhlIGZyYW1lcyBkb2VzblxcJ3QgaGF2ZSBhIGRpbWVuc2lvbkluZGV4VmFsdWVzIGFycmF5LicpO1xuICAgICAgd2luZG93LmNvbnNvbGUubG9nKGEpO1xuICAgICAgd2luZG93LmNvbnNvbGUubG9nKGIpO1xuICAgIH1cblxuICAgIHJldHVybiAwO1xuICB9XG5cbiAgX2NvbXB1dGVEaXN0YW5jZUFycmF5TWFwKG5vcm1hbCwgZnJhbWUpIHtcbiAgICBmcmFtZS5kaXN0ID0gZnJhbWUuaW1hZ2VQb3NpdGlvblswXSAqIG5vcm1hbC54ICtcbiAgICAgIGZyYW1lLmltYWdlUG9zaXRpb25bMV0gKiBub3JtYWwueSArXG4gICAgICBmcmFtZS5pbWFnZVBvc2l0aW9uWzJdICogbm9ybWFsLno7XG4gICAgcmV0dXJuIGZyYW1lO1xuICB9XG5cbiAgX3NvcnREaXN0YW5jZUFycmF5U29ydChhLCBiKSB7XG4gICAgcmV0dXJuIGEuZGlzdCAtIGIuZGlzdDtcbiAgfVxuICBfc29ydEluc3RhbmNlTnVtYmVyQXJyYXlTb3J0KGEsIGIpIHtcbiAgICByZXR1cm4gYS5pbnN0YW5jZU51bWJlciAtIGIuaW5zdGFuY2VOdW1iZXI7XG4gIH1cbiAgX3NvcnRTb3BJbnN0YW5jZVVJREFycmF5U29ydChhLCBiKSB7XG4gICAgcmV0dXJuIGEuc29wSW5zdGFuY2VVSUQgLSBiLnNvcEluc3RhbmNlVUlEO1xuICB9XG5cbiAgc2V0IG51bWJlck9mQ2hhbm5lbHMobnVtYmVyT2ZDaGFubmVscykge1xuICAgIHRoaXMuX251bWJlck9mQ2hhbm5lbHMgPSBudW1iZXJPZkNoYW5uZWxzO1xuICB9XG5cbiAgZ2V0IG51bWJlck9mQ2hhbm5lbHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX251bWJlck9mQ2hhbm5lbHM7XG4gIH1cblxuICBzZXQgZnJhbWUoZnJhbWUpIHtcbiAgICB0aGlzLl9mcmFtZSA9IGZyYW1lO1xuICB9XG5cbiAgZ2V0IGZyYW1lKCkge1xuICAgIHJldHVybiB0aGlzLl9mcmFtZTtcbiAgfVxuXG4gIHNldCBwcmVwYXJlZChwcmVwYXJlZCkge1xuICAgIHRoaXMuX3ByZXBhcmVkID0gcHJlcGFyZWQ7XG4gIH1cblxuICBnZXQgcHJlcGFyZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ByZXBhcmVkO1xuICB9XG5cbiAgc2V0IHBhY2tlZChwYWNrZWQpIHtcbiAgICB0aGlzLl9wYWNrZWQgPSBwYWNrZWQ7XG4gIH1cblxuICBnZXQgcGFja2VkKCkge1xuICAgIHJldHVybiB0aGlzLl9wYWNrZWQ7XG4gIH1cblxuICBzZXQgcGFja2VkUGVyUGl4ZWwocGFja2VkUGVyUGl4ZWwpIHtcbiAgICB0aGlzLl9wYWNrZWRQZXJQaXhlbCA9IHBhY2tlZFBlclBpeGVsO1xuICB9XG5cbiAgZ2V0IHBhY2tlZFBlclBpeGVsKCkge1xuICAgIHJldHVybiB0aGlzLl9wYWNrZWRQZXJQaXhlbDtcbiAgfVxuXG4gIHNldCBkaW1lbnNpb25zSUpLKGRpbWVuc2lvbnNJSkspIHtcbiAgICB0aGlzLl9kaW1lbnNpb25zSUpLID0gZGltZW5zaW9uc0lKSztcbiAgfVxuXG4gIGdldCBkaW1lbnNpb25zSUpLKCkge1xuICAgIHJldHVybiB0aGlzLl9kaW1lbnNpb25zSUpLO1xuICB9XG5cbiAgc2V0IGhhbGZEaW1lbnNpb25zSUpLKGhhbGZEaW1lbnNpb25zSUpLKSB7XG4gICAgdGhpcy5faGFsZkRpbWVuc2lvbnNJSksgPSBoYWxmRGltZW5zaW9uc0lKSztcbiAgfVxuXG4gIGdldCBoYWxmRGltZW5zaW9uc0lKSygpIHtcbiAgICByZXR1cm4gdGhpcy5faGFsZkRpbWVuc2lvbnNJSks7XG4gIH1cblxuICBzZXQgcmVnTWF0cml4KHJlZ01hdHJpeCkge1xuICAgIHRoaXMuX3JlZ01hdHJpeCA9IHJlZ01hdHJpeDtcbiAgfVxuXG4gIGdldCByZWdNYXRyaXgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlZ01hdHJpeDtcbiAgfVxuXG4gIHNldCBpamsyTFBTKGlqazJMUFMpIHtcbiAgICB0aGlzLl9pamsyTFBTID0gaWprMkxQUztcbiAgfVxuXG4gIGdldCBpamsyTFBTKCkge1xuICAgIHJldHVybiB0aGlzLl9pamsyTFBTO1xuICB9XG5cbiAgc2V0IGxwczJJSksobHBzMklKSykge1xuICAgIHRoaXMuX2xwczJJSksgPSBscHMySUpLO1xuICB9XG5cbiAgZ2V0IGxwczJJSksoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2xwczJJSks7XG4gIH1cblxuICBzZXQgbHBzMkFBQkIobHBzMkFBQkIpIHtcbiAgICB0aGlzLl9scHMyQUFCQiA9IGxwczJBQUJCO1xuICB9XG5cbiAgZ2V0IGxwczJBQUJCKCkge1xuICAgIHJldHVybiB0aGlzLl9scHMyQUFCQjtcbiAgfVxuXG4gIHNldCB0ZXh0dXJlU2l6ZSh0ZXh0dXJlU2l6ZSkge1xuICAgIHRoaXMuX3RleHR1cmVTaXplID0gdGV4dHVyZVNpemU7XG4gIH1cblxuICBnZXQgdGV4dHVyZVNpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RleHR1cmVTaXplO1xuICB9XG5cbiAgc2V0IHRleHR1cmVUeXBlKHRleHR1cmVUeXBlKSB7XG4gICAgdGhpcy5fdGV4dHVyZVR5cGUgPSB0ZXh0dXJlVHlwZTtcbiAgfVxuXG4gIGdldCB0ZXh0dXJlVHlwZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdGV4dHVyZVR5cGU7XG4gIH1cblxuICBzZXQgYml0c0FsbG9jYXRlZChiaXRzQWxsb2NhdGVkKSB7XG4gICAgdGhpcy5fYml0c0FsbG9jYXRlZCA9IGJpdHNBbGxvY2F0ZWQ7XG4gIH1cblxuICBnZXQgYml0c0FsbG9jYXRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fYml0c0FsbG9jYXRlZDtcbiAgfVxuXG4gIHNldCByYXdEYXRhKHJhd0RhdGEpIHtcbiAgICB0aGlzLl9yYXdEYXRhID0gcmF3RGF0YTtcbiAgfVxuXG4gIGdldCByYXdEYXRhKCkge1xuICAgIHJldHVybiB0aGlzLl9yYXdEYXRhO1xuICB9XG5cbiAgZ2V0IHdpbmRvd1dpZHRoKCkge1xuICAgIHJldHVybiB0aGlzLl93aW5kb3dXaWR0aDtcbiAgfVxuXG4gIHNldCB3aW5kb3dXaWR0aCh3aW5kb3dXaWR0aCkge1xuICAgIHRoaXMuX3dpbmRvd1dpZHRoID0gd2luZG93V2lkdGg7XG4gIH1cblxuICBnZXQgd2luZG93Q2VudGVyKCkge1xuICAgIHJldHVybiB0aGlzLl93aW5kb3dDZW50ZXI7XG4gIH1cblxuICBzZXQgd2luZG93Q2VudGVyKHdpbmRvd0NlbnRlcikge1xuICAgIHRoaXMuX3dpbmRvd0NlbnRlciA9IHdpbmRvd0NlbnRlcjtcbiAgfVxuXG4gIGdldCByZXNjYWxlU2xvcGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Jlc2NhbGVTbG9wZTtcbiAgfVxuXG4gIHNldCByZXNjYWxlU2xvcGUocmVzY2FsZVNsb3BlKSB7XG4gICAgdGhpcy5fcmVzY2FsZVNsb3BlID0gcmVzY2FsZVNsb3BlO1xuICB9XG5cbiAgZ2V0IHJlc2NhbGVJbnRlcmNlcHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Jlc2NhbGVJbnRlcmNlcHQ7XG4gIH1cblxuICBzZXQgcmVzY2FsZUludGVyY2VwdChyZXNjYWxlSW50ZXJjZXB0KSB7XG4gICAgdGhpcy5fcmVzY2FsZUludGVyY2VwdCA9IHJlc2NhbGVJbnRlcmNlcHQ7XG4gIH1cblxuICBnZXQgeENvc2luZSgpIHtcbiAgICByZXR1cm4gdGhpcy5feENvc2luZTtcbiAgfVxuXG4gIHNldCB4Q29zaW5lKHhDb3NpbmUpIHtcbiAgICB0aGlzLl94Q29zaW5lID0geENvc2luZTtcbiAgfVxuXG4gIGdldCB5Q29zaW5lKCkge1xuICAgIHJldHVybiB0aGlzLl95Q29zaW5lO1xuICB9XG5cbiAgc2V0IHlDb3NpbmUoeUNvc2luZSkge1xuICAgIHRoaXMuX3lDb3NpbmUgPSB5Q29zaW5lO1xuICB9XG5cbiAgZ2V0IHpDb3NpbmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3pDb3NpbmU7XG4gIH1cblxuICBzZXQgekNvc2luZSh6Q29zaW5lKSB7XG4gICAgdGhpcy5fekNvc2luZSA9IHpDb3NpbmU7XG4gIH1cblxuICBnZXQgbWluTWF4KCkge1xuICAgIHJldHVybiB0aGlzLl9taW5NYXg7XG4gIH1cblxuICBzZXQgbWluTWF4KG1pbk1heCkge1xuICAgIHRoaXMuX21pbk1heCA9IG1pbk1heDtcbiAgfVxuXG4gIGdldCBzdGFja0lEKCkge1xuICAgIHJldHVybiB0aGlzLl9zdGFja0lEO1xuICB9XG5cbiAgc2V0IHN0YWNrSUQoc3RhY2tJRCkge1xuICAgIHRoaXMuX3N0YWNrSUQgPSBzdGFja0lEO1xuICB9XG5cbiAgZ2V0IHBpeGVsVHlwZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fcGl4ZWxUeXBlO1xuICB9XG5cbiAgc2V0IHBpeGVsVHlwZShwaXhlbFR5cGUpIHtcbiAgICB0aGlzLl9waXhlbFR5cGUgPSBwaXhlbFR5cGU7XG4gIH1cblxuICBnZXQgcGl4ZWxSZXByZXNlbnRhdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fcGl4ZWxSZXByZXNlbnRhdGlvbjtcbiAgfVxuXG4gIHNldCBwaXhlbFJlcHJlc2VudGF0aW9uKHBpeGVsUmVwcmVzZW50YXRpb24pIHtcbiAgICB0aGlzLl9waXhlbFJlcHJlc2VudGF0aW9uID0gcGl4ZWxSZXByZXNlbnRhdGlvbjtcbiAgfVxuXG4gIHNldCBpbnZlcnQoaW52ZXJ0KSB7XG4gICAgdGhpcy5faW52ZXJ0ID0gaW52ZXJ0O1xuICB9XG5cbiAgZ2V0IGludmVydCgpIHtcbiAgICByZXR1cm4gdGhpcy5faW52ZXJ0O1xuICB9XG5cbiAgc2V0IG1vZGFsaXR5KG1vZGFsaXR5KSB7XG4gICAgdGhpcy5fbW9kYWxpdHkgPSBtb2RhbGl0eTtcbiAgfVxuXG4gIGdldCBtb2RhbGl0eSgpIHtcbiAgICByZXR1cm4gdGhpcy5fbW9kYWxpdHk7XG4gIH1cblxuICBnZXQgcmlnaHRIYW5kZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JpZ2h0SGFuZGVkO1xuICB9XG5cbiAgc2V0IHJpZ2h0SGFuZGVkKHJpZ2h0SGFuZGVkKSB7XG4gICAgdGhpcy5fcmlnaHRIYW5kZWQgPSByaWdodEhhbmRlZDtcbiAgfVxuXG4gIGdldCBzcGFjaW5nQmV0d2VlblNsaWNlcygpIHtcbiAgICByZXR1cm4gdGhpcy5fc3BhY2luZ0JldHdlZW5TbGljZXM7XG4gIH1cblxuICBzZXQgc3BhY2luZ0JldHdlZW5TbGljZXMoc3BhY2luZ0JldHdlZW5TbGljZXMpIHtcbiAgICB0aGlzLl9zcGFjaW5nQmV0d2VlblNsaWNlcyA9IHNwYWNpbmdCZXR3ZWVuU2xpY2VzO1xuICB9XG5cbiAgc2V0IHNlZ21lbnRhdGlvblNlZ21lbnRzKHNlZ21lbnRhdGlvblNlZ21lbnRzKSB7XG4gICAgdGhpcy5fc2VnbWVudGF0aW9uU2VnbWVudHMgPSBzZWdtZW50YXRpb25TZWdtZW50cztcbiAgfVxuXG4gIGdldCBzZWdtZW50YXRpb25TZWdtZW50cygpIHtcbiAgICByZXR1cm4gdGhpcy5fc2VnbWVudGF0aW9uU2VnbWVudHM7XG4gIH1cblxuICBzZXQgc2VnbWVudGF0aW9uVHlwZShzZWdtZW50YXRpb25UeXBlKSB7XG4gICAgdGhpcy5fc2VnbWVudGF0aW9uVHlwZSA9IHNlZ21lbnRhdGlvblR5cGU7XG4gIH1cblxuICBnZXQgc2VnbWVudGF0aW9uVHlwZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fc2VnbWVudGF0aW9uVHlwZTtcbiAgfVxuXG4gIHNldCBzZWdtZW50YXRpb25MVVQoc2VnbWVudGF0aW9uTFVUKSB7XG4gICAgdGhpcy5fc2VnbWVudGF0aW9uTFVUID0gc2VnbWVudGF0aW9uTFVUO1xuICB9XG5cbiAgZ2V0IHNlZ21lbnRhdGlvbkxVVCgpIHtcbiAgICByZXR1cm4gdGhpcy5fc2VnbWVudGF0aW9uTFVUO1xuICB9XG5cbiAgc2V0IHNlZ21lbnRhdGlvbkxVVE8oc2VnbWVudGF0aW9uTFVUTykge1xuICAgIHRoaXMuX3NlZ21lbnRhdGlvbkxVVE8gPSBzZWdtZW50YXRpb25MVVRPO1xuICB9XG5cbiAgZ2V0IHNlZ21lbnRhdGlvbkxVVE8oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NlZ21lbnRhdGlvbkxVVE87XG4gIH1cblxuICAvLyBERVBSRUNBVEVEIEZVTkNUSU9OXG5cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIGZvciBjb3JlLnV0aWxzLnZhbHVlXG4gICAqXG4gICAqIEdldCB2b3hlbCB2YWx1ZS5cbiAgICpcbiAgICogQHBhcmFtIHsqfSBzdGFja1xuICAgKiBAcGFyYW0geyp9IGNvb3JkaW5hdGVcbiAgICpcbiAgICogQHJldHVybiB7Kn1cbiAgICovXG4gIHN0YXRpYyB2YWx1ZShzdGFjaywgY29vcmRpbmF0ZSkge1xuICAgIGNvbnNvbGUud2FybihcbiAgICAgIGBtb2RlbHMuc3RhY2sudmFsdWUgaXMgZGVwcmVjYXRlZC5cbiAgICAgICBQbGVhc2UgdXNlIGNvcmUudXRpbHMudmFsdWUgaW5zdGVhZC5gKTtcbiAgICByZXR1cm4gQ29yZVV0aWxzLnZhbHVlKHN0YWNrLCBjb29yZGluYXRlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCBmb3IgY29yZS51dGlscy5yZXNjYWxlU2xvcGVJbnRlcmNlcHRcbiAgICpcbiAgICogQXBwbHkgc2xvcGUvaW50ZXJjZXB0IHRvIGEgdmFsdWUuXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICogQHBhcmFtIHsqfSBzbG9wZVxuICAgKiBAcGFyYW0geyp9IGludGVyY2VwdFxuICAgKlxuICAgKiBAcmV0dXJuIHsqfVxuICAgKi9cbiAgc3RhdGljIHZhbHVlUmVzY2FsZVNsb3BlSW50ZXJjZXB0KHZhbHVlLCBzbG9wZSwgaW50ZXJjZXB0KSB7XG4gICAgY29uc29sZS53YXJuKFxuICAgICAgYG1vZGVscy5zdGFjay52YWx1ZVJlc2NhbGVTbG9wZUludGVyY2VwdCBpcyBkZXByZWNhdGVkLlxuICAgICAgIFBsZWFzZSB1c2UgY29yZS51dGlscy5yZXNjYWxlU2xvcGVJbnRlcmNlcHQgaW5zdGVhZC5gKTtcbiAgICByZXR1cm4gQ29yZVV0aWxzLnJlc2NhbGVTbG9wZUludGVyY2VwdChcbiAgICAgIHZhbHVlLCBzbG9wZSwgaW50ZXJjZXB0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCBmb3IgY29yZS51dGlscy53b3JsZFRvRGF0YVxuICAgKlxuICAgKiBUcmFuc2Zvcm0gY29vcmRpbmF0ZXMgZnJvbSB3b3JsZCBjb29yZGluYXRlIHRvIGRhdGFcbiAgICpcbiAgICogQHBhcmFtIHsqfSBzdGFja1xuICAgKiBAcGFyYW0geyp9IHdvcmxkQ29vcmRpbmF0ZXNcbiAgICpcbiAgICogQHJldHVybiB7Kn1cbiAgICovXG4gIHN0YXRpYyB3b3JsZFRvRGF0YShzdGFjaywgd29ybGRDb29yZGluYXRlcykge1xuICAgIGNvbnNvbGUud2FybihcbiAgICAgIGBtb2RlbHMuc3RhY2sud29ybGRUb0RhdGEgaXMgZGVwcmVjYXRlZC5cbiAgICAgICBQbGVhc2UgdXNlIGNvcmUudXRpbHMud29ybGRUb0RhdGEgaW5zdGVhZC5gKTtcblxuICAgIHJldHVybiBDb3JlVXRpbHMud29ybGRUb0RhdGEoc3RhY2suX2xwczJJSkssIHdvcmxkQ29vcmRpbmF0ZXMpO1xuICB9XG59XG5cbi8vIFNsaWNlciB3YXkgdG8gaGFuZGxlIGltYWdlc1xuLy8gc2hvdWxkIGZvbGxvdyBpdC4uLlxuIC8vIDg5NyAgIGlmICggKHRoaXMtPkluZGV4U2VyaWVzSW5zdGFuY2VVSURzW2tdICE9IGlkeFNlcmllc0luc3RhbmNlVUlEICYmIHRoaXMtPkluZGV4U2VyaWVzSW5zdGFuY2VVSURzW2tdID49IDAgJiYgaWR4U2VyaWVzSW5zdGFuY2VVSUQgPj0gMCkgfHxcbiAvLyA4OTggICAgICAgICh0aGlzLT5JbmRleENvbnRlbnRUaW1lW2tdICE9IGlkeENvbnRlbnRUaW1lICYmIHRoaXMtPkluZGV4Q29udGVudFRpbWVba10gPj0gMCAmJiBpZHhDb250ZW50VGltZSA+PSAwKSB8fFxuIC8vIDg5OSAgICAgICAgKHRoaXMtPkluZGV4VHJpZ2dlclRpbWVba10gIT0gaWR4VHJpZ2dlclRpbWUgJiYgdGhpcy0+SW5kZXhUcmlnZ2VyVGltZVtrXSA+PSAwICYmIGlkeFRyaWdnZXJUaW1lID49IDApIHx8XG4gLy8gOTAwICAgICAgICAodGhpcy0+SW5kZXhFY2hvTnVtYmVyc1trXSAhPSBpZHhFY2hvTnVtYmVycyAmJiB0aGlzLT5JbmRleEVjaG9OdW1iZXJzW2tdID49IDAgJiYgaWR4RWNob051bWJlcnMgPj0gMCkgfHxcbiAvLyA5MDEgICAgICAgICh0aGlzLT5JbmRleERpZmZ1c2lvbkdyYWRpZW50T3JpZW50YXRpb25ba10gIT0gaWR4RGlmZnVzaW9uR3JhZGllbnRPcmllbnRhdGlvbiAgJiYgdGhpcy0+SW5kZXhEaWZmdXNpb25HcmFkaWVudE9yaWVudGF0aW9uW2tdID49IDAgJiYgaWR4RGlmZnVzaW9uR3JhZGllbnRPcmllbnRhdGlvbiA+PSAwKSB8fFxuIC8vIDkwMiAgICAgICAgKHRoaXMtPkluZGV4U2xpY2VMb2NhdGlvbltrXSAhPSBpZHhTbGljZUxvY2F0aW9uICYmIHRoaXMtPkluZGV4U2xpY2VMb2NhdGlvbltrXSA+PSAwICYmIGlkeFNsaWNlTG9jYXRpb24gPj0gMCkgfHxcbiAvLyA5MDMgICAgICAgICh0aGlzLT5JbmRleEltYWdlT3JpZW50YXRpb25QYXRpZW50W2tdICE9IGlkeEltYWdlT3JpZW50YXRpb25QYXRpZW50ICYmIHRoaXMtPkluZGV4SW1hZ2VPcmllbnRhdGlvblBhdGllbnRba10gPj0gMCAmJiBpZHhJbWFnZU9yaWVudGF0aW9uUGF0aWVudCA+PSAwKSApXG4gLy8gOTA0ICAgICB7XG4gLy8gOTA1ICAgICAgIGNvbnRpbnVlO1xuIC8vIDkwNiAgICAgfVxuIiwiLyoqXG4gKiBAbW9kdWxlIG1vZGVscy92b3hlbFxuICovXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1vZGVsc1ZveGVsIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5faWQgPSAtMTtcbiAgICB0aGlzLl93b3JsZENvb3JkaW5hdGVzID0gbnVsbDtcbiAgICB0aGlzLl9kYXRhQ29vcmRpbmF0ZXMgPSBudWxsO1xuICAgIHRoaXMuX3NjcmVlbkNvb3JkaW5hdGVzID0gbnVsbDtcbiAgICB0aGlzLl92YWx1ZSA9IG51bGw7XG4gIH1cblxuICBzZXQgd29ybGRDb29yZGluYXRlcyh3b3JsZENvb3JkaW5hdGVzKSB7XG4gICAgdGhpcy5fd29ybGRDb29yZGluYXRlcyA9IHdvcmxkQ29vcmRpbmF0ZXM7XG4gIH1cblxuICBnZXQgd29ybGRDb29yZGluYXRlcygpIHtcbiAgICByZXR1cm4gdGhpcy5fd29ybGRDb29yZGluYXRlcztcbiAgfVxuXG4gIHNldCBkYXRhQ29vcmRpbmF0ZXMoZGF0YUNvb3JkaW5hdGVzKSB7XG4gICAgdGhpcy5fZGF0YUNvb3JkaW5hdGVzID0gZGF0YUNvb3JkaW5hdGVzO1xuICB9XG5cbiAgZ2V0IGRhdGFDb29yZGluYXRlcygpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YUNvb3JkaW5hdGVzO1xuICB9XG5cbiAgc2V0IHNjcmVlbkNvb3JkaW5hdGVzKHNjcmVlbkNvb3JkaW5hdGVzKSB7XG4gICAgdGhpcy5fc2NyZWVuQ29vcmRpbmF0ZXMgPSBzY3JlZW5Db29yZGluYXRlcztcbiAgfVxuXG4gIGdldCBzY3JlZW5Db29yZGluYXRlcygpIHtcbiAgICByZXR1cm4gdGhpcy5fc2NyZWVuQ29vcmRpbmF0ZXM7XG4gIH1cblxuICBzZXQgdmFsdWUodmFsdWUpIHtcbiAgICB0aGlzLl92YWx1ZSA9IHZhbHVlO1xuICB9XG5cbiAgZ2V0IHZhbHVlKCkge1xuICAgIHJldHVybiB0aGlzLl92YWx1ZTtcbiAgfVxuXG4gIHNldCBpZChpZCkge1xuICAgIHRoaXMuX2lkID0gaWQ7XG4gIH1cblxuICBnZXQgaWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lkO1xuICB9XG59XG4iLCIvLyBmdHA6Ly9tZWRpY2FsLm5lbWEub3JnL01FRElDQUwvRGljb20vMjAxNGMvb3V0cHV0L2NodG1sL3BhcnQwNS9zZWN0XzYuMi5odG1sL1xuXG4vLyBTbGljZXIgd2F5IHRvIGhhbmRsZSBpbWFnZXNcbi8vIHNob3VsZCBmb2xsb3cgaXQuLi5cbi8vIDg5NyAgIGlmICggKHRoaXMtPkluZGV4U2VyaWVzSW5zdGFuY2VVSURzW2tdICE9IGlkeFNlcmllc0luc3RhbmNlVUlEICYmIHRoaXMtPkluZGV4U2VyaWVzSW5zdGFuY2VVSURzW2tdID49IDAgJiYgaWR4U2VyaWVzSW5zdGFuY2VVSUQgPj0gMCkgfHxcbi8vIDg5OCAgICAgICAgKHRoaXMtPkluZGV4Q29udGVudFRpbWVba10gIT0gaWR4Q29udGVudFRpbWUgJiYgdGhpcy0+SW5kZXhDb250ZW50VGltZVtrXSA+PSAwICYmIGlkeENvbnRlbnRUaW1lID49IDApIHx8XG4vLyA4OTkgICAgICAgICh0aGlzLT5JbmRleFRyaWdnZXJUaW1lW2tdICE9IGlkeFRyaWdnZXJUaW1lICYmIHRoaXMtPkluZGV4VHJpZ2dlclRpbWVba10gPj0gMCAmJiBpZHhUcmlnZ2VyVGltZSA+PSAwKSB8fFxuLy8gOTAwICAgICAgICAodGhpcy0+SW5kZXhFY2hvTnVtYmVyc1trXSAhPSBpZHhFY2hvTnVtYmVycyAmJiB0aGlzLT5JbmRleEVjaG9OdW1iZXJzW2tdID49IDAgJiYgaWR4RWNob051bWJlcnMgPj0gMCkgfHxcbi8vIDkwMSAgICAgICAgKHRoaXMtPkluZGV4RGlmZnVzaW9uR3JhZGllbnRPcmllbnRhdGlvbltrXSAhPSBpZHhEaWZmdXNpb25HcmFkaWVudE9yaWVudGF0aW9uICAmJiB0aGlzLT5JbmRleERpZmZ1c2lvbkdyYWRpZW50T3JpZW50YXRpb25ba10gPj0gMCAmJiBpZHhEaWZmdXNpb25HcmFkaWVudE9yaWVudGF0aW9uID49IDApIHx8XG4vLyA5MDIgICAgICAgICh0aGlzLT5JbmRleFNsaWNlTG9jYXRpb25ba10gIT0gaWR4U2xpY2VMb2NhdGlvbiAmJiB0aGlzLT5JbmRleFNsaWNlTG9jYXRpb25ba10gPj0gMCAmJiBpZHhTbGljZUxvY2F0aW9uID49IDApIHx8XG4vLyA5MDMgICAgICAgICh0aGlzLT5JbmRleEltYWdlT3JpZW50YXRpb25QYXRpZW50W2tdICE9IGlkeEltYWdlT3JpZW50YXRpb25QYXRpZW50ICYmIHRoaXMtPkluZGV4SW1hZ2VPcmllbnRhdGlvblBhdGllbnRba10gPj0gMCAmJiBpZHhJbWFnZU9yaWVudGF0aW9uUGF0aWVudCA+PSAwKSApXG4vLyA5MDQgICAgIHtcbi8vIDkwNSAgICAgICBjb250aW51ZTtcbi8vIDkwNiAgICAgfVxuXG4vKiogKiBJbXBvcnRzICoqKi9cbmltcG9ydCBQYXJzZXJzVm9sdW1lIGZyb20gJy4vcGFyc2Vycy52b2x1bWUnO1xuXG5sZXQgRGljb21QYXJzZXIgPSByZXF1aXJlKCdkaWNvbS1wYXJzZXInKTtcbmxldCBKcGVnID0gcmVxdWlyZSgnanBlZy1sb3NzbGVzcy1kZWNvZGVyLWpzJyk7XG5sZXQgSnBlZ0Jhc2VsaW5lID0gcmVxdWlyZSgnLi4vLi4vZXh0ZXJuYWwvc2NyaXB0cy9qcGVnJyk7XG5sZXQgSnB4ID0gcmVxdWlyZSgnLi4vLi4vZXh0ZXJuYWwvc2NyaXB0cy9qcHgnKTtcblxuLyoqXG4gKiBEaWNvbSBwYXJzZXIgaXMgYSBjb21iaW5hdGlvbiBvZiB1dGlsaXRpZXMgdG8gZ2V0IGEgVkpTIGltYWdlIGZyb20gZGljb20gZmlsZXMuXG4gKnNjcmlwdHNcbiAqIFJlbGllcyBvbiBkY21qcywganF1ZXJ5LCBIVE1MNSBmZXRjaCBBUEksIEhUTUw1IHByb21pc2UgQVBJLlxuICpcbiAqIEBtb2R1bGUgcGFyc2Vycy9kaWNvbVxuICpcbiAqIEBwYXJhbSBhcnJheUJ1ZmZlciB7YXJyYXlidWZmZXJ9IC0gTGlzdCBvZiBmaWxlcyB0byBiZSBwYXJzZWQuIEl0IGlzIHVybHMgZnJvbSB3aGljaFxuICogVkpTLnBhcnNlcnMuZGljb20gY2FuIHB1bGwgdGhlIGRhdGEgZnJvbS5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUGFyc2Vyc0RpY29tIGV4dGVuZHMgUGFyc2Vyc1ZvbHVtZSB7XG5cbiAgY29uc3RydWN0b3IoZGF0YSwgaWQpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5faWQgPSBpZDtcblxuICAgIHRoaXMuX2FycmF5QnVmZmVyID0gZGF0YS5idWZmZXI7XG5cbiAgICBsZXQgYnl0ZUFycmF5ID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5fYXJyYXlCdWZmZXIpO1xuXG4gICAgLy8gY2F0Y2ggZXJyb3JcbiAgICAvLyB0aHJvdyBlcnJvciBpZiBhbnkhXG4gICAgdGhpcy5fZGF0YVNldCA9IG51bGw7XG5cbiAgICB0cnkge1xuICAgICAgdGhpcy5fZGF0YVNldCA9IERpY29tUGFyc2VyLnBhcnNlRGljb20oYnl0ZUFycmF5KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB3aW5kb3cuY29uc29sZS5sb2coZSk7XG4gICAgICB0aHJvdyAncGFyc2Vycy5kaWNvbSBjb3VsZCBub3QgcGFyc2UgdGhlIGZpbGUnO1xuICAgIH1cbiAgfVxuXG4gIC8vIGltYWdlL2ZyYW1lIHNwZWNpZmljXG4gIHNlcmllc0luc3RhbmNlVUlEKCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRhU2V0LnN0cmluZygneDAwMjAwMDBlJyk7XG4gIH1cblxuICBzdHVkeUluc3RhbmNlVUlEKCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRhU2V0LnN0cmluZygneDAwMjAwMDBkJyk7XG4gIH1cblxuICBtb2RhbGl0eSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YVNldC5zdHJpbmcoJ3gwMDA4MDA2MCcpO1xuICB9XG5cbiAgc2VnbWVudGF0aW9uVHlwZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YVNldC5zdHJpbmcoJ3gwMDYyMDAwMScpO1xuICB9XG5cbiAgc2VnbWVudGF0aW9uU2VnbWVudHMoKSB7XG4gICAgbGV0IHNlZ21lbnRhdGlvblNlZ21lbnRzID0gW107XG4gICAgbGV0IHNlZ21lbnRTZXF1ZW5jZSA9IHRoaXMuX2RhdGFTZXQuZWxlbWVudHMueDAwNjIwMDAyO1xuXG4gICAgaWYgKCFzZWdtZW50U2VxdWVuY2UpIHtcbiAgICAgIHJldHVybiBzZWdtZW50YXRpb25TZWdtZW50cztcbiAgICB9XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaTwgc2VnbWVudFNlcXVlbmNlLml0ZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgcmVjb21tZW5kZWREaXNwbGF5Q0lFTGFiID1cbiAgICAgICAgdGhpcy5fcmVjb21tZW5kZWREaXNwbGF5Q0lFTGFiKHNlZ21lbnRTZXF1ZW5jZS5pdGVtc1tpXSk7XG4gICAgICBsZXQgc2VnbWVudGF0aW9uQ29kZSA9IHRoaXMuX3NlZ21lbnRhdGlvbkNvZGUoc2VnbWVudFNlcXVlbmNlLml0ZW1zW2ldKTtcbiAgICAgIGxldCBzZWdtZW50TnVtYmVyID0gc2VnbWVudFNlcXVlbmNlLml0ZW1zW2ldLmRhdGFTZXQudWludDE2KCd4MDA2MjAwMDQnKTtcbiAgICAgIGxldCBzZWdtZW50TGFiZWwgPSBzZWdtZW50U2VxdWVuY2UuaXRlbXNbaV0uZGF0YVNldC5zdHJpbmcoJ3gwMDYyMDAwNScpO1xuICAgICAgbGV0IHNlZ21lbnRBbGdvcml0aG1UeXBlID1cbiAgICAgICAgc2VnbWVudFNlcXVlbmNlLml0ZW1zW2ldLmRhdGFTZXQuc3RyaW5nKCd4MDA2MjAwMDgnKTtcblxuICAgICAgc2VnbWVudGF0aW9uU2VnbWVudHMucHVzaCh7XG4gICAgICAgIHJlY29tbWVuZGVkRGlzcGxheUNJRUxhYixcbiAgICAgICAgc2VnbWVudGF0aW9uQ29kZURlc2lnbmF0b3I6XG4gICAgICAgICAgc2VnbWVudGF0aW9uQ29kZVsnc2VnbWVudGF0aW9uQ29kZURlc2lnbmF0b3InXSxcbiAgICAgICAgc2VnbWVudGF0aW9uQ29kZVZhbHVlOiBzZWdtZW50YXRpb25Db2RlWydzZWdtZW50YXRpb25Db2RlVmFsdWUnXSxcbiAgICAgICAgc2VnbWVudGF0aW9uQ29kZU1lYW5pbmc6IHNlZ21lbnRhdGlvbkNvZGVbJ3NlZ21lbnRhdGlvbkNvZGVNZWFuaW5nJ10sXG4gICAgICAgIHNlZ21lbnROdW1iZXIsXG4gICAgICAgIHNlZ21lbnRMYWJlbCxcbiAgICAgICAgc2VnbWVudEFsZ29yaXRobVR5cGUsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2VnbWVudGF0aW9uU2VnbWVudHM7XG4gIH1cblxuICBfc2VnbWVudGF0aW9uQ29kZShzZWdtZW50KSB7XG4gICAgbGV0IHNlZ21lbnRhdGlvbkNvZGVEZXNpZ25hdG9yID0gJ3Vua25vd24nO1xuICAgIGxldCBzZWdtZW50YXRpb25Db2RlVmFsdWUgPSAndW5rbm93bic7XG4gICAgbGV0IHNlZ21lbnRhdGlvbkNvZGVNZWFuaW5nID0gJ3Vua25vd24nO1xuICAgIGxldCBlbGVtZW50ID0gc2VnbWVudC5kYXRhU2V0LmVsZW1lbnRzLngwMDA4MjIxODtcblxuICAgIGlmIChlbGVtZW50ICYmIGVsZW1lbnQuaXRlbXMgJiYgZWxlbWVudC5pdGVtcy5sZW5ndGggPiAwKSB7XG4gICAgICBzZWdtZW50YXRpb25Db2RlRGVzaWduYXRvciA9IGVsZW1lbnQuaXRlbXNbMF0uZGF0YVNldC5zdHJpbmcoJ3gwMDA4MDEwMicpO1xuICAgICAgc2VnbWVudGF0aW9uQ29kZVZhbHVlID0gZWxlbWVudC5pdGVtc1swXS5kYXRhU2V0LnN0cmluZygneDAwMDgwMTAwJyk7XG4gICAgICBzZWdtZW50YXRpb25Db2RlTWVhbmluZyA9IGVsZW1lbnQuaXRlbXNbMF0uZGF0YVNldC5zdHJpbmcoJ3gwMDA4MDEwNCcpO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBzZWdtZW50YXRpb25Db2RlRGVzaWduYXRvcixcbiAgICAgIHNlZ21lbnRhdGlvbkNvZGVWYWx1ZSxcbiAgICAgIHNlZ21lbnRhdGlvbkNvZGVNZWFuaW5nLFxuICAgIH07XG4gIH1cblxuICBfcmVjb21tZW5kZWREaXNwbGF5Q0lFTGFiKHNlZ21lbnQpIHtcbiAgICBpZiAoIXNlZ21lbnQuZGF0YVNldC5lbGVtZW50cy54MDA2MjAwMGQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGxldCBvZmZzZXQgPSBzZWdtZW50LmRhdGFTZXQuZWxlbWVudHMueDAwNjIwMDBkLmRhdGFPZmZzZXQ7XG4gICAgbGV0IGxlbmd0aCA9IHNlZ21lbnQuZGF0YVNldC5lbGVtZW50cy54MDA2MjAwMGQubGVuZ3RoO1xuICAgIGxldCBieXRlQXJyYXkgPSBzZWdtZW50LmRhdGFTZXQuYnl0ZUFycmF5LnNsaWNlKG9mZnNldCwgb2Zmc2V0KyBsZW5ndGgpO1xuXG4gICAgLy8gaHR0cHM6Ly93d3cuZGFic29mdC5jaC9kaWNvbS8zL0MuMTAuNy4xLjEvXG4gICAgbGV0IENJRUxhYlNjYWxlZCA9IG5ldyBVaW50MTZBcnJheShsZW5ndGgvMik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGk8bGVuZ3RoLzI7IGkrKykge1xuICAgICAgQ0lFTGFiU2NhbGVkW2ldID0gKGJ5dGVBcnJheVsyKmkgKyAxXSA8PCA4KSArIGJ5dGVBcnJheVsyKmldO1xuICAgIH1cblxuICAgIGxldCBDSUVMYWJOb3JtYWxpemVkID0gW1xuICAgICAgQ0lFTGFiU2NhbGVkWzBdIC8gNjU1MzUgKiAxMDAsXG4gICAgICBDSUVMYWJTY2FsZWRbMV0gLyA2NTUzNSAqIDI1NSAtIDEyOCxcbiAgICAgIENJRUxhYlNjYWxlZFsyXSAvIDY1NTM1ICogMjU1IC0gMTI4LFxuICAgIF07XG5cbiAgICByZXR1cm4gQ0lFTGFiTm9ybWFsaXplZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTT1AgSW5zdGFuY2UgVUlEXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gZnJhbWVJbmRleFxuICAgKlxuICAgKiBAcmV0dXJuIHsqfVxuICAgKi9cbiAgc29wSW5zdGFuY2VVSUQoZnJhbWVJbmRleCA9IDApIHtcbiAgICBsZXQgc29wSW5zdGFuY2VVSUQgPVxuICAgICAgdGhpcy5fZmluZFN0cmluZ0V2ZXJ5d2hlcmUoJ3gyMDA1MTQwZicsICd4MDAwODAwMTgnLCBmcmFtZUluZGV4KTtcbiAgICByZXR1cm4gc29wSW5zdGFuY2VVSUQ7XG4gIH1cblxuICAvKipcbiAgICogVHJhbnNmZXIgc3ludGF4IFVJRFxuICAgKlxuICAgKiBAcmV0dXJuIHsqfVxuICAgKi9cbiAgdHJhbnNmZXJTeW50YXhVSUQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGFTZXQuc3RyaW5nKCd4MDAwMjAwMTAnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdHVkeSBkZXNjcmlwdGlvblxuICAgKlxuICAgKiBAcmV0dXJuIHsqfVxuICAgKi9cbiAgc3R1ZHlEZXNjcmlwdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YVNldC5zdHJpbmcoJ3gwMDA4MTAzMCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlcmllcyBkZXNjcmlwdGlvblxuICAgKlxuICAgKiBAcmV0dXJuIHsqfVxuICAgKi9cbiAgc2VyaWVzRGVzY3JpcHRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGFTZXQuc3RyaW5nKCd4MDAwODEwM2UnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXRpZW50IG5hbWVcbiAgICpcbiAgICogQHJldHVybiB7Kn1cbiAgICovXG4gIHBhdGllbnROYW1lKCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRhU2V0LnN0cmluZygneDAwMTAwMDEwJyk7XG4gIH1cblxuICAvKipcbiAgICogUGF0aWVudCBJRFxuICAgKlxuICAgKiBAcmV0dXJuIHsqfVxuICAgKi9cbiAgcGF0aWVudElEKCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRhU2V0LnN0cmluZygneDAwMTAwMDIwJyk7XG4gIH1cblxuICAvKipcbiAgICogUGF0aWVudCBiaXJ0aGRhdGVcbiAgICpcbiAgICogQHJldHVybiB7Kn1cbiAgICovXG4gIHBhdGllbnRCaXJ0aGRhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGFTZXQuc3RyaW5nKCd4MDAxMDAwMzAnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXRpZW50IHNleFxuICAgKlxuICAgKiBAcmV0dXJuIHsqfVxuICAgKi9cbiAgcGF0aWVudFNleCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YVNldC5zdHJpbmcoJ3gwMDEwMDA0MCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhdGllbnQgYWdlXG4gICAqXG4gICAqIEByZXR1cm4geyp9XG4gICAqL1xuICBwYXRpZW50QWdlKCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRhU2V0LnN0cmluZygneDAwMTAxMDEwJyk7XG4gIH1cblxuICAvKipcbiAgICogUGhvdG9tZXRyaWMgaW50ZXJwcmV0YXRpb25cbiAgICpcbiAgICogQHJldHVybiB7Kn1cbiAgICovXG4gIHBob3RvbWV0cmljSW50ZXJwcmV0YXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGFTZXQuc3RyaW5nKCd4MDAyODAwMDQnKTtcbiAgfVxuXG4gIHBsYW5hckNvbmZpZ3VyYXRpb24oKSB7XG4gICAgbGV0IHBsYW5hckNvbmZpZ3VyYXRpb24gPSB0aGlzLl9kYXRhU2V0LnVpbnQxNigneDAwMjgwMDA2Jyk7XG5cbiAgICBpZiAodHlwZW9mIHBsYW5hckNvbmZpZ3VyYXRpb24gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBwbGFuYXJDb25maWd1cmF0aW9uID0gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gcGxhbmFyQ29uZmlndXJhdGlvbjtcbiAgfVxuXG4gIHNhbXBsZXNQZXJQaXhlbCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YVNldC51aW50MTYoJ3gwMDI4MDAwMicpO1xuICB9XG5cbiAgbnVtYmVyT2ZGcmFtZXMoKSB7XG4gICAgbGV0IG51bWJlck9mRnJhbWVzID0gdGhpcy5fZGF0YVNldC5pbnRTdHJpbmcoJ3gwMDI4MDAwOCcpO1xuXG4gICAgLy8gbmVlZCBzb21ldGhpbmcgc21hcnRlciFcbiAgICBpZiAodHlwZW9mIG51bWJlck9mRnJhbWVzID09PSAndW5kZWZpbmVkJykge1xuICAgICAgbnVtYmVyT2ZGcmFtZXMgPSBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBudW1iZXJPZkZyYW1lcztcbiAgfVxuXG4gIG51bWJlck9mQ2hhbm5lbHMoKSB7XG4gICAgbGV0IG51bWJlck9mQ2hhbm5lbHMgPSAxO1xuICAgIGxldCBwaG90b21ldHJpY0ludGVycHJldGF0aW9uID0gdGhpcy5waG90b21ldHJpY0ludGVycHJldGF0aW9uKCk7XG5cbiAgICBpZiAoIShwaG90b21ldHJpY0ludGVycHJldGF0aW9uICE9PSAnUkdCJyAmJlxuICAgICAgICBwaG90b21ldHJpY0ludGVycHJldGF0aW9uICE9PSAnUEFMRVRURSBDT0xPUicgJiZcbiAgICAgICAgcGhvdG9tZXRyaWNJbnRlcnByZXRhdGlvbiAhPT0gJ1lCUl9GVUxMJyAmJlxuICAgICAgICBwaG90b21ldHJpY0ludGVycHJldGF0aW9uICE9PSAnWUJSX0ZVTExfNDIyJyAmJlxuICAgICAgICBwaG90b21ldHJpY0ludGVycHJldGF0aW9uICE9PSAnWUJSX1BBUlRJQUxfNDIyJyAmJlxuICAgICAgICBwaG90b21ldHJpY0ludGVycHJldGF0aW9uICE9PSAnWUJSX1BBUlRJQUxfNDIwJyAmJlxuICAgICAgICBwaG90b21ldHJpY0ludGVycHJldGF0aW9uICE9PSAnWUJSX1JDVCcpKSB7XG4gICAgICBudW1iZXJPZkNoYW5uZWxzID0gMztcbiAgICB9XG5cbiAgICAvLyBtYWtlIHN1cmUgd2UgcmV0dXJuIGEgbnVtYmVyISAobm90IGEgc3RyaW5nISlcbiAgICByZXR1cm4gbnVtYmVyT2ZDaGFubmVscztcbiAgfVxuXG4gIGludmVydCgpIHtcbiAgICBsZXQgcGhvdG9tZXRyaWNJbnRlcnByZXRhdGlvbiA9IHRoaXMucGhvdG9tZXRyaWNJbnRlcnByZXRhdGlvbigpO1xuXG4gICAgcmV0dXJuICgocGhvdG9tZXRyaWNJbnRlcnByZXRhdGlvbiA9PT0gJ01PTk9DSFJPTUUxJykgPyB0cnVlIDogZmFsc2UpO1xuICB9XG5cbiAgaW1hZ2VPcmllbnRhdGlvbihmcmFtZUluZGV4ID0gMCkge1xuICAgIC8vIGV4cGVjdCBmcmFtZSBpbmRleCB0byBzdGFydCBhdCAwIVxuICAgIGxldCBpbWFnZU9yaWVudGF0aW9uID0gdGhpcy5fZmluZFN0cmluZ0V2ZXJ5d2hlcmUoJ3gwMDIwOTExNicsICd4MDAyMDAwMzcnLCBmcmFtZUluZGV4KTtcblxuICAgIC8vIGZvcm1hdCBpbWFnZSBvcmllbnRhdGlvbiAoJzFcXDBcXDBcXDBcXDFcXDAnKSB0byBhcnJheSBjb250YWluaW5nIDYgbnVtYmVyc1xuICAgIGlmIChpbWFnZU9yaWVudGF0aW9uKSB7XG4gICAgICAvLyBtYWtlIHN1cmUgd2UgcmV0dXJuIGEgbnVtYmVyISAobm90IGEgc3RyaW5nISlcbiAgICAgIC8vIG1pZ2h0IG5vdCBuZWVkIHRvIHNwbGl0IChmbG9hdFN0cmluZyArIGluZGV4KVxuICAgICAgaW1hZ2VPcmllbnRhdGlvbiA9IGltYWdlT3JpZW50YXRpb24uc3BsaXQoJ1xcXFwnKS5tYXAoTnVtYmVyKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaW1hZ2VPcmllbnRhdGlvbjtcbiAgfVxuXG4gIHJlZmVyZW5jZWRTZWdtZW50TnVtYmVyKGZyYW1lSW5kZXggPSAwKSB7XG4gICAgbGV0IHJlZmVyZW5jZWRTZWdtZW50TnVtYmVyID0gLTE7XG4gICAgbGV0IHJlZmVyZW5jZWRTZWdtZW50TnVtYmVyRWxlbWVudCA9IHRoaXMuX2ZpbmRJbkdyb3VwU2VxdWVuY2UoJ3g1MjAwOTIzMCcsICd4MDA2MjAwMGEnLCBmcmFtZUluZGV4KTtcblxuICAgIGlmIChyZWZlcmVuY2VkU2VnbWVudE51bWJlckVsZW1lbnQgIT09IG51bGwpIHtcbiAgICAgIHJlZmVyZW5jZWRTZWdtZW50TnVtYmVyID0gcmVmZXJlbmNlZFNlZ21lbnROdW1iZXJFbGVtZW50LnVpbnQxNigneDAwNjIwMDBiJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlZmVyZW5jZWRTZWdtZW50TnVtYmVyO1xuICB9XG5cbiAgcGl4ZWxBc3BlY3RSYXRpbygpIHtcbiAgICBsZXQgcGl4ZWxBc3BlY3RSYXRpbyA9IFtcbiAgICAgIHRoaXMuX2RhdGFTZXQuaW50U3RyaW5nKCd4MDAyODAwMzQnLCAwKSxcbiAgICAgIHRoaXMuX2RhdGFTZXQuaW50U3RyaW5nKCd4MDAyODAwMzQnLCAxKSxcbiAgICBdO1xuXG4gICAgLy8gbmVlZCBzb21ldGhpbmcgc21hcnRlciFcbiAgICBpZiAodHlwZW9mIHBpeGVsQXNwZWN0UmF0aW9bMF0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBwaXhlbEFzcGVjdFJhdGlvID0gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBtYWtlIHN1cmUgd2UgcmV0dXJuIGEgbnVtYmVyISAobm90IGEgc3RyaW5nISlcbiAgICByZXR1cm4gcGl4ZWxBc3BlY3RSYXRpbztcbiAgfVxuXG4gIGltYWdlUG9zaXRpb24oZnJhbWVJbmRleCA9IDApIHtcbiAgICBsZXQgaW1hZ2VQb3NpdGlvbiA9IHRoaXMuX2ZpbmRTdHJpbmdFdmVyeXdoZXJlKCd4MDAyMDkxMTMnLCAneDAwMjAwMDMyJywgZnJhbWVJbmRleCk7XG5cbiAgICAvLyBmb3JtYXQgaW1hZ2Ugb3JpZW50YXRpb24gKCcxXFwwXFwwXFwwXFwxXFwwJykgdG8gYXJyYXkgY29udGFpbmluZyA2IG51bWJlcnNcbiAgICBpZiAoaW1hZ2VQb3NpdGlvbikge1xuICAgICAgLy8gbWFrZSBzdXJlIHdlIHJldHVybiBhIG51bWJlciEgKG5vdCBhIHN0cmluZyEpXG4gICAgICBpbWFnZVBvc2l0aW9uID0gaW1hZ2VQb3NpdGlvbi5zcGxpdCgnXFxcXCcpLm1hcChOdW1iZXIpO1xuICAgIH1cblxuICAgIHJldHVybiBpbWFnZVBvc2l0aW9uO1xuICB9XG5cbiAgaW5zdGFuY2VOdW1iZXIoZnJhbWVJbmRleCA9IDApIHtcbiAgICBsZXQgaW5zdGFuY2VOdW1iZXIgPSBudWxsO1xuICAgIC8vIGZpcnN0IGxvb2sgZm9yIGZyYW1lIVxuICAgIC8vIHBlciBmcmFtZSBmdW5jdGlvbm5hbCBncm91cCBzZXF1ZW5jZVxuICAgIGxldCBwZXJGcmFtZUZ1bmN0aW9ubmFsR3JvdXBTZXF1ZW5jZSA9IHRoaXMuX2RhdGFTZXQuZWxlbWVudHMueDUyMDA5MjMwO1xuXG4gICAgaWYgKHR5cGVvZiBwZXJGcmFtZUZ1bmN0aW9ubmFsR3JvdXBTZXF1ZW5jZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGlmIChwZXJGcmFtZUZ1bmN0aW9ubmFsR3JvdXBTZXF1ZW5jZVxuICAgICAgICAgICAgICAuaXRlbXNbZnJhbWVJbmRleF0uZGF0YVNldC5lbGVtZW50cy54MjAwNTE0MGYpIHtcbiAgICAgICAgbGV0IHBsYW5lT3JpZW50YXRpb25TZXF1ZW5jZSA9IHBlckZyYW1lRnVuY3Rpb25uYWxHcm91cFNlcXVlbmNlXG4gICAgICAgICAgICAuaXRlbXNbZnJhbWVJbmRleF0uZGF0YVNldC5lbGVtZW50cy54MjAwNTE0MGYuaXRlbXNbMF0uZGF0YVNldDtcbiAgICAgICAgaW5zdGFuY2VOdW1iZXIgPSBwbGFuZU9yaWVudGF0aW9uU2VxdWVuY2UuaW50U3RyaW5nKCd4MDAyMDAwMTMnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluc3RhbmNlTnVtYmVyID0gdGhpcy5fZGF0YVNldC5pbnRTdHJpbmcoJ3gwMDIwMDAxMycpO1xuXG4gICAgICAgIGlmICh0eXBlb2YgaW5zdGFuY2VOdW1iZXIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgaW5zdGFuY2VOdW1iZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHNob3VsZCB3ZSBkZWZhdWx0IHRvIHVuZGVmaW5lZD8/XG4gICAgICAvLyBkZWZhdWx0IG9yaWVudGF0aW9uXG4gICAgICBpbnN0YW5jZU51bWJlciA9IHRoaXMuX2RhdGFTZXQuaW50U3RyaW5nKCd4MDAyMDAwMTMnKTtcblxuICAgICAgaWYgKHR5cGVvZiBpbnN0YW5jZU51bWJlciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgaW5zdGFuY2VOdW1iZXIgPSBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBpbnN0YW5jZU51bWJlcjtcbiAgfVxuXG4gIHBpeGVsU3BhY2luZyhmcmFtZUluZGV4ID0gMCkge1xuICAgIC8vIGV4cGVjdCBmcmFtZSBpbmRleCB0byBzdGFydCBhdCAwIVxuICAgIGxldCBwaXhlbFNwYWNpbmcgPSB0aGlzLl9maW5kU3RyaW5nRXZlcnl3aGVyZSgneDAwMjg5MTEwJywgJ3gwMDI4MDAzMCcsIGZyYW1lSW5kZXgpO1xuXG4gICAgLy8gZm9ybWF0IGltYWdlIG9yaWVudGF0aW9uICgnMVxcMFxcMFxcMFxcMVxcMCcpIHRvIGFycmF5IGNvbnRhaW5pbmcgNiBudW1iZXJzXG4gICAgLy8gc2hvdWxkIHdlIGRlZmF1bHQgdG8gdW5kZWZpbmVkPz9cbiAgICBpZiAocGl4ZWxTcGFjaW5nKSB7XG4gICAgICAvLyBtYWtlIHN1cmUgd2UgcmV0dXJuIGFycmF5IG9mIG51bWJlcnMhIChub3Qgc3RyaW5ncyEpXG4gICAgICBwaXhlbFNwYWNpbmcgPSBwaXhlbFNwYWNpbmcuc3BsaXQoJ1xcXFwnKS5tYXAoTnVtYmVyKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGl4ZWxTcGFjaW5nO1xuICB9XG5cbiAgcm93cyhmcmFtZUluZGV4ID0gMCkge1xuICAgIGxldCByb3dzID0gdGhpcy5fZGF0YVNldC51aW50MTYoJ3gwMDI4MDAxMCcpO1xuXG4gICAgaWYgKHR5cGVvZiByb3dzID09PSAndW5kZWZpbmVkJykge1xuICAgICAgcm93cyA9IG51bGw7XG4gICAgICAvLyBwcmludCB3YXJuaW5nIGF0IGxlYXN0Li4uXG4gICAgfVxuXG4gICAgcmV0dXJuIHJvd3M7XG4gIH1cblxuICBjb2x1bW5zKGZyYW1lSW5kZXggPSAwKSB7XG4gICAgbGV0IGNvbHVtbnMgPSB0aGlzLl9kYXRhU2V0LnVpbnQxNigneDAwMjgwMDExJyk7XG5cbiAgICBpZiAodHlwZW9mIGNvbHVtbnMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb2x1bW5zID0gbnVsbDtcbiAgICAgIC8vIHByaW50IHdhcm5pbmcgYXQgbGVhc3QuLi5cbiAgICB9XG5cbiAgICByZXR1cm4gY29sdW1ucztcbiAgfVxuXG4gIHBpeGVsVHlwZShmcmFtZUluZGV4ID0gMCkge1xuICAgIC8vIDAgaW50ZWdlciwgMSBmbG9hdFxuICAgIC8vIGRpY29tIG9ubHkgc3VwcG9ydCBpbnRlZ2Vyc1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgcGl4ZWxSZXByZXNlbnRhdGlvbihmcmFtZUluZGV4ID0gMCkge1xuICAgIGxldCBwaXhlbFJlcHJlc2VudGF0aW9uID0gdGhpcy5fZGF0YVNldC51aW50MTYoJ3gwMDI4MDEwMycpO1xuICAgIHJldHVybiBwaXhlbFJlcHJlc2VudGF0aW9uO1xuICB9XG5cbiAgYml0c0FsbG9jYXRlZChmcmFtZUluZGV4ID0gMCkge1xuICAgIC8vIGV4cGVjdCBmcmFtZSBpbmRleCB0byBzdGFydCBhdCAwIVxuICAgIGxldCBiaXRzQWxsb2NhdGVkID0gdGhpcy5fZGF0YVNldC51aW50MTYoJ3gwMDI4MDEwMCcpO1xuICAgIHJldHVybiBiaXRzQWxsb2NhdGVkO1xuICB9XG5cbiAgaGlnaEJpdChmcmFtZUluZGV4ID0gMCkge1xuICAgIC8vIGV4cGVjdCBmcmFtZSBpbmRleCB0byBzdGFydCBhdCAwIVxuICAgIGxldCBoaWdoQml0ID0gdGhpcy5fZGF0YVNldC51aW50MTYoJ3gwMDI4MDEwMicpO1xuICAgIHJldHVybiBoaWdoQml0O1xuICB9XG5cbiAgcmVzY2FsZUludGVyY2VwdChmcmFtZUluZGV4ID0gMCkge1xuICAgIHJldHVybiB0aGlzLl9maW5kRmxvYXRTdHJpbmdJbkZyYW1lR3JvdXBTZXF1ZW5jZShcbiAgICAgICd4MDAyODkxNDUnLCAneDAwMjgxMDUyJywgZnJhbWVJbmRleCk7XG4gIH1cblxuICByZXNjYWxlU2xvcGUoZnJhbWVJbmRleCA9IDApIHtcbiAgICByZXR1cm4gdGhpcy5fZmluZEZsb2F0U3RyaW5nSW5GcmFtZUdyb3VwU2VxdWVuY2UoXG4gICAgICAneDAwMjg5MTQ1JywgJ3gwMDI4MTA1MycsIGZyYW1lSW5kZXgpO1xuICB9XG5cbiAgd2luZG93Q2VudGVyKGZyYW1lSW5kZXggPSAwKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZpbmRGbG9hdFN0cmluZ0luRnJhbWVHcm91cFNlcXVlbmNlKFxuICAgICAgJ3gwMDI4OTEzMicsICd4MDAyODEwNTAnLCBmcmFtZUluZGV4KTtcbiAgfVxuXG4gIHdpbmRvd1dpZHRoKGZyYW1lSW5kZXggPSAwKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZpbmRGbG9hdFN0cmluZ0luRnJhbWVHcm91cFNlcXVlbmNlKFxuICAgICAgJ3gwMDI4OTEzMicsICd4MDAyODEwNTEnLCBmcmFtZUluZGV4KTtcbiAgfVxuXG4gIHNsaWNlVGhpY2tuZXNzKGZyYW1lSW5kZXggPSAwKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZpbmRGbG9hdFN0cmluZ0luRnJhbWVHcm91cFNlcXVlbmNlKFxuICAgICAgJ3gwMDI4OTExMCcsICd4MDAxODAwNTAnLCBmcmFtZUluZGV4KTtcbiAgfVxuXG4gIHNwYWNpbmdCZXR3ZWVuU2xpY2VzKGZyYW1lSW5kZXggPSAwKSB7XG4gICAgbGV0IHNwYWNpbmcgPSB0aGlzLl9kYXRhU2V0LmludFN0cmluZygneDAwMTgwMDg4Jyk7XG5cbiAgICBpZiAodHlwZW9mIHNwYWNpbmcgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBzcGFjaW5nID0gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gc3BhY2luZztcbiAgfVxuXG4gIGRpbWVuc2lvbkluZGV4VmFsdWVzKGZyYW1lSW5kZXggPSAwKSB7XG4gICAgbGV0IGRpbWVuc2lvbkluZGV4VmFsdWVzID0gbnVsbDtcblxuICAgIC8vIHRyeSB0byBnZXQgaXQgZnJvbSBlbmhhbmNlZCBNUiBpbWFnZXNcbiAgICAvLyBwZXItZnJhbWUgZnVuY3Rpb25uYWwgZ3JvdXAgc2VxdWVuY2VcbiAgICBsZXQgcGVyRnJhbWVGdW5jdGlvbm5hbEdyb3VwU2VxdWVuY2UgPSB0aGlzLl9kYXRhU2V0LmVsZW1lbnRzLng1MjAwOTIzMDtcblxuICAgIGlmICh0eXBlb2YgcGVyRnJhbWVGdW5jdGlvbm5hbEdyb3VwU2VxdWVuY2UgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBsZXQgZnJhbWVDb250ZW50U2VxdWVuY2UgPSBwZXJGcmFtZUZ1bmN0aW9ubmFsR3JvdXBTZXF1ZW5jZVxuICAgICAgICAgIC5pdGVtc1tmcmFtZUluZGV4XS5kYXRhU2V0LmVsZW1lbnRzLngwMDIwOTExMTtcbiAgICAgIGlmIChmcmFtZUNvbnRlbnRTZXF1ZW5jZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgZnJhbWVDb250ZW50U2VxdWVuY2UgIT09IG51bGwpIHtcbiAgICAgICAgZnJhbWVDb250ZW50U2VxdWVuY2UgPSBmcmFtZUNvbnRlbnRTZXF1ZW5jZS5pdGVtc1swXS5kYXRhU2V0O1xuICAgICAgICBsZXQgZGltZW5zaW9uSW5kZXhWYWx1ZXNFbHQgPSBmcmFtZUNvbnRlbnRTZXF1ZW5jZS5lbGVtZW50cy54MDAyMDkxNTc7XG4gICAgICAgIGlmIChkaW1lbnNpb25JbmRleFZhbHVlc0VsdCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICBkaW1lbnNpb25JbmRleFZhbHVlc0VsdCAhPT0gbnVsbCkge1xuICAgICAgICAgIC8vIC80IGJlY2F1c2UgVUxcbiAgICAgICAgICBsZXQgbmJWYWx1ZXMgPSBkaW1lbnNpb25JbmRleFZhbHVlc0VsdC5sZW5ndGggLyA0O1xuICAgICAgICAgIGRpbWVuc2lvbkluZGV4VmFsdWVzID0gW107XG5cbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5iVmFsdWVzOyBpKyspIHtcbiAgICAgICAgICAgIGRpbWVuc2lvbkluZGV4VmFsdWVzLnB1c2goXG4gICAgICAgICAgICAgIGZyYW1lQ29udGVudFNlcXVlbmNlLnVpbnQzMigneDAwMjA5MTU3JywgaSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBkaW1lbnNpb25JbmRleFZhbHVlcztcbiAgfVxuXG4gIGluU3RhY2tQb3NpdGlvbk51bWJlcihmcmFtZUluZGV4ID0gMCkge1xuICAgIGxldCBpblN0YWNrUG9zaXRpb25OdW1iZXIgPSBudWxsO1xuXG4gICAgLy8gdHJ5IHRvIGdldCBpdCBmcm9tIGVuaGFuY2VkIE1SIGltYWdlc1xuICAgIC8vIHBlci1mcmFtZSBmdW5jdGlvbm5hbCBncm91cCBzZXF1ZW5jZVxuICAgIGxldCBwZXJGcmFtZUZ1bmN0aW9ubmFsR3JvdXBTZXF1ZW5jZSA9IHRoaXMuX2RhdGFTZXQuZWxlbWVudHMueDUyMDA5MjMwO1xuXG4gICAgaWYgKHR5cGVvZiBwZXJGcmFtZUZ1bmN0aW9ubmFsR3JvdXBTZXF1ZW5jZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIC8vIE5PVCBBIFBISUxJUFMgVFJJQ0shXG4gICAgICBsZXQgcGhpbGlwc1ByaXZhdGVTZXF1ZW5jZSA9IHBlckZyYW1lRnVuY3Rpb25uYWxHcm91cFNlcXVlbmNlXG4gICAgICAgICAgLml0ZW1zW2ZyYW1lSW5kZXhdLmRhdGFTZXQuZWxlbWVudHMueDAwMjA5MTExLml0ZW1zWzBdLmRhdGFTZXQ7XG4gICAgICBpblN0YWNrUG9zaXRpb25OdW1iZXIgPSBwaGlsaXBzUHJpdmF0ZVNlcXVlbmNlLnVpbnQzMigneDAwMjA5MDU3Jyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGluU3RhY2tQb3NpdGlvbk51bWJlciA9IG51bGw7XG4gICAgfVxuXG4gICAgY29uc29sZS5sb2coYGluc3RhY2sgcG9zaXRpb24gJHtpblN0YWNrUG9zaXRpb25OdW1iZXJ9YCk7XG5cbiAgICByZXR1cm4gaW5TdGFja1Bvc2l0aW9uTnVtYmVyO1xuICB9XG5cbiAgc3RhY2tJRChmcmFtZUluZGV4ID0gMCkge1xuICAgIGxldCBzdGFja0lEID0gbnVsbDtcblxuICAgIC8vIHRyeSB0byBnZXQgaXQgZnJvbSBlbmhhbmNlZCBNUiBpbWFnZXNcbiAgICAvLyBwZXItZnJhbWUgZnVuY3Rpb25uYWwgZ3JvdXAgc2VxdWVuY2VcbiAgICBsZXQgcGVyRnJhbWVGdW5jdGlvbm5hbEdyb3VwU2VxdWVuY2UgPSB0aGlzLl9kYXRhU2V0LmVsZW1lbnRzLng1MjAwOTIzMDtcblxuICAgIGlmICh0eXBlb2YgcGVyRnJhbWVGdW5jdGlvbm5hbEdyb3VwU2VxdWVuY2UgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAvLyBOT1QgQSBQSElMSVBTIFRSSUNLIVxuICAgICAgbGV0IHBoaWxpcHNQcml2YXRlU2VxdWVuY2UgPSBwZXJGcmFtZUZ1bmN0aW9ubmFsR3JvdXBTZXF1ZW5jZVxuICAgICAgICAgIC5pdGVtc1tmcmFtZUluZGV4XS5kYXRhU2V0LmVsZW1lbnRzLngwMDIwOTExMS5pdGVtc1swXS5kYXRhU2V0O1xuICAgICAgc3RhY2tJRCA9IHBoaWxpcHNQcml2YXRlU2VxdWVuY2UuaW50U3RyaW5nKCd4MDAyMDkwNTYnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhY2tJRCA9IG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0YWNrSUQ7XG4gIH1cblxuICBleHRyYWN0UGl4ZWxEYXRhKGZyYW1lSW5kZXggPSAwKSB7XG4gICAgLy8gZGVjb21wcmVzc1xuICAgIGxldCBkZWNvbXByZXNzZWREYXRhID0gdGhpcy5fZGVjb2RlUGl4ZWxEYXRhKGZyYW1lSW5kZXgpO1xuXG4gICAgbGV0IG51bWJlck9mQ2hhbm5lbHMgPSB0aGlzLm51bWJlck9mQ2hhbm5lbHMoKTtcblxuICAgIGlmIChudW1iZXJPZkNoYW5uZWxzID4gMSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2NvbnZlcnRDb2xvclNwYWNlKGRlY29tcHJlc3NlZERhdGEpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZGVjb21wcmVzc2VkRGF0YTtcbiAgICB9XG4gIH1cblxuICBtaW5NYXhQaXhlbERhdGEocGl4ZWxEYXRhID0gW10pIHtcbiAgICBsZXQgbWluTWF4ID0gWzY1NTM1LCAtMzI3NjhdO1xuICAgIGxldCBudW1QaXhlbHMgPSBwaXhlbERhdGEubGVuZ3RoO1xuXG4gICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IG51bVBpeGVsczsgaW5kZXgrKykge1xuICAgICAgbGV0IHNwdiA9IHBpeGVsRGF0YVtpbmRleF07XG4gICAgICBtaW5NYXhbMF0gPSBNYXRoLm1pbihtaW5NYXhbMF0sIHNwdik7XG4gICAgICBtaW5NYXhbMV0gPSBNYXRoLm1heChtaW5NYXhbMV0sIHNwdik7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1pbk1heDtcbiAgfVxuXG4gIC8vXG4gIC8vIHByaXZhdGUgbWV0aG9kc1xuICAvL1xuXG4gIF9maW5kSW5Hcm91cFNlcXVlbmNlKHNlcXVlbmNlLCBzdWJzZXF1ZW5jZSwgaW5kZXgpIHtcbiAgICBsZXQgZnVuY3Rpb25hbEdyb3VwU2VxdWVuY2UgPSB0aGlzLl9kYXRhU2V0LmVsZW1lbnRzW3NlcXVlbmNlXTtcblxuICAgIGlmICh0eXBlb2YgZnVuY3Rpb25hbEdyb3VwU2VxdWVuY2UgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBsZXQgaW5TZXF1ZW5jZSA9IGZ1bmN0aW9uYWxHcm91cFNlcXVlbmNlLml0ZW1zW2luZGV4XS5kYXRhU2V0LmVsZW1lbnRzW3N1YnNlcXVlbmNlXTtcblxuICAgICAgaWYgKHR5cGVvZiBpblNlcXVlbmNlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gaW5TZXF1ZW5jZS5pdGVtc1swXS5kYXRhU2V0O1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgX2ZpbmRTdHJpbmdJbkdyb3VwU2VxdWVuY2Uoc2VxdWVuY2UsIHN1YnNlcXVlbmNlLCB0YWcsIGluZGV4KSB7XG4gICAgLy8gaW5kZXggPSAwIGlmIHNoYXJlZCEhIVxuICAgIGxldCBkYXRhU2V0ID0gdGhpcy5fZmluZEluR3JvdXBTZXF1ZW5jZShzZXF1ZW5jZSwgc3Vic2VxdWVuY2UsIGluZGV4KTtcblxuICAgIGlmIChkYXRhU2V0ICE9PSBudWxsKSB7XG4gICAgICByZXR1cm4gZGF0YVNldC5zdHJpbmcodGFnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIF9maW5kU3RyaW5nSW5GcmFtZUdyb3VwU2VxdWVuY2Uoc3Vic2VxdWVuY2UsIHRhZywgaW5kZXgpIHtcbiAgICByZXR1cm4gdGhpcy5fZmluZFN0cmluZ0luR3JvdXBTZXF1ZW5jZSgneDUyMDA5MjI5Jywgc3Vic2VxdWVuY2UsIHRhZywgMCkgfHxcbiAgICAgICAgdGhpcy5fZmluZFN0cmluZ0luR3JvdXBTZXF1ZW5jZSgneDUyMDA5MjMwJywgc3Vic2VxdWVuY2UsIHRhZywgaW5kZXgpO1xuICB9XG5cbiAgX2ZpbmRTdHJpbmdFdmVyeXdoZXJlKHN1YnNlcXVlbmNlLCB0YWcsIGluZGV4KSB7XG4gICAgbGV0IHRhcmdldFN0cmluZyA9IHRoaXMuX2ZpbmRTdHJpbmdJbkZyYW1lR3JvdXBTZXF1ZW5jZShzdWJzZXF1ZW5jZSwgdGFnLCBpbmRleCk7XG5cbiAgICBpZiAodGFyZ2V0U3RyaW5nID09PSBudWxsKSB7XG4gICAgICB0YXJnZXRTdHJpbmcgPSB0aGlzLl9kYXRhU2V0LnN0cmluZyh0YWcpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdGFyZ2V0U3RyaW5nID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdGFyZ2V0U3RyaW5nID0gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0U3RyaW5nO1xuICB9XG5cbiAgX2ZpbmRGbG9hdFN0cmluZ0luR3JvdXBTZXF1ZW5jZShzZXF1ZW5jZSwgc3Vic2VxdWVuY2UsIHRhZywgaW5kZXgpIHtcbiAgICBsZXQgZGF0YUluR3JvdXBTZXF1ZW5jZSA9IHRoaXMuX2RhdGFTZXQuZmxvYXRTdHJpbmcodGFnKTtcblxuICAgIC8vIHRyeSB0byBnZXQgaXQgZnJvbSBlbmhhbmNlZCBNUiBpbWFnZXNcbiAgICAvLyBwZXItZnJhbWUgZnVuY3Rpb25uYWwgZ3JvdXBcbiAgICBpZiAodHlwZW9mIGRhdGFJbkdyb3VwU2VxdWVuY2UgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBkYXRhSW5Hcm91cFNlcXVlbmNlID0gdGhpcy5fZmluZEluR3JvdXBTZXF1ZW5jZShzZXF1ZW5jZSwgc3Vic2VxdWVuY2UsIGluZGV4KTtcblxuICAgICAgaWYgKGRhdGFJbkdyb3VwU2VxdWVuY2UgIT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGRhdGFJbkdyb3VwU2VxdWVuY2UuZmxvYXRTdHJpbmcodGFnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBkYXRhSW5Hcm91cFNlcXVlbmNlO1xuICB9XG5cbiAgX2ZpbmRGbG9hdFN0cmluZ0luRnJhbWVHcm91cFNlcXVlbmNlKHN1YnNlcXVlbmNlLCB0YWcsIGluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZpbmRGbG9hdFN0cmluZ0luR3JvdXBTZXF1ZW5jZSgneDUyMDA5MjI5Jywgc3Vic2VxdWVuY2UsIHRhZywgMCkgfHxcbiAgICAgICAgdGhpcy5fZmluZEZsb2F0U3RyaW5nSW5Hcm91cFNlcXVlbmNlKCd4NTIwMDkyMzAnLCBzdWJzZXF1ZW5jZSwgdGFnLCBpbmRleCk7XG4gIH1cblxuICBfZGVjb2RlUGl4ZWxEYXRhKGZyYW1lSW5kZXggPSAwKSB7XG4gICAgLy8gaWYgY29tcHJlc3NlZC4uP1xuICAgIGxldCB0cmFuc2ZlclN5bnRheFVJRCA9IHRoaXMudHJhbnNmZXJTeW50YXhVSUQoKTtcblxuICAgIC8vIGZpbmQgY29tcHJlc3Npb24gc2NoZW1lXG4gICAgaWYgKFxuICAgICAgdHJhbnNmZXJTeW50YXhVSUQgPT09ICcxLjIuODQwLjEwMDA4LjEuMi40LjkwJyB8fFxuICAgICAgLy8gSlBFRyAyMDAwIExvc3NsZXNzXG4gICAgICB0cmFuc2ZlclN5bnRheFVJRCA9PT0gJzEuMi44NDAuMTAwMDguMS4yLjQuOTEnKSB7XG4gICAgICAvLyBKUEVHIDIwMDAgTG9zc3lcbiAgICAgIHJldHVybiB0aGlzLl9kZWNvZGVKMksoZnJhbWVJbmRleCk7XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIHRyYW5zZmVyU3ludGF4VUlEID09PSAnMS4yLjg0MC4xMDAwOC4xLjIuNC41NycgfHxcbiAgICAgIC8vIEpQRUcgTG9zc2xlc3MsIE5vbmhpZXJhcmNoaWNhbCAoUHJvY2Vzc2VzIDE0KVxuICAgICAgdHJhbnNmZXJTeW50YXhVSUQgPT09ICcxLjIuODQwLjEwMDA4LjEuMi40LjcwJykge1xuICAgICAgLy8gSlBFRyBMb3NzbGVzcywgTm9uaGllcmFyY2hpY2FsIChQcm9jZXNzZXMgMTQgW1NlbGVjdGlvbiAxXSlcbiAgICAgIHJldHVybiB0aGlzLl9kZWNvZGVKUEVHTG9zc2xlc3MoZnJhbWVJbmRleCk7XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIHRyYW5zZmVyU3ludGF4VUlEID09PSAnMS4yLjg0MC4xMDAwOC4xLjIuNC41MCcgfHxcbiAgICAgIC8vIEpQRUcgQmFzZWxpbmUgbG9zc3kgcHJvY2VzcyAxICg4IGJpdClcbiAgICAgIHRyYW5zZmVyU3ludGF4VUlEID09PSAnMS4yLjg0MC4xMDAwOC4xLjIuNC41MScpIHtcbiAgICAgIC8vIEpQRUcgQmFzZWxpbmUgbG9zc3kgcHJvY2VzcyAyICYgNCAoMTIgYml0KVxuICAgICAgcmV0dXJuIHRoaXMuX2RlY29kZUpQRUdCYXNlbGluZShmcmFtZUluZGV4KTtcbiAgICB9IGVsc2UgaWYgKFxuICAgICAgdHJhbnNmZXJTeW50YXhVSUQgPT09ICcxLjIuODQwLjEwMDA4LjEuMicgfHxcbiAgICAgIC8vIEltcGxpY2l0IFZSIExpdHRsZSBFbmRpYW5cbiAgICAgIHRyYW5zZmVyU3ludGF4VUlEID09PSAnMS4yLjg0MC4xMDAwOC4xLjIuMScpIHtcbiAgICAgIC8vIEV4cGxpY2l0IFZSIExpdHRsZSBFbmRpYW5cbiAgICAgIHJldHVybiB0aGlzLl9kZWNvZGVVbmNvbXByZXNzZWQoZnJhbWVJbmRleCk7XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIHRyYW5zZmVyU3ludGF4VUlEID09PSAnMS4yLjg0MC4xMDAwOC4xLjIuMicpIHtcbiAgICAgIC8vIEV4cGxpY2l0IFZSIEJpZyBFbmRpYW5cbiAgICAgIGxldCBmcmFtZSA9IHRoaXMuX2RlY29kZVVuY29tcHJlc3NlZChmcmFtZUluZGV4KTtcbiAgICAgIC8vIGFuZCBzYXdwIGl0IVxuICAgICAgcmV0dXJuIHRoaXMuX3N3YXBGcmFtZShmcmFtZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IHtcbiAgICAgICAgZXJyb3I6IGBubyBkZWNvZGVyIGZvciB0cmFuc2ZlciBzeW50YXggJHt0cmFuc2ZlclN5bnRheFVJRH1gLFxuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICBfZGVjb2RlSjJLKGZyYW1lSW5kZXggPSAwKSB7XG4gICAgbGV0IGVuY29kZWRQaXhlbERhdGEgPSBEaWNvbVBhcnNlci5yZWFkRW5jYXBzdWxhdGVkUGl4ZWxEYXRhKHRoaXMuX2RhdGFTZXQsIHRoaXMuX2RhdGFTZXQuZWxlbWVudHMueDdmZTAwMDEwLCBmcmFtZUluZGV4KTtcbiAgICAvLyBsZXQgcGl4ZWxEYXRhRWxlbWVudCA9IHRoaXMuX2RhdGFTZXQuZWxlbWVudHMueDdmZTAwMDEwO1xuICAgIC8vIGxldCBwaXhlbERhdGEgPSBuZXcgVWludDhBcnJheSh0aGlzLl9kYXRhU2V0LmJ5dGVBcnJheS5idWZmZXIsIHBpeGVsRGF0YUVsZW1lbnQuZGF0YU9mZnNldCwgcGl4ZWxEYXRhRWxlbWVudC5sZW5ndGgpO1xuICAgIGxldCBqcHhJbWFnZSA9IG5ldyBKcHgoKTtcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vT0hJRi9pbWFnZS1KUEVHMjAwMC9pc3N1ZXMvNlxuICAgIC8vIEl0IGN1cnJlbnRseSByZXR1cm5zIGVpdGhlciBJbnQxNiBvciBVaW50MTYgYmFzZWQgb24gd2hldGhlciB0aGUgY29kZXN0cmVhbSBpcyBzaWduZWQgb3Igbm90LlxuICAgIGpweEltYWdlLnBhcnNlKGVuY29kZWRQaXhlbERhdGEpO1xuXG4gICAgLy8gbGV0IGoya1dpZHRoID0ganB4SW1hZ2Uud2lkdGg7XG4gICAgLy8gbGV0IGoya0hlaWdodCA9IGpweEltYWdlLmhlaWdodDtcblxuICAgIGxldCBjb21wb25lbnRzQ291bnQgPSBqcHhJbWFnZS5jb21wb25lbnRzQ291bnQ7XG4gICAgaWYgKGNvbXBvbmVudHNDb3VudCAhPT0gMSkge1xuICAgICAgdGhyb3cgJ0pQRUcyMDAwIGRlY29kZXIgcmV0dXJuZWQgYSBjb21wb25lbnRDb3VudCBvZiAke2NvbXBvbmVudHNDb3VudH0sIHdoZW4gMSBpcyBleHBlY3RlZCc7XG4gICAgfVxuICAgIGxldCB0aWxlQ291bnQgPSBqcHhJbWFnZS50aWxlcy5sZW5ndGg7XG5cbiAgICBpZiAodGlsZUNvdW50ICE9PSAxKSB7XG4gICAgICB0aHJvdyAnSlBFRzIwMDAgZGVjb2RlciByZXR1cm5lZCBhIHRpbGVDb3VudCBvZiAke3RpbGVDb3VudH0sIHdoZW4gMSBpcyBleHBlY3RlZCc7XG4gICAgfVxuXG4gICAgbGV0IHRpbGVDb21wb25lbnRzID0ganB4SW1hZ2UudGlsZXNbMF07XG4gICAgbGV0IHBpeGVsRGF0YSA9IHRpbGVDb21wb25lbnRzLml0ZW1zO1xuXG4gICAgLy8gd2luZG93LmNvbnNvbGUubG9nKGoya1dpZHRoLCBqMmtIZWlnaHQpO1xuXG4gICAgcmV0dXJuIHBpeGVsRGF0YTtcbiAgfVxuXG4gIC8vIGZyb20gY29ybmVyc3RvbmVcbiAgX2RlY29kZUpQRUdMb3NzbGVzcyhmcmFtZUluZGV4ID0gMCkge1xuICAgIGxldCBlbmNvZGVkUGl4ZWxEYXRhID0gRGljb21QYXJzZXIucmVhZEVuY2Fwc3VsYXRlZFBpeGVsRGF0YSh0aGlzLl9kYXRhU2V0LCB0aGlzLl9kYXRhU2V0LmVsZW1lbnRzLng3ZmUwMDAxMCwgZnJhbWVJbmRleCk7XG4gICAgbGV0IHBpeGVsUmVwcmVzZW50YXRpb24gPSB0aGlzLnBpeGVsUmVwcmVzZW50YXRpb24oZnJhbWVJbmRleCk7XG4gICAgbGV0IGJpdHNBbGxvY2F0ZWQgPSB0aGlzLmJpdHNBbGxvY2F0ZWQoZnJhbWVJbmRleCk7XG4gICAgbGV0IGJ5dGVPdXRwdXQgPSBiaXRzQWxsb2NhdGVkIDw9IDggPyAxIDogMjtcbiAgICBsZXQgZGVjb2RlciA9IG5ldyBKcGVnLmxvc3NsZXNzLkRlY29kZXIoKTtcbiAgICBsZXQgZGVjb21wcmVzc2VkRGF0YSA9IGRlY29kZXIuZGVjb2RlKGVuY29kZWRQaXhlbERhdGEuYnVmZmVyLCBlbmNvZGVkUGl4ZWxEYXRhLmJ5dGVPZmZzZXQsIGVuY29kZWRQaXhlbERhdGEubGVuZ3RoLCBieXRlT3V0cHV0KTtcblxuICAgIGlmIChwaXhlbFJlcHJlc2VudGF0aW9uID09PSAwKSB7XG4gICAgICBpZiAoYnl0ZU91dHB1dCA9PT0gMikge1xuICAgICAgICByZXR1cm4gbmV3IFVpbnQxNkFycmF5KGRlY29tcHJlc3NlZERhdGEuYnVmZmVyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHVudGVzdGVkIVxuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoZGVjb21wcmVzc2VkRGF0YS5idWZmZXIpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbmV3IEludDE2QXJyYXkoZGVjb21wcmVzc2VkRGF0YS5idWZmZXIpO1xuICAgIH1cbiAgfVxuXG4gIF9kZWNvZGVKUEVHQmFzZWxpbmUoZnJhbWVJbmRleCA9IDApIHtcbiAgICBsZXQgZW5jb2RlZFBpeGVsRGF0YSA9IERpY29tUGFyc2VyLnJlYWRFbmNhcHN1bGF0ZWRQaXhlbERhdGEodGhpcy5fZGF0YVNldCwgdGhpcy5fZGF0YVNldC5lbGVtZW50cy54N2ZlMDAwMTAsIGZyYW1lSW5kZXgpO1xuICAgIGxldCByb3dzID0gdGhpcy5yb3dzKGZyYW1lSW5kZXgpO1xuICAgIGxldCBjb2x1bW5zID0gdGhpcy5jb2x1bW5zKGZyYW1lSW5kZXgpO1xuICAgIGxldCBiaXRzQWxsb2NhdGVkID0gdGhpcy5iaXRzQWxsb2NhdGVkKGZyYW1lSW5kZXgpO1xuICAgIGxldCBqcGVnQmFzZWxpbmUgPSBuZXcgSnBlZ0Jhc2VsaW5lKCk7XG4gICAganBlZ0Jhc2VsaW5lLnBhcnNlKGVuY29kZWRQaXhlbERhdGEpO1xuXG4gICAgaWYgKGJpdHNBbGxvY2F0ZWQgPT09IDgpIHtcbiAgICAgIHJldHVybiBqcGVnQmFzZWxpbmUuZ2V0RGF0YShjb2x1bW5zLCByb3dzKTtcbiAgICB9IGVsc2UgaWYgKGJpdHNBbGxvY2F0ZWQgPT09IDE2KSB7XG4gICAgICByZXR1cm4ganBlZ0Jhc2VsaW5lLmdldERhdGExNihjb2x1bW5zLCByb3dzKTtcbiAgICB9XG4gIH1cblxuICBfZGVjb2RlVW5jb21wcmVzc2VkKGZyYW1lSW5kZXggPSAwKSB7XG4gICAgbGV0IHBpeGVsUmVwcmVzZW50YXRpb24gPSB0aGlzLnBpeGVsUmVwcmVzZW50YXRpb24oZnJhbWVJbmRleCk7XG4gICAgbGV0IGJpdHNBbGxvY2F0ZWQgPSB0aGlzLmJpdHNBbGxvY2F0ZWQoZnJhbWVJbmRleCk7XG4gICAgbGV0IHBpeGVsRGF0YUVsZW1lbnQgPSB0aGlzLl9kYXRhU2V0LmVsZW1lbnRzLng3ZmUwMDAxMDtcbiAgICBsZXQgcGl4ZWxEYXRhT2Zmc2V0ID0gcGl4ZWxEYXRhRWxlbWVudC5kYXRhT2Zmc2V0O1xuICAgIGxldCBudW1iZXJPZkNoYW5uZWxzID0gdGhpcy5udW1iZXJPZkNoYW5uZWxzKCk7XG4gICAgbGV0IG51bVBpeGVscyA9XG4gICAgICB0aGlzLnJvd3MoZnJhbWVJbmRleCkgKiB0aGlzLmNvbHVtbnMoZnJhbWVJbmRleCkgKiBudW1iZXJPZkNoYW5uZWxzO1xuICAgIGxldCBmcmFtZU9mZnNldCA9IDA7XG4gICAgbGV0IGJ1ZmZlciA9IHRoaXMuX2RhdGFTZXQuYnl0ZUFycmF5LmJ1ZmZlcjtcblxuICAgIGlmIChwaXhlbFJlcHJlc2VudGF0aW9uID09PSAwICYmIGJpdHNBbGxvY2F0ZWQgPT09IDgpIHtcbiAgICAgIC8vIHVuc2lnbmVkIDggYml0XG4gICAgICBmcmFtZU9mZnNldCA9IHBpeGVsRGF0YU9mZnNldCArIGZyYW1lSW5kZXggKiBudW1QaXhlbHM7XG4gICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyLCBmcmFtZU9mZnNldCwgbnVtUGl4ZWxzKTtcbiAgICB9IGVsc2UgaWYgKHBpeGVsUmVwcmVzZW50YXRpb24gPT09IDAgJiYgYml0c0FsbG9jYXRlZCA9PT0gMTYpIHtcbiAgICAgIC8vIHVuc2lnbmVkIDE2IGJpdFxuICAgICAgZnJhbWVPZmZzZXQgPSBwaXhlbERhdGFPZmZzZXQgKyBmcmFtZUluZGV4ICogbnVtUGl4ZWxzICogMjtcbiAgICAgIHJldHVybiBuZXcgVWludDE2QXJyYXkoYnVmZmVyLCBmcmFtZU9mZnNldCwgbnVtUGl4ZWxzKTtcbiAgICB9IGVsc2UgaWYgKHBpeGVsUmVwcmVzZW50YXRpb24gPT09IDEgJiYgYml0c0FsbG9jYXRlZCA9PT0gMTYpIHtcbiAgICAgIC8vIHNpZ25lZCAxNiBiaXRcbiAgICAgIGZyYW1lT2Zmc2V0ID0gcGl4ZWxEYXRhT2Zmc2V0ICsgZnJhbWVJbmRleCAqIG51bVBpeGVscyAqIDI7XG4gICAgICByZXR1cm4gbmV3IEludDE2QXJyYXkoYnVmZmVyLCBmcmFtZU9mZnNldCwgbnVtUGl4ZWxzKTtcbiAgICB9IGVsc2UgaWYgKHBpeGVsUmVwcmVzZW50YXRpb24gPT09IDAgJiYgYml0c0FsbG9jYXRlZCA9PT0gMzIpIHtcbiAgICAgIC8vIHVuc2lnbmVkIDMyIGJpdFxuICAgICAgZnJhbWVPZmZzZXQgPSBwaXhlbERhdGFPZmZzZXQgKyBmcmFtZUluZGV4ICogbnVtUGl4ZWxzICogNDtcbiAgICAgIHJldHVybiBuZXcgVWludDMyQXJyYXkoYnVmZmVyLCBmcmFtZU9mZnNldCwgbnVtUGl4ZWxzKTtcbiAgICB9IGVsc2UgaWYgKHBpeGVsUmVwcmVzZW50YXRpb24gPT09IDAgJiYgYml0c0FsbG9jYXRlZCA9PT0gMSkge1xuICAgICAgbGV0IG5ld0J1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcihudW1QaXhlbHMpO1xuICAgICAgbGV0IG5ld0FycmF5ID0gbmV3IFVpbnQ4QXJyYXkobmV3QnVmZmVyKTtcblxuICAgICAgZnJhbWVPZmZzZXQgPSBwaXhlbERhdGFPZmZzZXQgKyBmcmFtZUluZGV4ICogbnVtUGl4ZWxzO1xuICAgICAgbGV0IGluZGV4ID0gMDtcblxuICAgICAgbGV0IGJpdFN0YXJ0ID0gZnJhbWVJbmRleCAqIG51bVBpeGVscztcbiAgICAgIGxldCBiaXRFbmQgPSBmcmFtZUluZGV4ICogbnVtUGl4ZWxzICsgbnVtUGl4ZWxzO1xuXG4gICAgICBsZXQgYnl0ZVN0YXJ0ID0gTWF0aC5mbG9vcihiaXRTdGFydCAvIDgpO1xuICAgICAgbGV0IGJpdFN0YXJ0T2Zmc2V0ID0gYml0U3RhcnQgLSBieXRlU3RhcnQgKiA4O1xuICAgICAgbGV0IGJ5dGVFbmQgPSBNYXRoLmNlaWwoYml0RW5kIC8gOCk7XG5cbiAgICAgIGxldCB0YXJnZXRCdWZmZXIgPSBuZXcgVWludDhBcnJheShidWZmZXIsIHBpeGVsRGF0YU9mZnNldCk7XG5cbiAgICAgIGZvciAobGV0IGkgPSBieXRlU3RhcnQ7IGkgPD0gYnl0ZUVuZDsgaSsrKSB7XG4gICAgICAgIHdoaWxlIChiaXRTdGFydE9mZnNldCA8IDgpIHtcbiAgICAgICAgICBzd2l0Y2ggKGJpdFN0YXJ0T2Zmc2V0KSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIG5ld0FycmF5W2luZGV4XSA9IHRhcmdldEJ1ZmZlcltpXSAmIDB4MDAwMTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgIG5ld0FycmF5W2luZGV4XSA9IHRhcmdldEJ1ZmZlcltpXSA+Pj4gMSAmIDB4MDAwMTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgIG5ld0FycmF5W2luZGV4XSA9IHRhcmdldEJ1ZmZlcltpXSA+Pj4gMiAmIDB4MDAwMTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgIG5ld0FycmF5W2luZGV4XSA9IHRhcmdldEJ1ZmZlcltpXSA+Pj4gMyAmIDB4MDAwMTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgIG5ld0FycmF5W2luZGV4XSA9IHRhcmdldEJ1ZmZlcltpXSA+Pj4gNCAmIDB4MDAwMTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgIG5ld0FycmF5W2luZGV4XSA9IHRhcmdldEJ1ZmZlcltpXSA+Pj4gNSAmIDB4MDAwMTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgIG5ld0FycmF5W2luZGV4XSA9IHRhcmdldEJ1ZmZlcltpXSA+Pj4gNiAmIDB4MDAwMTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgIG5ld0FycmF5W2luZGV4XSA9IHRhcmdldEJ1ZmZlcltpXSA+Pj4gNyAmIDB4MDAwMTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBiaXRTdGFydE9mZnNldCsrO1xuICAgICAgICAgIGluZGV4Kys7XG4gICAgICAgICAgLy8gaWYgcmV0dXJuLi5cbiAgICAgICAgICBpZiAoaW5kZXggPj0gbnVtUGl4ZWxzKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3QXJyYXk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJpdFN0YXJ0T2Zmc2V0ID0gMDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBfY29udmVydENvbG9yU3BhY2UodW5jb21wcmVzc2VkRGF0YSkge1xuICAgIGxldCByZ2JEYXRhID0gbnVsbDtcbiAgICBsZXQgcGhvdG9tZXRyaWNJbnRlcnByZXRhdGlvbiA9IHRoaXMucGhvdG9tZXRyaWNJbnRlcnByZXRhdGlvbigpO1xuICAgIGxldCBwbGFuYXJDb25maWd1cmF0aW9uID0gdGhpcy5wbGFuYXJDb25maWd1cmF0aW9uKCk7XG5cbiAgICBpZiAocGhvdG9tZXRyaWNJbnRlcnByZXRhdGlvbiA9PT0gJ1JHQicgJiZcbiAgICAgICAgcGxhbmFyQ29uZmlndXJhdGlvbiA9PT0gMCkge1xuICAgICAgLy8gQUxMIEdPT0QsIEFMUkVBRFkgT1JERVJFRFxuICAgICAgLy8gcGxhbmFyIG9yIG5vbiBwbGFuYXIgcGxhbmFyQ29uZmlndXJhdGlvblxuICAgICAgcmdiRGF0YSA9IHVuY29tcHJlc3NlZERhdGE7XG4gICAgfSBlbHNlIGlmIChwaG90b21ldHJpY0ludGVycHJldGF0aW9uID09PSAnUkdCJyAmJlxuICAgICAgICBwbGFuYXJDb25maWd1cmF0aW9uID09PSAxKSB7XG4gICAgICBpZiAodW5jb21wcmVzc2VkRGF0YSBpbnN0YW5jZW9mIEludDhBcnJheSkge1xuICAgICAgICByZ2JEYXRhID0gbmV3IEludDhBcnJheSh1bmNvbXByZXNzZWREYXRhLmxlbmd0aCk7XG4gICAgICB9IGVsc2UgaWYgKHVuY29tcHJlc3NlZERhdGEgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICAgIHJnYkRhdGEgPSBuZXcgVWludDhBcnJheSh1bmNvbXByZXNzZWREYXRhLmxlbmd0aCk7XG4gICAgICB9IGVsc2UgaWYgKHVuY29tcHJlc3NlZERhdGEgaW5zdGFuY2VvZiBJbnQxNkFycmF5KSB7XG4gICAgICAgIHJnYkRhdGEgPSBuZXcgSW50MTZBcnJheSh1bmNvbXByZXNzZWREYXRhLmxlbmd0aCk7XG4gICAgICB9IGVsc2UgaWYgKHVuY29tcHJlc3NlZERhdGEgaW5zdGFuY2VvZiBVaW50MTZBcnJheSkge1xuICAgICAgICByZ2JEYXRhID0gbmV3IFVpbnQxNkFycmF5KHVuY29tcHJlc3NlZERhdGEubGVuZ3RoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93ICd1bnN1cG9ydGVkIHR5cGVkIGFycmF5OiAke3VuY29tcHJlc3NlZERhdGF9JztcbiAgICAgIH1cblxuICAgICAgbGV0IG51bVBpeGVscyA9IHVuY29tcHJlc3NlZERhdGEubGVuZ3RoIC8gMztcbiAgICAgIGxldCByZ2JhSW5kZXggPSAwO1xuICAgICAgbGV0IHJJbmRleCA9IDA7XG4gICAgICBsZXQgZ0luZGV4ID0gbnVtUGl4ZWxzO1xuICAgICAgbGV0IGJJbmRleCA9IG51bVBpeGVscyAqIDI7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bVBpeGVsczsgaSsrKSB7XG4gICAgICAgIHJnYkRhdGFbcmdiYUluZGV4KytdID0gdW5jb21wcmVzc2VkRGF0YVtySW5kZXgrK107IC8vIHJlZFxuICAgICAgICByZ2JEYXRhW3JnYmFJbmRleCsrXSA9IHVuY29tcHJlc3NlZERhdGFbZ0luZGV4KytdOyAvLyBncmVlblxuICAgICAgICByZ2JEYXRhW3JnYmFJbmRleCsrXSA9IHVuY29tcHJlc3NlZERhdGFbYkluZGV4KytdOyAvLyBibHVlXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwaG90b21ldHJpY0ludGVycHJldGF0aW9uID09PSAnWUJSX0ZVTEwnKSB7XG4gICAgICBpZiAodW5jb21wcmVzc2VkRGF0YSBpbnN0YW5jZW9mIEludDhBcnJheSkge1xuICAgICAgICByZ2JEYXRhID0gbmV3IEludDhBcnJheSh1bmNvbXByZXNzZWREYXRhLmxlbmd0aCk7XG4gICAgICB9IGVsc2UgaWYgKHVuY29tcHJlc3NlZERhdGEgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICAgIHJnYkRhdGEgPSBuZXcgVWludDhBcnJheSh1bmNvbXByZXNzZWREYXRhLmxlbmd0aCk7XG4gICAgICB9IGVsc2UgaWYgKHVuY29tcHJlc3NlZERhdGEgaW5zdGFuY2VvZiBJbnQxNkFycmF5KSB7XG4gICAgICAgIHJnYkRhdGEgPSBuZXcgSW50MTZBcnJheSh1bmNvbXByZXNzZWREYXRhLmxlbmd0aCk7XG4gICAgICB9IGVsc2UgaWYgKHVuY29tcHJlc3NlZERhdGEgaW5zdGFuY2VvZiBVaW50MTZBcnJheSkge1xuICAgICAgICByZ2JEYXRhID0gbmV3IFVpbnQxNkFycmF5KHVuY29tcHJlc3NlZERhdGEubGVuZ3RoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93ICd1bnN1cG9ydGVkIHR5cGVkIGFycmF5OiAke3VuY29tcHJlc3NlZERhdGF9JztcbiAgICAgIH1cblxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2NoYWZleS9jb3JuZXJzdG9uZVdBRE9JbWFnZUxvYWRlci9ibG9iL21hc3Rlci9zcmMvZGVjb2RlWUJSRnVsbC5qc1xuICAgICAgbGV0IG5QaXhlbHMgPSB1bmNvbXByZXNzZWREYXRhLmxlbmd0aCAvIDM7XG4gICAgICBsZXQgeWJySW5kZXggPSAwO1xuICAgICAgbGV0IHJnYmFJbmRleCA9IDA7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5QaXhlbHM7IGkrKykge1xuICAgICAgICBsZXQgeSA9IHVuY29tcHJlc3NlZERhdGFbeWJySW5kZXgrK107XG4gICAgICAgIGxldCBjYiA9IHVuY29tcHJlc3NlZERhdGFbeWJySW5kZXgrK107XG4gICAgICAgIGxldCBjciA9IHVuY29tcHJlc3NlZERhdGFbeWJySW5kZXgrK107XG4gICAgICAgIHJnYkRhdGFbcmdiYUluZGV4KytdID0geSArIDEuNDAyMDAgKiAoY3IgLSAxMjgpOy8vIHJlZFxuICAgICAgICByZ2JEYXRhW3JnYmFJbmRleCsrXSA9IHkgLSAwLjM0NDE0ICogKGNiIC0gMTI4KSAtIDAuNzE0MTQgKiAoY3IgLSAxMjgpOyAvLyBncmVlblxuICAgICAgICByZ2JEYXRhW3JnYmFJbmRleCsrXSA9IHkgKyAxLjc3MjAwICogKGNiIC0gMTI4KTsgLy8gYmx1ZVxuICAgICAgICAvLyByZ2JEYXRhW3JnYmFJbmRleCsrXSA9IDI1NTsgLy9hbHBoYVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyAncGhvdG9tZXRyaWMgaW50ZXJwb2xhdGlvbiBub3Qgc3VwcG9ydGVkOiAke3Bob3RvbWV0cmljSW50ZXJwcmV0YXRpb259JztcbiAgICB9XG5cbiAgICByZXR1cm4gcmdiRGF0YTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTd2FwIGJ5dGVzIGluIGZyYW1lLlxuICAgKi9cbiAgX3N3YXBGcmFtZShmcmFtZSkge1xuICAgIC8vIHN3YXAgYnl0ZXMgKCBpZiA4Yml0cyAoMWJ5dGUpLCBub3RoaW5nIHRvIHN3YXApXG4gICAgbGV0IGJpdHNBbGxvY2F0ZWQgPSB0aGlzLmJpdHNBbGxvY2F0ZWQoKTtcblxuICAgIGlmIChiaXRzQWxsb2NhdGVkID09PSAxNikge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmcmFtZS5sZW5ndGg7IGkrKykge1xuICAgICAgICBmcmFtZVtpXSA9IHRoaXMuX3N3YXAxNihmcmFtZVtpXSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChiaXRzQWxsb2NhdGVkID09PSAzMikge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmcmFtZS5sZW5ndGg7IGkrKykge1xuICAgICAgICBmcmFtZVtpXSA9IHRoaXMuX3N3YXAzMihmcmFtZVtpXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZyYW1lO1xuICB9XG5cbn1cblxuLy8gVkpTLnBhcnNlcnMuZGljb20ucHJvdG90eXBlLmZyYW1lT2ZSZWZlcmVuY2VVSUQgPSBmdW5jdGlvbihpbWFnZUpxdWVyeURvbSkge1xuLy8gICAvLyB0cnkgdG8gYWNjZXNzIGZyYW1lIG9mIHJlZmVyZW5jZSBVSUQgdGhyb3VnaCBpdHMgRElDT00gdGFnXG4vLyAgIGxldCBzZXJpZXNOdW1iZXIgPSBpbWFnZUpxdWVyeURvbS5maW5kKCdbdGFnPVwiMDAyMDAwNTJcIl0gVmFsdWUnKS50ZXh0KCk7XG5cbi8vICAgLy8gaWYgbm90IGF2YWlsYWJsZSwgYXNzdW1lIHdlIG9ubHkgaGF2ZSAxIGZyYW1lXG4vLyAgIGlmIChzZXJpZXNOdW1iZXIgPT09ICcnKSB7XG4vLyAgICAgc2VyaWVzTnVtYmVyID0gMTtcbi8vICAgfVxuLy8gICByZXR1cm4gc2VyaWVzTnVtYmVyO1xuLy8gfTtcblxuLy9cbi8vIEVORElBTiBORVNTIE5PVCBUQUtFTiBDQVJFIE9GXG4vLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzUzMjA0MzkvaG93LWRvLWktc3dhcC1lbmRpYW4tbmVzcy1ieXRlLW9yZGVyLW9mLWEtbGV0aWFibGUtaW4tamF2YXNjcmlwdFxuLy8gaHR0cDovL3d3dy5iYXJyZS5ub20uZnIvbWVkaWNhbC9zYW1wbGVzL1xuLy9cbi8vXG4iLCJpbXBvcnQgRGljb20gZnJvbSAnLi9wYXJzZXJzLmRpY29tJztcbmltcG9ydCBOaWZ0aSBmcm9tICcuL3BhcnNlcnMubmlmdGknO1xuaW1wb3J0IE5ycmQgZnJvbSAnLi9wYXJzZXJzLm5ycmQnO1xuXG4vKipcbiAqIEBtb2R1bGUgcGFyc2Vyc1xuICovXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgRGljb20sXG4gIE5pZnRpLFxuICBOcnJkLFxufTtcbiIsIi8qKiAqIEltcG9ydHMgKioqL1xuaW1wb3J0IFBhcnNlcnNWb2x1bWUgZnJvbSAnLi9wYXJzZXJzLnZvbHVtZSc7XG5cbi8qKlxuICogQG1vZHVsZSBwYXJzZXJzL21oZFxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQYXJzZXJzTUhEIGV4dGVuZHMgUGFyc2Vyc1ZvbHVtZSB7XG4gIGNvbnN0cnVjdG9yKGRhdGEsIGlkKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIC8qKlxuICAgICAgKiBAbWVtYmVyXG4gICAgICAqIEB0eXBlIHthcnJheWJ1ZmZlcn1cbiAgICAqL1xuICAgIHRoaXMuX2lkID0gaWQ7XG4gICAgdGhpcy5fdXJsID0gZGF0YS51cmw7XG4gICAgdGhpcy5faGVhZGVyID0ge307XG4gICAgdGhpcy5fYnVmZmVyID0gbnVsbDtcblxuICAgIHRyeSB7XG4gICAgICAvLyBwYXJzZSBoZWFkZXIgKG1oZCkgZGF0YVxuICAgICAgbGV0IGxpbmVzID0gbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKGRhdGEubWhkQnVmZmVyKS5zcGxpdCgnXFxuJyk7XG4gICAgICBsaW5lcy5mb3JFYWNoKChsaW5lKSA9PiB7XG4gICAgICAgICAgbGV0IGtleXZhbHVlID0gbGluZS5zcGxpdCgnPScpO1xuICAgICAgICAgIGlmIChrZXl2YWx1ZS5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgIHRoaXMuX2hlYWRlcltrZXl2YWx1ZVswXS50cmltKCldID0ga2V5dmFsdWVbMV0udHJpbSgpO1xuICAgICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLl9oZWFkZXIuRGltU2l6ZSA9IHRoaXMuX2hlYWRlci5EaW1TaXplLnNwbGl0KCcgJyk7XG4gICAgICB0aGlzLl9oZWFkZXIuRWxlbWVudFNwYWNpbmcgPSB0aGlzLl9oZWFkZXIuRWxlbWVudFNwYWNpbmcuc3BsaXQoJyAnKTtcbiAgICAgIHRoaXMuX2hlYWRlci5UcmFuc2Zvcm1NYXRyaXggPSB0aGlzLl9oZWFkZXIuVHJhbnNmb3JtTWF0cml4LnNwbGl0KCcgJyk7XG4gICAgICB0aGlzLl9oZWFkZXIuT2Zmc2V0ID0gdGhpcy5faGVhZGVyLk9mZnNldC5zcGxpdCgnICcpO1xuICAgICAgLy9cbiAgICAgIHRoaXMuX2J1ZmZlciA9IGRhdGEucmF3QnVmZmVyO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB3aW5kb3cuY29uc29sZS5sb2coJ29vb3BzLi4uIDooJyk7XG4gICAgfVxuICB9XG5cbiAgcmlnaHRIYW5kZWQoKSB7XG4gICAgbGV0IGFuYXRvbWljYWxPcmllbnRhdGlvbiA9IHRoaXMuX2hlYWRlci5BbmF0b21pY2FsT3JpZW50YXRpb247XG4gICAgaWYgKGFuYXRvbWljYWxPcmllbnRhdGlvbiA9PT0gJ1JBUycgfHxcbiAgICAgICAgYW5hdG9taWNhbE9yaWVudGF0aW9uID09PSAnUlBJJyB8fFxuICAgICAgICBhbmF0b21pY2FsT3JpZW50YXRpb24gPT09ICdMUFMnIHx8XG4gICAgICAgIGFuYXRvbWljYWxPcmllbnRhdGlvbiA9PT0gJ0xBSScpIHtcbiAgICAgIHRoaXMuX3JpZ2h0SGFuZGVkID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fcmlnaHRIYW5kZWQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fcmlnaHRIYW5kZWQ7XG4gIH1cblxuICBzZXJpZXNJbnN0YW5jZVVJRCgpIHtcbiAgICAvLyB1c2UgZmlsZW5hbWUgKyB0aW1lc3RhbXAuLj9cbiAgICByZXR1cm4gdGhpcy5fdXJsO1xuICB9XG5cbiAgbnVtYmVyT2ZGcmFtZXMoKSB7XG4gICAgcmV0dXJuIHBhcnNlSW50KHRoaXMuX2hlYWRlci5EaW1TaXplWzJdLCAxMCk7XG4gIH1cblxuICBzb3BJbnN0YW5jZVVJRChmcmFtZUluZGV4ID0gMCkge1xuICAgIHJldHVybiBmcmFtZUluZGV4O1xuICB9XG5cbiAgcm93cyhmcmFtZUluZGV4ID0gMCkge1xuICAgIHJldHVybiBwYXJzZUludCh0aGlzLl9oZWFkZXIuRGltU2l6ZVsxXSwgMTApO1xuICB9XG5cbiAgY29sdW1ucyhmcmFtZUluZGV4ID0gMCkge1xuICAgIHJldHVybiBwYXJzZUludCh0aGlzLl9oZWFkZXIuRGltU2l6ZVswXSwgMTApO1xuICB9XG5cbiAgcGl4ZWxUeXBlKGZyYW1lSW5kZXggPSAwKSB7XG4gICAgLy8gMCAtIGludFxuICAgIC8vIDEgLSBmbG9hdFxuICAgIHJldHVybiAwO1xuICB9XG5cbiAgYml0c0FsbG9jYXRlZChmcmFtZUluZGV4ID0gMCkge1xuICAgIGxldCBiaXRzQWxsb2NhdGVkID0gMTtcblxuICAgIGlmICh0aGlzLl9oZWFkZXIuRWxlbWVudFR5cGUgPT09ICdNRVRfVUNIQVInIHx8XG4gICAgICAgIHRoaXMuX2hlYWRlci5FbGVtZW50VHlwZSA9PT0gJ01FVF9DSEFSJykge1xuICAgICAgYml0c0FsbG9jYXRlZCA9IDg7XG4gICAgfSBlbHNlIGlmIChcbiAgICAgICAgdGhpcy5faGVhZGVyLkVsZW1lbnRUeXBlID09PSAnTUVUX1VTSE9SVCcgfHxcbiAgICAgICAgdGhpcy5faGVhZGVyLkVsZW1lbnRUeXBlID09PSAnTUVUX1NIT1JUJykge1xuICAgICAgYml0c0FsbG9jYXRlZCA9IDE2O1xuICAgIH0gZWxzZSBpZiAoXG4gICAgICAgIHRoaXMuX2hlYWRlci5FbGVtZW50VHlwZSA9PT0gJ01FVF9VRkxPQVQnIHx8XG4gICAgICAgIHRoaXMuX2hlYWRlci5FbGVtZW50VHlwZSA9PT0gJ01FVF9GTE9BVCcpIHtcbiAgICAgIGJpdHNBbGxvY2F0ZWQgPSAzMjtcbiAgICB9XG5cbiAgICByZXR1cm4gYml0c0FsbG9jYXRlZDtcbiAgfVxuXG4gIHBpeGVsU3BhY2luZyhmcmFtZUluZGV4ID0gMCkge1xuICAgIGxldCB4ID0gcGFyc2VGbG9hdCh0aGlzLl9oZWFkZXIuRWxlbWVudFNwYWNpbmdbMF0sIDEwKTtcbiAgICBsZXQgeSA9IHBhcnNlRmxvYXQodGhpcy5faGVhZGVyLkVsZW1lbnRTcGFjaW5nWzFdLCAxMCk7XG4gICAgbGV0IHogPSBwYXJzZUZsb2F0KHRoaXMuX2hlYWRlci5FbGVtZW50U3BhY2luZ1syXSwgMTApO1xuICAgIHJldHVybiBbeCwgeSwgel07XG4gIH1cblxuICBpbWFnZU9yaWVudGF0aW9uKGZyYW1lSW5kZXggPSAwKSB7XG4gICAgbGV0IGludmVydFggPSB0aGlzLl9oZWFkZXIuQW5hdG9taWNhbE9yaWVudGF0aW9uLm1hdGNoKC9MLykgPyAtMSA6IDE7XG4gICAgbGV0IGludmVydFkgPSB0aGlzLl9oZWFkZXIuQW5hdG9taWNhbE9yaWVudGF0aW9uLm1hdGNoKC9QLykgPyAtMSA6IDE7XG5cbiAgICBsZXQgeCA9IG5ldyBUSFJFRS5WZWN0b3IzKFxuICAgICAgcGFyc2VGbG9hdCh0aGlzLl9oZWFkZXIuVHJhbnNmb3JtTWF0cml4WzBdKSAqIGludmVydFgsXG4gICAgICBwYXJzZUZsb2F0KHRoaXMuX2hlYWRlci5UcmFuc2Zvcm1NYXRyaXhbMV0pICogaW52ZXJ0WSxcbiAgICAgIHBhcnNlRmxvYXQodGhpcy5faGVhZGVyLlRyYW5zZm9ybU1hdHJpeFsyXSkpO1xuICAgIHgubm9ybWFsaXplKCk7XG5cbiAgICBsZXQgeSA9IG5ldyBUSFJFRS5WZWN0b3IzKFxuICAgICAgcGFyc2VGbG9hdCh0aGlzLl9oZWFkZXIuVHJhbnNmb3JtTWF0cml4WzNdKSAqIGludmVydFgsXG4gICAgICBwYXJzZUZsb2F0KHRoaXMuX2hlYWRlci5UcmFuc2Zvcm1NYXRyaXhbNF0pICogaW52ZXJ0WSxcbiAgICAgIHBhcnNlRmxvYXQodGhpcy5faGVhZGVyLlRyYW5zZm9ybU1hdHJpeFs1XSkpO1xuICAgIHkubm9ybWFsaXplKCk7XG5cbiAgICByZXR1cm4gW1xuICAgICAgeC54LCB4LnksIHgueixcbiAgICAgIHkueCwgeS55LCB5LnosXG4gICAgICBdO1xuICB9XG5cbiAgaW1hZ2VQb3NpdGlvbihmcmFtZUluZGV4ID0gMCkge1xuICAgIHJldHVybiBbXG4gICAgICBwYXJzZUZsb2F0KHRoaXMuX2hlYWRlci5PZmZzZXRbMF0pLFxuICAgICAgcGFyc2VGbG9hdCh0aGlzLl9oZWFkZXIuT2Zmc2V0WzFdKSxcbiAgICAgIHBhcnNlRmxvYXQodGhpcy5faGVhZGVyLk9mZnNldFsyXSksXG4gICAgXTtcbiAgfVxuXG4gIG1pbk1heFBpeGVsRGF0YShwaXhlbERhdGEgPSBbXSkge1xuICAgIGxldCBtaW5NYXggPSBbNjU1MzUsIC0zMjc2OF07XG4gICAgbGV0IG51bVBpeGVscyA9IHBpeGVsRGF0YS5sZW5ndGg7XG4gICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IG51bVBpeGVsczsgaW5kZXgrKykge1xuICAgICAgbGV0IHNwdiA9IHBpeGVsRGF0YVtpbmRleF07XG4gICAgICBtaW5NYXhbMF0gPSBNYXRoLm1pbihtaW5NYXhbMF0sIHNwdik7XG4gICAgICBtaW5NYXhbMV0gPSBNYXRoLm1heChtaW5NYXhbMV0sIHNwdik7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1pbk1heDtcbiAgfVxuXG4gIGV4dHJhY3RQaXhlbERhdGEoZnJhbWVJbmRleCA9IDApIHtcbiAgICByZXR1cm4gdGhpcy5fZGVjb21wcmVzc1VuY29tcHJlc3NlZChmcmFtZUluZGV4KTtcbiAgfVxuXG4gIF9kZWNvbXByZXNzVW5jb21wcmVzc2VkKGZyYW1lSW5kZXggPSAwKSB7XG4gICAgbGV0IGJ1ZmZlciA9IHRoaXMuX2J1ZmZlcjtcbiAgICBsZXQgbnVtYmVyT2ZDaGFubmVscyA9IHRoaXMubnVtYmVyT2ZDaGFubmVscygpO1xuICAgIGxldCBudW1QaXhlbHMgPVxuICAgICAgdGhpcy5yb3dzKGZyYW1lSW5kZXgpICogdGhpcy5jb2x1bW5zKGZyYW1lSW5kZXgpICogbnVtYmVyT2ZDaGFubmVscztcbiAgICBpZiAoIXRoaXMucmlnaHRIYW5kZWQoKSkge1xuICAgICAgZnJhbWVJbmRleCA9IHRoaXMubnVtYmVyT2ZGcmFtZXMoKSAtIDEgLSBmcmFtZUluZGV4O1xuICAgIH1cbiAgICBsZXQgZnJhbWVPZmZzZXQgPSBmcmFtZUluZGV4ICogbnVtUGl4ZWxzO1xuXG4gICAgaWYgKHRoaXMuX2hlYWRlci5FbGVtZW50VHlwZSA9PT0gJ01FVF9DSEFSJykge1xuICAgICAgZnJhbWVPZmZzZXQgPSBmcmFtZU9mZnNldDtcbiAgICAgIHJldHVybiBuZXcgSW50OEFycmF5KGJ1ZmZlciwgZnJhbWVPZmZzZXQsIG51bVBpeGVscyk7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9oZWFkZXIuRWxlbWVudFR5cGUgPT09ICdNRVRfVUNIQVInKSB7XG4gICAgICBmcmFtZU9mZnNldCA9IGZyYW1lT2Zmc2V0O1xuICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGJ1ZmZlciwgZnJhbWVPZmZzZXQsIG51bVBpeGVscyk7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9oZWFkZXIuRWxlbWVudFR5cGUgPT09ICdNRVRfU0hPUlQnKSB7XG4gICAgICBmcmFtZU9mZnNldCA9IGZyYW1lT2Zmc2V0ICogMjtcbiAgICAgIHJldHVybiBuZXcgSW50MTZBcnJheShidWZmZXIsIGZyYW1lT2Zmc2V0LCBudW1QaXhlbHMpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5faGVhZGVyLkVsZW1lbnRUeXBlID09PSAnTUVUX1VTSE9SVCcpIHtcbiAgICAgIGZyYW1lT2Zmc2V0ID0gZnJhbWVPZmZzZXQgKiAyO1xuICAgICAgcmV0dXJuIG5ldyBVaW50MTZBcnJheShidWZmZXIsIGZyYW1lT2Zmc2V0LCBudW1QaXhlbHMpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5faGVhZGVyLkVsZW1lbnRUeXBlID09PSAnTUVUX0ZMT0FUJykge1xuICAgICAgZnJhbWVPZmZzZXQgPSBmcmFtZU9mZnNldCAqIDQ7XG4gICAgICByZXR1cm4gbmV3IEZsb2F0MzJBcnJheShidWZmZXIsIGZyYW1lT2Zmc2V0LCBudW1QaXhlbHMpO1xuICAgIH1cbiAgfVxufVxuIiwiLy8gdXNlIG5pZnRpLWpzIGFuZCBqdXN0IHBhcnNlIGhlYWRlci4/Pz9cblxuLy8gU2xpY2VyIHdheSB0byBoYW5kbGUgaW1hZ2VzXG4vLyBzaG91bGQgZm9sbG93IGl0Li4uXG4gLy8gODk3ICAgaWYgKCAodGhpcy0+SW5kZXhTZXJpZXNJbnN0YW5jZVVJRHNba10gIT0gaWR4U2VyaWVzSW5zdGFuY2VVSUQgJiYgdGhpcy0+SW5kZXhTZXJpZXNJbnN0YW5jZVVJRHNba10gPj0gMCAmJiBpZHhTZXJpZXNJbnN0YW5jZVVJRCA+PSAwKSB8fFxuIC8vIDg5OCAgICAgICAgKHRoaXMtPkluZGV4Q29udGVudFRpbWVba10gIT0gaWR4Q29udGVudFRpbWUgJiYgdGhpcy0+SW5kZXhDb250ZW50VGltZVtrXSA+PSAwICYmIGlkeENvbnRlbnRUaW1lID49IDApIHx8XG4gLy8gODk5ICAgICAgICAodGhpcy0+SW5kZXhUcmlnZ2VyVGltZVtrXSAhPSBpZHhUcmlnZ2VyVGltZSAmJiB0aGlzLT5JbmRleFRyaWdnZXJUaW1lW2tdID49IDAgJiYgaWR4VHJpZ2dlclRpbWUgPj0gMCkgfHxcbiAvLyA5MDAgICAgICAgICh0aGlzLT5JbmRleEVjaG9OdW1iZXJzW2tdICE9IGlkeEVjaG9OdW1iZXJzICYmIHRoaXMtPkluZGV4RWNob051bWJlcnNba10gPj0gMCAmJiBpZHhFY2hvTnVtYmVycyA+PSAwKSB8fFxuIC8vIDkwMSAgICAgICAgKHRoaXMtPkluZGV4RGlmZnVzaW9uR3JhZGllbnRPcmllbnRhdGlvbltrXSAhPSBpZHhEaWZmdXNpb25HcmFkaWVudE9yaWVudGF0aW9uICAmJiB0aGlzLT5JbmRleERpZmZ1c2lvbkdyYWRpZW50T3JpZW50YXRpb25ba10gPj0gMCAmJiBpZHhEaWZmdXNpb25HcmFkaWVudE9yaWVudGF0aW9uID49IDApIHx8XG4gLy8gOTAyICAgICAgICAodGhpcy0+SW5kZXhTbGljZUxvY2F0aW9uW2tdICE9IGlkeFNsaWNlTG9jYXRpb24gJiYgdGhpcy0+SW5kZXhTbGljZUxvY2F0aW9uW2tdID49IDAgJiYgaWR4U2xpY2VMb2NhdGlvbiA+PSAwKSB8fFxuIC8vIDkwMyAgICAgICAgKHRoaXMtPkluZGV4SW1hZ2VPcmllbnRhdGlvblBhdGllbnRba10gIT0gaWR4SW1hZ2VPcmllbnRhdGlvblBhdGllbnQgJiYgdGhpcy0+SW5kZXhJbWFnZU9yaWVudGF0aW9uUGF0aWVudFtrXSA+PSAwICYmIGlkeEltYWdlT3JpZW50YXRpb25QYXRpZW50ID49IDApIClcbiAvLyA5MDQgICAgIHtcbiAvLyA5MDUgICAgICAgY29udGludWU7XG4gLy8gOTA2ICAgICB9XG5cbi8vIGh0dHA6Ly9icmFpbmRlci5vcmcvMjAxMi8wOS8yMy90aGUtbmlmdGktZmlsZS1mb3JtYXQvXG5cbi8qKiAqIEltcG9ydHMgKioqL1xuaW1wb3J0IFBhcnNlcnNWb2x1bWUgZnJvbSAnLi9wYXJzZXJzLnZvbHVtZSc7XG5cbmxldCBOaWZ0aVJlYWRlciA9IHJlcXVpcmUoJ25pZnRpLXJlYWRlci1qcycpO1xuLyoqXG4gKiBAbW9kdWxlIHBhcnNlcnMvbmlmdGlcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUGFyc2Vyc05pZnRpIGV4dGVuZHMgUGFyc2Vyc1ZvbHVtZSB7XG4gIGNvbnN0cnVjdG9yKGRhdGEsIGlkKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIC8qKlxuICAgICAgKiBAbWVtYmVyXG4gICAgICAqIEB0eXBlIHthcnJheWJ1ZmZlcn1cbiAgICAqL1xuICAgIHRoaXMuX2lkID0gaWQ7XG4gICAgdGhpcy5fYXJyYXlCdWZmZXIgPSBkYXRhLmJ1ZmZlcjtcbiAgICB0aGlzLl91cmwgPSBkYXRhLnVybDtcbiAgICB0aGlzLl9kYXRhU2V0ID0gbnVsbDtcbiAgICB0aGlzLl9uaWZ0aUhlYWRlciA9IG51bGw7XG4gICAgdGhpcy5fbmlmdGlJbWFnZSA9IG51bGw7XG4gICAgdGhpcy5fb3JkZXJlZCA9IHRydWU7XG4gICAgdGhpcy5fb3JkZXJlZERhdGEgPSBudWxsO1xuXG4gICAgLy9cbiAgICB0aGlzLl9xZmFjID0gMS4wO1xuXG4gICAgaWYgKE5pZnRpUmVhZGVyLmlzTklGVEkodGhpcy5fYXJyYXlCdWZmZXIpKSB7XG4gICAgICB0aGlzLl9kYXRhU2V0ID0gTmlmdGlSZWFkZXIucmVhZEhlYWRlcih0aGlzLl9hcnJheUJ1ZmZlcik7XG4gICAgICB0aGlzLl9uaWZ0aUltYWdlID1cbiAgICAgICAgTmlmdGlSZWFkZXIucmVhZEltYWdlKHRoaXMuX2RhdGFTZXQsIHRoaXMuX2FycmF5QnVmZmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgJ3BhcnNlcnMubmlmdGkgY291bGQgbm90IHBhcnNlIHRoZSBmaWxlJztcbiAgICB9XG4gIH1cblxuICBzZXJpZXNJbnN0YW5jZVVJRCgpIHtcbiAgICAvLyB1c2UgZmlsZW5hbWUgKyB0aW1lc3RhbXAuLj9cbiAgICByZXR1cm4gdGhpcy5fdXJsO1xuICB9XG5cbiAgbnVtYmVyT2ZGcmFtZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGFTZXQuZGltc1szXTtcbiAgfVxuXG4gIG51bWJlck9mQ2hhbm5lbHMoKSB7XG4gICAgbGV0IG51bWJlck9mQ2hhbm5lbHMgPSAxO1xuXG4gICAgLy8gY2FuIGRpbXNbMF0gPj0gNSBhbmQgbm90IG11bHRpIGNoYW5uZWxzIHdpdGggUkdCIGRhdGF0eXBlY29kZT9cblxuICAgIGlmICh0aGlzLl9kYXRhU2V0LmRpbXNbMF0gPj0gNSkge1xuICAgICAgbnVtYmVyT2ZDaGFubmVscyA9IHRoaXMuX2RhdGFTZXQuZGltc1s1XTtcbiAgICAgIHRoaXMuX29yZGVyZWQgPSBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX2RhdGFTZXQuZGF0YXR5cGVDb2RlID09PSAxMjgpIHtcbiAgICAgIG51bWJlck9mQ2hhbm5lbHMgPSAzO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fZGF0YVNldC5kYXRhdHlwZUNvZGUgPT09IDIzMDQpIHtcbiAgICAgIG51bWJlck9mQ2hhbm5lbHMgPSA0O1xuICAgIH1cblxuICAgIHJldHVybiBudW1iZXJPZkNoYW5uZWxzO1xuICB9XG5cbiAgc29wSW5zdGFuY2VVSUQoZnJhbWVJbmRleCA9IDApIHtcbiAgICByZXR1cm4gZnJhbWVJbmRleDtcbiAgfVxuXG4gIHJvd3MoZnJhbWVJbmRleCA9IDApIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YVNldC5kaW1zWzJdO1xuICB9XG5cbiAgY29sdW1ucyhmcmFtZUluZGV4ID0gMCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRhU2V0LmRpbXNbMV07XG4gIH1cblxuICBwaXhlbFR5cGUoZnJhbWVJbmRleCA9IDApIHtcbiAgICAgICAgLy8gcGFwYXlhLnZvbHVtZS5uaWZ0aS5OSUZUSV9UWVBFX1VJTlQ4ICAgICAgICAgICA9IDI7XG4gICAgLy8gcGFwYXlhLnZvbHVtZS5uaWZ0aS5OSUZUSV9UWVBFX0lOVDE2ICAgICAgICAgICA9IDQ7XG4gICAgLy8gcGFwYXlhLnZvbHVtZS5uaWZ0aS5OSUZUSV9UWVBFX0lOVDMyICAgICAgICAgICA9IDg7XG4gICAgLy8gcGFwYXlhLnZvbHVtZS5uaWZ0aS5OSUZUSV9UWVBFX0ZMT0FUMzIgICAgICAgID0gMTY7XG4gICAgLy8gcGFwYXlhLnZvbHVtZS5uaWZ0aS5OSUZUSV9UWVBFX0NPTVBMRVg2NCAgICAgID0gMzI7XG4gICAgLy8gcGFwYXlhLnZvbHVtZS5uaWZ0aS5OSUZUSV9UWVBFX0ZMT0FUNjQgICAgICAgID0gNjQ7XG4gICAgLy8gcGFwYXlhLnZvbHVtZS5uaWZ0aS5OSUZUSV9UWVBFX1JHQjI0ICAgICAgICAgPSAxMjg7XG4gICAgLy8gcGFwYXlhLnZvbHVtZS5uaWZ0aS5OSUZUSV9UWVBFX0lOVDggICAgICAgICAgPSAyNTY7XG4gICAgLy8gcGFwYXlhLnZvbHVtZS5uaWZ0aS5OSUZUSV9UWVBFX1VJTlQxNiAgICAgICAgPSA1MTI7XG4gICAgLy8gcGFwYXlhLnZvbHVtZS5uaWZ0aS5OSUZUSV9UWVBFX1VJTlQzMiAgICAgICAgPSA3Njg7XG4gICAgLy8gcGFwYXlhLnZvbHVtZS5uaWZ0aS5OSUZUSV9UWVBFX0lOVDY0ICAgICAgICA9IDEwMjQ7XG4gICAgLy8gcGFwYXlhLnZvbHVtZS5uaWZ0aS5OSUZUSV9UWVBFX1VJTlQ2NCAgICAgICA9IDEyODA7XG4gICAgLy8gcGFwYXlhLnZvbHVtZS5uaWZ0aS5OSUZUSV9UWVBFX0ZMT0FUMTI4ICAgICA9IDE1MzY7XG4gICAgLy8gcGFwYXlhLnZvbHVtZS5uaWZ0aS5OSUZUSV9UWVBFX0NPTVBMRVgxMjggICA9IDE3OTI7XG4gICAgLy8gcGFwYXlhLnZvbHVtZS5uaWZ0aS5OSUZUSV9UWVBFX0NPTVBMRVgyNTYgICA9IDIwNDg7XG5cbiAgICAvLyAwIGludGVnZXIsIDEgZmxvYXRcblxuICAgIGxldCBwaXhlbFR5cGUgPSAwO1xuICAgIGlmICh0aGlzLl9kYXRhU2V0LmRhdGF0eXBlQ29kZSA9PT0gMTYgfHxcbiAgICAgIHRoaXMuX2RhdGFTZXQuZGF0YXR5cGVDb2RlID09PSA2NCB8fFxuICAgICAgdGhpcy5fZGF0YVNldC5kYXRhdHlwZUNvZGUgPT09IDE1MzYpIHtcbiAgICAgIHBpeGVsVHlwZSA9IDE7XG4gICAgfVxuICAgIHJldHVybiBwaXhlbFR5cGU7XG4gIH1cblxuICBiaXRzQWxsb2NhdGVkKGZyYW1lSW5kZXggPSAwKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGFTZXQubnVtQml0c1BlclZveGVsO1xuICB9XG5cbiAgcGl4ZWxTcGFjaW5nKGZyYW1lSW5kZXggPSAwKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIHRoaXMuX2RhdGFTZXQucGl4RGltc1sxXSxcbiAgICAgIHRoaXMuX2RhdGFTZXQucGl4RGltc1syXSxcbiAgICAgIHRoaXMuX2RhdGFTZXQucGl4RGltc1szXSxcbiAgICAgIF07XG4gIH1cblxuICBzbGljZVRoaWNrbmVzcygpIHtcbiAgICAvLyBzaG91bGQgYmUgYSBzdHJpbmcuLi5cbiAgICByZXR1cm4gbnVsbDsvLyB0aGlzLl9kYXRhU2V0LnBpeERpbXNbM10udG9TdHJpbmcoKTtcbiAgfVxuXG4gIGltYWdlT3JpZW50YXRpb24oZnJhbWVJbmRleCA9IDApIHtcbiAgICAvLyB3aW5kb3cuY29uc29sZS5sb2codGhpcy5fZGF0YVNldCk7XG4gICAgLy8gaHR0cDovL25pZnRpLm5pbWgubmloLmdvdi9wdWIvZGlzdC9zcmMvbmlmdGlsaWIvbmlmdGkxLmhcbiAgICAvLyBodHRwOi8vbmlmdGkubmltaC5uaWguZ292L3B1Yi9kaXN0L3NyYy9uaWZ0aWxpYi9uaWZ0aTFfaW8uY1xuICAgIGlmICh0aGlzLl9kYXRhU2V0LnFmb3JtX2NvZGUgPiAwKSB7XG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vS2l0d2FyZS9JVEsvYmxvYi9tYXN0ZXIvTW9kdWxlcy9JTy9OSUZUSS9zcmMvaXRrTmlmdGlJbWFnZUlPLmN4eFxuICAgICAgbGV0IGEgPSAwLjA7XG4gICAgICBsZXQgYiA9IHRoaXMuX2RhdGFTZXQucXVhdGVybl9iO1xuICAgICAgbGV0IGMgPSB0aGlzLl9kYXRhU2V0LnF1YXRlcm5fYztcbiAgICAgIGxldCBkID0gdGhpcy5fZGF0YVNldC5xdWF0ZXJuX2Q7XG4gICAgICAvLyBjb21wdXRlIGFcbiAgICAgIGEgPSAxLjAgLSAoYipiICsgYypjICsgZCpkKTtcbiAgICAgIGlmIChhIDwgMC4wMDAwMDAxKSB7XG4gICAgICAgICAgICAgICAgICAgLyogc3BlY2lhbCBjYXNlICovXG5cbiAgICAgICAgYSA9IDEuMCAvIE1hdGguc3FydChiKmIrYypjK2QqZCk7XG4gICAgICAgIGIgKj0gYTsgYyAqPSBhOyBkICo9IGE7ICAgICAgICAvKiBub3JtYWxpemUgKGIsYyxkKSB2ZWN0b3IgKi9cbiAgICAgICAgYSA9IDAuMDsgICAgICAgICAgICAgICAgICAgICAgIC8qIGEgPSAwID09PiAxODAgZGVncmVlIHJvdGF0aW9uICovXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhID0gTWF0aC5zcXJ0KGEpOyAgICAgICAgICAgICAgICAgICAgIC8qIGFuZ2xlID0gMiphcmNjb3MoYSkgKi9cbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX2RhdGFTZXQucGl4RGltc1swXSA8IDAuMCkge1xuICAgICAgICB0aGlzLl9yaWdodEhhbmRlZCA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAtKGEqYStiKmItYypjLWQqZCksXG4gICAgICAgICAgLTIqKGIqYythKmQpLFxuICAgICAgICAgIDIqKGIqZC1hKmMpLFxuICAgICAgICAgIC0yKihiKmMtYSpkKSxcbiAgICAgICAgICAtKGEqYStjKmMtYipiLWQqZCksXG4gICAgICAgICAgMiooYypkK2EqYiksXG4gICAgICAgIF07XG4gICAgfSBlbHNlIGlmICh0aGlzLl9kYXRhU2V0LnNmb3JtX2NvZGUgPiAwKSB7XG4gICAgICBjb25zb2xlLmxvZygnc2Zvcm0gPiAwJyk7XG5cbiAgICAgIGxldCBzeCA9IHRoaXMuX2RhdGFTZXQuc3Jvd194O1xuICAgICAgbGV0IHN5ID0gdGhpcy5fZGF0YVNldC5zcm93X3k7XG4gICAgICBsZXQgc3ogPSB0aGlzLl9kYXRhU2V0LnNyb3dfejtcbiAgICAgIC8vIGZpbGwgSUpLVG9SQVNcbiAgICAgIC8vIGdvb2cudmVjLk1hdDQuc2V0Um93VmFsdWVzKElKS1RvUkFTLCAwLCBzeFswXSwgc3hbMV0sIHN4WzJdLCBzeFszXSk7XG4gICAgICAvLyBnb29nLnZlYy5NYXQ0LnNldFJvd1ZhbHVlcyhJSktUb1JBUywgMSwgc3lbMF0sIHN5WzFdLCBzeVsyXSwgc3lbM10pO1xuICAgICAgLy8gZ29vZy52ZWMuTWF0NC5zZXRSb3dWYWx1ZXMoSUpLVG9SQVMsIDIsIHN6WzBdLCBzelsxXSwgc3pbMl0sIHN6WzNdKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX2RhdGFTZXQucWZvcm1fY29kZSA9PT0gMCkge1xuICAgICAgY29uc29sZS5sb2coJ3Fmb3JtID09PSAwJyk7XG5cblxuICAgICAgLy8gZmlsbCBJSktUb1JBU1xuICAgICAgLy8gZ29vZy52ZWMuTWF0NC5zZXRSb3dWYWx1ZXMoSUpLVG9SQVMsIDAsIE1SSS5waXhkaW1bMV0sIDAsIDAsIDApO1xuICAgICAgLy8gZ29vZy52ZWMuTWF0NC5zZXRSb3dWYWx1ZXMoSUpLVG9SQVMsIDEsIDAsIE1SSS5waXhkaW1bMl0sIDAsIDApO1xuICAgICAgLy8gZ29vZy52ZWMuTWF0NC5zZXRSb3dWYWx1ZXMoSUpLVG9SQVMsIDIsIDAsIDAsIE1SSS5waXhkaW1bM10sIDApO1xuICAgIH1cbiAgICByZXR1cm4gWzEsIDAsIDAsIDAsIDEsIDBdO1xuICB9XG5cbiAgaW1hZ2VQb3NpdGlvbihmcmFtZUluZGV4ID0gMCkge1xuICAgIC8vIHFvZmZzZXQgaXMgUkFTXG4gICAgcmV0dXJuIFtcbiAgICAgIC10aGlzLl9kYXRhU2V0LnFvZmZzZXRfeCxcbiAgICAgIC10aGlzLl9kYXRhU2V0LnFvZmZzZXRfeSxcbiAgICAgIHRoaXMuX2RhdGFTZXQucW9mZnNldF96LFxuICAgIF07XG4gIH1cblxuICBkaW1lbnNpb25JbmRleFZhbHVlcyhmcmFtZUluZGV4ID0gMCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaW5zdGFuY2VOdW1iZXIoZnJhbWVJbmRleCA9IDApIHtcbiAgICByZXR1cm4gZnJhbWVJbmRleDtcbiAgfVxuXG4gIHdpbmRvd0NlbnRlcihmcmFtZUluZGV4ID0gMCkge1xuICAgIC8vIGNhbGMgbWluIGFuZCBjYWxjIG1heFxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgd2luZG93V2lkdGgoZnJhbWVJbmRleCA9IDApIHtcbiAgICAvLyBjYWxjIG1pbiBhbmQgY2FsYyBtYXhcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJlc2NhbGVTbG9wZShmcmFtZUluZGV4ID0gMCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRhU2V0LnNjbF9zbG9wZTtcbiAgfVxuXG4gIHJlc2NhbGVJbnRlcmNlcHQoZnJhbWVJbmRleCA9IDApIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YVNldC5zY2xfaW50ZXJjZXB0O1xuICB9XG5cbiAgbWluTWF4UGl4ZWxEYXRhKHBpeGVsRGF0YSA9IFtdKSB7XG4gICAgbGV0IG1pbk1heCA9IFs2NTUzNSwgLTMyNzY4XTtcbiAgICBsZXQgbnVtUGl4ZWxzID0gcGl4ZWxEYXRhLmxlbmd0aDtcbiAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgbnVtUGl4ZWxzOyBpbmRleCsrKSB7XG4gICAgICBsZXQgc3B2ID0gcGl4ZWxEYXRhW2luZGV4XTtcbiAgICAgIG1pbk1heFswXSA9IE1hdGgubWluKG1pbk1heFswXSwgc3B2KTtcbiAgICAgIG1pbk1heFsxXSA9IE1hdGgubWF4KG1pbk1heFsxXSwgc3B2KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbWluTWF4O1xuICB9XG5cbiAgZXh0cmFjdFBpeGVsRGF0YShmcmFtZUluZGV4ID0gMCkge1xuICAgIHJldHVybiB0aGlzLl9kZWNvbXByZXNzVW5jb21wcmVzc2VkKGZyYW1lSW5kZXgpO1xuICAgIC8vIGxldCBidWZmZXIgPSB0aGlzLl9kYXRhU2V0LmltYWdlRGF0YTtcbiAgICAvLyBpZiAodGhpcy5fZGF0YVNldC5jb21wcmVzc2VkKSB7XG4gICAgLy8gbGV0IGJ1ZmZlciA9IHRoaXMuX2RhdGFTZXQucmF3RGF0YVswXTtcbiAgICAvLyB0cnkge1xuICAgIC8vICAgbGV0IGRhdGEgPSBwYWtvLmluZmxhdGUobmV3IFVpbnQ4QXJyYXkoYnVmZmVyKSk7XG4gICAgLy8gICBidWZmZXIgPSBkYXRhLmJ1ZmZlcjtcbiAgICAvLyB9IGNhdGNoIChlcnIpIHtcbiAgICAvLyAgIGNvbnNvbGUubG9nKGVycik7XG4gICAgLy8gfVxuXG4gICAgLy8gd2luZG93LmNvbnNvbGUubG9nKGJ1ZmZlcik7XG4gICAgLy8gfVxuXG4gICAgLy8gaXMgaXQgY29tcHJlc3NlZD9cbiAgICAvLyB5ZXMvbm9cblxuICAgIC8vICAgICB0cnkge1xuICAgIC8vICAgdmFyIHJlc3VsdCA9IHBha28uaW5mbGF0ZShjb21wcmVzc2VkKTtcbiAgICAvLyB9IGNhdGNoIChlcnIpIHtcbiAgICAvLyAgIGNvbnNvbGUubG9nKGVycik7XG4gICAgLy8gfVxuXG4gICAgLy8gd2luZG93LmNvbnNvbGUubG9nKHRoaXMpO1xuICB9XG5cbiAgX2RlY29tcHJlc3NVbmNvbXByZXNzZWQoZnJhbWVJbmRleCA9IDApIHtcbiAgICAvLyBwYXBheWEudm9sdW1lLm5pZnRpLk5JRlRJX1RZUEVfVUlOVDggICAgICAgICAgID0gMjtcbiAgICAvLyBwYXBheWEudm9sdW1lLm5pZnRpLk5JRlRJX1RZUEVfSU5UMTYgICAgICAgICAgID0gNDtcbiAgICAvLyBwYXBheWEudm9sdW1lLm5pZnRpLk5JRlRJX1RZUEVfSU5UMzIgICAgICAgICAgID0gODtcbiAgICAvLyBwYXBheWEudm9sdW1lLm5pZnRpLk5JRlRJX1RZUEVfRkxPQVQzMiAgICAgICAgPSAxNjtcbiAgICAvLyBwYXBheWEudm9sdW1lLm5pZnRpLk5JRlRJX1RZUEVfQ09NUExFWDY0ICAgICAgPSAzMjtcbiAgICAvLyBwYXBheWEudm9sdW1lLm5pZnRpLk5JRlRJX1RZUEVfRkxPQVQ2NCAgICAgICAgPSA2NDtcbiAgICAvLyBwYXBheWEudm9sdW1lLm5pZnRpLk5JRlRJX1RZUEVfUkdCMjQgICAgICAgICA9IDEyODtcbiAgICAvLyBwYXBheWEudm9sdW1lLm5pZnRpLk5JRlRJX1RZUEVfSU5UOCAgICAgICAgICA9IDI1NjtcbiAgICAvLyBwYXBheWEudm9sdW1lLm5pZnRpLk5JRlRJX1RZUEVfVUlOVDE2ICAgICAgICA9IDUxMjtcbiAgICAvLyBwYXBheWEudm9sdW1lLm5pZnRpLk5JRlRJX1RZUEVfVUlOVDMyICAgICAgICA9IDc2ODtcbiAgICAvLyBwYXBheWEudm9sdW1lLm5pZnRpLk5JRlRJX1RZUEVfSU5UNjQgICAgICAgID0gMTAyNDtcbiAgICAvLyBwYXBheWEudm9sdW1lLm5pZnRpLk5JRlRJX1RZUEVfVUlOVDY0ICAgICAgID0gMTI4MDtcbiAgICAvLyBwYXBheWEudm9sdW1lLm5pZnRpLk5JRlRJX1RZUEVfRkxPQVQxMjggICAgID0gMTUzNjtcbiAgICAvLyBwYXBheWEudm9sdW1lLm5pZnRpLk5JRlRJX1RZUEVfQ09NUExFWDEyOCAgID0gMTc5MjtcbiAgICAvLyBwYXBheWEudm9sdW1lLm5pZnRpLk5JRlRJX1RZUEVfQ09NUExFWDI1NiAgID0gMjA0ODtcblxuICAgIGxldCBudW1iZXJPZkNoYW5uZWxzID0gdGhpcy5udW1iZXJPZkNoYW5uZWxzKCk7XG4gICAgbGV0IG51bVBpeGVscyA9XG4gICAgICB0aGlzLnJvd3MoZnJhbWVJbmRleCkgKiB0aGlzLmNvbHVtbnMoZnJhbWVJbmRleCkgKiBudW1iZXJPZkNoYW5uZWxzO1xuICAgIC8vIGlmKCAhdGhpcy5yaWdodEhhbmRlZCgpICl7XG4gICAgLy8gICBmcmFtZUluZGV4ID0gdGhpcy5udW1iZXJPZkZyYW1lcygpIC0gMSAtIGZyYW1lSW5kZXg7XG4gICAgLy8gfVxuICAgIGxldCBmcmFtZU9mZnNldCA9IGZyYW1lSW5kZXggKiBudW1QaXhlbHM7XG4gICAgbGV0IGJ1ZmZlciA9IHRoaXMuX25pZnRpSW1hZ2U7XG5cbiAgICAvLyB1c2UgYml0cyBhbGxvY2F0ZWQgJiYgcGl4ZWwgcmVwcmVuc2VudGF0aW9uIHRvb1xuICAgIGlmICghdGhpcy5fb3JkZXJlZCAmJiB0aGlzLl9vcmRlcmVkRGF0YSA9PT0gbnVsbCkge1xuICAgICAgLy8gb3JkZXIgdGhlblxuICAgICAgdGhpcy5fcmVvcmRlckRhdGEoKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fb3JkZXJlZERhdGEgIT09IG51bGwpIHtcbiAgICAgIC8vIGp1c3QgYSBzbGljZS4uLlxuICAgICAgcmV0dXJuIHRoaXMuX29yZGVyZWREYXRhLnNsaWNlKGZyYW1lT2Zmc2V0LCBmcmFtZU9mZnNldCArIG51bVBpeGVscyk7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9kYXRhU2V0LmRhdGF0eXBlQ29kZSA9PT0gMikge1xuICAgICAgLy8gdW5zaWduZWQgaW50IDggYml0XG4gICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyLCBmcmFtZU9mZnNldCwgbnVtUGl4ZWxzKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX2RhdGFTZXQuZGF0YXR5cGVDb2RlID09PSAyNTYpIHtcbiAgICAgIC8vIHNpZ25lZCBpbnQgOCBiaXRcbiAgICAgIHJldHVybiBuZXcgSW50OEFycmF5KGJ1ZmZlciwgZnJhbWVPZmZzZXQsIG51bVBpeGVscyk7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9kYXRhU2V0LmRhdGF0eXBlQ29kZSA9PT0gNTEyKSB7XG4gICAgICAvLyB1bnNpZ25lZCBpbnQgMTYgYml0XG4gICAgICBmcmFtZU9mZnNldCA9IGZyYW1lT2Zmc2V0ICogMjtcbiAgICAgIHJldHVybiBuZXcgVWludDE2QXJyYXkoYnVmZmVyLCBmcmFtZU9mZnNldCwgbnVtUGl4ZWxzKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX2RhdGFTZXQuZGF0YXR5cGVDb2RlID09PSA0KSB7XG4gICAgICAvLyBzaWduZWQgaW50IDE2IGJpdFxuICAgICAgZnJhbWVPZmZzZXQgPSBmcmFtZU9mZnNldCAqIDI7XG4gICAgICByZXR1cm4gbmV3IEludDE2QXJyYXkoYnVmZmVyLCBmcmFtZU9mZnNldCwgbnVtUGl4ZWxzKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX2RhdGFTZXQuZGF0YXR5cGVDb2RlID09PSA4KSB7XG4gICAgICAvLyBzaWduZWQgaW50IDMyIGJpdFxuICAgICAgZnJhbWVPZmZzZXQgPSBmcmFtZU9mZnNldCAqIDQ7XG4gICAgICByZXR1cm4gbmV3IEludDMyQXJyYXkoYnVmZmVyLCBmcmFtZU9mZnNldCwgbnVtUGl4ZWxzKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX2RhdGFTZXQuZGF0YXR5cGVDb2RlID09PSAxNikge1xuICAgICAgLy8gc2lnbmVkIGZsb2F0IDMyIGJpdFxuICAgICAgZnJhbWVPZmZzZXQgPSBmcmFtZU9mZnNldCAqIDQ7XG4gICAgICByZXR1cm4gbmV3IEZsb2F0MzJBcnJheShidWZmZXIsIGZyYW1lT2Zmc2V0LCBudW1QaXhlbHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgYFVua25vd24gZGF0YSB0eXBlOiBkYXRhdHlwZUNvZGUgOiAke3RoaXMuX2RhdGFTZXQuZGF0YXR5cGVDb2RlfWApO1xuICAgIH1cbiAgfVxuXG4gIF9yZW9yZGVyRGF0YSgpIHtcbiAgICB3aW5kb3cuY29uc29sZS5sb2coJ3JlLW9yZGVyJyk7XG4gICAgbGV0IG51bWJlck9mQ2hhbm5lbHMgPSB0aGlzLm51bWJlck9mQ2hhbm5lbHMoKTtcbiAgICBsZXQgbnVtUGl4ZWxzID0gdGhpcy5yb3dzKCkgKiB0aGlzLmNvbHVtbnMoKSAqIG51bWJlck9mQ2hhbm5lbHM7XG4gICAgbGV0IGJ1ZmZlciA9IHRoaXMuX25pZnRpSW1hZ2U7XG5cbiAgICBsZXQgdG90YWxOdW1QaXhlbHMgPSBudW1QaXhlbHMgKiB0aGlzLm51bWJlck9mRnJhbWVzKCk7XG4gICAgbGV0IHRtcCA9IG51bGw7XG4gICAgdGhpcy5fb3JkZXJlZERhdGEgPSBudWxsO1xuXG4gICAgaWYgKHRoaXMuX2RhdGFTZXQuZGF0YXR5cGVDb2RlID09PSAyKSB7XG4gICAgICAvLyB1bnNpZ25lZCA4IGJpdFxuICAgICAgdG1wID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyLCAwLCB0b3RhbE51bVBpeGVscyk7XG4gICAgICB0aGlzLl9vcmRlcmVkRGF0YSA9IG5ldyBVaW50OEFycmF5KHRtcC5sZW5ndGgpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fZGF0YVNldC5kYXRhdHlwZUNvZGUgPT09IDI1Nikge1xuICAgICAgLy8gc2lnbmVkIDggYml0XG4gICAgICB0bXAgPSBuZXcgSW50OEFycmF5KGJ1ZmZlciwgMCwgdG90YWxOdW1QaXhlbHMpO1xuICAgICAgdGhpcy5fb3JkZXJlZERhdGEgPSBuZXcgSW50OEFycmF5KHRtcC5sZW5ndGgpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fZGF0YVNldC5kYXRhdHlwZUNvZGUgPT09IDUxMikge1xuICAgICAgdG1wID0gbmV3IFVpbnQxNkFycmF5KGJ1ZmZlciwgMCwgdG90YWxOdW1QaXhlbHMpO1xuICAgICAgdGhpcy5fb3JkZXJlZERhdGEgPSBuZXcgVWludDE2QXJyYXkodG1wLmxlbmd0aCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9kYXRhU2V0LmRhdGF0eXBlQ29kZSA9PT0gNCkge1xuICAgICAgdG1wID0gbmV3IEludDE2QXJyYXkoYnVmZmVyLCAwLCB0b3RhbE51bVBpeGVscyk7XG4gICAgICB0aGlzLl9vcmRlcmVkRGF0YSA9IG5ldyBJbnQxNkFycmF5KHRtcC5sZW5ndGgpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fZGF0YVNldC5kYXRhdHlwZUNvZGUgPT09IDE2KSB7XG4gICAgICB0bXAgPSBuZXcgRmxvYXQzMkFycmF5KGJ1ZmZlciwgMCwgdG90YWxOdW1QaXhlbHMpO1xuICAgICAgdGhpcy5fb3JkZXJlZERhdGEgPSBuZXcgRmxvYXQzMkFycmF5KHRtcC5sZW5ndGgpO1xuICAgIH1cblxuICAgIC8vIHJlLW9yZGVyIHBpeGVscy4uLlxuICAgIGxldCBudW1QaXhlbHMyID0gdG1wLmxlbmd0aCAvIDM7XG4gICAgbGV0IHJnYmFJbmRleCA9IDA7XG4gICAgbGV0IHJJbmRleCA9IDA7XG4gICAgbGV0IGdJbmRleCA9IG51bVBpeGVsczI7XG4gICAgbGV0IGJJbmRleCA9IG51bVBpeGVsczIgKiAyO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1QaXhlbHMyOyBpKyspIHtcbiAgICAgIHRoaXMuX29yZGVyZWREYXRhW3JnYmFJbmRleCsrXSA9IHRtcFtySW5kZXgrK107IC8vIHJlZFxuICAgICAgdGhpcy5fb3JkZXJlZERhdGFbcmdiYUluZGV4KytdID0gdG1wW2dJbmRleCsrXTsgLy8gZ3JlZW5cbiAgICAgIHRoaXMuX29yZGVyZWREYXRhW3JnYmFJbmRleCsrXSA9IHRtcFtiSW5kZXgrK107IC8vIGJsdWVcbiAgICB9XG5cbiAgICB0aGlzLl9vcmRlcmVkID0gdHJ1ZTtcbiAgfVxufVxuIiwiLy8gdXNlIG5pZnRpLWpzIGFuZCBqdXN0IHBhcnNlIGhlYWRlci4/Pz9cblxuLy8gU2xpY2VyIHdheSB0byBoYW5kbGUgaW1hZ2VzXG4vLyBzaG91bGQgZm9sbG93IGl0Li4uXG4gLy8gODk3ICAgaWYgKCAodGhpcy0+SW5kZXhTZXJpZXNJbnN0YW5jZVVJRHNba10gIT0gaWR4U2VyaWVzSW5zdGFuY2VVSUQgJiYgdGhpcy0+SW5kZXhTZXJpZXNJbnN0YW5jZVVJRHNba10gPj0gMCAmJiBpZHhTZXJpZXNJbnN0YW5jZVVJRCA+PSAwKSB8fFxuIC8vIDg5OCAgICAgICAgKHRoaXMtPkluZGV4Q29udGVudFRpbWVba10gIT0gaWR4Q29udGVudFRpbWUgJiYgdGhpcy0+SW5kZXhDb250ZW50VGltZVtrXSA+PSAwICYmIGlkeENvbnRlbnRUaW1lID49IDApIHx8XG4gLy8gODk5ICAgICAgICAodGhpcy0+SW5kZXhUcmlnZ2VyVGltZVtrXSAhPSBpZHhUcmlnZ2VyVGltZSAmJiB0aGlzLT5JbmRleFRyaWdnZXJUaW1lW2tdID49IDAgJiYgaWR4VHJpZ2dlclRpbWUgPj0gMCkgfHxcbiAvLyA5MDAgICAgICAgICh0aGlzLT5JbmRleEVjaG9OdW1iZXJzW2tdICE9IGlkeEVjaG9OdW1iZXJzICYmIHRoaXMtPkluZGV4RWNob051bWJlcnNba10gPj0gMCAmJiBpZHhFY2hvTnVtYmVycyA+PSAwKSB8fFxuIC8vIDkwMSAgICAgICAgKHRoaXMtPkluZGV4RGlmZnVzaW9uR3JhZGllbnRPcmllbnRhdGlvbltrXSAhPSBpZHhEaWZmdXNpb25HcmFkaWVudE9yaWVudGF0aW9uICAmJiB0aGlzLT5JbmRleERpZmZ1c2lvbkdyYWRpZW50T3JpZW50YXRpb25ba10gPj0gMCAmJiBpZHhEaWZmdXNpb25HcmFkaWVudE9yaWVudGF0aW9uID49IDApIHx8XG4gLy8gOTAyICAgICAgICAodGhpcy0+SW5kZXhTbGljZUxvY2F0aW9uW2tdICE9IGlkeFNsaWNlTG9jYXRpb24gJiYgdGhpcy0+SW5kZXhTbGljZUxvY2F0aW9uW2tdID49IDAgJiYgaWR4U2xpY2VMb2NhdGlvbiA+PSAwKSB8fFxuIC8vIDkwMyAgICAgICAgKHRoaXMtPkluZGV4SW1hZ2VPcmllbnRhdGlvblBhdGllbnRba10gIT0gaWR4SW1hZ2VPcmllbnRhdGlvblBhdGllbnQgJiYgdGhpcy0+SW5kZXhJbWFnZU9yaWVudGF0aW9uUGF0aWVudFtrXSA+PSAwICYmIGlkeEltYWdlT3JpZW50YXRpb25QYXRpZW50ID49IDApIClcbiAvLyA5MDQgICAgIHtcbiAvLyA5MDUgICAgICAgY29udGludWU7XG4gLy8gOTA2ICAgICB9XG5cbi8vIGh0dHA6Ly9icmFpbmRlci5vcmcvMjAxMi8wOS8yMy90aGUtbmlmdGktZmlsZS1mb3JtYXQvXG5cbi8qKiAqIEltcG9ydHMgKioqL1xuaW1wb3J0IFBhcnNlcnNWb2x1bWUgZnJvbSAnLi9wYXJzZXJzLnZvbHVtZSc7XG5cbmxldCBwYWtvID0gcmVxdWlyZSgncGFrbycpO1xubGV0IE5ycmRSZWFkZXIgPSByZXF1aXJlKCducnJkLWpzJyk7XG4vKipcbiAqIEBtb2R1bGUgcGFyc2Vycy9uaWZ0aVxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQYXJzZXJzTmlmdGkgZXh0ZW5kcyBQYXJzZXJzVm9sdW1lIHtcbiAgY29uc3RydWN0b3IoZGF0YSwgaWQpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgLyoqXG4gICAgICAqIEBtZW1iZXJcbiAgICAgICogQHR5cGUge2FycmF5YnVmZmVyfVxuICAgICovXG4gICAgdGhpcy5faWQgPSBpZDtcbiAgICB0aGlzLl9hcnJheUJ1ZmZlciA9IGRhdGEuYnVmZmVyO1xuICAgIHRoaXMuX3VybCA9IGRhdGEudXJsO1xuICAgIHRoaXMuX2RhdGFTZXQgPSBudWxsO1xuICAgIHRoaXMuX3VucGFja2VkRGF0YSA9IG51bGw7XG5cbiAgICB0cnkge1xuICAgICAgdGhpcy5fZGF0YVNldCA9IE5ycmRSZWFkZXIucGFyc2UodGhpcy5fYXJyYXlCdWZmZXIpO1xuICAgICAgY29uc29sZS5sb2codGhpcy5fZGF0YVNldCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHdpbmRvdy5jb25zb2xlLmxvZygnb29vcHMuLi4gOignKTtcbiAgICB9XG5cbiAgICB3aW5kb3cuY29uc29sZS5sb2codGhpcy5fZGF0YVNldCk7XG4gIH1cblxuICByaWdodEhhbmRlZCgpIHtcbiAgICBpZiAodGhpcy5fZGF0YVNldC5zcGFjZS5tYXRjaCgvXnJpZ2h0LWFudGVyaW9yLXN1cGVyaW9yLykgfHxcbiAgICAgICAgdGhpcy5fZGF0YVNldC5zcGFjZS5tYXRjaCgvXmxlZnQtcG9zdGVyaW9yLXN1cGVyaW9yLykpIHtcbiAgICAgdGhpcy5fcmlnaHRIYW5kZWQgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9yaWdodEhhbmRlZCA9IGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9yaWdodEhhbmRlZDtcbiAgfVxuXG4gIHNlcmllc0luc3RhbmNlVUlEKCkge1xuICAgIC8vIHVzZSBmaWxlbmFtZSArIHRpbWVzdGFtcC4uP1xuICAgIHJldHVybiB0aGlzLl91cmw7XG4gIH1cblxuICBudW1iZXJPZkZyYW1lcygpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YVNldC5zaXplc1syXTtcbiAgfVxuXG4gIG51bWJlck9mQ2hhbm5lbHMoKSB7XG4gICAgbGV0IG51bWJlck9mQ2hhbm5lbHMgPSAxO1xuICAgIHJldHVybiBudW1iZXJPZkNoYW5uZWxzO1xuICB9XG5cbiAgc29wSW5zdGFuY2VVSUQoZnJhbWVJbmRleCA9IDApIHtcbiAgICByZXR1cm4gZnJhbWVJbmRleDtcbiAgfVxuXG4gIHJvd3MoZnJhbWVJbmRleCA9IDApIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YVNldC5zaXplc1sxXTtcbiAgfVxuXG4gIGNvbHVtbnMoZnJhbWVJbmRleCA9IDApIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YVNldC5zaXplc1swXTtcbiAgfVxuXG4gIHBpeGVsVHlwZShmcmFtZUluZGV4ID0gMCkge1xuICAgIC8vIDAgLSBpbnRcbiAgICAvLyAxIC0gZmxvYXRcbiAgICBsZXQgcGl4ZWxUeXBlID0gMDtcbiAgICBpZiAodGhpcy5fZGF0YVNldC50eXBlID09PSAnZmxvYXQnKSB7XG4gICAgICBwaXhlbFR5cGUgPSAxO1xuICAgIH1cbiAgICByZXR1cm4gcGl4ZWxUeXBlO1xuICB9XG5cbiAgYml0c0FsbG9jYXRlZChmcmFtZUluZGV4ID0gMCkge1xuICAgIGxldCBiaXRzQWxsb2NhdGVkID0gMTtcblxuICAgIGlmICh0aGlzLl9kYXRhU2V0LnR5cGUgPT09ICdpbnQ4JyB8fFxuICAgICAgIHRoaXMuX2RhdGFTZXQudHlwZSA9PT0gJ3VpbnQ4JyB8fFxuICAgICAgIHRoaXMuX2RhdGFTZXQudHlwZSA9PT0gJ2NoYXInKSB7XG4gICAgICBiaXRzQWxsb2NhdGVkID0gODtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX2RhdGFTZXQudHlwZSA9PT0gJ2ludDE2JyB8fFxuICAgICAgdGhpcy5fZGF0YVNldC50eXBlID09PSAndWludDE2JyB8fFxuICAgICAgdGhpcy5fZGF0YVNldC50eXBlID09PSAnc2hvcnQnKSB7XG4gICAgICBiaXRzQWxsb2NhdGVkID0gMTY7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9kYXRhU2V0LnR5cGUgPT09ICdpbnQzMicgfHxcbiAgICAgIHRoaXMuX2RhdGFTZXQudHlwZSA9PT0gJ3VpbnQzMicgfHxcbiAgICAgIHRoaXMuX2RhdGFTZXQudHlwZSA9PT0gJ2Zsb2F0Jykge1xuICAgICAgYml0c0FsbG9jYXRlZCA9IDMyO1xuICAgIH1cblxuICAgIHJldHVybiBiaXRzQWxsb2NhdGVkO1xuICB9XG5cbiAgcGl4ZWxTcGFjaW5nKGZyYW1lSW5kZXggPSAwKSB7XG4gICAgbGV0IHggPSBuZXcgVEhSRUUuVmVjdG9yMyhcbiAgICAgIHRoaXMuX2RhdGFTZXQuc3BhY2VEaXJlY3Rpb25zWzBdWzBdLFxuICAgICAgdGhpcy5fZGF0YVNldC5zcGFjZURpcmVjdGlvbnNbMF1bMV0sXG4gICAgICB0aGlzLl9kYXRhU2V0LnNwYWNlRGlyZWN0aW9uc1swXVsyXSk7XG5cbiAgICBsZXQgeSA9IG5ldyBUSFJFRS5WZWN0b3IzKFxuICAgICAgdGhpcy5fZGF0YVNldC5zcGFjZURpcmVjdGlvbnNbMV1bMF0sXG4gICAgICB0aGlzLl9kYXRhU2V0LnNwYWNlRGlyZWN0aW9uc1sxXVsxXSxcbiAgICAgIHRoaXMuX2RhdGFTZXQuc3BhY2VEaXJlY3Rpb25zWzFdWzJdKTtcblxuICAgIGxldCB6ID0gbmV3IFRIUkVFLlZlY3RvcjMoXG4gICAgICB0aGlzLl9kYXRhU2V0LnNwYWNlRGlyZWN0aW9uc1syXVswXSxcbiAgICAgIHRoaXMuX2RhdGFTZXQuc3BhY2VEaXJlY3Rpb25zWzJdWzFdLFxuICAgICAgdGhpcy5fZGF0YVNldC5zcGFjZURpcmVjdGlvbnNbMl1bMl0pO1xuXG4gICAgcmV0dXJuIFt4Lmxlbmd0aCgpLCB5Lmxlbmd0aCgpLCB6Lmxlbmd0aCgpXTtcbiAgfVxuXG4gIHNsaWNlVGhpY2tuZXNzKCkge1xuICAgIC8vIHNob3VsZCBiZSBhIHN0cmluZy4uLlxuICAgIHJldHVybiBudWxsOy8vIHRoaXMuX2RhdGFTZXQucGl4RGltc1szXS50b1N0cmluZygpO1xuICB9XG5cbiAgaW1hZ2VPcmllbnRhdGlvbihmcmFtZUluZGV4ID0gMCkge1xuICAgIGxldCBpbnZlcnRYID0gdGhpcy5fZGF0YVNldC5zcGFjZS5tYXRjaCgvcmlnaHQvKSA/IC0xIDogMTtcbiAgICBsZXQgaW52ZXJ0WSA9IHRoaXMuX2RhdGFTZXQuc3BhY2UubWF0Y2goL2FudGVyaW9yLykgPyAtMSA6IDE7XG5cbiAgICBsZXQgeCA9IG5ldyBUSFJFRS5WZWN0b3IzKFxuICAgICAgdGhpcy5fZGF0YVNldC5zcGFjZURpcmVjdGlvbnNbMF1bMF0gKiBpbnZlcnRYLFxuICAgICAgdGhpcy5fZGF0YVNldC5zcGFjZURpcmVjdGlvbnNbMF1bMV0gKiBpbnZlcnRZLFxuICAgICAgdGhpcy5fZGF0YVNldC5zcGFjZURpcmVjdGlvbnNbMF1bMl0pO1xuICAgIHgubm9ybWFsaXplKCk7XG5cbiAgICBsZXQgeSA9IG5ldyBUSFJFRS5WZWN0b3IzKFxuICAgICAgdGhpcy5fZGF0YVNldC5zcGFjZURpcmVjdGlvbnNbMV1bMF0gKiBpbnZlcnRYLFxuICAgICAgdGhpcy5fZGF0YVNldC5zcGFjZURpcmVjdGlvbnNbMV1bMV0gKiBpbnZlcnRZLFxuICAgICAgdGhpcy5fZGF0YVNldC5zcGFjZURpcmVjdGlvbnNbMV1bMl0pO1xuICAgIHkubm9ybWFsaXplKCk7XG5cbiAgICByZXR1cm4gW1xuICAgICAgeC54LCB4LnksIHgueixcbiAgICAgIHkueCwgeS55LCB5LnosXG4gICAgICBdO1xuICB9XG5cbiAgaW1hZ2VQb3NpdGlvbihmcmFtZUluZGV4ID0gMCkge1xuICAgIHJldHVybiBbXG4gICAgICB0aGlzLl9kYXRhU2V0LnNwYWNlT3JpZ2luWzBdLFxuICAgICAgdGhpcy5fZGF0YVNldC5zcGFjZU9yaWdpblsxXSxcbiAgICAgIHRoaXMuX2RhdGFTZXQuc3BhY2VPcmlnaW5bMl0sXG4gICAgXTtcbiAgfVxuXG4gIGRpbWVuc2lvbkluZGV4VmFsdWVzKGZyYW1lSW5kZXggPSAwKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpbnN0YW5jZU51bWJlcihmcmFtZUluZGV4ID0gMCkge1xuICAgIHJldHVybiBmcmFtZUluZGV4O1xuICB9XG5cbiAgd2luZG93Q2VudGVyKGZyYW1lSW5kZXggPSAwKSB7XG4gICAgLy8gY2FsYyBtaW4gYW5kIGNhbGMgbWF4XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB3aW5kb3dXaWR0aChmcmFtZUluZGV4ID0gMCkge1xuICAgIC8vIGNhbGMgbWluIGFuZCBjYWxjIG1heFxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmVzY2FsZVNsb3BlKGZyYW1lSW5kZXggPSAwKSB7XG4gICAgcmV0dXJuIDE7Ly8gdGhpcy5fZGF0YVNldC5zY2xfc2xvcGU7XG4gIH1cblxuICByZXNjYWxlSW50ZXJjZXB0KGZyYW1lSW5kZXggPSAwKSB7XG4gICAgcmV0dXJuIDA7Ly8gdGhpcy5fZGF0YVNldC5zY2xfaW50ZXJjZXB0O1xuICB9XG5cbiAgbWluTWF4UGl4ZWxEYXRhKHBpeGVsRGF0YSA9IFtdKSB7XG4gICAgbGV0IG1pbk1heCA9IFs2NTUzNSwgLTMyNzY4XTtcbiAgICBsZXQgbnVtUGl4ZWxzID0gcGl4ZWxEYXRhLmxlbmd0aDtcbiAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgbnVtUGl4ZWxzOyBpbmRleCsrKSB7XG4gICAgICBsZXQgc3B2ID0gcGl4ZWxEYXRhW2luZGV4XTtcbiAgICAgIG1pbk1heFswXSA9IE1hdGgubWluKG1pbk1heFswXSwgc3B2KTtcbiAgICAgIG1pbk1heFsxXSA9IE1hdGgubWF4KG1pbk1heFsxXSwgc3B2KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbWluTWF4O1xuICB9XG5cbiAgZXh0cmFjdFBpeGVsRGF0YShmcmFtZUluZGV4ID0gMCkge1xuICAgIHJldHVybiB0aGlzLl9kZWNvbXByZXNzVW5jb21wcmVzc2VkKGZyYW1lSW5kZXgpO1xuICB9XG5cbiAgX2RlY29tcHJlc3NVbmNvbXByZXNzZWQoZnJhbWVJbmRleCA9IDApIHtcbiAgICBsZXQgYnVmZmVyID0gdGhpcy5fZGF0YVNldC5idWZmZXI7XG4gICAgbGV0IG51bWJlck9mQ2hhbm5lbHMgPSB0aGlzLm51bWJlck9mQ2hhbm5lbHMoKTtcbiAgICBsZXQgbnVtUGl4ZWxzID0gdGhpcy5yb3dzKGZyYW1lSW5kZXgpICogdGhpcy5jb2x1bW5zKGZyYW1lSW5kZXgpICogbnVtYmVyT2ZDaGFubmVscztcbiAgICBpZiAoIXRoaXMucmlnaHRIYW5kZWQoKSkge1xuICAgICAgZnJhbWVJbmRleCA9IHRoaXMubnVtYmVyT2ZGcmFtZXMoKSAtIDEgLSBmcmFtZUluZGV4O1xuICAgIH1cbiAgICBsZXQgZnJhbWVPZmZzZXQgPSBmcmFtZUluZGV4ICogbnVtUGl4ZWxzO1xuXG4gICAgLy8gdW5wYWNrIGRhdGEgaWYgbmVlZGVkXG4gICAgaWYgKHRoaXMuX3VucGFja2VkRGF0YSA9PT0gbnVsbCAmJlxuICAgICAgdGhpcy5fZGF0YVNldC5lbmNvZGluZyA9PT0gJ2d6aXAnKSB7XG4gICAgICBsZXQgdW5wYWNrZWREYXRhID0gcGFrby5pbmZsYXRlKHRoaXMuX2RhdGFTZXQuYnVmZmVyKTtcbiAgICAgIHRoaXMuX3VucGFja2VkRGF0YSA9IHVucGFja2VkRGF0YS5idWZmZXI7XG4gICAgICBidWZmZXIgPSB0aGlzLl91bnBhY2tlZERhdGE7XG4gICAgfSBlbHNlIGlmKHRoaXMuX2RhdGFTZXQuZW5jb2RpbmcgPT09ICdnemlwJykge1xuICAgICAgYnVmZmVyID0gdGhpcy5fdW5wYWNrZWREYXRhO1xuICAgIH1cblxuICAgIGlmKHRoaXMuX2RhdGFTZXQudHlwZSA9PT0gJ2ludDgnIHx8XG4gICAgICAgdGhpcy5fZGF0YVNldC50eXBlID09PSAnY2hhcicpIHtcbiAgICAgIGZyYW1lT2Zmc2V0ID0gZnJhbWVPZmZzZXQ7XG4gICAgICByZXR1cm4gbmV3IEludDhBcnJheShidWZmZXIsIGZyYW1lT2Zmc2V0LCBudW1QaXhlbHMpO1xuICAgIH0gZWxzZSBpZih0aGlzLl9kYXRhU2V0LnR5cGUgPT09ICd1aW50OCcpIHtcbiAgICAgIGZyYW1lT2Zmc2V0ID0gZnJhbWVPZmZzZXQ7XG4gICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyLCBmcmFtZU9mZnNldCwgbnVtUGl4ZWxzKTtcbiAgICB9IGVsc2UgaWYodGhpcy5fZGF0YVNldC50eXBlID09PSAnaW50MTYnIHx8XG4gICAgICAgdGhpcy5fZGF0YVNldC50eXBlID09PSAnc2hvcnQnKSB7XG4gICAgICBmcmFtZU9mZnNldCA9IGZyYW1lT2Zmc2V0ICogMjtcbiAgICAgIHJldHVybiBuZXcgSW50MTZBcnJheShidWZmZXIsIGZyYW1lT2Zmc2V0LCBudW1QaXhlbHMpO1xuICAgIH0gZWxzZSBpZih0aGlzLl9kYXRhU2V0LnR5cGUgPT09ICd1aW50MTYnKSB7XG4gICAgICBmcmFtZU9mZnNldCA9IGZyYW1lT2Zmc2V0ICogMjtcbiAgICAgIHJldHVybiBuZXcgVWludDE2QXJyYXkoYnVmZmVyLCBmcmFtZU9mZnNldCwgbnVtUGl4ZWxzKTtcbiAgICB9IGVsc2UgaWYodGhpcy5fZGF0YVNldC50eXBlID09PSAnaW50MzInKSB7XG4gICAgICBmcmFtZU9mZnNldCA9IGZyYW1lT2Zmc2V0ICogNDtcbiAgICAgIHJldHVybiBuZXcgSW50MzJBcnJheShidWZmZXIsIGZyYW1lT2Zmc2V0LCBudW1QaXhlbHMpO1xuICAgIH0gZWxzZSBpZih0aGlzLl9kYXRhU2V0LnR5cGUgPT09ICd1aW50MzInKSB7XG4gICAgICBmcmFtZU9mZnNldCA9IGZyYW1lT2Zmc2V0ICogNDtcbiAgICAgIHJldHVybiBuZXcgVWludDMyQXJyYXkoYnVmZmVyLCBmcmFtZU9mZnNldCwgbnVtUGl4ZWxzKTtcbiAgICB9IGVsc2UgaWYodGhpcy5fZGF0YVNldC50eXBlID09PSAnZmxvYXQnKSB7XG4gICAgICBmcmFtZU9mZnNldCA9IGZyYW1lT2Zmc2V0ICogNDtcbiAgICAgIHJldHVybiBuZXcgRmxvYXQzMkFycmF5KGJ1ZmZlciwgZnJhbWVPZmZzZXQsIG51bVBpeGVscyk7XG4gICAgfVxuICB9XG59XG4iLCIvKipcbiAqIEBtb2R1bGUgcGFyc2Vycy92b2x1bWVcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUGFyc2Vyc1ZvbHVtZSB7XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5fcmlnaHRIYW5kZWQgPSB0cnVlO1xuICB9XG5cbiAgcGl4ZWxSZXByZXNlbnRhdGlvbigpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIG1vZGFsaXR5KCkge1xuICAgIHJldHVybiAndW5rbm93bic7XG4gIH1cblxuICBzZWdtZW50YXRpb25UeXBlKCkge1xuICAgIHJldHVybiAndW5rbm93bic7XG4gIH1cblxuICBzZWdtZW50YXRpb25TZWdtZW50cygpIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICByZWZlcmVuY2VkU2VnbWVudE51bWJlcihmcmFtZUluZGV4KSB7XG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgcmlnaHRIYW5kZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JpZ2h0SGFuZGVkO1xuICB9XG5cbiAgc3BhY2luZ0JldHdlZW5TbGljZXMoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBudW1iZXJPZkNoYW5uZWxzKCkge1xuICAgIHJldHVybiAxO1xuICB9XG5cbiAgc2xpY2VUaGlja25lc3MoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuXG4gIGRpbWVuc2lvbkluZGV4VmFsdWVzKGZyYW1lSW5kZXggPSAwKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpbnN0YW5jZU51bWJlcihmcmFtZUluZGV4ID0gMCkge1xuICAgIHJldHVybiBmcmFtZUluZGV4O1xuICB9XG5cbiAgd2luZG93Q2VudGVyKGZyYW1lSW5kZXggPSAwKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB3aW5kb3dXaWR0aChmcmFtZUluZGV4ID0gMCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmVzY2FsZVNsb3BlKGZyYW1lSW5kZXggPSAwKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cblxuICByZXNjYWxlSW50ZXJjZXB0KGZyYW1lSW5kZXggPSAwKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICBfZGVjb21wcmVzc1VuY29tcHJlc3NlZCgpIHtcblxuICB9XG5cbiAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy81MzIwNDM5L2hvdy1kby1pLXN3YXAtZW5kaWFuLW5lc3MtYnl0ZS1vcmRlci1vZi1hLXZhcmlhYmxlLWluLWphdmFzY3JpcHRcbiAgX3N3YXAxNih2YWwpIHtcbiAgICByZXR1cm4gKCh2YWwgJiAweEZGKSA8PCA4KVxuICAgICAgfCAoKHZhbCA+PiA4KSAmIDB4RkYpO1xuICB9XG5cbiAgX3N3YXAzMih2YWwpIHtcbiAgICByZXR1cm4gKCh2YWwgJiAweEZGKSA8PCAyNClcbiAgICAgICAgICAgfCAoKHZhbCAmIDB4RkYwMCkgPDwgOClcbiAgICAgICAgICAgfCAoKHZhbCA+PiA4KSAmIDB4RkYwMClcbiAgICAgICAgICAgfCAoKHZhbCA+PiAyNCkgJiAweEZGKTtcbiAgfVxuXG4gIGludmVydCgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB0cmFuc2ZlciBzeW50YXggVUlELlxuICAgKiBAcmV0dXJuIHsqfVxuICAgKi9cbiAgdHJhbnNmZXJTeW50YXhVSUQoKSB7XG4gICAgcmV0dXJuICdubyB2YWx1ZSBwcm92aWRlZCc7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBzdHVkeSBkZXNjaXB0aW9uLlxuICAgKiBAcmV0dXJuIHsqfVxuICAgKi9cbiAgc3R1ZHlEZXNjcmlwdGlvbigpIHtcbiAgICByZXR1cm4gJ25vIHZhbHVlIHByb3ZpZGVkJztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHNlcmllcyBkZXNjaXB0aW9uLlxuICAgKiBAcmV0dXJuIHsqfVxuICAgKi9cbiAgc2VyaWVzRGVzY3JpcHRpb24oKSB7XG4gICAgcmV0dXJuICdubyB2YWx1ZSBwcm92aWRlZCc7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBwYXRpZW50IElELlxuICAgKiBAcmV0dXJuIHsqfVxuICAgKi9cbiAgcGF0aWVudElEKCkge1xuICAgIHJldHVybiAnbm8gdmFsdWUgcHJvdmlkZWQnO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgcGF0aWVudCBuYW1lLlxuICAgKiBAcmV0dXJuIHsqfVxuICAgKi9cbiAgcGF0aWVudE5hbWUoKSB7XG4gICAgcmV0dXJuICdubyB2YWx1ZSBwcm92aWRlZCc7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBwYXRpZW50IGFnZS5cbiAgICogQHJldHVybiB7Kn1cbiAgICovXG4gIHBhdGllbnRBZ2UoKSB7XG4gICAgcmV0dXJuICdubyB2YWx1ZSBwcm92aWRlZCc7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBwYXRpZW50IGJpcnRoZGF0ZS5cbiAgICogQHJldHVybiB7Kn1cbiAgICovXG4gIHBhdGllbnRCaXJ0aGRhdGUoKSB7XG4gICAgcmV0dXJuICdubyB2YWx1ZSBwcm92aWRlZCc7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBwYXRpZW50IHNleC5cbiAgICogQHJldHVybiB7Kn1cbiAgICovXG4gIHBhdGllbnRTZXgoKSB7XG4gICAgcmV0dXJuICdubyB2YWx1ZSBwcm92aWRlZCc7XG4gIH1cbn1cbiIsImltcG9ydCBTaGFkZXJzQmFzZSBmcm9tICcuLi9zaGFkZXJzLmJhc2UnO1xuXG5jbGFzcyBJbnRlcnNlY3RCb3ggZXh0ZW5kcyBTaGFkZXJzQmFzZSB7XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLm5hbWUgPSAnaW50ZXJzZWN0Qm94JztcblxuICAgIC8vIGRlZmF1bHQgcHJvcGVydGllcyBuYW1lc1xuICAgIHRoaXMuX3JheU9yaWdpbiA9ICdyYXlPcmlnaW4nO1xuICAgIHRoaXMuX3JheURpcmVjdGlvbiA9ICdyYXlEaXJlY3Rpb24nO1xuICAgIHRoaXMuX2FhYmJNaW4gPSAnYWFiYk1pbic7XG4gICAgdGhpcy5fYWFiYk1heCA9ICdhYWJiTWF4JztcbiAgICB0aGlzLl90TmVhciA9ICd0TmVhcic7XG4gICAgdGhpcy5fdEZhciA9ICd0RmFyJztcbiAgICB0aGlzLl9pbnRlcnNlY3QgPSAnaW50ZXJzZWN0JztcbiAgfVxuXG4gIGFwaShiYXNlRnJhZ21lbnQgPSB0aGlzLl9iYXNlLFxuICAgICAgIHJheU9yaWdpbiA9IHRoaXMuX3JheU9yaWdpbiwgcmF5RGlyZWN0aW9uID0gdGhpcy5fcmF5RGlyZWN0aW9uLFxuICAgICAgIGFhYmJNaW4gPSB0aGlzLl9hYWJiTWluLCBhYWJiTWF4ID0gdGhpcy5fYWFiYk1heCxcbiAgICAgICB0TmVhciA9IHRoaXMuX3ROZWFyLCB0RmFyID0gdGhpcy5fdEZhcixcbiAgICAgICBpbnRlcnNlY3QgPSB0aGlzLl9pbnRlcnNlY3QpIHtcbiAgICB0aGlzLl9iYXNlID0gYmFzZUZyYWdtZW50O1xuICAgIHJldHVybiB0aGlzLmNvbXB1dGUocmF5T3JpZ2luLCByYXlEaXJlY3Rpb24sIGFhYmJNaW4sIGFhYmJNYXgsIHROZWFyLCB0RmFyLCBpbnRlcnNlY3QpO1xuICB9XG5cbiAgY29tcHV0ZShyYXlPcmlnaW4sIHJheURpcmVjdGlvbiwgYWFiYk1pbiwgYWFiYk1heCwgdE5lYXIsIHRGYXIsIGludGVyc2VjdCkge1xuICAgIHRoaXMuY29tcHV0ZURlZmluaXRpb24oKTtcbiAgICB0aGlzLl9iYXNlLl9mdW5jdGlvbnNbdGhpcy5fbmFtZV0gPSB0aGlzLl9kZWZpbml0aW9uO1xuICAgIHJldHVybiBgJHt0aGlzLl9uYW1lfSgke3JheU9yaWdpbn0sICR7cmF5RGlyZWN0aW9ufSwgJHthYWJiTWlufSwgJHthYWJiTWF4fSwgJHt0TmVhcn0sICR7dEZhcn0sICR7aW50ZXJzZWN0fSk7YDtcbiAgfVxuXG5cbiAgY29tcHV0ZURlZmluaXRpb24oKSB7XG4gICAgdGhpcy5fZGVmaW5pdGlvbiA9IGBcbnZvaWQgJHt0aGlzLl9uYW1lfSh2ZWMzIHJheU9yaWdpbiwgdmVjMyByYXlEaXJlY3Rpb24sIHZlYzMgYm94TWluLCB2ZWMzIGJveE1heCwgb3V0IGZsb2F0IHROZWFyLCBvdXQgZmxvYXQgdEZhciwgb3V0IGJvb2wgaW50ZXJzZWN0KXtcbiAgLy8gY29tcHV0ZSBpbnRlcnNlY3Rpb24gb2YgcmF5IHdpdGggYWxsIHNpeCBiYm94IHBsYW5lc1xuICB2ZWMzIGludlJheSA9IHZlYzMoMS4pIC8gcmF5RGlyZWN0aW9uO1xuICB2ZWMzIHRCb3QgPSBpbnZSYXkgKiAoYm94TWluIC0gcmF5T3JpZ2luKTtcbiAgdmVjMyB0VG9wID0gaW52UmF5ICogKGJveE1heCAtIHJheU9yaWdpbik7XG4gIC8vIHJlLW9yZGVyIGludGVyc2VjdGlvbnMgdG8gZmluZCBzbWFsbGVzdCBhbmQgbGFyZ2VzdCBvbiBlYWNoIGF4aXNcbiAgdmVjMyB0TWluID0gbWluKHRUb3AsIHRCb3QpO1xuICB2ZWMzIHRNYXggPSBtYXgodFRvcCwgdEJvdCk7XG4gIC8vIGZpbmQgdGhlIGxhcmdlc3QgdE1pbiBhbmQgdGhlIHNtYWxsZXN0IHRNYXhcbiAgZmxvYXQgbGFyZ2VzdF90TWluID0gbWF4KG1heCh0TWluLngsIHRNaW4ueSksIG1heCh0TWluLngsIHRNaW4ueikpO1xuICBmbG9hdCBzbWFsbGVzdF90TWF4ID0gbWluKG1pbih0TWF4LngsIHRNYXgueSksIG1pbih0TWF4LngsIHRNYXgueikpO1xuICB0TmVhciA9IGxhcmdlc3RfdE1pbjtcbiAgdEZhciA9IHNtYWxsZXN0X3RNYXg7XG4gIGludGVyc2VjdCA9IHNtYWxsZXN0X3RNYXggPiBsYXJnZXN0X3RNaW47XG59XG5cbiAgICBgO1xuICB9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgbmV3IEludGVyc2VjdEJveCgpO1xuIiwiaW1wb3J0IFNoYWRlcnNCYXNlIGZyb20gJy4uL3NoYWRlcnMuYmFzZSc7XG5cbmNsYXNzIFRleHR1cmUzZCBleHRlbmRzIFNoYWRlcnNCYXNlIHtcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMubmFtZSA9ICd0ZXh0dXJlM2QnO1xuXG4gICAgLy8gZGVmYXVsdCBwcm9wZXJ0aWVzIG5hbWVzXG4gICAgdGhpcy5fZGF0YUNvb3JkaW5hdGVzID0gJ2RhdGFDb29yZGluYXRlcyc7XG4gICAgdGhpcy5fZGF0YVZhbHVlID0gJ2RhdGFWYWx1ZSc7XG4gICAgdGhpcy5fb2Zmc2V0ID0gJ29mZnNldCc7XG4gIH1cblxuICAgIGFwaShiYXNlRnJhZ21lbnQgPSB0aGlzLl9iYXNlLCBkYXRhQ29vcmRpbmF0ZXMgPSB0aGlzLl9kYXRhQ29vcmRpbmF0ZXMsIGRhdGFWYWx1ZSA9IHRoaXMuX2RhdGFWYWx1ZSwgb2Zmc2V0ID0gdGhpcy5fb2Zmc2V0KSB7XG4gICAgdGhpcy5fYmFzZSA9IGJhc2VGcmFnbWVudDtcbiAgICByZXR1cm4gdGhpcy5jb21wdXRlKGRhdGFDb29yZGluYXRlcywgZGF0YVZhbHVlLCBvZmZzZXQpO1xuICB9XG5cbiAgY29tcHV0ZShkYXRhQ29vcmRpbmF0ZXMsIGRhdGFWYWx1ZSwgb2Zmc2V0KSB7XG4gICAgdGhpcy5jb21wdXRlRGVmaW5pdGlvbigpO1xuICAgIHRoaXMuX2Jhc2UuX2Z1bmN0aW9uc1t0aGlzLl9uYW1lXSA9IHRoaXMuX2RlZmluaXRpb247XG4gICAgcmV0dXJuIGAke3RoaXMuX25hbWV9KCR7ZGF0YUNvb3JkaW5hdGVzfSwgJHtkYXRhVmFsdWV9LCAke29mZnNldH0pO2A7XG4gIH1cblxuXG4gIGNvbXB1dGVEZWZpbml0aW9uKCkge1xuICAgIHRoaXMuX2RlZmluaXRpb24gPSBgXG52b2lkICR7dGhpcy5fbmFtZX0oaW4gaXZlYzMgZGF0YUNvb3JkaW5hdGVzLCBvdXQgdmVjNCBkYXRhVmFsdWUsIG91dCBpbnQgb2Zmc2V0KXtcbiAgICBcbiAgaW50IGluZGV4ID0gZGF0YUNvb3JkaW5hdGVzLnhcbiAgICAgICAgICAgICsgZGF0YUNvb3JkaW5hdGVzLnkgKiB1RGF0YURpbWVuc2lvbnMueFxuICAgICAgICAgICAgKyBkYXRhQ29vcmRpbmF0ZXMueiAqIHVEYXRhRGltZW5zaW9ucy55ICogdURhdGFEaW1lbnNpb25zLng7XG4gIGludCBpbmRleFAgPSBpbnQoaW5kZXgvdVBhY2tlZFBlclBpeGVsKTtcbiAgb2Zmc2V0ID0gaW5kZXggLSAyKmluZGV4UDtcblxuICAvLyBNYXAgZGF0YSBpbmRleCB0byByaWdodCBzYW1wbGVyMkQgdGV4dHVyZVxuICBpbnQgdm94ZWxzUGVyVGV4dHVyZSA9IHVUZXh0dXJlU2l6ZSp1VGV4dHVyZVNpemU7XG4gIGludCB0ZXh0dXJlSW5kZXggPSBpbnQoZmxvb3IoZmxvYXQoaW5kZXhQKSAvIGZsb2F0KHZveGVsc1BlclRleHR1cmUpKSk7XG4gIC8vIG1vZHVsbyBzZWVtcyBpbmNvcnJlY3Qgc29tZXRpbWVzLi4uXG4gIC8vIGludCBpblRleHR1cmVJbmRleCA9IGludChtb2QoZmxvYXQoaW5kZXgpLCBmbG9hdCh0ZXh0dXJlU2l6ZSp0ZXh0dXJlU2l6ZSkpKTtcbiAgaW50IGluVGV4dHVyZUluZGV4ID0gaW5kZXhQIC0gdm94ZWxzUGVyVGV4dHVyZSp0ZXh0dXJlSW5kZXg7XG5cbiAgLy8gR2V0IHJvdyBhbmQgY29sdW1uIGluIHRoZSB0ZXh0dXJlXG4gIGludCBjb2xJbmRleCA9IGludChtb2QoZmxvYXQoaW5UZXh0dXJlSW5kZXgpLCBmbG9hdCh1VGV4dHVyZVNpemUpKSk7XG4gIGludCByb3dJbmRleCA9IGludChmbG9vcihmbG9hdChpblRleHR1cmVJbmRleCkvZmxvYXQodVRleHR1cmVTaXplKSkpO1xuXG4gIC8vIE1hcCByb3cgYW5kIGNvbHVtbiB0byB1dlxuICB2ZWMyIHV2ID0gdmVjMigwLDApO1xuICB1di54ID0gKDAuNSArIGZsb2F0KGNvbEluZGV4KSkgLyBmbG9hdCh1VGV4dHVyZVNpemUpO1xuICB1di55ID0gMS4gLSAoMC41ICsgZmxvYXQocm93SW5kZXgpKSAvIGZsb2F0KHVUZXh0dXJlU2l6ZSk7XG5cbiAgLy9cbiAgaWYodGV4dHVyZUluZGV4ID09IDApeyBkYXRhVmFsdWUgPSB0ZXh0dXJlMkQodVRleHR1cmVDb250YWluZXJbMF0sIHV2KTsgfVxuICBlbHNlIGlmKHRleHR1cmVJbmRleCA9PSAxKXtkYXRhVmFsdWUgPSB0ZXh0dXJlMkQodVRleHR1cmVDb250YWluZXJbMV0sIHV2KTt9XG4gIGVsc2UgaWYodGV4dHVyZUluZGV4ID09IDIpeyBkYXRhVmFsdWUgPSB0ZXh0dXJlMkQodVRleHR1cmVDb250YWluZXJbMl0sIHV2KTsgfVxuICBlbHNlIGlmKHRleHR1cmVJbmRleCA9PSAzKXsgZGF0YVZhbHVlID0gdGV4dHVyZTJEKHVUZXh0dXJlQ29udGFpbmVyWzNdLCB1dik7IH1cbiAgZWxzZSBpZih0ZXh0dXJlSW5kZXggPT0gNCl7IGRhdGFWYWx1ZSA9IHRleHR1cmUyRCh1VGV4dHVyZUNvbnRhaW5lcls0XSwgdXYpOyB9XG4gIGVsc2UgaWYodGV4dHVyZUluZGV4ID09IDUpeyBkYXRhVmFsdWUgPSB0ZXh0dXJlMkQodVRleHR1cmVDb250YWluZXJbNV0sIHV2KTsgfVxuICBlbHNlIGlmKHRleHR1cmVJbmRleCA9PSA2KXsgZGF0YVZhbHVlID0gdGV4dHVyZTJEKHVUZXh0dXJlQ29udGFpbmVyWzZdLCB1dik7IH1cblxufVxuICAgIGA7XG4gIH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBuZXcgVGV4dHVyZTNkKCk7XG4iLCJpbXBvcnQgU2hhZGVyc0Jhc2UgZnJvbSAnLi4vc2hhZGVycy5iYXNlJztcblxuY2xhc3MgVW5wYWNrIGV4dGVuZHMgU2hhZGVyc0Jhc2Uge1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5uYW1lID0gJ3VucGFjayc7XG5cbiAgICAvLyBkZWZhdWx0IHByb3BlcnRpZXMgbmFtZXNcbiAgICB0aGlzLl9wYWNrZWREYXRhID0gJ3BhY2tlZERhdGEnO1xuICAgIHRoaXMuX29mZnNldCA9ICdvZmZzZXQnO1xuICAgIHRoaXMuX3VucGFja2VkRGF0YSA9ICd1bnBhY2tlZERhdGEnO1xuXG4gICAgdGhpcy5fYmFzZS5fdW5pZm9ybXMgPXtcbiAgICAgIHVOdW1iZXJPZkNoYW5uZWxzOiB7XG4gICAgICAgIHZhbHVlOiAxLFxuICAgICAgfSxcbiAgICAgIHVCaXRzQWxsb2NhdGVkOiB7XG4gICAgICAgIHZhbHVlOiAxNixcbiAgICAgIH0sXG4gICAgICB1UGl4ZWxUeXBlOiB7XG4gICAgICAgIHZhbHVlOiAwLFxuICAgICAgfSxcbiAgICB9O1xuICB9XG5cbiAgYXBpKGJhc2VGcmFnbWVudCA9IHRoaXMuX2Jhc2UsIHBhY2tlZERhdGEgPSB0aGlzLl9wYWNrZWREYXRhLCBvZmZzZXQgPSB0aGlzLl9vZmZzZXQsIHVucGFja2VkRGF0YSA9IHRoaXMuX3VucGFja2VkRGF0YSkge1xuICAgIHRoaXMuX2Jhc2UgPSBiYXNlRnJhZ21lbnQ7XG4gICAgcmV0dXJuIHRoaXMuY29tcHV0ZShwYWNrZWREYXRhLCBvZmZzZXQsIHVucGFja2VkRGF0YSk7XG4gIH1cblxuICBjb21wdXRlKHBhY2tlZERhdGEsIG9mZnNldCwgdW5wYWNrZWREYXRhKSB7XG4gICAgdGhpcy5jb21wdXRlRGVmaW5pdGlvbigpO1xuICAgIHRoaXMuX2Jhc2UuX2Z1bmN0aW9uc1t0aGlzLl9uYW1lXSA9IHRoaXMuX2RlZmluaXRpb247XG4gICAgcmV0dXJuIGAke3RoaXMuX25hbWV9KCR7cGFja2VkRGF0YX0sICR7b2Zmc2V0fSwgJHt1bnBhY2tlZERhdGF9KTtgO1xuICB9XG5cbiAgY29tcHV0ZURlZmluaXRpb24oKSB7XG4gICAgLy8gZnVuIHN0dWZmXG4gICAgbGV0IGNvbnRlbnQgPSAnJztcbiAgICBpZiAodGhpcy5fYmFzZS5fdW5pZm9ybXMudU51bWJlck9mQ2hhbm5lbHMudmFsdWUgPT09IDEpIHtcbiAgICAgIHN3aXRjaCAodGhpcy5fYmFzZS5fdW5pZm9ybXMudUJpdHNBbGxvY2F0ZWQudmFsdWUpIHtcblxuICAgICAgICBjYXNlIDE6XG4gICAgICAgIGNhc2UgODpcbiAgICAgICAgICBjb250ZW50ID0gdGhpcy51cGFjazgoKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIDE2OlxuICAgICAgICAgIGNvbnRlbnQgPSB0aGlzLnVwYWNrMTYoKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIDMyOlxuICAgICAgICAgIGNvbnRlbnQgPSB0aGlzLnVwYWNrMzIoKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGNvbnRlbnQgPSB0aGlzLnVwYWNrRGVmYXVsdCgpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnRlbnQgPSB0aGlzLnVwYWNrSWRlbnRpdHkoKTtcbiAgICB9XG5cbiAgICB0aGlzLl9kZWZpbml0aW9uID0gYFxudm9pZCAke3RoaXMuX25hbWV9KGluIHZlYzQgcGFja2VkRGF0YSwgaW4gaW50IG9mZnNldCwgb3V0IHZlYzQgdW5wYWNrZWREYXRhKXtcblxuJHtjb250ZW50fVxuXG59ICBcbiAgICBgO1xuICB9XG5cbiAgdXBhY2s4KCkge1xuICAgIHRoaXMuX2Jhc2UuX2Z1bmN0aW9uc1sndUludDgnXSA9IHRoaXMudUludDgoKTtcblxuICAgIHJldHVybiBgXG51SW50OChcbiAgcGFja2VkRGF0YS5yLFxuICB1bnBhY2tlZERhdGEueCk7XG4gICAgYDtcbiAgfVxuXG4gIHVwYWNrMTYoKSB7XG4gICAgdGhpcy5fYmFzZS5fZnVuY3Rpb25zWyd1SW50MTYnXSA9IHRoaXMudUludDE2KCk7XG5cbiAgICByZXR1cm4gYFxudUludDE2KFxuICBwYWNrZWREYXRhLnIgKiBmbG9hdCggMSAtIG9mZnNldCkgKyBwYWNrZWREYXRhLmIgKiBmbG9hdChvZmZzZXQpLFxuICBwYWNrZWREYXRhLmcgKiBmbG9hdCggMSAtIG9mZnNldCkgKyBwYWNrZWREYXRhLmEgKiBmbG9hdChvZmZzZXQpLFxuICB1bnBhY2tlZERhdGEueCk7XG4gICAgYDtcbiAgfVxuXG4gIHVwYWNrMzIoKSB7XG4gICAgaWYgKHRoaXMuX2Jhc2UuX3VuaWZvcm1zLnVQaXhlbFR5cGUudmFsdWUgPT09IDApIHtcbiAgICAgIHRoaXMuX2Jhc2UuX2Z1bmN0aW9uc1sndUludDMyJ10gPSB0aGlzLnVJbnQzMigpO1xuXG4gICAgICByZXR1cm4gYFxudUludDMyKFxuICBwYWNrZWREYXRhLnIsXG4gIHBhY2tlZERhdGEuZyxcbiAgcGFja2VkRGF0YS5iLFxuICBwYWNrZWREYXRhLmEsXG4gIHVucGFja2VkRGF0YS54KTtcbiAgICAgIGA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2Jhc2UuX2Z1bmN0aW9uc1sndUZsb2F0MzInXSA9IHRoaXMudUZsb2F0MzIoKTtcblxuICAgICAgcmV0dXJuIGBcbnVGbG9hdDMyKFxuICBwYWNrZWREYXRhLnIsXG4gIHBhY2tlZERhdGEuZyxcbiAgcGFja2VkRGF0YS5iLFxuICBwYWNrZWREYXRhLmEsXG4gIHVucGFja2VkRGF0YS54KTtcbiAgICAgIGA7XG4gICAgfVxuICB9XG5cbiAgdXBhY2tJZGVudGl0eSgpIHtcbiAgICByZXR1cm4gYFxuXG51bnBhY2tlZERhdGEgPSBwYWNrZWREYXRhO1xuXG4gICAgICBgO1xuICB9XG5cbiAgdUludDgoKSB7XG4gICAgcmV0dXJuIGBcbnZvaWQgdUludDgoaW4gZmxvYXQgciwgb3V0IGZsb2F0IHZhbHVlKXtcbiAgdmFsdWUgPSByICogMjU2Ljtcbn1cbiAgICBgO1xuICB9XG5cbiAgdUludDE2KCkge1xuICAgIHJldHVybiBgXG52b2lkIHVJbnQxNihpbiBmbG9hdCByLCBpbiBmbG9hdCBhLCBvdXQgZmxvYXQgdmFsdWUpe1xuICB2YWx1ZSA9IHIgKiAyNTYuICsgYSAqIDY1NTM2Ljtcbn1cbiAgICBgO1xuICB9XG5cbiAgdUludDMyKCkge1xuICAgIHJldHVybiBgXG52b2lkIHVJbnQzMihpbiBmbG9hdCByLCBpbiBmbG9hdCBnLCBpbiBmbG9hdCBiLCBpbiBmbG9hdCBhLCBvdXQgZmxvYXQgdmFsdWUpe1xuICB2YWx1ZSA9IHIgKiAyNTYuICsgZyAqIDY1NTM2LiArIGIgKiAxNjc3NzIxNi4gKyBhICogNDI5NDk2NzI5Ni47XG59XG4gICAgYDtcbiAgfVxuXG4gIHVGbG9hdDMyKCkge1xuICAgIHJldHVybiBgXG52b2lkIHVGbG9hdDMyKGluIGZsb2F0IHIsIGluIGZsb2F0IGcsIGluIGZsb2F0IGIsIGluIGZsb2F0IGEsIG91dCBmbG9hdCB2YWx1ZSl7XG5cbiAgLy8gY3JlYXRlIGFycmF5cyBjb250YWluaW5nIGJpdHMgZm9yIHJnYmEgdmFsdWVzXG4gIC8vIHZhbHVlIGJldHdlZW4gMCBhbmQgMjU1XG4gIHZhbHVlID0gciAqIDI1NS47XG4gIGludCBieXRlbWVSWzhdO1xuICBieXRlbWVSWzBdID0gaW50KGZsb29yKHZhbHVlIC8gMTI4LikpO1xuICB2YWx1ZSAtPSBmbG9hdChieXRlbWVSWzBdICogMTI4KTtcbiAgYnl0ZW1lUlsxXSA9IGludChmbG9vcih2YWx1ZSAvIDY0LikpO1xuICB2YWx1ZSAtPSBmbG9hdChieXRlbWVSWzFdICogNjQpO1xuICBieXRlbWVSWzJdID0gaW50KGZsb29yKHZhbHVlIC8gMzIuKSk7XG4gIHZhbHVlIC09IGZsb2F0KGJ5dGVtZVJbMl0gKiAzMik7XG4gIGJ5dGVtZVJbM10gPSBpbnQoZmxvb3IodmFsdWUgLyAxNi4pKTtcbiAgdmFsdWUgLT0gZmxvYXQoYnl0ZW1lUlszXSAqIDE2KTtcbiAgYnl0ZW1lUls0XSA9IGludChmbG9vcih2YWx1ZSAvIDguKSk7XG4gIHZhbHVlIC09IGZsb2F0KGJ5dGVtZVJbNF0gKiA4KTtcbiAgYnl0ZW1lUls1XSA9IGludChmbG9vcih2YWx1ZSAvIDQuKSk7XG4gIHZhbHVlIC09IGZsb2F0KGJ5dGVtZVJbNV0gKiA0KTtcbiAgYnl0ZW1lUls2XSA9IGludChmbG9vcih2YWx1ZSAvIDIuKSk7XG4gIHZhbHVlIC09IGZsb2F0KGJ5dGVtZVJbNl0gKiAyKTtcbiAgYnl0ZW1lUls3XSA9IGludChmbG9vcih2YWx1ZSkpO1xuXG4gIHZhbHVlID0gZyAqIDI1NS47XG4gIGludCBieXRlbWVHWzhdO1xuICBieXRlbWVHWzBdID0gaW50KGZsb29yKHZhbHVlIC8gMTI4LikpO1xuICB2YWx1ZSAtPSBmbG9hdChieXRlbWVHWzBdICogMTI4KTtcbiAgYnl0ZW1lR1sxXSA9IGludChmbG9vcih2YWx1ZSAvIDY0LikpO1xuICB2YWx1ZSAtPSBmbG9hdChieXRlbWVHWzFdICogNjQpO1xuICBieXRlbWVHWzJdID0gaW50KGZsb29yKHZhbHVlIC8gMzIuKSk7XG4gIHZhbHVlIC09IGZsb2F0KGJ5dGVtZUdbMl0gKiAzMik7XG4gIGJ5dGVtZUdbM10gPSBpbnQoZmxvb3IodmFsdWUgLyAxNi4pKTtcbiAgdmFsdWUgLT0gZmxvYXQoYnl0ZW1lR1szXSAqIDE2KTtcbiAgYnl0ZW1lR1s0XSA9IGludChmbG9vcih2YWx1ZSAvIDguKSk7XG4gIHZhbHVlIC09IGZsb2F0KGJ5dGVtZUdbNF0gKiA4KTtcbiAgYnl0ZW1lR1s1XSA9IGludChmbG9vcih2YWx1ZSAvIDQuKSk7XG4gIHZhbHVlIC09IGZsb2F0KGJ5dGVtZUdbNV0gKiA0KTtcbiAgYnl0ZW1lR1s2XSA9IGludChmbG9vcih2YWx1ZSAvIDIuKSk7XG4gIHZhbHVlIC09IGZsb2F0KGJ5dGVtZUdbNl0gKiAyKTtcbiAgYnl0ZW1lR1s3XSA9IGludChmbG9vcih2YWx1ZSkpO1xuXG4gIHZhbHVlID0gYiAqIDI1NS47XG4gIGludCBieXRlbWVCWzhdO1xuICBieXRlbWVCWzBdID0gaW50KGZsb29yKHZhbHVlIC8gMTI4LikpO1xuICB2YWx1ZSAtPSBmbG9hdChieXRlbWVCWzBdICogMTI4KTtcbiAgYnl0ZW1lQlsxXSA9IGludChmbG9vcih2YWx1ZSAvIDY0LikpO1xuICB2YWx1ZSAtPSBmbG9hdChieXRlbWVCWzFdICogNjQpO1xuICBieXRlbWVCWzJdID0gaW50KGZsb29yKHZhbHVlIC8gMzIuKSk7XG4gIHZhbHVlIC09IGZsb2F0KGJ5dGVtZUJbMl0gKiAzMik7XG4gIGJ5dGVtZUJbM10gPSBpbnQoZmxvb3IodmFsdWUgLyAxNi4pKTtcbiAgdmFsdWUgLT0gZmxvYXQoYnl0ZW1lQlszXSAqIDE2KTtcbiAgYnl0ZW1lQls0XSA9IGludChmbG9vcih2YWx1ZSAvIDguKSk7XG4gIHZhbHVlIC09IGZsb2F0KGJ5dGVtZUJbNF0gKiA4KTtcbiAgYnl0ZW1lQls1XSA9IGludChmbG9vcih2YWx1ZSAvIDQuKSk7XG4gIHZhbHVlIC09IGZsb2F0KGJ5dGVtZUJbNV0gKiA0KTtcbiAgYnl0ZW1lQls2XSA9IGludChmbG9vcih2YWx1ZSAvIDIuKSk7XG4gIHZhbHVlIC09IGZsb2F0KGJ5dGVtZUJbNl0gKiAyKTtcbiAgYnl0ZW1lQls3XSA9IGludChmbG9vcih2YWx1ZSkpO1xuXG4gIHZhbHVlID0gYSAqIDI1NS47XG4gIGludCBieXRlbWVBWzhdO1xuICBieXRlbWVBWzBdID0gaW50KGZsb29yKHZhbHVlIC8gMTI4LikpO1xuICB2YWx1ZSAtPSBmbG9hdChieXRlbWVBWzBdICogMTI4KTtcbiAgYnl0ZW1lQVsxXSA9IGludChmbG9vcih2YWx1ZSAvIDY0LikpO1xuICB2YWx1ZSAtPSBmbG9hdChieXRlbWVBWzFdICogNjQpO1xuICBieXRlbWVBWzJdID0gaW50KGZsb29yKHZhbHVlIC8gMzIuKSk7XG4gIHZhbHVlIC09IGZsb2F0KGJ5dGVtZUFbMl0gKiAzMik7XG4gIGJ5dGVtZUFbM10gPSBpbnQoZmxvb3IodmFsdWUgLyAxNi4pKTtcbiAgdmFsdWUgLT0gZmxvYXQoYnl0ZW1lQVszXSAqIDE2KTtcbiAgYnl0ZW1lQVs0XSA9IGludChmbG9vcih2YWx1ZSAvIDguKSk7XG4gIHZhbHVlIC09IGZsb2F0KGJ5dGVtZUFbNF0gKiA4KTtcbiAgYnl0ZW1lQVs1XSA9IGludChmbG9vcih2YWx1ZSAvIDQuKSk7XG4gIHZhbHVlIC09IGZsb2F0KGJ5dGVtZUFbNV0gKiA0KTtcbiAgYnl0ZW1lQVs2XSA9IGludChmbG9vcih2YWx1ZSAvIDIuKSk7XG4gIHZhbHVlIC09IGZsb2F0KGJ5dGVtZUFbNl0gKiAyKTtcbiAgYnl0ZW1lQVs3XSA9IGludChmbG9vcih2YWx1ZSkpO1xuXG4gIC8vIGNvbXB1dGUgZmxvYXQzMiB2YWx1ZSBmcm9tIGJpdCBhcnJheXNcblxuICAvLyBzaWduXG4gIGludCBpc3NpZ25lZCA9IDEgLSAyICogYnl0ZW1lUlswXTtcbiAgLy8gICBpc3NpZ25lZCA9IGludChwb3coLTEuLCBmbG9hdChieXRlbWVSWzBdKSkpO1xuXG4gIC8vIGV4cG9uZW50XG4gIGludCBleHBvbmVudCA9IDA7XG5cbiAgZXhwb25lbnQgKz0gYnl0ZW1lUlsxXSAqIGludChwb3coMi4sIDcuKSk7XG4gIGV4cG9uZW50ICs9IGJ5dGVtZVJbMl0gKiBpbnQocG93KDIuLCA2LikpO1xuICBleHBvbmVudCArPSBieXRlbWVSWzNdICogaW50KHBvdygyLiwgNS4pKTtcbiAgZXhwb25lbnQgKz0gYnl0ZW1lUls0XSAqIGludChwb3coMi4sIDQuKSk7XG4gIGV4cG9uZW50ICs9IGJ5dGVtZVJbNV0gKiBpbnQocG93KDIuLCAzLikpO1xuICBleHBvbmVudCArPSBieXRlbWVSWzZdICogaW50KHBvdygyLiwgMi4pKTtcbiAgZXhwb25lbnQgKz0gYnl0ZW1lUls3XSAqIGludChwb3coMi4sIDEuKSk7XG5cbiAgZXhwb25lbnQgKz0gYnl0ZW1lR1swXTtcblxuXG4gIC8vIGZyYWN0aW9uXG4gIGZsb2F0IGZyYWN0aW9uID0gMC47XG5cbiAgZnJhY3Rpb24gPSBmbG9hdChieXRlbWVHWzFdKSAqIHBvdygyLiwgLTEuKTtcbiAgZnJhY3Rpb24gKz0gZmxvYXQoYnl0ZW1lR1syXSkgKiBwb3coMi4sIC0yLik7XG4gIGZyYWN0aW9uICs9IGZsb2F0KGJ5dGVtZUdbM10pICogcG93KDIuLCAtMy4pO1xuICBmcmFjdGlvbiArPSBmbG9hdChieXRlbWVHWzRdKSAqIHBvdygyLiwgLTQuKTtcbiAgZnJhY3Rpb24gKz0gZmxvYXQoYnl0ZW1lR1s1XSkgKiBwb3coMi4sIC01Lik7XG4gIGZyYWN0aW9uICs9IGZsb2F0KGJ5dGVtZUdbNl0pICogcG93KDIuLCAtNi4pO1xuICBmcmFjdGlvbiArPSBmbG9hdChieXRlbWVHWzddKSAqIHBvdygyLiwgLTcuKTtcblxuICBmcmFjdGlvbiArPSBmbG9hdChieXRlbWVCWzBdKSAqIHBvdygyLiwgLTguKTtcbiAgZnJhY3Rpb24gKz0gZmxvYXQoYnl0ZW1lQlsxXSkgKiBwb3coMi4sIC05Lik7XG4gIGZyYWN0aW9uICs9IGZsb2F0KGJ5dGVtZUJbMl0pICogcG93KDIuLCAtMTAuKTtcbiAgZnJhY3Rpb24gKz0gZmxvYXQoYnl0ZW1lQlszXSkgKiBwb3coMi4sIC0xMS4pO1xuICBmcmFjdGlvbiArPSBmbG9hdChieXRlbWVCWzRdKSAqIHBvdygyLiwgLTEyLik7XG4gIGZyYWN0aW9uICs9IGZsb2F0KGJ5dGVtZUJbNV0pICogcG93KDIuLCAtMTMuKTtcbiAgZnJhY3Rpb24gKz0gZmxvYXQoYnl0ZW1lQls2XSkgKiBwb3coMi4sIC0xNC4pO1xuICBmcmFjdGlvbiArPSBmbG9hdChieXRlbWVCWzddKSAqIHBvdygyLiwgLTE1Lik7XG5cbiAgZnJhY3Rpb24gKz0gZmxvYXQoYnl0ZW1lQVswXSkgKiBwb3coMi4sIC0xNi4pO1xuICBmcmFjdGlvbiArPSBmbG9hdChieXRlbWVBWzFdKSAqIHBvdygyLiwgLTE3Lik7XG4gIGZyYWN0aW9uICs9IGZsb2F0KGJ5dGVtZUFbMl0pICogcG93KDIuLCAtMTguKTtcbiAgZnJhY3Rpb24gKz0gZmxvYXQoYnl0ZW1lQVszXSkgKiBwb3coMi4sIC0xOS4pO1xuICBmcmFjdGlvbiArPSBmbG9hdChieXRlbWVBWzRdKSAqIHBvdygyLiwgLTIwLik7XG4gIGZyYWN0aW9uICs9IGZsb2F0KGJ5dGVtZUFbNV0pICogcG93KDIuLCAtMjEuKTtcbiAgZnJhY3Rpb24gKz0gZmxvYXQoYnl0ZW1lQVs2XSkgKiBwb3coMi4sIC0yMi4pO1xuICBmcmFjdGlvbiArPSBmbG9hdChieXRlbWVBWzddKSAqIHBvdygyLiwgLTIzLik7XG5cbiAgdmFsdWUgPSBmbG9hdChpc3NpZ25lZCkgKiBwb3coIDIuLCBmbG9hdChleHBvbmVudCAtIDEyNykpICogKDEuICsgZnJhY3Rpb24pO1xufVxuICAgIGA7XG4gIH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBuZXcgVW5wYWNrKCk7XG4iLCJpbXBvcnQgU2hhZGVyc0Jhc2UgZnJvbSAnLi4vc2hhZGVycy5iYXNlJztcbmltcG9ydCBVbnBhY2sgZnJvbSAnLi4vaGVscGVycy9zaGFkZXJzLmhlbHBlcnMudW5wYWNrJztcbmltcG9ydCBUZXh0dXJlM2QgZnJvbSAnLi4vaGVscGVycy9zaGFkZXJzLmhlbHBlcnMudGV4dHVyZTNkJztcblxuXG5jbGFzcyBJbnRlcnBvbGF0aW9uSWRlbnRpdHkgZXh0ZW5kcyBTaGFkZXJzQmFzZSB7XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLm5hbWUgPSAnaW50ZXJwb2xhdGlvbklkZW50aXR5JztcblxuICAgIC8vIGRlZmF1bHQgcHJvcGVydGllcyBuYW1lc1xuICAgIHRoaXMuX2N1cnJlbnRWb3hlbCA9ICdjdXJyZW50Vm94ZWwnO1xuICAgIHRoaXMuX2RhdGFWYWx1ZSA9ICdkYXRhVmFsdWUnO1xuICB9XG5cbiAgICBhcGkoYmFzZUZyYWdtZW50ID0gdGhpcy5fYmFzZSwgY3VycmVudFZveGVsID0gdGhpcy5fY3VycmVudFZveGVsLCBkYXRhVmFsdWUgPSB0aGlzLl9kYXRhVmFsdWUpIHtcbiAgICB0aGlzLl9iYXNlID0gYmFzZUZyYWdtZW50O1xuICAgIHJldHVybiB0aGlzLmNvbXB1dGUoY3VycmVudFZveGVsLCBkYXRhVmFsdWUpO1xuICB9XG5cbiAgY29tcHV0ZShjdXJyZW50Vm94ZWwsIGRhdGFWYWx1ZSkge1xuICAgIHRoaXMuY29tcHV0ZURlZmluaXRpb24oKTtcbiAgICB0aGlzLl9iYXNlLl9mdW5jdGlvbnNbdGhpcy5fbmFtZV0gPSB0aGlzLl9kZWZpbml0aW9uO1xuICAgIHJldHVybiBgJHt0aGlzLl9uYW1lfSgke2N1cnJlbnRWb3hlbH0sICR7ZGF0YVZhbHVlfSk7YDtcbiAgfVxuXG5cbiAgY29tcHV0ZURlZmluaXRpb24oKSB7XG4gICAgdGhpcy5fZGVmaW5pdGlvbiA9IGBcbnZvaWQgJHt0aGlzLl9uYW1lfShpbiB2ZWMzIGN1cnJlbnRWb3hlbCwgb3V0IHZlYzQgZGF0YVZhbHVlKXtcbiAgLy8gbG93ZXIgYm91bmRcbiAgdmVjMyByY3VycmVudFZveGVsID0gdmVjMyhmbG9vcihjdXJyZW50Vm94ZWwueCArIDAuNSApLCBmbG9vcihjdXJyZW50Vm94ZWwueSArIDAuNSApLCBmbG9vcihjdXJyZW50Vm94ZWwueiArIDAuNSApKTtcbiAgaXZlYzMgdm94ZWwgPSBpdmVjMyhpbnQocmN1cnJlbnRWb3hlbC54KSwgaW50KHJjdXJyZW50Vm94ZWwueSksIGludChyY3VycmVudFZveGVsLnopKTtcblxuICB2ZWM0IHRtcCA9IHZlYzQoMC4sIDAuLCAwLiwgMC4pO1xuICBpbnQgb2Zmc2V0ID0gMDtcblxuICAke1RleHR1cmUzZC5hcGkodGhpcy5fYmFzZSwgJ3ZveGVsJywgJ3RtcCcsICdvZmZzZXQnKX1cbiAgJHtVbnBhY2suYXBpKHRoaXMuX2Jhc2UsICd0bXAnLCAnb2Zmc2V0JywgJ2RhdGFWYWx1ZScpfVxufVxuICAgIGA7XG4gIH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBuZXcgSW50ZXJwb2xhdGlvbklkZW50aXR5KCk7XG4iLCJpbXBvcnQgSW50ZXJwb2xhdGlvbklkZW50aXR5IGZyb20gJy4vc2hhZGVycy5pbnRlcnBvbGF0aW9uLmlkZW50aXR5JztcbmltcG9ydCBJbnRlcnBvbGF0aW9uVHJpbGluZWFyIGZyb20gJy4vc2hhZGVycy5pbnRlcnBvbGF0aW9uLnRyaWxpbmVhcic7XG5cbmZ1bmN0aW9uIHNoYWRlcnNJbnRlcnBvbGF0aW9uKGJhc2VGcmFnbWVudCwgY3VycmVudFZveGVsLCBkYXRhVmFsdWUsIGdyYWRpZW50KSB7XG4gIHN3aXRjaChiYXNlRnJhZ21lbnQuX3VuaWZvcm1zLnVJbnRlcnBvbGF0aW9uLnZhbHVlKSB7XG5cbiAgICBjYXNlIDA6XG4gICAgICAvLyBubyBpbnRlcnBvbGF0aW9uXG4gICAgICByZXR1cm4gSW50ZXJwb2xhdGlvbklkZW50aXR5LmFwaShiYXNlRnJhZ21lbnQsIGN1cnJlbnRWb3hlbCwgZGF0YVZhbHVlKTtcblxuICAgIGNhc2UgMTpcbiAgICAgIC8vIHRyaWxpbmVhciBpbnRlcnBvbGF0aW9uXG4gICAgICByZXR1cm4gSW50ZXJwb2xhdGlvblRyaWxpbmVhci5hcGkoYmFzZUZyYWdtZW50LCBjdXJyZW50Vm94ZWwsIGRhdGFWYWx1ZSwgZ3JhZGllbnQpO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBJbnRlcnBvbGF0aW9uSWRlbnRpdHkuYXBpKGJhc2VGcmFnbWVudCwgY3VycmVudFZveGVsLCBkYXRhVmFsdWUpO1xuXG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgc2hhZGVyc0ludGVycG9sYXRpb247XG4iLCJpbXBvcnQgU2hhZGVyc0Jhc2UgZnJvbSAnLi4vc2hhZGVycy5iYXNlJztcbmltcG9ydCBJbnRlcnBvbGF0aW9uSWRlbnRpdHkgZnJvbSAnLi9zaGFkZXJzLmludGVycG9sYXRpb24uaWRlbnRpdHknO1xuXG5jbGFzcyBJbnRlcnBvbGF0aW9uVHJpbGluZWFyIGV4dGVuZHMgU2hhZGVyc0Jhc2Uge1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5uYW1lID0gJ2ludGVycG9sYXRpb25UcmlsaW5lYXInO1xuXG4gICAgLy8gZGVmYXVsdCBwcm9wZXJ0aWVzIG5hbWVzXG4gICAgdGhpcy5fY3VycmVudFZveGVsID0gJ2N1cnJlbnRWb3hlbCc7XG4gICAgdGhpcy5fZGF0YVZhbHVlID0gJ2RhdGFWYWx1ZSc7XG4gICAgdGhpcy5fZ3JhZGllbnQgPSAnZ3JhZGllbnQnO1xuICB9XG5cbiAgYXBpKGJhc2VGcmFnbWVudCA9IHRoaXMuX2Jhc2UsIGN1cnJlbnRWb3hlbCA9IHRoaXMuX2N1cnJlbnRWb3hlbCwgZGF0YVZhbHVlID0gdGhpcy5fZGF0YVZhbHVlLCBncmFkaWVudCA9IHRoaXMuX2dyYWRpZW50KSB7XG4gICAgdGhpcy5fYmFzZSA9IGJhc2VGcmFnbWVudDtcbiAgICByZXR1cm4gdGhpcy5jb21wdXRlKGN1cnJlbnRWb3hlbCwgZGF0YVZhbHVlLCBncmFkaWVudCk7XG4gIH1cblxuICBjb21wdXRlKGN1cnJlbnRWb3hlbCwgZGF0YVZhbHVlLCBncmFkaWVudCkge1xuICAgIHRoaXMuY29tcHV0ZURlZmluaXRpb24oKTtcbiAgICB0aGlzLl9iYXNlLl9mdW5jdGlvbnNbdGhpcy5fbmFtZV0gPSB0aGlzLl9kZWZpbml0aW9uO1xuICAgIHJldHVybiBgJHt0aGlzLl9uYW1lfSgke2N1cnJlbnRWb3hlbH0sICR7ZGF0YVZhbHVlfSwgJHtncmFkaWVudH0pO2A7XG4gIH1cblxuICBjb21wdXRlRGVmaW5pdGlvbigpIHtcbiAgICB0aGlzLl9kZWZpbml0aW9uID0gYFxudm9pZCAke3RoaXMuX25hbWV9KGluIHZlYzMgY3VycmVudFZveGVsLCBvdXQgdmVjNCBkYXRhVmFsdWUsIG91dCB2ZWMzIGdyYWRpZW50KXtcblxuICAvLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9UcmlsaW5lYXJfaW50ZXJwb2xhdGlvblxuICB2ZWMzIGxvd2VyX2JvdW5kID0gdmVjMyhmbG9vcihjdXJyZW50Vm94ZWwueCksIGZsb29yKGN1cnJlbnRWb3hlbC55KSwgZmxvb3IoY3VycmVudFZveGVsLnopKTtcbiAgaWYobG93ZXJfYm91bmQueCA8IDAuKXtcbiAgICBsb3dlcl9ib3VuZC54ID0gMC47XG4gIH1cbiAgaWYobG93ZXJfYm91bmQueSA8IDAuKXtcbiAgICBsb3dlcl9ib3VuZC55ID0gMC47XG4gIH1cbiAgaWYobG93ZXJfYm91bmQueiA8IDAuKXtcbiAgICBsb3dlcl9ib3VuZC56ID0gMC47XG4gIH1cbiAgXG4gIHZlYzMgaGlnaGVyX2JvdW5kID0gbG93ZXJfYm91bmQgKyB2ZWMzKDEpO1xuXG4gIGZsb2F0IHhkID0gKCBjdXJyZW50Vm94ZWwueCAtIGxvd2VyX2JvdW5kLnggKSAvICggaGlnaGVyX2JvdW5kLnggLSBsb3dlcl9ib3VuZC54ICk7XG4gIGZsb2F0IHlkID0gKCBjdXJyZW50Vm94ZWwueSAtIGxvd2VyX2JvdW5kLnkgKSAvICggaGlnaGVyX2JvdW5kLnkgLSBsb3dlcl9ib3VuZC55ICk7XG4gIGZsb2F0IHpkID0gKCBjdXJyZW50Vm94ZWwueiAtIGxvd2VyX2JvdW5kLnogKSAvICggaGlnaGVyX2JvdW5kLnogLSBsb3dlcl9ib3VuZC56ICk7XG5cbiAgLy9cbiAgLy8gYzAwXG4gIC8vXG5cbiAgLy9cblxuICB2ZWM0IHYwMDAgPSB2ZWM0KDAuMCwgMC4wLCAwLjAsIDAuMCk7XG4gIHZlYzMgYzAwMCA9IHZlYzMobG93ZXJfYm91bmQueCwgbG93ZXJfYm91bmQueSwgbG93ZXJfYm91bmQueik7XG4gICR7SW50ZXJwb2xhdGlvbklkZW50aXR5LmFwaSh0aGlzLl9iYXNlLCAnYzAwMCcsICd2MDAwJyl9XG4gIHZlYzMgZzAwMCA9IHYwMDAuciAqIHZlYzMoLTEuLCAtMS4sIC0xLik7XG5cbiAgLy9cblxuICB2ZWM0IHYxMDAgPSB2ZWM0KDAuMCwgMC4wLCAwLjAsIDAuMCk7XG4gIHZlYzMgYzEwMCA9IHZlYzMoaGlnaGVyX2JvdW5kLngsIGxvd2VyX2JvdW5kLnksIGxvd2VyX2JvdW5kLnopO1xuICAke0ludGVycG9sYXRpb25JZGVudGl0eS5hcGkodGhpcy5fYmFzZSwgJ2MxMDAnLCAndjEwMCcpfVxuICB2ZWMzIGcxMDAgPSB2MTAwLnIgKiB2ZWMzKDEuLCAtMS4sIC0xLik7XG5cbiAgdmVjNCBjMDAgPSB2MDAwICogKCAxLjAgLSB4ZCApICsgdjEwMCAqIHhkO1xuXG4gIC8vXG4gIC8vIGMwMVxuICAvL1xuICB2ZWM0IHYwMDEgPSB2ZWM0KDAuMCwgMC4wLCAwLjAsIDAuMCk7XG4gIHZlYzMgYzAwMSA9IHZlYzMobG93ZXJfYm91bmQueCwgbG93ZXJfYm91bmQueSwgaGlnaGVyX2JvdW5kLnopO1xuICAke0ludGVycG9sYXRpb25JZGVudGl0eS5hcGkodGhpcy5fYmFzZSwgJ2MwMDEnLCAndjAwMScpfVxuICB2ZWMzIGcwMDEgPSB2MDAxLnIgKiB2ZWMzKC0xLiwgLTEuLCAxLik7XG5cbiAgdmVjNCB2MTAxID0gdmVjNCgwLjAsIDAuMCwgMC4wLCAwLjApO1xuICB2ZWMzIGMxMDEgPSB2ZWMzKGhpZ2hlcl9ib3VuZC54LCBsb3dlcl9ib3VuZC55LCBoaWdoZXJfYm91bmQueik7XG4gICR7SW50ZXJwb2xhdGlvbklkZW50aXR5LmFwaSh0aGlzLl9iYXNlLCAnYzEwMScsICd2MTAxJyl9XG4gIHZlYzMgZzEwMSA9IHYxMDEuciAqIHZlYzMoMS4sIC0xLiwgMS4pO1xuXG4gIHZlYzQgYzAxID0gdjAwMSAqICggMS4wIC0geGQgKSArIHYxMDEgKiB4ZDtcblxuICAvL1xuICAvLyBjMTBcbiAgLy9cbiAgdmVjNCB2MDEwID0gdmVjNCgwLjAsIDAuMCwgMC4wLCAwLjApO1xuICB2ZWMzIGMwMTAgPSB2ZWMzKGxvd2VyX2JvdW5kLngsIGhpZ2hlcl9ib3VuZC55LCBsb3dlcl9ib3VuZC56KTtcbiAgJHtJbnRlcnBvbGF0aW9uSWRlbnRpdHkuYXBpKHRoaXMuX2Jhc2UsICdjMDEwJywgJ3YwMTAnKX1cbiAgdmVjMyBnMDEwID0gdjAxMC5yICogdmVjMygtMS4sIDEuLCAtMS4pO1xuXG4gIHZlYzQgdjExMCA9IHZlYzQoMC4wLCAwLjAsIDAuMCwgMC4wKTtcbiAgdmVjMyBjMTEwID0gdmVjMyhoaWdoZXJfYm91bmQueCwgaGlnaGVyX2JvdW5kLnksIGxvd2VyX2JvdW5kLnopO1xuICAke0ludGVycG9sYXRpb25JZGVudGl0eS5hcGkodGhpcy5fYmFzZSwgJ2MxMTAnLCAndjExMCcpfVxuICB2ZWMzIGcxMTAgPSB2MTEwLnIgKiB2ZWMzKDEuLCAxLiwgLTEuKTtcblxuICB2ZWM0IGMxMCA9IHYwMTAgKiAoIDEuMCAtIHhkICkgKyB2MTEwICogeGQ7XG5cbiAgLy9cbiAgLy8gYzExXG4gIC8vXG4gIHZlYzQgdjAxMSA9IHZlYzQoMC4wLCAwLjAsIDAuMCwgMC4wKTtcbiAgdmVjMyBjMDExID0gdmVjMyhsb3dlcl9ib3VuZC54LCBoaWdoZXJfYm91bmQueSwgaGlnaGVyX2JvdW5kLnopO1xuICAke0ludGVycG9sYXRpb25JZGVudGl0eS5hcGkodGhpcy5fYmFzZSwgJ2MwMTEnLCAndjAxMScpfVxuICB2ZWMzIGcwMTEgPSB2MDExLnIgKiB2ZWMzKC0xLiwgMS4sIDEuKTtcblxuICB2ZWM0IHYxMTEgPSB2ZWM0KDAuMCwgMC4wLCAwLjAsIDAuMCk7XG4gIHZlYzMgYzExMSA9IHZlYzMoaGlnaGVyX2JvdW5kLngsIGhpZ2hlcl9ib3VuZC55LCBoaWdoZXJfYm91bmQueik7XG4gICR7SW50ZXJwb2xhdGlvbklkZW50aXR5LmFwaSh0aGlzLl9iYXNlLCAnYzExMScsICd2MTExJyl9XG4gIHZlYzMgZzExMSA9IHYxMTEuciAqIHZlYzMoMS4sIDEuLCAxLik7XG5cbiAgdmVjNCBjMTEgPSB2MDExICogKCAxLjAgLSB4ZCApICsgdjExMSAqIHhkO1xuXG4gIC8vIGMwIGFuZCBjMVxuICB2ZWM0IGMwID0gYzAwICogKCAxLjAgLSB5ZCkgKyBjMTAgKiB5ZDtcbiAgdmVjNCBjMSA9IGMwMSAqICggMS4wIC0geWQpICsgYzExICogeWQ7XG5cbiAgLy8gY1xuICB2ZWM0IGMgPSBjMCAqICggMS4wIC0gemQpICsgYzEgKiB6ZDtcbiAgZGF0YVZhbHVlID0gYztcblxuICAvLyBjb21wdXRlIGdyYWRpZW50XG4gIGdyYWRpZW50ID0gZzAwMCArIGcxMDAgKyBnMDEwICsgZzExMCArIGcwMTEgKyBnMTExICsgZzExMCArIGcwMTE7XG4gIC8vIGdyYWRpZW50TWFnbml0dWRlID0gbGVuZ3RoKGdyYWRpZW50KTtcbiAgLy8gLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTm9ybWFsXyhnZW9tZXRyeSkjVHJhbnNmb3JtaW5nX25vcm1hbHNcbiAgLy8gdmVjMyBsb2NhbE5vcm1hbCA9ICgtMS4gLyBncmFkaWVudE1hZ25pdHVkZSkgKiBncmFkaWVudDtcbiAgLy8gbm9ybWFsID0gbm9ybWFsaXplKG5vcm1hbFBpeGVsVG9QYXRpZW50JHt0aGlzLmlkfSAqIGxvY2FsTm9ybWFsKTtcbiAgLy9ub3JtYWwgPSBncmFkaWVudDtcblxufVxuICAgIGA7XG4gIH1cblxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IG5ldyBJbnRlcnBvbGF0aW9uVHJpbGluZWFyKCk7XG4iLCJleHBvcnQgZGVmYXVsdCBjbGFzcyBTaGFkZXJzQmFzZSB7XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5fbmFtZSA9ICdzaGFkZXJzQmFzZSc7XG4gICAgdGhpcy5fYmFzZSA9IHtcbiAgICAgIF9mdW5jdGlvbnM6IHt9LFxuICAgICAgX3VuaWZvcm1zOiB7fSxcbiAgICB9O1xuICAgIHRoaXMuX2RlZmluaXRpb24gPSAnJztcbiAgfVxuXG4gIGdldCBuYW1lKCkge1xuICAgIHJldHVybiB0aGlzLl9uYW1lO1xuICB9XG5cbiAgc2V0IG5hbWUobmFtZSkge1xuICAgIHRoaXMuX25hbWUgPSBuYW1lO1xuICB9XG59XG4iLCJleHBvcnQgZGVmYXVsdCBjbGFzcyBTaGFkZXJzRnJhZ21lbnQge1xuXG4gIC8vIHBhc3MgdW5pZm9ybXMgb2JqZWN0XG4gIGNvbnN0cnVjdG9yKHVuaWZvcm1zKSB7XG4gICAgdGhpcy5fdW5pZm9ybXMgPSB1bmlmb3JtcztcbiAgICB0aGlzLl9mdW5jdGlvbnMgPSB7fTtcbiAgICB0aGlzLl9tYWluID0gJyc7XG4gIH1cblxuICBmdW5jdGlvbnMoKSB7XG4gICAgaWYodGhpcy5fbWFpbiA9PT0gJycpIHtcbiAgICAgIC8vIGlmIG1haW4gaXMgZW1wdHksIGZ1bmN0aW9ucyBjYW4gbm90IGhhdmUgYmVlbiBjb21wdXRlZFxuICAgICAgdGhpcy5tYWluKCk7XG4gICAgfVxuXG4gICAgbGV0IGNvbnRlbnQgPSAnJztcbiAgICBmb3IgKGxldCBwcm9wZXJ0eSBpbiB0aGlzLl9mdW5jdGlvbnMpIHtcbiAgICAgIGNvbnRlbnQgKz0gdGhpcy5fZnVuY3Rpb25zW3Byb3BlcnR5XSArICdcXG4nO1xuICAgIH1cblxuICAgIHJldHVybiBjb250ZW50O1xuICB9XG5cbiAgdW5pZm9ybXMoKSB7XG4gICAgbGV0IGNvbnRlbnQgPSAnJztcbiAgICBmb3IgKGxldCBwcm9wZXJ0eSBpbiB0aGlzLl91bmlmb3Jtcykge1xuICAgICAgbGV0IHVuaWZvcm0gPSB0aGlzLl91bmlmb3Jtc1twcm9wZXJ0eV07XG4gICAgICBjb250ZW50ICs9IGB1bmlmb3JtICR7dW5pZm9ybS50eXBlR0xTTH0gJHtwcm9wZXJ0eX1gO1xuXG4gICAgICBpZih1bmlmb3JtICYmIHVuaWZvcm0ubGVuZ3RoKSB7XG4gICAgICAgIGNvbnRlbnQgKz0gYFske3VuaWZvcm0ubGVuZ3RofV1gO1xuICAgICAgfVxuXG4gICAgICBjb250ZW50ICs9ICc7XFxuJztcbiAgICB9XG5cbiAgICByZXR1cm4gY29udGVudDtcbiAgfVxuXG4gIG1haW4oKSB7XG4gICAgLy8gbmVlZCB0byBwcmUtY2FsbCBtYWluIHRvIGZpbGwgdXAgdGhlIGZ1bmN0aW9ucyBsaXN0XG4gICAgdGhpcy5fbWFpbiA9IGBcblxuICAgIGZsb2F0IGx1bWEgKHZlYzMgcmdiKSB7XG5cdHJldHVybiAocmdiLnIgKyByZ2IuZyArIHJnYi5iKS8zLjA7XG59XG5cbmNvbnN0IGZsb2F0IFQgPSAwLjA0O1xuY29uc3QgZmxvYXQgTSA9IDEuMDtcbmNvbnN0IGZsb2F0IEwgPSAwLjAwMjtcblxudm9pZCBtYWluKHZvaWQpIHtcblxuICB2ZWMyIHRleENvb3JkID0gdmVjMigoKHZQcm9qZWN0ZWRDb29yZHMueCAvIHZQcm9qZWN0ZWRDb29yZHMudykgKyAxLjAgKSAvIDIuMCxcbiAgICAgICAgICAgICAgICAoKHZQcm9qZWN0ZWRDb29yZHMueSAvIHZQcm9qZWN0ZWRDb29yZHMudykgKyAxLjAgKSAvIDIuMCApO1xuXG4gIGZsb2F0IGJvcmRlcldpZHRoID0gdVdpZHRoOyAvLyBpbiBweFxuICBmbG9hdCBzdGVwX3UgPSBib3JkZXJXaWR0aCAqIDEuMCAvIHVDYW52YXNXaWR0aDtcbiAgZmxvYXQgc3RlcF92ID0gYm9yZGVyV2lkdGggKiAxLjAgLyB1Q2FudmFzSGVpZ2h0O1xuICB2ZWM0IGNlbnRlclBpeGVsID0gdGV4dHVyZTJEKHVUZXh0dXJlRmlsbGVkLCB0ZXhDb29yZCk7XG5cbiAgdmVjNCByaWdodFBpeGVsICA9IHRleHR1cmUyRCh1VGV4dHVyZUZpbGxlZCwgdGV4Q29vcmQgKyB2ZWMyKHN0ZXBfdSwgMC4wKSk7XG4gIHZlYzQgYm90dG9tUGl4ZWwgPSB0ZXh0dXJlMkQodVRleHR1cmVGaWxsZWQsIHRleENvb3JkICsgdmVjMigwLjAsIHN0ZXBfdikpO1xuXG4gIC8vIG5vdyBtYW51YWxseSBjb21wdXRlIHRoZSBkZXJpdmF0aXZlc1xuICBmbG9hdCBfZEZkWCA9IGxlbmd0aChyaWdodFBpeGVsIC0gY2VudGVyUGl4ZWwpIC8gc3RlcF91O1xuICBmbG9hdCBfZEZkWSA9IGxlbmd0aChib3R0b21QaXhlbCAtIGNlbnRlclBpeGVsKSAvIHN0ZXBfdjtcblxuICAvLyBnbF9GcmFnQ29sb3IuciA9IF9kRmRYO1xuICAvLyBnbF9GcmFnQ29sb3IuZyA9IF9kRmRZO1xuICBnbF9GcmFnQ29sb3IuciA9IG1heChtYXgoY2VudGVyUGl4ZWwuciwgcmlnaHRQaXhlbC5yKSwgYm90dG9tUGl4ZWwucik7XG4gIGdsX0ZyYWdDb2xvci5nID0gbWF4KG1heChjZW50ZXJQaXhlbC5nLCByaWdodFBpeGVsLmcpLCBib3R0b21QaXhlbC5nKTtcbiAgZ2xfRnJhZ0NvbG9yLmIgPSBtYXgobWF4KGNlbnRlclBpeGVsLmIsIHJpZ2h0UGl4ZWwuYiksIGJvdHRvbVBpeGVsLmIpO1xuICBnbF9GcmFnQ29sb3IuYSA9IG1heChfZEZkWCwgX2RGZFkpO1xuXG4gIHJldHVybjtcbiAgZmxvYXQgaCA9IDEuL3VDYW52YXNIZWlnaHQ7XG4gIGZsb2F0IHcgPSAxLi91Q2FudmFzV2lkdGg7XG4gIHZlYzQgbls5XTtcbiAgblswXSA9IHRleHR1cmUyRCh1VGV4dHVyZUZpbGxlZCwgdlByb2plY3RlZFRleHRDb29yZHMgKyB2ZWMyKCAtdywgLWgpKTtcbiAgblsxXSA9IHRleHR1cmUyRCh1VGV4dHVyZUZpbGxlZCwgdlByb2plY3RlZFRleHRDb29yZHMgKyB2ZWMyKDAuMCwgLWgpKTtcbiAgblsyXSA9IHRleHR1cmUyRCh1VGV4dHVyZUZpbGxlZCwgdlByb2plY3RlZFRleHRDb29yZHMgKyB2ZWMyKCAgdywgLWgpKTtcbiAgblszXSA9IHRleHR1cmUyRCh1VGV4dHVyZUZpbGxlZCwgdlByb2plY3RlZFRleHRDb29yZHMgKyB2ZWMyKCAtdywgMC4wKSk7XG4gIG5bNF0gPSB0ZXh0dXJlMkQodVRleHR1cmVGaWxsZWQsIHZQcm9qZWN0ZWRUZXh0Q29vcmRzKTtcbiAgbls1XSA9IHRleHR1cmUyRCh1VGV4dHVyZUZpbGxlZCwgdGV4Q29vcmQgKyB2ZWMyKCAgdywgMC4wKSk7XG4gIG5bNl0gPSB0ZXh0dXJlMkQodVRleHR1cmVGaWxsZWQsIHRleENvb3JkICsgdmVjMiggLXcsIGgpKTtcbiAgbls3XSA9IHRleHR1cmUyRCh1VGV4dHVyZUZpbGxlZCwgdGV4Q29vcmQgKyB2ZWMyKDAuMCwgaCkpO1xuICBuWzhdID0gdGV4dHVyZTJEKHVUZXh0dXJlRmlsbGVkLCB0ZXhDb29yZCArIHZlYzIoICB3LCBoKSk7XG4gIHZlYzQgc29iZWxfaG9yaXpFZGdlID0gblsyXSArICgyLjAqbls1XSkgKyBuWzhdIC0gKG5bMF0gKyAoMi4wKm5bM10pICsgbls2XSk7XG4gIHZlYzQgc29iZWxfdmVydEVkZ2UgID0gblswXSArICgyLjAqblsxXSkgKyBuWzJdIC0gKG5bNl0gKyAoMi4wKm5bN10pICsgbls4XSk7XG4gIHZlYzMgc29iZWwgPSBzcXJ0KChzb2JlbF9ob3JpekVkZ2UucmdiICogc29iZWxfaG9yaXpFZGdlLnJnYikgKyAoc29iZWxfdmVydEVkZ2UucmdiICogc29iZWxfdmVydEVkZ2UucmdiKSk7XG4gIGdsX0ZyYWdDb2xvciA9IHZlYzQoIHNvYmVsLCBtYXgobWF4KHNvYmVsLnIsIHNvYmVsLmcpLCBzb2JlbC5iKSApO1xuXG5cbiAgcmV0dXJuO1xuXG4gIGdsX0ZyYWdDb2xvci5yID0gKHRleENvb3JkICsgdmVjMigwLjAsIHN0ZXBfdikpLnI7XG4gIGdsX0ZyYWdDb2xvci5nID0gKHRleENvb3JkICsgdmVjMihzdGVwX3UsIDAuMCkpLmc7XG4gIGdsX0ZyYWdDb2xvciA9IGNlbnRlclBpeGVsO1xuICBnbF9GcmFnQ29sb3IuciA9IHRleENvb3JkLng7XG4gIC8vIGdsX0ZyYWdDb2xvci5nID0gKHRleENvb3JkICsgdmVjMigwLjAsIHN0ZXBfdikpLng7XG4gIGdsX0ZyYWdDb2xvci5iID0gKHRleENvb3JkICsgdmVjMihzdGVwX3UsIDAuMCkpLng7XG4gIGdsX0ZyYWdDb2xvci5yZyA9ICh0ZXhDb29yZCArIHZlYzIoMC4wLCBzdGVwX3YpKTtcbiAgZ2xfRnJhZ0NvbG9yLmIgPSAwLjtcbiAgcmV0dXJuO1xuICB2ZWMyIHRleENvb3JkU2xvcGUgPSBmd2lkdGgodGV4Q29vcmQpO1xuICB2ZWM0IGNvbG9yMiA9IHRleHR1cmUyRCh1VGV4dHVyZUZpbGxlZCwgdlByb2plY3RlZFRleHRDb29yZHMpO1xuICAvLyBkZmR4IHRoYXQgdlByb2plY3RlZFRleHRDb29yZHNcbiAgZmxvYXQgbCA9IGx1bWEgKGNvbG9yMi5yZ2IpIDtcbiAgICBmbG9hdCBsdW1pbmFuY2UgPSBkb3QoY29sb3IyLnJnYix2ZWMzKDAuMjEyNiwgMC43MTUyLCAwLjA3MjIpKTtcblxuICBcdGZsb2F0IHEwID0gZndpZHRoIChsdW1pbmFuY2UpO1xuICAgIGlmKHEwID4gMC4wMSl7XG4gICAgICBxMCA9IDEuMDtcbiAgICB9XG5cdGZsb2F0IHExID0gYWJzIChkRmR4IChsKSk7IFxuXHRmbG9hdCBxMiA9IGFicyAoZEZkeSAobCkpO1xuXG4gIFx0dmVjNCBjdCA9IHZlYzQgKDEuMCwgMS4wLCAxLjAsIDAuMCk7XG5cdHZlYzQgYzAgPSBtaXggKGN0LCB2ZWM0ICgxLjAsIDAuMCwgMC4wLCAxLjApLCBcblx0XHRzbW9vdGhzdGVwIChUICogKDEuMCAtIE0pLCBUICogKDEuMCArIE0pLCBxMCkpO1xuXG5nbF9GcmFnQ29sb3IuciA9IGZ3aWR0aChjb2xvcjIucik7Ly9hYnMoZEZkeChjb2xvcjIuYikpOy8vdGV4Q29vcmQ7Ly9jb2xvcjIucmdiO1xuZ2xfRnJhZ0NvbG9yLmcgPSBmd2lkdGgoY29sb3IyLmcpO1xuZ2xfRnJhZ0NvbG9yLmIgPSBmd2lkdGgoY29sb3IyLmIpO1xuZ2xfRnJhZ0NvbG9yLmEgPSAxLjtcbi8vIGdsX0ZyYWdDb2xvci5hID0gcTA7XG4vLyBnbF9GcmFnQ29sb3IgPSBjb2xvcjI7XG4vL3JldHVybjtcblxuXG4gIC8vVGhlIGJhY2sgcG9zaXRpb24gaXMgdGhlIHdvcmxkIHNwYWNlIHBvc2l0aW9uIHN0b3JlZCBpbiB0aGUgdGV4dHVyZS5cbiAgdmVjNCBjb2xvciA9IHRleHR1cmUyRCh1VGV4dHVyZUZpbGxlZCwgdGV4Q29vcmQpO1xuICBmbG9hdCBsQ29sb3IgPSBsZW5ndGgoY29sb3IucmdiKTtcbiAgZmxvYXQgbWF4Q29sb3IgPSBsZW5ndGgoY29sb3IucmdiKTsvL21heChtYXgoY29sb3IuciwgY29sb3IuZyksIGNvbG9yLmIpO1xuICAvLyBpZihtYXhDb2xvciA+IDAuMSl7XG4gIC8vICAgbWF4Q29sb3IgPSAxLjA7XG4gIC8vIH1cblxuXG5cbiAgLy8gZ2xfRnJhZ0NvbG9yID0gY29sb3I7Ly92ZWM0KGNvbG9yLnIsIGNvbG9yLmcsIGNvbG9yLmIsIDEpO1xuICAvLyByZXR1cm47XG4gIC8vIGZsb2F0IHRtcHh4ICA9IGFicyhkRmR4KGxDb2xvcikpO1xuICAvLyBmbG9hdCB0bXB4eSAgPSBhYnMoZEZkeShsQ29sb3IpKTtcbiAgLy8gZmxvYXQgdG1weCA9IG1heCh0bXB4eCx0bXB4eSk7XG5cbiAgLy8gZmxvYXQgdG1weXggID0gYWJzKGRGZHgoY29sb3IueSkpO1xuICAvLyBmbG9hdCB0bXB5eSAgPSBhYnMoZEZkeShjb2xvci55KSk7XG4gIC8vIGZsb2F0IHRtcHkgPSBtYXgodG1weXgsdG1weXkpO1xuXG4gIC8vIGZsb2F0IHRtcHp4ICA9IGFicyhkRmR4KGNvbG9yLnopKTtcbiAgLy8gZmxvYXQgdG1wenkgID0gYWJzKGRGZHkoY29sb3IueikpO1xuICAvLyBmbG9hdCB0bXB6ID0gbWF4KHRtcHp4LHRtcHp5KTtcblxuICAvLyBmbG9hdCB0bXBtYXggPSBtYXgobWF4KHRtcHgsIHRtcHkpLCB0bXB6KTtcbiAgLy8gaWYodG1wbWF4ID4gMC4wMSl7XG4gIC8vICAgdG1wbWF4ID0gMS4wO1xuICAvLyB9XG4gIC8vIGdsX0ZyYWdDb2xvci5yID0gdG1weDsvL3Ntb290aHN0ZXAodG1weC01LiwgdG1weCs1LiwgbENvbG9yKTtcbiAgLy8gZ2xfRnJhZ0NvbG9yLmcgPSB0bXB4O1xuICAvLyBnbF9GcmFnQ29sb3IuYiA9IHRtcHg7XG5cbiAgLy8gdmVjNCBjb2xvcjIgPSB0ZXh0dXJlMkQodVRleHR1cmVGaWxsZWQsIHZlYzIodGV4Y1gsIHRleGNZKSk7XG5cbiAgLy8gZ2xfRnJhZ0NvbG9yLnIgPSBjb2xvci5yIC0gdGV4Y1g7XG4gIC8vIGdsX0ZyYWdDb2xvci5nID0gY29sb3IuZyAtIHRleGNZO1xuICAvLyBnbF9GcmFnQ29sb3IuYiA9IGNvbG9yLmIgLSBjb2xvcjIuYjtcbiAgLy8gZ2xfRnJhZ0NvbG9yLmEgPSAxLjtcblxuICAvLyBmbG9hdCB0aHJlc2hvbGQgPSAwLjc7XG4gIC8vIGZsb2F0IGFmd2lkdGggPSBsZW5ndGgodmVjMihkRmR4KG1heENvbG9yKSwgZEZkeShtYXhDb2xvcikpKTtcbiAgLy8gZ2xfRnJhZ0NvbG9yLmEgPSBhZndpZHRoO1xuICAvLyBmbG9hdCBvcGFjaXR5ID1cbiAgLy8gICBzbW9vdGhzdGVwKGFmd2lkdGggLSB0aHJlc2hvbGQsIGFmd2lkdGggKyB0aHJlc2hvbGQsIG1heENvbG9yKTtcblxuICAvLyBnbF9GcmFnQ29sb3IuYSA9IG1heENvbG9yO1xuXG4vLyBmbG9hdCBhYWYgPSBmd2lkdGgobWF4Q29sb3IpO1xuLy8gZmxvYXQgYWxwaGEgPSBzbW9vdGhzdGVwKC4wMSwgLjgsIGFhZik7XG4vLyBnbF9GcmFnQ29sb3IgPSB2ZWM0KGNvbG9yLnJnYiwgYWxwaGEpO1xuXG4gIC8vIGZsb2F0IGggPSAxLi91Q2FudmFzSGVpZ2h0O1xuICAvLyBmbG9hdCB3ID0gMS4vdUNhbnZhc1dpZHRoO1xuICAvLyB2ZWM0IG5bOV07XG4gIC8vIG5bMF0gPSB0ZXh0dXJlMkQodVRleHR1cmVGaWxsZWQsIHZQcm9qZWN0ZWRUZXh0Q29vcmRzICsgdmVjMiggLXcsIC1oKSk7XG4gIC8vIG5bMV0gPSB0ZXh0dXJlMkQodVRleHR1cmVGaWxsZWQsIHZQcm9qZWN0ZWRUZXh0Q29vcmRzICsgdmVjMigwLjAsIC1oKSk7XG4gIC8vIG5bMl0gPSB0ZXh0dXJlMkQodVRleHR1cmVGaWxsZWQsIHZQcm9qZWN0ZWRUZXh0Q29vcmRzICsgdmVjMiggIHcsIC1oKSk7XG4gIC8vIG5bM10gPSB0ZXh0dXJlMkQodVRleHR1cmVGaWxsZWQsIHZQcm9qZWN0ZWRUZXh0Q29vcmRzICsgdmVjMiggLXcsIDAuMCkpO1xuICAvLyBuWzRdID0gdGV4dHVyZTJEKHVUZXh0dXJlRmlsbGVkLCB2UHJvamVjdGVkVGV4dENvb3Jkcyk7XG4gIC8vIG5bNV0gPSB0ZXh0dXJlMkQodVRleHR1cmVGaWxsZWQsIHRleENvb3JkICsgdmVjMiggIHcsIDAuMCkpO1xuICAvLyBuWzZdID0gdGV4dHVyZTJEKHVUZXh0dXJlRmlsbGVkLCB0ZXhDb29yZCArIHZlYzIoIC13LCBoKSk7XG4gIC8vIG5bN10gPSB0ZXh0dXJlMkQodVRleHR1cmVGaWxsZWQsIHRleENvb3JkICsgdmVjMigwLjAsIGgpKTtcbiAgLy8gbls4XSA9IHRleHR1cmUyRCh1VGV4dHVyZUZpbGxlZCwgdGV4Q29vcmQgKyB2ZWMyKCAgdywgaCkpO1xuICAvLyB2ZWM0IHNvYmVsX2hvcml6RWRnZSA9IG5bMl0gKyAoMi4wKm5bNV0pICsgbls4XSAtIChuWzBdICsgKDIuMCpuWzNdKSArIG5bNl0pO1xuICAvLyB2ZWM0IHNvYmVsX3ZlcnRFZGdlICA9IG5bMF0gKyAoMi4wKm5bMV0pICsgblsyXSAtIChuWzZdICsgKDIuMCpuWzddKSArIG5bOF0pO1xuICAvLyB2ZWMzIHNvYmVsID0gc3FydCgoc29iZWxfaG9yaXpFZGdlLnJnYiAqIHNvYmVsX2hvcml6RWRnZS5yZ2IpICsgKHNvYmVsX3ZlcnRFZGdlLnJnYiAqIHNvYmVsX3ZlcnRFZGdlLnJnYikpO1xuICAvLyBnbF9GcmFnQ29sb3IgPSB2ZWM0KCBuWzFdLnJnYiwgMS4wICk7XG4gIC8vIGdsX0ZyYWdDb2xvci5yID0gMS4wO1xuXG4gIHJldHVybjtcbn1cbiAgIGA7XG4gIH1cblxuICBjb21wdXRlKCkge1xuICAgIGxldCBzaGFkZXJJbnRlcnBvbGF0aW9uID0gJyc7XG4gICAgLy8gc2hhZGVySW50ZXJwb2xhdGlvbi5pbmxpbmUoYXJncykgLy90cnVlL2ZhbHNlXG4gICAgLy8gc2hhZGVySW50ZXJwb2xhdGlvbi5mdW5jdGlvbnMoYXJncylcblxuICAgIHJldHVybiBgXG4vLyB1bmlmb3Jtc1xuJHt0aGlzLnVuaWZvcm1zKCl9XG5cbi8vIHZhcnlpbmcgKHNob3VsZCBmZXRjaCBpdCBmcm9tIHZlcnRleCBkaXJlY3RseSlcbnZhcnlpbmcgdmVjNCAgICAgIHZQb3M7XG52YXJ5aW5nIHZlYzQgICAgICB2UHJvamVjdGVkQ29vcmRzO1xudmFyeWluZyB2ZWMyICAgICAgdlByb2plY3RlZFRleHRDb29yZHM7XG52YXJ5aW5nIG1hdDQgICAgICB2UHJvamVjdGlvblZpZXdNYXRyaXg7XG5cbi8vIHRhaWxvcmVkIGZ1bmN0aW9uc1xuJHt0aGlzLmZ1bmN0aW9ucygpfVxuXG4vLyBtYWluIGxvb3BcbiR7dGhpcy5fbWFpbn1cbiAgICAgIGA7XG4gICAgfVxuXG59XG4iLCJcbi8qKlxuICogQG1vZHVsZSBzaGFkZXJzL2RhdGFcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2hhZGVyc1VuaWZvcm0ge1xuICBzdGF0aWMgdW5pZm9ybXMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICd1Q2FudmFzV2lkdGgnOiB7XG4gICAgICAgIHR5cGU6ICdmJyxcbiAgICAgICAgdmFsdWU6IDAuLFxuICAgICAgICB0eXBlR0xTTDogJ2Zsb2F0JyxcbiAgICAgIH0sXG4gICAgICAndUNhbnZhc0hlaWdodCc6IHtcbiAgICAgICAgdHlwZTogJ2YnLFxuICAgICAgICB2YWx1ZTogMC4sXG4gICAgICAgIHR5cGVHTFNMOiAnZmxvYXQnLFxuICAgICAgfSxcbiAgICAgICd1V2lkdGgnOiB7XG4gICAgICAgIHR5cGU6ICdmJyxcbiAgICAgICAgdmFsdWU6IDEuLFxuICAgICAgICB0eXBlR0xTTDogJ2Zsb2F0JyxcbiAgICAgIH0sXG4gICAgICAndVRleHR1cmVGaWxsZWQnOiB7XG4gICAgICAgIHR5cGU6ICd0JyxcbiAgICAgICAgdmFsdWU6IFtdLFxuICAgICAgICB0eXBlR0xTTDogJ3NhbXBsZXIyRCcsXG4gICAgICB9LFxuICAgIH07XG4gIH1cbn1cbiIsImV4cG9ydCBkZWZhdWx0IGNsYXNzIFNoYWRlcnNWZXJ0ZXgge1xuXG4gICAgY29uc3RydWN0b3IoKSB7XG5cbiAgICB9XG5cbiAgICBjb21wdXRlKCkge1xuICAgICAgICByZXR1cm4gYFxudmFyeWluZyB2ZWM0IHZQb3M7XG52YXJ5aW5nIHZlYzQgdlByb2plY3RlZENvb3JkcztcbnZhcnlpbmcgbWF0NCB2UHJvamVjdGlvblZpZXdNYXRyaXg7XG52YXJ5aW5nIHZlYzIgdlByb2plY3RlZFRleHRDb29yZHM7XG5cbi8vXG4vLyBtYWluXG4vL1xudm9pZCBtYWluKCkge1xuXG4gIHZQb3MgPSBtb2RlbE1hdHJpeCAqIHZlYzQocG9zaXRpb24sIDEuMCApO1xuICB2UHJvamVjdGlvblZpZXdNYXRyaXggPSBwcm9qZWN0aW9uTWF0cml4ICogdmlld01hdHJpeDtcbiAgdlByb2plY3RlZENvb3JkcyA9ICBwcm9qZWN0aW9uTWF0cml4ICogbW9kZWxWaWV3TWF0cml4ICogdmVjNCggcG9zaXRpb24sIDEuMCApO1xuICB2UHJvamVjdGVkVGV4dENvb3JkcyA9IHZlYzIoKCh2UHJvamVjdGVkQ29vcmRzLnggLyB2UHJvamVjdGVkQ29vcmRzLncpICsgMS4wICkgLyAyLjAsXG4gICAgICAgICAgICAgICAgKCh2UHJvamVjdGVkQ29vcmRzLnkgLyB2UHJvamVjdGVkQ29vcmRzLncpICsgMS4wICkgLyAyLjAgKTtcbiAgZ2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbW9kZWxWaWV3TWF0cml4ICogdmVjNChwb3NpdGlvbiwgMS4wICk7XG5cbn1cbiAgICAgICAgYDtcbiAgICB9XG5cbn1cbiIsImltcG9ydCBzaGFkZXJzSW50ZXJwb2xhdGlvbiBmcm9tICcuL2ludGVycG9sYXRpb24vc2hhZGVycy5pbnRlcnBvbGF0aW9uJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2hhZGVyc0ZyYWdtZW50IHtcblxuICAvLyBwYXNzIHVuaWZvcm1zIG9iamVjdFxuICBjb25zdHJ1Y3Rvcih1bmlmb3Jtcykge1xuICAgIHRoaXMuX3VuaWZvcm1zID0gdW5pZm9ybXM7XG4gICAgdGhpcy5fZnVuY3Rpb25zID0ge307XG4gICAgdGhpcy5fbWFpbiA9ICcnO1xuICB9XG5cbiAgZnVuY3Rpb25zKCkge1xuICAgIGlmICh0aGlzLl9tYWluID09PSAnJykge1xuICAgICAgLy8gaWYgbWFpbiBpcyBlbXB0eSwgZnVuY3Rpb25zIGNhbiBub3QgaGF2ZSBiZWVuIGNvbXB1dGVkXG4gICAgICB0aGlzLm1haW4oKTtcbiAgICB9XG5cbiAgICBsZXQgY29udGVudCA9ICcnO1xuICAgIGZvciAobGV0IHByb3BlcnR5IGluIHRoaXMuX2Z1bmN0aW9ucykge1xuICAgICAgY29udGVudCArPSB0aGlzLl9mdW5jdGlvbnNbcHJvcGVydHldICsgJ1xcbic7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbnRlbnQ7XG4gIH1cblxuICB1bmlmb3JtcygpIHtcbiAgICBsZXQgY29udGVudCA9ICcnO1xuICAgIGZvciAobGV0IHByb3BlcnR5IGluIHRoaXMuX3VuaWZvcm1zKSB7XG4gICAgICBsZXQgdW5pZm9ybSA9IHRoaXMuX3VuaWZvcm1zW3Byb3BlcnR5XTtcbiAgICAgIGNvbnRlbnQgKz0gYHVuaWZvcm0gJHt1bmlmb3JtLnR5cGVHTFNMfSAke3Byb3BlcnR5fWA7XG5cbiAgICAgIGlmICh1bmlmb3JtICYmIHVuaWZvcm0ubGVuZ3RoKSB7XG4gICAgICAgIGNvbnRlbnQgKz0gYFske3VuaWZvcm0ubGVuZ3RofV1gO1xuICAgICAgfVxuXG4gICAgICBjb250ZW50ICs9ICc7XFxuJztcbiAgICB9XG5cbiAgICByZXR1cm4gY29udGVudDtcbiAgfVxuXG4gIG1haW4oKSB7XG4gICAgLy8gbmVlZCB0byBwcmUtY2FsbCBtYWluIHRvIGZpbGwgdXAgdGhlIGZ1bmN0aW9ucyBsaXN0XG4gICAgdGhpcy5fbWFpbiA9IGBcbnZvaWQgbWFpbih2b2lkKSB7XG5cbiAgLy8gZHJhdyBib3JkZXIgaWYgc2xpY2UgaXMgY3JvcHBlZFxuICAvLyBmbG9hdCB1Qm9yZGVyRGFzaExlbmd0aCA9IDEwLjtcblxuICBpZiggdUNhbnZhc1dpZHRoID4gMC4gJiZcbiAgICAgICgoZ2xfRnJhZ0Nvb3JkLnggPiB1Qm9yZGVyTWFyZ2luICYmIChnbF9GcmFnQ29vcmQueCAtIHVCb3JkZXJNYXJnaW4pIDwgdUJvcmRlcldpZHRoKSB8fFxuICAgICAgIChnbF9GcmFnQ29vcmQueCA8ICh1Q2FudmFzV2lkdGggLSB1Qm9yZGVyTWFyZ2luKSAmJiAoZ2xfRnJhZ0Nvb3JkLnggKyB1Qm9yZGVyTWFyZ2luKSA+ICh1Q2FudmFzV2lkdGggLSB1Qm9yZGVyV2lkdGgpICkpKXtcbiAgICBmbG9hdCB2YWx1ZVkgPSBtb2QoZ2xfRnJhZ0Nvb3JkLnksIDIuICogdUJvcmRlckRhc2hMZW5ndGgpO1xuICAgIGlmKCB2YWx1ZVkgPCB1Qm9yZGVyRGFzaExlbmd0aCAmJiBnbF9GcmFnQ29vcmQueSA+IHVCb3JkZXJNYXJnaW4gJiYgZ2xfRnJhZ0Nvb3JkLnkgPCAodUNhbnZhc0hlaWdodCAtIHVCb3JkZXJNYXJnaW4pICl7XG4gICAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KHVCb3JkZXJDb2xvciwgMS4pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuXG4gIGlmKCB1Q2FudmFzSGVpZ2h0ID4gMC4gJiZcbiAgICAgICgoZ2xfRnJhZ0Nvb3JkLnkgPiB1Qm9yZGVyTWFyZ2luICYmIChnbF9GcmFnQ29vcmQueSAtIHVCb3JkZXJNYXJnaW4pIDwgdUJvcmRlcldpZHRoKSB8fFxuICAgICAgIChnbF9GcmFnQ29vcmQueSA8ICh1Q2FudmFzSGVpZ2h0IC0gdUJvcmRlck1hcmdpbikgJiYgKGdsX0ZyYWdDb29yZC55ICsgdUJvcmRlck1hcmdpbikgPiAodUNhbnZhc0hlaWdodCAtIHVCb3JkZXJXaWR0aCkgKSkpe1xuICAgIGZsb2F0IHZhbHVlWCA9IG1vZChnbF9GcmFnQ29vcmQueCwgMi4gKiB1Qm9yZGVyRGFzaExlbmd0aCk7XG4gICAgaWYoIHZhbHVlWCA8IHVCb3JkZXJEYXNoTGVuZ3RoICYmIGdsX0ZyYWdDb29yZC54ID4gdUJvcmRlck1hcmdpbiAmJiBnbF9GcmFnQ29vcmQueCA8ICh1Q2FudmFzV2lkdGggLSB1Qm9yZGVyTWFyZ2luKSApe1xuICAgICAgZ2xfRnJhZ0NvbG9yID0gdmVjNCh1Qm9yZGVyQ29sb3IsIDEuKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cblxuICAvLyBnZXQgdGV4dHVyZSBjb29yZGluYXRlcyBvZiBjdXJyZW50IHBpeGVsXG4gIHZlYzQgZGF0YUNvb3JkaW5hdGVzID0gdVdvcmxkVG9EYXRhICogdlBvcztcbiAgdmVjMyBjdXJyZW50Vm94ZWwgPSB2ZWMzKGRhdGFDb29yZGluYXRlcy54LCBkYXRhQ29vcmRpbmF0ZXMueSwgZGF0YUNvb3JkaW5hdGVzLnopO1xuICB2ZWM0IGRhdGFWYWx1ZSA9IHZlYzQoMC4sIDAuLCAwLiwgMC4pO1xuICB2ZWMzIGdyYWRpZW50ID0gdmVjMygwLiwgMC4sIDAuKTtcbiAgJHtzaGFkZXJzSW50ZXJwb2xhdGlvbih0aGlzLCAnY3VycmVudFZveGVsJywgJ2RhdGFWYWx1ZScsICdncmFkaWVudCcpfVxuXG4gIC8vIGhvdyBkbyB3ZSBkZWFsIHdpbCBtb3JlIHRoYW4gMSBjaGFubmVsP1xuICBpZih1TnVtYmVyT2ZDaGFubmVscyA9PSAxKXtcbiAgICBmbG9hdCBpbnRlbnNpdHkgPSBkYXRhVmFsdWUucjtcblxuICAgIC8vIHJlc2NhbGUvc2xvcGVcbiAgICBpbnRlbnNpdHkgPSBpbnRlbnNpdHkqdVJlc2NhbGVTbG9wZUludGVyY2VwdFswXSArIHVSZXNjYWxlU2xvcGVJbnRlcmNlcHRbMV07XG5cbiAgICBmbG9hdCB3aW5kb3dNaW4gPSB1V2luZG93Q2VudGVyV2lkdGhbMF0gLSB1V2luZG93Q2VudGVyV2lkdGhbMV0gKiAwLjU7XG4gICAgZmxvYXQgd2luZG93TWF4ID0gdVdpbmRvd0NlbnRlcldpZHRoWzBdICsgdVdpbmRvd0NlbnRlcldpZHRoWzFdICogMC41O1xuICAgIGludGVuc2l0eSA9ICggaW50ZW5zaXR5IC0gd2luZG93TWluICkgLyB1V2luZG93Q2VudGVyV2lkdGhbMV07XG5cbiAgICBkYXRhVmFsdWUuciA9IGRhdGFWYWx1ZS5nID0gZGF0YVZhbHVlLmIgPSBpbnRlbnNpdHk7XG4gICAgZGF0YVZhbHVlLmEgPSAxLjA7XG4gIH1cblxuICAvLyBBcHBseSBMVVQgdGFibGUuLi5cbiAgLy9cbiAgaWYodUx1dCA9PSAxKXtcbiAgICAvLyBzaG91bGQgb3BhY2l0eSBiZSBncmFiYmVkIHRoZXJlP1xuICAgIGRhdGFWYWx1ZSA9IHRleHR1cmUyRCggdVRleHR1cmVMVVQsIHZlYzIoIGRhdGFWYWx1ZS5yICwgMS4wKSApO1xuICB9XG5cbiAgaWYodUludmVydCA9PSAxKXtcbiAgICBkYXRhVmFsdWUgPSB2ZWM0KDEuKSAtIGRhdGFWYWx1ZTtcbiAgICAvLyBob3cgZG8gd2UgZGVhbCB3aXRoIHRoYXQgYW5kIG9wYWNpdHk/XG4gICAgZGF0YVZhbHVlLmEgPSAxLjtcbiAgfVxuXG4gIGdsX0ZyYWdDb2xvciA9IGRhdGFWYWx1ZTtcblxuICAgIC8vIGlmIG9uIGVkZ2UsIGRyYXcgbGluZVxuICAvLyBmbG9hdCB4UG9zID0gZ2xfRnJhZ0Nvb3JkLngvNTEyLjtcbiAgLy8gZmxvYXQgeVBvcyA9IGdsX0ZyYWdDb29yZC55LzUxMi47XG4gIC8vIGlmKCB4UG9zIDwgMC4wNSB8fCB4UG9zID4gLjk1IHx8IHlQb3MgPCAwLjA1IHx8IHlQb3MgPiAuOTUpe1xuICAvLyAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoeFBvcywgeVBvcywgMC4sIDEuKTsvL2RhdGFWYWx1ZTtcbiAgLy8gICAvL3JldHVybjtcbiAgLy8gfVxuXG59XG4gICBgO1xuICB9XG5cbiAgY29tcHV0ZSgpIHtcbiAgICBsZXQgc2hhZGVySW50ZXJwb2xhdGlvbiA9ICcnO1xuICAgIC8vIHNoYWRlckludGVycG9sYXRpb24uaW5saW5lKGFyZ3MpIC8vdHJ1ZS9mYWxzZVxuICAgIC8vIHNoYWRlckludGVycG9sYXRpb24uZnVuY3Rpb25zKGFyZ3MpXG5cbiAgICByZXR1cm4gYFxuLy8gdW5pZm9ybXNcbiR7dGhpcy51bmlmb3JtcygpfVxuXG4vLyB2YXJ5aW5nIChzaG91bGQgZmV0Y2ggaXQgZnJvbSB2ZXJ0ZXggZGlyZWN0bHkpXG52YXJ5aW5nIHZlYzQgICAgICB2UG9zO1xuXG4vLyB0YWlsb3JlZCBmdW5jdGlvbnNcbiR7dGhpcy5mdW5jdGlvbnMoKX1cblxuLy8gbWFpbiBsb29wXG4ke3RoaXMuX21haW59XG4gICAgICBgO1xuICAgIH1cblxufVxuIiwiXG4vKipcbiAqIEBtb2R1bGUgc2hhZGVycy9kYXRhXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNoYWRlcnNVbmlmb3JtIHtcbiAgLyoqXG4gICAqIFNoYWRlcnMgZGF0YSB1bmlmb3Jtc1xuICAgKi9cbiAgc3RhdGljIHVuaWZvcm1zKCkge1xuICAgIHJldHVybiB7XG4gICAgICAndVRleHR1cmVTaXplJzoge1xuICAgICAgICB0eXBlOiAnaScsXG4gICAgICAgIHZhbHVlOiAwLFxuICAgICAgICB0eXBlR0xTTDogJ2ludCcsXG4gICAgICB9LFxuICAgICAgJ3VUZXh0dXJlQ29udGFpbmVyJzoge1xuICAgICAgICB0eXBlOiAndHYnLFxuICAgICAgICB2YWx1ZTogW10sXG4gICAgICAgIHR5cGVHTFNMOiAnc2FtcGxlcjJEJyxcbiAgICAgICAgbGVuZ3RoOiA3LFxuICAgICAgfSxcbiAgICAgICd1RGF0YURpbWVuc2lvbnMnOiB7XG4gICAgICAgIHR5cGU6ICdpdicsXG4gICAgICAgIHZhbHVlOiBbMCwgMCwgMF0sXG4gICAgICAgIHR5cGVHTFNMOiAnaXZlYzMnLFxuICAgICAgfSxcbiAgICAgICd1V29ybGRUb0RhdGEnOiB7XG4gICAgICAgIHR5cGU6ICdtNCcsXG4gICAgICAgIHZhbHVlOiBuZXcgVEhSRUUuTWF0cml4NCgpLFxuICAgICAgICB0eXBlR0xTTDogJ21hdDQnLFxuICAgICAgfSxcbiAgICAgICd1V2luZG93Q2VudGVyV2lkdGgnOiB7XG4gICAgICAgIHR5cGU6ICdmdjEnLFxuICAgICAgICB2YWx1ZTogWzAuMCwgMC4wXSxcbiAgICAgICAgdHlwZUdMU0w6ICdmbG9hdCcsXG4gICAgICAgIGxlbmd0aDogMixcbiAgICAgIH0sXG4gICAgICAndVJlc2NhbGVTbG9wZUludGVyY2VwdCc6IHtcbiAgICAgICAgdHlwZTogJ2Z2MScsXG4gICAgICAgIHZhbHVlOiBbMC4wLCAwLjBdLFxuICAgICAgICB0eXBlR0xTTDogJ2Zsb2F0JyxcbiAgICAgICAgbGVuZ3RoOiAyLFxuICAgICAgfSxcbiAgICAgICd1TnVtYmVyT2ZDaGFubmVscyc6IHtcbiAgICAgICAgdHlwZTogJ2knLFxuICAgICAgICB2YWx1ZTogMSxcbiAgICAgICAgdHlwZUdMU0w6ICdpbnQnLFxuICAgICAgfSxcbiAgICAgICd1Qml0c0FsbG9jYXRlZCc6IHtcbiAgICAgICAgdHlwZTogJ2knLFxuICAgICAgICB2YWx1ZTogOCxcbiAgICAgICAgdHlwZUdMU0w6ICdpbnQnLFxuICAgICAgfSxcbiAgICAgICd1SW52ZXJ0Jzoge1xuICAgICAgICB0eXBlOiAnaScsXG4gICAgICAgIHZhbHVlOiAwLFxuICAgICAgICB0eXBlR0xTTDogJ2ludCcsXG4gICAgICB9LFxuICAgICAgJ3VMdXQnOiB7XG4gICAgICAgIHR5cGU6ICdpJyxcbiAgICAgICAgdmFsdWU6IDAsXG4gICAgICAgIHR5cGVHTFNMOiAnaW50JyxcbiAgICAgIH0sXG4gICAgICAndVRleHR1cmVMVVQnOiB7XG4gICAgICAgIHR5cGU6ICd0JyxcbiAgICAgICAgdmFsdWU6IFtdLFxuICAgICAgICB0eXBlR0xTTDogJ3NhbXBsZXIyRCcsXG4gICAgICB9LFxuICAgICAgJ3VQaXhlbFR5cGUnOiB7XG4gICAgICAgIHR5cGU6ICdpJyxcbiAgICAgICAgdmFsdWU6IDAsXG4gICAgICAgIHR5cGVHTFNMOiAnaW50JyxcbiAgICAgIH0sXG4gICAgICAndVBhY2tlZFBlclBpeGVsJzoge1xuICAgICAgICB0eXBlOiAnaScsXG4gICAgICAgIHZhbHVlOiAxLFxuICAgICAgICB0eXBlR0xTTDogJ2ludCcsXG4gICAgICB9LFxuICAgICAgJ3VJbnRlcnBvbGF0aW9uJzoge1xuICAgICAgICB0eXBlOiAnaScsXG4gICAgICAgIHZhbHVlOiAxLFxuICAgICAgICB0eXBlR0xTTDogJ2ludCcsXG4gICAgICB9LFxuICAgICAgJ3VDYW52YXNXaWR0aCc6IHtcbiAgICAgICAgdHlwZTogJ2YnLFxuICAgICAgICB2YWx1ZTogMC4sXG4gICAgICAgIHR5cGVHTFNMOiAnZmxvYXQnLFxuICAgICAgfSxcbiAgICAgICd1Q2FudmFzSGVpZ2h0Jzoge1xuICAgICAgICB0eXBlOiAnZicsXG4gICAgICAgIHZhbHVlOiAwLixcbiAgICAgICAgdHlwZUdMU0w6ICdmbG9hdCcsXG4gICAgICB9LFxuICAgICAgJ3VCb3JkZXJDb2xvcic6IHtcbiAgICAgICAgdHlwZTogJ3YzJyxcbiAgICAgICAgdmFsdWU6IFsxLjAsIDAuMCwgMC41XSxcbiAgICAgICAgdHlwZUdMU0w6ICd2ZWMzJyxcbiAgICAgIH0sXG4gICAgICAndUJvcmRlcldpZHRoJzoge1xuICAgICAgICB0eXBlOiAnZicsXG4gICAgICAgIHZhbHVlOiAyLixcbiAgICAgICAgdHlwZUdMU0w6ICdmbG9hdCcsXG4gICAgICB9LFxuICAgICAgJ3VCb3JkZXJNYXJnaW4nOiB7XG4gICAgICAgIHR5cGU6ICdmJyxcbiAgICAgICAgdmFsdWU6IDIuLFxuICAgICAgICB0eXBlR0xTTDogJ2Zsb2F0JyxcbiAgICAgIH0sXG4gICAgICAndUJvcmRlckRhc2hMZW5ndGgnOiB7XG4gICAgICAgIHR5cGU6ICdmJyxcbiAgICAgICAgdmFsdWU6IDEwLixcbiAgICAgICAgdHlwZUdMU0w6ICdmbG9hdCcsXG4gICAgICB9LFxuICAgIH07XG4gIH1cbn1cbiIsImV4cG9ydCBkZWZhdWx0IGNsYXNzIFNoYWRlcnNWZXJ0ZXgge1xuXG4gICAgY29uc3RydWN0b3IoKSB7XG5cbiAgICB9XG5cbiAgICBjb21wdXRlKCkge1xuICAgICAgICByZXR1cm4gYFxudmFyeWluZyB2ZWM0IHZQb3M7XG5cbi8vXG4vLyBtYWluXG4vL1xudm9pZCBtYWluKCkge1xuXG4gIHZQb3MgPSBtb2RlbE1hdHJpeCAqIHZlYzQocG9zaXRpb24sIDEuMCApO1xuICBnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KHBvc2l0aW9uLCAxLjAgKTtcblxufVxuICAgICAgICBgO1xuICAgIH1cblxufVxuIiwiaW1wb3J0IENvbnRvdXJVbmlmb3JtIGZyb20gJy4vc2hhZGVycy5jb250b3VyLnVuaWZvcm0nO1xuaW1wb3J0IENvbnRvdXJGcmFnbWVudCBmcm9tICcuL3NoYWRlcnMuY29udG91ci5mcmFnbWVudCc7XG5pbXBvcnQgQ29udG91clZlcnRleCBmcm9tICcuL3NoYWRlcnMuY29udG91ci52ZXJ0ZXgnO1xuXG5pbXBvcnQgRGF0YVVuaWZvcm0gZnJvbSAnLi9zaGFkZXJzLmRhdGEudW5pZm9ybSc7XG5pbXBvcnQgRGF0YUZyYWdtZW50IGZyb20gJy4vc2hhZGVycy5kYXRhLmZyYWdtZW50JztcbmltcG9ydCBEYXRhVmVydGV4IGZyb20gJy4vc2hhZGVycy5kYXRhLnZlcnRleCc7XG5cbmltcG9ydCBWUlVuaWZvcm0gZnJvbSAnLi9zaGFkZXJzLnZyLnVuaWZvcm0nO1xuaW1wb3J0IFZSRnJhZ21lbnQgZnJvbSAnLi9zaGFkZXJzLnZyLmZyYWdtZW50JztcbmltcG9ydCBWUlZlcnRleCBmcm9tICcuL3NoYWRlcnMudnIudmVydGV4JztcblxuaW1wb3J0IExheWVyVW5pZm9ybSBmcm9tICcuL3NoYWRlcnMubGF5ZXIudW5pZm9ybSc7XG5pbXBvcnQgTGF5ZXJGcmFnbWVudCBmcm9tICcuL3NoYWRlcnMubGF5ZXIuZnJhZ21lbnQnO1xuaW1wb3J0IExheWVyVmVydGV4IGZyb20gJy4vc2hhZGVycy5sYXllci52ZXJ0ZXgnO1xuXG5pbXBvcnQgTG9jYWxpemVyVW5pZm9ybSBmcm9tICcuL3NoYWRlcnMubG9jYWxpemVyLnVuaWZvcm0nO1xuaW1wb3J0IExvY2FsaXplckZyYWdtZW50IGZyb20gJy4vc2hhZGVycy5sb2NhbGl6ZXIuZnJhZ21lbnQnO1xuaW1wb3J0IExvY2FsaXplclZlcnRleCBmcm9tICcuL3NoYWRlcnMubG9jYWxpemVyLnZlcnRleCc7XG5cbi8qKlxuICogQG1vZHVsZSBzaGFkZXJzXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQge1xuICBDb250b3VyVW5pZm9ybSxcbiAgQ29udG91ckZyYWdtZW50LFxuICBDb250b3VyVmVydGV4LFxuXG4gIERhdGFVbmlmb3JtLFxuICBEYXRhRnJhZ21lbnQsXG4gIERhdGFWZXJ0ZXgsXG5cbiAgVlJVbmlmb3JtLFxuICBWUkZyYWdtZW50LFxuICBWUlZlcnRleCxcblxuICBMYXllclVuaWZvcm0sXG4gIExheWVyRnJhZ21lbnQsXG4gIExheWVyVmVydGV4LFxuXG4gIExvY2FsaXplclVuaWZvcm0sXG4gIExvY2FsaXplckZyYWdtZW50LFxuICBMb2NhbGl6ZXJWZXJ0ZXgsXG59O1xuIiwiZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2hhZGVyc0ZyYWdtZW50IHtcblxuICAvLyBwYXNzIHVuaWZvcm1zIG9iamVjdFxuICBjb25zdHJ1Y3Rvcih1bmlmb3Jtcykge1xuICAgIHRoaXMuX3VuaWZvcm1zID0gdW5pZm9ybXM7XG4gICAgdGhpcy5fZnVuY3Rpb25zID0ge307XG4gICAgdGhpcy5fbWFpbiA9ICcnO1xuICB9XG5cbiAgZnVuY3Rpb25zKCkge1xuICAgIGlmKHRoaXMuX21haW4gPT09ICcnKSB7XG4gICAgICAvLyBpZiBtYWluIGlzIGVtcHR5LCBmdW5jdGlvbnMgY2FuIG5vdCBoYXZlIGJlZW4gY29tcHV0ZWRcbiAgICAgIHRoaXMubWFpbigpO1xuICAgIH1cblxuICAgIGxldCBjb250ZW50ID0gJyc7XG4gICAgZm9yIChsZXQgcHJvcGVydHkgaW4gdGhpcy5fZnVuY3Rpb25zKSB7XG4gICAgICBjb250ZW50ICs9IHRoaXMuX2Z1bmN0aW9uc1twcm9wZXJ0eV0gKyAnXFxuJztcbiAgICB9XG5cbiAgICByZXR1cm4gY29udGVudDtcbiAgfVxuXG4gIHVuaWZvcm1zKCkge1xuICAgIGxldCBjb250ZW50ID0gJyc7XG4gICAgZm9yIChsZXQgcHJvcGVydHkgaW4gdGhpcy5fdW5pZm9ybXMpIHtcbiAgICAgIGxldCB1bmlmb3JtID0gdGhpcy5fdW5pZm9ybXNbcHJvcGVydHldO1xuICAgICAgY29udGVudCArPSBgdW5pZm9ybSAke3VuaWZvcm0udHlwZUdMU0x9ICR7cHJvcGVydHl9YDtcblxuICAgICAgaWYodW5pZm9ybSAmJiB1bmlmb3JtLmxlbmd0aCkge1xuICAgICAgICBjb250ZW50ICs9IGBbJHt1bmlmb3JtLmxlbmd0aH1dYDtcbiAgICAgIH1cblxuICAgICAgY29udGVudCArPSAnO1xcbic7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbnRlbnQ7XG4gIH1cblxuICBtYWluKCkge1xuICAgIC8vIG5lZWQgdG8gcHJlLWNhbGwgbWFpbiB0byBmaWxsIHVwIHRoZSBmdW5jdGlvbnMgbGlzdFxuICAgIHRoaXMuX21haW4gPSBgXG52b2lkIG1haW4odm9pZCkge1xuXG4gIHZlYzIgdGV4YyA9IHZlYzIoKCh2UHJvamVjdGVkQ29vcmRzLnggLyB2UHJvamVjdGVkQ29vcmRzLncpICsgMS4wICkgLyAyLjAsXG4gICAgICAgICAgICAgICAgKCh2UHJvamVjdGVkQ29vcmRzLnkgLyB2UHJvamVjdGVkQ29vcmRzLncpICsgMS4wICkgLyAyLjAgKTtcblxuICAvLyBqdXN0IHNpbGVuY2Ugd2FybmluZyBmb3JcbiAgdmVjNCBkdW1teSA9IHZQb3M7XG5cbiAgLy9UaGUgYmFjayBwb3NpdGlvbiBpcyB0aGUgd29ybGQgc3BhY2UgcG9zaXRpb24gc3RvcmVkIGluIHRoZSB0ZXh0dXJlLlxuICB2ZWM0IGJhc2VDb2xvcjAgPSB0ZXh0dXJlMkQodVRleHR1cmVCYWNrVGVzdDAsIHRleGMpO1xuICB2ZWM0IGJhc2VDb2xvcjEgPSB0ZXh0dXJlMkQodVRleHR1cmVCYWNrVGVzdDEsIHRleGMpO1xuXG4gIGlmKCB1VHJhY2tNb3VzZSA9PSAxICl7XG5cbiAgICAgIGlmKCB2UHJvamVjdGVkQ29vcmRzLnggPCB1TW91c2UueCApe1xuXG4gICAgICAgIGdsX0ZyYWdDb2xvciA9IGJhc2VDb2xvcjA7XG5cbiAgICAgIH1cbiAgICAgIGVsc2V7XG5cbiAgICAgICAgZ2xfRnJhZ0NvbG9yID0gbWl4KCBiYXNlQ29sb3IwLCBiYXNlQ29sb3IxLCB1T3BhY2l0eTEgKTtcblxuICAgICAgfVxuXG4gIH1cbiAgZWxzZXtcblxuICAgIGlmKCB1VHlwZTEgPT0gMCApe1xuXG4gICAgICAvL21lcmdlIGFuIGltYWdlIGludG9cbiAgICAgIGdsX0ZyYWdDb2xvciA9IG1peCggYmFzZUNvbG9yMCwgYmFzZUNvbG9yMSwgdU9wYWNpdHkxICk7XG5cbiAgICB9XG4gICAgZWxzZXtcblxuICAgICAgZmxvYXQgb3BhY2l0eSA9IGJhc2VDb2xvcjEuYTtcbiAgICAgIGdsX0ZyYWdDb2xvciA9IG1peCggYmFzZUNvbG9yMCwgYmFzZUNvbG9yMSwgb3BhY2l0eSAqIHVPcGFjaXR5MSApO1xuXG4gICAgfVxuXG4gIH1cblxuICByZXR1cm47XG59XG4gICBgO1xuICB9XG5cbiAgY29tcHV0ZSgpIHtcbiAgICBsZXQgc2hhZGVySW50ZXJwb2xhdGlvbiA9ICcnO1xuICAgIC8vIHNoYWRlckludGVycG9sYXRpb24uaW5saW5lKGFyZ3MpIC8vdHJ1ZS9mYWxzZVxuICAgIC8vIHNoYWRlckludGVycG9sYXRpb24uZnVuY3Rpb25zKGFyZ3MpXG5cbiAgICByZXR1cm4gYFxuLy8gdW5pZm9ybXNcbiR7dGhpcy51bmlmb3JtcygpfVxuXG4vLyB2YXJ5aW5nIChzaG91bGQgZmV0Y2ggaXQgZnJvbSB2ZXJ0ZXggZGlyZWN0bHkpXG52YXJ5aW5nIHZlYzQgICAgICB2UG9zO1xudmFyeWluZyB2ZWM0ICAgICAgdlByb2plY3RlZENvb3JkcztcblxuLy8gdGFpbG9yZWQgZnVuY3Rpb25zXG4ke3RoaXMuZnVuY3Rpb25zKCl9XG5cbi8vIG1haW4gbG9vcFxuJHt0aGlzLl9tYWlufVxuICAgICAgYDtcbiAgICB9XG5cbn1cbiIsIlxuLyoqXG4gKiBAbW9kdWxlIHNoYWRlcnMvZGF0YVxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTaGFkZXJzVW5pZm9ybSB7XG4gIHN0YXRpYyB1bmlmb3JtcygpIHtcbiAgICByZXR1cm4ge1xuICAgICd1VGV4dHVyZUJhY2tUZXN0MCc6IHtcbiAgICAgICAgdHlwZTogJ3QnLFxuICAgICAgICB2YWx1ZTogW10sXG4gICAgICAgIHR5cGVHTFNMOiAnc2FtcGxlcjJEJyxcbiAgICAgIH0sXG4gICAgICAndVRleHR1cmVCYWNrVGVzdDEnOiB7XG4gICAgICAgIHR5cGU6ICd0JyxcbiAgICAgICAgdmFsdWU6IFtdLFxuICAgICAgICB0eXBlR0xTTDogJ3NhbXBsZXIyRCcsXG4gICAgICB9LFxuICAgICAgJ3VPcGFjaXR5MCc6IHtcbiAgICAgICAgdHlwZTogJ2YnLFxuICAgICAgICB2YWx1ZTogMS4wLFxuICAgICAgICB0eXBlR0xTTDogJ2Zsb2F0JyxcbiAgICAgIH0sXG4gICAgICAndU9wYWNpdHkxJzoge1xuICAgICAgICB0eXBlOiAnZicsXG4gICAgICAgIHZhbHVlOiAxLjAsXG4gICAgICAgIHR5cGVHTFNMOiAnZmxvYXQnLFxuICAgICAgfSxcbiAgICAgICd1VHlwZTAnOiB7XG4gICAgICAgIHR5cGU6ICdpJyxcbiAgICAgICAgdmFsdWU6IDAsXG4gICAgICAgIHR5cGVHTFNMOiAnaW50JyxcbiAgICAgIH0sXG4gICAgICAndVR5cGUxJzoge1xuICAgICAgICB0eXBlOiAnaScsXG4gICAgICAgIHZhbHVlOiAxLFxuICAgICAgICB0eXBlR0xTTDogJ2ludCcsXG4gICAgICB9LFxuICAgICAgJ3VUcmFja01vdXNlJzoge1xuICAgICAgICB0eXBlOiAnaScsXG4gICAgICAgIHZhbHVlOiAwLFxuICAgICAgICB0eXBlR0xTTDogJ2ludCcsXG4gICAgICB9LFxuICAgICAgJ3VNb3VzZSc6IHtcbiAgICAgICAgdHlwZTogJ3YyJyxcbiAgICAgICAgdmFsdWU6IG5ldyBUSFJFRS5WZWN0b3IyKCksXG4gICAgICAgIHR5cGVHTFNMOiAndmVjMicsXG4gICAgICB9LFxuICAgIH07XG4gIH1cbn1cbiIsImV4cG9ydCBkZWZhdWx0IGNsYXNzIFNoYWRlcnNWZXJ0ZXgge1xuXG4gICAgY29uc3RydWN0b3IoKSB7XG5cbiAgICB9XG5cbiAgICBjb21wdXRlKCkge1xuICAgICAgICByZXR1cm4gYFxudmFyeWluZyB2ZWM0IHZQb3M7XG52YXJ5aW5nIHZlYzQgdlByb2plY3RlZENvb3JkcztcblxuLy9cbi8vIG1haW5cbi8vXG52b2lkIG1haW4oKSB7XG5cbiAgdlBvcyA9IG1vZGVsTWF0cml4ICogdmVjNChwb3NpdGlvbiwgMS4wICk7XG4gIHZQcm9qZWN0ZWRDb29yZHMgPSAgcHJvamVjdGlvbk1hdHJpeCAqIG1vZGVsVmlld01hdHJpeCAqIHZlYzQoIHBvc2l0aW9uLCAxLjAgKTtcbiAgZ2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbW9kZWxWaWV3TWF0cml4ICogdmVjNChwb3NpdGlvbiwgMS4wICk7XG5cbn1cbiAgICAgICAgYDtcbiAgICB9XG5cbn1cbiIsImltcG9ydCBzaGFkZXJzSW50ZXJwb2xhdGlvbiBmcm9tICcuL2ludGVycG9sYXRpb24vc2hhZGVycy5pbnRlcnBvbGF0aW9uJztcblxuLyoqXG4gKiBMb2NhbGl6ZXIgZnJhZ21lbnQgc2hhZGVyXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIHtcblxuICAvKipcbiAgICogXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih1bmlmb3Jtcykge1xuICAgIHRoaXMuX3VuaWZvcm1zID0gdW5pZm9ybXM7XG4gICAgdGhpcy5fZnVuY3Rpb25zID0ge307XG4gICAgdGhpcy5fbWFpbiA9ICcnO1xuICB9XG5cbiAgLyoqXG4gICAqIFxuICAgKi9cbiAgZnVuY3Rpb25zKCkge1xuICAgIGlmKHRoaXMuX21haW4gPT09ICcnKSB7XG4gICAgICAvLyBpZiBtYWluIGlzIGVtcHR5LCBmdW5jdGlvbnMgY2FuIG5vdCBoYXZlIGJlZW4gY29tcHV0ZWRcbiAgICAgIHRoaXMubWFpbigpO1xuICAgIH1cblxuICAgIGxldCBjb250ZW50ID0gJyc7XG4gICAgZm9yKGxldCBwcm9wZXJ0eSBpbiB0aGlzLl9mdW5jdGlvbnMpIHtcbiAgICAgIGNvbnRlbnQgKz0gdGhpcy5fZnVuY3Rpb25zW3Byb3BlcnR5XSArICdcXG4nO1xuICAgIH1cblxuICAgIHJldHVybiBjb250ZW50O1xuICB9XG5cbiAgLyoqXG4gICAqIFxuICAgKi9cbiAgdW5pZm9ybXMoKSB7XG4gICAgbGV0IGNvbnRlbnQgPSAnJztcbiAgICBmb3IgKGxldCBwcm9wZXJ0eSBpbiB0aGlzLl91bmlmb3Jtcykge1xuICAgICAgbGV0IHVuaWZvcm0gPSB0aGlzLl91bmlmb3Jtc1twcm9wZXJ0eV07XG4gICAgICBjb250ZW50ICs9IGB1bmlmb3JtICR7dW5pZm9ybS50eXBlR0xTTH0gJHtwcm9wZXJ0eX1gO1xuXG4gICAgICBpZih1bmlmb3JtICYmIHVuaWZvcm0ubGVuZ3RoKSB7XG4gICAgICAgIGNvbnRlbnQgKz0gYFske3VuaWZvcm0ubGVuZ3RofV1gO1xuICAgICAgfVxuXG4gICAgICBjb250ZW50ICs9ICc7XFxuJztcbiAgICB9XG5cbiAgICByZXR1cm4gY29udGVudDtcbiAgfVxuXG4gIC8qKlxuICAgKiBcbiAgICovXG4gIG1haW4oKSB7XG4gICAgLy8gbmVlZCB0byBwcmUtY2FsbCBtYWluIHRvIGZpbGwgdXAgdGhlIGZ1bmN0aW9ucyBsaXN0XG4gICAgdGhpcy5fbWFpbiA9IGBcbnZvaWQgaW50ZXJzZWN0aW9uUHJvamVjdGlvbihcbiAgaW4gdmVjNCBwbGFuZSxcbiAgaW4gdmVjNCBzbGljZSxcbiAgb3V0IHZlYzMgaW50ZXJzZWN0aW9uUHJvamVjdGlvbil7XG5cbiAgICAgIHZlYzMgaW50ZXJzZWN0aW9uRGlyZWN0aW9uID0gbm9ybWFsaXplKGNyb3NzKHBsYW5lLnh5eiwgc2xpY2UueHl6KSk7XG4gICAgICB2ZWMzIGludGVyc2VjdGlvblBvaW50ID0gXG4gICAgICAgIGNyb3NzKGludGVyc2VjdGlvbkRpcmVjdGlvbixzbGljZS54eXopICogcGxhbmUudyArXG4gICAgICAgIGNyb3NzKHBsYW5lLnh5eiwgaW50ZXJzZWN0aW9uRGlyZWN0aW9uKSAqIHNsaWNlLnc7XG5cbiAgICAgIGludGVyc2VjdGlvblByb2plY3Rpb24gPVxuICAgICAgICBpbnRlcnNlY3Rpb25Qb2ludC54eXogK1xuICAgICAgICAoZG90KHZQb3MueHl6IC0gaW50ZXJzZWN0aW9uUG9pbnQsIGludGVyc2VjdGlvbkRpcmVjdGlvbilcbiAgICAgICAgICAqIGludGVyc2VjdGlvbkRpcmVjdGlvbik7XG5cbn1cblxudm9pZCBtYWluKHZvaWQpIHtcbiAgICAgIHZlYzQgYzEgPSB2ZWM0KDAuLCAwLiwgMC4sIDAuKTtcbiAgICAgIHZlYzQgYzIgPSB2ZWM0KDAuLCAwLiwgMC4sIDAuKTtcbiAgICAgIHZlYzQgYzMgPSB2ZWM0KDAuLCAwLiwgMC4sIDAuKTtcblxuICAgICAgLy8gbG9jYWxpemVyICMxXG4gICAgICAvLyBtdXN0IGJlIG5vcm1hbGl6ZWQhXG4gICAgICBpZihsZW5ndGgodVBsYW5lMS54eXopID4gMC41KSB7XG4gICAgICAgIHZlYzMgcHJvamVjdGlvbjEgPSB2ZWMzKDEuKTtcbiAgICAgICAgaW50ZXJzZWN0aW9uUHJvamVjdGlvbihcbiAgICAgICAgICB1UGxhbmUxLFxuICAgICAgICAgIHVTbGljZSxcbiAgICAgICAgICBwcm9qZWN0aW9uMVxuICAgICAgICApO1xuXG4gICAgICAgIHZlYzQgcHJvakludGVyMSA9ICh2UHJvamVjdGlvblZpZXdNYXRyaXggKiB2ZWM0KHByb2plY3Rpb24xLCAxLikpO1xuICAgICAgICB2ZWMzIG5kYzEgPSBwcm9qSW50ZXIxLnh5eiAvIHByb2pJbnRlcjEudztcbiAgICAgICAgdmVjMiBzY3JlZW5TcGFjZTEgPSAobmRjMS54eSAqIC41ICsgLjUpICogdmVjMih1Q2FudmFzV2lkdGgsIHVDYW52YXNIZWlnaHQpO1xuXG4gICAgICAgIGZsb2F0IGQxID0gZGlzdGFuY2UoZ2xfRnJhZ0Nvb3JkLnh5LCBzY3JlZW5TcGFjZTEueHkpO1xuICAgICAgICBjMSA9IHZlYzQodVBsYW5lQ29sb3IxLCAxLiAtIHNtb290aHN0ZXAoLjUsIC43LCBkMSkpO1xuICAgICAgfVxuXG4gICAgICAvLyBsb2NhbGl6ZXIgIzJcbiAgICAgIGlmKGxlbmd0aCh1UGxhbmUyLnh5eikgPiAwLjUpIHtcbiAgICAgICAgdmVjMyBwcm9qZWN0aW9uMiA9IHZlYzMoMS4pO1xuICAgICAgICBpbnRlcnNlY3Rpb25Qcm9qZWN0aW9uKFxuICAgICAgICAgIHVQbGFuZTIsXG4gICAgICAgICAgdVNsaWNlLFxuICAgICAgICAgIHByb2plY3Rpb24yXG4gICAgICAgICk7XG5cbiAgICAgICAgdmVjNCBwcm9qSW50ZXIyID0gKHZQcm9qZWN0aW9uVmlld01hdHJpeCAqIHZlYzQocHJvamVjdGlvbjIsIDEuKSk7XG4gICAgICAgIHZlYzMgbmRjMiA9IHByb2pJbnRlcjIueHl6IC8gcHJvakludGVyMi53O1xuICAgICAgICB2ZWMyIHNjcmVlblNwYWNlMiA9IChuZGMyLnh5ICogLjUgKyAuNSkgKiB2ZWMyKHVDYW52YXNXaWR0aCwgdUNhbnZhc0hlaWdodCk7XG5cbiAgICAgICAgZmxvYXQgZDIgPSBkaXN0YW5jZShnbF9GcmFnQ29vcmQueHksIHNjcmVlblNwYWNlMi54eSk7XG4gICAgICAgIGMyID0gdmVjNCh1UGxhbmVDb2xvcjIsIDEuIC0gc21vb3Roc3RlcCguNSwgLjcsIGQyKSk7XG4gICAgICB9XG5cbiAgICAgIC8vIGxvY2FsaXplciAjM1xuICAgICAgaWYobGVuZ3RoKHVQbGFuZTMueHl6KSA+IDAuNSkge1xuICAgICAgICB2ZWMzIHByb2plY3Rpb24zID0gdmVjMygxLik7XG4gICAgICAgIGludGVyc2VjdGlvblByb2plY3Rpb24oXG4gICAgICAgICAgdVBsYW5lMyxcbiAgICAgICAgICB1U2xpY2UsXG4gICAgICAgICAgcHJvamVjdGlvbjNcbiAgICAgICAgKTtcblxuICAgICAgICB2ZWM0IHByb2pJbnRlcjMgPSAodlByb2plY3Rpb25WaWV3TWF0cml4ICogdmVjNChwcm9qZWN0aW9uMywgMS4pKTtcbiAgICAgICAgdmVjMyBuZGMzID0gcHJvakludGVyMy54eXogLyBwcm9qSW50ZXIzLnc7XG4gICAgICAgIHZlYzIgc2NyZWVuU3BhY2UzID0gKG5kYzMueHkgKiAuNSArIC41KSAqIHZlYzIodUNhbnZhc1dpZHRoLCB1Q2FudmFzSGVpZ2h0KTtcblxuICAgICAgICBmbG9hdCBkMyA9IGRpc3RhbmNlKGdsX0ZyYWdDb29yZC54eSwgc2NyZWVuU3BhY2UzLnh5KTtcbiAgICAgICAgYzMgPSB2ZWM0KHVQbGFuZUNvbG9yMywgMS4gLSBzbW9vdGhzdGVwKC41LCAuNywgZDMpKTtcbiAgICAgIH1cblxuICAgICAgdmVjMyBjb2xvck1peCA9IGMxLnh5eipjMS53ICsgYzIueHl6KmMyLncgKyBjMy54eXoqYzMudztcbiAgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoY29sb3JNaXgsIG1heChtYXgoYzEudywgYzIudyksYzMudykpO1xufVxuICAgYDtcbiAgfVxuXG4gIC8qKlxuICAgKiBcbiAgICovXG4gIGNvbXB1dGUoKSB7XG4gICAgbGV0IHNoYWRlckludGVycG9sYXRpb24gPSAnJztcbiAgICAvLyBzaGFkZXJJbnRlcnBvbGF0aW9uLmlubGluZShhcmdzKSAvL3RydWUvZmFsc2VcbiAgICAvLyBzaGFkZXJJbnRlcnBvbGF0aW9uLmZ1bmN0aW9ucyhhcmdzKVxuXG4gICAgcmV0dXJuIGBcbi8vIHVuaWZvcm1zXG4ke3RoaXMudW5pZm9ybXMoKX1cblxuLy8gdmFyeWluZyAoc2hvdWxkIGZldGNoIGl0IGZyb20gdmVydGV4IGRpcmVjdGx5KVxudmFyeWluZyB2ZWM0IHZQb3M7XG52YXJ5aW5nIG1hdDQgdlByb2plY3Rpb25WaWV3TWF0cml4O1xuXG4vLyB0YWlsb3JlZCBmdW5jdGlvbnNcbiR7dGhpcy5mdW5jdGlvbnMoKX1cblxuLy8gbWFpbiBsb29wXG4ke3RoaXMuX21haW59XG4gICAgICBgO1xuICAgIH1cblxufVxuIiwiLyoqXG4gKiBAbW9kdWxlIHNoYWRlcnMvbG9jYWxpemVyL3VuaWZvcm1zXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3Mge1xuICAvKipcbiAgICogU2hhZGVycyBkYXRhIHVuaWZvcm1zXG4gICAqL1xuICBzdGF0aWMgdW5pZm9ybXMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICd1Q2FudmFzV2lkdGgnOiB7XG4gICAgICAgIHR5cGU6ICdmJyxcbiAgICAgICAgdmFsdWU6IDAuLFxuICAgICAgICB0eXBlR0xTTDogJ2Zsb2F0JyxcbiAgICAgIH0sXG4gICAgICAndUNhbnZhc0hlaWdodCc6IHtcbiAgICAgICAgdHlwZTogJ2YnLFxuICAgICAgICB2YWx1ZTogMC4sXG4gICAgICAgIHR5cGVHTFNMOiAnZmxvYXQnLFxuICAgICAgfSxcbiAgICAgICd1U2xpY2UnOiB7XG4gICAgICAgIHR5cGU6ICd2NCcsXG4gICAgICAgIHZhbHVlOiBbMC4wLCAwLjAsIDAuMCwgMC4wXSxcbiAgICAgICAgdHlwZUdMU0w6ICd2ZWM0JyxcbiAgICAgIH0sXG4gICAgICAndVBsYW5lMSc6IHtcbiAgICAgICAgdHlwZTogJ3Y0JyxcbiAgICAgICAgdmFsdWU6IFswLjAsIDAuMCwgMC4wLCAwLjBdLFxuICAgICAgICB0eXBlR0xTTDogJ3ZlYzQnLFxuICAgICAgfSxcbiAgICAgICd1UGxhbmVDb2xvcjEnOiB7XG4gICAgICAgIHR5cGU6ICd2MycsXG4gICAgICAgIHZhbHVlOiBbMS4wLCAxLjAsIDAuMF0sXG4gICAgICAgIHR5cGVHTFNMOiAndmVjMycsXG4gICAgICB9LFxuICAgICAgJ3VQbGFuZTInOiB7XG4gICAgICAgIHR5cGU6ICd2NCcsXG4gICAgICAgIHZhbHVlOiBbMC4wLCAwLjAsIDAuMCwgMC4wXSxcbiAgICAgICAgdHlwZUdMU0w6ICd2ZWM0JyxcbiAgICAgIH0sXG4gICAgICAndVBsYW5lQ29sb3IyJzoge1xuICAgICAgICB0eXBlOiAndjMnLFxuICAgICAgICB2YWx1ZTogWzEuMCwgMS4wLCAwLjBdLFxuICAgICAgICB0eXBlR0xTTDogJ3ZlYzMnLFxuICAgICAgfSxcbiAgICAgICd1UGxhbmUzJzoge1xuICAgICAgICB0eXBlOiAndjQnLFxuICAgICAgICB2YWx1ZTogWzAuMCwgMC4wLCAwLjAsIDAuMF0sXG4gICAgICAgIHR5cGVHTFNMOiAndmVjNCcsXG4gICAgICB9LFxuICAgICAgJ3VQbGFuZUNvbG9yMyc6IHtcbiAgICAgICAgdHlwZTogJ3YzJyxcbiAgICAgICAgdmFsdWU6IFsxLjAsIDEuMCwgMC4wXSxcbiAgICAgICAgdHlwZUdMU0w6ICd2ZWMzJyxcbiAgICAgIH0sXG5cbiAgICB9O1xuICB9XG59XG4iLCIvKipcbiAqIFxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyB7XG4gICAgLyoqXG4gICAgICogXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoKSB7XG5cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBcbiAgICAgKi9cbiAgICBjb21wdXRlKCkge1xuICAgICAgICByZXR1cm4gYFxudmFyeWluZyB2ZWM0IHZQb3M7XG52YXJ5aW5nIG1hdDQgdlByb2plY3Rpb25WaWV3TWF0cml4O1xuXG4vL1xuLy8gbWFpblxuLy9cbnZvaWQgbWFpbigpIHtcblxuICB2UG9zID0gbW9kZWxNYXRyaXggKiB2ZWM0KHBvc2l0aW9uLCAxLjAgKTtcbiAgdlByb2plY3Rpb25WaWV3TWF0cml4ID0gcHJvamVjdGlvbk1hdHJpeCAqIHZpZXdNYXRyaXg7XG4gIGdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIG1vZGVsVmlld01hdHJpeCAqIHZlYzQocG9zaXRpb24sIDEuMCApO1xuXG59XG4gICAgICAgIGA7XG4gICAgfVxuXG59XG4iLCJpbXBvcnQgc2hhZGVyc0ludGVycG9sYXRpb24gZnJvbSAnLi9pbnRlcnBvbGF0aW9uL3NoYWRlcnMuaW50ZXJwb2xhdGlvbic7XG5pbXBvcnQgc2hhZGVyc0ludGVyc2VjdEJveCBmcm9tICcuL2hlbHBlcnMvc2hhZGVycy5oZWxwZXJzLmludGVyc2VjdEJveCc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNoYWRlcnNGcmFnbWVudCB7XG5cbiAgLy8gcGFzcyB1bmlmb3JtcyBvYmplY3RcbiAgY29uc3RydWN0b3IodW5pZm9ybXMpIHtcbiAgICB0aGlzLl91bmlmb3JtcyA9IHVuaWZvcm1zO1xuICAgIHRoaXMuX2Z1bmN0aW9ucyA9IHt9O1xuICAgIHRoaXMuX21haW4gPSAnJztcbiAgfVxuXG4gIGZ1bmN0aW9ucygpIHtcbiAgICBpZih0aGlzLl9tYWluID09PSAnJykge1xuICAgICAgLy8gaWYgbWFpbiBpcyBlbXB0eSwgZnVuY3Rpb25zIGNhbiBub3QgaGF2ZSBiZWVuIGNvbXB1dGVkXG4gICAgICB0aGlzLm1haW4oKTtcbiAgICB9XG5cbiAgICBsZXQgY29udGVudCA9ICcnO1xuICAgIGZvciAobGV0IHByb3BlcnR5IGluIHRoaXMuX2Z1bmN0aW9ucykge1xuICAgICAgY29udGVudCArPSB0aGlzLl9mdW5jdGlvbnNbcHJvcGVydHldICsgJ1xcbic7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbnRlbnQ7XG4gIH1cblxuICB1bmlmb3JtcygpIHtcbiAgICBsZXQgY29udGVudCA9ICcnO1xuICAgIGZvciAobGV0IHByb3BlcnR5IGluIHRoaXMuX3VuaWZvcm1zKSB7XG4gICAgICBsZXQgdW5pZm9ybSA9IHRoaXMuX3VuaWZvcm1zW3Byb3BlcnR5XTtcbiAgICAgIGNvbnRlbnQgKz0gYHVuaWZvcm0gJHt1bmlmb3JtLnR5cGVHTFNMfSAke3Byb3BlcnR5fWA7XG5cbiAgICAgIGlmKHVuaWZvcm0gJiYgdW5pZm9ybS5sZW5ndGgpIHtcbiAgICAgICAgY29udGVudCArPSBgWyR7dW5pZm9ybS5sZW5ndGh9XWA7XG4gICAgICB9XG5cbiAgICAgIGNvbnRlbnQgKz0gJztcXG4nO1xuICAgIH1cblxuICAgIHJldHVybiBjb250ZW50O1xuICB9XG5cbiAgbWFpbigpIHtcbiAgICAvLyBuZWVkIHRvIHByZS1jYWxsIG1haW4gdG8gZmlsbCB1cCB0aGUgZnVuY3Rpb25zIGxpc3RcbiAgICB0aGlzLl9tYWluID0gYFxudm9pZCBnZXRJbnRlbnNpdHkoaW4gdmVjMyBkYXRhQ29vcmRpbmF0ZXMsIG91dCBmbG9hdCBpbnRlbnNpdHksIG91dCB2ZWMzIGdyYWRpZW50KXtcblxuICB2ZWM0IGRhdGFWYWx1ZSA9IHZlYzQoMC4sIDAuLCAwLiwgMC4pO1xuICAke3NoYWRlcnNJbnRlcnBvbGF0aW9uKHRoaXMsICdkYXRhQ29vcmRpbmF0ZXMnLCAnZGF0YVZhbHVlJywgJ2dyYWRpZW50Jyl9XG5cbiAgaW50ZW5zaXR5ID0gZGF0YVZhbHVlLnI7XG5cbiAgLy8gcmVzY2FsZS9zbG9wZVxuICBpbnRlbnNpdHkgPSBpbnRlbnNpdHkqdVJlc2NhbGVTbG9wZUludGVyY2VwdFswXSArIHVSZXNjYWxlU2xvcGVJbnRlcmNlcHRbMV07XG4gIC8vIHdpbmRvdyBsZXZlbFxuICBmbG9hdCB3aW5kb3dNaW4gPSB1V2luZG93Q2VudGVyV2lkdGhbMF0gLSB1V2luZG93Q2VudGVyV2lkdGhbMV0gKiAwLjU7XG4gIGludGVuc2l0eSA9ICggaW50ZW5zaXR5IC0gd2luZG93TWluICkgLyB1V2luZG93Q2VudGVyV2lkdGhbMV07XG59XG5cbnZvaWQgbWFpbih2b2lkKSB7XG4gIGNvbnN0IGludCBtYXhTdGVwcyA9IDEwMjQ7XG5cbiAgLy8gdGhlIHJheVxuICB2ZWMzIHJheU9yaWdpbiA9IGNhbWVyYVBvc2l0aW9uO1xuICB2ZWMzIHJheURpcmVjdGlvbiA9IG5vcm1hbGl6ZSh2UG9zLnh5eiAtIHJheU9yaWdpbik7XG5cbiAgLy8gdGhlIEF4ZS1BbGlnbmVkIEItQm94XG4gIHZlYzMgQUFCQk1pbiA9IHZlYzModVdvcmxkQkJveFswXSwgdVdvcmxkQkJveFsyXSwgdVdvcmxkQkJveFs0XSk7XG4gIHZlYzMgQUFCQk1heCA9IHZlYzModVdvcmxkQkJveFsxXSwgdVdvcmxkQkJveFszXSwgdVdvcmxkQkJveFs1XSk7XG5cbiAgLy8gSW50ZXJzZWN0aW9uIHJheS9iYm94XG4gIGZsb2F0IHROZWFyLCB0RmFyO1xuICBib29sIGludGVyc2VjdCA9IGZhbHNlO1xuICAke3NoYWRlcnNJbnRlcnNlY3RCb3guYXBpKHRoaXMsICdyYXlPcmlnaW4nLCAncmF5RGlyZWN0aW9uJywgJ0FBQkJNaW4nLCAnQUFCQk1heCcsICd0TmVhcicsICd0RmFyJywgJ2ludGVyc2VjdCcpfVxuICBpZiAodE5lYXIgPCAwLjApIHROZWFyID0gMC4wO1xuXG4gIC8vIGluaXQgdGhlIHJheSBtYXJjaGluZ1xuICBmbG9hdCB0Q3VycmVudCA9IHROZWFyO1xuICBmbG9hdCB0U3RlcCA9ICh0RmFyIC0gdE5lYXIpIC8gZmxvYXQodVN0ZXBzKTtcbiAgdmVjNCBhY2N1bXVsYXRlZENvbG9yID0gdmVjNCgwLjApO1xuICBmbG9hdCBhY2N1bXVsYXRlZEFscGhhID0gMC4wO1xuXG4gIGZvcihpbnQgcmF5U3RlcCA9IDA7IHJheVN0ZXAgPCBtYXhTdGVwczsgcmF5U3RlcCsrKXtcbiAgICB2ZWMzIGN1cnJlbnRQb3NpdGlvbiA9IHJheU9yaWdpbiArIHJheURpcmVjdGlvbiAqIHRDdXJyZW50O1xuICAgIC8vIHNvbWUgbm9uLWxpbmVhciBGVU5cbiAgICAvLyBzb21lIG9jY2x1c2lvbiBpc3N1ZSB0byBiZSBmaXhlZFxuICAgIHZlYzMgdHJhbnNmb3JtZWRQb3NpdGlvbiA9IGN1cnJlbnRQb3NpdGlvbjsgLy90cmFuc2Zvcm1Qb2ludChjdXJyZW50UG9zaXRpb24sIHVBbXBsaXR1ZGUsIHVGcmVxdWVuY2UpO1xuICAgIC8vIHdvcmxkIHRvIGRhdGEgY29vcmRpbmF0ZXNcbiAgICAvLyByb3VuZGluZyB0cmlja1xuICAgIC8vIGZpcnN0IGNlbnRlciBvZiBmaXJzdCB2b3hlbCBpbiBkYXRhIHNwYWNlIGlzIENFTlRFUkVEIG9uICgwLDAsMClcbiAgICB2ZWM0IGRhdGFDb29yZGluYXRlc1JhdyA9IHVXb3JsZFRvRGF0YSAqIHZlYzQodHJhbnNmb3JtZWRQb3NpdGlvbiwgMS4wKTtcbiAgICB2ZWMzIGN1cnJlbnRWb3hlbCA9IHZlYzMoZGF0YUNvb3JkaW5hdGVzUmF3LngsIGRhdGFDb29yZGluYXRlc1Jhdy55LCBkYXRhQ29vcmRpbmF0ZXNSYXcueik7XG4gICAgZmxvYXQgaW50ZW5zaXR5ID0gMC4wO1xuICAgIHZlYzMgZ3JhZGllbnQgPSB2ZWMzKDAuLCAwLiwgMC4pO1xuICAgIGdldEludGVuc2l0eShjdXJyZW50Vm94ZWwsIGludGVuc2l0eSwgZ3JhZGllbnQpO1xuXG4gICAgdmVjNCBjb2xvclNhbXBsZTtcbiAgICBmbG9hdCBhbHBoYVNhbXBsZTtcbiAgICBpZih1THV0ID09IDEpe1xuICAgICAgdmVjNCBjb2xvckZyb21MVVQgPSB0ZXh0dXJlMkQoIHVUZXh0dXJlTFVULCB2ZWMyKCBpbnRlbnNpdHksIDEuMCkgKTtcbiAgICAgIC8vIDI1NiBjb2xvcnNcbiAgICAgIGNvbG9yU2FtcGxlID0gY29sb3JGcm9tTFVUO1xuICAgICAgYWxwaGFTYW1wbGUgPSBjb2xvckZyb21MVVQuYTtcbiAgICB9XG4gICAgZWxzZXtcbiAgICAgIGFscGhhU2FtcGxlID0gaW50ZW5zaXR5O1xuICAgICAgY29sb3JTYW1wbGUuciA9IGNvbG9yU2FtcGxlLmcgPSBjb2xvclNhbXBsZS5iID0gaW50ZW5zaXR5ICogYWxwaGFTYW1wbGU7XG4gICAgfVxuXG4gICAgYWxwaGFTYW1wbGUgPSBhbHBoYVNhbXBsZSAqIHVBbHBoYUNvcnJlY3Rpb247XG4gICAgYWxwaGFTYW1wbGUgKj0gKDEuMCAtIGFjY3VtdWxhdGVkQWxwaGEpO1xuXG4gICAgYWNjdW11bGF0ZWRDb2xvciArPSBhbHBoYVNhbXBsZSAqIGNvbG9yU2FtcGxlO1xuICAgIGFjY3VtdWxhdGVkQWxwaGEgKz0gYWxwaGFTYW1wbGU7XG5cbiAgICB0Q3VycmVudCArPSB0U3RlcDtcblxuICAgIGlmKHRDdXJyZW50ID4gdEZhciB8fCBhY2N1bXVsYXRlZEFscGhhID49IDEuMCApIGJyZWFrO1xuICB9XG5cbiAgZ2xfRnJhZ0NvbG9yID0gdmVjNChhY2N1bXVsYXRlZENvbG9yLnh5eiwgYWNjdW11bGF0ZWRBbHBoYSk7XG59XG4gICBgO1xuICB9XG5cbiAgY29tcHV0ZSgpIHtcbiAgICBsZXQgc2hhZGVySW50ZXJwb2xhdGlvbiA9ICcnO1xuICAgIC8vIHNoYWRlckludGVycG9sYXRpb24uaW5saW5lKGFyZ3MpIC8vdHJ1ZS9mYWxzZVxuICAgIC8vIHNoYWRlckludGVycG9sYXRpb24uZnVuY3Rpb25zKGFyZ3MpXG5cbiAgICByZXR1cm4gYFxuLy8gdW5pZm9ybXNcbiR7dGhpcy51bmlmb3JtcygpfVxuXG4vLyB2YXJ5aW5nIChzaG91bGQgZmV0Y2ggaXQgZnJvbSB2ZXJ0ZXggZGlyZWN0bHkpXG52YXJ5aW5nIHZlYzQgICAgICB2UG9zO1xuXG4vLyB0YWlsb3JlZCBmdW5jdGlvbnNcbiR7dGhpcy5mdW5jdGlvbnMoKX1cblxuLy8gbWFpbiBsb29wXG4ke3RoaXMuX21haW59XG4gICAgICBgO1xuICAgIH1cblxufVxuIiwiXG4vKipcbiAqIEBtb2R1bGUgc2hhZGVycy9kYXRhXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNoYWRlcnNVbmlmb3JtIHtcbiAgc3RhdGljIHVuaWZvcm1zKCkge1xuICAgIHJldHVybiB7XG4gICAgICAndVRleHR1cmVTaXplJzoge1xuICAgICAgICB0eXBlOiAnaScsXG4gICAgICAgIHZhbHVlOiAwLFxuICAgICAgICB0eXBlR0xTTDogJ2ludCcsXG4gICAgICB9LFxuICAgICAgJ3VUZXh0dXJlQ29udGFpbmVyJzoge1xuICAgICAgICB0eXBlOiAndHYnLFxuICAgICAgICB2YWx1ZTogW10sXG4gICAgICAgIHR5cGVHTFNMOiAnc2FtcGxlcjJEJyxcbiAgICAgICAgbGVuZ3RoOiA3LFxuICAgICAgfSxcbiAgICAgICd1RGF0YURpbWVuc2lvbnMnOiB7XG4gICAgICAgIHR5cGU6ICdpdicsXG4gICAgICAgIHZhbHVlOiBbMCwgMCwgMF0sXG4gICAgICAgIHR5cGVHTFNMOiAnaXZlYzMnLFxuICAgICAgfSxcbiAgICAgICd1V29ybGRUb0RhdGEnOiB7XG4gICAgICAgIHR5cGU6ICdtNCcsXG4gICAgICAgIHZhbHVlOiBuZXcgVEhSRUUuTWF0cml4NCgpLFxuICAgICAgICB0eXBlR0xTTDogJ21hdDQnLFxuICAgICAgfSxcbiAgICAgICd1V2luZG93Q2VudGVyV2lkdGgnOiB7XG4gICAgICAgIHR5cGU6ICdmdjEnLFxuICAgICAgICB2YWx1ZTogWzAuMCwgMC4wXSxcbiAgICAgICAgdHlwZUdMU0w6ICdmbG9hdCcsXG4gICAgICAgIGxlbmd0aDogMixcbiAgICAgIH0sXG4gICAgICAndVJlc2NhbGVTbG9wZUludGVyY2VwdCc6IHtcbiAgICAgICAgdHlwZTogJ2Z2MScsXG4gICAgICAgIHZhbHVlOiBbMC4wLCAwLjBdLFxuICAgICAgICB0eXBlR0xTTDogJ2Zsb2F0JyxcbiAgICAgICAgbGVuZ3RoOiAyLFxuICAgICAgfSxcbiAgICAgICd1TnVtYmVyT2ZDaGFubmVscyc6IHtcbiAgICAgICAgdHlwZTogJ2knLFxuICAgICAgICB2YWx1ZTogMSxcbiAgICAgICAgdHlwZUdMU0w6ICdpbnQnLFxuICAgICAgfSxcbiAgICAgICd1Qml0c0FsbG9jYXRlZCc6IHtcbiAgICAgICAgdHlwZTogJ2knLFxuICAgICAgICB2YWx1ZTogOCxcbiAgICAgICAgdHlwZUdMU0w6ICdpbnQnLFxuICAgICAgfSxcbiAgICAgICd1SW52ZXJ0Jzoge1xuICAgICAgICB0eXBlOiAnaScsXG4gICAgICAgIHZhbHVlOiAwLFxuICAgICAgICB0eXBlR0xTTDogJ2ludCcsXG4gICAgICB9LFxuICAgICAgJ3VMdXQnOiB7XG4gICAgICAgIHR5cGU6ICdpJyxcbiAgICAgICAgdmFsdWU6IDAsXG4gICAgICAgIHR5cGVHTFNMOiAnaW50JyxcbiAgICAgIH0sXG4gICAgICAndVRleHR1cmVMVVQnOiB7XG4gICAgICAgIHR5cGU6ICd0JyxcbiAgICAgICAgdmFsdWU6IFtdLFxuICAgICAgICB0eXBlR0xTTDogJ3NhbXBsZXIyRCcsXG4gICAgICB9LFxuICAgICAgJ3VQaXhlbFR5cGUnOiB7XG4gICAgICAgIHR5cGU6ICdpJyxcbiAgICAgICAgdmFsdWU6IDAsXG4gICAgICAgIHR5cGVHTFNMOiAnaW50JyxcbiAgICAgIH0sXG4gICAgICAndVBhY2tlZFBlclBpeGVsJzoge1xuICAgICAgICB0eXBlOiAnaScsXG4gICAgICAgIHZhbHVlOiAxLFxuICAgICAgICB0eXBlR0xTTDogJ2ludCcsXG4gICAgICB9LFxuICAgICAgJ3VJbnRlcnBvbGF0aW9uJzoge1xuICAgICAgICB0eXBlOiAnaScsXG4gICAgICAgIHZhbHVlOiAxLFxuICAgICAgICB0eXBlR0xTTDogJ2ludCcsXG4gICAgICB9LFxuICAgICAgJ3VXb3JsZEJCb3gnOiB7XG4gICAgICAgIHR5cGU6ICdmdjEnLFxuICAgICAgICB2YWx1ZTogWzAuMCwgMC4wLCAwLjAsIDAuMCwgMC4wLCAwLjBdLFxuICAgICAgICB0eXBlR0xTTDogJ2Zsb2F0JyxcbiAgICAgICAgbGVuZ3RoOiA2LFxuICAgICAgfSxcbiAgICAgICd1U3RlcHMnOiB7XG4gICAgICAgIHR5cGU6ICdpJyxcbiAgICAgICAgdmFsdWU6IDI1NixcbiAgICAgICAgdHlwZUdMU0w6ICdpbnQnLFxuICAgICAgfSxcbiAgICAgICd1QWxwaGFDb3JyZWN0aW9uJzoge1xuICAgICAgICB0eXBlOiAnZicsXG4gICAgICAgIHZhbHVlOiAwLjUsXG4gICAgICAgIHR5cGVHTFNMOiAnZmxvYXQnLFxuICAgICAgfSxcbiAgICAgICd1RnJlcXVlbmNlJzoge1xuICAgICAgICB0eXBlOiAnZicsXG4gICAgICAgIHZhbHVlOiAwLjAsXG4gICAgICAgIHR5cGVHTFNMOiAnZmxvYXQnLFxuICAgICAgfSxcbiAgICAgICd1QW1wbGl0dWRlJzoge1xuICAgICAgICB0eXBlOiAnZicsXG4gICAgICAgIHZhbHVlOiAwLjAsXG4gICAgICAgIHR5cGVHTFNMOiAnZmxvYXQnLFxuICAgICAgfSxcbiAgICB9O1xuICB9XG59XG4iLCJleHBvcnQgZGVmYXVsdCBjbGFzcyBTaGFkZXJzVmVydGV4IHtcblxuICAgIGNvbnN0cnVjdG9yKCkge1xuXG4gICAgfVxuXG4gICAgY29tcHV0ZSgpIHtcbiAgICAgICAgcmV0dXJuIGBcbnZhcnlpbmcgdmVjNCB2UG9zO1xuXG4vL1xuLy8gbWFpblxuLy9cbnZvaWQgbWFpbigpIHtcblxuICB2UG9zID0gbW9kZWxNYXRyaXggKiB2ZWM0KHBvc2l0aW9uLCAxLjAgKTtcbiAgZ2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbW9kZWxWaWV3TWF0cml4ICogdmVjNChwb3NpdGlvbiwgMS4wICk7XG5cbn1cbiAgICAgICAgYDtcbiAgICB9XG5cbn1cbiIsImltcG9ydCBXaWRnZXRzQmFzZSBmcm9tICcuLi93aWRnZXRzL3dpZGdldHMuYmFzZSc7XG5pbXBvcnQgV2lkZ2V0c0hhbmRsZSBmcm9tICcuLi93aWRnZXRzL3dpZGdldHMuaGFuZGxlJztcblxuLyoqXG4gKiBAbW9kdWxlIHdpZGdldHMvaGFuZGxlXG4gKlxuICovXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFdpZGdldHNBbm5vdGF0aW9uIGV4dGVuZHMgV2lkZ2V0c0Jhc2Uge1xuXG4gIGNvbnN0cnVjdG9yKHRhcmdldE1lc2gsIGNvbnRyb2xzLCBjYW1lcmEsIGNvbnRhaW5lcikge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLl90YXJnZXRNZXNoID0gdGFyZ2V0TWVzaDtcbiAgICB0aGlzLl9jb250cm9scyA9IGNvbnRyb2xzO1xuICAgIHRoaXMuX2NhbWVyYSA9IGNhbWVyYTtcbiAgICB0aGlzLl9jb250YWluZXIgPSBjb250YWluZXI7XG5cbiAgICB0aGlzLl9hY3RpdmUgPSB0cnVlO1xuXG4gICAgdGhpcy5fd29ybGRQb3NpdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgaWYodGhpcy5fdGFyZ2V0TWVzaCAhPT0gbnVsbCkge1xuICAgICAgdGhpcy5fd29ybGRQb3NpdGlvbiA9IHRoaXMuX3RhcmdldE1lc2gucG9zaXRpb247XG4gICAgfVxuXG4gICAgLy8gbWVzaCBzdHVmZlxuICAgIHRoaXMuX21hdGVyaWFsID0gbnVsbDtcbiAgICB0aGlzLl9nZW9tZXRyeSA9IG51bGw7XG4gICAgdGhpcy5fbWVzaCA9IG51bGw7XG5cbiAgICAvLyBkb20gc3R1ZmZcbiAgICB0aGlzLl9saW5lID0gbnVsbDtcbiAgICB0aGlzLl9sYWJlbCA9IG51bGw7XG4gICAgdGhpcy5fY29uZSA9IG51bGw7XG4gICAgdGhpcy5fbGFiZWx0ZXh0ID0gbnVsbDtcblxuICAgIC8vYm9vbGVhbnNcbiAgICB0aGlzLl9hbHJlYWR5Y3JlYXRlZCA9IG51bGw7IC8vYm9vbCB0aGF0IHR1cm5zIHRydWUgd2hlbiB0aGUgdXNlciBlbnRlciB0aGUgbmFtZSBvZiB0aGUgbGFiZWxcbiAgICB0aGlzLl9tb3ZpbmdsYWJlbCA9IG51bGw7IC8vYm9vbCB0aGF0IHR1cm5zIHRydWUgd2hlbiB0aGUgbGFiZWwgaXMgbW92aW5nIHdpdGggdGhlIG1vdXNlXG4gICAgdGhpcy5fbGFiZWxtb3ZlZCA9IGZhbHNlOyAvL2Jvb2wgdGhhdCB0dXJucyB0cnVlIG9uY2UgdGhlIGxhYmVsIGlzIG1vdmVkIGJ5IHRoZSB1c2VyIChhdCBsZWFzdCBvbmNlKVxuXG4gICAgdGhpcy5fbGFiZWxob3ZlcmVkID0gZmFsc2U7XG4gICAgdGhpcy5fZG9tSG92ZXJlZCA9IGZhbHNlO1xuICAgIHRoaXMuX2hvdmVyZWQgPSB0cnVlO1xuXG4gICAgLy92YXJcbiAgICB0aGlzLl9sYWJlbHBvc2l0aW9ueCA9IG51bGw7IC8vcG9zaXRpb24gb2YgbGFiZWwgKHRvcCBsZWZ0IGNvcm5lcilcbiAgICB0aGlzLl9sYWJlbHBvc2l0aW9ueSA9IG51bGw7IC8vcG9zaXRpb24gb2YgbGFiZWwgKHRvcCBsZWZ0IGNvcm5lcilcbiAgICB0aGlzLl9kaWZmZXJlbmNlbW91c2VjZW50ZXJsYWJlbHggPSAwOyAvL2RpZmZlcmVuY2UgYmV0d2VlbiBtb3VzZSBwb3NpdGlvbiBpbiB0aGUgbGFiZWwgYW5kIHBvc2l0aW9uIG9mIGxhYmVsICh0b3AgbGVmdCBjb3JuZXIpXG4gICAgdGhpcy5fZGlmZmVyZW5jZW1vdXNlY2VudGVybGFiZWx5ID0gMDsgLy9kaWZmZXJlbmNlIGJldHdlZW4gbW91c2UgcG9zaXRpb24gaW4gdGhlIGxhYmVsIGFuZCBwb3NpdGlvbiBvZiBsYWJlbCAodG9wIGxlZnQgY29ybmVyKVxuXG4gICAgLy8gYWRkIGhhbmRsZXNcbiAgICB0aGlzLl9oYW5kbGVzID0gW107XG5cbiAgICBzZWxmID0gdGhpcztcblxuICAgIC8vIGZpcnN0IGhhbmRsZVxuICAgIGxldCBmaXJzdEhhbmRsZSA9IG5ldyBXaWRnZXRzSGFuZGxlKHRoaXMuX3RhcmdldE1lc2gsIHRoaXMuX2NvbnRyb2xzLCB0aGlzLl9jYW1lcmEsIHRoaXMuX2NvbnRhaW5lcik7XG4gICAgZmlyc3RIYW5kbGUud29ybGRQb3NpdGlvbiA9IHRoaXMuX3dvcmxkUG9zaXRpb247XG4gICAgZmlyc3RIYW5kbGUuaG92ZXJlZCA9IHRydWU7XG4gICAgdGhpcy5hZGQoZmlyc3RIYW5kbGUpO1xuXG4gICAgdGhpcy5faGFuZGxlcy5wdXNoKGZpcnN0SGFuZGxlKTtcblxuICAgIGxldCBzZWNvbmRIYW5kbGUgPSBuZXcgV2lkZ2V0c0hhbmRsZSh0aGlzLl90YXJnZXRNZXNoLCB0aGlzLl9jb250cm9scywgdGhpcy5fY2FtZXJhLCB0aGlzLl9jb250YWluZXIpO1xuICAgIHNlY29uZEhhbmRsZS53b3JsZFBvc2l0aW9uID0gdGhpcy5fd29ybGRQb3NpdGlvbjtcbiAgICBzZWNvbmRIYW5kbGUuaG92ZXJlZCA9IHRydWU7XG4gICAgLy8gYWN0aXZlIGFuZCB0cmFja2luZyBtaWdodCBiZSByZWR1bmRhbnRcbiAgICBzZWNvbmRIYW5kbGUuYWN0aXZlID0gdHJ1ZTtcbiAgICBzZWNvbmRIYW5kbGUudHJhY2tpbmcgPSB0cnVlO1xuICAgIHRoaXMuYWRkKHNlY29uZEhhbmRsZSk7XG5cbiAgICB0aGlzLl9oYW5kbGVzLnB1c2goc2Vjb25kSGFuZGxlKTtcblxuICAgIC8vIENyZWF0ZSBhbm5vdGF0aW9uXG5cbiAgICB0aGlzLmNyZWF0ZSgpO1xuXG4gICAgdGhpcy5vbk1vdmUgPSB0aGlzLm9uTW92ZS5iaW5kKHRoaXMpO1xuICAgIHRoaXMub25Ib3ZlcmxhYmVsID0gdGhpcy5vbkhvdmVybGFiZWwuYmluZCh0aGlzKTtcbiAgICB0aGlzLm5vdG9uSG92ZXJsYWJlbCA9IHRoaXMubm90b25Ib3ZlcmxhYmVsLmJpbmQodGhpcyk7ICBcbiAgICB0aGlzLmNoYW5nZWxhYmVsdGV4dCA9IHRoaXMuY2hhbmdlbGFiZWx0ZXh0LmJpbmQodGhpcyk7IFxuICAgIHRoaXMubW92ZWxhYmVsID0gdGhpcy5tb3ZlbGFiZWwuYmluZCh0aGlzKTtcbiAgICB0aGlzLm5vdG1vdmVsYWJlbCA9IHRoaXMubm90bW92ZWxhYmVsLmJpbmQodGhpcyk7XG5cbiAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXJzKCk7XG5cbiAgfVxuXG4gIGFkZEV2ZW50TGlzdGVuZXJzKCkge1xuICAgIHRoaXMuX2xhYmVsLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZW50ZXInLCB0aGlzLm9uSG92ZXJsYWJlbCk7XG4gICAgdGhpcy5fbGFiZWwuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIHRoaXMubm90b25Ib3ZlcmxhYmVsKTtcbiAgICB0aGlzLl9sYWJlbC5hZGRFdmVudExpc3RlbmVyKCdkYmxjbGljaycsIHRoaXMuY2hhbmdlbGFiZWx0ZXh0KTtcbiAgICB0aGlzLl9sYWJlbC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLm1vdmVsYWJlbCk7XG4gICAgdGhpcy5fY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLm5vdG1vdmVsYWJlbCk7XG5cbiAgICB0aGlzLl9jb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V3aGVlbCcsIHRoaXMub25Nb3ZlKTtcbiAgICB0aGlzLl9jb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcignRE9NTW91c2VTY3JvbGwnLCB0aGlzLm9uTW92ZSk7XG4gIH1cblxuICBtb3ZlbGFiZWwoKSB7IC8vZnVuY3Rpb24gY2FsbGVkIHdoZW4gbW91c2Vkb3duXG4gICAgaWYgKHRoaXMuX2xhYmVsaG92ZXJlZCA9IHRydWUpeyAvL2lmIGxhYmVsIGhvYmVyZWQgd2Ugd2lsbCBtb3ZlIHRoZSBsYWJlbFxuICAgICAgICB0aGlzLl9tb3ZpbmdsYWJlbCA9IHRydWU7XG4gICAgICAgIHRoaXMuX2xhYmVsbW92ZWQgPSB0cnVlO1xuICAgICAgICBsZXQgbW91c2V5ID0gIC0gKC1ldmVudC5jbGllbnRZICsgdGhpcy5fY29udGFpbmVyLm9mZnNldEhlaWdodCk7XG4gICAgICAgIGxldCBtb3VzZXggPSBldmVudC5jbGllbnRYO1xuICAgICAgICAvL2NhbGN1bGF0ZSBkaWZmZXJlbmNlbW91c2VjZW50ZXJsYWJlbCAoZGlmZmVyZW5jZSBiZXR3ZWVuIHJlZiBwb3NpdGlvbiBvZiB0aGUgbGFiZWwgKHRvcC1sZWZ0IGNvcm5lcikgYW5kIG1vdXNlIHBvc2l0aW9uIGluIHRoZSBsYWJlbClcbiAgICAgICAgdGhpcy5fZGlmZmVyZW5jZW1vdXNlY2VudGVybGFiZWx4ID0gTWF0aC5hYnMoTWF0aC5hYnMobW91c2V4KSAtIE1hdGguYWJzKHRoaXMuX2xhYmVscG9zaXRpb254KSk7XG4gICAgICAgIHRoaXMuX2RpZmZlcmVuY2Vtb3VzZWNlbnRlcmxhYmVseSA9IE1hdGguYWJzKE1hdGguYWJzKG1vdXNleSkgLSBNYXRoLmFicyh0aGlzLl9sYWJlbHBvc2l0aW9ueSkpO1xuICAgIH1cbiAgfVxuXG4gIG5vdG1vdmVsYWJlbCgpIHsgLy90aGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCB3aGVuIG1vdXNldXBcbiAgICB0aGlzLl9tb3ZpbmdsYWJlbCA9IGZhbHNlO1xuICAgIHRoaXMuX2hhbmRsZXNbMF0uX2NvbnRyb2xzLmVuYWJsZWQgPSB0cnVlOyAvL21vdmUgdGhlIGNhbWVyYSB3aGVuIG1vdXNlZG93biBhbmQgbW91c2Vkb3duIGFnYWluXG4gICAgdGhpcy5faGFuZGxlc1sxXS5fY29udHJvbHMuZW5hYmxlZCA9IHRydWU7IFxuICAgIHRoaXMuX2RpZmZlcmVuY2Vtb3VzZWNlbnRlcmxhYmVseCA9IDA7IC8vcmVzdGFydCB0aGUgdmFsdWUgb2YgZGlmZmVyZW5jZW1vdXNlY2VudGVybGFiZWwuIE5lY2Vzc2FyeT9cbiAgICB0aGlzLl9kaWZmZXJlbmNlbW91c2VjZW50ZXJsYWJlbHkgPSAwO1xuICB9XG5cbiAgb25Ib3ZlcmxhYmVsKCkgeyAvL3RoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIHdoZW4gbW91c2UgZW50ZXJzIHRoZSBsYWJlbCB3aXRoIFwibW91c2VlbnRlclwiIGV2ZW50XG4gICAgdGhpcy5fbGFiZWxob3ZlcmVkID0gdHJ1ZTtcbiAgfVxuIFxuICBub3RvbkhvdmVybGFiZWwoKSB7IC8vdGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgd2hlbiBtb3VzZSBsZWF2ZXMgdGhlIGxhYmVsIHdpdGggXCJtb3VzZWxlYXZlXCIgZXZlbnRcbiAgICB0aGlzLl9sYWJlbGhvdmVyZWQgPSBmYWxzZTtcbiAgfVxuXG4gIG9uTW92ZShldnQpIHtcblxuICAgIGlmICh0aGlzLl9tb3ZpbmdsYWJlbCA9PSB0cnVlKXtcbiAgICAgICAgdGhpcy5faGFuZGxlc1swXS5fY29udHJvbHMuZW5hYmxlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9oYW5kbGVzWzFdLl9jb250cm9scy5lbmFibGVkID0gZmFsc2U7IFxuICAgIH1cblxuICAgIHRoaXMuX2RyYWdnZWQgPSB0cnVlO1xuXG4gICAgdGhpcy5faGFuZGxlc1swXS5vbk1vdmUoZXZ0KTtcbiAgICB0aGlzLl9oYW5kbGVzWzFdLm9uTW92ZShldnQpO1xuXG4gICAgdGhpcy5faG92ZXJlZCA9IHRoaXMuX2hhbmRsZXNbMF0uaG92ZXJlZCB8fCB0aGlzLl9oYW5kbGVzWzFdLmhvdmVyZWQgfHwgdGhpcy5fbGFiZWxob3ZlcmVkO1xuXG4gICAgdGhpcy51cGRhdGUoKTtcblxuICB9XG5cblxuICBvblN0YXJ0KGV2dCkge1xuXG4gICAgdGhpcy5fZHJhZ2dlZCA9IGZhbHNlO1xuXG4gICAgdGhpcy5faGFuZGxlc1swXS5vblN0YXJ0KGV2dCk7XG4gICAgdGhpcy5faGFuZGxlc1sxXS5vblN0YXJ0KGV2dCk7XG5cbiAgICB0aGlzLl9hY3RpdmUgPSB0aGlzLl9oYW5kbGVzWzBdLmFjdGl2ZSB8fCB0aGlzLl9oYW5kbGVzWzFdLmFjdGl2ZTtcblxuICAgIHRoaXMudXBkYXRlKCk7XG4gIH1cblxuXG4gIHNldGxhYmVsdGV4dCgpIHtcbiAgICB0aGlzLl9sYWJlbHRleHQgPSBwcm9tcHQoXCJQbGVhc2UgZW50ZXIgdGhlIG5hbWUgb2YgdGhlIGxhYmVsXCIsIFwiXCIpOyAvL3RoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIHdoZW4gdGhlIHVzZXIgY3JlYXRlcyBhIG5ldyBhcnJvd1xuICAgIGlmICh0eXBlb2YgdGhpcy5fbGFiZWx0ZXh0ID09ICdzdHJpbmcnKXsgLy9hdm9pZCBlcnJvclxuICAgICAgICBpZiAodGhpcy5fbGFiZWx0ZXh0Lmxlbmd0aCA+IDApe1xuICAgICAgICAgICAgdGhpcy5fbGFiZWwuaW5uZXJIVE1MID0gdGhpcy5fbGFiZWx0ZXh0O1xuICAgICAgICAgICAgdGhpcy5fbGFiZWwuc3R5bGUuZGlzcGxheSA9ICcnOyAvL2luIGNzcyBhbiBlbXB0eSBzdHJpbmcgaXMgdXNlZCB0byByZXZlcnQgZGlzcGxheT1ub25lLiBTaG93IHRoZSBsYWJlbCBvbmNlIHdlIGtub3cgdGhlIGNvbnRlbnRcbiAgICAgICAgICAgIHRoaXMuX2Rhc2hsaW5lLnN0eWxlLmRpc3BsYXkgPSAnJzsgLy9pbiBjc3MgYW4gZW1wdHkgc3RyaW5nIGlzIHVzZWQgdG8gcmV2ZXJ0IGRpc3BsYXk9bm9uZS4gU2hvdyB0aGUgbGFiZWwgb25jZSB3ZSBrbm93IHRoZSBjb250ZW50XG4gICAgICAgIH1lbHNle1xuICAgICAgICAgICAgdGhpcy5fbGFiZWwuaW5uZXJIVE1MID0gdGhpcy5fbGFiZWx0ZXh0O1xuICAgICAgICAgICAgdGhpcy5fbGFiZWwuc3R5bGUuZGlzcGxheSA9ICdub25lJzsgLy9oaWRlIHRoZSBsYWJlbFxuICAgICAgICAgICAgdGhpcy5fZGFzaGxpbmUuc3R5bGUuZGlzcGxheSA9ICdub25lJzsgLy9oaWRlIHRoZSBsYWJlbFxuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgY2hhbmdlbGFiZWx0ZXh0KCkgeyAvL3RoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIHdoZW4gdGhlIHVzZXIgZG9lcyBkb3VibGUgY2xpY2sgaW4gdGhlIGxhYmVsXG4gICAgdGhpcy5fbGFiZWx0ZXh0ID0gcHJvbXB0KFwiUGxlYXNlIGVudGVyIG5ldyBuYW1lIG9mIHRoZSBsYWJlbFwiLCB0aGlzLl9sYWJlbC5pbm5lckhUTUwpO1xuICAgIGlmICh0eXBlb2YgdGhpcy5fbGFiZWx0ZXh0ID09ICdzdHJpbmcnKXsgLy9hdm9pZCBlcnJvclxuICAgICAgICBpZiAodGhpcy5fbGFiZWx0ZXh0Lmxlbmd0aCA+IDApeyBcbiAgICAgICAgICAgIHRoaXMuX2xhYmVsLmlubmVySFRNTCA9IHRoaXMuX2xhYmVsdGV4dDtcbiAgICAgICAgICAgIHRoaXMuX2xhYmVsLnN0eWxlLmRpc3BsYXkgPSAnJzsgLy9pbiBjc3MgYW4gZW1wdHkgc3RyaW5nIGlzIHVzZWQgdG8gcmV2ZXJ0IGRpc3BsYXk9bm9uZS4gU2hvdyB0aGUgbGFiZWxcbiAgICAgICAgICAgIHRoaXMuX2Rhc2hsaW5lLnN0eWxlLmRpc3BsYXkgPSAnJzsgLy9pbiBjc3MgYW4gZW1wdHkgc3RyaW5nIGlzIHVzZWQgdG8gcmV2ZXJ0IGRpc3BsYXk9bm9uZS4gU2hvdyB0aGUgbGFiZWxcbiAgICAgICAgfWVsc2V7IC8vIGlmIHRoZSBsZW5ndGggaXMgMCB0aGUgdXNlciBwcmVzc2VkIENhbmNlbFxuICAgICAgICAgICAgdGhpcy5fbGFiZWwuaW5uZXJIVE1MID0gdGhpcy5fbGFiZWx0ZXh0O1xuICAgICAgICAgICAgdGhpcy5fbGFiZWwuc3R5bGUuZGlzcGxheSA9ICdub25lJzsgLy9oaWRlIHRoZSBsYWJlbFxuICAgICAgICAgICAgdGhpcy5fZGFzaGxpbmUuc3R5bGUuZGlzcGxheSA9ICdub25lJzsgLy9oaWRlIHRoZSBsYWJlbFxuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgb25FbmQoZXZ0KSB7XG4gICAgLy8gRmlyc3QgSGFuZGxlXG4gICAgdGhpcy5faGFuZGxlc1swXS5vbkVuZChldnQpO1xuXG4gICAgLy8gU2Vjb25kIEhhbmRsZVxuICAgIGlmKHRoaXMuX2RyYWdnZWQgfHwgIXRoaXMuX2hhbmRsZXNbMV0udHJhY2tpbmcpIHtcbiAgICAgIHRoaXMuX2hhbmRsZXNbMV0udHJhY2tpbmcgPSBmYWxzZTtcbiAgICAgIHRoaXMuX2hhbmRsZXNbMV0ub25FbmQoZXZ0KTtcbiAgICB9ZWxzZXtcbiAgICAgIHRoaXMuX2hhbmRsZXNbMV0udHJhY2tpbmcgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoc2VsZi5fYWxyZWFkeWNyZWF0ZWQgIT0gdHJ1ZSl7XG4gICAgICB0aGlzLnNldGxhYmVsdGV4dCgpO1xuICAgICAgc2VsZi5fYWxyZWFkeWNyZWF0ZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIC8vIFN0YXRlIG9mIGFubm90YXRpb24gd2lkZ2V0XG4gICAgdGhpcy5fYWN0aXZlID0gdGhpcy5faGFuZGxlc1swXS5hY3RpdmUgfHwgdGhpcy5faGFuZGxlc1sxXS5hY3RpdmU7XG4gICAgdGhpcy51cGRhdGUoKTtcblxuICB9XG5cblxuICBjcmVhdGUoKSB7XG4gICAgdGhpcy5jcmVhdGVNZXNoKCk7XG4gICAgdGhpcy5jcmVhdGVET00oKTtcbiAgfVxuXG4gIHVwZGF0ZSgpIHtcbiAgICB0aGlzLnVwZGF0ZUNvbG9yKCk7XG5cbiAgICAvLyBtZXNoIHN0dWZmXG4gICAgdGhpcy51cGRhdGVNZXNoQ29sb3IoKTtcbiAgICB0aGlzLnVwZGF0ZU1lc2hQb3NpdGlvbigpO1xuXG4gICAgLy8gRE9NIHN0dWZmXG4gICAgdGhpcy51cGRhdGVET01Qb3NpdGlvbigpO1xuICAgIHRoaXMudXBkYXRlRE9NQ29sb3IoKTtcbiAgfVxuXG4gIGNyZWF0ZU1lc2goKSB7XG4gICAgLy8gZ2VvbWV0cnlcbiAgICB0aGlzLl9nZW9tZXRyeSA9IG5ldyBUSFJFRS5HZW9tZXRyeSgpO1xuICAgIHRoaXMuX2dlb21ldHJ5LnZlcnRpY2VzLnB1c2godGhpcy5faGFuZGxlc1swXS53b3JsZFBvc2l0aW9uKTtcbiAgICB0aGlzLl9nZW9tZXRyeS52ZXJ0aWNlcy5wdXNoKHRoaXMuX2hhbmRsZXNbMV0ud29ybGRQb3NpdGlvbik7XG5cbiAgICAvLyBtYXRlcmlhbFxuICAgIHRoaXMuX21hdGVyaWFsID0gbmV3IFRIUkVFLkxpbmVCYXNpY01hdGVyaWFsKCk7XG4gICAgdGhpcy51cGRhdGVNZXNoQ29sb3IoKTtcblxuICAgIC8vIG1lc2hcbiAgICB0aGlzLl9tZXNobGluZSA9IG5ldyBUSFJFRS5MaW5lKHRoaXMuX2dlb21ldHJ5LCB0aGlzLl9tYXRlcmlhbCk7XG4gICAgdGhpcy5fbWVzaGxpbmUudmlzaWJsZSA9IHRydWU7XG5cbiAgICAvLyBhZGQgaXQhXG4gICAgdGhpcy5hZGQodGhpcy5fbWVzaGxpbmUpO1xuXG4gICAgLy9jcmVhdGUgY29uZSBhbmQgYWRkIGl0XG4gICAgdGhpcy5fY29uZWdlb21ldHJ5ID0gbmV3IFRIUkVFLkN5bGluZGVyR2VvbWV0cnkoIDAsIDIsIDEwICk7XG4gICAgdGhpcy5fY29uZWdlb21ldHJ5LnRyYW5zbGF0ZSggMCwgLTUsIDAgKTtcbiAgICB0aGlzLl9jb25lZ2VvbWV0cnkucm90YXRlWCggLSBNYXRoLlBJIC8gMiApO1xuICAgIHRoaXMuX2NvbmUgPSBuZXcgVEhSRUUuTWVzaCggdGhpcy5fY29uZWdlb21ldHJ5LCB0aGlzLl9tYXRlcmlhbCApO1xuICAgIHRoaXMuX2NvbmUudmlzaWJsZSA9IHRydWU7XG4gICAgdGhpcy5hZGQodGhpcy5fY29uZSk7XG5cbiAgfVxuXG4gIHVwZGF0ZU1lc2hDb2xvcigpIHtcbiAgICBpZih0aGlzLl9tYXRlcmlhbCkge1xuICAgICAgdGhpcy5fbWF0ZXJpYWwuY29sb3Iuc2V0KHRoaXMuX2NvbG9yKTtcbiAgICB9XG4gIH1cblxuICB1cGRhdGVNZXNoUG9zaXRpb24oKSB7XG4gICAgaWYodGhpcy5fZ2VvbWV0cnkpIHtcbiAgICAgIHRoaXMuX2dlb21ldHJ5LnZlcnRpY2VzTmVlZFVwZGF0ZSA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgY3JlYXRlRE9NKCkge1xuICAgIC8vIGFkZCBsaW5lIVxuICAgIHRoaXMuX2xpbmUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB0aGlzLl9saW5lLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAnd2lkZ2V0cyBoYW5kbGUgbGluZScpO1xuICAgIHRoaXMuX2xpbmUuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgIHRoaXMuX2xpbmUuc3R5bGUudHJhbnNmb3JtT3JpZ2luID0gJzAgMTAwJSc7XG4gICAgdGhpcy5fbGluZS5zdHlsZS5tYXJnaW5Ub3AgPSAnLTFweCc7XG4gICAgdGhpcy5fbGluZS5zdHlsZS5oZWlnaHQgPSAnMnB4JzsvLzJcbiAgICB0aGlzLl9saW5lLnN0eWxlLndpZHRoID0gJzNweCc7Ly8zXG4gICAgdGhpcy5fY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuX2xpbmUpO1xuXG4gICAgLy8gYWRkIGRhc2ggbGluZVxuICAgIHRoaXMuX2Rhc2hsaW5lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdGhpcy5fZGFzaGxpbmUuc2V0QXR0cmlidXRlKCdjbGFzcycsICd3aWRnZXRzIGhhbmRsZSBkYXNobGluZScpO1xuICAgIHRoaXMuX2Rhc2hsaW5lLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICB0aGlzLl9kYXNobGluZS5zdHlsZS5ib3JkZXIgPSAnbm9uZSc7XG4gICAgdGhpcy5fZGFzaGxpbmUuc3R5bGUuYm9yZGVyVG9wID0gJzIuNXB4IGRhc2hlZCAjRjlGOUY5JztcbiAgICB0aGlzLl9kYXNobGluZS5zdHlsZS50cmFuc2Zvcm1PcmlnaW4gPSAnMCAxMDAlJztcbiAgICB0aGlzLl9kYXNobGluZS5zdHlsZS5oZWlnaHQgPSAnMXB4JztcbiAgICB0aGlzLl9kYXNobGluZS5zdHlsZS53aWR0aCA9ICc1MCUnO1xuICAgIHRoaXMuX2Rhc2hsaW5lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgdGhpcy5fY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuX2Rhc2hsaW5lKTtcblxuICAgIC8vIGFkZCBsYWJlbCFcbiAgICB0aGlzLl9sYWJlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHRoaXMuX2xhYmVsLnNldEF0dHJpYnV0ZSgnaWQnLCB0aGlzLnV1aWQpO1xuICAgIHRoaXMuX2xhYmVsLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAnd2lkZ2V0cyBoYW5kbGUgbGFiZWwnKTtcbiAgICB0aGlzLl9sYWJlbC5zdHlsZS5ib3JkZXIgPSAnMnB4IHNvbGlkICNGOUY5RjknO1xuICAgIHRoaXMuX2xhYmVsLnN0eWxlLmJhY2tncm91bmRDb2xvciA9ICcjRjlGOUY5JztcbiAgICAvLyB0aGlzLl9sYWJlbC5zdHlsZS5vcGFjaXR5ID0gJzAuNSc7XG4gICAgdGhpcy5fbGFiZWwuc3R5bGUuY29sb3IgPSAnIzM1MzUzNSc7XG4gICAgdGhpcy5fbGFiZWwuc3R5bGUucGFkZGluZyA9ICc0cHgnO1xuICAgIHRoaXMuX2xhYmVsLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICB0aGlzLl9sYWJlbC5zdHlsZS50cmFuc2Zvcm1PcmlnaW4gPSAnMCAxMDAlJztcbiAgICB0aGlzLl9sYWJlbC5pbm5lckhUTUwgPSAnSGVsbG8sIHdvcmxkISc7XG4gICAgdGhpcy5fbGFiZWwuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICB0aGlzLl9jb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5fbGFiZWwpO1xuXG4gICAgdGhpcy51cGRhdGVET01Db2xvcigpO1xuICB9XG5cblxuICB1cGRhdGVET01Qb3NpdGlvbigpIHtcblxuICAgIGNvbnNvbGUubG9nKCdmdW5jdGlvbiB1cGRhdGVET01Qb3NpdGlvbicpO1xuICAgIC8vIHVwZGF0ZSBhbm5vdGF0aW9uIGxpbmVzIGFuZCB0ZXh0IVxuICAgIGxldCB4MSA9IHRoaXMuX2hhbmRsZXNbMF0uc2NyZWVuUG9zaXRpb24ueDtcbiAgICBsZXQgeTEgPSB0aGlzLl9oYW5kbGVzWzBdLnNjcmVlblBvc2l0aW9uLnk7XG4gICAgbGV0IHgyID0gdGhpcy5faGFuZGxlc1sxXS5zY3JlZW5Qb3NpdGlvbi54O1xuICAgIGxldCB5MiA9IHRoaXMuX2hhbmRsZXNbMV0uc2NyZWVuUG9zaXRpb24ueTtcblxuICAgIGxldCB4MCA9IHgxICsgKHgyIC0geDEpLzI7XG4gICAgbGV0IHkwID0geTEgKyAoeTIgLSB5MSkvMjtcblxuICAgIGxldCBsZW5ndGggPSBNYXRoLnNxcnQoKHgxLXgyKSooeDEteDIpICsgKHkxLXkyKSooeTEteTIpKTtcbiAgICBsZXQgYW5nbGUgPSBNYXRoLmF0YW4yKHkyIC0geTEsIHgyIC0geDEpICogMTgwIC8gTWF0aC5QSTsgLy9yZXN1bHQgaW4gZGVnXG5cbiAgICBsZXQgcG9zWSA9IHkxIC0gdGhpcy5fY29udGFpbmVyLm9mZnNldEhlaWdodDtcblxuICAgIC8vIHVwZGF0ZSBsaW5lXG4gICAgbGV0IHRyYW5zZm9ybSA9IGB0cmFuc2xhdGUzRCgke3gxfXB4LCR7cG9zWX1weCwgMClgO1xuICAgIHRyYW5zZm9ybSArPSBgIHJvdGF0ZSgke2FuZ2xlfWRlZylgO1xuXG4gICAgdGhpcy5fbGluZS5zdHlsZS50cmFuc2Zvcm0gPSB0cmFuc2Zvcm07XG4gICAgdGhpcy5fbGluZS5zdHlsZS53aWR0aCA9IGxlbmd0aCArICdweCc7XG5cblxuICAgIC8vIHVwZGF0ZSBsYWJlbCBwb3NpdGlvblxuICAgIHZhciBtb3VzZXggPSAwO1xuICAgIHZhciBtb3VzZXkgPSAwO1xuXG4gICAgbGV0IHBvc1kwO1xuXG4gICAgcG9zWTAgPSB5MCAtIHRoaXMuX2NvbnRhaW5lci5vZmZzZXRIZWlnaHQgLSB0aGlzLl9sYWJlbC5vZmZzZXRIZWlnaHQvMjtcbiAgICB4MCAtPSB0aGlzLl9sYWJlbC5vZmZzZXRXaWR0aC8yO1xuXG4gICAgdmFyIHg7XG4gICAgdmFyIHk7XG5cbiAgICBpZiAodGhpcy5fbGFiZWxtb3ZlZCA9PSBmYWxzZSl7IC8vaWYgdGhlIHVzZXIgaGFzbnQgbW92ZWQgdGhlIGxhYmVsLCB0aGUgcG9zaXRpb24gaXMgZGVmaW5lZCBieSB0aGUgcG9zaXRpb24gb2YgdGhlIGFycm93XG4gICAgICAgIGxldCB0cmFuc2Zvcm0yID0gYHRyYW5zbGF0ZTNEKCR7TWF0aC5yb3VuZCh4MCl9cHgsJHtNYXRoLnJvdW5kKHBvc1kwKX1weCwgMClgO1xuICAgICAgICB0aGlzLl9sYWJlbC5zdHlsZS50cmFuc2Zvcm0gPSB0cmFuc2Zvcm0yO1xuICAgICAgICB0aGlzLl9sYWJlbHBvc2l0aW9ueCA9IE1hdGgucm91bmQoeDApO1xuICAgICAgICB0aGlzLl9sYWJlbHBvc2l0aW9ueSA9IE1hdGgucm91bmQocG9zWTApO1xuICAgIH1cblxuXG4gICAgaWYgKHRoaXMuX21vdmluZ2xhYmVsKSB7IC8vaWYgdGhlIHVzZXIgaGFzIG1vdmVkIHRoZSBsYWJlbCwgdGhlIHBvc2l0aW9uIGlzIGRlZmluZWQgYnkgdGhlIG1vdXNlXG4gICAgICAgIG1vdXNleCA9IGV2ZW50LmNsaWVudFg7XG4gICAgICAgIG1vdXNleSA9ICAtKC1ldmVudC5jbGllbnRZICsgdGhpcy5fY29udGFpbmVyLm9mZnNldEhlaWdodCk7XG4gICAgICAgIHRoaXMuX2xhYmVsLnN0eWxlLnRyYW5zZm9ybSA9IGB0cmFuc2xhdGUzRCgke21vdXNleCAtIHRoaXMuX2RpZmZlcmVuY2Vtb3VzZWNlbnRlcmxhYmVseH1weCwke21vdXNleSAtIHRoaXMuX2RpZmZlcmVuY2Vtb3VzZWNlbnRlcmxhYmVseX1weCwgMClgOyBcbiAgICAgICAgLy93ZSB1c2UgZGlmZmVyZW5jZW1vdXNlY2VudGVybGFiZWwgdG8gY2hlY2sgdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiB0aGUgcG9zaXRpb24gb2YgdGhlIG1vdXNlIGluIHRoZSBsYWJlbCBhbmQgdGhlIHJlZmVyZW5jZSBwb3NpdGlvbiBvZiB0aGUgbGFiZWwgKHRvcC1sZWZ0IGNvcm5lcilcbiAgICAgICAgdGhpcy5fbGFiZWxwb3NpdGlvbnggPSBtb3VzZXggLSB0aGlzLl9kaWZmZXJlbmNlbW91c2VjZW50ZXJsYWJlbHg7XG4gICAgICAgIHRoaXMuX2xhYmVscG9zaXRpb255ID0gbW91c2V5IC0gdGhpcy5fZGlmZmVyZW5jZW1vdXNlY2VudGVybGFiZWx5O1xuICAgIH1cblxuICAgIC8vdXBkYXRlIGNvbmVcbiAgICBsZXQgdzAgPSB0aGlzLl9oYW5kbGVzWzBdLndvcmxkUG9zaXRpb247XG4gICAgbGV0IHcxID0gdGhpcy5faGFuZGxlc1sxXS53b3JsZFBvc2l0aW9uO1xuXG4gICAgLy9wb3NpdGlvbiBhbmQgcm90YXRpb24gb2YgY29uZVxuICAgIHRoaXMuX2NvbmUucG9zaXRpb24uc2V0KHcxLngsdzEueSx3MS56KTtcbiAgICB0aGlzLl9jb25lLmxvb2tBdCh3MCk7XG5cbiAgICAvLyB1cGRhdGUgZGFzaCBsaW5lXG5cbiAgICAvL2NhbGN1bGF0ZSB0aGUgcGxhY2UgaW4gdGhlIGxhYmVsOiBjZW50ZXIgb2YgdGhlIGxhYmVsXG4gICAgeDEgPSB0aGlzLl9oYW5kbGVzWzBdLnNjcmVlblBvc2l0aW9uLng7XG4gICAgeTEgPSB0aGlzLl9oYW5kbGVzWzBdLnNjcmVlblBvc2l0aW9uLnk7XG4gICAgeDIgPSB0aGlzLl9sYWJlbHBvc2l0aW9ueDtcbiAgICB5MiA9IHRoaXMuX2xhYmVscG9zaXRpb255ICsgdGhpcy5fY29udGFpbmVyLm9mZnNldEhlaWdodDsgLy9yZXZlcnQgdGhlIG9wZXJhdGlvbiBpbiAnbW91c2V5JyB0byBnZXQgdGhlIHByZXZpb3VzIGV2ZW50WVxuXG4gICAgLy9nZXQgdGhlIHNpemUgb2YgdGhlIGxhYmVsIHNvIHdlIGNhbiBwbGFjZSB0aGUgZGFzaGVkIGxpbmUgaW4gdGhlIGNlbnRlciBvZiBpdFxuICAgIHZhciBsYWJlbGhlaWdodCA9IHRoaXMuX2xhYmVsLm9mZnNldEhlaWdodDtcbiAgICB2YXIgbGFiZWx3aWR0aCA9IHRoaXMuX2xhYmVsLm9mZnNldFdpZHRoO1xuXG4gICAgdmFyIGNlbnRlcmxhYmVseCA9IDA7XG4gICAgdmFyIGNlbnRlcmxhYmVseSA9IDA7XG5cbiAgICBpZiAoaXNGaW5pdGUobGFiZWx3aWR0aCkgJiYgaXNGaW5pdGUobGFiZWxoZWlnaHQpKXsgLy9pZiB0aGUgZXh0cmFjdGlvbiBoYXMgYmVlbiBzdWNjZXNmdWxsLCB3ZSBjYWxjdWxhdGUgdGhlIGNlbnRlciBvZiB0aGUgbGFiZWwgd2l0aCB0b3RhbCBzaXplXG4gICAgICAgIGNlbnRlcmxhYmVseCA9IGxhYmVsd2lkdGgvMjtcbiAgICAgICAgY2VudGVybGFiZWx5ID0gbGFiZWxoZWlnaHQvMjtcbiAgICB9XG5cbiAgICB4MiArPSBjZW50ZXJsYWJlbHg7XG4gICAgeTIgKz0gY2VudGVybGFiZWx5O1xuXG4gICAgLy9jYWxjdWxhdGUgdGhlIHBsYWNlIGluIHRoZSBhcnJvdzogY2xvc2VzdCBwYXJ0IG9mIHRoZSBsaW5lIHRvIHBsYWNlIHRoZSBkYXNoZWQgbGluZVxuICAgIHZhciB4MV90YWlsID0gdGhpcy5faGFuZGxlc1swXS5zY3JlZW5Qb3NpdGlvbi54OyAvL2ZpcnN0IHBvc2l0aW9uOiB0YWlsIG9mIGFycm93XG4gICAgdmFyIHkxX3RhaWwgPSB0aGlzLl9oYW5kbGVzWzBdLnNjcmVlblBvc2l0aW9uLnk7XG4gICAgdmFyIHgxX2JvZHkgPSAodGhpcy5faGFuZGxlc1swXS5zY3JlZW5Qb3NpdGlvbi54ICsgdGhpcy5faGFuZGxlc1sxXS5zY3JlZW5Qb3NpdGlvbi54KS8yOyAvL3NlY29uZCBwb3NpdGlvbjogY2VudGVyIG9mIGFycm93XG4gICAgdmFyIHkxX2JvZHkgPSAodGhpcy5faGFuZGxlc1swXS5zY3JlZW5Qb3NpdGlvbi55ICsgdGhpcy5faGFuZGxlc1sxXS5zY3JlZW5Qb3NpdGlvbi55KS8yO1xuICAgIHZhciB4MV9ub3NlID0gdGhpcy5faGFuZGxlc1sxXS5zY3JlZW5Qb3NpdGlvbi54OyAvL3RoaXJkIHBvc2l0aW9uOiBwZWFrIG9mIGFycm93XG4gICAgdmFyIHkxX25vc2UgPSB0aGlzLl9oYW5kbGVzWzFdLnNjcmVlblBvc2l0aW9uLnk7XG5cbiAgICAvL2NhbGN1bGF0ZSBhbGwgdGhlIGxlbmd0aHMgdG8gdGhlIGxhYmVsLCBzbyB3ZSBjYW4gY2hvb3NlIHRoZSBtaW5cbiAgICB2YXIgbGVuZ3RodGFpbGxhYmVsID0gTWF0aC5zcXJ0KCh4MV90YWlsLXgyKSooeDFfdGFpbC14MikgKyAoeTFfdGFpbC15MikqKHkxX3RhaWwteTIpKTtcbiAgICB2YXIgbGVuZ3RoYm9keWxhYmVsID0gTWF0aC5zcXJ0KCh4MV9ib2R5LXgyKSooeDFfYm9keS14MikgKyAoeTFfYm9keS15MikqKHkxX2JvZHkteTIpKTtcbiAgICB2YXIgbGVuZ3Robm9zZWxhYmVsID0gTWF0aC5zcXJ0KCh4MV9ub3NlLXgyKSooeDFfbm9zZS14MikgKyAoeTFfbm9zZS15MikqKHkxX25vc2UteTIpKTtcblxuICAgIHZhciBsZW5ndGhzID0gW2xlbmd0aHRhaWxsYWJlbCwgbGVuZ3RoYm9keWxhYmVsLCBsZW5ndGhub3NlbGFiZWxdO1xuICAgIHZhciBtaW5sZW5ndGggPSBNYXRoLm1pbihsZW5ndGh0YWlsbGFiZWwsIGxlbmd0aGJvZHlsYWJlbCwgbGVuZ3Robm9zZWxhYmVsKTtcbiAgICB2YXIgbWlubGVuZ3RoaW5kZXggPSBsZW5ndGhzLmluZGV4T2YobWlubGVuZ3RoKTtcblxuICAgIGlmIChtaW5sZW5ndGhpbmRleCA9PSAwKXtcbiAgICAgICAgeDEgPSB4MV90YWlsO1xuICAgICAgICB5MSA9IHkxX3RhaWw7XG4gICAgfVxuICAgIGlmIChtaW5sZW5ndGhpbmRleCA9PSAxKXtcbiAgICAgICAgeDEgPSB4MV9ib2R5O1xuICAgICAgICB5MSA9IHkxX2JvZHk7XG4gICAgfVxuICAgIGlmIChtaW5sZW5ndGhpbmRleCA9PSAyKXtcbiAgICAgICAgeDEgPSB4MV9ub3NlO1xuICAgICAgICB5MSA9IHkxX25vc2U7XG4gICAgfVxuXG4gICAgLy8gT25jZSB3ZSBmb3VuZCB0aGUgY2xvc2VzdCBwb2ludCB0byB0aGUgbGFiZWwsIHdlIGNyZWF0ZSB0aGUgZGFzaGVkIGxpbmUgZnJvbSB0aGF0IHBvaW50XG4gICAgbGV0IGxlbmd0aGRhc2hsaW5lID0gTWF0aC5zcXJ0KCh4MS14MikqKHgxLXgyKSArICh5MS15MikqKHkxLXkyKSk7XG4gICAgbGV0IGFuZ2xlZGFzaGxpbmUgPSBNYXRoLmF0YW4yKHkyIC0geTEsIHgyIC0geDEpICogMTgwIC8gTWF0aC5QSTsgLy9yZXN1bHQgaW4gZGVnXG5cbiAgICBsZXQgcG9zWWRhc2hsaW5lID0geTEgLSB0aGlzLl9jb250YWluZXIub2Zmc2V0SGVpZ2h0O1xuXG4gICAgLy8gdXBkYXRlIGRhc2hlZCBsaW5lXG4gICAgbGV0IHRyYW5zZm9ybWRhc2hsaW5lID0gYHRyYW5zbGF0ZTNEKCR7eDF9cHgsJHtwb3NZZGFzaGxpbmV9cHgsIDApYDtcbiAgICB0cmFuc2Zvcm1kYXNobGluZSArPSBgIHJvdGF0ZSgke2FuZ2xlZGFzaGxpbmV9ZGVnKWA7XG5cbiAgICB0aGlzLl9kYXNobGluZS5zdHlsZS50cmFuc2Zvcm0gPSB0cmFuc2Zvcm1kYXNobGluZTtcbiAgICB0aGlzLl9kYXNobGluZS5zdHlsZS53aWR0aCA9IGxlbmd0aGRhc2hsaW5lICsgJ3B4JztcbiAgfVxuXG4gIHVwZGF0ZURPTUNvbG9yKCkge1xuICAgIHRoaXMuX2xpbmUuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gYCR7dGhpcy5fY29sb3J9YDtcbiAgICB0aGlzLl9kYXNobGluZS5zdHlsZS5ib3JkZXJUb3AgPSAnMi41cHggZGFzaGVkICcgKyBgJHt0aGlzLl9jb2xvcn1gO1xuICAgIHRoaXMuX2xhYmVsLnN0eWxlLmJvcmRlckNvbG9yID0gYCR7dGhpcy5fY29sb3J9YDtcbiAgfVxuXG4gIGdldCB3b3JsZFBvc2l0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl93b3JsZFBvc2l0aW9uO1xuICB9XG5cbiAgc2V0IHdvcmxkUG9zaXRpb24od29ybGRQb3NpdGlvbikge1xuICAgIHRoaXMuX3dvcmxkUG9zaXRpb24gPSB3b3JsZFBvc2l0aW9uO1xuICAgIHRoaXMuX2hhbmRsZXNbMF0ud29ybGRQb3NpdGlvbiA9IHRoaXMuX3dvcmxkUG9zaXRpb247XG4gICAgdGhpcy5faGFuZGxlc1sxXS53b3JsZFBvc2l0aW9uID0gdGhpcy5fd29ybGRQb3NpdGlvbjtcblxuICAgIHRoaXMudXBkYXRlKCk7XG4gIH1cblxufVxuIiwiLyoqXG4gKlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBXaWRnZXRzQmFzZSBleHRlbmRzIFRIUkVFLk9iamVjdDNEIHtcblxuICBjb25zdHJ1Y3Rvcihjb250YWluZXIpIHtcbiAgICAvLyBpbml0IFRIUkVFIE9iamVjdCAzRFxuICAgIHN1cGVyKCk7XG5cbiAgICAvLyBpcyB3aWRnZXQgZW5hYmxlZD9cbiAgICB0aGlzLl9lbmFibGVkID0gdHJ1ZTtcblxuICAgIC8vIFNUQVRFLCBFTlVNIG1pZ2h0IGJlIGJldHRlclxuICAgIHRoaXMuX3NlbGVjdGVkID0gZmFsc2U7XG4gICAgdGhpcy5faG92ZXJlZCA9IGZhbHNlO1xuICAgIHRoaXMuX2FjdGl2ZSA9IGZhbHNlO1xuICAgIC8vIHRob3MuX3N0YXRlID0gJ1NFTEVDVEVEJztcblxuICAgIHRoaXMuX2NvbG9ycyA9IHtcbiAgICAgIGRlZmF1bHQ6ICcjMDBCMEZGJyxcbiAgICAgIGFjdGl2ZTogJyNGRkVCM0InLFxuICAgICAgaG92ZXI6ICcjRjUwMDU3JyxcbiAgICAgIHNlbGVjdDogJyM3NkZGMDMnLFxuICAgIH07XG4gICAgdGhpcy5fY29sb3IgPSB0aGlzLl9jb2xvcnMuZGVmYXVsdDtcblxuICAgIHRoaXMuX2RyYWdnZWQgPSBmYWxzZTtcbiAgICAvLyBjYW4gbm90IGNhbGwgaXQgdmlzaWJsZSBiZWNhdXNlIGl0IGNvbmZsaWN0cyB3aXRoIFRIUkVFLk9iamVjdDNEXG4gICAgdGhpcy5fZGlzcGxheWVkID0gdHJ1ZTtcblxuICAgIHRoaXMuX2NvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgfVxuXG4gIGluaXRPZmZzZXRzKCkge1xuICAgIGNvbnN0IGJveCA9IHRoaXMuX2NvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgIGNvbnN0IGJvZHkgPSBkb2N1bWVudC5ib2R5O1xuICAgIGNvbnN0IGRvY0VsID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuXG4gICAgY29uc3Qgc2Nyb2xsVG9wID0gd2luZG93LnBhZ2VZT2Zmc2V0IHx8IGRvY0VsLnNjcm9sbFRvcCB8fCBib2R5LnNjcm9sbFRvcDtcbiAgICBjb25zdCBzY3JvbGxMZWZ0ID1cbiAgICAgIHdpbmRvdy5wYWdlWE9mZnNldCB8fCBkb2NFbC5zY3JvbGxMZWZ0IHx8IGJvZHkuc2Nyb2xsTGVmdDtcblxuICAgIGNvbnN0IGNsaWVudFRvcCA9IGRvY0VsLmNsaWVudFRvcCB8fCBib2R5LmNsaWVudFRvcCB8fCAwO1xuICAgIGNvbnN0IGNsaWVudExlZnQgPSBkb2NFbC5jbGllbnRMZWZ0IHx8IGJvZHkuY2xpZW50TGVmdCB8fCAwO1xuXG4gICAgY29uc3QgdG9wID0gYm94LnRvcCArIHNjcm9sbFRvcCAtIGNsaWVudFRvcDtcbiAgICBjb25zdCBsZWZ0ID0gYm94LmxlZnQgKyBzY3JvbGxMZWZ0IC0gY2xpZW50TGVmdDtcblxuICAgIHRoaXMuX29mZnNldHMgPSB7XG4gICAgICB0b3A6IE1hdGgucm91bmQodG9wKSxcbiAgICAgIGxlZnQ6IE1hdGgucm91bmQobGVmdCksXG4gICAgfTtcbiAgfVxuXG4gIG9mZnNldENoYW5nZWQoKSB7XG4gICAgdGhpcy5pbml0T2Zmc2V0cygpO1xuICAgIHRoaXMudXBkYXRlKCk7XG4gIH1cblxuICBnZXRNb3VzZU9mZnNldHMoZXZlbnQsIGNvbnRhaW5lcikge1xuICAgIHJldHVybiB7XG4gICAgICB4OiAoZXZlbnQuY2xpZW50WCAtIHRoaXMuX29mZnNldHMubGVmdCkgLyBjb250YWluZXIub2Zmc2V0V2lkdGggKiAyIC0gMSxcbiAgICAgIHk6IC0oKGV2ZW50LmNsaWVudFkgLSB0aGlzLl9vZmZzZXRzLnRvcCkgLyBjb250YWluZXIub2Zmc2V0SGVpZ2h0KVxuICAgICAgICAqIDIgKyAxLFxuICAgICAgc2NyZWVuWDogZXZlbnQuY2xpZW50WCAtIHRoaXMuX29mZnNldHMubGVmdCxcbiAgICAgIHNjcmVlblk6IGV2ZW50LmNsaWVudFkgLSB0aGlzLl9vZmZzZXRzLnRvcCxcbiAgICB9O1xuICB9XG5cbiAgdXBkYXRlKCkge1xuICAgIC8vIHRvIGJlIG92ZXJsb2FkZWRcbiAgICB3aW5kb3cuY29uc29sZS5sb2coJ3VwZGF0ZSgpIHNob3VsZCBiZSBvdmVybG9hZGVkIScpO1xuICB9XG5cbiAgZnJlZSgpIHtcbiAgICB0aGlzLl9jb250YWluZXIgPSBudWxsO1xuICB9XG5cbiAgdXBkYXRlQ29sb3IoKSB7XG4gICAgaWYgKHRoaXMuX2FjdGl2ZSkge1xuICAgICAgdGhpcy5fY29sb3IgPSB0aGlzLl9jb2xvcnMuYWN0aXZlO1xuICAgIH0gZWxzZSBpZiAodGhpcy5faG92ZXJlZCkge1xuICAgICAgdGhpcy5fY29sb3IgPSB0aGlzLl9jb2xvcnMuaG92ZXI7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9zZWxlY3RlZCkge1xuICAgICAgdGhpcy5fY29sb3IgPSB0aGlzLl9jb2xvcnMuc2VsZWN0O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9jb2xvciA9IHRoaXMuX2NvbG9ycy5kZWZhdWx0O1xuICAgIH1cbiAgfVxuXG4gIGdldCBlbmFibGVkKCkge1xuICAgIHJldHVybiB0aGlzLl9lbmFibGVkO1xuICB9XG5cbiAgc2V0IGVuYWJsZWQoZW5hYmxlZCkge1xuICAgIHRoaXMuX2VuYWJsZWQgPSBlbmFibGVkO1xuICAgIHRoaXMudXBkYXRlKCk7XG4gIH1cblxuICBnZXQgc2VsZWN0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NlbGVjdGVkO1xuICB9XG5cbiAgc2V0IHNlbGVjdGVkKHNlbGVjdGVkKSB7XG4gICAgdGhpcy5fc2VsZWN0ZWQgPSBzZWxlY3RlZDtcbiAgICB0aGlzLnVwZGF0ZSgpO1xuICB9XG5cbiAgZ2V0IGhvdmVyZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2hvdmVyZWQ7XG4gIH1cblxuICBzZXQgaG92ZXJlZChob3ZlcmVkKSB7XG4gICAgdGhpcy5faG92ZXJlZCA9IGhvdmVyZWQ7XG4gICAgdGhpcy51cGRhdGUoKTtcbiAgfVxuXG4gIGdldCBkcmFnZ2VkKCkge1xuICAgIHJldHVybiB0aGlzLl9kcmFnZ2VkO1xuICB9XG5cbiAgc2V0IGRyYWdnZWQoZHJhZ2dlZCkge1xuICAgIHRoaXMuX2RyYWdnZWQgPSBkcmFnZ2VkO1xuICAgIHRoaXMudXBkYXRlKCk7XG4gIH1cblxuICBnZXQgZGlzcGxheWVkKCkge1xuICAgIHJldHVybiB0aGlzLl9kaXNwbGF5ZWQ7XG4gIH1cblxuICBzZXQgZGlzcGxheWVkKGRpc3BsYXllZCkge1xuICAgIHRoaXMuX2Rpc3BsYXllZCA9IGRpc3BsYXllZDtcbiAgICB0aGlzLnVwZGF0ZSgpO1xuICB9XG5cbiAgZ2V0IGFjdGl2ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fYWN0aXZlO1xuICB9XG5cbiAgc2V0IGFjdGl2ZShhY3RpdmUpIHtcbiAgICB0aGlzLl9hY3RpdmUgPSBhY3RpdmU7XG4gICAgdGhpcy51cGRhdGUoKTtcbiAgfVxuXG4gIGdldCBjb2xvcigpIHtcbiAgICByZXR1cm4gdGhpcy5fY29sb3I7XG4gIH1cblxuICBzZXQgY29sb3IoY29sb3IpIHtcbiAgICB0aGlzLl9jb2xvciA9IGNvbG9yO1xuICAgIHRoaXMudXBkYXRlKCk7XG4gIH1cblxufVxuIiwiaW1wb3J0IFdpZGdldHNCYXNlIGZyb20gJy4uL3dpZGdldHMvd2lkZ2V0cy5iYXNlJztcbmltcG9ydCBXaWRnZXRzSGFuZGxlIGZyb20gJy4uL3dpZGdldHMvd2lkZ2V0cy5oYW5kbGUnO1xuXG4vKipcbiAqIEBtb2R1bGUgd2lkZ2V0cy9oYW5kbGVcbiAqXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgV2lkZ2V0c0JpUnVsZXIgZXh0ZW5kcyBXaWRnZXRzQmFzZSB7XG5cbiAgICBjb25zdHJ1Y3Rvcih0YXJnZXRNZXNoLCBjb250cm9scywgY2FtZXJhLCBjb250YWluZXIpIHtcbiAgICAgICAgc3VwZXIoKTtcblxuICAgICAgICB0aGlzLl90YXJnZXRNZXNoID0gdGFyZ2V0TWVzaDtcbiAgICAgICAgdGhpcy5fY29udHJvbHMgPSBjb250cm9scztcbiAgICAgICAgdGhpcy5fY2FtZXJhID0gY2FtZXJhO1xuICAgICAgICB0aGlzLl9jb250YWluZXIgPSBjb250YWluZXI7XG5cbiAgICAgICAgdGhpcy5fYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5faW5pdE9ydGhvID0gZmFsc2U7XG5cbiAgICAgICAgdGhpcy5fd29ybGRQb3NpdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgICAgIGlmKHRoaXMuX3RhcmdldE1lc2ggIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX3dvcmxkUG9zaXRpb24gPSB0aGlzLl90YXJnZXRNZXNoLnBvc2l0aW9uO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbWVzaCBzdHVmZlxuICAgICAgICB0aGlzLl9tYXRlcmlhbCA9IG51bGw7XG4gICAgICAgIHRoaXMuX2dlb21ldHJ5ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fbWVzaCA9IG51bGw7XG5cbiAgICAgICAgLy8gZG9tIHN0dWZmXG4gICAgICAgIHRoaXMuX2xpbmUgPSBudWxsO1xuICAgICAgICB0aGlzLl9kaXN0YW5jZSA9IG51bGw7XG5cbiAgICAgICAgLy8gYWRkIGhhbmRsZXNcbiAgICAgICAgdGhpcy5faGFuZGxlcyA9IFtdO1xuXG4gICAgICAgIC8vIGZpcnN0IGhhbmRsZVxuICAgICAgICBsZXQgZmlyc3RIYW5kbGUgPSBuZXcgV2lkZ2V0c0hhbmRsZSh0aGlzLl90YXJnZXRNZXNoLCB0aGlzLl9jb250cm9scywgdGhpcy5fY2FtZXJhLCB0aGlzLl9jb250YWluZXIpO1xuICAgICAgICBmaXJzdEhhbmRsZS53b3JsZFBvc2l0aW9uID0gdGhpcy5fd29ybGRQb3NpdGlvbjtcbiAgICAgICAgZmlyc3RIYW5kbGUuaG92ZXJlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuYWRkKGZpcnN0SGFuZGxlKTtcblxuICAgICAgICB0aGlzLl9oYW5kbGVzLnB1c2goZmlyc3RIYW5kbGUpO1xuXG4gICAgICAgIGxldCBzZWNvbmRIYW5kbGUgPSBuZXcgV2lkZ2V0c0hhbmRsZSh0aGlzLl90YXJnZXRNZXNoLCB0aGlzLl9jb250cm9scywgdGhpcy5fY2FtZXJhLCB0aGlzLl9jb250YWluZXIpO1xuICAgICAgICBzZWNvbmRIYW5kbGUud29ybGRQb3NpdGlvbiA9IHRoaXMuX3dvcmxkUG9zaXRpb247XG4gICAgICAgIHNlY29uZEhhbmRsZS5ob3ZlcmVkID0gdHJ1ZTtcbiAgICAgICAgLy8gYWN0aXZlIGFuZCB0cmFja2luZyBtaWdodCBiZSByZWR1bmRhbnRcbiAgICAgICAgc2Vjb25kSGFuZGxlLmFjdGl2ZSA9IHRydWU7XG4gICAgICAgIHNlY29uZEhhbmRsZS50cmFja2luZyA9IHRydWU7XG4gICAgICAgIHRoaXMuYWRkKHNlY29uZEhhbmRsZSk7XG5cbiAgICAgICAgdGhpcy5faGFuZGxlcy5wdXNoKHNlY29uZEhhbmRsZSk7XG5cbiAgICAgICAgLy8gdGhpcmQgaGFuZGxlXG4gICAgICAgIGxldCB0aGlyZEhhbmRsZSA9IG5ldyBXaWRnZXRzSGFuZGxlKHRoaXMuX3RhcmdldE1lc2gsIHRoaXMuX2NvbnRyb2xzLCB0aGlzLl9jYW1lcmEsIHRoaXMuX2NvbnRhaW5lcik7XG4gICAgICAgIHRoaXJkSGFuZGxlLndvcmxkUG9zaXRpb24gPSB0aGlzLl93b3JsZFBvc2l0aW9uO1xuICAgICAgICB0aGlyZEhhbmRsZS5ob3ZlcmVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5hZGQodGhpcmRIYW5kbGUpO1xuXG4gICAgICAgIHRoaXMuX2hhbmRsZXMucHVzaCh0aGlyZEhhbmRsZSk7XG5cbiAgICAgICAgLy8gZm91cnRoIGhhbmRsZVxuICAgICAgICBsZXQgZm91cnRoSGFuZGxlID0gbmV3IFdpZGdldHNIYW5kbGUodGhpcy5fdGFyZ2V0TWVzaCwgdGhpcy5fY29udHJvbHMsIHRoaXMuX2NhbWVyYSwgdGhpcy5fY29udGFpbmVyKTtcbiAgICAgICAgZm91cnRoSGFuZGxlLndvcmxkUG9zaXRpb24gPSB0aGlzLl93b3JsZFBvc2l0aW9uO1xuICAgICAgICBmb3VydGhIYW5kbGUuaG92ZXJlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuYWRkKGZvdXJ0aEhhbmRsZSk7XG5cbiAgICAgICAgdGhpcy5faGFuZGxlcy5wdXNoKGZvdXJ0aEhhbmRsZSk7XG5cbiAgICAgICAgLy8gQ3JlYXRlIHJ1bGVyXG4gICAgICAgIHRoaXMuY3JlYXRlKCk7XG5cbiAgICAgICAgdGhpcy5vbk1vdmUgPSB0aGlzLm9uTW92ZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXJzKCk7XG5cbiAgICAgICAgdGhpcy5fb3JpZW50YXRpb24gPSBudWxsO1xuICAgICAgICB0aGlzLl9zbGljZSA9IG51bGw7XG4gICAgfVxuXG4gICAgYWRkRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgICAgIHRoaXMuX2NvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXdoZWVsJywgdGhpcy5vbk1vdmUpO1xuICAgICAgICB0aGlzLl9jb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcignRE9NTW91c2VTY3JvbGwnLCB0aGlzLm9uTW92ZSk7XG4gICAgfVxuXG4gICAgb25Nb3ZlKGV2dCkge1xuICAgICAgICB0aGlzLl9kcmFnZ2VkID0gdHJ1ZTtcblxuICAgICAgICB0aGlzLl9oYW5kbGVzWzBdLm9uTW92ZShldnQpO1xuICAgICAgICB0aGlzLl9oYW5kbGVzWzFdLm9uTW92ZShldnQpO1xuICAgICAgICB0aGlzLl9oYW5kbGVzWzJdLm9uTW92ZShldnQpO1xuICAgICAgICB0aGlzLl9oYW5kbGVzWzNdLm9uTW92ZShldnQpO1xuXG4gICAgICAgIHRoaXMuX2hvdmVyZWQgPSB0aGlzLl9oYW5kbGVzWzBdLmhvdmVyZWQgfHwgdGhpcy5faGFuZGxlc1sxXS5ob3ZlcmVkIHx8IHRoaXMuX2hhbmRsZXNbMl0uaG92ZXJlZCB8fCB0aGlzLl9oYW5kbGVzWzNdLmhvdmVyZWQ7XG5cbiAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICB9XG5cbiAgICBvblN0YXJ0KGV2dCkge1xuICAgICAgICB0aGlzLl9kcmFnZ2VkID0gZmFsc2U7XG5cbiAgICAgICAgdGhpcy5faGFuZGxlc1swXS5vblN0YXJ0KGV2dCk7XG4gICAgICAgIHRoaXMuX2hhbmRsZXNbMV0ub25TdGFydChldnQpO1xuICAgICAgICB0aGlzLl9oYW5kbGVzWzJdLm9uU3RhcnQoZXZ0KTtcbiAgICAgICAgdGhpcy5faGFuZGxlc1szXS5vblN0YXJ0KGV2dCk7XG5cbiAgICAgICAgdGhpcy5fYWN0aXZlID0gdGhpcy5faGFuZGxlc1swXS5hY3RpdmUgfHwgdGhpcy5faGFuZGxlc1sxXS5hY3RpdmUgfHwgdGhpcy5faGFuZGxlc1syXS5hY3RpdmUgfHwgdGhpcy5faGFuZGxlc1szXS5hY3RpdmU7XG4gICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgfVxuXG4gICAgb25FbmQoZXZ0KSB7XG4gICAgICAgIC8vIEZpcnN0IEhhbmRsZVxuICAgICAgICB0aGlzLl9oYW5kbGVzWzBdLm9uRW5kKGV2dCk7XG4gICAgICAgIHRoaXMuX2hhbmRsZXNbMl0ub25FbmQoZXZ0KTtcbiAgICAgICAgdGhpcy5faGFuZGxlc1szXS5vbkVuZChldnQpO1xuXG4gICAgICAgIHdpbmRvdy5jb25zb2xlLmxvZyh0aGlzKTtcblxuICAgICAgICAvLyBTZWNvbmQgSGFuZGxlXG4gICAgICAgIGlmKHRoaXMuX2RyYWdnZWQgfHwgIXRoaXMuX2hhbmRsZXNbMV0udHJhY2tpbmcpIHtcbiAgICAgICAgICAgIHRoaXMuX2hhbmRsZXNbMV0udHJhY2tpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX2hhbmRsZXNbMV0ub25FbmQoZXZ0KTtcbiAgICAgICAgfSBlbHNle1xuICAgICAgICAgICAgdGhpcy5faGFuZGxlc1sxXS50cmFja2luZyA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU3RhdGUgb2YgcnVsZXIgd2lkZ2V0XG4gICAgICAgIHRoaXMuX2FjdGl2ZSA9IHRoaXMuX2hhbmRsZXNbMF0uYWN0aXZlIHx8IHRoaXMuX2hhbmRsZXNbMV0uYWN0aXZlIHx8IHRoaXMuX2hhbmRsZXNbMl0uYWN0aXZlIHx8IHRoaXMuX2hhbmRsZXNbM10uYWN0aXZlO1xuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgIH1cblxuICAgIGNyZWF0ZSgpIHtcbiAgICAgICAgdGhpcy5jcmVhdGVNZXNoKCk7XG4gICAgICAgIHRoaXMuY3JlYXRlRE9NKCk7XG4gICAgfVxuXG4gICAgaGlkZURPTSgpIHtcbiAgICAgICAgdGhpcy5fbGluZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICB0aGlzLl9kaXN0YW5jZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICB0aGlzLl9saW5lMi5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICB0aGlzLl9kaXN0YW5jZTIuc3R5bGUuZGlzcGxheSA9ICdub25lJztcblxuICAgICAgICBmb3IgKGxldCBpbmRleCBpbiB0aGlzLl9oYW5kbGVzKSB7XG4gICAgICAgICAgICB0aGlzLl9oYW5kbGVzW2luZGV4XS5oaWRlRE9NKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9kYXNobGluZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgIH1cblxuICAgIHNob3dET00oKSB7XG4gICAgICAgIHRoaXMuX2xpbmUuc3R5bGUuZGlzcGxheSA9ICcnO1xuICAgICAgICB0aGlzLl9kaXN0YW5jZS5zdHlsZS5kaXNwbGF5ID0gJyc7XG4gICAgICAgIHRoaXMuX2xpbmUyLnN0eWxlLmRpc3BsYXkgPSAnJztcbiAgICAgICAgdGhpcy5fZGlzdGFuY2UyLnN0eWxlLmRpc3BsYXkgPSAnJztcblxuICAgICAgICBmb3IgKGxldCBpbmRleCBpbiB0aGlzLl9oYW5kbGVzKSB7XG4gICAgICAgICAgICB0aGlzLl9oYW5kbGVzW2luZGV4XS5zaG93RE9NKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9kYXNobGluZS5zdHlsZS5kaXNwbGF5ID0gJyc7XG4gICAgfVxuXG4gICAgaGlkZU1lc2goKXtcbiAgICAgICAgdGhpcy5fbWVzaC52aXNpYmxlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX21lc2gyLnZpc2libGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5faGFuZGxlc1swXS52aXNpYmxlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2hhbmRsZXNbMV0udmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9oYW5kbGVzWzJdLnZpc2libGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5faGFuZGxlc1szXS52aXNpYmxlID0gZmFsc2U7XG4gICAgfVxuXG4gICAgc2hvd01lc2goKSB7XG4gICAgICAgIHRoaXMuX21lc2gudmlzaWJsZSA9IHRydWU7XG4gICAgICAgIHRoaXMuX21lc2gyLnZpc2libGUgPSB0cnVlO1xuICAgICAgICB0aGlzLl9oYW5kbGVzWzBdLnZpc2libGUgPSB0cnVlO1xuICAgICAgICB0aGlzLl9oYW5kbGVzWzFdLnZpc2libGUgPSB0cnVlO1xuICAgICAgICB0aGlzLl9oYW5kbGVzWzJdLnZpc2libGUgPSB0cnVlO1xuICAgICAgICB0aGlzLl9oYW5kbGVzWzNdLnZpc2libGUgPSB0cnVlO1xuICAgIH1cblxuICAgIHNob3coKSB7XG4gICAgICAgIHRoaXMuc2hvd0RPTSgpO1xuICAgICAgICB0aGlzLnNob3dNZXNoKCk7XG4gICAgfVxuXG4gICAgaGlkZSgpIHtcbiAgICAgICAgdGhpcy5oaWRlRE9NKCk7XG4gICAgICAgIHRoaXMuaGlkZU1lc2goKTtcbiAgICB9XG5cbiAgICB1cGRhdGUoKSB7XG4gICAgICAgIHRoaXMudXBkYXRlQ29sb3IoKTtcblxuICAgICAgICAvLyBtZXNoIHN0dWZmXG4gICAgICAgIHRoaXMudXBkYXRlTWVzaENvbG9yKCk7XG4gICAgICAgIHRoaXMudXBkYXRlTWVzaFBvc2l0aW9uKCk7XG5cbiAgICAgICAgLy8gRE9NIHN0dWZmXG4gICAgICAgIHRoaXMudXBkYXRlRE9NUG9zaXRpb24oKTtcbiAgICAgICAgdGhpcy51cGRhdGVET01Db2xvcigpO1xuICAgIH1cblxuICAgIGNyZWF0ZU1lc2goKSB7XG4gICAgICAgIC8vIGdlb21ldHJ5XG4gICAgICAgIHRoaXMuX2dlb21ldHJ5ID0gbmV3IFRIUkVFLkdlb21ldHJ5KCk7XG4gICAgICAgIHRoaXMuX2dlb21ldHJ5LnZlcnRpY2VzLnB1c2godGhpcy5faGFuZGxlc1swXS53b3JsZFBvc2l0aW9uKTtcbiAgICAgICAgdGhpcy5fZ2VvbWV0cnkudmVydGljZXMucHVzaCh0aGlzLl9oYW5kbGVzWzFdLndvcmxkUG9zaXRpb24pO1xuXG4gICAgICAgIC8vIGdlb21ldHJ5XG4gICAgICAgIHRoaXMuX2dlb21ldHJ5MiA9IG5ldyBUSFJFRS5HZW9tZXRyeSgpO1xuICAgICAgICB0aGlzLl9nZW9tZXRyeTIudmVydGljZXMucHVzaCh0aGlzLl9oYW5kbGVzWzJdLndvcmxkUG9zaXRpb24pO1xuICAgICAgICB0aGlzLl9nZW9tZXRyeTIudmVydGljZXMucHVzaCh0aGlzLl9oYW5kbGVzWzNdLndvcmxkUG9zaXRpb24pO1xuXG4gICAgICAgIC8vIG1hdGVyaWFsXG4gICAgICAgIHRoaXMuX21hdGVyaWFsID0gbmV3IFRIUkVFLkxpbmVCYXNpY01hdGVyaWFsKCk7XG4gICAgICAgIHRoaXMuX21hdGVyaWFsMiA9IG5ldyBUSFJFRS5MaW5lQmFzaWNNYXRlcmlhbCgpO1xuICAgICAgICB0aGlzLnVwZGF0ZU1lc2hDb2xvcigpO1xuXG4gICAgICAgIC8vIG1lc2hcbiAgICAgICAgdGhpcy5fbWVzaCA9IG5ldyBUSFJFRS5MaW5lKHRoaXMuX2dlb21ldHJ5LCB0aGlzLl9tYXRlcmlhbCk7XG4gICAgICAgIHRoaXMuX21lc2gudmlzaWJsZSA9IHRydWU7XG4gICAgICAgIHRoaXMuX21lc2gyID0gbmV3IFRIUkVFLkxpbmUodGhpcy5fZ2VvbWV0cnkyLCB0aGlzLl9tYXRlcmlhbDIpO1xuICAgICAgICB0aGlzLl9tZXNoMi52aXNpYmxlID0gdHJ1ZTtcblxuICAgICAgICAvLyBhZGQgaXQhXG4gICAgICAgIHRoaXMuYWRkKHRoaXMuX21lc2gpO1xuICAgICAgICB0aGlzLmFkZCh0aGlzLl9tZXNoMik7XG4gICAgfVxuXG4gICAgdXBkYXRlTWVzaENvbG9yKCkge1xuICAgICAgICBpZih0aGlzLl9tYXRlcmlhbCkge1xuICAgICAgICAgICAgdGhpcy5fbWF0ZXJpYWwuY29sb3Iuc2V0KHRoaXMuX2NvbG9yKTtcbiAgICAgICAgfVxuICAgICAgICBpZih0aGlzLl9tYXRlcmlhbDIpIHtcbiAgICAgICAgICAgIHRoaXMuX21hdGVyaWFsMi5jb2xvci5zZXQodGhpcy5fY29sb3IpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdXBkYXRlTWVzaFBvc2l0aW9uKCkge1xuICAgICAgICBpZih0aGlzLl9nZW9tZXRyeSkge1xuICAgICAgICAgICAgdGhpcy5fZ2VvbWV0cnkudmVydGljZXNOZWVkVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZih0aGlzLl9nZW9tZXRyeTIpIHtcbiAgICAgICAgICAgIHRoaXMuX2dlb21ldHJ5Mi52ZXJ0aWNlc05lZWRVcGRhdGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY3JlYXRlRE9NKCkge1xuICAgICAgICAvLyBhZGQgbGluZSFcbiAgICAgICAgdGhpcy5fbGluZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLl9saW5lLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAnd2lkZ2V0cyBoYW5kbGUgbGluZScpO1xuICAgICAgICB0aGlzLl9saW5lLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgICAgdGhpcy5fbGluZS5zdHlsZS50cmFuc2Zvcm1PcmlnaW4gPSAnMCAxMDAlJztcbiAgICAgICAgdGhpcy5fbGluZS5zdHlsZS5tYXJnaW5Ub3AgPSAnLTFweCc7XG4gICAgICAgIHRoaXMuX2xpbmUuc3R5bGUuaGVpZ2h0ID0gJzJweCc7XG4gICAgICAgIHRoaXMuX2xpbmUuc3R5bGUud2lkdGggPSAnM3B4JztcbiAgICAgICAgdGhpcy5fY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuX2xpbmUpO1xuXG4gICAgICAgIC8vIGFkZCBkaXN0YW5jZSFcbiAgICAgICAgdGhpcy5fZGlzdGFuY2UgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy5fZGlzdGFuY2Uuc2V0QXR0cmlidXRlKCdjbGFzcycsICd3aWRnZXRzIGhhbmRsZSBkaXN0YW5jZScpO1xuICAgICAgICB0aGlzLl9kaXN0YW5jZS5zdHlsZS5ib3JkZXIgPSAnMnB4IHNvbGlkJztcbiAgICAgICAgdGhpcy5fZGlzdGFuY2Uuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gJyNGOUY5RjknO1xuICAgICAgICAvLyB0aGlzLl9kaXN0YW5jZS5zdHlsZS5vcGFjaXR5ID0gJzAuNSc7XG4gICAgICAgIHRoaXMuX2Rpc3RhbmNlLnN0eWxlLmNvbG9yID0gJyMzNTM1MzUnO1xuICAgICAgICB0aGlzLl9kaXN0YW5jZS5zdHlsZS5wYWRkaW5nID0gJzRweCc7XG4gICAgICAgIHRoaXMuX2Rpc3RhbmNlLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgICAgdGhpcy5fZGlzdGFuY2Uuc3R5bGUudHJhbnNmb3JtT3JpZ2luID0gJzAgMTAwJSc7XG4gICAgICAgIHRoaXMuX2Rpc3RhbmNlLmlubmVySFRNTCA9ICdIZWxsbywgd29ybGQhJztcbiAgICAgICAgdGhpcy5fY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuX2Rpc3RhbmNlKTtcblxuICAgICAgICAvLyBhZGQgbGluZSFcbiAgICAgICAgdGhpcy5fbGluZTIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy5fbGluZTIuc2V0QXR0cmlidXRlKCdjbGFzcycsICd3aWRnZXRzIGhhbmRsZSBsaW5lJyk7XG4gICAgICAgIHRoaXMuX2xpbmUyLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgICAgdGhpcy5fbGluZTIuc3R5bGUudHJhbnNmb3JtT3JpZ2luID0gJzAgMTAwJSc7XG4gICAgICAgIHRoaXMuX2xpbmUyLnN0eWxlLm1hcmdpblRvcCA9ICctMXB4JztcbiAgICAgICAgdGhpcy5fbGluZTIuc3R5bGUuaGVpZ2h0ID0gJzJweCc7XG4gICAgICAgIHRoaXMuX2xpbmUyLnN0eWxlLndpZHRoID0gJzNweCc7XG4gICAgICAgIHRoaXMuX2NvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLl9saW5lMik7XG5cbiAgICAgICAgLy8gYWRkIGRpc3RhbmNlIVxuICAgICAgICB0aGlzLl9kaXN0YW5jZTIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy5fZGlzdGFuY2UyLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAnd2lkZ2V0cyBoYW5kbGUgZGlzdGFuY2UnKTtcbiAgICAgICAgdGhpcy5fZGlzdGFuY2Uuc3R5bGUuYm9yZGVyID0gJzJweCBzb2xpZCc7XG4gICAgICAgIHRoaXMuX2Rpc3RhbmNlLnN0eWxlLmJhY2tncm91bmRDb2xvciA9ICcjRjlGOUY5JztcbiAgICAgICAgLy8gdGhpcy5fZGlzdGFuY2UyLnN0eWxlLm9wYWNpdHkgPSAnMC41JztcbiAgICAgICAgdGhpcy5fZGlzdGFuY2UyLnN0eWxlLmNvbG9yID0gJyMzNTM1MzUnO1xuICAgICAgICB0aGlzLl9kaXN0YW5jZTIuc3R5bGUucGFkZGluZyA9ICc0cHgnO1xuICAgICAgICB0aGlzLl9kaXN0YW5jZTIuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgICB0aGlzLl9kaXN0YW5jZTIuc3R5bGUudHJhbnNmb3JtT3JpZ2luID0gJzAgMTAwJSc7XG4gICAgICAgIHRoaXMuX2Rpc3RhbmNlMi5pbm5lckhUTUwgPSAnSGVsbG8sIHdvcmxkISc7XG4gICAgICAgIHRoaXMuX2NvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLl9kaXN0YW5jZTIpO1xuXG4gICAgICAgIC8vIGFkZCBkYXNoIGxpbmVcbiAgICAgICAgdGhpcy5fZGFzaGxpbmUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy5fZGFzaGxpbmUuc2V0QXR0cmlidXRlKCdjbGFzcycsICd3aWRnZXRzIGhhbmRsZSBkYXNobGluZScpO1xuICAgICAgICB0aGlzLl9kYXNobGluZS5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICAgIHRoaXMuX2Rhc2hsaW5lLnN0eWxlLmJvcmRlciA9ICdub25lJztcbiAgICAgICAgdGhpcy5fZGFzaGxpbmUuc3R5bGUuYm9yZGVyVG9wID0gJzIuNXB4IGRhc2hlZCAjRjlGOUY5JztcbiAgICAgICAgdGhpcy5fZGFzaGxpbmUuc3R5bGUudHJhbnNmb3JtT3JpZ2luID0gJzAgMTAwJSc7XG4gICAgICAgIHRoaXMuX2Rhc2hsaW5lLnN0eWxlLmhlaWdodCA9ICcxcHgnO1xuICAgICAgICB0aGlzLl9kYXNobGluZS5zdHlsZS53aWR0aCA9ICc1MCUnO1xuICAgICAgICB0aGlzLl9jb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5fZGFzaGxpbmUpO1xuXG4gICAgICAgIHRoaXMudXBkYXRlRE9NQ29sb3IoKTtcbiAgICB9XG5cbiAgICB1cGRhdGVET01Qb3NpdGlvbigpIHtcbiAgICAgICAgLy8gdXBkYXRlIHJ1bGVycyBsaW5lcyBhbmQgdGV4dCFcbiAgICAgICAgbGV0IHgxID0gdGhpcy5faGFuZGxlc1swXS5zY3JlZW5Qb3NpdGlvbi54O1xuICAgICAgICBsZXQgeTEgPSB0aGlzLl9oYW5kbGVzWzBdLnNjcmVlblBvc2l0aW9uLnk7XG4gICAgICAgIGxldCB4MiA9IHRoaXMuX2hhbmRsZXNbMV0uc2NyZWVuUG9zaXRpb24ueDtcbiAgICAgICAgbGV0IHkyID0gdGhpcy5faGFuZGxlc1sxXS5zY3JlZW5Qb3NpdGlvbi55O1xuXG4gICAgICAgIC8vbGV0IHgwID0geDEgKyAoeDIgLSB4MSkvMjtcbiAgICAgICAgLy9sZXQgeTAgPSB5MSArICh5MiAtIHkxKS8yO1xuICAgICAgICBsZXQgeDAgPSB4MjtcbiAgICAgICAgbGV0IHkwID0geTI7XG5cbiAgICAgICAgaWYgKHkxID49IHkyKSB7XG4gICAgICAgICAgICB5MCA9IHkyIC0gMzA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB5MCA9IHkyICsgMzA7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgbGVuZ3RoID0gTWF0aC5zcXJ0KCh4MS14MikqKHgxLXgyKSArICh5MS15MikqKHkxLXkyKSk7XG4gICAgICAgIGxldCBhbmdsZSA9IE1hdGguYXRhbjIoeTIgLSB5MSwgeDIgLSB4MSkgKiAxODAgLyBNYXRoLlBJO1xuXG4gICAgICAgIGxldCBwb3NZID0geTEgLSB0aGlzLl9jb250YWluZXIub2Zmc2V0SGVpZ2h0O1xuXG4gICAgICAgIC8vIHVwZGF0ZSBsaW5lXG4gICAgICAgIGxldCB0cmFuc2Zvcm0gPSBgdHJhbnNsYXRlM0QoJHt4MX1weCwke3Bvc1l9cHgsIDApYDtcbiAgICAgICAgdHJhbnNmb3JtICs9IGAgcm90YXRlKCR7YW5nbGV9ZGVnKWA7XG5cbiAgICAgICAgdGhpcy5fbGluZS5zdHlsZS50cmFuc2Zvcm0gPSB0cmFuc2Zvcm07XG4gICAgICAgIHRoaXMuX2xpbmUuc3R5bGUud2lkdGggPSBsZW5ndGg7XG5cbiAgICAgICAgLy8gdXBkYXRlIGRpc3RhbmNlXG4gICAgICAgIGxldCB3MCA9IHRoaXMuX2hhbmRsZXNbMF0ud29ybGRQb3NpdGlvbjtcbiAgICAgICAgbGV0IHcxID0gdGhpcy5faGFuZGxlc1sxXS53b3JsZFBvc2l0aW9uO1xuXG4gICAgICAgIHRoaXMuX2Rpc3RhbmNlLmlubmVySFRNTCA9IGAke01hdGguc3FydCgodzAueC13MS54KSoodzAueC13MS54KSArICh3MC55LXcxLnkpKih3MC55LXcxLnkpICsgKHcwLnotdzEueikqKHcwLnotdzEueikpLnRvRml4ZWQoMil9IG1tYDtcbiAgICAgICAgdGhpcy5fZGlzdGFuY2VWYWx1ZSA9IE1hdGguc3FydCgodzAueC13MS54KSoodzAueC13MS54KSArICh3MC55LXcxLnkpKih3MC55LXcxLnkpICsgKHcwLnotdzEueikqKHcwLnotdzEueikpLnRvRml4ZWQoMik7XG4gICAgICAgIGxldCBwb3NZMCA9IHkwIC0gdGhpcy5fY29udGFpbmVyLm9mZnNldEhlaWdodCAtIHRoaXMuX2Rpc3RhbmNlLm9mZnNldEhlaWdodC8yO1xuICAgICAgICB4MCAtPSB0aGlzLl9kaXN0YW5jZS5vZmZzZXRXaWR0aC8yO1xuXG4gICAgICAgIGxldCB0cmFuc2Zvcm0yID0gYHRyYW5zbGF0ZTNEKCR7TWF0aC5yb3VuZCh4MCl9cHgsJHtNYXRoLnJvdW5kKHBvc1kwKX1weCwgMClgO1xuICAgICAgICB0aGlzLl9kaXN0YW5jZS5zdHlsZS50cmFuc2Zvcm0gPSB0cmFuc2Zvcm0yO1xuXG4gICAgICAgIC8vIHVwZGF0ZSBydWxlcnMgbGluZXMgMiBhbmQgdGV4dCFcbiAgICAgICAgbGV0IHgzID0gdGhpcy5faGFuZGxlc1syXS5zY3JlZW5Qb3NpdGlvbi54O1xuICAgICAgICBsZXQgeTMgPSB0aGlzLl9oYW5kbGVzWzJdLnNjcmVlblBvc2l0aW9uLnk7XG4gICAgICAgIGxldCB4NCA9IHRoaXMuX2hhbmRsZXNbM10uc2NyZWVuUG9zaXRpb24ueDtcbiAgICAgICAgbGV0IHk0ID0gdGhpcy5faGFuZGxlc1szXS5zY3JlZW5Qb3NpdGlvbi55O1xuXG4gICAgICAgIC8vbGV0IHgwID0geDEgKyAoeDIgLSB4MSkvMjtcbiAgICAgICAgLy9sZXQgeTAgPSB5MSArICh5MiAtIHkxKS8yO1xuICAgICAgICBsZXQgeDAyID0geDQ7XG4gICAgICAgIGxldCB5MDIgPSB5NDtcblxuICAgICAgICBpZiAoeTMgPj0geTQpIHtcbiAgICAgICAgICAgIHkwMiA9IHk0IC0gMzA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB5MDIgPSB5NCArIDMwO1xuICAgICAgICB9XG5cbiAgICAgICAgbGVuZ3RoID0gTWF0aC5zcXJ0KCh4My14NCkqKHgzLXg0KSArICh5My15NCkqKHkzLXk0KSk7XG4gICAgICAgIGFuZ2xlID0gTWF0aC5hdGFuMih5NCAtIHkzLCB4NCAtIHgzKSAqIDE4MCAvIE1hdGguUEk7XG5cbiAgICAgICAgcG9zWSA9IHkzIC0gdGhpcy5fY29udGFpbmVyLm9mZnNldEhlaWdodDtcblxuICAgICAgICAvLyB1cGRhdGUgbGluZVxuICAgICAgICB0cmFuc2Zvcm0gPSBgdHJhbnNsYXRlM0QoJHt4M31weCwke3Bvc1l9cHgsIDApYDtcbiAgICAgICAgdHJhbnNmb3JtICs9IGAgcm90YXRlKCR7YW5nbGV9ZGVnKWA7XG5cbiAgICAgICAgdGhpcy5fbGluZTIuc3R5bGUudHJhbnNmb3JtID0gdHJhbnNmb3JtO1xuICAgICAgICB0aGlzLl9saW5lMi5zdHlsZS53aWR0aCA9IGxlbmd0aDtcblxuICAgICAgICAvLyB1cGRhdGUgZGlzdGFuY2VcbiAgICAgICAgbGV0IHcwMiA9IHRoaXMuX2hhbmRsZXNbMl0ud29ybGRQb3NpdGlvbjtcbiAgICAgICAgbGV0IHcxMiA9IHRoaXMuX2hhbmRsZXNbM10ud29ybGRQb3NpdGlvbjtcblxuICAgICAgICB0aGlzLl9kaXN0YW5jZTIuaW5uZXJIVE1MID0gYCR7TWF0aC5zcXJ0KCh3MDIueC13MTIueCkqKHcwMi54LXcxMi54KSArICh3MDIueS13MTIueSkqKHcwMi55LXcxMi55KSArICh3MDIuei13MTIueikqKHcwMi56LXcxMi56KSkudG9GaXhlZCgyKX0gbW1gO1xuICAgICAgICB0aGlzLl9kaXN0YW5jZTJWYWx1ZSA9IE1hdGguc3FydCgodzAyLngtdzEyLngpKih3MDIueC13MTIueCkgKyAodzAyLnktdzEyLnkpKih3MDIueS13MTIueSkgKyAodzAyLnotdzEyLnopKih3MDIuei13MTIueikpLnRvRml4ZWQoMik7XG4gICAgICAgIGxldCBwb3NZMDIgPSB5MDIgLSB0aGlzLl9jb250YWluZXIub2Zmc2V0SGVpZ2h0IC0gdGhpcy5fZGlzdGFuY2UyLm9mZnNldEhlaWdodC8yO1xuICAgICAgICB4MDIgLT0gdGhpcy5fZGlzdGFuY2UyLm9mZnNldFdpZHRoLzI7XG5cbiAgICAgICAgdHJhbnNmb3JtMiA9IGB0cmFuc2xhdGUzRCgke01hdGgucm91bmQoeDAyKX1weCwke01hdGgucm91bmQocG9zWTAyKX1weCwgMClgO1xuICAgICAgICB0aGlzLl9kaXN0YW5jZTIuc3R5bGUudHJhbnNmb3JtID0gdHJhbnNmb3JtMjtcblxuICAgICAgICAvLyB1cGRhdGUgZGFzaCBsaW5lXG5cbiAgICAgICAgbGV0IGwxY2VudGVyID0gdGhpcy5nZXRQb2ludEluQmV0d2VlbkJ5UGVyYyh0aGlzLl9oYW5kbGVzWzBdLndvcmxkUG9zaXRpb24sIHRoaXMuX2hhbmRsZXNbMV0ud29ybGRQb3NpdGlvbiwgMC41KTtcbiAgICAgICAgbGV0IGwyY2VudGVyID0gdGhpcy5nZXRQb2ludEluQmV0d2VlbkJ5UGVyYyh0aGlzLl9oYW5kbGVzWzJdLndvcmxkUG9zaXRpb24sIHRoaXMuX2hhbmRsZXNbM10ud29ybGRQb3NpdGlvbiwgMC41KTtcblxuICAgICAgICBsZXQgc2NyZWVuMSA9IHRoaXMuX2hhbmRsZXNbMF0ud29ybGRUb1NjcmVlbihsMWNlbnRlciwgdGhpcy5fY2FtZXJhLCB0aGlzLl9jb250YWluZXIpO1xuICAgICAgICBsZXQgc2NyZWVuMiA9IHRoaXMuX2hhbmRsZXNbMF0ud29ybGRUb1NjcmVlbihsMmNlbnRlciwgdGhpcy5fY2FtZXJhLCB0aGlzLl9jb250YWluZXIpO1xuXG4gICAgICAgIHgxID0gc2NyZWVuMS54O1xuICAgICAgICB5MSA9IHNjcmVlbjEueTtcbiAgICAgICAgeDIgPSBzY3JlZW4yLng7XG4gICAgICAgIHkyID0gc2NyZWVuMi55O1xuXG4gICAgICAgIGxlbmd0aCA9IE1hdGguc3FydCgoeDEteDIpKih4MS14MikgKyAoeTEteTIpKih5MS15MikpO1xuICAgICAgICBhbmdsZSA9IE1hdGguYXRhbjIoeTIgLSB5MSwgeDIgLSB4MSkgKiAxODAgLyBNYXRoLlBJO1xuXG4gICAgICAgIHBvc1kgPSB5MSAtIHRoaXMuX2NvbnRhaW5lci5vZmZzZXRIZWlnaHQ7XG5cbiAgICAgICAgLy8gdXBkYXRlIGxpbmVcbiAgICAgICAgdHJhbnNmb3JtID0gYHRyYW5zbGF0ZTNEKCR7eDF9cHgsJHtwb3NZfXB4LCAwKWA7XG4gICAgICAgIHRyYW5zZm9ybSArPSBgIHJvdGF0ZSgke2FuZ2xlfWRlZylgO1xuXG4gICAgICAgIHRoaXMuX2Rhc2hsaW5lLnN0eWxlLnRyYW5zZm9ybSA9IHRyYW5zZm9ybTtcbiAgICAgICAgdGhpcy5fZGFzaGxpbmUuc3R5bGUud2lkdGggPSBsZW5ndGg7XG4gICAgfVxuXG4gICAgdXBkYXRlRE9NQ29sb3IoKSB7XG4gICAgICAgIHRoaXMuX2xpbmUuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gYCR7dGhpcy5fY29sb3J9YDtcbiAgICAgICAgdGhpcy5fZGlzdGFuY2Uuc3R5bGUuYm9yZGVyQ29sb3IgPSBgJHt0aGlzLl9jb2xvcn1gO1xuXG4gICAgICAgIHRoaXMuX2xpbmUyLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IGAke3RoaXMuX2NvbG9yfWA7XG4gICAgICAgIHRoaXMuX2Rpc3RhbmNlMi5zdHlsZS5ib3JkZXJDb2xvciA9IGAke3RoaXMuX2NvbG9yfWA7XG4gICAgfVxuXG4gICAgZ2V0UG9pbnRJbkJldHdlZW5CeVBlcmMocG9pbnRBLCBwb2ludEIsIHBlcmNlbnRhZ2UpIHtcblxuICAgICAgICB2YXIgZGlyID0gcG9pbnRCLmNsb25lKCkuc3ViKHBvaW50QSk7XG4gICAgICAgIHZhciBsZW4gPSBkaXIubGVuZ3RoKCk7XG4gICAgICAgIGRpciA9IGRpci5ub3JtYWxpemUoKS5tdWx0aXBseVNjYWxhcihsZW4qcGVyY2VudGFnZSk7XG4gICAgICAgIHJldHVybiBwb2ludEEuY2xvbmUoKS5hZGQoZGlyKTtcblxuICAgIH1cblxuICAgIGluaXRPcnRobyAoKSB7XG4gICAgICAgIHRoaXMuX2luaXRPcnRobyA9IHRydWU7XG5cbiAgICAgICAgbGV0IHBjZW50ZXIgPSB0aGlzLmdldFBvaW50SW5CZXR3ZWVuQnlQZXJjKHRoaXMuX2hhbmRsZXNbMF0ud29ybGRQb3NpdGlvbiwgdGhpcy5faGFuZGxlc1sxXS53b3JsZFBvc2l0aW9uLCAwLjUpO1xuICAgICAgICB0aGlzLl9oYW5kbGVzWzJdLndvcmxkUG9zaXRpb24gPSB0aGlzLmdldFBvaW50SW5CZXR3ZWVuQnlQZXJjKHRoaXMuX2hhbmRsZXNbMF0ud29ybGRQb3NpdGlvbiwgdGhpcy5faGFuZGxlc1sxXS53b3JsZFBvc2l0aW9uLCAwLjI1KTtcbiAgICAgICAgdGhpcy5faGFuZGxlc1szXS53b3JsZFBvc2l0aW9uID0gdGhpcy5nZXRQb2ludEluQmV0d2VlbkJ5UGVyYyh0aGlzLl9oYW5kbGVzWzBdLndvcmxkUG9zaXRpb24sIHRoaXMuX2hhbmRsZXNbMV0ud29ybGRQb3NpdGlvbiwgMC43NSk7XG5cbiAgICAgICAgdGhpcy5faGFuZGxlc1syXS53b3JsZFBvc2l0aW9uLnggPSBwY2VudGVyLnggLSBNYXRoLnNxcnQoKHBjZW50ZXIueSAtIHRoaXMuX2hhbmRsZXNbMl0ud29ybGRQb3NpdGlvbi55KSoocGNlbnRlci55IC0gdGhpcy5faGFuZGxlc1syXS53b3JsZFBvc2l0aW9uLnkpKTtcbiAgICAgICAgdGhpcy5faGFuZGxlc1syXS53b3JsZFBvc2l0aW9uLnkgPSBwY2VudGVyLnkgKyBNYXRoLnNxcnQoKHBjZW50ZXIueCAtIHRoaXMuX2hhbmRsZXNbMl0ud29ybGRQb3NpdGlvbi54KSoocGNlbnRlci54IC0gdGhpcy5faGFuZGxlc1syXS53b3JsZFBvc2l0aW9uLngpKTtcblxuICAgICAgICB0aGlzLl9oYW5kbGVzWzNdLndvcmxkUG9zaXRpb24ueCA9IHBjZW50ZXIueCArIE1hdGguc3FydCgocGNlbnRlci55IC0gdGhpcy5faGFuZGxlc1syXS53b3JsZFBvc2l0aW9uLnkpKihwY2VudGVyLnkgLSB0aGlzLl9oYW5kbGVzWzJdLndvcmxkUG9zaXRpb24ueSkpO1xuICAgICAgICB0aGlzLl9oYW5kbGVzWzNdLndvcmxkUG9zaXRpb24ueSA9IHBjZW50ZXIueSAtIE1hdGguc3FydCgocGNlbnRlci54IC0gdGhpcy5faGFuZGxlc1syXS53b3JsZFBvc2l0aW9uLngpKihwY2VudGVyLnggLSB0aGlzLl9oYW5kbGVzWzJdLndvcmxkUG9zaXRpb24ueCkpO1xuICAgIH1cblxuICAgIGdldCB3b3JsZFBvc2l0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd29ybGRQb3NpdGlvbjtcbiAgICB9XG5cbiAgICBzZXQgd29ybGRQb3NpdGlvbih3b3JsZFBvc2l0aW9uKSB7XG4gICAgICAgIHRoaXMuX3dvcmxkUG9zaXRpb24gPSB3b3JsZFBvc2l0aW9uO1xuICAgICAgICB0aGlzLl9oYW5kbGVzWzBdLndvcmxkUG9zaXRpb24gPSB0aGlzLl93b3JsZFBvc2l0aW9uO1xuICAgICAgICB0aGlzLl9oYW5kbGVzWzFdLndvcmxkUG9zaXRpb24gPSB0aGlzLl93b3JsZFBvc2l0aW9uO1xuICAgICAgICB0aGlzLl9oYW5kbGVzWzJdLndvcmxkUG9zaXRpb24gPSB0aGlzLl93b3JsZFBvc2l0aW9uO1xuICAgICAgICB0aGlzLl9oYW5kbGVzWzNdLndvcmxkUG9zaXRpb24gPSB0aGlzLl93b3JsZFBvc2l0aW9uO1xuXG4gICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgfVxuXG4gICAgZ2V0IHNob3Rlc3REaXN0YW5jZSgpIHtcbiAgICAgICAgcmV0dXJuICgodGhpcy5fZGlzdGFuY2VWYWx1ZSA8IHRoaXMuX2Rpc3RhbmNlMlZhbHVlKSA/IHRoaXMuX2Rpc3RhbmNlVmFsdWUgOiB0aGlzLl9kaXN0YW5jZTJWYWx1ZSk7XG4gICAgfVxuXG4gICAgZ2V0IGxvbmdlc3REaXN0YW5jZSgpIHtcbiAgICAgICAgcmV0dXJuICgodGhpcy5fZGlzdGFuY2VWYWx1ZSA+IHRoaXMuX2Rpc3RhbmNlMlZhbHVlKSA/IHRoaXMuX2Rpc3RhbmNlVmFsdWUgOiB0aGlzLl9kaXN0YW5jZTJWYWx1ZSk7XG4gICAgfVxuXG59XG4iLCJpbXBvcnQgV2lkZ2V0c0Jhc2UgZnJvbSAnLi4vd2lkZ2V0cy93aWRnZXRzLmJhc2UnO1xuaW1wb3J0IENvcmVJbnRlcnNlY3Rpb25zIGZyb20gJy4uL2NvcmUvY29yZS5pbnRlcnNlY3Rpb25zJztcblxuXG4vKipcbiAqIEBtb2R1bGUgd2lkZ2V0cy9oYW5kbGVcbiAqXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgV2lkZ2V0c0hhbmRsZSBleHRlbmRzIFdpZGdldHNCYXNlIHtcblxuICBjb25zdHJ1Y3Rvcih0YXJnZXRNZXNoLCBjb250cm9scywgY2FtZXJhLCBjb250YWluZXIpIHtcbiAgICBzdXBlcihjb250YWluZXIpO1xuXG4gICAgdGhpcy5fdGFyZ2V0TWVzaCA9IHRhcmdldE1lc2g7XG4gICAgdGhpcy5fY29udHJvbHMgPSBjb250cm9scztcbiAgICB0aGlzLl9jYW1lcmEgPSBjYW1lcmE7XG5cbiAgICAvLyBpZiBubyB0YXJnZXQgbWVzaCwgdXNlIHBsYW5lIGZvciBGUkVFIGRyYWdnaW5nLlxuICAgIHRoaXMuX3BsYW5lID0ge1xuICAgICAgICBwb3NpdGlvbjogbmV3IFRIUkVFLlZlY3RvcjMoKSxcbiAgICAgICAgZGlyZWN0aW9uOiBuZXcgVEhSRUUuVmVjdG9yMygpLFxuICAgIH07XG4gICAgdGhpcy5fb2Zmc2V0ID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICB0aGlzLl9yYXljYXN0ZXIgPSBuZXcgVEhSRUUuUmF5Y2FzdGVyKCk7XG5cbiAgICB0aGlzLl90cmFja2luZyA9IGZhbHNlO1xuXG4gICAgdGhpcy5fbW91c2UgPSBuZXcgVEhSRUUuVmVjdG9yMigpO1xuICAgIHRoaXMuX2xhc3RFdmVudCA9IG51bGw7XG5cbiAgICAvLyB3b3JsZCAoTFBTKSBwb3NpdGlvbiBvZiB0aGlzIGhhbmRsZVxuICAgIHRoaXMuX3dvcmxkUG9zaXRpb24gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gICAgLy8gc2NyZWVuIHBvc2l0aW9uIG9mIHRoaXMgaGFuZGxlXG4gICAgdGhpcy5fc2NyZWVuUG9zaXRpb24gPSBuZXcgVEhSRUUuVmVjdG9yMigpO1xuXG4gICAgLy8gbWVzaCBzdHVmZlxuICAgIHRoaXMuX21hdGVyaWFsID0gbnVsbDtcbiAgICB0aGlzLl9nZW9tZXRyeSA9IG51bGw7XG4gICAgdGhpcy5fbWVzaCA9IG51bGw7XG4gICAgdGhpcy5fbWVzaERpc3BsYXllZCA9IHRydWU7XG4gICAgdGhpcy5fbWVzaEhvdmVyZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9tZXNoU3R5bGUgPSAnc3BoZXJlJzsgLy8gY3ViZSwgZXRjLlxuXG4gICAgLy8gZG9tIHN0dWZmXG4gICAgdGhpcy5fZG9tID0gbnVsbDtcbiAgICB0aGlzLl9kb21EaXNwbGF5ZWQgPSB0cnVlO1xuICAgIHRoaXMuX2RvbUhvdmVyZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9kb21TdHlsZSA9ICdjaXJjbGUnOyAvLyBzcXVhcmUsIHRyaWFuZ2xlXG5cbiAgICBpZiAodGhpcy5fdGFyZ2V0TWVzaCAhPT0gbnVsbCkge1xuICAgICAgdGhpcy5fd29ybGRQb3NpdGlvbi5jb3B5KHRoaXMuX3RhcmdldE1lc2gucG9zaXRpb24pO1xuICAgIH1cblxuICAgIHRoaXMuX3NjcmVlblBvc2l0aW9uID1cbiAgICAgIHRoaXMud29ybGRUb1NjcmVlbih0aGlzLl93b3JsZFBvc2l0aW9uLCB0aGlzLl9jYW1lcmEsIHRoaXMuX2NvbnRhaW5lcik7XG5cbiAgICAvLyBjcmVhdGUgaGFuZGxlXG4gICAgdGhpcy5jcmVhdGUoKTtcbiAgICB0aGlzLmluaXRPZmZzZXRzKCk7XG5cbiAgICAvLyBldmVudCBsaXN0ZW5lcnNcbiAgICB0aGlzLm9uTW92ZSA9IHRoaXMub25Nb3ZlLmJpbmQodGhpcyk7XG4gICAgdGhpcy5vbkhvdmVyID0gdGhpcy5vbkhvdmVyLmJpbmQodGhpcyk7XG4gICAgdGhpcy5vbkVuZENvbnRyb2wgPSB0aGlzLm9uRW5kQ29udHJvbC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcnMoKTtcbiAgfVxuXG4gIGFkZEV2ZW50TGlzdGVuZXJzKCkge1xuICAgIHRoaXMuX2RvbS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWVudGVyJywgdGhpcy5vbkhvdmVyKTtcbiAgICB0aGlzLl9kb20uYWRkRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIHRoaXMub25Ib3Zlcik7XG5cbiAgICB0aGlzLl9jb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V3aGVlbCcsIHRoaXMub25Nb3ZlKTtcbiAgICB0aGlzLl9jb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcignRE9NTW91c2VTY3JvbGwnLCB0aGlzLm9uTW92ZSk7XG5cbiAgICB0aGlzLl9jb250cm9scy5hZGRFdmVudExpc3RlbmVyKCdlbmQnLCB0aGlzLm9uRW5kQ29udHJvbCk7XG4gIH1cblxuICByZW1vdmVFdmVudExpc3RlbmVycygpIHtcbiAgICB0aGlzLl9kb20ucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2VlbnRlcicsIHRoaXMub25Ib3Zlcik7XG4gICAgdGhpcy5fZG9tLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCB0aGlzLm9uSG92ZXIpO1xuXG4gICAgdGhpcy5fY29udGFpbmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNld2hlZWwnLCB0aGlzLm9uTW92ZSk7XG4gICAgdGhpcy5fY29udGFpbmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ0RPTU1vdXNlU2Nyb2xsJywgdGhpcy5vbk1vdmUpO1xuXG4gICAgdGhpcy5fY29udHJvbHMucmVtb3ZlRXZlbnRMaXN0ZW5lcignZW5kJywgdGhpcy5vbkVuZENvbnRyb2wpO1xuICB9XG5cbiAgY3JlYXRlKCkge1xuICAgIHRoaXMuY3JlYXRlTWVzaCgpO1xuICAgIHRoaXMuY3JlYXRlRE9NKCk7XG4gIH1cblxuICBvblN0YXJ0KGV2dCkge1xuICAgIGNvbnNvbGUubG9nKGV2dCk7XG4gICAgdGhpcy5fbGFzdEV2ZW50ID0gZXZ0O1xuICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgY29uc3Qgb2Zmc2V0cyA9IHRoaXMuZ2V0TW91c2VPZmZzZXRzKGV2dCwgdGhpcy5fY29udGFpbmVyKTtcbiAgICB0aGlzLl9tb3VzZS5zZXQob2Zmc2V0cy54LCBvZmZzZXRzLnkpO1xuICAgIGNvbnNvbGUubG9nKHRoaXMuX21vdXNlKTtcblxuICAgIC8vIHVwZGF0ZSByYXljYXN0ZXJcbiAgICB0aGlzLl9yYXljYXN0ZXIuc2V0RnJvbUNhbWVyYSh0aGlzLl9tb3VzZSwgdGhpcy5fY2FtZXJhKTtcbiAgICB0aGlzLl9yYXljYXN0ZXIucmF5LnBvc2l0aW9uID0gdGhpcy5fcmF5Y2FzdGVyLnJheS5vcmlnaW47XG5cbiAgICBpZiAodGhpcy5faG92ZXJlZCkge1xuICAgICAgdGhpcy5fYWN0aXZlID0gdHJ1ZTtcbiAgICAgIHRoaXMuX2NvbnRyb2xzLmVuYWJsZWQgPSBmYWxzZTtcblxuICAgICAgaWYgKHRoaXMuX3RhcmdldE1lc2gpIHtcbiAgICAgICAgbGV0IGludGVyc2VjdHNUYXJnZXQgPVxuICAgICAgICAgIHRoaXMuX3JheWNhc3Rlci5pbnRlcnNlY3RPYmplY3QodGhpcy5fdGFyZ2V0TWVzaCk7XG4gICAgICAgIGlmIChpbnRlcnNlY3RzVGFyZ2V0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICB0aGlzLl9vZmZzZXQuY29weShpbnRlcnNlY3RzVGFyZ2V0WzBdLnBvaW50KS5zdWIodGhpcy5fd29ybGRQb3NpdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3BsYW5lLnBvc2l0aW9uLmNvcHkodGhpcy5fd29ybGRQb3NpdGlvbik7XG4gICAgICAgIHRoaXMuX3BsYW5lLmRpcmVjdGlvbi5jb3B5KHRoaXMuX2NhbWVyYS5nZXRXb3JsZERpcmVjdGlvbigpKTtcbiAgICAgICAgbGV0IGludGVyc2VjdGlvbiA9XG4gICAgICAgICAgQ29yZUludGVyc2VjdGlvbnMucmF5UGxhbmUodGhpcy5fcmF5Y2FzdGVyLnJheSwgdGhpcy5fcGxhbmUpO1xuICAgICAgICBpZiAoaW50ZXJzZWN0aW9uICE9PSBudWxsKSB7XG4gICAgICAgICAgdGhpcy5fb2Zmc2V0LmNvcHkoaW50ZXJzZWN0aW9uKS5zdWIodGhpcy5fcGxhbmUucG9zaXRpb24pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgfVxuICB9XG5cbiAgb25FbmQoZXZ0KSB7XG4gICAgdGhpcy5fbGFzdEV2ZW50ID0gZXZ0O1xuICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgLy8gc3RheSBhY3RpdmUgYW5kIGtlZXAgY29udHJvbHMgZGlzYWJsZWRcbiAgICBpZiAodGhpcy5fdHJhY2tpbmcgPT09IHRydWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyB1bnNlbGVjdCBpZiBnbyB1cCB3aXRob3V0IG1vdmluZ1xuICAgIGlmICghdGhpcy5fZHJhZ2dlZCAmJiB0aGlzLl9hY3RpdmUpIHtcbiAgICAgIC8vIGNoYW5nZSBzdGF0ZSBpZiB3YXMgbm90IGRyYWdnaW5nXG4gICAgICB0aGlzLl9zZWxlY3RlZCA9ICF0aGlzLl9zZWxlY3RlZDtcbiAgICB9XG5cbiAgICB0aGlzLl9hY3RpdmUgPSBmYWxzZTtcbiAgICB0aGlzLl9kcmFnZ2VkID0gZmFsc2U7XG4gICAgdGhpcy5fY29udHJvbHMuZW5hYmxlZCA9IHRydWU7XG5cbiAgICB0aGlzLnVwZGF0ZSgpO1xuICB9XG5cbiAgb25FbmRDb250cm9sKCkge1xuICAgIGlmICghdGhpcy5fbGFzdEV2ZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICB0aGlzLm9uTW92ZSh0aGlzLl9sYXN0RXZlbnQpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqXG4gICAqL1xuICBvbk1vdmUoZXZ0KSB7XG4gICAgdGhpcy5fbGFzdEV2ZW50ID0gZXZ0O1xuICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgY29uc3Qgb2Zmc2V0cyA9IHRoaXMuZ2V0TW91c2VPZmZzZXRzKGV2dCwgdGhpcy5fY29udGFpbmVyKTtcbiAgICB0aGlzLl9tb3VzZS5zZXQob2Zmc2V0cy54LCBvZmZzZXRzLnkpO1xuXG4gICAgLy8gdXBkYXRlIHJheWNhc3RlclxuICAgIC8vIHNldCByYXkucG9zaXRpb24gdG8gc2F0aXNmeSBDb3JlSW50ZXJzZWN0aW9uczo6cmF5UGxhbmUgQVBJXG4gICAgdGhpcy5fcmF5Y2FzdGVyLnNldEZyb21DYW1lcmEodGhpcy5fbW91c2UsIHRoaXMuX2NhbWVyYSk7XG4gICAgdGhpcy5fcmF5Y2FzdGVyLnJheS5wb3NpdGlvbiA9IHRoaXMuX3JheWNhc3Rlci5yYXkub3JpZ2luO1xuXG4gICAgaWYgKHRoaXMuX2FjdGl2ZSkge1xuICAgICAgdGhpcy5fZHJhZ2dlZCA9IHRydWU7XG5cbiAgICAgIGlmICh0aGlzLl90YXJnZXRNZXNoICE9PSBudWxsKSB7XG4gICAgICAgIGxldCBpbnRlcnNlY3RzVGFyZ2V0ID1cbiAgICAgICAgICB0aGlzLl9yYXljYXN0ZXIuaW50ZXJzZWN0T2JqZWN0KHRoaXMuX3RhcmdldE1lc2gpO1xuICAgICAgICBpZiAoaW50ZXJzZWN0c1RhcmdldC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgdGhpcy5fd29ybGRQb3NpdGlvbi5jb3B5KGludGVyc2VjdHNUYXJnZXRbMF0ucG9pbnQuc3ViKHRoaXMuX29mZnNldCkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodGhpcy5fcGxhbmUuZGlyZWN0aW9uLmxlbmd0aCgpID09PSAwKSB7XG4gICAgICAgICAgLy8gZnJlZSBtb2RlIXRoaXMuX3RhcmdldE1lc2hcbiAgICAgICAgICB0aGlzLl9wbGFuZS5wb3NpdGlvbi5jb3B5KHRoaXMuX3dvcmxkUG9zaXRpb24pO1xuICAgICAgICAgIHRoaXMuX3BsYW5lLmRpcmVjdGlvbi5jb3B5KHRoaXMuX2NhbWVyYS5nZXRXb3JsZERpcmVjdGlvbigpKTtcbiAgICAgICAgIH1cblxuICAgICAgICBsZXQgaW50ZXJzZWN0aW9uID1cbiAgICAgICAgICBDb3JlSW50ZXJzZWN0aW9ucy5yYXlQbGFuZSh0aGlzLl9yYXljYXN0ZXIucmF5LCB0aGlzLl9wbGFuZSk7XG4gICAgICAgIGlmIChpbnRlcnNlY3Rpb24gIT09IG51bGwpIHtcbiAgICAgICAgICB0aGlzLl93b3JsZFBvc2l0aW9uLmNvcHkoaW50ZXJzZWN0aW9uLnN1Yih0aGlzLl9vZmZzZXQpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm9uSG92ZXIobnVsbCk7XG4gICAgfVxuXG4gICAgdGhpcy51cGRhdGUoKTtcbiAgfVxuXG4gIG9uSG92ZXIoZXZ0KSB7XG4gICAgaWYgKGV2dCkge1xuICAgICAgdGhpcy5fbGFzdEV2ZW50ID0gZXZ0O1xuICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB0aGlzLmhvdmVyRG9tKGV2dCk7XG4gICAgfVxuXG4gICAgdGhpcy5ob3Zlck1lc2goKTtcblxuICAgIHRoaXMuX2hvdmVyZWQgPSB0aGlzLl9tZXNoSG92ZXJlZCB8fCB0aGlzLl9kb21Ib3ZlcmVkO1xuICAgIHRoaXMuX2NvbnRhaW5lci5zdHlsZS5jdXJzb3IgPSB0aGlzLl9ob3ZlcmVkID8gJ3BvaW50ZXInIDogJ2RlZmF1bHQnO1xuICB9XG5cbiAgdXBkYXRlKCkge1xuICAgIC8vIGdlbmVyYWwgdXBkYXRlXG4gICAgdGhpcy51cGRhdGVDb2xvcigpO1xuXG4gICAgLy8gdXBkYXRlIHNjcmVlbiBwb3NpdGlvbiBvZiBoYW5kbGVcbiAgICB0aGlzLl9zY3JlZW5Qb3NpdGlvbiA9XG4gICAgICB0aGlzLndvcmxkVG9TY3JlZW4odGhpcy5fd29ybGRQb3NpdGlvbiwgdGhpcy5fY2FtZXJhLCB0aGlzLl9jb250YWluZXIpO1xuXG4gICAgLy8gbWVzaCBzdHVmZlxuICAgIHRoaXMudXBkYXRlTWVzaENvbG9yKCk7XG4gICAgdGhpcy51cGRhdGVNZXNoUG9zaXRpb24oKTtcblxuICAgIC8vIERPTSBzdHVmZlxuICAgIHRoaXMudXBkYXRlRE9NQ29sb3IoKTtcbiAgICB0aGlzLnVwZGF0ZURPTVBvc2l0aW9uKCk7XG4gIH1cblxuICAvL1xuICB1cGRhdGVNZXNoQ29sb3IoKSB7XG4gICAgaWYgKHRoaXMuX21hdGVyaWFsKSB7XG4gICAgICB0aGlzLl9tYXRlcmlhbC5jb2xvci5zZXQodGhpcy5fY29sb3IpO1xuICAgIH1cbiAgfVxuXG4gIHVwZGF0ZU1lc2hQb3NpdGlvbigpIHtcbiAgICBpZiAodGhpcy5fbWVzaCkge1xuICAgICAgdGhpcy5fbWVzaC5wb3NpdGlvbi54ID0gdGhpcy5fd29ybGRQb3NpdGlvbi54O1xuICAgICAgdGhpcy5fbWVzaC5wb3NpdGlvbi55ID0gdGhpcy5fd29ybGRQb3NpdGlvbi55O1xuICAgICAgdGhpcy5fbWVzaC5wb3NpdGlvbi56ID0gdGhpcy5fd29ybGRQb3NpdGlvbi56O1xuICAgIH1cbiAgfVxuXG4gIGhvdmVyTWVzaCgpIHtcbiAgICAvLyBjaGVjayByYXljYXN0IGludGVyc2VjdGlvbiwgZG8gd2Ugd2FudCB0byBob3ZlciBvbiBtZXNoIG9yIGp1c3QgY3NzP1xuICAgIGxldCBpbnRlcnNlY3RzSGFuZGxlID0gdGhpcy5fcmF5Y2FzdGVyLmludGVyc2VjdE9iamVjdCh0aGlzLl9tZXNoKTtcbiAgICB0aGlzLl9tZXNoSG92ZXJlZCA9IChpbnRlcnNlY3RzSGFuZGxlLmxlbmd0aCA+IDApO1xuICB9XG5cbiAgaG92ZXJEb20oZXZ0KSB7XG4gICAgdGhpcy5fZG9tSG92ZXJlZCA9IChldnQudHlwZSA9PT0gJ21vdXNlZW50ZXInKTtcbiAgfVxuXG4gIHdvcmxkVG9TY3JlZW4od29ybGRDb29yZGluYXRlLCBjYW1lcmEsIGNhbnZhcykge1xuICAgIGxldCBzY3JlZW5Db29yZGluYXRlcyA9IHdvcmxkQ29vcmRpbmF0ZS5jbG9uZSgpO1xuICAgIHNjcmVlbkNvb3JkaW5hdGVzLnByb2plY3QoY2FtZXJhKTtcblxuICAgIHNjcmVlbkNvb3JkaW5hdGVzLnggPVxuICAgICAgTWF0aC5yb3VuZCgoc2NyZWVuQ29vcmRpbmF0ZXMueCArIDEpICogY2FudmFzLm9mZnNldFdpZHRoIC8gMik7XG4gICAgc2NyZWVuQ29vcmRpbmF0ZXMueSA9XG4gICAgICBNYXRoLnJvdW5kKCgtc2NyZWVuQ29vcmRpbmF0ZXMueSArIDEpICogY2FudmFzLm9mZnNldEhlaWdodCAvIDIpO1xuICAgIHNjcmVlbkNvb3JkaW5hdGVzLnogPSAwO1xuXG4gICAgcmV0dXJuIHNjcmVlbkNvb3JkaW5hdGVzO1xuICB9XG5cbiAgY3JlYXRlTWVzaCgpIHtcbiAgICAvLyBnZW9tZXRyeVxuICAgIHRoaXMuX2dlb21ldHJ5ID0gbmV3IFRIUkVFLlNwaGVyZUdlb21ldHJ5KDEsIDE2LCAxNik7XG5cbiAgICAvLyBtYXRlcmlhbFxuICAgIHRoaXMuX21hdGVyaWFsID0gbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKHtcbiAgICAgICAgd2lyZWZyYW1lOiB0cnVlLFxuICAgICAgICB3aXJlZnJhbWVMaW5ld2lkdGg6IDIsXG4gICAgICB9KTtcblxuICAgIC8vIG1lc2hcbiAgICB0aGlzLl9tZXNoID0gbmV3IFRIUkVFLk1lc2godGhpcy5fZ2VvbWV0cnksIHRoaXMuX21hdGVyaWFsKTtcbiAgICB0aGlzLl9tZXNoLnBvc2l0aW9uLnggPSB0aGlzLl93b3JsZFBvc2l0aW9uLng7XG4gICAgdGhpcy5fbWVzaC5wb3NpdGlvbi55ID0gdGhpcy5fd29ybGRQb3NpdGlvbi55O1xuICAgIHRoaXMuX21lc2gucG9zaXRpb24ueiA9IHRoaXMuX3dvcmxkUG9zaXRpb24uejtcbiAgICB0aGlzLl9tZXNoLnZpc2libGUgPSB0cnVlO1xuXG4gICAgdGhpcy51cGRhdGVNZXNoQ29sb3IoKTtcblxuICAgIC8vIGFkZCBpdCFcbiAgICB0aGlzLmFkZCh0aGlzLl9tZXNoKTtcbiAgfVxuXG5cbiAgY3JlYXRlRE9NKCkge1xuICAgIC8vIGRvbVxuICAgIHRoaXMuX2RvbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHRoaXMuX2RvbS5zZXRBdHRyaWJ1dGUoJ2lkJywgdGhpcy51dWlkKTtcbiAgICB0aGlzLl9kb20uc2V0QXR0cmlidXRlKCdjbGFzcycsICdBTUkgV2lkZ2V0IEhhbmRsZScpO1xuICAgIHRoaXMuX2RvbS5zdHlsZS5ib3JkZXIgPSAnMnB4IHNvbGlkJztcbiAgICB0aGlzLl9kb20uc3R5bGUuYmFja2dyb3VuZENvbG9yID0gJyNGOUY5RjknO1xuICAgIHRoaXMuX2RvbS5zdHlsZS5jb2xvciA9ICcjRjlGOUY5JztcbiAgICB0aGlzLl9kb20uc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgIHRoaXMuX2RvbS5zdHlsZS53aWR0aCA9ICcxMnB4JztcbiAgICB0aGlzLl9kb20uc3R5bGUuaGVpZ2h0ID0gJzEycHgnO1xuICAgIHRoaXMuX2RvbS5zdHlsZS5tYXJnaW4gPSAnLTZweCc7XG4gICAgdGhpcy5fZG9tLnN0eWxlLmJvcmRlclJhZGl1cyA9ICc1MCUnO1xuICAgIHRoaXMuX2RvbS5zdHlsZS50cmFuc2Zvcm1PcmlnaW4gPSAnMCAxMDAlJztcblxuICAgIGxldCBwb3NZID0gdGhpcy5fc2NyZWVuUG9zaXRpb24ueSAtIHRoaXMuX2NvbnRhaW5lci5vZmZzZXRIZWlnaHQ7XG4gICAgdGhpcy5fZG9tLnN0eWxlLnRyYW5zZm9ybSA9XG4gICAgICBgdHJhbnNsYXRlM0QoJHt0aGlzLl9zY3JlZW5Qb3NpdGlvbi54fXB4LCAke3Bvc1l9cHgsIDApYDtcblxuICAgIHRoaXMudXBkYXRlRE9NQ29sb3IoKTtcblxuICAgIC8vIGFkZCBpdCFcbiAgICB0aGlzLl9jb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5fZG9tKTtcbiAgfVxuXG4gIHVwZGF0ZURPTVBvc2l0aW9uKCkge1xuICAgIGlmICh0aGlzLl9kb20pIHtcbiAgICAgIGxldCBwb3NZID0gdGhpcy5fc2NyZWVuUG9zaXRpb24ueSAtIHRoaXMuX2NvbnRhaW5lci5vZmZzZXRIZWlnaHQ7XG4gICAgICB0aGlzLl9kb20uc3R5bGUudHJhbnNmb3JtID1cbiAgICAgICAgYHRyYW5zbGF0ZTNEKCR7dGhpcy5fc2NyZWVuUG9zaXRpb24ueH1weCwgJHtwb3NZfXB4LCAwKWA7XG4gICAgfVxuICB9XG5cbiAgdXBkYXRlRE9NQ29sb3IoKSB7XG4gICAgdGhpcy5fZG9tLnN0eWxlLmJvcmRlckNvbG9yID0gYCR7dGhpcy5fY29sb3J9YDtcbiAgfVxuXG4gIGZyZWUoKSB7XG4gICAgLy8gdGhyZWVqcyBzdHVmZlxuXG4gICAgLy8gZG9tXG4gICAgdGhpcy5fY29udGFpbmVyLnJlbW92ZUNoaWxkKHRoaXMuX2RvbSk7XG4gICAgLy8gZXZlbnRcbiAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXJzKCk7XG5cbiAgICBzdXBlci5mcmVlKCk7XG4gIH1cblxuICBzZXQgd29ybGRQb3NpdGlvbih3b3JsZFBvc2l0aW9uKSB7XG4gICAgdGhpcy5fd29ybGRQb3NpdGlvbi5jb3B5KHdvcmxkUG9zaXRpb24pO1xuXG4gICAgdGhpcy51cGRhdGUoKTtcbiAgfVxuXG4gIGdldCB3b3JsZFBvc2l0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl93b3JsZFBvc2l0aW9uO1xuICB9XG5cbiAgc2V0IHNjcmVlblBvc2l0aW9uKHNjcmVlblBvc2l0aW9uKSB7XG4gICAgdGhpcy5fc2NyZWVuUG9zaXRpb24gPSBzY3JlZW5Qb3NpdGlvbjtcbiAgfVxuXG4gIGdldCBzY3JlZW5Qb3NpdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fc2NyZWVuUG9zaXRpb247XG4gIH1cblxuICBnZXQgYWN0aXZlKCkge1xuICAgIHJldHVybiB0aGlzLl9hY3RpdmU7XG4gIH1cblxuICBzZXQgYWN0aXZlKGFjdGl2ZSkge1xuICAgIHRoaXMuX2FjdGl2ZSA9IGFjdGl2ZTtcbiAgICAvLyB0aGlzLl90cmFja2luZyA9IHRoaXMuX2FjdGl2ZTtcbiAgICB0aGlzLl9jb250cm9scy5lbmFibGVkID0gIXRoaXMuX2FjdGl2ZTtcblxuICAgIHRoaXMudXBkYXRlKCk7XG4gIH1cblxuICBnZXQgdHJhY2tpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYWNraW5nO1xuICB9XG5cbiAgc2V0IHRyYWNraW5nKHRyYWNraW5nKSB7XG4gICAgdGhpcy5fdHJhY2tpbmcgPSB0cmFja2luZztcbiAgICB0aGlzLnVwZGF0ZSgpO1xuICB9XG5cbiAgaGlkZURPTSgpIHtcbiAgICB0aGlzLl9kb20uc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgfVxuXG4gIHNob3dET00oKSB7XG4gICAgdGhpcy5fZG9tLnN0eWxlLmRpc3BsYXkgPSAnJztcbiAgfVxuXG4gIGhpZGVNZXNoKCkge1xuICAgIHRoaXMudmlzaWJsZSA9IGZhbHNlO1xuICB9XG5cbiAgc2hvd01lc2goKSB7XG4gICAgdGhpcy52aXNpYmxlID0gdHJ1ZTtcbiAgfVxuXG4gIHNob3coKSB7XG4gICAgdGhpcy5zaG93RE9NKCk7XG4gICAgdGhpcy5zaG93TWVzaCgpO1xuICB9XG5cbiAgaGlkZSgpIHtcbiAgICB0aGlzLmhpZGVET00oKTtcbiAgICB0aGlzLmhpZGVNZXNoKCk7XG4gIH1cbn1cbiIsImltcG9ydCBBbm5vdGF0aW9uIGZyb20gJy4vd2lkZ2V0cy5hbm5vdGF0aW9uJztcbmltcG9ydCBCaVJ1bGVyIGZyb20gJy4vd2lkZ2V0cy5iaXJ1bGVyJztcbmltcG9ydCBIYW5kbGUgZnJvbSAnLi93aWRnZXRzLmhhbmRsZSc7XG5pbXBvcnQgUm9pIGZyb20gJy4vd2lkZ2V0cy5yb2knO1xuaW1wb3J0IFJ1bGVyIGZyb20gJy4vd2lkZ2V0cy5ydWxlcic7XG5pbXBvcnQgVm94ZWxQcm9iZSBmcm9tICcuL3dpZGdldHMudm94ZWxQcm9iZSc7XG5cbi8qKlxuICogQG1vZHVsZSB3aWRnZXRzXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQge1xuICAgIEFubm90YXRpb24sXG4gICAgQmlSdWxlcixcblx0SGFuZGxlLFxuICAgIFJvaSxcbiAgICBSdWxlcixcbiAgICBWb3hlbFByb2JlLFxufTtcbiIsImltcG9ydCBXaWRnZXRzQmFzZSBmcm9tICcuLi93aWRnZXRzL3dpZGdldHMuYmFzZSc7XG5pbXBvcnQgV2lkZ2V0c0hhbmRsZSBmcm9tICcuLi93aWRnZXRzL3dpZGdldHMuaGFuZGxlJztcblxuLyoqXG4gKiBAbW9kdWxlIHdpZGdldHMvaGFuZGxlXG4gKlxuICovXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFdpZGdldHNSb2kgZXh0ZW5kcyBXaWRnZXRzQmFzZSB7XG5cbiAgICBjb25zdHJ1Y3Rvcih0YXJnZXRNZXNoLCBjb250cm9scywgY2FtZXJhLCBjb250YWluZXIpIHtcbiAgICAgICAgc3VwZXIoKTtcblxuICAgICAgICB0aGlzLl90YXJnZXRNZXNoID0gdGFyZ2V0TWVzaDtcbiAgICAgICAgdGhpcy5fY29udHJvbHMgPSBjb250cm9scztcbiAgICAgICAgdGhpcy5fY2FtZXJhID0gY2FtZXJhO1xuICAgICAgICB0aGlzLl9jb250YWluZXIgPSBjb250YWluZXI7XG5cbiAgICAgICAgdGhpcy5fYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5faW5pdCA9IGZhbHNlO1xuXG4gICAgICAgIHRoaXMuX3dvcmxkUG9zaXRpb24gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgICAgICBpZih0aGlzLl90YXJnZXRNZXNoICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl93b3JsZFBvc2l0aW9uID0gdGhpcy5fdGFyZ2V0TWVzaC5wb3NpdGlvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG1lc2ggc3R1ZmZcbiAgICAgICAgdGhpcy5fbWF0ZXJpYWwgPSBudWxsO1xuICAgICAgICB0aGlzLl9nZW9tZXRyeSA9IG51bGw7XG4gICAgICAgIHRoaXMuX21lc2ggPSBudWxsO1xuXG4gICAgICAgIC8vIGRvbSBzdHVmZlxuICAgICAgICB0aGlzLl9saW5lcyA9IFtdO1xuICAgICAgICB0aGlzLl9hcmVhID0gbnVsbDtcblxuICAgICAgICAvLyBhZGQgaGFuZGxlc1xuICAgICAgICB0aGlzLl9oYW5kbGVzID0gW107XG5cbiAgICAgICAgLy8gZmlyc3QgaGFuZGxlXG4gICAgICAgIGxldCBmaXJzdEhhbmRsZSA9IG5ldyBXaWRnZXRzSGFuZGxlKHRoaXMuX3RhcmdldE1lc2gsIHRoaXMuX2NvbnRyb2xzLCB0aGlzLl9jYW1lcmEsIHRoaXMuX2NvbnRhaW5lcik7XG4gICAgICAgIGZpcnN0SGFuZGxlLndvcmxkUG9zaXRpb24gPSB0aGlzLl93b3JsZFBvc2l0aW9uO1xuICAgICAgICBmaXJzdEhhbmRsZS5ob3ZlcmVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5hZGQoZmlyc3RIYW5kbGUpO1xuXG4gICAgICAgIHRoaXMuX2hhbmRsZXMucHVzaChmaXJzdEhhbmRsZSk7XG5cbiAgICAgICAgLy8gQ3JlYXRlIHJ1bGVyXG4gICAgICAgIHRoaXMuY3JlYXRlKCk7XG5cbiAgICAgICAgdGhpcy5vbk1vdmUgPSB0aGlzLm9uTW92ZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXJzKCk7XG5cbiAgICAgICAgdGhpcy5fb3JpZW50YXRpb24gPSBudWxsO1xuICAgICAgICB0aGlzLl9zbGljZSA9IG51bGw7XG4gICAgfVxuXG4gICAgYWRkRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgICAgIHRoaXMuX2NvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXdoZWVsJywgdGhpcy5vbk1vdmUpO1xuICAgICAgICB0aGlzLl9jb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcignRE9NTW91c2VTY3JvbGwnLCB0aGlzLm9uTW92ZSk7XG4gICAgfVxuXG4gICAgb25Nb3ZlKGV2dCkge1xuICAgICAgICB0aGlzLl9kcmFnZ2VkID0gdHJ1ZTtcbiAgICAgICAgbGV0IG51bUhhbmRsZXMgPSAgdGhpcy5faGFuZGxlcy5sZW5ndGg7XG5cbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlICYmICF0aGlzLl9pbml0KSB7XG4gICAgICAgICAgICBsZXQgbGFzdEhhbmRsZSA9IHRoaXMuX2hhbmRsZXNbbnVtSGFuZGxlcy0xXTtcbiAgICAgICAgICAgIGxhc3RIYW5kbGUuaG92ZXJlZCA9IGZhbHNlO1xuICAgICAgICAgICAgbGFzdEhhbmRsZS5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgIGxhc3RIYW5kbGUudHJhY2tpbmcgPSBmYWxzZTtcblxuICAgICAgICAgICAgbGV0IG5leHRIYW5kbGUgPSBuZXcgV2lkZ2V0c0hhbmRsZSh0aGlzLl90YXJnZXRNZXNoLCB0aGlzLl9jb250cm9scywgdGhpcy5fY2FtZXJhLCB0aGlzLl9jb250YWluZXIpO1xuICAgICAgICAgICAgbmV4dEhhbmRsZS53b3JsZFBvc2l0aW9uID0gdGhpcy5fd29ybGRQb3NpdGlvbjtcbiAgICAgICAgICAgIG5leHRIYW5kbGUuaG92ZXJlZCA9IHRydWU7XG4gICAgICAgICAgICBuZXh0SGFuZGxlLmFjdGl2ZSA9IHRydWU7XG4gICAgICAgICAgICBuZXh0SGFuZGxlLnRyYWNraW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuYWRkKG5leHRIYW5kbGUpO1xuXG4gICAgICAgICAgICB0aGlzLl9oYW5kbGVzLnB1c2gobmV4dEhhbmRsZSk7XG5cbiAgICAgICAgICAgIGxldCBuZXdMaW5lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICBuZXdMaW5lLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAnd2lkZ2V0cyBoYW5kbGUgbGluZScpO1xuICAgICAgICAgICAgbmV3TGluZS5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICAgICAgICBuZXdMaW5lLnN0eWxlLnRyYW5zZm9ybU9yaWdpbiA9ICcwIDEwMCUnO1xuICAgICAgICAgICAgbmV3TGluZS5zdHlsZS5tYXJnaW5Ub3AgPSAnLTFweCc7XG4gICAgICAgICAgICBuZXdMaW5lLnN0eWxlLmhlaWdodCA9ICcycHgnO1xuICAgICAgICAgICAgbmV3TGluZS5zdHlsZS53aWR0aCA9ICczcHgnO1xuICAgICAgICAgICAgbmV3TGluZS5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSAnI0Y5RjlGOSc7XG5cbiAgICAgICAgICAgIHRoaXMuX2xpbmVzLnB1c2gobmV3TGluZSk7XG4gICAgICAgICAgICB0aGlzLl9jb250YWluZXIuYXBwZW5kQ2hpbGQobmV3TGluZSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaG92ZXJlZCA9IGZhbHNlO1xuXG4gICAgICAgIGZvciAobGV0IGluZGV4IGluIHRoaXMuX2hhbmRsZXMpIHtcbiAgICAgICAgICAgIHRoaXMuX2hhbmRsZXNbaW5kZXhdLm9uTW92ZShldnQpO1xuICAgICAgICAgICAgaG92ZXJlZCA9IGhvdmVyZWQgfHwgdGhpcy5faGFuZGxlc1tpbmRleF0uaG92ZXJlZFxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5faG92ZXJlZCA9IGhvdmVyZWQ7XG5cbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlICYmIG51bUhhbmRsZXMgPiAyKSB7XG4gICAgICAgICAgICB0aGlzLnB1c2hQb3BIYW5kbGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgfVxuXG4gICAgb25TdGFydChldnQpIHtcbiAgICAgICAgdGhpcy5fZHJhZ2dlZCA9IGZhbHNlO1xuXG4gICAgICAgIHZhciBhY3RpdmUgPSBmYWxzZTtcblxuICAgICAgICBmb3IgKGxldCBpbmRleCBpbiB0aGlzLl9oYW5kbGVzKSB7XG4gICAgICAgICAgICB0aGlzLl9oYW5kbGVzW2luZGV4XS5vblN0YXJ0KGV2dCk7XG4gICAgICAgICAgICBhY3RpdmUgPSBhY3RpdmUgfHwgdGhpcy5faGFuZGxlc1tpbmRleF0uYWN0aXZlXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9hY3RpdmUgPSBhY3RpdmU7XG4gICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgfVxuXG4gICAgb25FbmQoZXZ0KSB7XG4gICAgICAgIC8vIEZpcnN0IEhhbmRsZVxuICAgICAgICB2YXIgYWN0aXZlID0gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGluZGV4IGluIHRoaXMuX2hhbmRsZXMuc2xpY2UoMCwgdGhpcy5faGFuZGxlcy5sZW5ndGgtMikpIHtcbiAgICAgICAgICAgIHRoaXMuX2hhbmRsZXNbaW5kZXhdLm9uRW5kKGV2dCk7XG4gICAgICAgICAgICBhY3RpdmUgPSBhY3RpdmUgfHwgdGhpcy5faGFuZGxlc1tpbmRleF0uYWN0aXZlXG4gICAgICAgIH1cblxuICAgICAgICAvLyBTZWNvbmQgSGFuZGxlXG4gICAgICAgIGlmKHRoaXMuX2RyYWdnZWQgfHwgIXRoaXMuX2hhbmRsZXNbdGhpcy5faGFuZGxlcy5sZW5ndGgtMV0udHJhY2tpbmcpIHtcbiAgICAgICAgICAgIHRoaXMuX2hhbmRsZXNbdGhpcy5faGFuZGxlcy5sZW5ndGgtMV0udHJhY2tpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX2hhbmRsZXNbdGhpcy5faGFuZGxlcy5sZW5ndGgtMV0ub25FbmQoZXZ0KTtcbiAgICAgICAgfSBlbHNle1xuICAgICAgICAgICAgdGhpcy5faGFuZGxlc1t0aGlzLl9oYW5kbGVzLmxlbmd0aC0xXS50cmFja2luZyA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgYWN0aXZlID0gYWN0aXZlIHx8IHRoaXMuX2hhbmRsZXNbdGhpcy5faGFuZGxlcy5sZW5ndGgtMV0uYWN0aXZlXG4gICAgICAgIC8vIFN0YXRlIG9mIHJ1bGVyIHdpZGdldFxuICAgICAgICB0aGlzLl9hY3RpdmUgPSBhY3RpdmU7XG5cbiAgICAgICAgbGV0IG5ld0xpbmUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgbmV3TGluZS5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgJ3dpZGdldHMgaGFuZGxlIGxpbmUnKTtcbiAgICAgICAgbmV3TGluZS5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICAgIG5ld0xpbmUuc3R5bGUudHJhbnNmb3JtT3JpZ2luID0gJzAgMTAwJSc7XG4gICAgICAgIG5ld0xpbmUuc3R5bGUubWFyZ2luVG9wID0gJy0xcHgnO1xuICAgICAgICBuZXdMaW5lLnN0eWxlLmhlaWdodCA9ICcycHgnO1xuICAgICAgICBuZXdMaW5lLnN0eWxlLndpZHRoID0gJzNweCc7XG4gICAgICAgIG5ld0xpbmUuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gJyNGOUY5RjknO1xuXG4gICAgICAgIHRoaXMuX2xpbmVzLnB1c2gobmV3TGluZSk7XG4gICAgICAgIHRoaXMuX2NvbnRhaW5lci5hcHBlbmRDaGlsZChuZXdMaW5lKTtcblxuICAgICAgICB0aGlzLl9pbml0ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICB9XG5cbiAgICBjcmVhdGUoKSB7XG4gICAgICAgIHRoaXMuY3JlYXRlTWVzaCgpO1xuICAgICAgICB0aGlzLmNyZWF0ZURPTSgpO1xuICAgIH1cblxuICAgIGhpZGVET00oKSB7XG4gICAgICAgIGZvciAobGV0IGluZGV4IGluIHRoaXMuX2hhbmRsZXMpIHtcbiAgICAgICAgICAgIHRoaXMuX2hhbmRsZXNbaW5kZXhdLmhpZGVET00oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAobGV0IGluZGV4IGluIHRoaXMuX2xpbmVzKSB7XG4gICAgICAgICAgICB0aGlzLl9saW5lc1tpbmRleF0uc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNob3dET00oKSB7XG4gICAgICAgIGZvciAobGV0IGluZGV4IGluIHRoaXMuX2hhbmRsZXMpIHtcbiAgICAgICAgICAgIHRoaXMuX2hhbmRsZXNbaW5kZXhdLnNob3dET00oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAobGV0IGluZGV4IGluIHRoaXMuX2xpbmVzKSB7XG4gICAgICAgICAgICB0aGlzLl9saW5lc1tpbmRleF0uc3R5bGUuZGlzcGxheSA9ICcnO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaGlkZU1lc2goKXtcbiAgICAgICAgdGhpcy52aXNpYmxlID0gZmFsc2U7XG4gICAgfVxuXG4gICAgc2hvd01lc2goKSB7XG4gICAgICAgIHRoaXMudmlzaWJsZSA9IHRydWU7XG4gICAgfVxuXG4gICAgc2hvdygpIHtcbiAgICAgICAgdGhpcy5zaG93RE9NKCk7XG4gICAgICAgIHRoaXMuc2hvd01lc2goKTtcbiAgICB9XG5cbiAgICBoaWRlKCkge1xuICAgICAgICB0aGlzLmhpZGVET00oKTtcbiAgICAgICAgdGhpcy5oaWRlTWVzaCgpO1xuICAgIH1cblxuICAgIHVwZGF0ZSgpIHtcbiAgICAgICAgdGhpcy51cGRhdGVDb2xvcigpO1xuXG4gICAgICAgIGZvciAobGV0IGluZGV4IGluIHRoaXMuX2hhbmRsZXMpIHtcbiAgICAgICAgICAgIHRoaXMuX2hhbmRsZXNbaW5kZXhdLnVwZGF0ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbWVzaCBzdHVmZlxuICAgICAgICB0aGlzLnVwZGF0ZU1lc2hDb2xvcigpO1xuICAgICAgICB0aGlzLnVwZGF0ZU1lc2hQb3NpdGlvbigpO1xuXG4gICAgICAgIC8vIERPTSBzdHVmZlxuICAgICAgICB0aGlzLnVwZGF0ZURPTVBvc2l0aW9uKCk7XG4gICAgICAgIHRoaXMudXBkYXRlRE9NQ29sb3IoKTtcbiAgICB9XG5cbiAgICBjcmVhdGVNZXNoKCkge1xuICAgICAgICAvLyBnZW9tZXRyeVxuICAgICAgICB0aGlzLl9nZW9tZXRyeSA9IG5ldyBUSFJFRS5HZW9tZXRyeSgpO1xuICAgICAgICBmb3IgKGxldCBpbmRleCBpbiB0aGlzLl9oYW5kbGVzKSB7XG4gICAgICAgICAgICB0aGlzLl9nZW9tZXRyeS52ZXJ0aWNlcy5wdXNoKHRoaXMuX2hhbmRsZXNbaW5kZXhdLndvcmxkUG9zaXRpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbWF0ZXJpYWxcbiAgICAgICAgdGhpcy5fbWF0ZXJpYWwgPSBuZXcgVEhSRUUuTGluZUJhc2ljTWF0ZXJpYWwoKTtcbiAgICAgICAgdGhpcy51cGRhdGVNZXNoQ29sb3IoKTtcblxuICAgICAgICAvLyBtZXNoXG4gICAgICAgIHRoaXMuX21lc2ggPSBuZXcgVEhSRUUuTGluZSh0aGlzLl9nZW9tZXRyeSwgdGhpcy5fbWF0ZXJpYWwpO1xuICAgICAgICB0aGlzLl9tZXNoLnZpc2libGUgPSB0cnVlO1xuXG4gICAgICAgIC8vIGFkZCBpdCFcbiAgICAgICAgdGhpcy5hZGQodGhpcy5fbWVzaCk7XG4gICAgfVxuXG4gICAgdXBkYXRlTWVzaENvbG9yKCkge1xuICAgICAgICBpZih0aGlzLl9tYXRlcmlhbCkge1xuICAgICAgICAgICAgdGhpcy5fbWF0ZXJpYWwuY29sb3Iuc2V0KHRoaXMuX2NvbG9yKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHVwZGF0ZU1lc2hQb3NpdGlvbigpIHtcbiAgICAgICAgaWYodGhpcy5fZ2VvbWV0cnkpIHtcbiAgICAgICAgICAgIHRoaXMuX2dlb21ldHJ5LnZlcnRpY2VzTmVlZFVwZGF0ZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjcmVhdGVET00oKSB7XG4gICAgICAgIC8vIGFkZCBsaW5lIVxuICAgICAgICB0aGlzLl9saW5lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMuX2xpbmUuc2V0QXR0cmlidXRlKCdjbGFzcycsICd3aWRnZXRzIGhhbmRsZSBsaW5lJyk7XG4gICAgICAgIHRoaXMuX2xpbmUuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgICB0aGlzLl9saW5lLnN0eWxlLnRyYW5zZm9ybU9yaWdpbiA9ICcwIDEwMCUnO1xuICAgICAgICB0aGlzLl9saW5lLnN0eWxlLm1hcmdpblRvcCA9ICctMXB4JztcbiAgICAgICAgdGhpcy5fbGluZS5zdHlsZS5oZWlnaHQgPSAnMnB4JztcbiAgICAgICAgdGhpcy5fbGluZS5zdHlsZS53aWR0aCA9ICczcHgnO1xuICAgICAgICB0aGlzLl9jb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5fbGluZSk7XG5cbiAgICAgICAgLy8gYWRkIGRpc3RhbmNlIVxuICAgICAgICB0aGlzLl9kaXN0YW5jZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLl9kaXN0YW5jZS5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgJ3dpZGdldHMgaGFuZGxlIGRpc3RhbmNlJyk7XG4gICAgICAgIHRoaXMuX2Rpc3RhbmNlLnN0eWxlLmJvcmRlciA9ICcycHggc29saWQnO1xuICAgICAgICB0aGlzLl9kaXN0YW5jZS5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSAnI0Y5RjlGOSc7XG4gICAgICAgIC8vIHRoaXMuX2Rpc3RhbmNlLnN0eWxlLm9wYWNpdHkgPSAnMC41JztcbiAgICAgICAgdGhpcy5fZGlzdGFuY2Uuc3R5bGUuY29sb3IgPSAnIzM1MzUzNSc7XG4gICAgICAgIHRoaXMuX2Rpc3RhbmNlLnN0eWxlLnBhZGRpbmcgPSAnNHB4JztcbiAgICAgICAgdGhpcy5fZGlzdGFuY2Uuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgICB0aGlzLl9kaXN0YW5jZS5zdHlsZS50cmFuc2Zvcm1PcmlnaW4gPSAnMCAxMDAlJztcbiAgICAgICAgdGhpcy5fZGlzdGFuY2UuaW5uZXJIVE1MID0gJ0hlbGxvLCB3b3JsZCEnO1xuICAgICAgICB0aGlzLl9jb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5fZGlzdGFuY2UpO1xuXG4gICAgICAgIHRoaXMudXBkYXRlRE9NQ29sb3IoKTtcbiAgICB9XG5cbiAgICBpc1BvaW50T25MaW5lIChwb2ludEEsIHBvaW50QiwgcG9pbnRUb0NoZWNrKSB7XG4gICAgICAgIHZhciBjID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICAgICAgYy5jcm9zc1ZlY3RvcnMocG9pbnRBLmNsb25lKCkuc3ViKHBvaW50VG9DaGVjayksIHBvaW50Qi5jbG9uZSgpLnN1Yihwb2ludFRvQ2hlY2spKTtcbiAgICAgICAgcmV0dXJuICFjLmxlbmd0aCgpO1xuICAgIH1cblxuICAgIHB1c2hQb3BIYW5kbGUgKCkge1xuICAgICAgICBsZXQgaGFuZGxlMCA9IHRoaXMuX2hhbmRsZXNbdGhpcy5faGFuZGxlcy5sZW5ndGgtM107XG4gICAgICAgIGxldCBoYW5kbGUxID0gdGhpcy5faGFuZGxlc1t0aGlzLl9oYW5kbGVzLmxlbmd0aC0yXTtcbiAgICAgICAgbGV0IG5ld2hhbmRsZSA9IHRoaXMuX2hhbmRsZXNbdGhpcy5faGFuZGxlcy5sZW5ndGgtMV07XG5cbiAgICAgICAgdmFyIGlzT25MaW5lID0gdGhpcy5pc1BvaW50T25MaW5lKGhhbmRsZTAud29ybGRQb3NpdGlvbiwgaGFuZGxlMS53b3JsZFBvc2l0aW9uLCBuZXdoYW5kbGUud29ybGRQb3NpdGlvbik7XG5cbiAgICAgICAgaWYgKGlzT25MaW5lKSB7XG4gICAgICAgICAgICBoYW5kbGUxLl9kb20uc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlKGhhbmRsZTEpO1xuXG4gICAgICAgICAgICB0aGlzLl9oYW5kbGVzW3RoaXMuX2hhbmRsZXMubGVuZ3RoLTJdID0gbmV3aGFuZGxlO1xuICAgICAgICAgICAgdGhpcy5faGFuZGxlcy5wb3AoKTtcblxuICAgICAgICAgICAgbGV0IHRlbXBMaW5lID0gdGhpcy5fbGluZXMucG9wKCk7XG4gICAgICAgICAgICB0ZW1wTGluZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICAgICAgdGhpcy5fY29udGFpbmVyLnJlbW92ZUNoaWxkKHRlbXBMaW5lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpc09uTGluZTtcbiAgICB9XG5cbiAgICB1cGRhdGVMaW5lRE9NIChsaW5lSW5kZXgsIGhhbmRsZTBJbmRleCwgaGFuZGxlMUluZGV4KSB7XG4gICAgICAgIC8vIHVwZGF0ZSBydWxlcnMgbGluZXMgYW5kIHRleHQhXG4gICAgICAgIGxldCB4MSA9IHRoaXMuX2hhbmRsZXNbaGFuZGxlMEluZGV4XS5zY3JlZW5Qb3NpdGlvbi54O1xuICAgICAgICBsZXQgeTEgPSB0aGlzLl9oYW5kbGVzW2hhbmRsZTBJbmRleF0uc2NyZWVuUG9zaXRpb24ueTtcbiAgICAgICAgbGV0IHgyID0gdGhpcy5faGFuZGxlc1toYW5kbGUxSW5kZXhdLnNjcmVlblBvc2l0aW9uLng7XG4gICAgICAgIGxldCB5MiA9IHRoaXMuX2hhbmRsZXNbaGFuZGxlMUluZGV4XS5zY3JlZW5Qb3NpdGlvbi55O1xuXG4gICAgICAgIGxldCB4MCA9IHgyO1xuICAgICAgICBsZXQgeTAgPSB5MjtcblxuICAgICAgICBpZiAoeTEgPj0geTIpIHtcbiAgICAgICAgICAgIHkwID0geTIgLSAzMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHkwID0geTIgKyAzMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBsZW5ndGggPSBNYXRoLnNxcnQoKHgxIC0geDIpICogKHgxIC0geDIpICsgKHkxIC0geTIpICogKHkxIC0geTIpKTtcbiAgICAgICAgbGV0IGFuZ2xlID0gTWF0aC5hdGFuMih5MiAtIHkxLCB4MiAtIHgxKSAqIDE4MCAvIE1hdGguUEk7XG5cbiAgICAgICAgbGV0IHBvc1kgPSB5MSAtIHRoaXMuX2NvbnRhaW5lci5vZmZzZXRIZWlnaHQ7XG5cbiAgICAgICAgLy8gdXBkYXRlIGxpbmVcbiAgICAgICAgbGV0IHRyYW5zZm9ybSA9IGB0cmFuc2xhdGUzRCgke3gxfXB4LCAke3Bvc1l9cHgsIDApYDtcbiAgICAgICAgdHJhbnNmb3JtICs9IGAgcm90YXRlKCR7YW5nbGV9ZGVnKWA7XG5cbiAgICAgICAgLy90aGlzLl9saW5lc1tsaW5lSW5kZXhdLnN0eWxlLmRpc3BsYXkgPSAnJztcbiAgICAgICAgdGhpcy5fbGluZXNbbGluZUluZGV4XS5zdHlsZS50cmFuc2Zvcm0gPSB0cmFuc2Zvcm07XG4gICAgICAgIHRoaXMuX2xpbmVzW2xpbmVJbmRleF0uc3R5bGUud2lkdGggPSBsZW5ndGg7XG4gICAgfVxuXG4gICAgdXBkYXRlRE9NUG9zaXRpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLl9oYW5kbGVzLmxlbmd0aCA+PSAyKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpbmRleCBpbiB0aGlzLl9saW5lcykge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlTGluZURPTShpbmRleCwgaW5kZXgsIHBhcnNlSW50KGluZGV4KSArIDEgPT0gdGhpcy5faGFuZGxlcy5sZW5ndGggPyAwIDogcGFyc2VJbnQoaW5kZXgpICsgMSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHVwZGF0ZURPTUNvbG9yKCkge1xuICAgICAgICB0aGlzLl9saW5lLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IGAke3RoaXMuX2NvbG9yfWA7XG4gICAgICAgIHRoaXMuX2Rpc3RhbmNlLnN0eWxlLmJvcmRlckNvbG9yID0gYCR7dGhpcy5fY29sb3J9YDtcbiAgICB9XG5cbiAgICBnZXRQb2ludEluQmV0d2VlbkJ5UGVyYyhwb2ludEEsIHBvaW50QiwgcGVyY2VudGFnZSkge1xuXG4gICAgICAgIHZhciBkaXIgPSBwb2ludEIuY2xvbmUoKS5zdWIocG9pbnRBKTtcbiAgICAgICAgdmFyIGxlbiA9IGRpci5sZW5ndGgoKTtcbiAgICAgICAgZGlyID0gZGlyLm5vcm1hbGl6ZSgpLm11bHRpcGx5U2NhbGFyKGxlbipwZXJjZW50YWdlKTtcbiAgICAgICAgcmV0dXJuIHBvaW50QS5jbG9uZSgpLmFkZChkaXIpO1xuXG4gICAgfVxuXG4gICAgZ2V0IHdvcmxkUG9zaXRpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93b3JsZFBvc2l0aW9uO1xuICAgIH1cblxuICAgIHNldCB3b3JsZFBvc2l0aW9uKHdvcmxkUG9zaXRpb24pIHtcbiAgICAgICAgdGhpcy5fd29ybGRQb3NpdGlvbiA9IHdvcmxkUG9zaXRpb247XG5cbiAgICAgICAgZm9yIChsZXQgaW5kZXggaW4gdGhpcy5faGFuZGxlcykge1xuICAgICAgICAgICAgdGhpcy5faGFuZGxlc1tpbmRleF0uX3dvcmxkUG9zaXRpb24gPSB0aGlzLl93b3JsZFBvc2l0aW9uO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICB9XG59IiwiaW1wb3J0IFdpZGdldHNCYXNlIGZyb20gJy4uL3dpZGdldHMvd2lkZ2V0cy5iYXNlJztcbmltcG9ydCBXaWRnZXRzSGFuZGxlIGZyb20gJy4uL3dpZGdldHMvd2lkZ2V0cy5oYW5kbGUnO1xuXG4vKipcbiAqIEBtb2R1bGUgd2lkZ2V0cy9oYW5kbGVcbiAqXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgV2lkZ2V0c1J1bGVyIGV4dGVuZHMgV2lkZ2V0c0Jhc2Uge1xuXG4gIGNvbnN0cnVjdG9yKHRhcmdldE1lc2gsIGNvbnRyb2xzLCBjYW1lcmEsIGNvbnRhaW5lcikge1xuICAgIHN1cGVyKGNvbnRhaW5lcik7XG5cbiAgICB0aGlzLl90YXJnZXRNZXNoID0gdGFyZ2V0TWVzaDtcbiAgICB0aGlzLl9jb250cm9scyA9IGNvbnRyb2xzO1xuICAgIHRoaXMuX2NhbWVyYSA9IGNhbWVyYTtcblxuICAgIHRoaXMuX2FjdGl2ZSA9IHRydWU7XG4gICAgdGhpcy5fbGFzdEV2ZW50ID0gbnVsbDtcblxuICAgIHRoaXMuX3dvcmxkUG9zaXRpb24gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgIGlmICh0aGlzLl90YXJnZXRNZXNoICE9PSBudWxsKSB7XG4gICAgICB0aGlzLl93b3JsZFBvc2l0aW9uID0gdGhpcy5fdGFyZ2V0TWVzaC5wb3NpdGlvbjtcbiAgICB9XG5cbiAgICAvLyBtZXNoIHN0dWZmXG4gICAgdGhpcy5fbWF0ZXJpYWwgPSBudWxsO1xuICAgIHRoaXMuX2dlb21ldHJ5ID0gbnVsbDtcbiAgICB0aGlzLl9tZXNoID0gbnVsbDtcblxuICAgIC8vIGRvbSBzdHVmZlxuICAgIHRoaXMuX2xpbmUgPSBudWxsO1xuICAgIHRoaXMuX2Rpc3RhbmNlID0gbnVsbDtcblxuICAgIC8vIGFkZCBoYW5kbGVzXG4gICAgdGhpcy5faGFuZGxlcyA9IFtdO1xuXG4gICAgLy8gZmlyc3QgaGFuZGxlXG4gICAgbGV0IGZpcnN0SGFuZGxlID1cbiAgICAgIG5ldyBXaWRnZXRzSGFuZGxlKHRoaXMuX3RhcmdldE1lc2gsIHRoaXMuX2NvbnRyb2xzLCB0aGlzLl9jYW1lcmEsIHRoaXMuX2NvbnRhaW5lcik7XG4gICAgZmlyc3RIYW5kbGUud29ybGRQb3NpdGlvbiA9IHRoaXMuX3dvcmxkUG9zaXRpb247XG4gICAgZmlyc3RIYW5kbGUuaG92ZXJlZCA9IHRydWU7XG4gICAgdGhpcy5hZGQoZmlyc3RIYW5kbGUpO1xuXG4gICAgdGhpcy5faGFuZGxlcy5wdXNoKGZpcnN0SGFuZGxlKTtcblxuICAgIGxldCBzZWNvbmRIYW5kbGUgPVxuICAgICAgbmV3IFdpZGdldHNIYW5kbGUodGhpcy5fdGFyZ2V0TWVzaCwgdGhpcy5fY29udHJvbHMsIHRoaXMuX2NhbWVyYSwgdGhpcy5fY29udGFpbmVyKTtcbiAgICBzZWNvbmRIYW5kbGUud29ybGRQb3NpdGlvbiA9IHRoaXMuX3dvcmxkUG9zaXRpb247XG4gICAgc2Vjb25kSGFuZGxlLmhvdmVyZWQgPSB0cnVlO1xuICAgIC8vIGFjdGl2ZSBhbmQgdHJhY2tpbmcgbWlnaHQgYmUgcmVkdW5kYW50XG4gICAgc2Vjb25kSGFuZGxlLmFjdGl2ZSA9IHRydWU7XG4gICAgc2Vjb25kSGFuZGxlLnRyYWNraW5nID0gdHJ1ZTtcbiAgICB0aGlzLmFkZChzZWNvbmRIYW5kbGUpO1xuXG4gICAgdGhpcy5faGFuZGxlcy5wdXNoKHNlY29uZEhhbmRsZSk7XG5cbiAgICAvLyBDcmVhdGUgcnVsZXJcbiAgICB0aGlzLmNyZWF0ZSgpO1xuICAgIHRoaXMuaW5pdE9mZnNldHMoKTtcblxuICAgIHRoaXMub25Nb3ZlID0gdGhpcy5vbk1vdmUuYmluZCh0aGlzKTtcbiAgICB0aGlzLm9uRW5kQ29udHJvbCA9IHRoaXMub25FbmRDb250cm9sLmJpbmQodGhpcyk7XG4gICAgdGhpcy5hZGRFdmVudExpc3RlbmVycygpO1xuICB9XG5cbiAgYWRkRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgdGhpcy5fY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNld2hlZWwnLCB0aGlzLm9uTW92ZSk7XG4gICAgdGhpcy5fY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ0RPTU1vdXNlU2Nyb2xsJywgdGhpcy5vbk1vdmUpO1xuXG4gICAgdGhpcy5fY29udHJvbHMuYWRkRXZlbnRMaXN0ZW5lcignZW5kJywgdGhpcy5vbkVuZENvbnRyb2wpO1xuICB9XG5cbiAgcmVtb3ZlRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgdGhpcy5fY29udGFpbmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNld2hlZWwnLCB0aGlzLm9uTW92ZSk7XG4gICAgdGhpcy5fY29udGFpbmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ0RPTU1vdXNlU2Nyb2xsJywgdGhpcy5vbk1vdmUpO1xuXG4gICAgdGhpcy5fY29udHJvbHMucmVtb3ZlRXZlbnRMaXN0ZW5lcignZW5kJywgdGhpcy5vbkVuZENvbnRyb2wpO1xuICB9XG5cbiAgb25Nb3ZlKGV2dCkge1xuICAgIHRoaXMuX2xhc3RFdmVudCA9IGV2dDtcbiAgICB0aGlzLl9kcmFnZ2VkID0gdHJ1ZTtcblxuICAgIHRoaXMuX2hhbmRsZXNbMF0ub25Nb3ZlKGV2dCk7XG4gICAgdGhpcy5faGFuZGxlc1sxXS5vbk1vdmUoZXZ0KTtcblxuICAgIHRoaXMuX2hvdmVyZWQgPSB0aGlzLl9oYW5kbGVzWzBdLmhvdmVyZWQgfHwgdGhpcy5faGFuZGxlc1sxXS5ob3ZlcmVkO1xuICAgIHRoaXMudXBkYXRlKCk7XG4gIH1cblxuICBvblN0YXJ0KGV2dCkge1xuICAgIHRoaXMuX2xhc3RFdmVudCA9IGV2dDtcbiAgICB0aGlzLl9kcmFnZ2VkID0gZmFsc2U7XG5cbiAgICB0aGlzLl9oYW5kbGVzWzBdLm9uU3RhcnQoZXZ0KTtcbiAgICB0aGlzLl9oYW5kbGVzWzFdLm9uU3RhcnQoZXZ0KTtcblxuICAgIHRoaXMuX2FjdGl2ZSA9IHRoaXMuX2hhbmRsZXNbMF0uYWN0aXZlIHx8IHRoaXMuX2hhbmRsZXNbMV0uYWN0aXZlO1xuICAgIHRoaXMudXBkYXRlKCk7XG4gIH1cblxuICBvbkVuZChldnQpIHtcbiAgICB0aGlzLl9sYXN0RXZlbnQgPSBldnQ7XG4gICAgLy8gRmlyc3QgSGFuZGxlXG4gICAgdGhpcy5faGFuZGxlc1swXS5vbkVuZChldnQpO1xuXG4gICAgLy8gd2luZG93LmNvbnNvbGUubG9nKHRoaXMpO1xuXG4gICAgLy8gU2Vjb25kIEhhbmRsZVxuICAgIGlmICh0aGlzLl9kcmFnZ2VkIHx8ICF0aGlzLl9oYW5kbGVzWzFdLnRyYWNraW5nKSB7XG4gICAgICB0aGlzLl9oYW5kbGVzWzFdLnRyYWNraW5nID0gZmFsc2U7XG4gICAgICB0aGlzLl9oYW5kbGVzWzFdLm9uRW5kKGV2dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2hhbmRsZXNbMV0udHJhY2tpbmcgPSBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBTdGF0ZSBvZiBydWxlciB3aWRnZXRcbiAgICB0aGlzLl9hY3RpdmUgPSB0aGlzLl9oYW5kbGVzWzBdLmFjdGl2ZSB8fCB0aGlzLl9oYW5kbGVzWzFdLmFjdGl2ZTtcbiAgICB0aGlzLnVwZGF0ZSgpO1xuICB9XG5cbiAgb25FbmRDb250cm9sKCkge1xuICAgIGlmICghdGhpcy5fbGFzdEV2ZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICB0aGlzLm9uTW92ZSh0aGlzLl9sYXN0RXZlbnQpO1xuICAgIH0pO1xuICB9XG5cbiAgY3JlYXRlKCkge1xuICAgIHRoaXMuY3JlYXRlTWVzaCgpO1xuICAgIHRoaXMuY3JlYXRlRE9NKCk7XG4gIH1cblxuICBoaWRlRE9NKCkge1xuICAgIHRoaXMuX2xpbmUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICB0aGlzLl9kaXN0YW5jZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgIGZvciAobGV0IGluZGV4IGluIHRoaXMuX2hhbmRsZXMpIHtcbiAgICAgIHRoaXMuX2hhbmRsZXNbaW5kZXhdLmhpZGVET00oKTtcbiAgICB9XG4gIH1cblxuICBzaG93RE9NKCkge1xuICAgIHRoaXMuX2xpbmUuc3R5bGUuZGlzcGxheSA9ICcnO1xuICAgIHRoaXMuX2Rpc3RhbmNlLnN0eWxlLmRpc3BsYXkgPSAnJztcbiAgICBmb3IgKGxldCBpbmRleCBpbiB0aGlzLl9oYW5kbGVzKSB7XG4gICAgICB0aGlzLl9oYW5kbGVzW2luZGV4XS5zaG93RE9NKCk7XG4gICAgfVxuICB9XG5cbiAgaGlkZU1lc2goKSB7XG4gICAgdGhpcy52aXNpYmxlID0gZmFsc2U7XG4gIH1cblxuICBzaG93TWVzaCgpIHtcbiAgICB0aGlzLnZpc2libGUgPSB0cnVlO1xuICB9XG5cbiAgc2hvdygpIHtcbiAgICB0aGlzLnNob3dET00oKTtcbiAgICB0aGlzLnNob3dNZXNoKCk7XG4gIH1cblxuICBoaWRlKCkge1xuICAgIHRoaXMuaGlkZURPTSgpO1xuICAgIHRoaXMuaGlkZU1lc2goKTtcbiAgfVxuXG4gIHVwZGF0ZSgpIHtcbiAgICB0aGlzLnVwZGF0ZUNvbG9yKCk7XG5cbiAgICAvLyB1cGRhdGUgaGFuZGxlc1xuICAgIHRoaXMuX2hhbmRsZXNbMF0udXBkYXRlKCk7XG4gICAgdGhpcy5faGFuZGxlc1sxXS51cGRhdGUoKTtcblxuICAgIC8vIG1lc2ggc3R1ZmZcbiAgICB0aGlzLnVwZGF0ZU1lc2hDb2xvcigpO1xuICAgIHRoaXMudXBkYXRlTWVzaFBvc2l0aW9uKCk7XG5cbiAgICAvLyBET00gc3R1ZmZcbiAgICB0aGlzLnVwZGF0ZURPTUNvbG9yKCk7XG4gICAgdGhpcy51cGRhdGVET01Qb3NpdGlvbigpO1xuICB9XG5cbiAgY3JlYXRlTWVzaCgpIHtcbiAgICAvLyBnZW9tZXRyeVxuICAgIHRoaXMuX2dlb21ldHJ5ID0gbmV3IFRIUkVFLkdlb21ldHJ5KCk7XG4gICAgdGhpcy5fZ2VvbWV0cnkudmVydGljZXMucHVzaCh0aGlzLl9oYW5kbGVzWzBdLndvcmxkUG9zaXRpb24pO1xuICAgIHRoaXMuX2dlb21ldHJ5LnZlcnRpY2VzLnB1c2godGhpcy5faGFuZGxlc1sxXS53b3JsZFBvc2l0aW9uKTtcblxuICAgIC8vIG1hdGVyaWFsXG4gICAgdGhpcy5fbWF0ZXJpYWwgPSBuZXcgVEhSRUUuTGluZUJhc2ljTWF0ZXJpYWwoKTtcbiAgICB0aGlzLnVwZGF0ZU1lc2hDb2xvcigpO1xuXG4gICAgLy8gbWVzaFxuICAgIHRoaXMuX21lc2ggPSBuZXcgVEhSRUUuTGluZSh0aGlzLl9nZW9tZXRyeSwgdGhpcy5fbWF0ZXJpYWwpO1xuICAgIHRoaXMuX21lc2gudmlzaWJsZSA9IHRydWU7XG5cbiAgICAvLyBhZGQgaXQhXG4gICAgdGhpcy5hZGQodGhpcy5fbWVzaCk7XG4gIH1cblxuICB1cGRhdGVNZXNoQ29sb3IoKSB7XG4gICAgaWYgKHRoaXMuX21hdGVyaWFsKSB7XG4gICAgICB0aGlzLl9tYXRlcmlhbC5jb2xvci5zZXQodGhpcy5fY29sb3IpO1xuICAgIH1cbiAgfVxuXG4gIHVwZGF0ZU1lc2hQb3NpdGlvbigpIHtcbiAgICBpZiAodGhpcy5fZ2VvbWV0cnkpIHtcbiAgICAgIHRoaXMuX2dlb21ldHJ5LnZlcnRpY2VzTmVlZFVwZGF0ZSA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgY3JlYXRlRE9NKCkge1xuICAgIC8vIGFkZCBsaW5lIVxuICAgIHRoaXMuX2xpbmUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB0aGlzLl9saW5lLnNldEF0dHJpYnV0ZSgnaWQnLCB0aGlzLnV1aWQpO1xuICAgIHRoaXMuX2xpbmUuc2V0QXR0cmlidXRlKCdjbGFzcycsICdBTUkgV2lkZ2V0IFJ1bGVyJyk7XG4gICAgdGhpcy5fbGluZS5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgdGhpcy5fbGluZS5zdHlsZS50cmFuc2Zvcm1PcmlnaW4gPSAnMCAxMDAlJztcbiAgICB0aGlzLl9saW5lLnN0eWxlLm1hcmdpblRvcCA9ICctMXB4JztcbiAgICB0aGlzLl9saW5lLnN0eWxlLmhlaWdodCA9ICcycHgnO1xuICAgIHRoaXMuX2xpbmUuc3R5bGUud2lkdGggPSAnM3B4JztcbiAgICB0aGlzLl9jb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5fbGluZSk7XG5cbiAgICAvLyBhZGQgZGlzdGFuY2UhXG4gICAgdGhpcy5fZGlzdGFuY2UgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB0aGlzLl9kaXN0YW5jZS5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgJ3dpZGdldHMgaGFuZGxlIGRpc3RhbmNlJyk7XG4gICAgdGhpcy5fZGlzdGFuY2Uuc3R5bGUuYm9yZGVyID0gJzJweCBzb2xpZCc7XG4gICAgdGhpcy5fZGlzdGFuY2Uuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gJyNGOUY5RjknO1xuICAgIC8vIHRoaXMuX2Rpc3RhbmNlLnN0eWxlLm9wYWNpdHkgPSAnMC41JztcbiAgICB0aGlzLl9kaXN0YW5jZS5zdHlsZS5jb2xvciA9ICcjMzUzNTM1JztcbiAgICB0aGlzLl9kaXN0YW5jZS5zdHlsZS5wYWRkaW5nID0gJzRweCc7XG4gICAgdGhpcy5fZGlzdGFuY2Uuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgIHRoaXMuX2Rpc3RhbmNlLnN0eWxlLnRyYW5zZm9ybU9yaWdpbiA9ICcwIDEwMCUnO1xuICAgIHRoaXMuX2Rpc3RhbmNlLmlubmVySFRNTCA9ICdIZWxsbywgd29ybGQhJztcbiAgICB0aGlzLl9jb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5fZGlzdGFuY2UpO1xuXG4gICAgdGhpcy51cGRhdGVET01Db2xvcigpO1xuICB9XG5cbiAgdXBkYXRlRE9NUG9zaXRpb24oKSB7XG4gICAgLy8gdXBkYXRlIHJ1bGVycyBsaW5lcyBhbmQgdGV4dCFcbiAgICBsZXQgeDEgPSB0aGlzLl9oYW5kbGVzWzBdLnNjcmVlblBvc2l0aW9uLng7XG4gICAgbGV0IHkxID0gdGhpcy5faGFuZGxlc1swXS5zY3JlZW5Qb3NpdGlvbi55O1xuICAgIGxldCB4MiA9IHRoaXMuX2hhbmRsZXNbMV0uc2NyZWVuUG9zaXRpb24ueDtcbiAgICBsZXQgeTIgPSB0aGlzLl9oYW5kbGVzWzFdLnNjcmVlblBvc2l0aW9uLnk7XG5cbiAgICAvL2xldCB4MCA9IHgxICsgKHgyIC0geDEpLzI7XG4gICAgLy9sZXQgeTAgPSB5MSArICh5MiAtIHkxKS8yO1xuICAgIGxldCB4MCA9IHgyO1xuICAgIGxldCB5MCA9IHkyO1xuXG4gICAgaWYgKHkxID49IHkyKSB7XG4gICAgICB5MCA9IHkyIC0gMzA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHkwID0geTIgKyAzMDtcbiAgICB9XG5cbiAgICBsZXQgbGVuZ3RoID0gTWF0aC5zcXJ0KCh4MS14MikqKHgxLXgyKSArICh5MS15MikqKHkxLXkyKSk7XG4gICAgbGV0IGFuZ2xlID0gTWF0aC5hdGFuMih5MiAtIHkxLCB4MiAtIHgxKSAqIDE4MCAvIE1hdGguUEk7XG5cbiAgICBsZXQgcG9zWSA9IHkxIC0gdGhpcy5fY29udGFpbmVyLm9mZnNldEhlaWdodDtcblxuICAgIC8vIHVwZGF0ZSBsaW5lXG4gICAgbGV0IHRyYW5zZm9ybSA9IGB0cmFuc2xhdGUzRCgke3gxfXB4LCR7cG9zWX1weCwgMClgO1xuICAgIHRyYW5zZm9ybSArPSBgIHJvdGF0ZSgke2FuZ2xlfWRlZylgO1xuXG4gICAgdGhpcy5fbGluZS5zdHlsZS50cmFuc2Zvcm0gPSB0cmFuc2Zvcm07XG4gICAgdGhpcy5fbGluZS5zdHlsZS53aWR0aCA9IGxlbmd0aDtcblxuICAgIC8vIHVwZGF0ZSBkaXN0YW5jZVxuICAgIGxldCB3MCA9IHRoaXMuX2hhbmRsZXNbMF0ud29ybGRQb3NpdGlvbjtcbiAgICBsZXQgdzEgPSB0aGlzLl9oYW5kbGVzWzFdLndvcmxkUG9zaXRpb247XG5cbiAgICB0aGlzLl9kaXN0YW5jZS5pbm5lckhUTUwgPVxuICAgICAgYCR7XG4gICAgICAgIE1hdGguc3FydChcbiAgICAgICAgICAodzAueC13MS54KSoodzAueC13MS54KSArXG4gICAgICAgICAgKHcwLnktdzEueSkqKHcwLnktdzEueSkgK1xuICAgICAgICAgICh3MC56LXcxLnopKih3MC56LXcxLnopXG4gICAgICAgICkudG9GaXhlZCgyKX0gbW1gO1xuICAgIGxldCBwb3NZMCA9XG4gICAgICB5MCAtIHRoaXMuX2NvbnRhaW5lci5vZmZzZXRIZWlnaHQgLSB0aGlzLl9kaXN0YW5jZS5vZmZzZXRIZWlnaHQvMjtcbiAgICB4MCAtPSB0aGlzLl9kaXN0YW5jZS5vZmZzZXRXaWR0aC8yO1xuXG4gICAgbGV0IHRyYW5zZm9ybTIgPVxuICAgICAgYHRyYW5zbGF0ZTNEKCR7TWF0aC5yb3VuZCh4MCl9cHgsJHtNYXRoLnJvdW5kKHBvc1kwKX1weCwgMClgO1xuICAgIHRoaXMuX2Rpc3RhbmNlLnN0eWxlLnRyYW5zZm9ybSA9IHRyYW5zZm9ybTI7XG4gIH1cblxuICB1cGRhdGVET01Db2xvcigpIHtcbiAgICB0aGlzLl9saW5lLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IGAke3RoaXMuX2NvbG9yfWA7XG4gICAgdGhpcy5fZGlzdGFuY2Uuc3R5bGUuYm9yZGVyQ29sb3IgPSBgJHt0aGlzLl9jb2xvcn1gO1xuICB9XG5cbiAgZnJlZSgpIHtcbiAgICB0aGlzLl9jb250YWluZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V3aGVlbCcsIHRoaXMub25Nb3ZlKTtcbiAgICB0aGlzLl9jb250YWluZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcignRE9NTW91c2VTY3JvbGwnLCB0aGlzLm9uTW92ZSk7XG5cbiAgICB0aGlzLl9oYW5kbGVzLmZvckVhY2goKGgpID0+IHtcbiAgICAgIGguZnJlZSgpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5faGFuZGxlcyA9IFtdO1xuXG4gICAgdGhpcy5fY29udGFpbmVyLnJlbW92ZUNoaWxkKHRoaXMuX2xpbmUpO1xuICAgIHRoaXMuX2NvbnRhaW5lci5yZW1vdmVDaGlsZCh0aGlzLl9kaXN0YW5jZSk7XG5cbiAgICB0aGlzLnJlbW92ZSh0aGlzLl9tZXNoKTtcblxuICAgIHN1cGVyLmZyZWUoKTtcbiAgfVxuXG4gIGdldCB3b3JsZFBvc2l0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl93b3JsZFBvc2l0aW9uO1xuICB9XG5cbiAgc2V0IHdvcmxkUG9zaXRpb24od29ybGRQb3NpdGlvbikge1xuICAgIHRoaXMuX3dvcmxkUG9zaXRpb24gPSB3b3JsZFBvc2l0aW9uO1xuICAgIHRoaXMuX2hhbmRsZXNbMF0ud29ybGRQb3NpdGlvbiA9IHRoaXMuX3dvcmxkUG9zaXRpb247XG4gICAgdGhpcy5faGFuZGxlc1sxXS53b3JsZFBvc2l0aW9uID0gdGhpcy5fd29ybGRQb3NpdGlvbjtcblxuICAgIHRoaXMudXBkYXRlKCk7XG4gIH1cblxufVxuIiwiXG5pbXBvcnQgV2lkZ2V0c0Jhc2UgZnJvbSAnLi4vd2lkZ2V0cy93aWRnZXRzLmJhc2UnO1xuaW1wb3J0IEdlb21ldHJpZXNWb3hlbCBmcm9tICcuLi9nZW9tZXRyaWVzL2dlb21ldHJpZXMudm94ZWwnO1xuaW1wb3J0IE1vZGVsc1N0YWNrIGZyb20gJy4uL21vZGVscy9tb2RlbHMuc3RhY2snO1xuaW1wb3J0IE1vZGVsc1ZveGVsIGZyb20gJy4uL21vZGVscy9tb2RlbHMudm94ZWwnO1xuaW1wb3J0IENvcmVJbnRlcnNlY3Rpb25zIGZyb20gJy4uL2NvcmUvY29yZS5pbnRlcnNlY3Rpb25zJztcblxuLyoqXG4gKiBAbW9kdWxlIHdpZGdldHMvdm94ZWxQcm9iZVxuICovXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFdpZGdldHNWb3hlbFByb2JlIGV4dGVuZHMgV2lkZ2V0c0Jhc2Uge1xuICBjb25zdHJ1Y3RvcihzdGFjaywgdGFyZ2V0TWVzaCwgY29udHJvbHMsIGNhbWVyYSwgY29udGFpbmVyKSB7XG4gICAgc3VwZXIoY29udGFpbmVyKTtcblxuICAgIHRoaXMuX3N0YWNrID0gc3RhY2s7XG5cbiAgICB0aGlzLl90YXJnZXRNZXNoID0gdGFyZ2V0TWVzaDtcbiAgICB0aGlzLl9jb250cm9scyA9IGNvbnRyb2xzO1xuICAgIHRoaXMuX2NhbWVyYSA9IGNhbWVyYTtcblxuICAgIC8vIGlmIG5vIHRhcmdldCBtZXNoLCB1c2UgcGxhbmUgZm9yIEZSRUUgZHJhZ2dpbmcuXG4gICAgdGhpcy5fcGxhbmUgPSB7XG4gICAgICAgIHBvc2l0aW9uOiBuZXcgVEhSRUUuVmVjdG9yMygpLFxuICAgICAgICBkaXJlY3Rpb246IG5ldyBUSFJFRS5WZWN0b3IzKCksXG4gICAgfTtcblxuICAgIHRoaXMuX29mZnNldCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgdGhpcy5fcmF5Y2FzdGVyID0gbmV3IFRIUkVFLlJheWNhc3RlcigpO1xuXG4gICAgdGhpcy5fdHJhY2tpbmcgPSBmYWxzZTtcblxuICAgIHRoaXMuX21vdXNlID0gbmV3IFRIUkVFLlZlY3RvcjIoKTtcbiAgICB0aGlzLl9sYXN0RXZlbnQgPSBudWxsO1xuXG4gICAgLy8gd29ybGQgKExQUykgcG9zaXRpb24gb2YgdGhlIGNlbnRlclxuICAgIHRoaXMuX3dvcmxkUG9zaXRpb24gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gICAgLy8gc2NyZWVuIHBvc2l0aW9uIG9mIHRoZSBjZW50ZXJcbiAgICB0aGlzLl9zY3JlZW5Qb3NpdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IyKCk7XG5cbiAgICAvLyBtZXNoIHN0dWZmXG4gICAgdGhpcy5fbWF0ZXJpYWwgPSBudWxsO1xuICAgIHRoaXMuX2dlb21ldHJ5ID0gbnVsbDtcbiAgICB0aGlzLl9tZXNoID0gbnVsbDtcbiAgICB0aGlzLl9tZXNoRGlzcGxheWVkID0gdHJ1ZTtcbiAgICB0aGlzLl9tZXNoSG92ZXJlZCA9IGZhbHNlO1xuICAgIHRoaXMuX21lc2hTdHlsZSA9ICdzcGhlcmUnOyAvLyBjdWJlLCBldGMuXG5cbiAgICAvLyBkb20gc3R1ZmZcbiAgICB0aGlzLl9kb20gPSBudWxsO1xuICAgIHRoaXMuX2RvbURpc3BsYXllZCA9IHRydWU7XG4gICAgdGhpcy5fZG9tSG92ZXJlZCA9IGZhbHNlO1xuICAgIHRoaXMuX2RvbVN0eWxlID0gJ2NpcmNsZSc7IC8vIHNxdWFyZSwgdHJpYW5nbGVcblxuICAgIGlmICh0aGlzLl90YXJnZXRNZXNoICE9PSBudWxsKSB7XG4gICAgICB0aGlzLl93b3JsZFBvc2l0aW9uLmNvcHkodGhpcy5fdGFyZ2V0TWVzaC5wb3NpdGlvbik7XG4gICAgfVxuXG4gICAgdGhpcy5fc2NyZWVuUG9zaXRpb24gPVxuICAgICAgdGhpcy53b3JsZFRvU2NyZWVuKHRoaXMuX3dvcmxkUG9zaXRpb24sIHRoaXMuX2NhbWVyYSwgdGhpcy5fY29udGFpbmVyKTtcblxuICAgIC8vIGNyZWF0ZSBoYW5kbGVcbiAgICB0aGlzLmNyZWF0ZSgpO1xuICAgIHRoaXMuaW5pdE9mZnNldHMoKTtcblxuICAgIC8vIGV2ZW50IGxpc3RlbmVyc1xuICAgIHRoaXMub25Nb3ZlID0gdGhpcy5vbk1vdmUuYmluZCh0aGlzKTtcbiAgICB0aGlzLm9uSG92ZXIgPSB0aGlzLm9uSG92ZXIuYmluZCh0aGlzKTtcbiAgICB0aGlzLm9uRW5kQ29udHJvbCA9IHRoaXMub25FbmRDb250cm9sLmJpbmQodGhpcyk7XG4gICAgdGhpcy5hZGRFdmVudExpc3RlbmVycygpO1xuICB9XG5cbiAgYWRkRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgdGhpcy5fZG9tLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZW50ZXInLCB0aGlzLm9uSG92ZXIpO1xuICAgIHRoaXMuX2RvbS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgdGhpcy5vbkhvdmVyKTtcblxuICAgIHRoaXMuX2NvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXdoZWVsJywgdGhpcy5vbk1vdmUpO1xuICAgIHRoaXMuX2NvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKCdET01Nb3VzZVNjcm9sbCcsIHRoaXMub25Nb3ZlKTtcblxuICAgIHRoaXMuX2NvbnRyb2xzLmFkZEV2ZW50TGlzdGVuZXIoJ2VuZCcsIHRoaXMub25FbmRDb250cm9sKTtcbiAgfVxuXG4gIHJlbW92ZUV2ZW50TGlzdGVuZXJzKCkge1xuICAgIHRoaXMuX2RvbS5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWVudGVyJywgdGhpcy5vbkhvdmVyKTtcbiAgICB0aGlzLl9kb20ucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIHRoaXMub25Ib3Zlcik7XG5cbiAgICB0aGlzLl9jb250YWluZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V3aGVlbCcsIHRoaXMub25Nb3ZlKTtcbiAgICB0aGlzLl9jb250YWluZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcignRE9NTW91c2VTY3JvbGwnLCB0aGlzLm9uTW92ZSk7XG5cbiAgICB0aGlzLl9jb250cm9scy5yZW1vdmVFdmVudExpc3RlbmVyKCdlbmQnLCB0aGlzLm9uRW5kQ29udHJvbCk7XG4gIH1cblxuICBvblN0YXJ0KGV2dCkge1xuICAgIHRoaXMuX2xhc3RFdmVudCA9IGV2dDtcbiAgICBldnQucHJldmVudERlZmF1bHQoKTtcblxuICAgIGNvbnN0IG9mZnNldHMgPSB0aGlzLmdldE1vdXNlT2Zmc2V0cyhldnQsIHRoaXMuX2NvbnRhaW5lcik7XG4gICAgdGhpcy5fbW91c2Uuc2V0KG9mZnNldHMueCwgb2Zmc2V0cy55KTtcblxuICAgIC8vIHVwZGF0ZSByYXljYXN0ZXJcbiAgICB0aGlzLl9yYXljYXN0ZXIuc2V0RnJvbUNhbWVyYSh0aGlzLl9tb3VzZSwgdGhpcy5fY2FtZXJhKTtcbiAgICB0aGlzLl9yYXljYXN0ZXIucmF5LnBvc2l0aW9uID0gdGhpcy5fcmF5Y2FzdGVyLnJheS5vcmlnaW47XG5cbiAgICBpZiAodGhpcy5faG92ZXJlZCkge1xuICAgICAgdGhpcy5fYWN0aXZlID0gdHJ1ZTtcbiAgICAgIHRoaXMuX2NvbnRyb2xzLmVuYWJsZWQgPSBmYWxzZTtcblxuICAgICAgaWYgKHRoaXMuX3RhcmdldE1lc2gpIHtcbiAgICAgICAgbGV0IGludGVyc2VjdHNUYXJnZXQgPVxuICAgICAgICAgIHRoaXMuX3JheWNhc3Rlci5pbnRlcnNlY3RPYmplY3QodGhpcy5fdGFyZ2V0TWVzaCk7XG4gICAgICAgIGlmIChpbnRlcnNlY3RzVGFyZ2V0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICB0aGlzLl9vZmZzZXQuY29weShpbnRlcnNlY3RzVGFyZ2V0WzBdLnBvaW50KS5zdWIodGhpcy5fd29ybGRQb3NpdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3BsYW5lLnBvc2l0aW9uLmNvcHkodGhpcy5fd29ybGRQb3NpdGlvbik7XG4gICAgICAgIHRoaXMuX3BsYW5lLmRpcmVjdGlvbi5jb3B5KHRoaXMuX2NhbWVyYS5nZXRXb3JsZERpcmVjdGlvbigpKTtcbiAgICAgICAgbGV0IGludGVyc2VjdGlvbiA9XG4gICAgICAgICAgQ29yZUludGVyc2VjdGlvbnMucmF5UGxhbmUodGhpcy5fcmF5Y2FzdGVyLnJheSwgdGhpcy5fcGxhbmUpO1xuICAgICAgICBpZiAoaW50ZXJzZWN0aW9uICE9PSBudWxsKSB7XG4gICAgICAgICAgdGhpcy5fb2Zmc2V0LmNvcHkoaW50ZXJzZWN0aW9uKS5zdWIodGhpcy5fcGxhbmUucG9zaXRpb24pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgfVxuICB9XG5cbiAgb25FbmQoZXZ0KSB7XG4gICAgdGhpcy5fbGFzdEV2ZW50ID0gZXZ0O1xuICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgLy8gc3RheSBhY3RpdmUgYW5kIGtlZXAgY29udHJvbHMgZGlzYWJsZWRcbiAgICBpZiAodGhpcy5fdHJhY2tpbmcgPT09IHRydWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyB1bnNlbGVjdCBpZiBnbyB1cCB3aXRob3V0IG1vdmluZ1xuICAgIGlmICghdGhpcy5fZHJhZ2dlZCAmJiB0aGlzLl9hY3RpdmUpIHtcbiAgICAgIC8vIGNoYW5nZSBzdGF0ZSBpZiB3YXMgbm90IGRyYWdnaW5nXG4gICAgICB0aGlzLl9zZWxlY3RlZCA9ICF0aGlzLl9zZWxlY3RlZDtcbiAgICB9XG5cbiAgICB0aGlzLl9hY3RpdmUgPSBmYWxzZTtcbiAgICB0aGlzLl9kcmFnZ2VkID0gZmFsc2U7XG4gICAgdGhpcy5fY29udHJvbHMuZW5hYmxlZCA9IHRydWU7XG5cbiAgICB0aGlzLnVwZGF0ZSgpO1xuICB9XG5cbiAgb25FbmRDb250cm9sKCkge1xuICAgIGlmICghdGhpcy5fbGFzdEV2ZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICB0aGlzLm9uTW92ZSh0aGlzLl9sYXN0RXZlbnQpO1xuICAgIH0pO1xuICB9XG5cbiAgb25Nb3ZlKGV2dCkge1xuICAgIHRoaXMuX2xhc3RFdmVudCA9IGV2dDtcbiAgICBldnQucHJldmVudERlZmF1bHQoKTtcblxuICAgIGNvbnN0IG9mZnNldHMgPSB0aGlzLmdldE1vdXNlT2Zmc2V0cyhldnQsIHRoaXMuX2NvbnRhaW5lcik7XG4gICAgdGhpcy5fbW91c2Uuc2V0KG9mZnNldHMueCwgb2Zmc2V0cy55KTtcblxuICAgIC8vIHVwZGF0ZSByYXljYXN0ZXJcbiAgICAvLyBzZXQgcmF5LnBvc2l0aW9uIHRvIHNhdGlzZnkgQ29yZUludGVyc2VjdGlvbnM6OnJheVBsYW5lIEFQSVxuICAgIHRoaXMuX3JheWNhc3Rlci5zZXRGcm9tQ2FtZXJhKHRoaXMuX21vdXNlLCB0aGlzLl9jYW1lcmEpO1xuICAgIHRoaXMuX3JheWNhc3Rlci5yYXkucG9zaXRpb24gPSB0aGlzLl9yYXljYXN0ZXIucmF5Lm9yaWdpbjtcblxuICAgIGlmICh0aGlzLl9hY3RpdmUpIHtcbiAgICAgIHRoaXMuX2RyYWdnZWQgPSB0cnVlO1xuXG4gICAgICBpZiAodGhpcy5fdGFyZ2V0TWVzaCAhPT0gbnVsbCkge1xuICAgICAgICBsZXQgaW50ZXJzZWN0c1RhcmdldCA9XG4gICAgICAgICAgdGhpcy5fcmF5Y2FzdGVyLmludGVyc2VjdE9iamVjdCh0aGlzLl90YXJnZXRNZXNoKTtcbiAgICAgICAgaWYgKGludGVyc2VjdHNUYXJnZXQubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHRoaXMuX3dvcmxkUG9zaXRpb24uY29weShpbnRlcnNlY3RzVGFyZ2V0WzBdLnBvaW50LnN1Yih0aGlzLl9vZmZzZXQpKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRoaXMuX3BsYW5lLmRpcmVjdGlvbi5sZW5ndGgoKSA9PT0gMCkge1xuICAgICAgICAgIC8vIGZyZWUgbW9kZSF0aGlzLl90YXJnZXRNZXNoXG4gICAgICAgICAgdGhpcy5fcGxhbmUucG9zaXRpb24uY29weSh0aGlzLl93b3JsZFBvc2l0aW9uKTtcbiAgICAgICAgICB0aGlzLl9wbGFuZS5kaXJlY3Rpb24uY29weSh0aGlzLl9jYW1lcmEuZ2V0V29ybGREaXJlY3Rpb24oKSk7XG4gICAgICAgICB9XG5cbiAgICAgICAgbGV0IGludGVyc2VjdGlvbiA9XG4gICAgICAgICAgQ29yZUludGVyc2VjdGlvbnMucmF5UGxhbmUodGhpcy5fcmF5Y2FzdGVyLnJheSwgdGhpcy5fcGxhbmUpO1xuICAgICAgICBpZiAoaW50ZXJzZWN0aW9uICE9PSBudWxsKSB7XG4gICAgICAgICAgdGhpcy5fd29ybGRQb3NpdGlvbi5jb3B5KGludGVyc2VjdGlvbi5zdWIodGhpcy5fb2Zmc2V0KSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5vbkhvdmVyKG51bGwpO1xuICAgIH1cblxuICAgIHRoaXMudXBkYXRlKCk7XG4gIH1cblxuICBvbkhvdmVyKGV2dCkge1xuICAgIGlmIChldnQpIHtcbiAgICAgIHRoaXMuX2xhc3RFdmVudCA9IGV2dDtcbiAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgdGhpcy5ob3ZlckRvbShldnQpO1xuICAgIH1cblxuICAgIHRoaXMuaG92ZXJNZXNoKCk7XG5cbiAgICB0aGlzLl9ob3ZlcmVkID0gdGhpcy5fbWVzaEhvdmVyZWQgfHwgdGhpcy5fZG9tSG92ZXJlZDtcbiAgICB0aGlzLl9jb250YWluZXIuc3R5bGUuY3Vyc29yID0gdGhpcy5faG92ZXJlZCA/ICdwb2ludGVyJyA6ICdkZWZhdWx0JztcbiAgfVxuXG4gIGhvdmVyTWVzaCgpIHtcbiAgICAvLyBjaGVjayByYXljYXN0IGludGVyc2VjdGlvbiwgZG8gd2Ugd2FudCB0byBob3ZlciBvbiBtZXNoIG9yIGp1c3QgY3NzP1xuICAgIGxldCBpbnRlcnNlY3RzSGFuZGxlID0gdGhpcy5fcmF5Y2FzdGVyLmludGVyc2VjdE9iamVjdCh0aGlzLl9tZXNoKTtcbiAgICB0aGlzLl9tZXNoSG92ZXJlZCA9IChpbnRlcnNlY3RzSGFuZGxlLmxlbmd0aCA+IDApO1xuICB9XG5cbiAgaG92ZXJEb20oZXZ0KSB7XG4gICAgdGhpcy5fZG9tSG92ZXJlZCA9IChldnQudHlwZSA9PT0gJ21vdXNlZW50ZXInKTtcbiAgfVxuXG4gIHdvcmxkVG9TY3JlZW4od29ybGRDb29yZGluYXRlLCBjYW1lcmEsIGNhbnZhcykge1xuICAgIGxldCBzY3JlZW5Db29yZGluYXRlcyA9IHdvcmxkQ29vcmRpbmF0ZS5jbG9uZSgpO1xuICAgIHNjcmVlbkNvb3JkaW5hdGVzLnByb2plY3QoY2FtZXJhKTtcblxuICAgIHNjcmVlbkNvb3JkaW5hdGVzLnggPVxuICAgICAgTWF0aC5yb3VuZCgoc2NyZWVuQ29vcmRpbmF0ZXMueCArIDEpICogY2FudmFzLm9mZnNldFdpZHRoIC8gMik7XG4gICAgc2NyZWVuQ29vcmRpbmF0ZXMueSA9XG4gICAgICBNYXRoLnJvdW5kKCgtc2NyZWVuQ29vcmRpbmF0ZXMueSArIDEpICogY2FudmFzLm9mZnNldEhlaWdodCAvIDIpO1xuICAgIHNjcmVlbkNvb3JkaW5hdGVzLnogPSAwO1xuXG4gICAgcmV0dXJuIHNjcmVlbkNvb3JkaW5hdGVzO1xuICB9XG5cbiAgY3JlYXRlKCkge1xuICAgIHRoaXMuY3JlYXRlVm94ZWwoKTtcbiAgICB0aGlzLmNyZWF0ZU1lc2goKTtcbiAgICB0aGlzLmNyZWF0ZURPTSgpO1xuICB9XG5cbiAgY3JlYXRlVm94ZWwoKSB7XG4gICAgdGhpcy5fdm94ZWwgPSBuZXcgTW9kZWxzVm94ZWwoKTtcbiAgICB0aGlzLl92b3hlbC5pZCA9IHRoaXMuaWQ7XG4gICAgdGhpcy5fdm94ZWwud29ybGRDb29yZGluYXRlcyA9IHRoaXMuX3dvcmxkQ29vcmRpbmF0ZXM7XG4gIH1cblxuICBjcmVhdGVNZXNoKCkge1xuICAgIGNvbnN0IGRhdGFDb29yZGluYXRlcyA9IE1vZGVsc1N0YWNrLndvcmxkVG9EYXRhKFxuICAgICAgdGhpcy5fc3RhY2ssXG4gICAgICB0aGlzLl93b3JsZFBvc2l0aW9uKTtcblxuICAgIHRoaXMuX2dlb21ldHJ5ID0gbmV3IEdlb21ldHJpZXNWb3hlbChkYXRhQ29vcmRpbmF0ZXMpO1xuICAgIHRoaXMuX21hdGVyaWFsID0gbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKHtcbiAgICAgICAgd2lyZWZyYW1lOiB0cnVlLFxuICAgICAgICB3aXJlZnJhbWVMaW5ld2lkdGg6IDEsXG4gICAgICB9KTtcbiAgICB0aGlzLl9tZXNoID0gbmV3IFRIUkVFLk1lc2godGhpcy5fZ2VvbWV0cnksIHRoaXMuX21hdGVyaWFsKTtcbiAgICB0aGlzLl9tZXNoLmFwcGx5TWF0cml4KHRoaXMuX3N0YWNrLmlqazJMUFMpO1xuICAgIHRoaXMuX21lc2gudmlzaWJsZSA9IHRydWU7XG5cbiAgICB0aGlzLnVwZGF0ZU1lc2hDb2xvcigpO1xuXG4gICAgdGhpcy5hZGQodGhpcy5fbWVzaCk7XG4gIH1cblxuICB1cGRhdGVNZXNoQ29sb3IoKSB7XG4gICAgaWYgKHRoaXMuX21hdGVyaWFsKSB7XG4gICAgICB0aGlzLl9tYXRlcmlhbC5jb2xvci5zZXQodGhpcy5fY29sb3IpO1xuICAgIH1cbiAgfVxuXG4gIGNyZWF0ZURPTSgpIHtcbiAgICAvLyBkb21cbiAgICB0aGlzLl9kb20gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB0aGlzLl9kb20uc2V0QXR0cmlidXRlKCdpZCcsIHRoaXMudXVpZCk7XG4gICAgdGhpcy5fZG9tLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAnQU1JIFdpZGdldCBWb3hlbFByb2JlJyk7XG4gICAgdGhpcy5fZG9tLnN0eWxlLmJvcmRlciA9ICcycHggc29saWQgIzAwMCc7XG4gICAgdGhpcy5fZG9tLnN0eWxlLmJhY2tncm91bmRDb2xvciA9ICdyZ2IoMjQ5LCAyNDksIDI0OSknO1xuICAgIHRoaXMuX2RvbS5zdHlsZS5jb2xvciA9ICcjMjEyMTIxJztcbiAgICB0aGlzLl9kb20uc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgIHRoaXMuX2RvbS5zdHlsZS50cmFuc2Zvcm1PcmlnaW4gPSAnMHB4IDEwMCUgMHB4JztcblxuICAgIC8vIG1lYXN1cmVuZW50c1xuICAgIGxldCBtZWFzdXJlbWVudHNDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAvLyBMUFNcbiAgICBsZXQgbHBzQ29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgbHBzQ29udGFpbmVyLnNldEF0dHJpYnV0ZSgnaWQnLCAnbHBzUG9zaXRpb24nKTtcbiAgICBtZWFzdXJlbWVudHNDb250YWluZXIuYXBwZW5kQ2hpbGQobHBzQ29udGFpbmVyKTtcbiAgICAvLyBJSktcbiAgICBsZXQgaWprQ29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgaWprQ29udGFpbmVyLnNldEF0dHJpYnV0ZSgnaWQnLCAnaWprUG9zaXRpb24nKTtcbiAgICBtZWFzdXJlbWVudHNDb250YWluZXIuYXBwZW5kQ2hpbGQoaWprQ29udGFpbmVyKTtcbiAgICAvLyBWYWx1ZVxuICAgIGxldCB2YWx1ZUNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHZhbHVlQ29udGFpbmVyLnNldEF0dHJpYnV0ZSgnaWQnLCAndmFsdWUnKTtcbiAgICBtZWFzdXJlbWVudHNDb250YWluZXIuYXBwZW5kQ2hpbGQodmFsdWVDb250YWluZXIpO1xuXG4gICAgdGhpcy51cGRhdGVET01Db2xvcigpO1xuICAgIHRoaXMuX2RvbS5hcHBlbmRDaGlsZChtZWFzdXJlbWVudHNDb250YWluZXIpO1xuXG4gICAgLy8gYWRkIGl0IVxuICAgIHRoaXMuX2NvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLl9kb20pO1xuICB9XG5cbiAgdXBkYXRlRE9NQ29udGVudCgpIHtcbiAgICBjb25zdCByYXNDb250YWluZXIgPSB0aGlzLl9kb20ucXVlcnlTZWxlY3RvcignI2xwc1Bvc2l0aW9uJyk7XG4gICAgcmFzQ29udGFpbmVyLmlubmVySFRNTCA9IGBMUFM6IFxuICAgICAgJHt0aGlzLl92b3hlbC53b3JsZENvb3JkaW5hdGVzLngudG9GaXhlZCgyKX0gOlxuICAgICAgJHt0aGlzLl92b3hlbC53b3JsZENvb3JkaW5hdGVzLnkudG9GaXhlZCgyKX0gOlxuICAgICAgJHt0aGlzLl92b3hlbC53b3JsZENvb3JkaW5hdGVzLnoudG9GaXhlZCgyKX1gO1xuXG4gICAgY29uc3QgaWprQ29udGFpbmVyID0gdGhpcy5fZG9tLnF1ZXJ5U2VsZWN0b3IoJyNpamtQb3NpdGlvbicpO1xuICAgIGlqa0NvbnRhaW5lci5pbm5lckhUTUwgPSBgSUpLOiBcbiAgICAgICR7dGhpcy5fdm94ZWwuZGF0YUNvb3JkaW5hdGVzLnh9IDpcbiAgICAgICR7dGhpcy5fdm94ZWwuZGF0YUNvb3JkaW5hdGVzLnl9IDpcbiAgICAgICR7dGhpcy5fdm94ZWwuZGF0YUNvb3JkaW5hdGVzLnp9YDtcblxuICAgIGNvbnN0IHZhbHVlQ29udGFpbmVyID0gdGhpcy5fZG9tLnF1ZXJ5U2VsZWN0b3IoJyN2YWx1ZScpO1xuICAgIHZhbHVlQ29udGFpbmVyLmlubmVySFRNTCA9IGBWYWx1ZTogJHt0aGlzLl92b3hlbC52YWx1ZX1gO1xuICB9XG5cbiAgdXBkYXRlKCkge1xuICAgIC8vIGdlbmVyYWwgdXBkYXRlXG4gICAgdGhpcy51cGRhdGVDb2xvcigpO1xuICAgIHRoaXMuX3NjcmVlblBvc2l0aW9uID1cbiAgICAgIHRoaXMud29ybGRUb1NjcmVlbih0aGlzLl93b3JsZFBvc2l0aW9uLCB0aGlzLl9jYW1lcmEsIHRoaXMuX2NvbnRhaW5lcik7XG5cbiAgICAvLyBzZXQgZGF0YSBjb29yZGluYXRlcyAmJiB2YWx1ZVxuICAgIHRoaXMudXBkYXRlVm94ZWwodGhpcy5fd29ybGRQb3NpdGlvbik7XG5cbiAgICAvLyB1cGRhdGUgbWVzaCBwb3NpdGlvblxuICAgIHRoaXMudXBkYXRlTWVzaENvbG9yKCk7XG4gICAgaWYgKHRoaXMuX21lc2ggJiYgdGhpcy5fbWVzaC5nZW9tZXRyeSkge1xuICAgICAgdGhpcy5fbWVzaC5nZW9tZXRyeS5sb2NhdGlvbiA9IHRoaXMuX3ZveGVsLmRhdGFDb29yZGluYXRlcztcbiAgICAgIHRoaXMuX21lc2gudXBkYXRlTWF0cml4KCk7XG4gICAgfVxuXG4gICAgLy8gdXBkYXRlIGRvbVxuICAgIHRoaXMudXBkYXRlRE9NQ29udGVudCgpO1xuICAgIHRoaXMudXBkYXRlRE9NQ29sb3IoKTtcbiAgICB0aGlzLnVwZGF0ZURPTVBvc2l0aW9uKCk7XG4gIH1cblxuXG4gIHVwZGF0ZVZveGVsKHdvcmxkQ29vcmRpbmF0ZXMpIHtcbiAgICAvLyB1cGRhdGUgd29ybGQgY29vcmRpbmF0ZXNcbiAgICB0aGlzLl92b3hlbC53b3JsZENvb3JkaW5hdGVzID0gd29ybGRDb29yZGluYXRlcztcblxuICAgIC8vIHVwZGF0ZSBkYXRhIGNvb3JkaW5hdGVzXG4gICAgdGhpcy5fdm94ZWwuZGF0YUNvb3JkaW5hdGVzID0gTW9kZWxzU3RhY2sud29ybGRUb0RhdGEoXG4gICAgICAgICAgICAgICAgICB0aGlzLl9zdGFjayxcbiAgICAgICAgICAgICAgICAgIHRoaXMuX3ZveGVsLndvcmxkQ29vcmRpbmF0ZXMpO1xuXG4gICAgLy8gdXBkYXRlIHZhbHVlXG4gICAgbGV0IHZhbHVlID0gTW9kZWxzU3RhY2sudmFsdWUoXG4gICAgICB0aGlzLl9zdGFjayxcbiAgICAgIHRoaXMuX3ZveGVsLmRhdGFDb29yZGluYXRlcyk7XG5cbiAgICB0aGlzLl92b3hlbC52YWx1ZSA9IE1vZGVsc1N0YWNrLnZhbHVlUmVzY2FsZVNsb3BlSW50ZXJjZXB0KFxuICAgICAgdmFsdWUsXG4gICAgICB0aGlzLl9zdGFjay5yZXNjYWxlU2xvcGUsXG4gICAgICB0aGlzLl9zdGFjay5yZXNjYWxlSW50ZXJjZXB0KTtcbiAgfVxuXG4gIHVwZGF0ZURPTVBvc2l0aW9uKCkge1xuICAgIGlmICh0aGlzLl9kb20pIHtcbiAgICAgIGxldCBwb3NZID0gdGhpcy5fc2NyZWVuUG9zaXRpb24ueSAtIHRoaXMuX2NvbnRhaW5lci5vZmZzZXRIZWlnaHQ7XG4gICAgICB0aGlzLl9kb20uc3R5bGUudHJhbnNmb3JtID1cbiAgICAgICAgYHRyYW5zbGF0ZTNEKCR7dGhpcy5fc2NyZWVuUG9zaXRpb24ueH1weCwgJHtwb3NZfXB4LCAwKWA7XG4gICAgfVxuICB9XG5cbiAgdXBkYXRlRE9NQ29sb3IoKSB7XG4gICAgdGhpcy5fZG9tLnN0eWxlLmJvcmRlckNvbG9yID0gYCR7dGhpcy5fY29sb3J9YDtcbiAgfVxuXG4gIGZyZWUoKSB7XG4gICAgdGhpcy5fY29udGFpbmVyLlxuICAgICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMub25Nb3VzZVVwSGFuZGxlciwgZmFsc2UpO1xuICAgIHRoaXMuX2NvbnRhaW5lci5cbiAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMub25Nb3VzZU1vdmVIYW5kbGVyLCBmYWxzZSk7XG5cbiAgICB0aGlzLl9jb250YWluZXIuXG4gICAgICByZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXdoZWVsJywgdGhpcy5vbk1vdXNlTW92ZUhhbmRsZXIsIGZhbHNlKTtcbiAgICB0aGlzLl9jb250YWluZXIuXG4gICAgICByZW1vdmVFdmVudExpc3RlbmVyKCdET01Nb3VzZVNjcm9sbCcsIHRoaXMub25Nb3VzZU1vdmVIYW5kbGVyLCBmYWxzZSk7XG5cbiAgICB0aGlzLl92b3hlbC5yZW1vdmVUZXN0KCk7XG4gICAgdGhpcy5yZW1vdmUodGhpcy5fdm94ZWwpO1xuICAgIHRoaXMuX3ZveGVsID0gbnVsbDtcblxuICAgIHN1cGVyLmZyZWUoKTtcbiAgfVxuXG4gIGhvdmVyVm94ZWwobW91c2VTY3JlZW5Db29yZGluYXRlcywgY3VycmVudERhdGFDb29yZGluYXRlcykge1xuICAgIC8vIHVwZGF0ZSBkaXN0YW5jZSBtb3VzZS90aGlzLl92b3hlbFxuICAgIGxldCBkeCA9XG4gICAgICBtb3VzZVNjcmVlbkNvb3JkaW5hdGVzLnNjcmVlblggLSB0aGlzLl92b3hlbC52b3hlbC5zY3JlZW5Db29yZGluYXRlcy54O1xuICAgIGxldCBkeSA9XG4gICAgICBtb3VzZVNjcmVlbkNvb3JkaW5hdGVzLnNjcmVlblkgLSB0aGlzLl92b3hlbC52b3hlbC5zY3JlZW5Db29yZGluYXRlcy55O1xuICAgIGxldCBkaXN0YW5jZSA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gICAgdGhpcy5fdm94ZWwuZGlzdGFuY2UgPSBkaXN0YW5jZTtcbiAgICBpZiAoZGlzdGFuY2UgPj0gMCAmJiBkaXN0YW5jZSA8IDEwKSB7XG4gICAgICB0aGlzLl9ob3ZlciA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2hvdmVyID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgc2V0IHdvcmxkUG9zaXRpb24od29ybGRQb3NpdGlvbikge1xuICAgIHRoaXMuX3dvcmxkUG9zaXRpb24uY29weSh3b3JsZFBvc2l0aW9uKTtcbiAgICB0aGlzLnVwZGF0ZSgpO1xuICB9XG5cbiAgc2V0IGRlZmF1bHRDb2xvcihkZWZhdWx0Q29sb3IpIHtcbiAgICB0aGlzLl9kZWZhdWx0Q29sb3IgPSBkZWZhdWx0Q29sb3I7XG4gICAgdGhpcy51cGRhdGUoKTtcbiAgfVxuXG4gIGdldCBkZWZhdWx0Q29sb3IoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RlZmF1bHRDb2xvcjtcbiAgfVxuXG4gIHNldCBhY3RpdmVDb2xvcihhY3RpdmVDb2xvcikge1xuICAgIHRoaXMuX2FjdGl2ZUNvbG9yID0gYWN0aXZlQ29sb3I7XG4gICAgdGhpcy51cGRhdGUoKTtcbiAgfVxuXG4gIGdldCBhY3RpdmVDb2xvcigpIHtcbiAgICByZXR1cm4gdGhpcy5fYWN0aXZlQ29sb3I7XG4gIH1cblxuICBzZXQgaG92ZXJDb2xvcihob3ZlckNvbG9yKSB7XG4gICAgdGhpcy5faG92ZXJDb2xvciA9IGhvdmVyQ29sb3I7XG4gICAgdGhpcy51cGRhdGUoKTtcbiAgfVxuXG4gIGdldCBob3ZlckNvbG9yKCkge1xuICAgIHJldHVybiB0aGlzLl9ob3ZlckNvbG9yO1xuICB9XG5cbiAgc2V0IHNlbGVjdGVkQ29sb3Ioc2VsZWN0ZWRDb2xvcikge1xuICAgIHRoaXMuX3NlbGVjdGVkQ29sb3IgPSBzZWxlY3RlZENvbG9yO1xuICAgIHRoaXMudXBkYXRlKCk7XG4gIH1cblxuICBnZXQgc2VsZWN0ZWRDb2xvcigpIHtcbiAgICByZXR1cm4gdGhpcy5fc2VsZWN0ZWRDb2xvcjtcbiAgfVxuXG4gIHNldCBzaG93Vm94ZWwoc2hvd1ZveGVsKSB7XG4gICAgdGhpcy5fc2hvd1ZveGVsID0gc2hvd1ZveGVsO1xuICAgIHRoaXMudXBkYXRlKCk7XG4gIH1cblxuICBnZXQgc2hvd1ZveGVsKCkge1xuICAgIHJldHVybiB0aGlzLl9zaG93Vm94ZWw7XG4gIH1cblxuICBzZXQgc2hvd0RvbVNWRyhzaG93RG9tU1ZHKSB7XG4gICAgdGhpcy5fc2hvd0RvbVNWRyA9IHNob3dEb21TVkc7XG4gICAgdGhpcy51cGRhdGUoKTtcbiAgfVxuXG4gIGdldCBzaG93RG9tU1ZHKCkge1xuICAgIHJldHVybiB0aGlzLl9zaG93RG9tU1ZHO1xuICB9XG5cbiAgc2V0IHNob3dEb21NZWFzdXJlbWVudHMoc2hvd0RvbU1lYXN1cmVtZW50cykge1xuICAgIHRoaXMuX3Nob3dEb21NZWFzdXJlbWVudHMgPSBzaG93RG9tTWVhc3VyZW1lbnRzO1xuICAgIHRoaXMudXBkYXRlKCk7XG4gIH1cblxuICBnZXQgc2hvd0RvbU1lYXN1cmVtZW50cygpIHtcbiAgICByZXR1cm4gdGhpcy5fc2hvd0RvbU1lYXN1cmVtZW50cztcbiAgfVxufVxuIl19
